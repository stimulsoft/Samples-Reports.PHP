/*
Stimulsoft.Reports.JS
Version: 2025.3.5
Build date: 2025.09.04
License: https://www.stimulsoft.com/en/licensing/reports
*/
export namespace Stimulsoft.System {
    class Activator {
        static createInstance(type: Type): any;
    }
}
export namespace Stimulsoft.System {
    class Attribute {
    }
}
export namespace Stimulsoft.ExternalLibrary.Blockly {
    let blocklyToolbox: string;
    let blocklyToolboxCurrentValue: string;
    let blocklyWorkspace: string;
    let blocklyBlocks: string;
}
export namespace Stimulsoft.System.Globalization {
    enum UnicodeCategory {
        UppercaseLetter = 0,
        LowercaseLetter = 1,
        TitlecaseLetter = 2,
        ModifierLetter = 3,
        OtherLetter = 4,
        NonSpacingMark = 5,
        SpacingCombiningMark = 6,
        EnclosingMark = 7,
        DecimalDigitNumber = 8,
        LetterNumber = 9,
        OtherNumber = 10,
        SpaceSeparator = 11,
        LineSeparator = 12,
        ParagraphSeparator = 13,
        Control = 14,
        Format = 15,
        Surrogate = 16,
        PrivateUse = 17,
        ConnectorPunctuation = 18,
        DashPunctuation = 19,
        OpenPunctuation = 20,
        ClosePunctuation = 21,
        InitialQuotePunctuation = 22,
        FinalQuotePunctuation = 23,
        OtherPunctuation = 24,
        MathSymbol = 25,
        CurrencySymbol = 26,
        ModifierSymbol = 27,
        OtherSymbol = 28,
        OtherNotAssigned = 29
    }
}
export namespace Stimulsoft.System {
    class Char {
        static isUpper(char: string, index?: number): boolean;
        static isLower(char: string, index?: number): boolean;
        static isLetter(char: string, index?: number): boolean;
        static isDigit(char: string | number, index?: number): boolean;
        static isLetterOrDigit(char: string, index?: number): boolean;
        static toLower(char: string): string;
        static toUpper(char: string): string;
        static isWhitespace(char: string, index?: number, allowNbsp?: boolean): boolean;
        private static checkLetter;
        static getUnicodeCategory(char: string, index?: number): number;
        static isControl(char: string, index?: number): boolean;
    }
}
export namespace Stimulsoft.System {
    class Chars {
        static getUnicodeCategory(char: number): number;
        private static _table_0;
        private static _table_9fc0;
        private static _table_d780;
        private static _table_fa40;
    }
}
export namespace Stimulsoft.System {
    class Convert {
        static changeType(value: any, type: Type): any;
        static changeType2(value: any, typeCode: TypeCode): any;
        static toDateTime(value: any): DateTime;
        static toString(value: any): string;
        static toFont(value: string): Stimulsoft.System.Drawing.Font;
        static toBoolean(value: any): boolean;
        static toNumber(value: any): number;
        static toDouble(value: any): number;
        static toInt32(value: any, radix?: number): number;
        static toInt64(value: any): number;
        static toUInt64(value: any): number;
        static toUInt32(value: any): number;
        private static bytesToBase64String;
        static toBase64String(input: string | number[] | Uint8Array): string;
        private static base64StringToBytes;
        static fromBase64String(input: string): number[];
        static fromBase64StringText(input: string): string;
        static fromUTF16LE<T extends string | number[] | Uint8Array>(input: T): T;
        static isUTF16LE(input: string | number[] | Uint8Array): boolean;
        static stripBom<T extends string | number[]>(data: T): T;
    }
}
export namespace Stimulsoft.System {
    class NodeJs {
        private static isInitialize;
        static initialize(onResult?: Function): void;
        static get fs(): {
            readdirSync: (path: string) => string[];
            existsSync: (path: string) => boolean;
            exists: (path: string, cb: (exists: boolean) => void) => void;
            mkdirSync: (path: string, options: {
                recursive: boolean;
            }) => void;
            rmSync: (path: string, options: {
                recursive: boolean;
                force: boolean;
            }) => void;
            readFileSync: (path: string, code?: string) => string;
            writeFileSync: (parh: string, data: string) => void;
            writeFile: (path: string, data: any, cb: (error: string) => void) => void;
            promises: {
                mkdtemp: (path: string) => Promise<string>;
                writeFile: (path: string, data: string) => Promise<void>;
                rm: (path: string, options: {
                    recursive: boolean;
                    force: boolean;
                }) => Promise<void>;
            };
            createReadStream: (path: string) => {
                setEncoding: (code: string) => void;
                read: (count: number) => string;
                on: (event: string, cb: () => void) => void;
                removeListener: (event: string, cb: () => void) => void;
            };
        };
        static get path(): {
            extname: (path: string) => string;
            basename: (path: string, suffix?: string) => string;
            join: (...args: string[]) => string;
            sep: string;
        };
        static get os(): {
            hostname: () => string;
            networkInterfaces: () => {
                Ethernet: {
                    mac: string;
                }[];
                Wireless80211: {
                    mac: string;
                }[];
            };
            userInfo: () => {
                username: string;
            };
            tmpdir: () => string;
            platform: () => string;
            type: () => string;
            release: () => string;
        };
        static get http(): {
            request: (options: {}, cb: (response: {
                setEncoding: (code: string) => void;
                on: (event: string, cb: (data: any) => void) => void;
                statusCode: number;
                statusMessage: string;
            }) => void) => {
                on: (event: string, cb: (data: any) => void) => void;
                write: (data: string) => void;
                end: () => void;
            };
        };
        static get https(): {
            request: (options: {}, cb: (response: {
                setEncoding: (code: string) => void;
                on: (event: string, cb: (data: any) => void) => void;
                statusCode: number;
                statusMessage: string;
            }) => void) => {
                on: (event: string, cb: (data: any) => void) => void;
                write: (data: string) => void;
                end: () => void;
            };
        };
        static get url(): {
            parse: (url: string) => {
                protocol: string;
                hostname: string;
                path: string;
                port: number;
            };
        };
        static require(module: string): any;
        private static convertInternal;
        private static getEmbeddedFonts;
        private static convertSvgToPng;
        static sendAsync(method: string, url: string, body?: string, headers?: Header[], timeout?: number): StiPromise<{
            status: number;
            responseText: string;
            statusText: string;
        }>;
        static callRemoteApi(command: any, timeout: number): StiPromise<string>;
        static stripBom(data: any): any;
        static getFile(filePath: string, binary: boolean, contentType: string, headers: Header[], disableCache?: boolean, withCredentials?: boolean, allowException?: boolean): any;
        static getFileHttp(filePath: string, binary: boolean, contentType: string, headers: Header[], disableCache?: boolean, withCredentials?: boolean, allowException?: boolean): any;
        static send(method: string, url: string, body: string, headers?: Header[]): {
            status: number;
            responseText: string;
            statusText: string;
        };
        static saveAs(data: any, fileName: string, type?: string): any;
        static saveFile(filePath: string, fileData: string | number[]): void;
        static getFilesNames(filesPath: string): string[];
        static getSep(): string;
        private static fromBase64String;
        private static fromBase64StringText;
        private static toBase64String;
        private static fromUnicodeString;
        private static _isNodeJs;
        static isNodeJs(): boolean;
        static isBuffer(data: any): boolean;
        static isStandaloneVersion: boolean;
        static useWebKit: boolean;
        get consoleLog(): boolean;
        set consoleLog(value: boolean);
        private static fillInfo;
        static localizationPath: string;
        private static getLocalizationInfo;
    }
}
export namespace Stimulsoft.System.Globalization {
    class TextInfo {
        listSeparator: string;
        toTitleCase(str: string): string;
        constructor(listSeparator?: string);
    }
}
export namespace Stimulsoft.System.Globalization {
    import IFormatProvider = Stimulsoft.System.IFormatProvider;
    import Type = Stimulsoft.System.Type;
    class NumberFormatInfo implements IFormatProvider {
        numberDecimalSeparator: string;
        numberDecimalDigits: number;
        numberGroupSeparator: string;
        numberGroupSizes: number[];
        numberNegativePattern: number;
        currencyDecimalDigits: number;
        currencyDecimalSeparator: string;
        currencyGroupSeparator: string;
        currencyGroupSizes: number[];
        currencyNegativePattern: number;
        currencyPositivePattern: number;
        currencySymbol: string;
        percentDecimalDigits: number;
        percentDecimalSeparator: string;
        percentGroupSeparator: string;
        percentGroupSizes: number[];
        percentNegativePattern: number;
        percentPositivePattern: number;
        percentSymbol: string;
        perMilleSymbol: string;
        positiveInfinitySymbol: string;
        positiveSign: string;
        NaNSymbol: string;
        negativeInfinitySymbol: string;
        negativeSign: string;
        getFormat(formatType: Type): any;
        constructor(numberDecimalSeparator?: string, numberDecimalDigits?: number, numberGroupSeparator?: string, numberGroupSizes?: number[], numberNegativePattern?: number, currencyDecimalDigits?: number, currencyDecimalSeparator?: string, currencyGroupSeparator?: string, currencyGroupSizes?: number[], currencyNegativePattern?: number, currencyPositivePattern?: number, currencySymbol?: string, percentDecimalDigits?: number, percentDecimalSeparator?: string, percentGroupSeparator?: string, percentGroupSizes?: number[], percentNegativePattern?: number, percentPositivePattern?: number, percentSymbol?: string, perMilleSymbol?: string, positiveInfinitySymbol?: string, positiveSign?: string, NaNSymbol?: string, negativeInfinitySymbol?: string, negativeSign?: string);
    }
}
export namespace Stimulsoft.System.Globalization {
    class DateTimeFormatInfo {
        shortDatePattern: string;
        dateSeparator: string;
        longDatePattern: string;
        dayNames: string[];
        monthNames: string[];
        shortestDayNames: string[];
        abbreviatedMonthNames: string[];
        monthGenitiveNames: string[];
        timeSeparator: string;
        AMDesignator: string;
        PMDesignator: string;
        fullDateTimePattern: string;
        shortTimePattern: string;
        longTimePattern: string;
        yearMonthPattern: string;
        calendarWeekRule: Stimulsoft.System.Globalization.CalendarWeekRule;
        firstDayOfWeek: Stimulsoft.System.DayOfWeek;
        constructor(shortDatePattern: string, dateSeparator: string, longDatePattern: string, dayNames: string[], monthNames: string[], shortestDayNames: string[], abbreviatedMonthNames: string[], monthGenitiveNames: string[], timeSeparator: string, AMDesignator: string, PMDesignator: string, fullDateTimePattern: string, shortTimePattern: string, longTimePattern: string, yearMonthPattern: string, calendarWeekRule: Stimulsoft.System.Globalization.CalendarWeekRule, firstDayOfWeek: Stimulsoft.System.DayOfWeek);
    }
}
export namespace Stimulsoft.System.Globalization {
    class CultureInfo {
        numberFormat: NumberFormatInfo;
        dateTimeFormat: DateTimeFormatInfo;
        name: string;
        readonly displayName: string;
        textInfo: TextInfo;
        regionInfo: RegionInfo;
        private static _cultures;
        private static _currentCulture;
        static get currentCulture(): CultureInfo;
        static set currentCulture(val: CultureInfo);
        static get cultures(): {
            [key: string]: CultureInfo;
        };
        static get ivariantCulture(): CultureInfo;
        static getCultureInfo(name: string): CultureInfo;
        constructor(name: string, numberFormat?: NumberFormatInfo, dateTimeFormat?: DateTimeFormatInfo, textInfo?: TextInfo, displayName?: string);
    }
}
export namespace Stimulsoft.System {
    class DateTime {
        private static ticksPerMillisecond;
        private static ticksPerSecond;
        private static ticksPerMinute;
        private static ticksPerHour;
        private static ticksPerDay;
        private static daysPerYear;
        private static daysPer4Years;
        private static daysPer100Years;
        private static daysPer400Years;
        private static daysTo10000;
        private static minTicks;
        private static maxTicks;
        private static daysToMonth365;
        private static daysToMonth366;
        static minValue: DateTime;
        static maxValue: DateTime;
        static getNetTypeName(): string;
        dateTimeOffset: string;
        private innerDate;
        get year(): number;
        get month(): number;
        get monthName(): string;
        get monthGenitiveName(): string;
        get monthShortName(): string;
        get day(): number;
        get dayOfWeek(): DayOfWeek;
        get dayName(): string;
        get dayShortName(): string;
        get hour(): number;
        get minute(): number;
        get second(): number;
        get millisecond(): number;
        get ticks(): number;
        get dayOfYear(): number;
        firstDayOfWeek(): DateTime;
        lastDayOfWeek(): DateTime;
        firstDayOfMonth(): DateTime;
        lastDayOfMonth(): DateTime;
        firstDayOfQuarter(): DateTime;
        lastDayOfQuarter(): DateTime;
        lastDateTimeOfDay(): DateTime;
        firstDayOfFirthQuarter(): DateTime;
        lastDayOfFirthQuarter(): DateTime;
        firstDayOfSecondQuarter(): DateTime;
        lastDayOfSecondQuarter(): DateTime;
        firstDayOfThirdQuarter(): DateTime;
        lastDayOfThirdQuarter(): DateTime;
        firstDayOfFourthQuarter(): DateTime;
        lastDayOfFourthQuarter(): DateTime;
        firstDayOfYear(): DateTime;
        lastDayOfYear(): DateTime;
        toShortDateString(): string;
        toShortTimeString(): string;
        static get now(): DateTime;
        static get today(): DateTime;
        static isLeapYear(year: number): boolean;
        static daysInMonth(year: number, month: number): number;
        static compare(t1: DateTime, t2: DateTime): number;
        static ticksNetToTicksJs(ticks: number): number;
        static dateToNetTicks(date: Date): number;
        negate(): DateTime;
        addYears(value: number): DateTime;
        addMonths(value: number): DateTime;
        addDays(value: number): DateTime;
        addHours(value: number): DateTime;
        addMinutes(value: number): DateTime;
        addSeconds(value: number): DateTime;
        addMilliseconds(value: number): DateTime;
        addTicks(value: number): DateTime;
        compareTo(value: DateTime): number;
        subtract(value: DateTime): TimeSpan;
        get date(): DateTime;
        get jsDate(): Date;
        toString(format?: string): string;
        static oaDateToTicks0(oaDate: number): number;
        static ticksToOADate0(ticks: number): number;
        toOADate(): number;
        toOADate2(round: boolean): number;
        toNetJsonString(): string;
        getHashCode(): number;
        static parse(value: string): DateTime;
        static tryParse(d?: string): {
            result: DateTime;
            successfully: boolean;
        };
        static tryParseExact(d: string, format: string[]): {
            result: DateTime;
            successfully: boolean;
        };
        static fromNetJsonString(jsonDate: string): DateTime;
        static fromOADate(oadate: number): DateTime;
        private static dayjsFormatsSlash;
        private static dayjsFormats;
        private static dayjsFormatsMilliseconds;
        private static lastDayjsFormat;
        static fromString(d?: string, logError?: boolean): DateTime;
        static fromString2(format: string, value: string, logError?: boolean): DateTime;
        private static dayjsIsoDateFormats;
        static isISO8601String(d: string): boolean;
        get timeOfDay(): TimeSpan;
        equals(date: DateTime): boolean;
        constructor(param1: Date | number, month?: number, day?: number, hour?: number, minute?: number, second?: number, millisecond?: number);
    }
}
export namespace Stimulsoft.System {
    import DateTime = Stimulsoft.System.DateTime;
    class DateOnly implements IComparable<DateOnly> {
        implements(): any[];
        private internalValue;
        static get now(): DateOnly;
        static get minValue(): DateOnly;
        static get maxValue(): DateOnly;
        get year(): number;
        get month(): number;
        get day(): number;
        toString(format?: string): string;
        subtract(date: DateOnly): TimeSpan;
        toDateTime(): DateTime;
        toODate(): number;
        static fromDateTime(dateTime: DateTime): DateOnly;
        static parse(s: string): DateOnly;
        static tryParse(s: string, refResult: {
            ref: DateOnly;
        }): boolean;
        compareTo(other: DateOnly): number;
        equals(date: any): boolean;
        getHashCode(): number;
        constructor(dateTime: DateTime);
    }
}
export namespace Stimulsoft.System {
    class DateTimeOffset extends DateTime {
        static getNetTypeName(): string;
        static fromString(d?: string, logError?: boolean): DateTimeOffset;
        static parse(value: string): DateTimeOffset;
        static get now(): DateTimeOffset;
        get dateTime(): DateTime;
        constructor(param1: Date | number, month?: number, day?: number, hour?: number, minute?: number, second?: number, millisecond?: number);
    }
}
export namespace Stimulsoft.System {
    enum DayOfWeek {
        Sunday = 0,
        Monday = 1,
        Tuesday = 2,
        Wednesday = 3,
        Thursday = 4,
        Friday = 5,
        Saturday = 6
    }
}
export namespace Stimulsoft.ExternalLibrary {
    type Input = Stimulsoft.ExternalLibrary.dayjs.ConfigType;
    type Dayjs = Stimulsoft.ExternalLibrary.dayjs.Dayjs;
    type OptionType = Stimulsoft.ExternalLibrary.dayjs.OptionType;
    function dayjs(date?: Input): Dayjs;
    function dayjs(date?: Input, format?: OptionType, strict?: boolean): Dayjs;
    function dayjs(date?: Input, format?: OptionType, locale?: string, strict?: boolean): Dayjs;
}
export namespace Stimulsoft.ExternalLibrary.dayjs {
    interface ConfigTypeMap {
        default: string | number | Date | Dayjs | null | undefined;
    }
    type ConfigType = ConfigTypeMap[keyof ConfigTypeMap];
    interface FormatObject {
        locale?: string;
        format?: string;
        utc?: boolean;
    }
    type OptionType = FormatObject | string | string[];
    type UnitTypeShort = 'd' | 'M' | 'y' | 'h' | 'm' | 's' | 'ms';
    type UnitTypeLong = 'millisecond' | 'second' | 'minute' | 'hour' | 'day' | 'month' | 'year' | 'date';
    type UnitTypeLongPlural = 'milliseconds' | 'seconds' | 'minutes' | 'hours' | 'days' | 'months' | 'years' | 'dates';
    type UnitType = UnitTypeLong | UnitTypeLongPlural | UnitTypeShort;
    type OpUnitType = UnitType | "week" | "weeks" | 'w';
    type QUnitType = UnitType | "quarter" | "quarters" | 'Q';
    type ManipulateType = Omit<OpUnitType, 'date' | 'dates'>;
    interface ILocale {
        name: string;
        weekdays?: string[];
        months?: string[];
        weekStart?: number;
        weekdaysShort?: string[];
        monthsShort?: string[];
        weekdaysMin?: string[];
        ordinal?: (n: number) => number | string;
        formats: Partial<{
            LT: string;
            LTS: string;
            L: string;
            LL: string;
            LLL: string;
            LLLL: string;
        }>;
        relativeTime?: Partial<{
            future: string;
            past: string;
            s: string;
            m: string;
            mm: string;
            h: string;
            hh: string;
            d: string;
            dd: string;
            M: string;
            MM: string;
            y: string;
            yy: string;
        }>;
        meridiem: {
            AM: string;
            PM: string;
        };
    }
    class Dayjs {
        constructor(config?: ConfigType);
        clone(): Dayjs;
        isValid(): boolean;
        year(): number;
        year(value: number): Dayjs;
        month(): number;
        month(value: number): Dayjs;
        date(): number;
        date(value: number): Dayjs;
        day(): number;
        day(value: number): Dayjs;
        hour(): number;
        hour(value: number): Dayjs;
        minute(): number;
        minute(value: number): Dayjs;
        second(): number;
        second(value: number): Dayjs;
        millisecond(): number;
        millisecond(value: number): Dayjs;
        set(unit: UnitType, value: number): Dayjs;
        get(unit: UnitType): number;
        add(value: number, unit?: ManipulateType): Dayjs;
        subtract(value: number, unit?: ManipulateType): Dayjs;
        startOf(unit: OpUnitType): Dayjs;
        endOf(unit: OpUnitType): Dayjs;
        format(template?: string): string;
        diff(date?: ConfigType, unit?: QUnitType | OpUnitType, float?: boolean): number;
        valueOf(): number;
        unix(): number;
        daysInMonth(): number;
        toDate(): Date;
        toJSON(): string;
        toISOString(): string;
        toString(): string;
        utcOffset(): number;
        isBefore(date: ConfigType, unit?: OpUnitType): boolean;
        isSame(date: ConfigType, unit?: OpUnitType): boolean;
        isAfter(date: ConfigType, unit?: OpUnitType): boolean;
        locale(): string;
        locale(preset: string | ILocale, object?: Partial<ILocale>): Dayjs;
    }
    interface Dayjs {
        quarter(): number;
        quarter(quarter: number): Dayjs;
        add(value: number, unit: QUnitType): Dayjs;
        subtract(value: number, unit: QUnitType): Dayjs;
        startOf(unit: QUnitType): Dayjs;
        endOf(unit: QUnitType): Dayjs;
        isSame(date: ConfigType, unit?: QUnitType): boolean;
        isBefore(date: ConfigType, unit?: QUnitType): boolean;
        isAfter(date: ConfigType, unit?: QUnitType): boolean;
    }
    type PluginFunc<T = unknown> = (option: T, c: typeof Dayjs, d: typeof dayjs) => void;
    function extend<T = unknown>(plugin: PluginFunc<T>, option?: T): Dayjs;
    function locale(preset?: string | ILocale, object?: Partial<ILocale>, isLocal?: boolean): string;
    function isDayjs(d: any): d is Dayjs;
    function unix(t: number): Dayjs;
    const Ls: {
        [key: string]: ILocale;
    };
}
export namespace Stimulsoft.System {
    class Enum {
        static getName(enumType: any, value: number): string;
        static parse(enumType: any, value: string | number, upperFirstChar?: boolean): number;
        private static upperFirstChar;
        static getNames(enumType: any): string[];
        static getValues(enumType: any): number[];
        name: string;
        value: number;
        toString(): string;
        compareTo(value: Enum): number;
        constructor(name: string, value?: number);
    }
}
export namespace Stimulsoft.System {
    class Environment {
        static get newLine(): string;
    }
}
export namespace Stimulsoft.System {
    class Event {
        private eventList;
        get isNull(): boolean;
        get isNotNull(): boolean;
        add(funct: Function, _this: any): void;
        call(...args: any[]): void;
    }
}
export namespace Stimulsoft.System {
    class EventArgs {
        static empty: EventArgs;
    }
}
export namespace Stimulsoft.System {
    class LogStatus {
        get isImportant(): boolean;
        get isAll(): boolean;
    }
    class Exception extends Error {
        innerException?: Exception;
        static log(exception: Exception | string, obj: any, message?: string): LogStatus;
        static logEvent(exception: Exception | string, compObject: any, eventName: string): LogStatus;
        static logExpression(exception: Exception | string, compObject: any, propertyName: string): LogStatus;
        static logSeriesExpression(exception: Exception | string, compObject: any, series: string, propertyName: string): LogStatus;
        static getMessage(exception: Exception | string): string;
        constructor(message?: string, innerException?: Exception);
    }
}
export namespace Stimulsoft.ExternalLibrary.Fontkit {
    type FontKitType = {
        familyName: string;
        head: {
            macStyle: {
                bold: boolean;
                italic: boolean;
                underline: boolean;
            };
        };
    };
    function create(buffer: number[] | ArrayBuffer | Uint8Array): FontKitType;
}
export namespace Stimulsoft.System {
    class Guid {
        private id;
        static newGuid(): Guid;
        static newGuidString(): string;
        private static s4;
        toString(): string;
        toByteArray(): number[];
        static get empty(): Guid;
        static compareTo(value: Guid): number;
        constructor(id: string);
    }
}
export namespace Stimulsoft.System {
    class Header {
        key: string;
        value: string;
        static concatArray(headers1: Header[], headers2: Header[]): Header[];
    }
}
export namespace Stimulsoft.System {
    class Interface<T> {
        typeName: string;
        type: T;
        constructor(typeName: string);
    }
}
export namespace Stimulsoft.System {
    let IAsIs: Interface<IAsIs>;
    interface IAsIs {
        is<T>(type: (new (...args: any[]) => T) | Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Interface<T>): T;
    }
}
export namespace Stimulsoft.System {
    let ICloneable: Interface<ICloneable>;
    interface ICloneable {
        clone(): any;
    }
}
export namespace Stimulsoft.System {
    let IComparable: Interface<IComparable<any>>;
    interface IComparable<T> {
        compareTo(obj: T): number;
    }
}
export namespace Stimulsoft.System {
    let IFormatProvider: Interface<IFormatProvider>;
    interface IFormatProvider {
        getFormat(formatType: Type): any;
    }
}
export namespace Stimulsoft.System {
    interface IRefOut<T> {
        arg: T;
    }
}
export namespace Stimulsoft.System {
    class JSON2 {
        static decode(text: string): any;
        static encode(value: any): string;
        static stiPopulateObject(json: any, object: any): void;
    }
}
export namespace Stimulsoft.System {
    enum MidpointRounding {
        ToEven = 1000,
        AwayFromZero = 1001,
        ToZero = 1002,
        ToNegativeInfinity = 1003,
        ToPositiveInfinity = 1004
    }
}
interface ObjectConstructor {
    saveAs(data: any, fileName: string, type?: string): any;
}
export namespace Stimulsoft.System {
}
export namespace Stimulsoft.System.Reflection {
    enum BindingFlags {
        Default = 0,
        IgnoreCase = 1,
        DeclaredOnly = 2,
        Instance = 4,
        Static = 8,
        Public = 16,
        NonPublic = 32,
        FlattenHierarchy = 64,
        InvokeMethod = 256,
        CreateInstance = 512,
        GetField = 1024,
        SetField = 2048,
        GetProperty = 4096,
        SetProperty = 8192
    }
}
export namespace Stimulsoft.System {
    import IAsIs = Stimulsoft.System.IAsIs;
    import BindingFlags = Stimulsoft.System.Reflection.BindingFlags;
    const compactBase64: (value: string) => string;
    const decompressLiteral: (value: any) => any;
    function applyMixins(dest: any, mixins: any[]): any;
    function enumerable(value: boolean): (target: any, propertyKey: string, descriptor: PropertyDescriptor) => void;
    function enumType(type: any): (target: any, propertyKey: string, descriptor: PropertyDescriptor) => void;
    function promiseCancellable(target: any, name: string, descriptor: PropertyDescriptor): any;
    class StiObject implements IAsIs {
        value: any;
        is<T>(type: (new (...args: any[]) => T) | Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Interface<T>): T;
        memberwiseClone(isBase?: boolean): any;
        equals(...args: any[]): boolean;
        getHashCode(...args: any[]): number;
        static compareTo(a: any, b: any): number;
        compareTo(object: any): number;
        toBoolean(): boolean;
        toNumber(float?: boolean): number;
        toString(): string;
        getType(): Stimulsoft.System.Type;
        getTypeName(): string;
        getNetTypeName(): string;
        static referenceEquals(objA: any, objB: any): boolean;
        static addEvent(element: any, eventName: string, fn: Function): void;
        static equals(objA: any, objB: any): boolean;
        static isNullOrUndefined: (obj: any) => boolean;
        static disableAllEnumerable(prototype: any, obj: any): void;
        static keys(obj: any): string[];
        static getOwnPropertyNames(obj: any): string[];
        getMethods(bindingAttr: BindingFlags): string[];
        static saveAs(data: any, fileName: string, type?: string): void;
        static mergeDeep(target: any, ...sources: any[]): any;
        static stimulsoft: symbol;
        static init(): void;
        constructor(value: any);
    }
    class StiNumber extends StiObject implements IAsIs {
        value: number;
        getHashCode(...args: any[]): number;
        is<T>(type: any): this is T;
        as(type: any): any;
        memberwiseClone(isBase?: boolean): any;
        compareTo(value: number): number;
        toShort(): number;
        toStringFormat(formatString: string): string;
        getType(): Stimulsoft.System.Type;
        getTypeName(): string;
        getNetTypeName(): string;
        private static _numberRegexp;
        static tryParse(value: string, float?: boolean): {
            result: number;
            successfully: boolean;
        };
        static getValueOrDefault(value: number): number;
    }
    class StiString extends StiObject implements IAsIs {
        value: string;
        is<T>(type: any): this is T;
        as(type: any): any;
        memberwiseClone(isBase?: boolean): any;
        replaceAll(searchValue: string, replaceValue: string, startIndex?: number, count?: number): string;
        contains(str: string): boolean;
        compareTo(strB: string): number;
        isBase64String(): boolean;
        remove(startIndex: number, count?: number): string;
        insert(startIndex: number, value: string, removeLength?: number): string;
        padLeft(totalWidth: number, paddingChar?: string): string;
        padRight(totalWidth: number, paddingChar?: string): string;
        trimStart(char?: string): string;
        trimEnd(char?: string): string;
        getHashCode(...args: any[]): number;
        toBytesArray(): number[];
        toUnicodeString(): string;
        fromUnicodeString(): string;
        indexOfAny(values: string[]): number;
        regexIndexOf(regex: RegExp, startpos: number): number;
        regexLastIndexOf(regex: RegExp, startpos: number): number;
        split(...separators: string[]): string[];
        toLowerFirst(): string;
        getType(): Stimulsoft.System.Type;
        getTypeName(): string;
        getNetTypeName(): string;
        toString(): string;
        static isNullOrEmpty(value: string): boolean;
        static isNullOrWhiteSpace(value: string): boolean;
        static repeat(value: string, n: number): string;
        static fill(value: string, count: number): string;
        static format(str: string, ...values: any[]): string;
        private static _formatRegexp;
        static format1(str: string, values: any[]): string;
        static parseFormatString(formatString: string, values: any[]): string;
        static customFormat(arg: any, format: string): string;
        static indexOfAny(str: string, searchChars: string[]): number;
        static join(separator: string, value: string[]): string;
        static fromBytesArray(bytes: number[]): string;
    }
    class StiBoolean extends StiObject implements IAsIs {
        is<T>(type: any): this is T;
        as(type: any): any;
        memberwiseClone(isBase?: boolean): any;
        getHashCode(...args: any[]): number;
        getType(): Stimulsoft.System.Type;
        getTypeName(): string;
        getNetTypeName(): string;
        compareTo(object: boolean): number;
        toNumber(float?: boolean): number;
        toString(): string;
    }
    class StiArray extends StiObject {
        getHashCode(): number;
        getType(): Stimulsoft.System.Type;
        getTypeName(): string;
        getNetTypeName(): string;
        contains(item: any): boolean;
        remove<T>(item: T): void;
        removeAt(index: number): void;
        insert(index: number, item: any): void;
        clear(): void;
        clone(): any;
        addRange(items: any[]): void;
        removeRange(index: number, count: number): void;
        copyTo(array: any[], index?: number): void;
        getKeys(): string[];
        getByIndex(index: number, keys: string[]): any;
        sort2(comparer: Stimulsoft.System.Collections.IComparer<any>): any[];
        getLength(dimension: number): number;
        toArray(): any[];
        toNumber(float?: boolean): number;
        peek(): any;
        toList<T>(): Stimulsoft.System.Collections.List<T>;
        subarray<T>(start: number, end: number): T[];
        static create<T>(t: Stimulsoft.System.Type, count: number, isStructure?: boolean): T[];
        static create2<T>(t: Stimulsoft.System.Type, count1: number, count2: number, isStructure?: boolean): T[][];
        static create3<T>(t: Stimulsoft.System.Type, count1: number, count2: number, count3: number, isStructure?: boolean): T[][][];
        static create1<T>(t: Stimulsoft.System.Type, ...values: any[]): T[];
        static numberSortFunction: () => any;
        static copy: (sourceArray: any[], startIndex: number, destinationArray: any[], count: number) => void;
        static copy2: (sourceArray: any[], sourceIndex: number, destinationArray: any[], destinationIndex: number, count: number) => void;
        static copy3: (sourceArray: any[], destinationArray: any[]) => void;
        static reverse: (array: any[]) => any[];
        static sort: (array: any[]) => any[];
        static sort3(keys: number[], items: any[]): void;
        static clear: (array: any[], index: number, length: number) => any[];
        static distinct<T>(array: T[]): T[];
        static isArray<T>(data: any): data is Array<T>;
        constructor(value: any);
    }
    class StiDate extends StiObject implements IAsIs {
        is<T>(type: any): this is T;
        as(type: any): any;
    }
}
interface Object {
    //StiObject;
}
interface String {
    //StiString;
}
interface Number {
    //StiNumber;
}
interface Boolean {
    //StiBoolean;
}
interface Array<T> {
    //StiArray;
}
export namespace Stimulsoft.Report {
    import Type = Stimulsoft.System.Type;
    class Range {
        static isRangeType(type: Type): boolean;
        static isNumericRangeType(type: Type): boolean;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        parse(from: string, to: string): void;
        equals(obj: any): boolean;
        get fromStrLoc(): string;
        get toStrLoc(): string;
        toString(): string;
        getHashCode(): number;
        constructor();
    }
    class CharRange extends Range {
        from: string;
        to: string;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        contains(value: string): boolean;
        constructor(from?: string, to?: string);
    }
    class DateTimeRange extends Range {
        from: Stimulsoft.System.NullableDateTime;
        to: Stimulsoft.System.NullableDateTime;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        get fromDate(): Stimulsoft.System.DateTime;
        get toDate(): Stimulsoft.System.DateTime;
        contains(value: Stimulsoft.System.DateTime): boolean;
        toString(): string;
        constructor(from?: Stimulsoft.System.DateTime, to?: Stimulsoft.System.DateTime);
    }
    class TimeSpanRange extends Range {
        from: Stimulsoft.System.NullableTimeSpan;
        to: Stimulsoft.System.NullableTimeSpan;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        get fromTime(): Stimulsoft.System.TimeSpan;
        get toTime(): Stimulsoft.System.TimeSpan;
        contains(value: Stimulsoft.System.TimeSpan): boolean;
        toString(): string;
        constructor(from?: Stimulsoft.System.TimeSpan, to?: Stimulsoft.System.TimeSpan);
    }
    class DecimalRange extends Range {
        from: number;
        to: number;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class FloatRange extends Range {
        from: number;
        to: number;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class DoubleRange extends Range {
        from: number;
        to: number;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class ByteRange extends Range {
        from: number;
        to: number;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class ShortRange extends Range {
        from: number;
        to: number;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class IntRange extends Range {
        from: number;
        to: number;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class LongRange extends Range {
        from: number;
        to: number;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class GuidRange extends Range {
        from: Stimulsoft.System.Guid;
        to: Stimulsoft.System.Guid;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        contains(value: Stimulsoft.System.Guid): boolean;
        constructor(from?: Stimulsoft.System.Guid, to?: Stimulsoft.System.Guid);
    }
    class StringRange extends Range {
        from: string;
        to: string;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        contains(value: string): boolean;
        constructor(from?: string, to?: string);
    }
}
export namespace Stimulsoft.System {
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    class ResourceManager {
        private resource;
        getString(name: string, culture: CultureInfo): string;
    }
}
export namespace Stimulsoft.System {
    class StiError {
        static consoleErrorLog: boolean;
        static consoleWarningLog: boolean;
        static consoleMessageLog: boolean;
        private static lastErrorMessage;
        static errorMessageForm: any;
        static showError(e: Exception | string, showForm?: boolean, infoForm?: boolean): void;
    }
}
export namespace Stimulsoft.System {
    import MidpointRounding = Stimulsoft.System.MidpointRounding;
    class StiMath {
        private static roundToInt;
        static round2(value: number, precision?: number, mode?: MidpointRounding): number;
        static trunc(x: number): number;
        static sign(x: number): number;
        static log10(value: number): number;
    }
}
export namespace Stimulsoft.System {
    enum StiNavigatorType {
        Unknown = 0,
        Edge = 1,
        MSIE = 2,
        Chrome = 3,
        Safari = 4,
        Mozilla = 5,
        Opera = 6
    }
    class StiNavigator {
        private static _type;
        static get type(): StiNavigatorType;
        static get isIE(): boolean;
    }
}
type NumberFormatInfo = Stimulsoft.System.Globalization.NumberFormatInfo;
export namespace Stimulsoft.System.Internals {
    function formatNumber(value: number, format: string, info?: NumberFormatInfo): string;
    namespace formatNumber {
        export function decimalFormat(value: number, precision?: number, info?: NumberFormatInfo): string;
        export function hexadecimalFormat(value: number, precision?: number, isUpper?: boolean): string;
        export function fixedPointFormat(value: number, precision?: number, info?: NumberFormatInfo): string;
        export function currencyFormat(value: number, precision?: number, info?: NumberFormatInfo): string;
        export function placeCurrencyValue(value: string, isPositive: boolean, negativeSign: string, currencySymbol: string, patternNumber: number): string;
        export function numericFormat(value: number, precision?: number, info?: NumberFormatInfo): string;
        export function exponentialFormat(value: number, precision?: number, isUpper?: boolean, info?: NumberFormatInfo, minExpDigits?: number): string;
        export function roundTripFormat(value: number, info?: NumberFormatInfo): string;
        export function generalFormat(value: number, precision?: number, isUpper?: boolean, info?: NumberFormatInfo): string;
        export function percentFormat(value: number, precision?: number, info?: NumberFormatInfo): string;
        const SpecifierToken = 1;
        const TextToken = 2;
        type CustomFormatElement = {
            type: (typeof SpecifierToken | typeof TextToken);
            token: string;
        };
        type CustomFormat = {
            tokens: CustomFormatElement[];
            useGroupSeparators: boolean;
            numbersBeforeDot: number;
            numbersAfterDot: number;
            effectiveNumbersBeforeDot: number;
            effectiveNumbersAfterDot: number;
            dotIndex: number;
            scaling: number;
            expIndex: number;
        };
        export function parseCustomFormatString(format: string): {
            tokens: CustomFormatElement[];
            useGroupSeparators: boolean;
            numbersBeforeDot: number;
            numbersAfterDot: number;
            effectiveNumbersBeforeDot: number;
            effectiveNumbersAfterDot: number;
            dotIndex: number;
            scaling: number;
            expIndex: number;
        };
        export function normalizeForFormat(value: number, format: CustomFormat, info?: NumberFormatInfo): string[];
        export function customFormat(numberParts: string[], format: CustomFormat, info?: NumberFormatInfo): string;
        export function trimTrailingZeros(value: string, decimalSeparator: string): string;
        export function splitToGroups(intPart: string, groupSeparator?: string, groupSizes?: number[]): string;
        export function splitToGroupsArray(intPart: string, groupSizes?: number[]): string[];
        export function getFixedPointNumberParts(value: number, precision: number, negativeSign?: string): string[];
        export function seemsToBeZero(intPart: string, fraction: string): boolean;
        export {};
    }
}
export namespace Stimulsoft.System {
    class StiPromise<T> {
        private _this;
        returnValue: T;
        private _tryFunctions;
        private _finallyFunction;
        private _timeout;
        private _startTime;
        private _callTry;
        private _callCatch;
        private _callFinaly;
        private _callTimeout;
        private _catchArgument;
        private _finalyArgument;
        private timeoutHanderId;
        private assignFunction;
        private _catchFunctions;
        try(tryFunction: Function, _this?: any): StiPromise<T>;
        catch(catchFunction: Function, _this?: any): StiPromise<T>;
        finally(finallyFunction: Function, _this?: any): StiPromise<T>;
        this(_this: any): StiPromise<T>;
        timeout(timeout: number): StiPromise<T>;
        callTry(returnValue?: T): StiPromise<T>;
        callCatch(catchArgument?: any): StiPromise<T>;
        private callFinally;
        callTimeout(): void;
        private nextPromises;
        abort(previusPromise?: StiPromise<any>): StiPromise<T>;
        private abortFunction;
        onAbort(abortFunction: Function): void;
        private behindFunction;
        onBehindFunction(behindFunction: Function): void;
        promise(): Promise<T>;
        static lock(lockObject: any): Promise<void>;
        static unlock(lockObject: any): void;
        constructor();
    }
}
export namespace Stimulsoft.System {
    enum StringComparison {
        CurrentCulture = 0,
        CurrentCultureIgnoreCase = 1,
        InvariantCulture = 2,
        InvariantCultureIgnoreCase = 3,
        Ordinal = 4,
        OrdinalIgnoreCase = 5
    }
}
export namespace Stimulsoft.System {
    class SwitchSymbolFormatter {
        private numberSymbol;
        formatValue(format: string, source: any): string;
        constructor(numberSymbol?: string);
    }
}
export namespace Stimulsoft.System {
    import DateTime = Stimulsoft.System.DateTime;
    class TimeOnly implements IComparable<TimeOnly> {
        implements(): any[];
        private internalValue;
        static get now(): TimeOnly;
        get hour(): number;
        get minute(): number;
        get second(): number;
        get millisecond(): number;
        toString(format?: string): string;
        toDateTime(): DateTime;
        static fromDateTime(dateTime: DateTime): TimeOnly;
        static parse(s: string): TimeOnly;
        static tryParse(s: string, refResult: {
            ref: TimeOnly;
        }): boolean;
        compareTo(other: TimeOnly): number;
        equals(time: any): boolean;
        getHashCode(): number;
        constructor(param: number | DateTime);
    }
}
export namespace Stimulsoft.System {
    class TimeSpan {
        static ticksPerMillisecond: number;
        private static millisecondsPerTick;
        static ticksPerSecond: number;
        private static secondsPerTick;
        static ticksPerMinute: number;
        private static minutesPerTick;
        static ticksPerHour: number;
        private static hoursPerTick;
        static ticksPerDay: number;
        private static daysPerTick;
        private static millisPerSecond;
        static maxSeconds: number;
        static minSeconds: number;
        static maxMilliSeconds: number;
        static minMilliSeconds: number;
        static ticksPerTenthSecond: number;
        static get zero(): TimeSpan;
        static getNetTypeName(): string;
        private static _minValue;
        static get minValue(): TimeSpan;
        private static _maxValue;
        static get maxValue(): TimeSpan;
        private _minus;
        ticks: number;
        get days(): number;
        get hours(): number;
        get milliseconds(): number;
        get minutes(): number;
        get seconds(): number;
        get totalDays(): number;
        get totalHours(): number;
        get totalMinutes(): number;
        get totalSeconds(): number;
        get totalMilliseconds(): number;
        static fromString(value: string, format?: string): TimeSpan;
        private static interval;
        static fromTicks(value: number): TimeSpan;
        static fromSeconds(value: number): TimeSpan;
        static fromMilliseconds(value: number): TimeSpan;
        static fromDays(value: number): TimeSpan;
        static fromHours(value: number): TimeSpan;
        static fromMinutes(value: number): TimeSpan;
        add(value: number): TimeSpan;
        add2(value: TimeSpan): TimeSpan;
        toString(format?: string): string;
        negate(): TimeSpan;
        static tryParse(time: string): {
            result: TimeSpan;
            successfully: boolean;
        };
        static parse(s: string): TimeSpan;
        static compare(t1: TimeSpan, t2: TimeSpan): number;
        compareTo(value: TimeSpan): number;
        private static timeToTicks;
        static create(days?: number, hours?: number, minutes?: number, seconds?: number, milliseconds?: number): TimeSpan;
        constructor(param1?: number, minutes?: number, seconds?: number, milliseconds?: number);
    }
}
export namespace Stimulsoft.System {
    enum TypeCode {
        Empty = 0,
        Object = 1,
        DBNull = 2,
        Boolean = 3,
        Char = 4,
        SByte = 5,
        Byte = 6,
        Int16 = 7,
        UInt16 = 8,
        Int32 = 9,
        UInt32 = 10,
        Int64 = 11,
        UInt64 = 12,
        Single = 13,
        Double = 14,
        Decimal = 15,
        DateTime = 16,
        String = 18
    }
}
export namespace Stimulsoft.System {
    import TypeCode = Stimulsoft.System.TypeCode;
    class TypeHelper {
        private static types;
        static getTypes(): Stimulsoft.System.Type[];
        static isValueType(type: Type): boolean;
    }
    class Type {
        apply(thisArg: any, argArray?: any): any;
        call(thisArg: any, ...argArray: any[]): any;
        bind(thisArg: any, ...argArray: any[]): any;
        prototype: any;
        length: number;
        arguments: any;
        caller: Function;
        name: string;
        [Symbol.hasInstance]: any;
        static getType(value: any): Type;
        static getTypeName(value: any): string;
        static getTypeCode(value: any): TypeCode;
        static isNumericType(type: Type): boolean;
        static isIntegerType(type: Type): boolean;
        static isDateType(type: Type): boolean;
        static isArrayType(type: Type): boolean;
        static getHashCode(type: any): number;
    }
    type KeyObjectType = {
        [key: string]: {};
    };
    class Byte {
    }
    class ByteArray {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class Decimal {
    }
    class Double {
    }
    class Float {
    }
    class Int {
    }
    class Int16 {
    }
    class Int32 {
    }
    class Int64 {
    }
    class Short {
    }
    class Long {
    }
    class SByte {
    }
    class Single extends Number {
    }
    class UInt {
    }
    class UInt16 {
    }
    class UInt32 {
    }
    class UInt64 {
    }
    class UShort {
    }
    class ULong {
    }
    class Nullable {
        static getUnderlyingType(nullableType: Type): Type;
    }
    class NullableBoolean extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableByte extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableChar extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableDateTime extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableDateTimeOffset extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableDateOnly extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableTimeSpan extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableTimeOnly extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableDecimal extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableDouble extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableFloat extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableGuid extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableInt extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableInt16 extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableInt32 extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableInt64 extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableShort extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableLong extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableSByte extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableSingle extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableUInt extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableUInt16 extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableUInt32 extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableUInt64 extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableUShort extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableULong extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftByteRange extends Stimulsoft.Report.ByteRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftCharRange extends Stimulsoft.Report.CharRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftDateTimeRange extends Stimulsoft.Report.DateTimeRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftDecimalRange extends Stimulsoft.Report.DecimalRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftDoubleRange extends Stimulsoft.Report.DoubleRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftFloatRange extends Stimulsoft.Report.FloatRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftGuidRange extends Stimulsoft.Report.GuidRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftIntRange extends Stimulsoft.Report.IntRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftLongRange extends Stimulsoft.Report.LongRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftShortRange extends Stimulsoft.Report.ShortRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftStringRange extends Stimulsoft.Report.StringRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftTimeSpanRange extends Stimulsoft.Report.TimeSpanRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftList {
        static isListType(type: Type): boolean;
    }
    class StimulsoftBoolList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftByteList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftCharList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftDateTimeList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftDecimalList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftDoubleList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftFloatList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftGuidList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftIntList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftLongList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftShortList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftStringList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftTimeSpanList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
}
export namespace Stimulsoft.ExternalLibrary.xmldoc {
    class XmlDocument {
        constructor(xmlString: string);
    }
}
export namespace Stimulsoft.ExternalLibrary.fflate {
    function decompressSync(data: Uint8Array): Uint8Array;
    function compressSync(data: Uint8Array, opts?: {
        level: number;
    }): Uint8Array;
    function zipSync(data: {
        [path: string]: Uint8Array;
    }): Uint8Array;
    function deflateSync(data: Uint8Array, opts?: {
        level: number;
    }): Uint8Array;
}
export namespace Stimulsoft.System.Collections {
    class CollectionBase<T> implements ICollection<T> {
        list: T[];
        toList(): List<T>;
        toCast<C>(): C[];
        get count(): number;
        get length(): number;
        clear(): void;
        add(value: T): void;
        addRange(data: T[] | CollectionBase<T>): void;
        remove(item: T): void;
        removeAt(index: number): void;
        indexOf(item: T): number;
        getByIndex(index: number): T;
        setByIndex(index: number, value: T): void;
        insert(index: number, value: T): void;
        contains(item: T | any): boolean;
    }
}
export namespace Stimulsoft.System.Collections {
    class Hashtable<K = any, V = any> {
        private ignoreCase;
        private checkType;
        entries: Map<string | K, {
            key: K;
            value: V;
        }>;
        get keys(): LinqHelper<K>;
        get values(): LinqHelper<V>;
        [Symbol.iterator](): Iterator<{
            key: K;
            value: V;
        }>;
        constructor(options?: {
            ignoreCase?: boolean;
            checkType?: boolean;
        });
        protected getActualKey(key: K): string | K;
        protected getRawValueByKey(key: K): {
            key: K;
            value: V;
        };
        get(key: K): V;
        set(key: K, value: V): void;
        add(key: K, value: V): void;
        contains(key: K): boolean;
        containsKey(key: K): boolean;
        containsValue(value: V): boolean;
        remove(key: K): void;
        clear(): void;
        copyTo(array: V[], arrayIndex: number): void;
        indexOfKey(key: K): number;
        getByIndex(index: number): V;
        get count(): number;
        clone(): Hashtable<K, V>;
    }
}
export namespace Stimulsoft.System.Collections {
    class Dictionary<K, V> extends Hashtable<K, V> {
        get pairs(): Iterable<{
            key: K;
            value: V;
        }>;
        tryGetValue(key: K, out: {
            ref: V;
        }): boolean;
    }
}
export namespace Stimulsoft.System.Collections {
    class DictionaryEntry {
        key: any;
        value: any;
    }
}
export namespace Stimulsoft.System.Collections {
    abstract class Enumerable<T> {
        protected get source(): Iterable<T>;
        where(predicate: (value: T, index: number) => boolean, __this?: any): LinqHelper<T>;
        cast<S>(): LinqHelper<S>;
        toList(): Stimulsoft.System.Collections.List<T>;
        get list(): Stimulsoft.System.Collections.List<T>;
        toArray(): T[];
        toDictionary<K, V>(keySelector: (item: T) => K, elementSelector: (item: T) => V): Stimulsoft.System.Collections.Dictionary<K, V>;
        toLookup<K>(keySelector: (value: T) => K, __this?: any): Stimulsoft.System.Collections.Hashtable;
        static repeat<T>(element: T, count: number): LinqHelper<T>;
        select<S>(selector: (value: T) => S, __this?: any): LinqHelper<S>;
        selectMany<S>(selector: (value: T) => List<S>, __this?: any): LinqHelper<S>;
        selectMany2<C, V>(collectionSelector: (value: T) => List<C>, resultSelector: (value1: T, value2: C) => V, __this?: any): LinqHelper<V>;
        concat(second: Iterable<T>): LinqHelper<T>;
        aggregate(func: (av: T, e: T) => T): T;
        aggregate2(seed: T, func: (av: T, e: T) => T): T;
        count2(selector?: (value: T) => boolean, __this?: any): number;
        max<S>(selector?: (value: T) => S): S;
        min<S>(selector?: (value: T) => S): S;
        sum(selector?: (value: T) => number): number;
        average(selector?: (value: T) => number): number;
        all(predicate?: (value: T) => boolean, __this?: any): boolean;
        any(predicate?: (value: T) => boolean, __this?: any): boolean;
        contains(item: T): boolean;
        skip(count: number): LinqHelper<T>;
        take(count: number): LinqHelper<T>;
        sequenceEqual(second: Iterable<T>): boolean;
        first(selector?: (value: T) => boolean, __this?: any): T;
        firstOrDefault(predicate?: (value: T) => boolean): T;
        lastOrDefault(): T;
        distinct(): LinqHelper<T>;
        except(second: Iterable<T>): LinqHelper<T>;
        union(second: Iterable<T>): LinqHelper<T>;
        orderBy<K>(keySelector: (value: T) => K, comparer?: IComparer<K>): LinqHelper<T>;
        orderByDescending<K>(keySelector: (value: T) => K, comparer?: IComparer<K>): LinqHelper<T>;
        groupBy<K>(keySelector: (value: T) => K, comparer?: IEqualityComparer<K>, __this?: any): Stimulsoft.System.Collections.List<Grouping<K, T>>;
        join2<U, K, V>(inner: Iterable<U>, outerKeySelector: (value: T) => K, innerKeySelector: (value: U) => K, resultSelector: (value1: T, value2: U) => V, __this?: any): LinqHelper<V>;
        groupJoin<U, K, V>(inner: Iterable<U>, outerKeySelector: (value: T) => K, innerKeySelector: (value: U) => K, resultSelector: (value1: T, value2: List<U>) => V, __this?: any): LinqHelper<V>;
        defaultIfEmpty(): LinqHelper<T>;
        zip<S, R>(second: Iterable<S>, resultSelector: (first: T, second: S) => R): LinqHelper<R>;
        fullOuterJoin<K, V, Z>(inner: Iterable<V>, outerKeySelector: (value: T) => K, innerKeySelector: (value: V) => K, resultSelector: (value1: T, value2: V) => Z, __this?: any): LinqHelper<Z>;
    }
    class LinqHelper<T> extends Enumerable<T> {
        private _source;
        constructor(source: Iterable<T>);
        protected get source(): Iterable<T>;
        copyTo(array: T[], index: number): void;
        [Symbol.iterator](): Generator<T, void, any>;
    }
}
export namespace Stimulsoft.System.Collections {
    import DateTime = Stimulsoft.System.DateTime;
    class List<T> extends Array<T> {
        constructor(items?: T[] | number);
        static create<T>(t: Stimulsoft.System.Type, ...values: any[]): List<T>;
        get countItems(): number;
        addRange(items: List<T> | T[]): void;
        removeRange(index: number, count: number): void;
        getRange(index: number, count: number): List<T>;
        add(item: T): void;
        insert(index: number, item: T): void;
        getKeys(): string[];
        getByIndex(index: number, keys: string[]): T;
        setByIndex(index: number, item: T, keys?: string[]): void;
        removeByIndex(index: number): List<T>;
        copyTo(array: any[], index?: number): void;
        clear(): void;
        peek(): T;
        remove(item: T): void;
        removeAt(index: number): void;
        exists(predicate: (value: T) => boolean): boolean;
        fullOuterJoin<K, V, Z>(inner: List<V>, outerKeySelector: (value: T) => K, innerKeySelector: (value: V) => K, resultSelector: (value1: T, value2: V) => Z, __this?: any): List<Z>;
        toList(): List<T>;
        findIndex2(match: (value: T) => boolean): number;
        findLastIndex2(match: (value: T) => boolean): number;
        zip<S, R>(second: List<S>, resultSelector: (first: T, second: S) => R): List<R>;
        static repeat<T>(element: T, count: number): List<T>;
        
        whereAsync(predicate: (value: T, index: number) => Promise<boolean>, __this?: any): Promise<List<T>>;
        join2<U, K, V>(inner: List<U>, outerKeySelector: (value: T) => K, innerKeySelector: (value: U) => K, resultSelector: (value1: T, value2: U) => V, __this?: any): List<V>;
        groupJoin<U, K, V>(inner: List<U>, outerKeySelector: (value: T) => K, innerKeySelector: (value: U) => K, resultSelector: (value1: T, value2: List<U>) => V, __this?: any): List<V>;
        
        selectAsync<S>(selector: (value: T) => Promise<S>, __this?: any): Promise<List<S>>;
        
        selectMany2<C, V>(collectionSelector: (value: T) => List<C>, resultSelector: (value1: T, value2: C) => V, __this?: any): List<V>;
        
        orderByDescending<K>(keySelector: (value: T) => K, comparer?: IComparer<K>): List<T>;
        groupBy<K>(keySelector: (value: T) => K, __this?: any): List<Grouping<K, T>>;
        groupBy2<K>(keySelector: (value: T) => K, comparer?: IEqualityComparer<K>, __this?: any): List<Grouping<K, T>>;
        cast<S>(): List<S>;
        toDictionary<K, V>(keySelector: (item: T) => K, elementSelector: (item: T) => V): Dictionary<K, V>;
        toLookup<K>(keySelector: (value: T) => K, __this?: any): Hashtable;
        
        aggregate(func: (av: T, e: T) => T): T;
        aggregate2(seed: T, func: (av: T, e: T) => T): T;
        count2(selector?: (value: T) => boolean, __this?: any): number;
        max<S>(selector?: (value: T) => S): S;
        min<S>(selector?: (value: T) => S): S;
        sum(selector?: (value: T) => number): number;
        average(selector?: (value: T) => number): number;
        all(predicate?: (value: T) => boolean, __this?: any): boolean;
        any(predicate?: (value: T) => boolean, __this?: any): boolean;
        contains(item: T): boolean;
        
        take(count: number): List<T>;
        defaultIfEmpty(): List<T>;
        distinct(): List<T>;
        except(second: List<T>): List<T>;
        union(second: List<T>): List<T>;
        sequenceEqual(second: List<T>): boolean;
        first(selector?: (value: T) => boolean, __this?: any): T;
        firstOrDefault(predicate?: (value: T) => boolean): T;
        last(): T;
        lastOrDefault(): T;
        whereEqualsTo(values1: any, values2: any): List<any[]>;
        whereArrayItemEqualsTo(itemIndex: number, value: any): List<any[]>;
        whereArrayItemStringEqualsTo(itemIndex: number, value: string): List<any[]>;
        whereFirstOrDefaultArrayItemStringEqualsTo(itemIndex: number, value: string): any[];
        static toString2(value: any): string;
        getArrayItem(itemIndex: number): List<any[]>;
        tryCastValueOrFirstDefaultToNullableNumber(): List<number | null>;
        tryCastToNullableNumber(): List<number | null>;
        tryCastToNumber(): List<number | null>;
        tryCastToBool(): List<boolean | null>;
        tryCastToDateTime(): List<DateTime>;
        tryCastToNullableDateTime(): List<DateTime | null>;
        tryCastToTimeSpan(): List<TimeSpan>;
        tryCastToNullableTimeSpan(): List<TimeSpan | null>;
        tryCastToString(): List<string>;
        firstOrDefaultAsNullableNumber(): number | null;
        firstOrDefaultAsNumber(): number;
        firstOrDefaultAsDateTime(): DateTime;
        firstOrDefaultAsNullableDateTime(): DateTime | null;
        static getValueOrFirstOrDefault(value: any): any;
        static add2(a: any, b: any): List<any>;
        static sub(a: any, b: any): List<any>;
        static mult(a: any, b: any): List<any>;
        static bitwiseAnd(a: any, b: any): List<any>;
        static bitwiseXOr(a: any, b: any): List<any>;
        static bitwiseOr(a: any, b: any): List<any>;
        static div(a: any, b: any): List<any>;
        static logicalOr(a: any, b: any): List<any>;
        static logicalAnd(a: any, b: any): List<any>;
        sort2(): void;
    }
}
export namespace Stimulsoft.System.Collections {
    class Grouping<K, V> extends List<V> {
        key: K;
    }
}
export namespace Stimulsoft.System.Collections {
    let ICollection: ICollection<any>;
    interface ICollection<T> {
        list: T[];
        clear(): void;
        removeAt(index: number): void;
        count: number;
        length: number;
        getByIndex(index: number): T;
        toCast<C>(): C[];
    }
}
export namespace Stimulsoft.System.Collections {
    let IComparer: IComparer<any>;
    interface IComparer<T> {
        compare(x: T, y: T): number;
    }
}
export namespace Stimulsoft.System.Collections {
    let IEnumerator: Interface<IEnumerator>;
    interface IEnumerator {
        current: any;
        moveNext(): boolean;
        reset(): void;
    }
}
export namespace Stimulsoft.System.Collections {
    let IEqualityComparer: IEqualityComparer<any>;
    interface IEqualityComparer<T> {
        equals(x: T, y: T): boolean;
        getHashCode(obj: T): number;
    }
}
export namespace Stimulsoft.System.Collections {
    class Queue<T> {
        dequeue(): T;
        enqueue(item: T): void;
        get count(): number;
        clear(): void;
    }
}
export namespace Stimulsoft.System.Collections {
    class Stack<T> {
        pop(): T;
        push(item: T): void;
        clear(): void;
    }
}
export namespace Stimulsoft.System.Crypt {
    class AES {
        private key;
        private data;
        private blockSize;
        private iv;
        private prevBlock;
        private SBOX;
        private INV_SBOX;
        private SUB_MIX_0;
        private SUB_MIX_1;
        private SUB_MIX_2;
        private SUB_MIX_3;
        private INV_SUB_MIX_0;
        private INV_SUB_MIX_1;
        private INV_SUB_MIX_2;
        private INV_SUB_MIX_3;
        private RCON;
        private nRounds;
        private invKeySchedule;
        private keySchedule;
        private doReset;
        private process;
        private processBlock;
        private xorBlock;
        private pkcs7pad;
        private pkcs7Unpad;
        private encryptBlock;
        private decryptBlock;
        private doCryptBlock;
        static encrypt(text: string, key: string): string;
        private encrypt;
        static decrypt(text: string, key: string): string;
        private decrypt;
        constructor();
    }
}
export namespace Stimulsoft.System.Crypt {
    class BigInteger {
        private static BI_RM;
        private static BI_RC;
        private static dbits;
        private static lowprimes;
        private static lplim;
        static staticConstructor(): void;
        private static fromInt;
        static ZERO: BigInteger;
        static ONE: BigInteger;
        get DV(): number;
        get DB(): number;
        get DM(): number;
        private BI_FP;
        private get FV();
        private get F1();
        private get F2();
        t: number;
        s: number;
        am(i: number, x: number, w: BigInteger, j: number, c: number, n: number): number;
        static int2char(n: any): string;
        private int2char;
        private intAt;
        copyTo(r: BigInteger): void;
        private fromInt;
        static fromString(s: any, b?: number): BigInteger;
        fromString(s: any, b?: number): void;
        clamp(): void;
        toString(radix: number): string;
        private negate;
        abs(): BigInteger;
        compareTo(a: BigInteger): number;
        private nbits;
        bitLength(): number;
        dlShiftTo(n: number, r: BigInteger): void;
        drShiftTo(n: number, r: BigInteger): void;
        private lShiftTo;
        private rShiftTo;
        subTo(a: BigInteger, r: BigInteger): void;
        multiplyTo(a: BigInteger, r: BigInteger): void;
        squareTo(r: BigInteger): void;
        divRemTo(m: BigInteger, q: BigInteger, r: BigInteger): void;
        mod(a: BigInteger): BigInteger;
        invDigit(): number;
        private isEven;
        private exp;
        modPowInt(e: number, m: BigInteger): BigInteger;
        private clone;
        private intValue;
        private chunkSize;
        private signum;
        private toRadix;
        private fromRadix;
        static fromNumber(a: number, b: number, c: SecureRandom): BigInteger;
        fromNumber(a: number, b: number, c: SecureRandom): void;
        private fromNumber2;
        toByteArray(): number[];
        private bitwiseTo;
        private op_or;
        private shiftLeft;
        private shiftRight;
        private lbit;
        private getLowestSetBit;
        private testBit;
        private addTo;
        private add;
        subtract(a: BigInteger): BigInteger;
        multiply(a: BigInteger): BigInteger;
        square(): BigInteger;
        divide(a: any): BigInteger;
        private multiply2;
        addOffset2(n: number, w: number): void;
        multiplyLowerTo(a: BigInteger, n: number, r: BigInteger): void;
        multiplyUpperTo(a: BigInteger, n: number, r: BigInteger): void;
        private modPow;
        gcd(a: BigInteger): BigInteger;
        private modInt;
        modInverse(m: BigInteger): BigInteger;
        isProbablePrime(t: any): boolean;
        private millerRabin;
    }
}
export namespace Stimulsoft.System.Crypt {
    class CRC32 {
        private static _crcTable;
        private static get crcTable();
        static calculate(data: number[], text1?: string, text2?: string): number;
    }
}
export namespace Stimulsoft.System.Crypt {
    abstract class HashAlgorithm {
        computeHash(data: number[]): number[];
    }
    class SHA512 extends HashAlgorithm {
        private hashf;
        computeHash(data: number[]): number[];
        constructor();
    }
    abstract class HMAC {
        protected _key: number[];
        computeHash(data: number[]): number[];
        constructor(key: number[]);
    }
    class HMACSHA512 extends HMAC {
        private hashf;
        computeHash(data: number[]): number[];
        constructor(key: number[]);
    }
}
export namespace Stimulsoft.System.Crypt {
    class RSAKey {
        private n;
        private e;
        private d;
        private p;
        private q;
        private dmp1;
        private dmq1;
        private coeff;
        verifyString(message: string, signature: string): boolean;
        private base64toHex;
        private parseBigInt;
        private pkcs1pad2;
        private pkcs1unpad2;
        setPublic(N: string, E: string): void;
        setPrivate(N: string, E: string, D: string): void;
        setPrivateEx(N: string, E: string, D: string, P: string, Q: string, DP: string, DQ: string, C: string): void;
        generate(B: number, E: string): void;
        doPublic(x: BigInteger): BigInteger;
        private doPrivate;
        encrypt(text: string): string;
        decrypt(ctext: string): string;
        constructor();
    }
}
export namespace Stimulsoft.System.Crypt {
    class SHA1 {
        private blockLength;
        private state;
        private K;
        static signature: string;
        static hex(data: string): string;
        hex(data: string): string;
        bytes(data: number[]): number[];
        private getMD;
        private rotl;
        private round;
        private paddingData;
        private toHex;
        private fromBigEndian32;
        private toBigEndian32;
        private unpack;
    }
}
export namespace Stimulsoft.System.Crypt {
    class SHA2 {
        private static HASH_224;
        private static HASH_256;
        private static HASH_384;
        private static HASH_512;
        private static HASH_512_224;
        private static HASH_512_256;
        private static ROUNDS_256;
        private static ROUNDS_512;
        private static HEX_DIGITS;
        private rotate;
        private sigma;
        private sum;
        private aggregate;
        private conglomerate;
        private compress;
        private hash;
        SHA2_224(sData: string): string;
        SHA2_256(sData: string | number[]): string | number[];
        SHA2_384(sData: string | number[]): string | number[];
        SHA2_512(sData: string | number[]): string | number[];
        SHA2_512_224(sData: string): string;
        SHA2_512_256(sData: string): string;
        static SHA256(sData: number[]): number[];
    }
}
export namespace Stimulsoft.System.Crypt {
    class SecureRandom {
        private state;
        private pool;
        private position;
        private seedInteger;
        private seedTime;
        private getByte;
        nextBytes(ba: number[], count?: number): void;
        createNextBytes(count: number): number[];
        constructor();
    }
}
export namespace Stimulsoft.ExternalLibrary.aesjs.ModeOfOperation {
    class cbc {
        encrypt(data: number[]): Uint8Array | number[];
        decrypt(data: number[]): Uint8Array | number[];
        constructor(key: number[], iv: number[]);
    }
    class ecb {
        encrypt(data: number[]): Uint8Array | number[];
        decrypt(data: number[]): Uint8Array | number[];
        constructor(key: number[]);
    }
}
export namespace Stimulsoft.ExternalLibrary.aesjs.padding.pkcs7 {
    class pad extends Array {
        constructor(forEncrypt: number[]);
    }
}
export namespace Stimulsoft.System.Data {
    class DataStorage {
        values: any[];
        private _column;
        static createStorage(column: DataColumn, type: Type): DataStorage;
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
export namespace Stimulsoft.System.Data {
    class BooleanStorage extends DataStorage {
        setValue(recordNo: number, value: any): void;
    }
}
export namespace Stimulsoft.System.Data {
    class ByteArrayStorage extends DataStorage {
    }
}
export namespace Stimulsoft.System.Data {
    class CharStorage extends DataStorage {
        setValue(recordNo: number, value: any): void;
    }
}
export namespace Stimulsoft.System.Data {
    class DBNull {
        static value: DBNull;
    }
}
export namespace Stimulsoft.System.Data {
    class DataColumn {
        clone(): DataColumn;
        private _caption;
        get caption(): string;
        set caption(value: string);
        storage: DataStorage;
        columnName: string;
        dataType: Type;
        table: DataTable;
        getRecord(record: number): any;
        setRecord(record: number, value: any): void;
        setTable(table: DataTable): void;
        delete(): void;
        private insureStorage;
        changeType(dataType: Type): void;
        constructor(columnName: string, dataType?: Type, caption?: string);
    }
}
export namespace Stimulsoft.System.Data {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class DataColumnCollection extends CollectionBase<DataColumn> {
        table: DataTable;
        private baseAdd;
        private baseRemove;
        add(column: DataColumn): void;
        contains(columnName: string): boolean;
        remove(column: DataColumn): void;
        removeByName(name: string): void;
        hashNames: Map<string, DataColumn>;
        getByName(name: string): DataColumn;
        getIndexByName(name: string): number;
        constructor(table: DataTable);
    }
}
export namespace Stimulsoft.System.Data {
    class DataKey {
        columns: DataColumn[];
        get table(): DataTable;
        get columnsReference(): any[];
        getKeyValues(record: number): any[];
        getRows(values: any[], valueColumns: DataColumn[]): any[];
        toArray(): any[];
        constructor(columns: DataColumn[], copyColumns: boolean);
    }
}
export namespace Stimulsoft.System.Data {
    class DataRelation {
        childKey: DataKey;
        parentKey: DataKey;
        dataSet: DataSet;
        relationName: string;
        get parentTable(): DataTable;
        get childTable(): DataTable;
        get parentColumns(): any[];
        get childColumns(): any[];
        private create;
        setDataSet(dataSet: DataSet): void;
        static getChildRows(parentKey: DataKey, childKey: DataKey, parentRow: DataRow): any[];
        static getParentRows(parentKey: DataKey, childKey: DataKey, childRow: DataRow): any[];
        constructor(relationName: string, parentColumns: DataColumn[], childColumns: DataColumn[]);
    }
}
export namespace Stimulsoft.System.Data {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class DataRelationCollection extends CollectionBase<DataRelation> {
        addCore(relation: DataRelation): void;
        add(relation: DataRelation): void;
        addRange(relations: any[]): void;
        internalIndexOf(name: string): number;
        contains(name: string): boolean;
        getByName(name: string): DataRelation;
        getDataSet(): DataSet;
    }
}
export namespace Stimulsoft.System.Data {
    import List = Stimulsoft.System.Collections.List;
    class DataRow {
        _recordIndex: number;
        get recordIndex(): number;
        static create(table: DataTable): DataRow;
        columns: DataColumnCollection;
        table: DataTable;
        private getColumnIndex;
        gett(column: any): any;
        sett(column: any, value: any): void;
        get itemArray(): any[];
        getValue(column: any): any;
        setValue(column: any, value: any): void;
        getValueByIndex(columnIndex: number): any;
        setValueByIndex(columnIndex: number, value: any): void;
        getDataColumn(columnName: string): DataColumn;
        getChildRows(relationName: string): any[];
        getParentRow(relationName: string): DataRow;
        getParentRows(relationName: string): any[];
        getKeyValues(key: DataKey): any[];
        static copyToDataTable(source: List<DataRow>): DataTable;
    }
}
export namespace Stimulsoft.System.Data {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class DataRowCollection extends CollectionBase<DataRow> {
        table: DataTable;
        add(row: DataRow): number;
        remove(row: DataRow): void;
        addArray(row: DataRow): number;
        removeArray(row: DataRow): void;
        copyTo(array: any[], startIndex: number): void;
        sort(...parameters: any[]): any;
        gett(rowIndex: number, columnIndex: number): any;
        constructor(table: DataTable);
    }
}
export namespace Stimulsoft.System.Text {
    class XMLConvert {
        static encodeName(name: string): string;
        static decodeName(name: string): string;
        private static fromHex;
        private static toHex;
    }
}
export namespace Stimulsoft.System.Xml {
    class XmlNode {
        nodeName: string;
        nodeType: XmlNodeType;
        childNodes: XmlNode[];
        localName: string;
        textContent: string;
        get firstChild(): XmlNode;
        attributes: XmlAttrCollection;
        parentNode: XmlNode;
        setParentNode(node: XmlNode): void;
        getAttribute(name?: string): string;
        item(index: number): XmlNode;
        getNodeByName(name?: string): XmlNode;
        getNodesByName(name?: string): XmlNode[];
    }
}
export namespace Stimulsoft.System.Xml {
    class XmlAttr {
        name: string;
        value: string;
    }
}
export namespace Stimulsoft.System.Xml {
    enum XmlNodeType {
        ATTRIBUTE_NODE = 0,
        ELEMENT_NODE = 1,
        TEXT_NODE = 2,
        DOCUMENT_NODE = 3
    }
}
export namespace Stimulsoft.System.Xml {
    class XmlConverter {
        static toXml(xmlString: string, decodeTagNames?: boolean): XmlNode;
        static toXml2(xmlString: string, decodeTagNames?: boolean): XmlNode;
        private static toXmlNode2;
        private static toXmlNode;
        static getXmlDocumentFromString(xmlString: string): any;
        static getAttributesArray(xmlDocument: any): any[];
        static getNodeType2(xmlDocument: any): number;
        static getNodeType(xmlDocument: any): number;
        static getNodeName(xmlDocument: any): string;
        static getNodeLocalName2(xmlDocument: {
            name: string;
        }): string;
        static getNodeLocalName(xmlDocument: any): string;
        static getText(str: string): string;
        static getChildNodesArray(xmlDocument: any): any[];
    }
}
export namespace Stimulsoft.System.Data {
    enum JsonRelationDirection {
        ChildToParent = 0,
        ParentToChild = 1
    }
    class DataSet {
        private dataNode;
        private schemaNode;
        private isRetrieveColumns;
        private structureFromSchema;
        dataSetName: string;
        tables: DataTableCollection;
        relations: DataRelationCollection;
        enforceConstraints: boolean;
        private complexTypeNodes;
        private _tryParseDateTime;
        get tryParseDateTime(): boolean;
        set tryParseDateTime(value: boolean);
        static tryParseDateTime: boolean;
        dispose(): void;
        private correctJsonString;
        private correctArray;
        private correctJson;
        readJsonFile(filePath: string, jsonRelationDirection?: JsonRelationDirection, maxDataRows?: number): void;
        readJson(param: string | number[] | Uint8Array | any, jsonRelationDirection?: JsonRelationDirection, maxDataRows?: number): void;
        private fillCollection;
        private processObject2;
        readXmlAsJson(param: string | number[] | Uint8Array | any, relationDirection: JsonRelationDirection, maxDataRows?: number): void;
        private static convertXmlToJsObject;
        readXmlFile(filePath: string, maxDataRows?: number): void;
        readXml(param: string | number[] | Uint8Array | any, maxDataRows?: number): void;
        readXmlSchemaFile(filePath: string): void;
        readXmlSchema(param: string | number[] | any): void;
        private fillDataSet;
        private parseSchema;
        private parseAdoNetSchema;
        private extractKey;
        private extractReference;
        private extractRelationsFromAdoNetRelationships;
        private parseUnknownSchema;
        private extractTableFromElementNode;
        private extractColumnsFromComplexTypeNode;
        private extractColumnFromElementNode;
        private inferSchemaFromData;
        private inferTableFromNode;
        private inferColumnsFromNode;
        private inferColumnFromNode;
        private fillTable;
        private fillRow;
        private addNodeValueToRowIntoColumn;
        private linkTables;
        private getStorageTypeOrDefault;
        private findTable;
        private findColumns;
        writeXml(writeSchema?: boolean): string;
        private writeXsd;
        private getTypeFromStorageType;
        constructor(dataSetName?: string);
    }
}
export namespace Stimulsoft.System.Data {
    class DataSetRelationCollection extends DataRelationCollection {
        private dataSet;
        addCore(relation: DataRelation): void;
        getDataSet(): DataSet;
        constructor(dataSet: DataSet);
    }
}
export namespace Stimulsoft.System.Data {
    import List = Stimulsoft.System.Collections.List;
    class DataTable {
        private needCleanCache;
        private _index;
        get index(): any[];
        columns: DataColumnCollection;
        rows: DataRowCollection;
        tableName: string;
        dataSet: DataSet;
        defaultView: DataView;
        private _childRelations;
        get childRelations(): DataRelationCollection;
        set childRelations(value: DataRelationCollection);
        private _parentRelations;
        get parentRelations(): DataRelationCollection;
        set parentRelations(value: DataRelationCollection);
        setDataSet(dataSet: DataSet): void;
        addRow(row: DataRow): number;
        removeRow(row: DataRow): void;
        addNewRow(): DataRow;
        extendedProperties: any;
        newRow(): DataRow;
        clone(): DataTable;
        copy(): DataTable;
        toList(): List<DataColumn>;
        loadDataRow(values: any[], acceptChanges?: boolean): DataRow;
        constructor(tableName?: string);
    }
}
export namespace Stimulsoft.System.Data {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class DataTableCollection extends CollectionBase<DataTable> {
        add(table: DataTable): void;
        remove(table: DataTable): void;
        private baseAdd;
        private baseRemove;
        dataSet: DataSet;
        getByName(name: string): DataTable;
        private checkTableName;
        constructor(dataSet: DataSet);
    }
}
export namespace Stimulsoft.System.Data {
    class DataTableRelationCollection extends DataRelationCollection {
        private table;
        private parentCollection;
        private addCache;
        addCore(relation: DataRelation): void;
        getDataSet(): DataSet;
        constructor(table: DataTable, parentCollection: boolean);
    }
}
export namespace Stimulsoft.System.Data {
    class DataView {
        clone(): DataView;
        rowFilter: string;
        sort: string;
        table: DataTable;
        toTable(throw1?: boolean): DataTable;
        private filter;
        constructor(table: DataTable);
    }
}
export namespace Stimulsoft.System.Data {
    class DateTimeStorage extends DataStorage {
        setValue(recordNo: number, value: any): void;
    }
}
export namespace Stimulsoft.System.Data {
    enum DbType {
        AnsiString = 0,
        Binary = 1,
        Byte = 2,
        Boolean = 3,
        Currency = 4,
        Date = 5,
        DateTime = 6,
        Decimal = 7,
        Double = 8,
        Guid = 9,
        Int16 = 10,
        Int32 = 11,
        Int64 = 12,
        Object = 13,
        SByte = 14,
        Single = 15,
        String = 16,
        Time = 17,
        UInt16 = 18,
        UInt32 = 19,
        UInt64 = 20,
        VarNumeric = 21,
        AnsiStringFixedLength = 22,
        StringFixedLength = 23,
        Xml = 25,
        DateTime2 = 26,
        DateTimeOffset = 27
    }
}
export namespace Stimulsoft.System.Data {
    class NumberStorage extends DataStorage {
        setValue(recordNo: number, value: any): void;
    }
}
export namespace Stimulsoft.System.Data {
    class ObjectStorage extends DataStorage {
    }
}
export namespace Stimulsoft.System.Data {
    enum StorageType {
        ObjectType = 1,
        BooleanType = 3,
        CharType = 4,
        SByteType = 5,
        ByteType = 6,
        Number16Type = 7,
        Unumber16Type = 8,
        NumberType = 9,
        Number32Type = 9,
        Unumber32Type = 10,
        Number64Type = 11,
        Unumber64Type = 12,
        SingleType = 13,
        DoubleType = 14,
        DecimalType = 15,
        DateTimeType = 16,
        TimeSpanType = 17,
        StringType = 18,
        GuidType = 19,
        ByteArrayType = 20,
        IntType = 30,
        Int16Type = 31,
        Int32Type = 32,
        Int64Type = 33,
        UInt16Type = 34,
        UInt32Type = 35,
        UInt64Type = 36
    }
}
export namespace Stimulsoft.System.Data {
    class StringStorage extends DataStorage {
        setValue(recordNo: number, value: any): void;
    }
}
export namespace Stimulsoft.System.Data {
    class TimeSpanStorage extends DataStorage {
        setValue(recordNo: number, value: any): void;
    }
}
export namespace Stimulsoft.System.Drawing {
    import IAsIs = Stimulsoft.System.IAsIs;
    class Brush implements IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
    }
}
export namespace Stimulsoft.System.Drawing {
    class Brushes {
        static get aliceBlue(): Brush;
        static get antiqueWhite(): Brush;
        static get aqua(): Brush;
        static get aquamarine(): Brush;
        static get azure(): Brush;
        static get beige(): Brush;
        static get bisque(): Brush;
        static get black(): Brush;
        static get blanchedAlmond(): Brush;
        static get blue(): Brush;
        static get blueViolet(): Brush;
        static get brown(): Brush;
        static get burlyWood(): Brush;
        static get cadetBlue(): Brush;
        static get chartreuse(): Brush;
        static get chocolate(): Brush;
        static get coral(): Brush;
        static get cornflowerBlue(): Brush;
        static get cornsilk(): Brush;
        static get crimson(): Brush;
        static get cyan(): Brush;
        static get darkBlue(): Brush;
        static get darkCyan(): Brush;
        static get darkGoldenrod(): Brush;
        static get darkGray(): Brush;
        static get darkGreen(): Brush;
        static get darkKhaki(): Brush;
        static get darkMagenta(): Brush;
        static get darkOliveGreen(): Brush;
        static get darkOrange(): Brush;
        static get darkOrchid(): Brush;
        static get darkRed(): Brush;
        static get darkSalmon(): Brush;
        static get darkSeaGreen(): Brush;
        static get darkSlateBlue(): Brush;
        static get darkSlateGray(): Brush;
        static get darkTurquoise(): Brush;
        static get darkViolet(): Brush;
        static get deepPink(): Brush;
        static get deepSkyBlue(): Brush;
        static get dimGray(): Brush;
        static get dodgerBlue(): Brush;
        static get firebrick(): Brush;
        static get floralWhite(): Brush;
        static get forestGreen(): Brush;
        static get fuchsia(): Brush;
        static get gainsboro(): Brush;
        static get ghostWhite(): Brush;
        static get gold(): Brush;
        static get goldenrod(): Brush;
        static get gray(): Brush;
        static get green(): Brush;
        static get greenYellow(): Brush;
        static get honeydew(): Brush;
        static get hotPink(): Brush;
        static get indianRed(): Brush;
        static get indigo(): Brush;
        static get ivory(): Brush;
        static get khaki(): Brush;
        static get lavender(): Brush;
        static get lavenderBlush(): Brush;
        static get lawnGreen(): Brush;
        static get lemonChiffon(): Brush;
        static get lightBlue(): Brush;
        static get lightCoral(): Brush;
        static get lightCyan(): Brush;
        static get lightGoldenrodYellow(): Brush;
        static get lightGray(): Brush;
        static get lightGreen(): Brush;
        static get lightPink(): Brush;
        static get lightSalmon(): Brush;
        static get lightSeaGreen(): Brush;
        static get lightSkyBlue(): Brush;
        static get lightSlateGray(): Brush;
        static get lightSteelBlue(): Brush;
        static get lightYellow(): Brush;
        static get lime(): Brush;
        static get limeGreen(): Brush;
        static get linen(): Brush;
        static get magenta(): Brush;
        static get maroon(): Brush;
        static get mediumAquamarine(): Brush;
        static get mediumBlue(): Brush;
        static get mediumOrchid(): Brush;
        static get mediumPurple(): Brush;
        static get mediumSeaGreen(): Brush;
        static get mediumSlateBlue(): Brush;
        static get mediumSpringGreen(): Brush;
        static get mediumTurquoise(): Brush;
        static get mediumVioletRed(): Brush;
        static get midnightBlue(): Brush;
        static get mintCream(): Brush;
        static get mistyRose(): Brush;
        static get moccasin(): Brush;
        static get navajoWhite(): Brush;
        static get navy(): Brush;
        static get oldLace(): Brush;
        static get olive(): Brush;
        static get oliveDrab(): Brush;
        static get orange(): Brush;
        static get orangeRed(): Brush;
        static get orchid(): Brush;
        static get paleGoldenrod(): Brush;
        static get paleGreen(): Brush;
        static get paleTurquoise(): Brush;
        static get paleVioletRed(): Brush;
        static get papayaWhip(): Brush;
        static get peachPuff(): Brush;
        static get peru(): Brush;
        static get pink(): Brush;
        static get plum(): Brush;
        static get powderBlue(): Brush;
        static get purple(): Brush;
        static get red(): Brush;
        static get rosyBrown(): Brush;
        static get royalBlue(): Brush;
        static get saddleBrown(): Brush;
        static get salmon(): Brush;
        static get sandyBrown(): Brush;
        static get seaGreen(): Brush;
        static get seaShell(): Brush;
        static get sienna(): Brush;
        static get silver(): Brush;
        static get skyBlue(): Brush;
        static get slateBlue(): Brush;
        static get slateGray(): Brush;
        static get snow(): Brush;
        static get springGreen(): Brush;
        static get steelBlue(): Brush;
        static get tan(): Brush;
        static get teal(): Brush;
        static get thistle(): Brush;
        static get tomato(): Brush;
        static get turquoise(): Brush;
        static get violet(): Brush;
        static get wheat(): Brush;
        static get white(): Brush;
        static get whiteSmoke(): Brush;
        static get yellow(): Brush;
        static get yellowGreen(): Brush;
    }
}
export namespace Stimulsoft.System.Drawing {
    class Color {
        private static colorCache;
        static aliceBlue: Color;
        static antiqueWhite: Color;
        static aqua: Color;
        static aquamarine: Color;
        static azure: Color;
        static beige: Color;
        static bisque: Color;
        static black: Color;
        static blanchedAlmond: Color;
        static blue: Color;
        static blueViolet: Color;
        static brown: Color;
        static burlyWood: Color;
        static cadetBlue: Color;
        static chartreuse: Color;
        static chocolate: Color;
        static coral: Color;
        static cornflowerBlue: Color;
        static cornsilk: Color;
        static crimson: Color;
        static cyan: Color;
        static darkBlue: Color;
        static darkCyan: Color;
        static darkGoldenrod: Color;
        static darkGray: Color;
        static darkGreen: Color;
        static darkKhaki: Color;
        static darkMagenta: Color;
        static darkOliveGreen: Color;
        static darkOrange: Color;
        static darkOrchid: Color;
        static darkRed: Color;
        static darkSalmon: Color;
        static darkSeaGreen: Color;
        static darkSlateBlue: Color;
        static darkSlateGray: Color;
        static darkTurquoise: Color;
        static darkViolet: Color;
        static deepPink: Color;
        static deepSkyBlue: Color;
        static dimGray: Color;
        static dodgerBlue: Color;
        static firebrick: Color;
        static floralWhite: Color;
        static forestGreen: Color;
        static fuchsia: Color;
        static gainsboro: Color;
        static ghostWhite: Color;
        static gold: Color;
        static goldenrod: Color;
        static gray: Color;
        static green: Color;
        static greenYellow: Color;
        static honeydew: Color;
        static hotPink: Color;
        static indianRed: Color;
        static indigo: Color;
        static ivory: Color;
        static khaki: Color;
        static lavender: Color;
        static lavenderBlush: Color;
        static lawnGreen: Color;
        static lemonChiffon: Color;
        static lightBlue: Color;
        static lightCoral: Color;
        static lightCyan: Color;
        static lightGoldenrodYellow: Color;
        static lightGray: Color;
        static lightGreen: Color;
        static lightPink: Color;
        static lightSalmon: Color;
        static lightSeaGreen: Color;
        static lightSkyBlue: Color;
        static lightSlateGray: Color;
        static lightSteelBlue: Color;
        static lightYellow: Color;
        static lime: Color;
        static limeGreen: Color;
        static linen: Color;
        static magenta: Color;
        static maroon: Color;
        static mediumAquamarine: Color;
        static mediumBlue: Color;
        static mediumOrchid: Color;
        static mediumPurple: Color;
        static mediumSeaGreen: Color;
        static mediumSlateBlue: Color;
        static mediumSpringGreen: Color;
        static mediumTurquoise: Color;
        static mediumVioletRed: Color;
        static midnightBlue: Color;
        static mintCream: Color;
        static mistyRose: Color;
        static moccasin: Color;
        static navajoWhite: Color;
        static navy: Color;
        static oldLace: Color;
        static olive: Color;
        static oliveDrab: Color;
        static orange: Color;
        static orangeRed: Color;
        static orchid: Color;
        static paleGoldenrod: Color;
        static paleGreen: Color;
        static paleTurquoise: Color;
        static paleVioletRed: Color;
        static papayaWhip: Color;
        static peachPuff: Color;
        static peru: Color;
        static pink: Color;
        static plum: Color;
        static powderBlue: Color;
        static purple: Color;
        static red: Color;
        static rosyBrown: Color;
        static royalBlue: Color;
        static saddleBrown: Color;
        static salmon: Color;
        static sandyBrown: Color;
        static seaGreen: Color;
        static seaShell: Color;
        static sienna: Color;
        static silver: Color;
        static skyBlue: Color;
        static slateBlue: Color;
        static slateGray: Color;
        static snow: Color;
        static springGreen: Color;
        static steelBlue: Color;
        static tan: Color;
        static teal: Color;
        static thistle: Color;
        static tomato: Color;
        static turquoise: Color;
        static violet: Color;
        static wheat: Color;
        static white: Color;
        static whiteSmoke: Color;
        static yellow: Color;
        static yellowGreen: Color;
        static transparent: Color;
        static empty: Color;
        static fromName(name: string): Color;
        readonly a: number;
        readonly r: number;
        readonly g: number;
        readonly b: number;
        readonly name: string;
        private constructor();
        private static customName;
        get isNamedColor(): boolean;
        equals(color: Color): boolean;
        toString(): string;
        static fromArgb(alpha: number, red: number, green: number, blue: number): Color;
        static fromArgb2(red: number, green: number, blue: number): Color;
        static fromArgb3(alpha: number, color: Color): Color;
        changeAlpha(alpha: number): Color;
        toArgb(): number;
        getBrightness(): number;
        getHashCode(): number;
        is(type: any): this is Color;
        is2(type: any): boolean;
        as(type: any): this;
        over(other: Color): Color;
    }
}
export namespace Stimulsoft.System.Drawing {
    class ColorTranslator {
        private static colorCache;
        static toHtml(color: Color): string;
        static toHtml2(color: Color, useNamedColor: boolean): string;
        static fromHtml(text: string): Color;
    }
}
export namespace Stimulsoft.System.Drawing {
    enum ContentAlignment {
        TopLeft = 1,
        TopCenter = 2,
        TopRight = 4,
        MiddleLeft = 16,
        MiddleCenter = 32,
        MiddleRight = 64,
        BottomLeft = 256,
        BottomCenter = 512,
        BottomRight = 1024
    }
}
export namespace Stimulsoft.System.Drawing {
    class Font implements ICloneable {
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        fontFamily: FontFamily;
        get name(): string;
        size: number;
        get sizeInPoints(): number;
        style: FontStyle;
        unit: GraphicsUnit;
        get bold(): boolean;
        get italic(): boolean;
        get strikeout(): boolean;
        get underline(): boolean;
        private _toString;
        toString(): string;
        private _height;
        getHeight(): number;
        private hashCode;
        getHashCode(): number;
        constructor(family?: string, emSize?: number, style?: FontStyle, unit?: GraphicsUnit);
    }
}
export namespace Stimulsoft.System.Drawing {
    class FontFamily {
        private static _families;
        static get families(): FontFamily[];
        name: string;
        isStyleAvailable(style: FontStyle): boolean;
        static cleanFamilies(): void;
        constructor(name: string);
    }
}
export namespace Stimulsoft.System.Drawing {
    class FontResources {
        static getSize(font: Font, text: string): Size;
        private static _standardFontWidths;
        static get standardFontWidths(): any[];
        private static _standardFontInfo;
        static get standardFontInfo(): any[];
        private static family_Helvetica;
        private static family_Courier;
        private static family_Times_Roman;
    }
}
export namespace Stimulsoft.System.Drawing {
    enum FontStyle {
        Regular = 0,
        Bold = 1,
        Italic = 2,
        Strikeout = 4,
        Underline = 8
    }
}
export namespace Stimulsoft.System.Drawing.Drawing2D {
    import Point = Stimulsoft.System.Drawing.Point;
    class Matrix {
        private a;
        private c;
        private b;
        private d;
        private tx;
        private ty;
        get elements(): number[];
        constructor(...arg: any[]);
        private setValues;
        private reset;
        clone(): Matrix;
        toString(): string;
        translate(x: number, y: number): Matrix;
        scale(scaleX: number, scaleY: number): Matrix;
        rotate(angle: number): Matrix;
        isIdentity(): boolean;
        transformPoints(points: Point[]): void;
        multiply(matrix2: Matrix): this;
        multiplyAppend(mx: Matrix): this;
        multiplyPrepend(mx: Matrix): this;
    }
}
export namespace Stimulsoft.System.Drawing {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import FontKitType = Stimulsoft.ExternalLibrary.Fontkit.FontKitType;
    type CustomFontType = {
        font: any;
        data: any;
        filePath: string;
        autoLoad?: boolean;
        used?: boolean;
    };
    export class Graphics {
        private context;
        static measureBearingScale: number;
        drawImage(image: Image, point: Point): void;
        drawRectangle(pen: Pen, rect: Rectangle): void;
        fillRectangle(brush: Brush, x: number, y: number, width: number, height: number): void;
        drawLine(pen: Pen, x1: number, y1: number, x2: number, y2: number): void;
        drawString(text: string, font: Font, brush: Brush, x: number, y: number): void;
        translateTransform(dx: number, dy: number): void;
        static customFonts: Hashtable<string, Hashtable<FontStyle, CustomFontType>>;
        static getCustomFont(fontName: string, fontStyle: FontStyle): any;
        static clearAutoLoadFonts(): void;
        static addCustomFont(font: FontKitType, fontName?: string, binFont?: any, filePath?: string, fontStyle?: FontStyle, store?: boolean): void;
        static addCustomFontFile(filePath: string, fontName?: string, fontStyle?: FontStyle, store?: boolean): void;
        static addCustomFontFileAsync(callback: () => void, filePath: string, fontName?: string, fontStyle?: FontStyle, store?: boolean): void;
        static addCustomFontBytes(data: ArrayBuffer | Uint8Array, fontName?: string, fontStyle?: FontStyle, store?: boolean): void;
        static getFontMimeType(data: any): string;
        static getCustomFontsCss(embeddedData?: boolean): string;
        static getCustomFontName(fontName: string, fontStyle: FontStyle): string;
        static allowStyle(fontName: string, fontStyle: FontStyle): boolean;
        private static measureDiv;
        private static measureHash;
        static measureString(text: string, font: Font, width?: number, useCache?: boolean, multiple?: number, angle?: number, replaceTags?: boolean): Size;
        private static isWordWrapSymbol;
        static measureChars(chars: number[], count: number, font: Font): Size;
        private static rotate;
        private static getMeasureDiv;
        private static lineHeightFactorHash;
        static getLineHeightFactor(font: string | Font): number;
        static clearCache(): void;
        constructor(context: CanvasRenderingContext2D);
    }
    export {};
}
export namespace Stimulsoft.System.Drawing {
    enum GraphicsUnit {
        Pixel = 2,
        Point = 3
    }
}
export namespace Stimulsoft.System.Drawing.Imaging {
    type ImageInfo = {
        width: number;
        height: number;
        horizontalResolution: number;
        verticalResolution: number;
    };
    export class ImageFormat {
        private static _tiff;
        static get Tiff(): ImageFormat;
        private static _png;
        static get Png(): ImageFormat;
        private static _gif;
        static get Gif(): ImageFormat;
        private static _jpeg;
        static get Jpeg(): ImageFormat;
        private static getBytes;
        private static getJpegInfo;
        private static parseTiffHeaderForOrientation;
        private static readTagValue;
        private static readWord;
        private static readDWord;
        private static _bmp;
        static get Bmp(): ImageFormat;
        private static _svg;
        static get Svg(): ImageFormat;
        static getImageFormat(dataBytes: number[]): ImageFormat;
        private header;
        private guid;
        private checkHeader;
        getInfo(data: {
            bytes: number[];
            base64: string;
            svg: string;
        }): ImageInfo;
        get mimeType(): string;
        toString(): string;
        constructor(guid: string);
    }
    export {};
}
export namespace Stimulsoft.System.Drawing {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import ImageFormat = Stimulsoft.System.Drawing.Imaging.ImageFormat;
    class Image {
        data: any;
        imageFormat: ImageFormat;
        imageData: any;
        private _width;
        get width(): number;
        private _height;
        get height(): number;
        private _horizontalResolution;
        get horizontalResolution(): number;
        private _verticalResolution;
        get verticalResolution(): number;
        private fillImageInfo;
        get base64(): string;
        set base64(value: string);
        get bytes(): number[];
        set bytes(value: number[]);
        get svg(): string;
        set svg(value: string);
        static fromFile(path: string, headers: Header[]): Image;
        static fromBytes(bytes: number[]): Image;
        static fromBase64(base64: string): Image;
        private setData;
        convertAsync(imageFormat: ImageFormat, flate?: boolean, rect?: Rectangle, reconvert?: boolean, hashTable?: Hashtable): Promise<void>;
        private static convertInternal;
        tryConvertSync(imageFormat: ImageFormat): boolean;
        private getHash;
        dispose(): void;
        clone(): Image;
        aspectRatio: boolean;
        multipleFactor: number;
        margins: {
            left: number;
            right: number;
            top: number;
            bottom: number;
            isEmpty: boolean;
        };
        horAlignment: number;
        vertAlignment: number;
        imageRotation: number;
        stretch: boolean;
        zoom: number;
        url: string;
        headers: Header[];
        constructor(width?: number, height?: number);
    }
}
export namespace Stimulsoft.System.Drawing {
    enum Orientation {
        Horizontal = 0,
        Vertical = 1
    }
}
export namespace Stimulsoft.System.Drawing {
    import LineCap = Stimulsoft.System.Drawing.Drawing2D.LineCap;
    import DashStyle = Stimulsoft.System.Drawing.Drawing2D.DashStyle;
    class Pen {
        brush: Brush;
        color: Color;
        endCap: LineCap;
        startCap: LineCap;
        width: number;
        dashStyle: DashStyle;
        lineJoin: string;
        constructor(color: Color, width?: number);
    }
}
export namespace Stimulsoft.System.Drawing {
    class Point {
        x: number;
        y: number;
        get isEmpty(): boolean;
        static get empty(): Point;
        toString(): string;
        equals(point: Point): boolean;
        static convertFromXml(text: string): Point;
        constructor(x?: number, y?: number);
    }
}
export namespace Stimulsoft.System.Drawing {
    class Rectangle {
        static fromLTRB(left: number, top: number, right: number, bottom: number): Rectangle;
        static get empty(): Rectangle;
        static union(a: Rectangle, b: Rectangle): Rectangle;
        static convertFromXml(text: string): Rectangle;
        static round(value: Rectangle): Rectangle;
        clone(): Rectangle;
        inflate(width: number, height: number): Rectangle;
        normalize(): Rectangle;
        multiply(multipleFactor: number): Rectangle;
        offset(x: number, y: number): Rectangle;
        offsetRect(offsettingRectangle: Rectangle): Rectangle;
        intersectsWith(rect: Rectangle): boolean;
        alignToGrid(gridSize: number, aligningToGrid: boolean): Rectangle;
        fitToRectangle(rectangle: Rectangle): Rectangle;
        get isEmpty(): boolean;
        get isEmptyF(): boolean;
        contains(x: number, y: number): boolean;
        x: number;
        y: number;
        width: number;
        height: number;
        get left(): number;
        set left(value: number);
        get top(): number;
        set top(value: number);
        get right(): number;
        set right(value: number);
        get bottom(): number;
        set bottom(value: number);
        get location(): Point;
        set location(value: Point);
        get size(): Size;
        set size(value: Size);
        toString(): string;
        constructor(x?: number, y?: number, width?: number, height?: number);
    }
}
export namespace Stimulsoft.System.Drawing {
    class Size {
        static get empty(): Size;
        width: number;
        height: number;
        get isEmpty(): boolean;
        swap(): Size;
        round(digits?: number): Size;
        multiply(multipleFactor: number): Size;
        static convertFromXml(text: string): Size;
        constructor(width: number, height: number);
    }
}
export namespace Stimulsoft.System.Drawing {
    class SolidBrush extends Brush {
        color: Color;
        constructor(color: Color);
    }
}
export namespace Stimulsoft.System.Drawing {
    enum StringAlignment {
        Near = 0,
        Center = 1,
        Far = 2
    }
}
export namespace Stimulsoft.System.Drawing {
    import HotkeyPrefix = Stimulsoft.System.Drawing.Text.HotkeyPrefix;
    class StringFormat {
        alignment: StringAlignment;
        formatFlags: StringFormatFlags;
        hotkeyPrefix: HotkeyPrefix;
        lineAlignment: StringAlignment;
        trimming: StringTrimming;
    }
}
export namespace Stimulsoft.System.Drawing {
    enum StringFormatFlags {
        None = 0,
        DirectionRightToLeft = 1,
        DirectionVertical = 2,
        FitBlackBox = 4,
        DisplayFormatControl = 32,
        NoFontFallback = 1024,
        MeasureTrailingSpaces = 2048,
        NoWrap = 4096,
        LineLimit = 8192,
        NoClip = 16384
    }
}
export namespace Stimulsoft.System.Drawing {
    enum StringTrimming {
        None = 0,
        Character = 1,
        Word = 2,
        EllipsisCharacter = 3,
        EllipsisWord = 4,
        EllipsisPath = 5
    }
}
export namespace Stimulsoft.System.Drawing.Drawing2D {
    enum DashStyle {
        Solid = 0,
        Dash = 1,
        Dot = 2,
        DashDot = 3,
        DashDotDot = 4,
        Custom = 5
    }
}
export namespace Stimulsoft.System.Drawing.Drawing2D {
    enum HatchStyle {
        Min = 0,
        Horizontal = 0,
        Vertical = 1,
        ForwardDiagonal = 2,
        BackwardDiagonal = 3,
        Max = 4,
        Cross = 4,
        LargeGrid = 4,
        DiagonalCross = 5,
        Percent05 = 6,
        Percent10 = 7,
        Percent20 = 8,
        Percent25 = 9,
        Percent30 = 10,
        Percent40 = 11,
        Percent50 = 12,
        Percent60 = 13,
        Percent70 = 14,
        Percent75 = 15,
        Percent80 = 16,
        Percent90 = 17,
        LightDownwardDiagonal = 18,
        LightUpwardDiagonal = 19,
        DarkDownwardDiagonal = 20,
        DarkUpwardDiagonal = 21,
        WideDownwardDiagonal = 22,
        WideUpwardDiagonal = 23,
        LightVertical = 24,
        LightHorizontal = 25,
        NarrowVertical = 26,
        NarrowHorizontal = 27,
        DarkVertical = 28,
        DarkHorizontal = 29,
        DashedDownwardDiagonal = 30,
        DashedUpwardDiagonal = 31,
        DashedHorizontal = 32,
        DashedVertical = 33,
        SmallConfetti = 34,
        LargeConfetti = 35,
        ZigZag = 36,
        Wave = 37,
        DiagonalBrick = 38,
        HorizontalBrick = 39,
        Weave = 40,
        Plaid = 41,
        Divot = 42,
        DottedGrid = 43,
        DottedDiamond = 44,
        Shingle = 45,
        Trellis = 46,
        Sphere = 47,
        SmallGrid = 48,
        SmallCheckerBoard = 49,
        LargeCheckerBoard = 50,
        OutlinedDiamond = 51,
        SolidDiamond = 52
    }
}
export namespace Stimulsoft.System.Drawing.Drawing2D {
    enum LineCap {
        AnchorMask = 240,
        ArrowAnchor = 20,
        Custom = 255,
        DiamondAnchor = 19,
        Flat = 0,
        NoAnchor = 16,
        Round = 2,
        RoundAnchor = 18,
        Square = 1,
        SquareAnchor = 17,
        Triangle = 3
    }
}
export namespace Stimulsoft.System.Drawing.Imaging {
    enum EncoderValue {
        ColorTypeCMYK = 0,
        ColorTypeYCCK = 1,
        CompressionLZW = 2,
        CompressionCCITT3 = 3,
        CompressionCCITT4 = 4,
        CompressionRle = 5,
        CompressionNone = 6,
        ScanMethodInterlaced = 7,
        ScanMethodNonInterlaced = 8,
        VersionGif87 = 9,
        VersionGif89 = 10,
        RenderProgressive = 11,
        RenderNonProgressive = 12,
        TransformRotate90 = 13,
        TransformRotate180 = 14,
        TransformRotate270 = 15,
        TransformFlipHorizontal = 16,
        TransformFlipVertical = 17,
        MultiFrame = 18,
        LastFrame = 19,
        Flush = 20,
        FrameDimensionTime = 21,
        FrameDimensionResolution = 22,
        FrameDimensionPage = 23
    }
}
export namespace Stimulsoft.System.Drawing.Imaging {
    class ImageCodecInfo {
        clsid: Guid;
        codecName: string;
        filenameExtension: string;
        formatDescription: string;
        formatID: Guid;
        mimeType: string;
        version: number;
        static getImageDecoders(): ImageCodecInfo[];
        static getImageEncoders(): ImageCodecInfo[];
    }
}
export namespace Stimulsoft.System.Drawing.Printing {
    enum PaperKind {
        A2 = 66,
        A3 = 8,
        A3Extra = 63,
        A3ExtraTransverse = 68,
        A3Rotated = 76,
        A3Transverse = 67,
        A4 = 9,
        A4Extra = 53,
        A4Plus = 60,
        A4Rotated = 77,
        A4Small = 10,
        A4Transverse = 55,
        A5 = 11,
        A5Extra = 64,
        A5Rotated = 78,
        A5Transverse = 61,
        A6 = 70,
        A6Rotated = 83,
        APlus = 57,
        B4 = 12,
        B4Envelope = 33,
        B4JisRotated = 79,
        B5 = 13,
        B5Envelope = 34,
        B5Extra = 65,
        B5JisRotated = 80,
        B5Transverse = 62,
        B6Envelope = 35,
        B6Jis = 88,
        B6JisRotated = 89,
        BPlus = 58,
        C3Envelope = 29,
        C4Envelope = 30,
        C5Envelope = 28,
        C65Envelope = 32,
        C6Envelope = 31,
        CSheet = 24,
        Custom = 0,
        DLEnvelope = 27,
        DSheet = 25,
        ESheet = 26,
        Executive = 7,
        Folio = 14,
        GermanLegalFanfold = 41,
        GermanStandardFanfold = 40,
        InviteEnvelope = 47,
        IsoB4 = 42,
        ItalyEnvelope = 36,
        JapaneseDoublePostcard = 69,
        JapaneseDoublePostcardRotated = 82,
        JapaneseEnvelopeChouNumber3 = 73,
        JapaneseEnvelopeChouNumber3Rotated = 86,
        JapaneseEnvelopeChouNumber4 = 74,
        JapaneseEnvelopeChouNumber4Rotated = 87,
        JapaneseEnvelopeKakuNumber2 = 71,
        JapaneseEnvelopeKakuNumber2Rotated = 84,
        JapaneseEnvelopeKakuNumber3 = 72,
        JapaneseEnvelopeKakuNumber3Rotated = 85,
        JapaneseEnvelopeYouNumber4 = 91,
        JapaneseEnvelopeYouNumber4Rotated = 92,
        JapanesePostcard = 43,
        JapanesePostcardRotated = 81,
        Ledger = 4,
        Legal = 5,
        LegalExtra = 51,
        Letter = 1,
        LetterExtra = 50,
        LetterExtraTransverse = 56,
        LetterPlus = 59,
        LetterRotated = 75,
        LetterSmall = 2,
        LetterTransverse = 54,
        MonarchEnvelope = 37,
        Note = 18,
        Number10Envelope = 20,
        Number11Envelope = 21,
        Number12Envelope = 22,
        Number14Envelope = 23,
        Number9Envelope = 19,
        PersonalEnvelope = 38,
        Prc16K = 93,
        Prc16KRotated = 106,
        Prc32K = 94,
        Prc32KBig = 95,
        Prc32KBigRotated = 108,
        Prc32KRotated = 107,
        PrcEnvelopeNumber1 = 96,
        PrcEnvelopeNumber10 = 105,
        PrcEnvelopeNumber10Rotated = 118,
        PrcEnvelopeNumber1Rotated = 109,
        PrcEnvelopeNumber2 = 97,
        PrcEnvelopeNumber2Rotated = 110,
        PrcEnvelopeNumber3 = 98,
        PrcEnvelopeNumber3Rotated = 111,
        PrcEnvelopeNumber4 = 99,
        PrcEnvelopeNumber4Rotated = 112,
        PrcEnvelopeNumber5 = 100,
        PrcEnvelopeNumber5Rotated = 113,
        PrcEnvelopeNumber6 = 101,
        PrcEnvelopeNumber6Rotated = 114,
        PrcEnvelopeNumber7 = 102,
        PrcEnvelopeNumber7Rotated = 115,
        PrcEnvelopeNumber8 = 103,
        PrcEnvelopeNumber8Rotated = 116,
        PrcEnvelopeNumber9 = 104,
        PrcEnvelopeNumber9Rotated = 117,
        Quarto = 15,
        Standard10x11 = 45,
        Standard10x14 = 16,
        Standard11x17 = 17,
        Standard12x11 = 90,
        Standard15x11 = 46,
        Standard9x11 = 44,
        Statement = 6,
        Tabloid = 3,
        TabloidExtra = 52,
        USStandardFanfold = 39
    }
}
export namespace Stimulsoft.System.Drawing.Printing {
    class PaperSize {
        private createdByDefaultConstructor;
        private _kind;
        get kind(): number;
        private _name;
        get name(): string;
        set name(value: string);
        private _width;
        get width(): number;
        set width(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        constructor(kind?: number, name?: string, width?: number, height?: number);
    }
}
export namespace Stimulsoft.System.Drawing.Printing {
    enum PrinterUnit {
        Display = 0,
        ThousandthsOfAnInch = 1,
        HundredthsOfAMillimeter = 2,
        TenthsOfAMillimeter = 3
    }
}
export namespace Stimulsoft.System.Drawing.Printing {
    class PrinterUnitConvert {
        static convert(value: number, fromUnit: PrinterUnit, toUnit: PrinterUnit): number;
        private static unitsPerDisplay;
    }
}
export namespace Stimulsoft.System.Drawing.Printing.PrinterSettings {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class PaperSizeCollection extends CollectionBase<PaperSize> {
    }
}
export namespace Stimulsoft.System.Drawing.Printing.PrinterSettings {
    class PrinterSettings {
        get paperSizes(): PaperSizeCollection;
    }
}
export namespace Stimulsoft.System.Drawing.Text {
    enum HotkeyPrefix {
        Hide = 0,
        None = 1,
        Show = 2
    }
}
export namespace Stimulsoft.System.Globalization {
    class Calendar {
        static getWeekOfYear(time: DateTime, rule?: CalendarWeekRule, firstDayOfWeek?: DayOfWeek): number;
        private static getFirstDayWeekOfYear;
        private static getWeekOfYearFullDays;
        static getDaysInYear(year: number): number;
        static getWeekOfMonth(time: DateTime, rule?: CalendarWeekRule, firstDayOfWeek?: DayOfWeek): number;
    }
}
export namespace Stimulsoft.System.Globalization {
    enum CalendarWeekRule {
        FirstDay = 0,
        FirstFullWeek = 1,
        FirstFourDayWeek = 2
    }
}
export namespace Stimulsoft.System.Globalization {
    class RegionInfo {
        name: string;
        nativeName: string;
        threeLetterISORegionName: string;
        threeLetterWindowsRegionName: string;
        twoLetterISORegionName: string;
    }
}
export namespace Stimulsoft.System.IO {
    enum SeekOrigin {
        Begin = 0,
        Current = 1,
        End = 2
    }
}
export namespace Stimulsoft.System.IO {
    import Header = Stimulsoft.System.Header;
    class File {
        static getFile(filePath: string, binary?: boolean, contentType?: string, headers?: Header[], disableCache?: boolean, withCredentials?: boolean, allowException?: boolean): any;
        static getFileAsync(callback: Function, filePath: string, binary?: boolean, contentType?: string, headers?: Header[], disableCache?: boolean, withCredentials?: boolean, allowException?: boolean): void;
        static saveFile(filePath: string, fileData: string | number[]): void;
        static getFilesNames(filePath: string): string[];
    }
}
export namespace Stimulsoft.System.IO {
    import StiPromise = Stimulsoft.System.StiPromise;
    import Header = Stimulsoft.System.Header;
    class Http {
        private static addNoCacheHeaders;
        static disableCache: boolean;
        static withCredentials: boolean;
        static getFile(filePath: string, binary?: boolean, contentType?: string, headers?: Header[], disableCache?: boolean, withCredentials?: boolean, allowException?: boolean): any;
        static getFileAsync(callback: Function, filePath: string, binary?: boolean, contentType?: string, headers?: Header[], disableCache?: boolean, withCredentials?: boolean, allowException?: boolean): void;
        static getUrlParameters(): {
            name: string;
            value: string;
        }[];
        static send(method: string, url: string, body?: string, headers?: Header[], disableCache?: boolean, withCredentials?: boolean): {
            status: number;
            responseText: string;
            statusText: string;
        };
        static sendAsync(method: string, url: string, body?: string, headers?: Header[], timeout?: number, disableCache?: boolean, withCredentials?: boolean): StiPromise<{
            status: number;
            responseText: string;
            statusText: string;
        }>;
    }
}
export namespace Stimulsoft.System.IO {
    class MemoryStream {
        private static memStreamMaxLength;
        private _origin;
        private _buffer;
        private _position;
        get position(): number;
        set position(value: number);
        get length(): number;
        get canSeek(): boolean;
        get canWrite(): boolean;
        setLength(length: number): void;
        toArray(): number[];
        toString(): string;
        writeTo(stream: MemoryStream): void;
        writeByte(byte: number): void;
        write(array: number[] | Uint8Array, offset?: number, length?: number): void;
        writeBytes(array: Uint8Array, offset?: number, length?: number): void;
        writeLine1(inputString?: string, ...values: any[]): void;
        writeLine(inputString?: string): void;
        writeString(inputString: string, newLine?: boolean): void;
        read(array: number[], offset?: number, length?: number): number;
        seek(offset: number, origin: SeekOrigin): number;
        flush(): void;
        close(): void;
        copyTo(stream: MemoryStream): void;
        constructor(array?: number[] | Uint8Array);
    }
}
export namespace Stimulsoft.System.IO {
    class Path {
        static combine(path1: string, path2: string): string;
        static getFileNameWithoutExtension(path: string): string;
        static getExtension(path: string): string;
        static getSep(): string;
    }
}
export namespace Stimulsoft.System.IO {
    import Encoding = Stimulsoft.System.Text.Encoding;
    class StreamReader {
        private stream;
        private encoding;
        constructor(stream: MemoryStream, encoding?: Encoding);
        read(): string;
        readLine(): string;
        readAll(): string;
        private readLineInternal;
    }
}
export namespace Stimulsoft.System.Text {
    class Encoding {
        private static CodePageDefault;
        private static CodePageUnicode;
        private static CodePageBigEndian;
        private static CodePageWindows1250;
        private static CodePageWindows1251;
        private static CodePageWindows1252;
        private static CodePageWindows1256;
        private static CodePageASCII;
        private static CodePageISO_8859_1;
        private static CodePageUTF7;
        private static CodePageUTF8;
        private static CodePageUTF32;
        static ASCII: Encoding;
        static BigEndianUnicode: Encoding;
        static Default: Encoding;
        static Unicode: Encoding;
        static UTF32: Encoding;
        static UTF7: Encoding;
        static UTF8: Encoding;
        static Windows1250: Encoding;
        static Windows1251: Encoding;
        static Windows1252: Encoding;
        static Windows1256: Encoding;
        static ISO_8859_1: Encoding;
        private static _windows_1250;
        private static _windows_1251;
        private static _windows_1252;
        private static _windows_1256;
        private static charToCodepageList;
        webName: string;
        encodingName: string;
        codepage: number;
        getBytes(str: string): number[];
        getString(bytes: number[] | Uint8Array): string;
        static getEncoding(codepage: number): Encoding;
        static getSupportedEncodings(): {
            key: string;
            name: string;
        }[];
        private static fromCodePageToUnicode;
        private static fromUnicodeToCodePage;
        private static fillCodepage;
        constructor(name: string, codepage: number, webName?: string);
    }
}
export namespace Stimulsoft.System.Text {
    class StringBuilder {
        private isNew;
        private partArray;
        private appendSingle;
        appendThese(items: any[]): StringBuilder;
        append(...items: any[]): StringBuilder;
        appendCount(item: any, count?: number): StringBuilder;
        appendLine(...items: any[]): StringBuilder;
        appendLines(items: any[]): StringBuilder;
        appendFormat(str: string, ...values: any[]): StringBuilder;
        insert(index: number, value: string, count?: number): StringBuilder;
        remove(startIndex: number, length: number): StringBuilder;
        get isEmpty(): boolean;
        get length(): number;
        set length(value: number);
        private latest;
        toString(): string;
        join(delimiter: string): string;
        clear(): void;
        dispose(): void;
        charAt(index: number): string;
        charCodeAt(index: number): number;
        setByIndex(index: number, value: string): void;
        replace(searchValue: string, replaceValue: string): StringBuilder;
        constructor(value?: string);
    }
}
export namespace Stimulsoft.System.IO {
    import StringBuilder = Stimulsoft.System.Text.StringBuilder;
    class TextWriter {
        private sb;
        write(value: any): void;
        writeLine(value?: any): void;
        close(): void;
        flush(): void;
        getStringBuilder(): StringBuilder;
    }
}
export namespace Stimulsoft.System.IO {
    import Encoding = Stimulsoft.System.Text.Encoding;
    import TextWriter = Stimulsoft.System.IO.TextWriter;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StreamWriter extends TextWriter {
        private stream;
        private encoding;
        private cn;
        writeLine(value: string): void;
        write(value: string): void;
        get baseStream(): MemoryStream;
        close(): void;
        flush(): void;
        constructor(stream: MemoryStream, encoding?: Encoding);
    }
}
export namespace Stimulsoft.System.Text {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiReportObjectStringConverter {
        static convertStringToColorArray(str: string): Color[];
        static convertStringToColor(str: string): Color;
        static convertStringToFont(str: string): Stimulsoft.System.Drawing.Font;
        private static getByName;
    }
}
export namespace Stimulsoft.System.Text {
    import Font = Stimulsoft.System.Drawing.Font;
    class TextUtils {
        static splitString(inputString: string, removeControl: boolean): string[];
        static trimEndWhiteSpace(inputString: string): string;
        static trimEndWhiteSpace2(inputString: string, removeControl: boolean): string;
        private static isWordWrapSymbol;
        static getWordWrapTextLines(st: string, font: Font, needWidthAlign: boolean, textW: number): string[];
    }
}
export namespace Stimulsoft.System.Xml {
    enum Formatting {
        None = 0,
        Indented = 1
    }
}
export namespace Stimulsoft.System.Xml {
    class XmlAttrCollection extends Array<XmlAttr> {
        getNamedItem(name: string): XmlAttr;
    }
}
export namespace Stimulsoft.System.Xml {
    class XmlCharType {
        static fWhitespace: number;
        static fLetter: number;
        static fNCStartName: number;
        static fNCName: number;
        static fCharData: number;
        static fPublicId: number;
        static fText: number;
        static fAttrValue: number;
        private static charPropertiesSize;
        static get instance(): XmlCharType;
        private static s_CharProperties;
        charProperties: number[];
        private static initInstance;
        private static setProperties;
        private static s_Whitespace;
        private static s_Letter;
        private static s_NCStartName;
        private static s_NCName;
        private static s_CharData;
        private static s_PublicID;
        private static s_Text;
        private static s_AttrValue;
        constructor(charProperties: any[]);
    }
}
export namespace Stimulsoft.System.Xml {
    class XmlReservedNs {
        static NsCollationBase: string;
        static NsCollCodePoint: string;
        static NsDataType: string;
        static NsDataTypeAlias: string;
        static NsDataTypeOld: string;
        static NsExsltCommon: string;
        static NsExsltDates: string;
        static NsExsltMath: string;
        static NsExsltRegExps: string;
        static NsExsltSets: string;
        static NsExsltStrings: string;
        static NsMsxsl: string;
        static NsWdXsl: string;
        static NsXdr: string;
        static NsXdrAlias: string;
        static NsXml: string;
        static NsXmlNs: string;
        static NsXQueryDataType: string;
        static NsXQueryFunc: string;
        static NsXs: string;
        static NsXsd: string;
        static NsXsi: string;
        static NsXslDebug: string;
        static NsXslt: string;
        static NsXsltInternal: string;
    }
}
export namespace Stimulsoft.System.Xml {
    enum XmlSpace {
        Default = 1,
        None = 0,
        Preserve = 2
    }
}
export namespace Stimulsoft.System.Xml {
    import TextWriter = Stimulsoft.System.IO.TextWriter;
    class XmlTextEncoder {
        private textWriter;
        quoteChar: string;
        private attrValue;
        private cacheAttrValue;
        startAttribute(cacheAttrValue: boolean): void;
        endAttribute(): void;
        get attributeValue(): string;
        write(text: string): void;
        writeRawWithSurrogateChecking(text: string): void;
        constructor(textWriter: TextWriter);
    }
}
export namespace Stimulsoft.System.Xml {
    import Encoding = Stimulsoft.System.Text.Encoding;
    import TextWriter = Stimulsoft.System.IO.TextWriter;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class XmlTextWriter {
        private static stateTableDefault;
        private static stateTableDocument;
        textWriter: TextWriter;
        private xmlEncoder;
        private encoding;
        formatting: Formatting;
        private indented;
        indentation: number;
        private indentChar;
        private stack;
        private top;
        private stateTable;
        private currentState;
        private lastToken;
        private quoteChar;
        private curQuoteChar;
        private namespaces;
        private specialAttr;
        private prefixForXmlNs;
        private _flush;
        private nsStack;
        private nsTop;
        private nsHashtable;
        private useNsHashtable;
        private xmlCharType;
        private namespaceStackInitialSize;
        private maxNamespacesWalkCount;
        writeStartDocument(standalone?: boolean): void;
        writeEndDocument(): void;
        writeDocType(name: string, pubid: string, sysid: string, subset: string): void;
        writeStartElement(localName: string): void;
        private writeStartElement3;
        writeEndElement(): void;
        writeFullEndElement(): void;
        writeStartAttribute(prefix: string, localName: string, ns: string): void;
        writeEndAttribute(): void;
        writeString(text: string): void;
        writeRaw(data: string): void;
        close(): void;
        flush(): void;
        writeName(name: string): void;
        writeQualifiedName(localName: string, ns: string): void;
        private startDocument;
        private autoComplete;
        private autoCompleteAll;
        private internalWriteEndElement;
        private writeEndStartTag;
        private writeEndAttributeQuote;
        private indent;
        private pushNamespace;
        private addNamespace;
        private addToNamespaceHashtable;
        private popNamespaces;
        private generatePrefix;
        private internalWriteProcessingInstruction;
        private lookupNamespace;
        private lookupNamespaceInCurrentScope;
        private findPrefix;
        private internalWriteName;
        private validateName;
        private handleSpecialAttribute;
        private verifyPrefixXml;
        private pushStack;
        private flushEncoders;
        writeAttributeString(localName: string, value: string): void;
        writeElementString(localName: string, value: string): void;
        writeElementString2(localName: string, ns: string, value: string): void;
        writeElementString3(prefix: string, localName: string, ns: string, value: string): void;
        constructor_(encoding: Encoding, w?: MemoryStream): void;
        constructor(encoding: Encoding, w?: MemoryStream);
    }
}
export namespace Stimulsoft.Base {
    enum StiAnimationType {
        Opacity = 0,
        Scale = 1,
        Translation = 2,
        Rotation = 3,
        Column = 4,
        Points = 5,
        PieSegment = 6
    }
    enum StiTokenType {
        None = 0,
        Dot = 1,
        Comma = 2,
        Colon = 3,
        SemiColon = 4,
        Shl = 5,
        Shr = 6,
        Assign = 7,
        PlusAssign = 8,
        MinusAssign = 9,
        MultAssign = 10,
        DivAssign = 11,
        ModAssign = 12,
        AndAssign = 13,
        OrAssign = 14,
        XorAssign = 15,
        ShlAssign = 16,
        ShrAssign = 17,
        NullCoalescingAssign = 18,
        Equal = 19,
        NotEqual = 20,
        LeftEqual = 21,
        Left = 22,
        RightEqual = 23,
        Right = 24,
        Or = 25,
        Xor = 26,
        And = 27,
        Not = 28,
        DoubleOr = 29,
        DoubleXor = 30,
        DoubleAnd = 31,
        Copyright = 32,
        Question = 33,
        DoubleQuestion = 34,
        Plus = 35,
        Minus = 36,
        Mult = 37,
        Div = 38,
        Splash = 39,
        Percent = 40,
        Ampersand = 41,
        Sharp = 42,
        Dollar = 43,
        Euro = 44,
        DoublePlus = 45,
        DoubleMinus = 46,
        LPar = 47,
        RPar = 48,
        LBrace = 49,
        RBrace = 50,
        LBracket = 51,
        RBracket = 52,
        Value = 53,
        Ident = 54,
        Keyword = 55,
        Unknown = 56,
        EOF = 57,
        InterpolatedString = 58
    }
    enum StiLevel {
        Basic = 0,
        Standard = 1,
        Professional = 2
    }
    enum StiAutoBool {
        Auto = 0,
        True = 1,
        False = 2
    }
    enum StiRelationDirection {
        ParentToChild = 1,
        ChildToParent = 0
    }
    enum StiGisDataType {
        Wkt = 0,
        GeoJSON = 1
    }
    enum StiSummaryColumnType {
        Sum = 0,
        Min = 1,
        Max = 2,
        Count = 3,
        Average = 4
    }
    enum StiDataJoinType {
        Inner = 1,
        Left = 2,
        Right = 3,
        Cross = 4,
        Full = 5
    }
}
export namespace Stimulsoft.Base {
    let IStiApp: System.Interface<IStiApp>;
    interface IStiApp extends IStiAppCell {
        getDictionary(): IStiAppDictionary;
    }
}
export namespace Stimulsoft.Base {
    let IStiAppAlias: System.Interface<IStiAppAlias>;
    interface IStiAppAlias {
        getAlias(): string;
    }
}
export namespace Stimulsoft.Base {
    let IStiAppCalcDataColumn: System.Interface<IStiAppCalcDataColumn>;
    interface IStiAppCalcDataColumn extends IStiAppDataColumn {
    }
}
export namespace Stimulsoft.Base {
    import IAsIs = Stimulsoft.System.IAsIs;
    let IStiAppCell: System.Interface<IStiAppCell>;
    interface IStiAppCell extends IAsIs {
        getKey(): string;
        setKey(key: string): void;
    }
}
export namespace Stimulsoft.Base {
    let IStiAppComponent: System.Interface<IStiAppComponent>;
    interface IStiAppComponent extends IStiAppCell {
        getName(): string;
        getApp(): IStiApp;
    }
}
export namespace Stimulsoft.Base {
    import List = Stimulsoft.System.Collections.List;
    let IStiAppConnection: System.Interface<IStiAppConnection>;
    interface IStiAppConnection extends IStiAppCell {
        getName(): string;
        fetchSiblingDataSources(dictionary: IStiAppDictionary): List<IStiAppDataSource>;
    }
}
export namespace Stimulsoft.Base {
    let IStiAppDataCell: System.Interface<IStiAppDataCell>;
    interface IStiAppDataCell extends IStiAppCell {
        getName(): string;
    }
}
export namespace Stimulsoft.Base {
    import Type = Stimulsoft.System.Type;
    let IStiAppDataColumn: System.Interface<IStiAppDataColumn>;
    interface IStiAppDataColumn extends IStiAppDataCell {
        getNameInSource(): string;
        getDataType(): Type;
    }
}
export namespace Stimulsoft.Base {
    import List = Stimulsoft.System.Collections.List;
    let IStiAppDataRelation: System.Interface<IStiAppDataRelation>;
    interface IStiAppDataRelation extends IStiAppCell {
        getName(): string;
        getDictionary(): IStiAppDictionary;
        getParentDataSource(): IStiAppDataSource;
        getChildDataSource(): IStiAppDataSource;
        fetchParentColumns(): List<string>;
        fetchChildColumns(): List<string>;
        getActiveState(): boolean;
        getJoinType(): StiDataJoinType;
    }
}
export namespace Stimulsoft.Base {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import List = Stimulsoft.System.Collections.List;
    let IStiAppDataSource: System.Interface<IStiAppDataSource>;
    interface IStiAppDataSource extends IStiAppCell {
        getNameInSource(): string;
        getName(): string;
        getDataTable2(allowConnectToData: boolean): DataTable;
        getDataTable2Async(allowConnectToData: boolean): Promise<DataTable>;
        getDictionary(): IStiAppDictionary;
        fetchColumns(): List<IStiAppDataColumn>;
        getConnection(): IStiAppConnection;
        fetchParentRelations(activePreferred: boolean): List<IStiAppDataRelation>;
        fetchChildRelations(activePreferred: boolean): List<IStiAppDataRelation>;
        fetchColumnValues(names: List<string>): List<any[]>;
        fetchColumnValuesAsync(names: List<string>): Promise<List<any[]>>;
        convertDataColumnType(dataTable: DataTable): any;
    }
}
export namespace Stimulsoft.Base {
    import List = Stimulsoft.System.Collections.List;
    let IStiAppDictionary: System.Interface<IStiAppDictionary>;
    interface IStiAppDictionary {
        fetchDataSources(): List<IStiAppDataSource>;
        fetchDataRelations(): List<IStiAppDataRelation>;
        fetchVariables(): List<IStiAppVariable>;
        getDataSourceByName(name: string): IStiAppDataSource;
        getColumnByName(name: string): IStiAppDataColumn;
        getVariableByName(name: string): IStiAppVariable;
        getVariableValueByName(name: string): any;
        isSystemVariable(name: string): boolean;
        isReadOnlyVariable(name: string): boolean;
        getSystemVariableValue(name: string): any;
        getApp(): IStiApp;
        openConnectionsAsync(connections: List<IStiAppConnection>): Promise<List<IStiAppConnection>>;
        openConnections(connections: List<IStiAppConnection>): List<IStiAppConnection>;
        closeConnections(connections: List<IStiAppConnection>): void;
        existsUserFunction(functionName: string): boolean;
        invokeUserFunction(functionName: string, args: any[]): any;
    }
}
export namespace Stimulsoft.Base {
    let IStiAppExpressionCollection: System.Interface<IStiAppExpressionCollection>;
    interface IStiAppExpressionCollection {
        expressions: StiAppExpressionCollection;
    }
}
export namespace Stimulsoft.Base {
    let IStiAppFunction: System.Interface<IStiAppFunction>;
    interface IStiAppFunction extends IStiAppCell {
        getName(): string;
        invoke(arguments: any[]): any;
    }
}
export namespace Stimulsoft.Base {
    import Type = Stimulsoft.System.Type;
    let IStiAppVariable: System.Interface<IStiAppVariable>;
    interface IStiAppVariable extends IStiAppDataCell {
        getValue(): any;
        getCellType(): Type;
    }
}
export namespace Stimulsoft.Base {
    import Font = Stimulsoft.System.Drawing.Font;
    let IStiGetFonts: System.Interface<IStiGetFonts>;
    interface IStiGetFonts {
        getFonts(): Font[];
    }
}
export namespace Stimulsoft.Base {
    import List = Stimulsoft.System.Collections.List;
    let IStiReport: System.Interface<IStiReport>;
    interface IStiReport extends IStiApp {
        fetchPages(): List<IStiReportPage>;
    }
}
export namespace Stimulsoft.Base {
    let IStiReportComponent: System.Interface<IStiReportComponent>;
    interface IStiReportComponent extends IStiAppComponent {
        getReport(): IStiReport;
    }
}
export namespace Stimulsoft.Base {
    let IStiReportPage: System.Interface<IStiReportPage>;
    interface IStiReportPage extends IStiReportComponent {
        parseExpression(text: string, allowReturnNull: boolean): string;
    }
}
export namespace Stimulsoft.Base {
    class StiActivator {
        static createObject(_type: Stimulsoft.System.Type): any;
        static createObject2(typeString: string): any;
    }
}
export namespace Stimulsoft.Base {
    class StiAlignValue {
        static alignToMaxGrid(value: number, gridSize: number, aligningToGrid: boolean): number;
        static alignToMinGrid(value: number, gridSize: number, aligningToGrid: boolean): number;
        static alignToGrid(value: number, gridSize: number, aligningToGrid: boolean): number;
    }
}
export namespace Stimulsoft.Base.JsonReportObject {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    let IStiJsonReportObject: System.Interface<IStiJsonReportObject>;
    interface IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): any;
    }
}
export namespace Stimulsoft.Base {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiAppExpression implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private upperFirstChar;
        private lowerFirstChar;
        clone(): StiAppExpression;
        name: string;
        expression: string;
        get isEmpty(): boolean;
        constructor(name: string, expression: string);
    }
}
export namespace Stimulsoft.Base {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiAppExpressionCollection extends CollectionBase<StiAppExpression> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        add2(name: string, expression: string): void;
        addRange2(props: StiAppExpressionCollection): void;
        contains2(name: string): boolean;
        remove2(name: string): void;
        getByName(name: string): StiAppExpression;
        setByName(name: string, value: StiAppExpression): void;
        clone(): StiAppExpressionCollection;
    }
}
export namespace Stimulsoft.Base {
    import IAsIs = Stimulsoft.System.IAsIs;
    class StiAppExpressionHelper {
        static isExpressionSpecified(component: IAsIs, propName: string): boolean;
        static getExpression(component: IAsIs, propName: string): StiAppExpression;
        static getExpressionValue(component: IAsIs, propName: string): string;
        static setExpression(component: IAsIs, propName: string, expression: string): void;
        static removeExpression(component: any, propName: string): void;
    }
}
export namespace Stimulsoft.Base {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiAppFunctions {
        static functionsToCompile: Hashtable<string, IStiAppFunction[]>;
        static functionsToCompileLower: Hashtable<string, IStiAppFunction[]>;
        static functions: Hashtable<string, IStiAppFunction[]>;
        static functionsLower: Hashtable<string, IStiAppFunction[]>;
        static getFunctions(isCompile: boolean, isCaseSensitive: boolean): IStiAppFunction[];
        static getFunctions2(functionName: string, isCompile: boolean, isCaseSensitive: boolean): IStiAppFunction[];
    }
}
export namespace Stimulsoft.Base {
    class StiAppKey {
        static getOrGeneratedKey(component: IStiReportComponent): string;
        static getOrGeneratedKey2(app: IStiApp): string;
        static getOrGeneratedKey3(dictionary: IStiAppDictionary): string;
        static getOrGeneratedKey4(dataSource: IStiAppDataSource): string;
    }
}
export namespace Stimulsoft.Base {
    class StiEncryption {
        private static randomSeed;
        private static rand_m;
        private static rand_a;
        private static rand_c;
        static encrypt(src: number[], key: number[]): number[];
        static encrypt2(src: number[], password: string): number[];
        static encryptS(src: string, password: string): string;
        static decrypt(src: number[], key: number[]): number[];
        static decrypt2(src: number[], password: string): number[];
        static decryptS(src: string, password: string): string;
        static generateRandomKey(): number[];
        private static encryptAdv;
        private static decryptAdv;
        private static cryptXor;
        private static cryptShift;
        private static shiftLeft;
        private static shiftRight;
        private static cryptRandom;
        private static getMixArray;
        private static setRandomSeed;
        private static getRandom;
        private static getKeyFromPassword;
    }
}
export namespace Stimulsoft.Base {
    import Point = Stimulsoft.System.Drawing.Point;
    import List = Stimulsoft.System.Collections.List;
    import DateTime = Stimulsoft.System.DateTime;
    class StiJson {
        static prettyPrint: boolean;
        static dateToJsonDate(date: DateTime): string;
        static jsonDateFormatToDate(jsonDate: string): DateTime;
        name: string;
        value: any;
        private isProperty;
        private isArray;
        private isRaw;
        properties(): List<StiJson>;
        removeProperty(propertyName: string): void;
        addPropertyNumber(propertyName: string, value: number, defaultValue?: number): void;
        addPropertyNumberNoDefaultValue(propertyName: string, value: number): void;
        addPropertyJObject(propertyName: string, value: StiJson): void;
        addPropertyJObjectArray(propertyName: string, values: StiJson[]): void;
        addPropertyPoint(propertyName: string, point: Point): void;
        addPropertyIdent(propertyName: string, value: string): void;
        addPropertyBool(propertyName: string, value: boolean, defaultValue?: boolean, ignoreDefaultValues?: boolean): void;
        addPropertyDateTime(propertyName: string, value: DateTime): void;
        addPropertyEnum(propertyName: string, enumType: any, value: any, defaultValue?: any): void;
        addPropertyString(propertyName: string, value: string, defaultValue?: string): void;
        addPropertyStringNullOrEmpty(propertyName: string, value: string): void;
        addRawString(propertyName: string, value: string): void;
        get count(): number;
        serialize(indent?: number): string;
        deserialize(text: any): void;
        private deserializeFromObject;
        toString(): string;
        constructor(name?: string, value?: any, isProperty?: boolean, isRaw?: boolean);
    }
}
export namespace Stimulsoft.Base {
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCID {
        private static key;
        private static undefined;
        private static prefix;
        private machineAddress;
        private machineName;
        private machineUserName;
        private machineGuid;
        saveToString(): string;
        saveToJsonObject(): StiJson;
        loadFromString(value: string): void;
        loadFromJsonObject(jObject: StiJson): void;
        static getDefault(): string;
        private static getDeveloperCID;
        private static getCurrentMachineName;
        private static getCurrentMachineGuid;
        private static getCurrentMachineAddress;
        private static getCurrentMachineUserName;
        static isCID(cid: string): boolean;
        constructor(machineName: string, machineAddress?: string, machineUserName?: string, machineGuid?: string);
    }
}
export namespace Stimulsoft.Base.Localization {
    class StiLocalization {
        private static enLanguage;
        static languages: {
            [key: string]: {
                language: string;
                cultureName: string;
                filePath?: string;
                jsonString?: string;
            };
        };
        static setLocalization(localizationXml: string, onlyThis?: boolean): void;
        private static _cultureName;
        static get cultureName(): string;
        static set cultureName(value: string);
        static addLocalizationFile(filePath: string, load?: boolean, language?: string): string;
        static setLocalizationFile(filePath: string, onlyThis?: boolean): void;
        static getJsonStringLocalization(): string;
        static loadLocalization(localizationXml: string): string;
        static loadLocalizationFile(filePath: string): string;
        private static loadLocalizationXmlInternal;
        static get(category: string, key: string): string;
    }
}
export namespace Stimulsoft.Base {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Exception = Stimulsoft.System.Exception;
    class StiChartNotSupportedException extends Exception {
        static message: string;
        static getTextJson(chartJson: StiJson, message?: string): StiJson;
        static getTextXml(chartXml: XmlNode, message?: string): XmlNode;
        get message(): string;
    }
}
export namespace Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiColor {
        static get(color: string): Color;
        static get2(...colors: string[]): Color[];
    }
}
export namespace Stimulsoft.Base {
    class StiConvert {
        static changeType(value: any, conversionType: Stimulsoft.System.Type, convertNulls?: boolean): any;
    }
}
export namespace Stimulsoft.Base {
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    class StiCultureInfo {
        static set(culture: string): CultureInfo;
        static getByName(culture: string): CultureInfo;
    }
}
export namespace Stimulsoft.Base {
    import Exception = Stimulsoft.System.Exception;
    class StiDashboardNotSupportedException extends Exception {
        get message(): string;
    }
}
export namespace Stimulsoft.Base {
    import Exception = Stimulsoft.System.Exception;
    class StiExportNotSupportedException extends Exception {
        get message(): string;
    }
}
export namespace Stimulsoft.Base {
    import Font = Stimulsoft.System.Drawing.Font;
    class StiFont {
        static get(...fonts: Font[]): Font[];
    }
}
export namespace Stimulsoft.Base {
    import FontFamily = Stimulsoft.System.Drawing.FontFamily;
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    type FontConfigType = {
        fontName?: string;
        fontStyle?: FontStyle;
        fontPath?: string;
        fontData?: string | number[];
    };
    class StiFontCollection {
        static addOpentypeFont(font: any, fontName?: string, binFont?: any, filePath?: string, fontStyle?: FontStyle, store?: boolean): void;
        static addFont(font: any, fontName?: string, binFont?: any, filePath?: string, fontStyle?: FontStyle, store?: boolean): void;
        static addOpentypeFontFile(filePath: string, fontName?: string, fontStyle?: FontStyle, store?: boolean): void;
        static addFontFile(filePath: string, fontName?: string, fontStyle?: FontStyle, store?: boolean): void;
        static addOpentypeFontFileAsync(callback: () => void, filePath: string, fontName?: string, fontStyle?: FontStyle, store?: boolean): void;
        static addFontFileAsync(callback: () => void, filePath: string, fontName?: string, fontStyle?: FontStyle, store?: boolean): void;
        static addFontBytes(data: any, fontName?: string, fontStyle?: FontStyle, store?: boolean): void;
        static setOpentypeFontsFolder(folderPatch: string): void;
        static setFontsFolder(folderPatch: string): void;
        static registerFontConfigFile(filePath: string): void;
        static registerFontConfigFileAsync(callback: () => void, filePath: string): void;
        static registerFontConfig(fontsConfig: FontConfigType[]): void;
        static registerFontConfigAsync(callback: () => void, fontsConfig: FontConfigType[]): void;
        static getFontFamilies(): FontFamily[];
        static getBinFont(fontName: string, fontStyle?: FontStyle): any;
        static getBinFonts(): string[];
        static isCustomFont(fontName: string): boolean;
    }
}
export namespace Stimulsoft.Base {
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiGisToDataSetConverter {
        static getDataSetFromWkt(content: number[] | string | Uint8Array, separator: string, maxDataRows?: number): DataSet;
        private static getDataSetFromWkt2;
        static getDataSetFromGeoJson(content: number[] | string | Uint8Array, maxDataRows?: number): DataSet;
        static getDataSetFromGeoJson2(jObject: {}, maxDataRows?: number): DataSet;
    }
}
export namespace Stimulsoft.Base {
    class StiGuidUtils {
        static newGuid(): string;
    }
}
export namespace Stimulsoft.Base {
    import Exception = Stimulsoft.System.Exception;
    class StiImportExcelNotSupportedException extends Exception {
        get message(): string;
    }
}
export namespace Stimulsoft.Base {
    class StiJsonChecker {
        static isValidJson(strInput: string): boolean;
    }
}
export namespace Stimulsoft.Base {
    class StiKeyHelper {
        static generateKey(): string;
        static isKey(key: string): boolean;
        static isCorrectKey(key: string): boolean;
        static isEmptyKey(key: string): boolean;
        static isEmptyKey2(key1: string, key2: string): boolean;
        static selectKey(key1: string, key2: string): string;
        static isEqualKeys(key1: string, key2: string): boolean;
        static getOrGeneratedKey(key: string): string;
        static getOrGeneratedKey2(key1: string, key2: string): string;
    }
}
export namespace Stimulsoft.Base {
    class StiLexer {
        private static readonly CR;
        private static readonly LF;
        private static readonly TAB;
        private static _keywords;
        private static _typeKeywords;
        isScript: boolean;
        private _text;
        get text(): string;
        set text(value: string);
        baseText: string;
        positionInText: number;
        private positions;
        savePosToken(): void;
        getPosition(positionInText: number): StiPosition;
        waitLparen2(): boolean;
        waitComma2(): boolean;
        waitAssign2(): boolean;
        waitRparen2(): boolean;
        waitLbrace2(): boolean;
        waitSemicolon2(): boolean;
        waitRbrace2(): boolean;
        scanNumber(): StiToken;
        scanIdent(): StiToken;
        scanString(): StiToken;
        scanChar(): StiToken;
        private isIdentifierPart;
        ungetToken(): void;
        getToken(): StiToken;
        reset(): void;
        scanInterpolatedString(): StiToken;
        static isKeyword(ident: string, includingTypes?: boolean): boolean;
        static replaceWithPrefix(textValue: string, prefix: string, oldValue: string, newValue: string): string;
        replaceWithPrefix(prefix: string, oldValue: string, newValue: string): void;
        replaceWithNotEqualPrefix(prefix: StiTokenType, oldValue: string, newValue: string): void;
        static identExists(str: string, name: string, caseSensitive: boolean): boolean;
        static getAllTokens(str: string): StiToken[];
        private handleError;
        skipWhitespaceAndComments(): void;
        constructor(textValue: string);
    }
}
export namespace Stimulsoft.Base {
    class StiMD5Helper {
        static MD5(string: any, convertToUtf8?: boolean): number[];
    }
}
export namespace Stimulsoft.Base {
    import Exception = Stimulsoft.System.Exception;
    class StiMapNotSupportedException extends Exception {
        get message(): string;
    }
}
export namespace Stimulsoft.Base {
    class StiObjectConverter {
        static convertToNumber(value: any): number;
        private static normalizeFloatingPointValue;
    }
}
export namespace Stimulsoft.Base {
    class StiPosition {
        line: number;
        column: number;
        constructor(line: number, column: number);
    }
}
export namespace Stimulsoft.Base {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRepositoryItems implements ICloneable {
        implements(): any[];
        clone(): any;
        private items;
        private valueBoolFalse;
        private valueBoolTrue;
        setNumber(key: string, value: number, defaultValue: number): void;
        getNumber(key: string, defaultValue: number): number;
        setBool(key: string, value: boolean, defaultValue: boolean): void;
        getBool(key: string, defaultValue: boolean): boolean;
        set(key: string, value: any, defaultValue: any): void;
        get(key: string, defaultValue: any): any;
        isPresent(key: string): boolean;
    }
}
export namespace Stimulsoft.Base {
    class StiScale {
        static xx(value: number): number;
        static yy(value: number): number;
        static factor: number;
    }
}
export namespace Stimulsoft.Base {
    class StiToken {
        index: number;
        length: number;
        type: StiTokenType;
        data: string;
        static EOF: StiToken;
        isKeyword(keyword?: string): boolean;
        isIdent(ident?: string): boolean;
        isIdentOrKeyword(): boolean;
        isAssign(): boolean;
        isDot(): boolean;
        isLBrace(): boolean;
        isRBrace(): boolean;
        isLBracket(): boolean;
        isRBracket(): boolean;
        isLPar(): boolean;
        isRPar(): boolean;
        toString(): string;
        get dataAsString(): string;
        constructor(type: StiTokenType, index?: number, length?: number, obj?: any);
    }
}
export namespace Stimulsoft.Base {
    class StiTypeFinder {
        private static findTypes;
        private static getCorrectTypeName;
        static getStiType(typeName: string): Stimulsoft.System.Type;
        private static addTypeFF;
        private static getTypeFF;
        static findType(exType: Stimulsoft.System.Type, typeForFinding: Stimulsoft.System.Type): boolean;
    }
}
export namespace Stimulsoft.Base {
    class StiTypeWrapper {
        private _type;
        get type(): Stimulsoft.System.Type;
        toString(): string;
        static toString(type: Stimulsoft.System.Type): string;
        private static _simpleTypes;
        static get simpleTypes(): Stimulsoft.System.Type[];
        private static _simpleBaseTypes;
        static get simpleBaseTypes(): Stimulsoft.System.Type[];
        static getTypeWrappers(): StiTypeWrapper[];
        constructor(type: Stimulsoft.System.Type);
    }
}
export namespace Stimulsoft.Base {
    class StiUrl {
        static combine(uriParts: string[]): string;
    }
}
export namespace Stimulsoft {
    class StiVersion {
        static version: string;
        static creationDate: string;
        static created: System.DateTime;
        static versionInfo: string;
        static platform(): string;
    }
}
export namespace Stimulsoft.Base {
    import DateTime = Stimulsoft.System.DateTime;
    class StringExt {
        static tryParseDateTime(value: string, refDateTime: {
            ref: DateTime;
        }): boolean;
        private static tryParseUsingDate;
        private static tryParseJsonDateTime;
        private static tryParseJsonDateTimeInNewDate;
    }
}
export namespace Stimulsoft.Base {
    class TextValue {
        value: string;
        toString(): string;
        constructor(value: string);
    }
}
export namespace Stimulsoft.Base.Blocks {
    interface IStiBlocklyValueEventArgs {
    }
}
export namespace Stimulsoft.Base.Blocks {
    import EventArgs = Stimulsoft.System.EventArgs;
    import IStiReport = Stimulsoft.Base.IStiReport;
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    interface IStiBlocksParser {
        evaluate(report: IStiReport, sender: any, xml: string, args: EventArgs): any;
        evaluateAsync(report: IStiReport, sender: any, xml: string, args: EventArgs): any;
        evaluateUserFunction(report: IStiReport, functionObj: object, args: Dictionary<string, any>): any;
    }
}
export namespace Stimulsoft.Base.Blocks {
    class StiBlocksConst {
        static identXml: string;
    }
}
export namespace Stimulsoft.Base.Blocks {
    import IStiBlocksParser = Stimulsoft.Base.Blocks.IStiBlocksParser;
    class StiBlocksCreator {
        static getBlockParse(): IStiBlocksParser;
    }
}
export namespace Stimulsoft.Base.CompoundDocument {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class BinaryWriter extends MemoryStream {
        writeEmptyBytes(count: number): void;
        writeUInt16(value: number): void;
        writeInt16(value: number): void;
        writeUInt32(value: number): void;
        writeInt32(value: number): void;
        writeUInt64(value: number): void;
        writeInt64(value: number): void;
    }
}
export namespace Stimulsoft.Base.CompoundDocument {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import List = Stimulsoft.System.Collections.List;
    class StoragePart {
        SubStorage: Dictionary<string, StoragePart>;
        DataStreams: Dictionary<string, number[]>;
    }
    class CompoundDocument {
        Storage: StoragePart;
        Directories: List<CompoundDocumentItem>;
        private GetStorageAndStreams;
        Save(ms: MemoryStream): void;
        private WriteStorageAndStreams;
        constructor();
    }
}
export namespace Stimulsoft.Base.CompoundDocument {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import List = Stimulsoft.System.Collections.List;
    class CompoundDocumentFile {
        readonly miniFATSectorSize = 64;
        readonly FATSectorSizeV3 = 512;
        readonly DIFAT_SECTOR = -4;
        readonly FAT_SECTOR = -3;
        readonly END_OF_CHAIN = -2;
        static readonly header: number[];
        minorVersion: number;
        majorVersion: number;
        numberOfDirectorySector: number;
        sectorShif: number;
        minSectorShift: number;
        _numberOfFATSectors: number;
        _firstDirectorySectorLocation: number;
        _transactionSignatureNumber: number;
        _miniStreamCutoffSize: number;
        _firstMiniFATSectorLocation: number;
        _numberofMiniFATSectors: number;
        _firstDIFATSectorLocation: number;
        _numberofDIFATSectors: number;
        _sectors: List<Uint8Array>;
        _miniSectors: List<Uint8Array>;
        _sectorSize: number;
        _miniSectorSize: number;
        _sectorSizeInt: number;
        _currentDIFATSectorPos: number;
        _currentFATSectorPos: number;
        _currentDirSectorPos: number;
        _prevDirFATSectorPos: number;
        rootItem: CompoundDocumentItem;
        _directories: List<CompoundDocumentItem>;
        get Directories(): List<CompoundDocumentItem>;
        private FlattenDirs;
        private InitItem;
        private AddChildren;
        private SetSiblings;
        private GetPos;
        write(ms: MemoryStream): void;
        private FillDIFAT;
        private WritePosition;
        private WritePosition2;
        private WriteDirs;
        private WriteDirStream;
        private WriteMiniFAT;
        private WriteStream;
        private WriteFAT;
        private CheckUpdateDIFAT;
        private AllocateFAT;
        private GetDIFatSectors;
        private WriteFATItem;
        private GetSectors;
        private SetMiniStream;
        private WriteStreamFullSector;
        private WriteHeader;
        private CreateFATStreams;
        private WriteStreamFat;
        private AddFAT;
        dispose(): void;
        constructor();
    }
}
export namespace Stimulsoft.Base.CompoundDocument {
    import IComparable = Stimulsoft.System.IComparable;
    import List = Stimulsoft.System.Collections.List;
    class CompoundDocumentItem implements IComparable<CompoundDocumentItem> {
        implements(): any[];
        parent: CompoundDocumentItem;
        children: List<CompoundDocumentItem>;
        name: string;
        colorFlag: number;
        objectType: number;
        childID: number;
        clsID: Stimulsoft.System.Guid;
        leftSibling: number;
        rightSibling: number;
        statBits: number;
        creationTime: number;
        modifiedTime: number;
        startingSectorLocation: number;
        streamSize: number;
        stream: number[];
        _handled: boolean;
        write(bw: BinaryWriter): void;
        compareTo(other: CompoundDocumentItem): number;
        constructor();
    }
}
export namespace Stimulsoft.Base.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    class Font {
        Name: string;
        Size: number;
        Color: Color;
        SelectedColor: Color;
        IsBold: boolean;
        getGdiFont(zoom?: number, fontSize?: number, baseFont?: Stimulsoft.System.Drawing.Font): Stimulsoft.System.Drawing.Font;
        getCachedGdiFont(): Stimulsoft.System.Drawing.Font;
        private cachedFont;
        constructor(name: string, size: number, color: Color, isBold?: boolean);
    }
    export class StiElementConsts {
        static TitleFont: Font;
        static ForegroundColor: Color;
        static BackgroundColor: Color;
        static TreeView: {
            ItemHeight: number;
        };
        static ComboBox: {
            ItemHeight: number;
        };
        static Highlight: {
            Color: Color;
            DarkColor: Color;
        };
        static ListBox: {
            ItemHeight: number;
            CheckBoxWidth: number;
        };
        static Table: {
            Font: Font;
            BorderColor: Color;
            Height: number;
            getHeight: (font: Stimulsoft.System.Drawing.Font, scale?: number) => number;
            Header: {
                BackgroundColor: Color;
            };
        };
    }
    export {};
}
export namespace Stimulsoft.Base {
    enum StiDataFormatType {
        Xml = 0,
        Json = 1
    }
    enum StiRetrieveColumnsMode {
        KeyInfo = 0,
        SchemaOnly = 1,
        FillSchema = 2
    }
    enum StiConnectionIdent {
        Db2DataSource = 1,
        InformixDataSource = 2,
        MsAccessDataSource = 3,
        MsSqlDataSource = 4,
        MySqlDataSource = 5,
        OdbcDataSource = 6,
        OleDbDataSource = 7,
        FirebirdDataSource = 8,
        PostgreSqlDataSource = 9,
        OracleDataSource = 10,
        SqlCeDataSource = 11,
        SqLiteDataSource = 12,
        SybaseDataSource = 13,
        TeradataDataSource = 14,
        VistaDbDataSource = 15,
        UniversalDevartDataSource = 16,
        MariaDbDataSource = 17,
        SnowflakeDataSource = 18,
        ClickHouseDataSource = 19,
        ODataDataSource = 20,
        CsvDataSource = 21,
        DBaseDataSource = 22,
        DynamicsNavDataSource = 23,
        ExcelDataSource = 24,
        JsonDataSource = 25,
        GisDataSource = 26,
        XmlDataSource = 27,
        DropboxCloudStorage = 28,
        GoogleDriveCloudStorage = 29,
        OneDriveCloudStorage = 30,
        SharePointCloudStorage = 31,
        DataWorldDataSource = 32,
        QuickBooksDataSource = 33,
        Unspecified = 34
    }
    enum StiConnectionOrder {
        MsSqlDataSource = 10,
        MySqlDataSource = 20,
        OdbcDataSource = 30,
        OleDbDataSource = 40,
        OracleDataSource = 50,
        GisDataSource = 55,
        MsAccessDataSource = 60,
        PostgreSqlDataSource = 70,
        FirebirdDataSource = 80,
        SqlCeDataSource = 90,
        SqLiteDataSource = 100,
        Db2DataSource = 110,
        InformixDataSource = 120,
        SybaseDataSource = 130,
        TeradataDataSource = 140,
        VistaDbDataSource = 150,
        UniversalDevartDataSource = 160,
        MariaDbDataSource = 165,
        SnowflakeDataSource = 166,
        ClickHouseDataSource = 167,
        ODataDataSource = 170,
        ExcelDataSource = 180,
        JsonDataSource = 190,
        XmlDataSource = 200,
        CsvDataSource = 210,
        DBaseDataSource = 220,
        DynamicsNavDataSource = 230,
        DropboxCloudStorage = 240,
        GoogleDriveCloudStorage = 250,
        OneDriveCloudStorage = 260,
        SharePointCloudStorage = 270,
        DataWorldDataSource = 330,
        QuickBooksDataSource = 340,
        Unspecified = 0
    }
    enum StiFileType {
        Unknown = 1,
        ReportSnapshot = 2,
        Pdf = 3,
        Xps = 4,
        PowerPoint = 5,
        Html = 6,
        Text = 7,
        RichText = 8,
        Word = 9,
        OpenDocumentWriter = 10,
        Excel = 11,
        OpenDocumentCalc = 12,
        Data = 13,
        Image = 14,
        Xml = 15,
        Xsd = 16,
        Csv = 17,
        Dbf = 18,
        Sylk = 19,
        Dif = 20,
        Json = 21,
        Gis = 22
    }
}
export namespace Stimulsoft.Base {
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import DataTable = Stimulsoft.System.Data.DataTable;
    let IStiBIDataCache: System.Interface<IStiBIDataCache>;
    interface IStiBIDataCache {
        exists(dataSource: IStiAppDataSource): boolean;
        exists2(tableKey: string): boolean;
        remove(tableKey: string): void;
        clean(appKey: string): void;
        cleanAll(): void;
        getTableCount(): number;
        getRowCount(tableKey: string): number;
        getSchema(tableKey: string): DataTable;
        getData(tableKey: string): DataTable;
        runQuery(query: string): DataTable;
        add(appKey: string, tableKey: string, dataTable: DataTable): void;
        getTableName(appKey: string, tableKey: string): string;
    }
}
export namespace Stimulsoft.Base {
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiBIDataCacheHelper {
        private static checkInitialization;
        static exists(tableKey: string): boolean;
        static remove(tableKey: string): void;
        static clean(appKey: string): void;
        static cleanAll(): void;
        static getTableCount(): number;
        static getRowCount(tableKey: string): number;
        static runQuery(query: string): DataTable;
        static get(tableKey: string, loadData?: boolean): DataTable;
        static add(app: IStiApp, tableKey: string, dataTable: DataTable): void;
        static add2(appKey: string, tableKey: string, dataTable: DataTable): void;
        static getTableName(appKey: string, tableKey: string): string;
    }
}
export namespace Stimulsoft.Base {
    class StiBIDataCacheOptions {
        static enabled: boolean;
        static cache: IStiBIDataCache;
    }
}
export namespace Stimulsoft.Base.Data.StiDbType {
    enum Db2 {
        Invalid = 0,
        SmallInt = 1,
        Integer = 2,
        BigInt = 3,
        Real = 4,
        Double = 5,
        Float = 6,
        Decimal = 7,
        Numeric = 8,
        Date = 9,
        Time = 10,
        Timestamp = 11,
        Char = 12,
        VarChar = 13,
        LongVarChar = 14,
        Binary = 15,
        VarBinary = 16,
        LongVarBinary = 17,
        Graphic = 18,
        VarGraphic = 19,
        LongVarGraphic = 20,
        Clob = 21,
        Blob = 22,
        DbClob = 23,
        Datalink = 24,
        RowId = 25,
        Xml = 26,
        Real370 = 27,
        DecimalFloat = 28,
        DynArray = 29,
        BigSerial = 30,
        BinaryXml = 31,
        TimeStampWithTimeZone = 32,
        Cursor = 33,
        Serial = 34,
        Int8 = 35,
        Serial8 = 36,
        Money = 37,
        DateTime = 38,
        Text = 39,
        Byte = 40,
        SmallFloat = 1002,
        Null = 1003,
        NChar = 1006,
        NVarChar = 1007,
        Boolean = 1015,
        Other = 1016
    }
    enum DevartMySql {
        BigInt = 1,
        Binary = 2,
        Bit = 3,
        Blob = 4,
        Char = 5,
        Date = 6,
        DateTime = 7,
        Decimal = 8,
        Double = 9,
        Float = 10,
        Int = 11,
        SmallInt = 12,
        Text = 13,
        Time = 14,
        TimeStamp = 15,
        TinyInt = 16,
        VarBinary = 17,
        VarChar = 18,
        Year = 19,
        Guid = 20,
        Geometry = 21
    }
    enum DevartOracle {
        Array = 1,
        BFile = 2,
        Blob = 3,
        Boolean = 4,
        Char = 5,
        Clob = 6,
        Cursor = 7,
        Date = 8,
        Double = 9,
        Float = 10,
        Integer = 11,
        IntervalDS = 12,
        IntervalYM = 13,
        Long = 14,
        LongRaw = 15,
        NChar = 16,
        NClob = 17,
        NVarChar = 18,
        Number = 19,
        Object = 20,
        Ref = 21,
        Raw = 22,
        RowId = 23,
        Table = 24,
        TimeStamp = 25,
        TimeStampLTZ = 26,
        TimeStampTZ = 27,
        VarChar = 28,
        Xml = 29,
        AnyData = 30,
        Byte = 31,
        Int16 = 32,
        Int64 = 33
    }
    enum DevartPostgreSql {
        Row = 1,
        Array = 2,
        LargeObject = 3,
        Boolean = 16,
        ByteA = 17,
        BigInt = 20,
        SmallInt = 21,
        Int = 23,
        Text = 25,
        Json = 114,
        Xml = 142,
        Point = 600,
        LSeg = 601,
        Path = 602,
        Box = 603,
        Polygon = 604,
        Line = 628,
        CIdr = 650,
        Real = 700,
        Double = 701,
        Circle = 718,
        Money = 790,
        MacAddr = 829,
        Inet = 869,
        Char = 1042,
        VarChar = 1043,
        Date = 1082,
        Time = 1083,
        TimeStamp = 1114,
        TimeStampTZ = 1184,
        Interval = 1186,
        TimeTZ = 1266,
        Bit = 1560,
        VarBit = 1562,
        Numeric = 1700,
        Uuid = 2950,
        IntRange = 3904,
        NumericRange = 3906,
        TimeStampRange = 3908,
        TimeStampTZRange = 3910,
        DateRange = 3912,
        BigIntRange = 3926
    }
    enum Firebird {
        Array = 0,
        BigInt = 1,
        Binary = 2,
        Boolean = 3,
        Char = 4,
        Date = 5,
        Decimal = 6,
        Double = 7,
        Float = 8,
        Guid = 9,
        Integer = 10,
        Numeric = 11,
        SmallInt = 12,
        Text = 13,
        Time = 14,
        TimeStamp = 15,
        VarChar = 16
    }
    enum Informix {
        Char = 0,
        SmallInt = 1,
        Integer = 2,
        Float = 3,
        SmallFloat = 4,
        Real = 4,
        Decimal = 5,
        Serial = 6,
        Date = 7,
        Money = 8,
        Null = 9,
        DateTime = 10,
        Byte = 11,
        Text = 12,
        VarChar = 13,
        NChar = 15,
        NVarChar = 16,
        Int8 = 17,
        Serial8 = 18,
        Other = 99,
        LVarChar = 101,
        LongVarChar = 101,
        Blob = 110,
        Clob = 111,
        Boolean = 126,
        Invalid = 200,
        BigInt = 203,
        Double = 205,
        Numeric = 208,
        Time = 210,
        Timestamp = 211,
        Binary = 215,
        VarBinary = 216,
        LongVarBinary = 217,
        BigSerial = 230
    }
    enum MySql {
        Decimal = 0,
        Byte = 1,
        Int16 = 2,
        Int32 = 3,
        Float = 4,
        Double = 5,
        Timestamp = 7,
        Int64 = 8,
        Int24 = 9,
        Date = 10,
        Time = 11,
        DateTime = 12,
        Year = 13,
        Newdate = 14,
        VarString = 15,
        Bit = 16,
        NewDecimal = 246,
        Enum = 247,
        Set = 248,
        TinyBlob = 249,
        MediumBlob = 250,
        LongBlob = 251,
        Blob = 252,
        VarChar = 253,
        String = 254,
        Geometry = 255,
        UByte = 501,
        UInt16 = 502,
        UInt32 = 503,
        UInt64 = 508,
        UInt24 = 509,
        Binary = 600,
        VarBinary = 601,
        TinyText = 749,
        MediumText = 750,
        LongText = 751,
        Text = 752,
        Guid = 800
    }
    enum MsSql {
        BigInt = 0,
        Binary = 1,
        Bit = 2,
        Char = 3,
        DateTime = 4,
        Decimal = 5,
        Float = 6,
        Image = 7,
        Int = 8,
        Money = 9,
        NChar = 10,
        NText = 11,
        NVarChar = 12,
        Real = 13,
        UniqueIdentifier = 14,
        SmallDateTime = 15,
        SmallInt = 16,
        SmallMoney = 17,
        Text = 18,
        Timestamp = 19,
        TinyInt = 20,
        VarBinary = 21,
        VarChar = 22,
        Variant = 23,
        Xml = 25,
        Udt = 29,
        Structured = 30,
        Date = 31,
        Time = 32,
        DateTime2 = 33,
        DateTimeOffset = 34
    }
    enum Odbc {
        BigInt = 1,
        Binary = 2,
        Bit = 3,
        Char = 4,
        DateTime = 5,
        Decimal = 6,
        Numeric = 7,
        Double = 8,
        Image = 9,
        Int = 10,
        NChar = 11,
        NText = 12,
        NVarChar = 13,
        Real = 14,
        UniqueIdentifier = 15,
        SmallDateTime = 16,
        SmallInt = 17,
        Text = 18,
        Timestamp = 19,
        TinyInt = 20,
        VarBinary = 21,
        VarChar = 22,
        Date = 23,
        Time = 24
    }
    enum OleDb {
        Empty = 0,
        SmallInt = 2,
        Integer = 3,
        Single = 4,
        Double = 5,
        Currency = 6,
        Date = 7,
        BSTR = 8,
        IDispatch = 9,
        Error = 10,
        Boolean = 11,
        Variant = 12,
        IUnknown = 13,
        Decimal = 14,
        TinyInt = 16,
        UnsignedTinyInt = 17,
        UnsignedSmallInt = 18,
        UnsignedInt = 19,
        BigInt = 20,
        UnsignedBigInt = 21,
        Filetime = 64,
        Guid = 72,
        Binary = 128,
        Char = 129,
        WChar = 130,
        Numeric = 131,
        DBDate = 133,
        DBTime = 134,
        DBTimeStamp = 135,
        PropVariant = 138,
        VarNumeric = 139,
        VarChar = 200,
        LongVarChar = 201,
        VarWChar = 202,
        LongVarWChar = 203,
        VarBinary = 204,
        LongVarBinary = 205
    }
    enum Oracle {
        BFile = 101,
        Blob = 102,
        Byte = 103,
        Char = 104,
        Clob = 105,
        Date = 106,
        Decimal = 107,
        Double = 108,
        Long = 109,
        LongRaw = 110,
        Int16 = 111,
        Int32 = 112,
        Int64 = 113,
        IntervalDS = 114,
        IntervalYM = 115,
        NClob = 116,
        NChar = 117,
        NVarchar2 = 119,
        Raw = 120,
        RefCursor = 121,
        Single = 122,
        TimeStamp = 123,
        TimeStampLTZ = 124,
        TimeStampTZ = 125,
        Varchar2 = 126,
        XmlType = 127,
        BinaryDouble = 132,
        BinaryFloat = 133
    }
    enum OracleClient {
        BFile = 1,
        Blob = 2,
        Char = 3,
        Clob = 4,
        Cursor = 5,
        DateTime = 6,
        IntervalDayToSecond = 7,
        IntervalYearToMonth = 8,
        LongRaw = 9,
        LongVarChar = 10,
        NChar = 11,
        NClob = 12,
        Number = 13,
        NVarChar = 14,
        Raw = 15,
        RowId = 16,
        Timestamp = 18,
        TimestampLocal = 19,
        TimestampWithTZ = 20,
        VarChar = 22,
        Byte = 23,
        UInt16 = 24,
        UInt32 = 25,
        SByte = 26,
        Int16 = 27,
        Int32 = 28,
        Float = 29,
        Double = 30
    }
    enum PostgreSql {
        Array = -2147483648,
        Bigint = 1,
        Boolean = 2,
        Box = 3,
        Bytea = 4,
        Circle = 5,
        Char = 6,
        Date = 7,
        Double = 8,
        Integer = 9,
        Line = 10,
        LSeg = 11,
        Money = 12,
        Numeric = 13,
        Path = 14,
        Point = 15,
        Polygon = 16,
        Real = 17,
        Smallint = 18,
        Text = 19,
        Time = 20,
        Timestamp = 21,
        Varchar = 22,
        Refcursor = 23,
        Inet = 24,
        Bit = 25,
        TimestampTZ = 26,
        Uuid = 27,
        Xml = 28,
        Oidvector = 29,
        Interval = 30,
        TimeTZ = 31,
        Name = 32,
        Abstime = 33,
        MacAddr = 34,
        Json = 35,
        Jsonb = 36,
        Hstore = 37
    }
    enum SqlCe {
        BigInt = 0,
        Binary = 1,
        Bit = 2,
        Char = 3,
        DateTime = 4,
        Decimal = 5,
        Float = 6,
        Image = 7,
        Int = 8,
        Money = 9,
        NChar = 10,
        NText = 11,
        NVarChar = 12,
        Real = 13,
        UniqueIdentifier = 14,
        SmallDateTime = 15,
        SmallInt = 16,
        SmallMoney = 17,
        Text = 18,
        Timestamp = 19,
        TinyInt = 20,
        VarBinary = 21,
        VarChar = 22,
        Variant = 23,
        Xml = 25,
        Udt = 29,
        Structured = 30,
        Date = 31,
        Time = 32,
        DateTime2 = 33,
        DateTimeOffset = 34
    }
    enum SqLite {
        Uninitialized = 0,
        Int64 = 1,
        Double = 2,
        Text = 3,
        Blob = 4,
        Null = 5,
        DateTime = 10,
        None = 11
    }
    enum Sybase {
        UnsignedBigInt = -208,
        UnsignedInt = -207,
        UnsignedSmallInt = -206,
        NVarChar = -205,
        NChar = -204,
        TimeStamp = -203,
        SmallDateTime = -202,
        SmallMoney = -201,
        Money = -200,
        Unitext = -10,
        UniVarChar = -9,
        UniChar = -8,
        Bit = -7,
        TinyInt = -6,
        BigInt = -5,
        Image = -4,
        VarBinary = -3,
        Binary = -2,
        Text = -1,
        Unsupported = 0,
        Char = 1,
        Numeric = 2,
        Decimal = 3,
        Integer = 4,
        SmallInt = 5,
        Real = 7,
        Double = 8,
        VarChar = 12,
        Date = 91,
        Time = 92,
        BigDateTime = 93,
        DateTime = 93
    }
    enum Teradata {
        BigInt = 90,
        Blob = 100,
        Byte = 110,
        ByteInt = 120,
        Char = 130,
        Clob = 140,
        Date = 150,
        Decimal = 160,
        Double = 170,
        Graphic = 180,
        Integer = 190,
        IntervalDay = 200,
        IntervalDayToHour = 210,
        IntervalDayToMinute = 220,
        IntervalDayToSecond = 230,
        IntervalHour = 240,
        IntervalHourToMinute = 250,
        IntervalHourToSecond = 260,
        IntervalMinute = 270,
        IntervalMinuteToSecond = 280,
        IntervalSecond = 290,
        IntervalYear = 300,
        IntervalYearToMonth = 310,
        IntervalMonth = 320,
        SmallInt = 330,
        Time = 340,
        TimeWithZone = 350,
        Timestamp = 360,
        TimestampWithZone = 370,
        VarByte = 380,
        VarChar = 390,
        VarGraphic = 400,
        PeriodDate = 410,
        PeriodTime = 420,
        PeriodTimeWithTimeZone = 430,
        PeriodTimestamp = 440,
        PeriodTimestampWithTimeZone = 450,
        Number = 460,
        Xml = 480,
        Json = 500,
        AnyType = 65535
    }
    enum Universal {
        Array = 0,
        BigInt = 1,
        Binary = 2,
        Bit = 3,
        Blob = 4,
        Boolean = 5,
        Byte = 6,
        Char = 7,
        Clob = 8,
        Currency = 9,
        Cursor = 10,
        Date = 11,
        DateTime = 12,
        Decimal = 13,
        Double = 14,
        Guid = 15,
        Int = 16,
        IntervalDS = 17,
        IntervalYM = 18,
        NChar = 19,
        NClob = 20,
        NVarChar = 21,
        Object = 22,
        Single = 23,
        SmallInt = 24,
        TinyInt = 25,
        Time = 26,
        TimeStamp = 27,
        VarChar = 28,
        Xml = 29,
        TimeStampTZ = 30,
        DateTime2 = 31
    }
    enum VistaDb {
        Uninitialized = -1,
        Char = 1,
        NChar = 2,
        VarChar = 3,
        NVarChar = 4,
        Text = 5,
        NText = 6,
        TinyInt = 8,
        SmallInt = 9,
        Int = 10,
        BigInt = 11,
        Real = 12,
        Float = 13,
        Decimal = 14,
        Money = 15,
        SmallMoney = 16,
        Bit = 17,
        DateTime = 19,
        Image = 20,
        UniqueIdentifier = 22,
        SmallDateTime = 23,
        Timestamp = 24,
        Binary = 25,
        VarBinary = 26,
        Time = 27,
        Date = 28,
        DateTime2 = 29,
        DateTimeOffset = 30,
        Unknown = 31
    }
    enum Pdo {
        String = 0
    }
    enum MariaDb {
        Binary = 1,
        Bit = 2,
        Blob = 3,
        Byte = 4,
        Date = 5,
        DateTime = 6,
        Decimal = 7,
        Double = 8,
        Enum = 9,
        Float = 10,
        Geometry = 11,
        Guid = 12,
        Int16 = 13,
        Int24 = 14,
        Int32 = 15,
        Int64 = 16,
        LongBlob = 17,
        LongText = 18,
        MediumBlob = 19,
        MediumText = 20,
        Newdate = 21,
        NewDecimal = 22,
        Set = 23,
        String = 24,
        Text = 25,
        Time = 26,
        TimeStamp = 27,
        TinyBlob = 28,
        TinyText = 29,
        UByte = 30,
        UInt16 = 31,
        UInt24 = 32,
        UInt32 = 33,
        UInt64 = 34,
        VarBinary = 35,
        VarChar = 36,
        VarString = 37,
        Year = 38
    }
    enum Snowflake {
        None = 1,
        Fixed = 2,
        Real = 3,
        Text = 4,
        Date = 5,
        Variant = 6,
        Timestamp_ltz = 7,
        Timestamp_ntz = 8,
        Timestamp_tz = 9,
        Object = 10,
        Binary = 11,
        Time = 12,
        Boolean = 13,
        Array = 14
    }
    enum ClickHouse {
        Int8 = 1,
        UInt8 = 2,
        Int16 = 3,
        UInt16 = 4,
        Int32 = 5,
        UInt32 = 6,
        Int64 = 7,
        UInt64 = 8,
        Float32 = 9,
        Float64 = 10,
        Decimal = 11,
        Boolean = 12,
        String = 13,
        DateTime = 14,
        UUID = 15
    }
}
export namespace Stimulsoft.ExternalLibrary.XLSX {
    interface IProperties {
        LastAuthor?: string;
        Author?: string;
        CreatedDate?: Date;
        ModifiedDate?: Date;
        Application?: string;
        AppVersion?: string;
        Company?: string;
        DocSecurity?: string;
        Manager?: string;
        HyperlinksChanged?: boolean;
        SharedDoc?: boolean;
        LinksUpToDate?: boolean;
        ScaleCrop?: boolean;
        Worksheets?: number;
        SheetNames?: string[];
    }
    interface IParsingOptions {
        cellFormula?: boolean;
        cellHTML?: boolean;
        cellNF?: boolean;
        cellStyles?: boolean;
        cellDates?: boolean;
        sheetStubs?: boolean;
        sheetRows?: number;
        bookDeps?: boolean;
        bookFiles?: boolean;
        bookProps?: boolean;
        bookSheets?: boolean;
        bookVBA?: boolean;
        password?: string;
        type?: string;
    }
    interface IWorkBook {
        Sheets: {
            [sheet: string]: IWorkSheet;
        };
        SheetNames: string[];
        Props: IProperties;
    }
    interface IWorkSheet {
        [cell: string]: IWorkSheetCell;
    }
    interface IWorkSheetCell {
        t: string;
        v: string;
        r?: string;
        h?: string;
        w?: string;
        f?: string;
        c?: string;
        z?: string;
        l?: string;
        s?: string;
    }
    interface IUtils {
        sheet_to_json<T>(worksheet: IWorkSheet): T[];
        sheet_to_csv(worksheet: IWorkSheet): any;
        sheet_to_formulae(worksheet: IWorkSheet): any;
    }
    let utils: IUtils;
    function readFile(filename: string, opts?: IParsingOptions): IWorkBook;
    function read(data: any, opts?: IParsingOptions): IWorkBook;
}
export namespace Stimulsoft.Base.Data.Connectors {
    class StiConnectionStringHelper {
        static getConnectionStringKey(connectionString: string, key: string, separators?: string[]): string;
        static getConnectionStringKey2(connectionString: string): string;
        static setConnectionStringKey(connectionString: string, key: string, value: string): string;
        static removeConnectionStringKey(connectionString: string, key: string): string;
    }
}
export namespace Stimulsoft.Base {
    class StiDataConnector {
        static advancedRetrievalModeOfDatabaseSchema: boolean;
        static getSchemaColumnsMode: boolean;
        connectionIdent: StiConnectionIdent;
        connectionOrder: StiConnectionOrder;
        name: string;
        nuGetPackages: string[];
        nuGetVersion: string;
        isAvailable: boolean;
        resetSettings(): void;
        getFamilyConnectors(): StiDataConnector[];
    }
}
export namespace Stimulsoft.Base {
    import Header = Stimulsoft.System.Header;
    class StiDataLoaderHelperData {
        name: string;
        array: any;
        toList(): StiDataLoaderHelperData[];
        constructor(name: string, array: any);
    }
    class StiDataLoaderHelper {
        static loadMultiple(path: string, fileExt: string, binary: boolean, headers: Header[], withCredentials?: boolean): StiDataLoaderHelperData[];
        static loadSingle(path: string, binary: boolean, headers: Header[], withCredentials?: boolean, allowException?: boolean): StiDataLoaderHelperData;
    }
}
export namespace Stimulsoft.Base.StiDataOptions {
    class SampleConnectionString {
        static dataWorld: string;
        static oData: string;
        static quickBooks: string;
        static graphQL: string;
        static azureSql: string;
        static cosmosSql: string;
        static bigQuery: string;
        static firebase: string;
        static mongoDb: string;
        static db2: string;
        static firebird: string;
        static informix: string;
        static msAccess: string;
        static mySql: string;
        static odbc: string;
        static oleDb: string;
        static oracle: string;
        static postgreSql: string;
        static sqlCe: string;
        static msSql: string;
        static sqLite: string;
        static sybase: string;
        static snowflake: string;
        static clickHouse: string;
        static sybaseAds: string;
        static teradata: string;
        static mariaDb: string;
        static vistaDb: string;
        static googleAnalytics: string;
        static azureTableStorage: string;
        static azureBlobStorage: string;
        static cDataConnectCloud: string;
        static msAnalysis: string;
    }
}
export namespace Stimulsoft.Base {
    import Header = Stimulsoft.System.Header;
    class StiFileUrlHelper {
        static get(path: string, headers: Header[]): number[];
    }
}
export namespace Stimulsoft.Base {
    class StiTableName {
        static getName(schema: string, table: string): string;
    }
}
export namespace Stimulsoft.Base {
    class StiTableQuery {
        private correctName;
        getName(schema: string, table: string): string;
        getSelectQuery(table: string): string;
        getSelectQuery2(schema: string, table: string): string;
        getExecuteQuery(table: string): string;
        getExecuteQuery2(schema: string, table: string): string;
        getCallQuery(table: string): string;
        getCallQuery2(schema: string, table: string): string;
        getProcQuery(table: string): string;
        getProcQuery2(schema: string, table: string): string;
        static get(connector: StiSqlDataConnector): StiTableQuery;
        private connector;
        constructor(connector: StiSqlDataConnector);
    }
}
export namespace Stimulsoft.Base {
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiFileDataConnector extends StiDataConnector {
        fileType: StiFileType;
        retrieveSchema(options: StiFileDataOptions): StiDataSchema;
        testConnection(options: StiFileDataOptions): StiTestConnectionResult;
        getDataSet(options: StiFileDataOptions): DataSet;
        static get(ident: StiConnectionIdent): StiFileDataConnector;
    }
}
export namespace Stimulsoft.Base {
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiCsvConnector extends StiFileDataConnector {
        connectionIdent: StiConnectionIdent;
        connectionOrder: StiConnectionOrder;
        name: string;
        isAvailable: boolean;
        fileType: StiFileType;
        getDataSet(options: StiFileDataOptions): DataSet;
        private getDataSetFromPath;
        static get(): StiCsvConnector;
    }
}
export namespace Stimulsoft.Base {
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiDBaseConnector extends StiFileDataConnector {
        connectionIdent: StiConnectionIdent;
        connectionOrder: StiConnectionOrder;
        name: string;
        isAvailable: boolean;
        fileType: StiFileType;
        getDataSet(options: StiFileDataOptions): DataSet;
        static get(): StiDBaseConnector;
    }
}
export namespace Stimulsoft.Base {
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiExcelConnector extends StiFileDataConnector {
        connectionIdent: StiConnectionIdent;
        connectionOrder: StiConnectionOrder;
        name: string;
        isAvailable: boolean;
        fileType: StiFileType;
        getDataSet(options: StiFileDataOptions): DataSet;
        static get(): StiExcelConnector;
    }
}
export namespace Stimulsoft.Base {
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiGisConnector extends StiFileDataConnector {
        connectionIdent: StiConnectionIdent;
        connectionOrder: StiConnectionOrder;
        name: string;
        isAvailable: boolean;
        fileType: StiFileType;
        getDataSet(options: StiFileDataOptions): DataSet;
        static get(): StiGisConnector;
    }
}
export namespace Stimulsoft.Base {
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiJsonConnector extends StiFileDataConnector {
        connectionIdent: StiConnectionIdent;
        connectionOrder: StiConnectionOrder;
        name: string;
        isAvailable: boolean;
        fileType: StiFileType;
        getDataSet(options: StiFileDataOptions): DataSet;
        static get(): StiJsonConnector;
    }
}
export namespace Stimulsoft.Base {
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiXmlConnector extends StiFileDataConnector {
        connectionIdent: StiConnectionIdent;
        connectionOrder: StiConnectionOrder;
        name: string;
        isAvailable: boolean;
        fileType: StiFileType;
        getDataSet(options: StiFileDataOptions): DataSet;
        static get(): StiXmlConnector;
    }
}
export namespace Stimulsoft.Base {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import DataSet = Stimulsoft.System.Data.DataSet;
    import Header = Stimulsoft.System.Header;
    class StiCsvHelper {
        static codePageCodes: number[];
        static codePageNames: string[];
        static getTable(path: string, codePage: number, separator: string, maxDataRows: number, headers: Header[]): DataTable;
        static getDataSet(data: number[] | Uint8Array | string, tableName: string, codePage: number, separator: string, maxDataRows?: number): DataSet;
        static getTable2(data: number[] | Uint8Array, codePage?: number, separator?: string, loadData?: boolean, maxDataRows?: number): DataTable;
        private static splitToColumns;
    }
}
export namespace Stimulsoft.Base {
    class StiDataNameValidator {
        static correct(str: string): string;
    }
}
export namespace Stimulsoft.Base {
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiExcelHelper {
        static typeFromAllRows: boolean;
        static getDataSetFromExcelDocument(content: number[], firstRowIsHeader: boolean, maxDataRows?: number): DataSet;
        private static getNumber;
        private static getType;
        private static getTypeCell;
        private static getTicksForTimeSpan;
        private static isTimeSpan;
        private static getTimeSpan;
    }
}
export namespace Stimulsoft.Base {
    class StiFileItemTable {
        static defaultCsvTableName: string;
        static defaultDBaseTableName: string;
    }
}
export namespace Stimulsoft.Base {
    import DataSet = Stimulsoft.System.Data.DataSet;
    import Header = Stimulsoft.System.Header;
    class StiFileDataOptions {
        content: number[] | Uint8Array | string;
        dataSet: DataSet;
        headers: Header[];
        maxDataRows: number;
        constructor(content: number[] | string | Uint8Array);
    }
}
export namespace Stimulsoft.Base {
    class StiCsvOptions extends StiFileDataOptions {
        path: string;
        tableName: string;
        codePage: number;
        separator: string;
        constructor(content: string, tableName: string, codePage?: number, separator?: string);
    }
}
export namespace Stimulsoft.Base {
    class StiDBaseOptions extends StiFileDataOptions {
        path: string;
        tableName: string;
        codePage: number;
        constructor(content: number[], tableName: string, codePage?: number);
    }
}
export namespace Stimulsoft.Base {
    class StiExcelOptions extends StiFileDataOptions {
        firstRowIsHeader: boolean;
        constructor(content: number[], firstRowIsHeader?: boolean);
    }
}
export namespace Stimulsoft.Base {
    class StiGisOptions extends StiFileDataOptions {
        separator: string;
        dataType: StiGisDataType;
        constructor(content: number[] | string, separator: string, dataType: StiGisDataType);
    }
}
export namespace Stimulsoft.Base {
    class StiJsonOptions extends StiFileDataOptions {
        relationDirection: StiRelationDirection;
        constructor(content: number[] | string, relationDirection?: StiRelationDirection);
    }
}
export namespace Stimulsoft.Base {
    class StiXmlOptions extends StiFileDataOptions {
        schema: number[] | string;
        isAdoNet: boolean;
        relationDirection: StiRelationDirection;
        constructor(schema: number[] | string, content: number[] | string, isAdoNet: boolean, relationDirection: StiRelationDirection);
    }
}
export namespace Stimulsoft.Base {
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiNoSqlDataConnector extends StiDataConnector {
        connectionString: string;
        testConnection(): StiTestConnectionResult;
        retrieveSchema(allowException?: boolean): StiDataSchema;
        getSampleConnectionString(): string;
        getColumns(collectionName: string): StiDataColumnSchema[];
        getDataTable(collectionName: string, query: string, index?: number, count?: number): DataTable;
    }
}
export namespace Stimulsoft.Base {
    class StiDbNoSqlDataConnector extends StiNoSqlDataConnector {
        close(): void;
        open(): void;
    }
}
export namespace Stimulsoft.Base {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import DateTime = Stimulsoft.System.DateTime;
    class StiMongoDbConnector extends StiDbNoSqlDataConnector {
        private mongoProvider;
        private getMongoDBProvider;
        testConnection(): StiTestConnectionResult;
        retrieveSchema(allowException?: boolean): StiDataSchema;
        getSampleConnectionString(): string;
        getColumns(collectionName: string): StiDataColumnSchema[];
        getDataTable(collectionName: string, query: string, index?: number, count?: number): DataTable;
        convertDateTimeToJsonStr(date: DateTime): string;
    }
}
export namespace Stimulsoft.Base {
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiDataWorldConnector extends StiDbNoSqlDataConnector {
        getColumns(collectionName: string): StiDataColumnSchema[];
        getDataTable(collectionName: string, query: string): DataTable;
        getSampleConnectionString(): string;
        retrieveSchema(allowException?: boolean): StiDataSchema;
        testConnection(): StiTestConnectionResult;
        static get(connectionString: string): StiDataWorldConnector;
        connectionString: string;
        constructor(connectionString: string);
    }
}
export namespace Stimulsoft.Base {
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiDataWorldHelper {
        urlBase: string;
        private getDefaultWebClient;
        getTableNames(): string[];
        getColumns(collectionName: string): StiDataColumnSchema[];
        getDataTable(collectionName: string, query: string): DataTable;
        testConnection(): StiTestConnectionResult;
        retrieveSchema(): StiDataSchema;
        private getConnectionStringKey;
        private getConnectionStringKey1;
        connectionString: string;
        get owner(): string;
        get token(): string;
        get database(): string;
        constructor(connectionString: string);
    }
}
export namespace Stimulsoft.Base {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiGraphQLConnector extends StiDbNoSqlDataConnector {
        getDataTable(collectionName: string, query: string, index?: number, count?: number): DataTable;
        getDataTable2(collectionName: string, variable: Hashtable<string, object>): DataTable;
        static get(connectionString: string): StiGraphQLConnector;
        connectionString: string;
        constructor(connectionString: string);
    }
}
export namespace Stimulsoft.Base {
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiQuickBooksConnector {
        private stimulsoftClientId;
        private stimulsoftClientSecret;
        private oauth2Url;
        private bearerUrl;
        private baseUrl;
        private stimulsoftRedirectUrl;
        private responseType;
        private scope;
        private state;
        connectionString: string;
        connectionIdent: StiConnectionIdent;
        connectionOrder: StiConnectionOrder;
        name: string;
        isAvailable: boolean;
        get useApp(): boolean;
        set useApp(value: boolean);
        get clientId(): string;
        set clientId(value: string);
        get clientIdPrivate(): string;
        set clientIdPrivate(value: string);
        get clientSecret(): string;
        set clientSecret(value: string);
        get clientSecretPrivate(): string;
        set clientSecretPrivate(value: string);
        get redirectURL(): string;
        set redirectURL(value: string);
        get redirectURLPrivate(): string;
        set redirectURLPrivate(value: string);
        get authorizationCode(): string;
        set authorizationCode(value: string);
        get realmId(): string;
        set realmId(value: string);
        get accessToken(): string;
        set accessToken(value: string);
        get refreshToken(): string;
        set refreshToken(value: string);
        connectionTimeout: number;
        fillAuthorizationCode(): void;
        private getDefaultWebClient;
        private getAuthorizationUrl;
        fillTokens(): void;
        refreshAccessToken(): void;
        private getTableNames;
        private getColumns;
        retrieveSchema(allowException?: boolean): StiDataSchema;
        getDataTable(collectionName: string, query: string): DataTable;
        fillDataTable(table: DataTable, query: string): void;
        private executeQuery;
        private removeUnsupportedColumns;
        private correctRefColumns;
        getSampleConnectionString(): string;
        static Get(connectionString?: string): StiQuickBooksConnector;
        constructor(connectionString?: string);
    }
}
export namespace Stimulsoft.Base {
    class StiDataRelationSchema {
        name: string;
        parentSourceName: string;
        childSourceName: string;
        parentColumns: string[];
        childColumns: string[];
        constructor(name: string, parentSourceName: string, childSourceName: string, parentColumns: string[], childColumns: string[]);
    }
}
export namespace Stimulsoft.Base {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiGraphQLHelper {
        private getDefaultWebClient;
        testConnection(): StiTestConnectionResult;
        getDataTable(collectionName: string, count: number): DataTable;
        private getDataSet;
        private getHeaders;
        private loadColumnsAndStringRowsFromPackedString;
        private loadColumnsAndStringRowsFromString;
        getConnectionStringKey(key: string, splitter: string): string;
        private getQuery;
        retrieveSchema(): StiDataSchema;
        getColumns(table: DataTable): StiDataColumnSchema[];
        getColumnsByTableName(tableName: string): StiDataColumnSchema[];
        connectionString: string;
        variables: Hashtable<string, object>;
        get endPoint(): string;
        get query(): string;
        get headers(): string;
        constructor(connectionString: string, variables: Hashtable<string, object>);
    }
}
export namespace Stimulsoft.Base {
    class StiObjectSchema {
        name: string;
    }
}
export namespace Stimulsoft.Base {
    import List = Stimulsoft.System.Collections.List;
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiDataSchema extends StiObjectSchema {
        tables: List<StiDataTableSchema>;
        views: List<StiDataTableSchema>;
        storedProcedures: List<StiDataTableSchema>;
        queries: List<StiDataTableSchema>;
        relations: List<StiDataRelationSchema>;
        connectionIdent: StiConnectionIdent;
        isEmpty(): boolean;
        getDataSet(): DataSet;
        sort(): StiDataSchema;
        constructor(ident?: StiConnectionIdent);
    }
}
export namespace Stimulsoft.Base {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import Type = Stimulsoft.System.Type;
    import Header = Stimulsoft.System.Header;
    class StiODataHelper {
        connectionString: string;
        get address(): string;
        get userName(): string;
        get password(): string;
        get addressBearer(): string;
        get clientId(): string;
        headers: Header[];
        allowException: boolean;
        private getConnectionStringKey;
        private getConnectionStringKey1;
        private bearerAccessToken;
        retrieveSchema(): StiDataSchema;
        fillDataTable(table: DataTable, query: string): void;
        testConnection(): StiTestConnectionResult;
        getColumns(collectionName: string): StiDataColumnSchema[];
        static getNetType(dbType: string): Type;
        static getBearerAccessToken(url: string, userName: string, password: string, clientId: string): string;
        private getDefaultWebClient;
        constructor(connectionString: string);
    }
}
export namespace Stimulsoft.Base {
    type StiSqlDataConnector = {
        getDatabaseSpecificName: (name: string) => string;
    };
}
export namespace Stimulsoft.Base {
    class StiTestConnectionResult {
        success: boolean;
        notice: string;
        static makeWrong(notice: string): StiTestConnectionResult;
        static makeWrong2(exception: string): StiTestConnectionResult;
        static makeWrong3(): StiTestConnectionResult;
        static makeFine(): StiTestConnectionResult;
    }
}
export namespace Stimulsoft.Base {
    class StiDataColumnSchema extends StiObjectSchema {
        type: Stimulsoft.System.Type;
        constructor(name: string, type: Stimulsoft.System.Type);
    }
}
export namespace Stimulsoft.Base {
    class StiDataParameterSchema extends StiObjectSchema {
        type: Stimulsoft.System.Type;
        value: any;
        constructor(name?: string, type?: Stimulsoft.System.Type);
    }
}
export namespace Stimulsoft.Base {
    class StiDataTableSchema extends StiObjectSchema {
        columns: StiDataColumnSchema[];
        parameters: StiDataParameterSchema[];
        query: string;
        static newTableOrView(name: string, connector?: StiSqlDataConnector, query?: string): StiDataTableSchema;
        static newTable(name: string, connector?: StiSqlDataConnector, query?: string): StiDataTableSchema;
        static newView(name: string, connector?: StiSqlDataConnector, query?: string): StiDataTableSchema;
        static newProcedure(name: string, connector?: StiSqlDataConnector, query?: string): StiDataTableSchema;
        constructor(name?: string, query?: string);
    }
}
export namespace Stimulsoft.Base.Drawing {
    enum StiCheckState {
        Unchecked = 1,
        Checked = 2,
        Indeterminate = 3
    }
    enum StiAction {
        None = 0,
        Move = 1,
        Select = 2,
        SizeLeft = 3,
        SizeRight = 4,
        SizeTop = 5,
        SizeBottom = 6,
        SizeLeftTop = 7,
        SizeLeftBottom = 8,
        SizeRightTop = 9,
        SizeRightBottom = 10,
        ResizeColumns = 11,
        ResizeRows = 12,
        SelectColumn = 13,
        SelectRow = 14
    }
    enum StiBorderSides {
        None = 0,
        All = 15,
        Top = 1,
        Left = 2,
        Right = 4,
        Bottom = 8
    }
    enum StiPenStyle {
        Solid = 0,
        Dash = 1,
        DashDot = 2,
        DashDotDot = 3,
        Dot = 4,
        Double = 5,
        None = 6
    }
    enum StiRotationMode {
        LeftTop = 0,
        LeftCenter = 1,
        LeftBottom = 2,
        CenterTop = 3,
        CenterCenter = 4,
        CenterBottom = 5,
        RightTop = 6,
        RightCenter = 7,
        RightBottom = 8
    }
    enum StiShadowSides {
        Top = 1,
        Right = 2,
        Edge = 4,
        Bottom = 8,
        Left = 16,
        All = 31
    }
    enum StiVertAlignment {
        Top = 0,
        Center = 1,
        Bottom = 2
    }
    enum StiTextHorAlignment {
        Left = 0,
        Center = 1,
        Right = 2,
        Width = 3
    }
    enum StiHorAlignment {
        Left = 1,
        Center = 2,
        Right = 3
    }
    enum StiTextDockMode {
        Top = 0,
        Bottom = 1,
        Left = 2,
        Right = 3
    }
    enum StiBrushIdent {
        Empty = 1,
        Solid = 2,
        Gradient = 3,
        Glare = 4,
        Glass = 5,
        Hatch = 6,
        Default = 7,
        Style = 8
    }
    enum StiBorderIdent {
        Border = 1,
        AdvancedBorder = 2
    }
    enum StiCapStyle {
        None = 0,
        Arrow = 1,
        Open = 2,
        Stealth = 3,
        Diamond = 4,
        Square = 5,
        Oval = 6
    }
    enum StiTableColumnVisibility {
        True = 0,
        TrueAndHidden = 1,
        False = 2,
        Expression = 3
    }
    enum StiCardsColumnVisibility {
        True = 0,
        False = 1,
        Expression = 2
    }
    enum StiButtonShapeType {
        Rectangle = 0,
        Circle = 1
    }
}
export namespace Stimulsoft.Base.Drawing {
    let PointD: typeof System.Drawing.Point;
}
export namespace Stimulsoft.Base.Drawing {
    let RectangleD: typeof System.Drawing.Rectangle;
}
export namespace Stimulsoft.Base.Drawing {
    let SizeD: typeof System.Drawing.Size;
}
export namespace Stimulsoft.Base.Drawing {
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiActionUtils {
        static pointInEdge(x: number, y: number, point: Point, size: number): boolean;
        static pointInRect(x: number, y: number, rect: Rectangle): boolean;
    }
}
export namespace Stimulsoft.Base.Drawing {
    import IAsIs = Stimulsoft.System.IAsIs;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    import Brush = Stimulsoft.System.Drawing.Brush;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiBrush implements ICloneable, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        clone(): StiBrush;
        memberwiseClone(): StiBrush;
        equals(obj: any): boolean;
        static convertToBrush(text: string): StiBrush;
        static loadFromXml(text: string): StiBrush;
        static light(baseBrush: StiBrush, value: number): StiBrush;
        static dark(baseBrush: StiBrush, value: number): StiBrush;
        static getBrush(brush: StiBrush, rect: Rectangle): Brush;
        static toColor(brush: StiBrush): Color;
        static isEmpty(brush: StiBrush): boolean;
        static isTransparent(brush: StiBrush): boolean;
    }
}
export namespace Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSolidBrush extends StiBrush {
        memberwiseClone(): StiBrush;
        color: Color;
        constructor(color?: Color);
    }
}
export namespace Stimulsoft.Base.Drawing {
    import IAsIs = Stimulsoft.System.IAsIs;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    class StiBorder implements ICloneable, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        private bits;
        clone(): StiBorder;
        equals(obj: StiBorder | any): boolean;
        getSizeOffset(): number;
        getSize(): number;
        getHashCode(): number;
        private defaultHashCode;
        getSizeIncludingSide(): number;
        draw(g: Graphics, rect: Rectangle, zoom: number, emptyColor?: Color, drawBorderFormatting?: boolean, drawBorderSides?: boolean): void;
        drawBorderShadow(g: Graphics, rect: Rectangle, zoom: number): void;
        get isTopBorderSidePresent(): boolean;
        get isBottomBorderSidePresent(): boolean;
        get isLeftBorderSidePresent(): boolean;
        get isRightBorderSidePresent(): boolean;
        get isAllBorderSidesPresent(): boolean;
        private get isDefaultShadowBrush();
        get side(): StiBorderSides;
        set side(value: StiBorderSides);
        get color(): Color;
        set color(value: Color);
        get size(): number;
        set size(value: number);
        get style(): StiPenStyle;
        set style(value: StiPenStyle);
        private _shadowBrush;
        get shadowBrush(): StiBrush;
        set shadowBrush(value: StiBrush);
        get shadowSize(): number;
        set shadowSize(value: number);
        get dropShadow(): boolean;
        set dropShadow(value: boolean);
        get topmost(): boolean;
        set topmost(value: boolean);
        static loadFromXml(text: string): StiBorder;
        constructor(side?: StiBorderSides, color?: Color, size?: number, style?: StiPenStyle, dropShadow?: boolean, shadowSize?: number, shadowBrush?: StiBrush, topmost?: boolean);
    }
}
export namespace Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiAdvancedBorder extends StiBorder {
        clone(): StiAdvancedBorder;
        equals(obj: StiAdvancedBorder | any): boolean;
        getHashCode(): number;
        private _leftSide;
        get leftSide(): StiBorderSide;
        private _rightSide;
        get rightSide(): StiBorderSide;
        private _topSide;
        get topSide(): StiBorderSide;
        private _bottomSide;
        get bottomSide(): StiBorderSide;
        get isTopBorderSidePresent(): boolean;
        get isBottomBorderSidePresent(): boolean;
        get isLeftBorderSidePresent(): boolean;
        get isRightBorderSidePresent(): boolean;
        get isAllBorderSidesPresent(): boolean;
        get side(): StiBorderSides;
        set side(value: StiBorderSides);
        get color(): Color;
        set color(value: Color);
        get size(): number;
        set size(value: number);
        get style(): StiPenStyle;
        set style(value: StiPenStyle);
        constructor(topSide?: StiBorderSide, bottomSide?: StiBorderSide, leftSide?: StiBorderSide, rightSide?: StiBorderSide, dropShadow?: boolean, shadowSize?: number, shadowBrush?: StiBrush, topmost?: boolean);
    }
}
export namespace Stimulsoft.Report.Helpers {
    enum StiFontIconSet {
        Rating = 0,
        Quarter = 1,
        Square = 2,
        Star = 3,
        Latin = 4
    }
    enum StiFontIconGroup {
        WebApplicationIcons = 0,
        AccessibilityIcons = 1,
        HandIcons = 2,
        TransportationIcons = 3,
        GenderIcons = 4,
        FileTypeIcons = 5,
        SpinnerIcons = 6,
        FormControlIcons = 7,
        PaymentIcons = 8,
        ChartIcons = 9,
        CurrencyIcons = 10,
        TextEditorIcons = 11,
        DirectionalIcons = 12,
        VideoPlayerIcons = 13,
        BrandIcons = 14,
        MedicalIcons = 15,
        OtherIcons = 16
    }
    enum StiFontIcons {
        Latin5 = 0,
        Latin4 = 1,
        Latin3 = 2,
        Latin2 = 3,
        Latin1 = 4,
        QuarterFull = 5,
        QuarterThreeFourth = 6,
        QuarterHalf = 7,
        QuarterQuarter = 8,
        QuarterNone = 9,
        Rating4 = 10,
        Rating3 = 11,
        Rating2 = 12,
        Rating1 = 13,
        Rating0 = 14,
        Square0 = 15,
        Square1 = 16,
        Square2 = 17,
        Square3 = 18,
        Square4 = 19,
        StarFull = 20,
        StarThreeFourth = 21,
        StarHalf = 22,
        StarQuarter = 23,
        StarNone = 24,
        ArrowDown = 25,
        ArrowRight = 26,
        ArrowRightDown = 27,
        ArrowRightUp = 28,
        ArrowUp = 29,
        Check = 30,
        Circle = 31,
        CircleCheck = 32,
        CircleCross = 33,
        CircleExclamation = 34,
        Cross = 35,
        Rhomb = 36,
        Exclamation = 37,
        Flag = 38,
        Minus = 39,
        Triangle = 40,
        TriangleDown = 41,
        TriangleUp = 42,
        Home = 43,
        Cart = 44,
        Phone = 45,
        Mobile = 46,
        Mug = 47,
        Airplane = 48,
        Man = 49,
        Woman = 50,
        UserTie = 51,
        Truck = 52,
        Earth = 53,
        ManWoman = 54,
        Appleinc = 55,
        Windows8 = 56,
        Glass = 57,
        Music = 58,
        Search = 59,
        EnvelopeO = 60,
        Heart = 61,
        Star = 62,
        StarO = 63,
        User = 64,
        Film = 65,
        ThLarge = 66,
        Th = 67,
        ThList = 68,
        Times = 69,
        SearchPlus = 70,
        SearchMinus = 71,
        PowerOff = 72,
        Signal = 73,
        Cog = 74,
        TrashO = 75,
        FileO = 76,
        ClockO = 77,
        Road = 78,
        Download = 79,
        ArrowCircleODown = 80,
        ArrowCircleOUp = 81,
        Inbox = 82,
        PlayCircleO = 83,
        Repeat = 84,
        Refresh = 85,
        ListAlt = 86,
        Lock = 87,
        FAFlag = 88,
        Headphones = 89,
        VolumeOff = 90,
        VolumeDown = 91,
        VolumeUp = 92,
        Qrcode = 93,
        Barcode = 94,
        Tag = 95,
        Tags = 96,
        Book = 97,
        Bookmark = 98,
        Print = 99,
        Camera = 100,
        Font = 101,
        Bold = 102,
        Italic = 103,
        TextHeight = 104,
        TextWidth = 105,
        AlignLeft = 106,
        AlignCenter = 107,
        AlignRight = 108,
        AlignJustify = 109,
        List = 110,
        Outdent = 111,
        Indent = 112,
        VideoCamera = 113,
        PictureO = 114,
        Pencil = 115,
        MapMarker = 116,
        Adjust = 117,
        Tint = 118,
        PencilSquareO = 119,
        ShareSquareO = 120,
        CheckSquareO = 121,
        Arrows = 122,
        StepBackward = 123,
        FastBackward = 124,
        Backward = 125,
        Play = 126,
        Pause = 127,
        Stop = 128,
        Forward = 129,
        FastForward = 130,
        StepForward = 131,
        Eject = 132,
        ChevronLeft = 133,
        ChevronRight = 134,
        PlusCircle = 135,
        MinusCircle = 136,
        TimesCircle = 137,
        CheckCircle = 138,
        QuestionCircle = 139,
        InfoCircle = 140,
        Crosshairs = 141,
        TimesCircleO = 142,
        CheckCircleO = 143,
        Ban = 144,
        FAArrowLeft = 145,
        FAArrowRight = 146,
        FAArrowUp = 147,
        FAArrowDown = 148,
        Share = 149,
        Expand = 150,
        Compress = 151,
        FAPlus = 152,
        FAMinus = 153,
        Asterisk = 154,
        ExclamationCircle = 155,
        Gift = 156,
        Leaf = 157,
        Fire = 158,
        Eye = 159,
        EyeSlash = 160,
        ExclamationTriangle = 161,
        Plane = 162,
        Calendar = 163,
        Random = 164,
        Comment = 165,
        Magnet = 166,
        ChevronUp = 167,
        ChevronDown = 168,
        Retweet = 169,
        ShoppingCart = 170,
        Folder = 171,
        FolderOpen = 172,
        ArrowsV = 173,
        ArrowsH = 174,
        BarChart = 175,
        TwitterSquare = 176,
        FacebookSquare = 177,
        CameraRetro = 178,
        Key = 179,
        Cogs = 180,
        Comments = 181,
        ThumbsOUp = 182,
        ThumbsODown = 183,
        HeartO = 184,
        SignOut = 185,
        LinkedinSquare = 186,
        ThumbTack = 187,
        ExternalLink = 188,
        SignIn = 189,
        Trophy = 190,
        GithubSquare = 191,
        Upload = 192,
        LemonO = 193,
        SquareO = 194,
        BookmarkO = 195,
        PhoneSquare = 196,
        Twitter = 197,
        Facebook = 198,
        Github = 199,
        Unlock = 200,
        CreditCard = 201,
        Rss = 202,
        HddO = 203,
        Bullhorn = 204,
        Bell = 205,
        Certificate = 206,
        HandORight = 207,
        HandOLeft = 208,
        HandOUp = 209,
        HandODown = 210,
        ArrowCircleLeft = 211,
        ArrowCircleRight = 212,
        ArrowCircleUp = 213,
        ArrowCircleDown = 214,
        Globe = 215,
        Wrench = 216,
        Tasks = 217,
        Filter = 218,
        Briefcase = 219,
        ArrowsAlt = 220,
        Users = 221,
        Link = 222,
        Cloud = 223,
        Flask = 224,
        Scissors = 225,
        FilesO = 226,
        Paperclip = 227,
        FloppyO = 228,
        Square = 229,
        Bars = 230,
        ListUl = 231,
        ListOl = 232,
        Strikethrough = 233,
        Underline = 234,
        Table = 235,
        Magic = 236,
        Pinterest = 237,
        PinterestSquare = 238,
        GooglePlusSquare = 239,
        GooglePlus = 240,
        Money = 241,
        CaretDown = 242,
        CaretUp = 243,
        CaretLeft = 244,
        CaretRight = 245,
        Columns = 246,
        Sort = 247,
        SortDesc = 248,
        SortAsc = 249,
        Envelope = 250,
        Linkedin = 251,
        Undo = 252,
        Gavel = 253,
        Tachometer = 254,
        CommentO = 255,
        CommentsO = 256,
        Bolt = 257,
        Sitemap = 258,
        Umbrella = 259,
        Clipboard = 260,
        LightbulbO = 261,
        Exchange = 262,
        CloudDownload = 263,
        CloudUpload = 264,
        UserMd = 265,
        Stethoscope = 266,
        Suitcase = 267,
        BellO = 268,
        Coffee = 269,
        Cutlery = 270,
        FileTextO = 271,
        BuildingO = 272,
        HospitalO = 273,
        Ambulance = 274,
        Medkit = 275,
        FighterJet = 276,
        Beer = 277,
        HSquare = 278,
        PlusSquare = 279,
        AngleDoubleLeft = 280,
        AngleDoubleRight = 281,
        AngleDoubleUp = 282,
        AngleDoubleDown = 283,
        AngleLeft = 284,
        AngleRight = 285,
        AngleUp = 286,
        AngleDown = 287,
        Desktop = 288,
        Laptop = 289,
        Tablet = 290,
        CircleO = 291,
        QuoteLeft = 292,
        QuoteRight = 293,
        Spinner = 294,
        Reply = 295,
        GithubAlt = 296,
        FolderO = 297,
        FolderOpenO = 298,
        SmileO = 299,
        FrownO = 300,
        MehO = 301,
        Gamepad = 302,
        KeyboardO = 303,
        FlagO = 304,
        FlagCheckered = 305,
        Terminal = 306,
        Code = 307,
        ReplyAll = 308,
        StarHalfO = 309,
        LocationArrow = 310,
        Crop = 311,
        CodeFork = 312,
        ChainBroken = 313,
        Question = 314,
        Info = 315,
        Superscript = 316,
        Subscript = 317,
        Eraser = 318,
        PuzzlePiece = 319,
        Microphone = 320,
        MicrophoneSlash = 321,
        Shield = 322,
        CalendarO = 323,
        FireExtinguisher = 324,
        Rocket = 325,
        Maxcdn = 326,
        ChevronCircleLeft = 327,
        ChevronCircleRight = 328,
        ChevronCircleUp = 329,
        ChevronCircleDown = 330,
        Html5 = 331,
        Css3 = 332,
        Anchor = 333,
        UnlockAlt = 334,
        Bullseye = 335,
        EllipsisH = 336,
        EllipsisV = 337,
        RssSquare = 338,
        PlayCircle = 339,
        Ticket = 340,
        MinusSquare = 341,
        InusSquareO = 342,
        LevelUp = 343,
        LevelDown = 344,
        CheckSquare = 345,
        PencilSquare = 346,
        ExternalLinkSquare = 347,
        ShareSquare = 348,
        Compass = 349,
        CaretSquareODown = 350,
        CaretSquareOUp = 351,
        CaretSquareORight = 352,
        Eur = 353,
        Gbp = 354,
        Usd = 355,
        Inr = 356,
        Jpy = 357,
        Rub = 358,
        Krw = 359,
        Btc = 360,
        File = 361,
        FileText = 362,
        SortAlphaAsc = 363,
        SortAlphaDesc = 364,
        SortAmountAsc = 365,
        SortAmountDesc = 366,
        SortNumericAsc = 367,
        SortNumericDesc = 368,
        ThumbsUp = 369,
        ThumbsDown = 370,
        YoutubeSquare = 371,
        Youtube = 372,
        Xing = 373,
        XingSquare = 374,
        YoutubePlay = 375,
        Dropbox = 376,
        StackOverflow = 377,
        Instagram = 378,
        Flickr = 379,
        Adn = 380,
        Bitbucket = 381,
        BitbucketSquare = 382,
        Tumblr = 383,
        TumblrSquare = 384,
        LongArrowDown = 385,
        LongArrowUp = 386,
        LongArrowLeft = 387,
        LongArrowRight = 388,
        Apple = 389,
        Windows = 390,
        Android = 391,
        Linux = 392,
        Dribbble = 393,
        Skype = 394,
        Foursquare = 395,
        Trello = 396,
        Female = 397,
        Male = 398,
        Gratipay = 399,
        SunO = 400,
        MoonO = 401,
        Archive = 402,
        Bug = 403,
        Vk = 404,
        Weibo = 405,
        Renren = 406,
        Pagelines = 407,
        StackExchange = 408,
        ArrowCircleORight = 409,
        ArrowCircleOLeft = 410,
        CaretSquareOLeft = 411,
        DotCircleO = 412,
        Wheelchair = 413,
        VimeoSquare = 414,
        Try = 415,
        PlusSquareO = 416,
        SpaceShuttle = 417,
        Slack = 418,
        EnvelopeSquare = 419,
        Wordpress = 420,
        Openid = 421,
        University = 422,
        GraduationCap = 423,
        Yahoo = 424,
        Google = 425,
        Reddit = 426,
        RedditSquare = 427,
        StumbleuponCircle = 428,
        Stumbleupon = 429,
        Delicious = 430,
        Digg = 431,
        PiedPiper = 432,
        PiedPiperAlt = 433,
        Drupal = 434,
        Joomla = 435,
        Language = 436,
        Fax = 437,
        Building = 438,
        Child = 439,
        Paw = 440,
        Spoon = 441,
        Cube = 442,
        Cubes = 443,
        Behance = 444,
        BehanceSquare = 445,
        Steam = 446,
        SteamSquare = 447,
        Recycle = 448,
        Car = 449,
        Taxi = 450,
        Tree = 451,
        Spotify = 452,
        Deviantart = 453,
        Soundcloud = 454,
        Database = 455,
        FilePdfO = 456,
        FileWordO = 457,
        FileExcelO = 458,
        FilePowerpointO = 459,
        FileImageO = 460,
        FileArchiveO = 461,
        FileAudioO = 462,
        FileVideoO = 463,
        FileCodeO = 464,
        Vine = 465,
        Codepen = 466,
        Jsfiddle = 467,
        LifeRing = 468,
        CircleONotch = 469,
        Rebel = 470,
        Empire = 471,
        GitSquare = 472,
        Git = 473,
        HackerNews = 474,
        TencentWeibo = 475,
        Qq = 476,
        Weixin = 477,
        PaperPlane = 478,
        PaperPlaneO = 479,
        History = 480,
        CircleThin = 481,
        Header = 482,
        Paragraph = 483,
        Sliders = 484,
        ShareAlt = 485,
        ShareAltSquare = 486,
        Bomb = 487,
        FutbolO = 488,
        Tty = 489,
        Binoculars = 490,
        Plug = 491,
        Slideshare = 492,
        Twitch = 493,
        Yelp = 494,
        NewspaperO = 495,
        Wifi = 496,
        Calculator = 497,
        Paypal = 498,
        GoogleWallet = 499,
        CcVisa = 500,
        CcMastercard = 501,
        CcDiscover = 502,
        CcAmex = 503,
        CcPaypal = 504,
        CcStripe = 505,
        BellSlash = 506,
        BellSlashO = 507,
        Trash = 508,
        Copyright = 509,
        At = 510,
        Eyedropper = 511,
        PaintBrush = 512,
        BirthdayCake = 513,
        AreaChart = 514,
        PieChart = 515,
        LineChart = 516,
        Lastfm = 517,
        LastfmSquare = 518,
        ToggleOff = 519,
        ToggleOn = 520,
        Bicycle = 521,
        Bus = 522,
        Ioxhost = 523,
        Angellist = 524,
        Cc = 525,
        Ils = 526,
        Meanpath = 527,
        Buysellads = 528,
        Connectdevelop = 529,
        Dashcube = 530,
        Forumbee = 531,
        Leanpub = 532,
        Sellsy = 533,
        Shirtsinbulk = 534,
        Simplybuilt = 535,
        Skyatlas = 536,
        CartPlus = 537,
        CartArrowDown = 538,
        Diamond = 539,
        Ship = 540,
        UserSecret = 541,
        Motorcycle = 542,
        StreetView = 543,
        Heartbeat = 544,
        Venus = 545,
        Mars = 546,
        Mercury = 547,
        Transgender = 548,
        TransgenderAlt = 549,
        VenusDouble = 550,
        MarsDouble = 551,
        VenusMars = 552,
        MarsStroke = 553,
        MarsStrokeV = 554,
        MarsStrokeH = 555,
        Neuter = 556,
        Genderless = 557,
        FacebookOfficial = 558,
        PinterestP = 559,
        Whatsapp = 560,
        Server = 561,
        UserPlus = 562,
        UserTimes = 563,
        Bed = 564,
        Viacoin = 565,
        Train = 566,
        Subway = 567,
        Medium = 568,
        YCombinator = 569,
        OptinMonster = 570,
        Opencart = 571,
        Expeditedssl = 572,
        BatteryFull = 573,
        BatteryThreeQuarters = 574,
        BatteryHalf = 575,
        BatteryQuarter = 576,
        BatteryEmpty = 577,
        MousePointer = 578,
        ICursor = 579,
        ObjectGroup = 580,
        ObjectUngroup = 581,
        StickyNote = 582,
        StickyNoteO = 583,
        CcJcb = 584,
        CcDinersClub = 585,
        Clone = 586,
        BalanceScale = 587,
        HourglassO = 588,
        HourglassStart = 589,
        HourglassHalf = 590,
        HourglassEnd = 591,
        Hourglass = 592,
        HandRockO = 593,
        HandPaperO = 594,
        HandScissorsO = 595,
        HandLizardO = 596,
        HandSpockO = 597,
        HandPointerO = 598,
        HandPeaceO = 599,
        Trademark = 600,
        Registered = 601,
        CreativeCommons = 602,
        Gg = 603,
        GgCircle = 604,
        Tripadvisor = 605,
        Odnoklassniki = 606,
        OdnoklassnikiSquare = 607,
        GetPocket = 608,
        WikipediaW = 609,
        Safari = 610,
        Chrome = 611,
        Firefox = 612,
        Opera = 613,
        InternetExplorer = 614,
        Television = 615,
        Contao = 616,
        Px500 = 617,
        Amazon = 618,
        CalendarPlusO = 619,
        CalendarMinusO = 620,
        CalendarTimesO = 621,
        CalendarCheckO = 622,
        Industry = 623,
        MapPin = 624,
        MapSigns = 625,
        MapO = 626,
        Map = 627,
        Commenting = 628,
        CommentingO = 629,
        Houzz = 630,
        Vimeo = 631,
        BlackTie = 632,
        Fonticons = 633
    }
}
export namespace Stimulsoft.Base.Drawing {
    import Image = Stimulsoft.System.Drawing.Image;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Font = Stimulsoft.System.Drawing.Font;
    import ContentAlignment = Stimulsoft.System.Drawing.ContentAlignment;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiAdvancedWatermark implements ICloneable, IStiJsonReportObject {
        private static defaultWeaveMajorColor;
        private static defaultWeaveMinorColor;
        private static defaultTextColor;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        private cachedImage;
        get isVisible(): boolean;
        textEnabled: boolean;
        text: string;
        textFont: Font;
        textColor: Color;
        textAngle: number;
        imageEnabled: boolean;
        get image(): Image;
        set image(value: Image);
        private imageBytes_;
        get imageBytes(): number[];
        set imageBytes(value: number[]);
        imageMultipleFactor: number;
        private _imageTransparency;
        get imageTransparency(): number;
        set imageTransparency(value: number);
        imageAlignment: ContentAlignment;
        imageTiling: boolean;
        imageStretch: boolean;
        imageAspectRatio: boolean;
        weaveEnabled: boolean;
        weaveMajorIcon: StiFontIcons;
        private weaveMajorSize_;
        get weaveMajorSize(): number;
        set weaveMajorSize(value: number);
        weaveMajorColor: Color;
        weaveMinorIcon: StiFontIcons;
        private weaveMinorSize_;
        get weaveMinorSize(): number;
        set weaveMinorSize(value: number);
        weaveMinorColor: Color;
        private weaveAngle_;
        get weaveAngle(): number;
        set weaveAngle(value: number);
        private weaveDistance_;
        get weaveDistance(): number;
        set weaveDistance(value: number);
        private getCachedImage;
        private putCachedImage;
        private disposeCachedImage;
        private existImage;
        private takeImage;
        private takeGdiImage;
        putImage(image: Image): void;
        putImage2(image: number[]): void;
        resetImage(): void;
        constructor(textEnabled?: boolean, text?: string, textColor?: Color, textAngle?: number, textFont?: Font, imageEnabled?: boolean, imageBytes?: number[], imageMultipleFactor?: number, imageTransparency?: number, imageAlignment?: ContentAlignment, imageTiling?: boolean, imageStretch?: boolean, imageAspectRatio?: boolean, weaveEnabled?: boolean, weaveMajorIcon?: StiFontIcons, weaveMajorSize?: number, weaveMajorColor?: Color, weaveMinorIcon?: StiFontIcons, weaveMinorSize?: number, weaveMinorColor?: Color, weaveAngle?: number, weaveDistance?: number);
    }
}
export namespace Stimulsoft.Base.Drawing {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiAlignHelper {
        static alignToGrid(value: number, gridSize: number, aligningToGrid: boolean): number;
        static alignToGrid2(rect: Rectangle, gridSize: number, aligningToGrid: boolean): Rectangle;
    }
}
export namespace Stimulsoft.Base.Drawing {
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBorderSide implements ICloneable {
        implements(): any[];
        clone(): StiBorderSide;
        equals(obj: StiBorderSide | any): boolean;
        getHashCode(): number;
        getSizeOffset(): number;
        side: StiBorderSides;
        private _color;
        get color(): Color;
        set color(value: Color);
        private _size;
        get size(): number;
        set size(value: number);
        private _style;
        get style(): StiPenStyle;
        set style(value: StiPenStyle);
        constructor(color?: Color, size?: number, style?: StiPenStyle);
    }
}
export namespace Stimulsoft.Base.Drawing {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCap implements ICloneable {
        implements(): any[];
        clone(): StiCap;
        width: number;
        style: StiCapStyle;
        height: number;
        fill: boolean;
        color: Color;
        loadFromXml(xmlNode: XmlNode): void;
        constructor(width?: number, style?: StiCapStyle, height?: number, fill?: boolean, color?: Color);
    }
}
export namespace Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiColorUtils {
        static changeLightness(color: Color, correctionFactor: number): Color;
        static changeDarkness(color: Color, percDarker: number): Color;
        static changeAlpha(alpha: number, color: Color): Color;
        static light(baseColor: Color, value: number): Color;
        static mixingColors(color1: Color, color2: Color, alpha: number): Color;
        static dark(baseColor: Color, value: number): Color;
    }
}
export namespace Stimulsoft.Base.Drawing {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCornerRadius implements ICloneable, IStiJsonReportObject {
        clone(): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        isDefault(): boolean;
        equals(obj: any): boolean;
        toString(): string;
        static tryParse(str: string): StiCornerRadius;
        getUniqueCode(): number;
        private topLeft_;
        get topLeft(): number;
        set topLeft(value: number);
        private topRight_;
        get topRight(): number;
        set topRight(value: number);
        private bottomRight_;
        get bottomRight(): number;
        set bottomRight(value: number);
        private bottomLeft_;
        get bottomLeft(): number;
        set bottomLeft(value: number);
        get isEmpty(): boolean;
        constructor(topLeft?: number, topRight?: number, bottomRight?: number, bottomLeft?: number);
    }
}
export namespace Stimulsoft.Base.Drawing {
    class StiCornerRadiusHelper {
        static flipVertical(cornerRadius: StiCornerRadius): StiCornerRadius;
        static flipHorizontal(cornerRadius: StiCornerRadius): StiCornerRadius;
        static rotation90(cornerRadius: StiCornerRadius): StiCornerRadius;
    }
}
export namespace Stimulsoft.Base.Drawing {
    class StiDefaultBrush extends StiBrush {
        equals(obj: any): boolean;
        getHashCode(): number;
        ident: StiBrushIdent;
    }
}
export namespace Stimulsoft.Base.Drawing {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Brush = Stimulsoft.System.Drawing.Brush;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiDrawing {
        static fillRectangle(g: Graphics, brush: Brush, arg: number | Rectangle, y?: number, width?: number, height?: number): void;
    }
}
export namespace Stimulsoft.Base.Drawing {
    class StiEmptyBrush extends StiBrush {
        equals(obj: any): boolean;
        private defaultHashCode;
        getHashCode(): number;
    }
}
export namespace Stimulsoft.Base.Drawing {
    import Font = Stimulsoft.System.Drawing.Font;
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    class StiFontUtils {
        static correctStyle(fontName: string, style: FontStyle): FontStyle;
        static changeFontName(font: Font, newFontName: string): Font;
        static changeFontSize(font: Font, newFontSize: number): Font;
        static changeFontStyle(font: Font, style: FontStyle): Font;
        static changeFontStyle2(fontName: string, fontSize: number, style: FontStyle): Font;
        static changeFontStyleBold(font: Font, bold: boolean): Font;
        static changeFontStyleItalic(font: Font, italic: boolean): Font;
        static changeFontStyleUnderline(font: Font, underline: boolean): Font;
        static changeFontStyleStrikeout(font: Font, strikeout: boolean): Font;
    }
}
export namespace Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGlareBrush extends StiBrush {
        memberwiseClone(): StiBrush;
        private _startColor;
        get startColor(): Color;
        set startColor(value: Color);
        private _endColor;
        get endColor(): Color;
        set endColor(value: Color);
        private _angle;
        get angle(): number;
        set angle(value: number);
        private _focus;
        get focus(): number;
        set focus(value: number);
        private _scale;
        get scale(): number;
        set scale(value: number);
        equals(obj: any): boolean;
        private defaultHashCode;
        getHashCode(): number;
        constructor(startColor?: Color, endColor?: Color, angle?: number, focus?: number, scale?: number);
    }
}
export namespace Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiGlassBrush extends StiBrush {
        memberwiseClone(): StiBrush;
        private _color;
        get color(): Color;
        set color(value: Color);
        private _drawHatch;
        get drawHatch(): boolean;
        set drawHatch(value: boolean);
        private _blend;
        get blend(): number;
        set blend(value: number);
        equals(obj: any): boolean;
        private defaultHashCode;
        getHashCode(): number;
        getTopColor(): Color;
        getTopColorLight(): Color;
        getBottomColor(): Color;
        getBottomColorLight(): Color;
        getTopRectangle(rect: Rectangle): Rectangle;
        getBottomRectangle(rect: Rectangle): Rectangle;
        constructor(color?: Color, drawHatch?: boolean, blend?: number);
    }
}
export namespace Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGradientBrush extends StiBrush {
        memberwiseClone(): StiBrush;
        private _startColor;
        get startColor(): Color;
        set startColor(value: Color);
        private _endColor;
        get endColor(): Color;
        set endColor(value: Color);
        private _angle;
        get angle(): number;
        set angle(value: number);
        equals(obj: any): boolean;
        private defaultHashCode;
        getHashCode(): number;
        constructor(startColor?: Color, endColor?: Color, angle?: number);
    }
}
export namespace Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    import HatchStyle = Stimulsoft.System.Drawing.Drawing2D.HatchStyle;
    class StiHatchBrush extends StiBrush {
        memberwiseClone(): StiBrush;
        private _backColor;
        get backColor(): Color;
        set backColor(value: Color);
        private _foreColor;
        get foreColor(): Color;
        set foreColor(value: Color);
        private _style;
        get style(): HatchStyle;
        set style(value: HatchStyle);
        equals(obj: any): boolean;
        private defaultHashCode;
        getHashCode(): number;
        constructor(style?: HatchStyle, foreColor?: Color, backColor?: Color);
    }
}
export namespace Stimulsoft.Base.Drawing {
    import ImageCodecInfo = Stimulsoft.System.Drawing.Imaging.ImageCodecInfo;
    class StiImageCodecInfo {
        static getImageCodec(mimeType: string): ImageCodecInfo;
    }
}
export namespace Stimulsoft.Base.Drawing {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImageConverter {
        static imageToString(image: Image): string;
        static imageToBytes(image: Image, allowNulls?: boolean): number[];
        static bytesToImage(bytes: number[], width?: number, height?: number, stretch?: boolean, aspectRatio?: boolean): Image;
        static stringToImage(str: string): Image;
        static stringToByteArray(str: string): number[];
    }
}
export namespace Stimulsoft.Base.Drawing {
    import Image = Stimulsoft.System.Drawing.Image;
    import Header = Stimulsoft.System.Header;
    class StiImageFromURL {
        static loadBitmap(url: string, headers: Header[]): Image;
    }
}
export namespace Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiLinearGradientBrush extends StiBrush {
        angle: number;
        positions: number[];
        colors: Color[];
        memberwiseClone(): StiBrush;
        color: Color;
        constructor(colors: Color[], positions: number[], angle: number);
    }
}
export namespace Stimulsoft.Base.Drawing {
    import DashStyle = Stimulsoft.System.Drawing.Drawing2D.DashStyle;
    class StiPenUtils {
        static getPenStyle(penStyle: StiPenStyle): DashStyle;
    }
}
export namespace Stimulsoft.Base.Drawing {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiSimpleBorder implements ICloneable, IStiJsonReportObject {
        clone(): any;
        getBorder(): StiBorder;
        getSizeOffset(): number;
        getSize(): number;
        getSizeIncludingSide(): number;
        get isTopBorderSidePresent(): boolean;
        get isBottomBorderSidePresent(): boolean;
        get isLeftBorderSidePresent(): boolean;
        get isRightBorderSidePresent(): boolean;
        get isAllBorderSidesPresent(): boolean;
        side: StiBorderSides;
        color: Color;
        size: number;
        style: StiPenStyle;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        constructor(side?: StiBorderSides, color?: Color, size?: number, style?: StiPenStyle);
    }
}
export namespace Stimulsoft.Base.Drawing {
    import Point = Stimulsoft.System.Drawing.Point;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSimpleShadow implements ICloneable {
        clone(): any;
        static loadFromXml(text: string): StiSimpleShadow;
        color: Color;
        private location_;
        get location(): Point;
        set location(value: Point);
        private size_;
        get size(): number;
        set size(value: number);
        visible: boolean;
        constructor(color?: Color, location?: Point, size?: number, visible?: boolean);
    }
}
export namespace Stimulsoft.Base.Drawing {
    class StiStyleBrush extends StiBrush {
        equals(obj: any): boolean;
        getHashCode(): number;
        ident: StiBrushIdent;
    }
}
export namespace Stimulsoft.Base.Drawing {
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import Size = Stimulsoft.System.Drawing.Size;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Font = Stimulsoft.System.Drawing.Font;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    class Range {
        text: string;
        pos: Point;
        size: Size;
        isStart: boolean;
        isEnd: boolean;
        newLineForm: boolean;
        constructor(text: string, size: Size, newLineForm: boolean);
    }
    class StiTextDrawing {
        static measureString(g: Graphics, text: string, font: Font, width?: number, textOptions?: StiTextOptions, ha?: StiTextHorAlignment, va?: StiVertAlignment, antialiasing?: boolean, allowHtmlTags?: boolean): Size;
        private static correctFontSize;
        static splitTextWordwrap(text: string, g: Graphics, font: Font, rect: Rectangle, textOptions: StiTextOptions, ha: StiTextHorAlignment, typographic: boolean): LineInfo[];
        static splitTextWordwrap2(text: string, g: Graphics, font: Font, rect: Rectangle, sf: StringFormat, horAlignWidth?: boolean): LineInfo[];
        private static isWordWrapSymbol;
        private static makeLineInfoNotGdi;
        static splitTextWordwrapWidth(text: string, g: Graphics, font: Font, rect: Rectangle): string[];
        private static getAdditionalSpaceSize;
        private static makeLineInfo;
        static splitString(inputString: string, removeControl: boolean): string[];
        static getStringFormat(textOptions: StiTextOptions, ha: StiTextHorAlignment, va: StiVertAlignment, zoom: number): StringFormat;
        static getAlignment(alignment: StiTextHorAlignment): StringAlignment;
        static getAlignment2(alignment: StiVertAlignment): StringAlignment;
        static getStringFormat2(textOptions: StiTextOptions, ha: StiTextHorAlignment, va: StiVertAlignment, antialiasing: boolean, zoom: number): StringFormat;
        static measureTrailingSpaces: boolean;
    }
}
export namespace Stimulsoft.Base.Drawing {
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
    import HotkeyPrefix = Stimulsoft.System.Drawing.Text.HotkeyPrefix;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTextOptions implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromXml(str: string): StiTextOptions;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiTextOptions;
        private bits;
        getStringFormat(antialiasing?: boolean, zoom?: number): StringFormat;
        get rightToLeft(): boolean;
        set rightToLeft(value: boolean);
        get lineLimit(): boolean;
        set lineLimit(value: boolean);
        wordWrap: boolean;
        get angle(): number;
        set angle(value: number);
        get firstTabOffset(): number;
        set firstTabOffset(value: number);
        get distanceBetweenTabs(): number;
        set distanceBetweenTabs(value: number);
        get hotkeyPrefix(): HotkeyPrefix;
        set hotkeyPrefix(value: HotkeyPrefix);
        get trimming(): StringTrimming;
        set trimming(value: StringTrimming);
        getHashCode(): number;
        constructor(rightToLeft?: boolean, lineLimit?: boolean, wordWrap?: boolean, angle?: number, hotkeyPrefix?: HotkeyPrefix, trimming?: StringTrimming, firstTabOffset?: number, distanceBetweenTabs?: number);
    }
}
export namespace Stimulsoft.Base.Drawing {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StringBuilder = Stimulsoft.System.Text.StringBuilder;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Font = Stimulsoft.System.Drawing.Font;
    import Size = Stimulsoft.System.Drawing.Size;
    import StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiTextRenderer {
        private static precisionDigits;
        static defaultParagraphLineHeight: number;
        static precisionModeFactor: number;
        static precisionModeEnabled: boolean;
        static correctionEnabled: boolean;
        static maxFontSize: number;
        static compatibility2009: boolean;
        static optimizeBottomMargin: boolean;
        private static hashFonts;
        private static getTabsWidth;
        static getFontIndex(fontName: string, fontSize: number, bold: boolean, italic: boolean, underlined: boolean, strikeout: boolean, superOrSubscript: boolean, tempFontList: StiFontState[]): number;
        private static getFontIndex2;
        private static htmlNameToColor;
        static interpreteFontSizeInHtmlTagsAsInHtml: boolean;
        private static _htmlEscapeSequence;
        private static get htmlEscapeSequence();
        private static convertStringToTag;
        static parseHtmlToStates(inputHtml: string, baseState: StiHtmlState, storeStack?: boolean): StiHtmlState[];
        private static getMarginSize;
        static prepareStateText(stateText: StringBuilder): StringBuilder;
        static stateToHtml(state: StiHtmlState, state2: StiHtmlState, text: string, lineInfoIndent: number): string;
        private static getIndentString;
        private static bulletBlack;
        private static bulletWhite;
        private static insertMarker;
        private static stackToString;
        private static listLevelsToString;
        private static parseHtmlTag;
        private static pushPopStack;
        private static correctFontName;
        private static parseTagIntoPairs;
        private static parseMarkerTypeAttribute;
        private static parseStyleAttributes;
        private static parseStyleAttribute;
        private static stringToListLevels;
        private static stringToStack;
        private static parseFontSize;
        private static parseSizeToEm;
        static parseColor(colorAttribute: string, inheritColor: Color): Color;
        static measureString(maxWidth: number, font: Font, text: string, angle?: number, allowHtmlTags?: boolean): Size;
        static getTextLinesAndWidths(g: Graphics, REFtext: any, font: Font, bounds: Rectangle, lineSpacing: number, wordWrap: boolean, rightToLeft: boolean, scale: number, angle: number, trimming: StringTrimming, allowHtmlTags: boolean, REFtextLines: any, REFlinesInfo: any): string[];
        static StiForceWidthAlignTag: string;
        private static arabics;
        private static romans;
        private static subs;
        private static toRoman;
        static toABC(value: number): string;
    }
    class StiFontState {
        fontName: string;
        fontBase: Font;
        fontScaled: Font;
        superOrSubscriptIndex: number;
        parentFontIndex: number;
        hFont: number;
        hFontScaled: number;
        hScriptCache: number;
        hScriptCacheScaled: number;
        lineHeight: number;
        ascend: number;
        descend: number;
        elipsisWidth: number;
        emValue: number;
        private _fontNameReal;
        get fontNameReal(): string;
    }
    class LineInfo {
        begin: number;
        length: number;
        needWidthAlign: boolean;
        get end(): number;
        set end(value: number);
        width: number;
        widths: number[];
        justifyOffset: number;
        text: string;
        indexOfMaxFont: number;
        lineHeight: number;
        textAlignment: StiTextHorAlignment;
        indent: number;
    }
    class RunInfo {
        text: string;
        xPos: number;
        yPos: number;
        widths: number[];
        glyphWidths: number[];
        textColor: Color;
        backColor: Color;
        fontIndex: number;
        glyphIndexList: number[];
        scaleList: number[];
        href: string;
        textAlign: StiTextHorAlignment;
    }
    enum StiHtmlTag {
        None = 0,
        B = 1,
        I = 2,
        U = 3,
        S = 4,
        Sup = 5,
        Sub = 6,
        Font = 7,
        FontName = 8,
        FontSize = 9,
        FontColor = 10,
        Backcolor = 11,
        LetterSpacing = 12,
        WordSpacing = 13,
        LineHeight = 14,
        TextAlign = 15,
        P = 16,
        Br = 17,
        OrderedList = 18,
        UnorderedList = 19,
        ListItem = 20,
        A = 21,
        Unknown = 22
    }
    enum StiHtmlTag2State {
        Start = 0,
        End = 1,
        Empty = 2
    }
    class StiHtmlTag2 {
        tag: StiHtmlTag;
        tagName: string;
        attributes: TagPair[];
        state: StiHtmlTag2State;
        get isStart(): boolean;
        get isEnd(): boolean;
        get isEmpty(): boolean;
        isStartTag(tag: StiHtmlTag): boolean;
        isEndTag(tag: StiHtmlTag): boolean;
        getAttribute(name: string): string;
        getAttributePair(name: string): TagPair;
        hasAttribute(name: string): boolean;
        equals(tag2: StiHtmlTag2): boolean;
        toString(): string;
        constructor(tag?: StiHtmlTag, state?: StiHtmlTag2State);
    }
    class StiHtmlTagsState {
        clone(): StiHtmlTagsState;
        getStyleAttribute(name: string): string;
        bold: boolean;
        italic: boolean;
        underline: boolean;
        strikeout: boolean;
        fontSize: number;
        fontName: string;
        fontColor: Color;
        backColor: Color;
        subscript: boolean;
        superscript: boolean;
        letterSpacing: number;
        wordSpacing: number;
        lineHeight: number;
        textAlign: StiTextHorAlignment;
        isColorChanged: boolean;
        isBackcolorChanged: boolean;
        tag: StiHtmlTag2;
        indent: number;
        htmlStyle: string;
        href: string;
        hrefTarget: string;
        styleAttributes: Hashtable;
        constructor(bold: any, italic?: boolean, underline?: boolean, strikeout?: boolean, fontSize?: number, fontName?: string, fontColor?: Color, backColor?: Color, superscript?: boolean, subscript?: boolean, letterSpacing?: number, wordSpacing?: number, lineHeight?: number, textAlign?: StiTextHorAlignment);
    }
    class StiHtmlState {
        clone(): StiHtmlState;
        ts: StiHtmlTagsState;
        text: StringBuilder;
        fontIndex: number;
        posBegin: number;
        tagsStack: StiHtmlTagsState[];
        listLevels: number[];
        toString(): string;
        constructor(ts: any, posBegin?: number);
    }
    class TagPair {
        key: string;
        keyBase: string;
        value: string;
        constructor(key?: string, keyBase?: string, value?: string);
    }
}
export namespace Stimulsoft.Base {
    enum StiPlanIdent {
        OnlineTrial = 100,
        OnlineStandard = 101,
        ServerTrial = 200,
        ServerTeam5 = 201,
        ServerTeam10 = 202,
        ServerTeam25 = 203,
        ServerTeam50 = 204,
        ServerBusiness = 205,
        ServerEnterprise = 206,
        ServerWorldWide = 207,
        Test = 300
    }
    enum StiPlanFeatureIdent {
        Cycles = 1
    }
}
export namespace Stimulsoft.Base.Helpers {
    import DateTime = Stimulsoft.System.DateTime;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    enum DateTimeFormat {
        USA_DATE = 0,
        UK_DATE = 1
    }
    class ParsedDateTime {
        readonly indexOfDate: number;
        readonly lengthOfDate: number;
        readonly indexOfTime: number;
        readonly lengthOfTime: number;
        readonly dateTime: DateTime;
        readonly isDateFound: boolean;
        readonly isTimeFound: boolean;
        readonly utcOffset: TimeSpan;
        readonly isUtcOffsetFound: boolean;
        utcDateTime: DateTime;
        constructor(indexOfDate: number, lengthOfDate: number, indexOfTime: number, lengthOfTime: number, dateTime: DateTime, utcOffset?: TimeSpan);
    }
    class DateTimeRoutines {
        private static _defaultDate;
        static get defaultDate(): DateTime;
        static set defaultDate(value: DateTime);
        static defaultDateIsNow: boolean;
        static tryParseDateTime(str: string, defaultFormat: DateTimeFormat, refDateTime: {
            ref: DateTime;
        }): boolean;
        static tryParseDateTime2(str: string, defaultFormat: DateTimeFormat, refParsedDateTime: {
            ref: ParsedDateTime;
        }): boolean;
        static tryParseDateOrTime2(str: string, defaultFormat: DateTimeFormat, refParsedDateTime: {
            ref: ParsedDateTime;
        }): boolean;
        static tryParseTime2(str: string, defaultFormat: DateTimeFormat, refParsedTime: {
            ref: ParsedDateTime;
        }, parsedDate: ParsedDateTime): boolean;
        static tryParseDate2(str: string, defaultFormat: DateTimeFormat, refParsedDate: {
            ref: ParsedDateTime;
        }): boolean;
        private static tryParseDateInternal;
        private static convertToDate;
    }
}
export namespace Stimulsoft.Base.Helpers {
    import Size = Stimulsoft.System.Drawing.Size;
    class StiBingMapHelper {
        static _bingKey: string;
        static bingMapKey: string;
        static bingKeysUrl: string;
        private static defaultBingKey;
        static getBingKey(userBingKey: string): string;
        static getImage(size: Size, map: {
            mapImage: string;
        }, userBingKey: string, pushPins?: string[]): Promise<string>;
        private static base64ArrayBuffer;
        private static getBingUrl;
    }
}
export namespace Stimulsoft.Base.Helpers {
    class StiComponentProgressHelper {
        progressDelta: number;
        timerInterval: number;
        private static lockCompletedProgressHandler;
        static currentValue: number;
        static add(comp: IStiAppComponent): void;
    }
}
export namespace Stimulsoft.Base {
    class StiPacker {
        private static encryptedId;
        static allowPacking: boolean;
        static pack(bytes: number[]): number[];
        static unpack<B extends boolean>(bytes: number[], returnString: B): B extends true ? string : number[];
        static unpack2(bytes: number[]): string;
        static unpackAndDecrypt<B extends boolean>(str: string, returnString: B): B extends true ? string : number[];
        static packAndEncryptToString(data: number[] | string): string;
        static packToString(bytes: number[]): string;
        static unpackFromString(str: string): number[];
        static packToBytes(str: string, allowPacking?: boolean): number[];
        static unpackToString(bytes: number[]): string;
        private static addZipSignature;
        static isPacked(bytes: number[]): boolean;
        private static isPacked2;
    }
}
export namespace Stimulsoft.Base.Helpers {
    class StiValueComparer {
        static equalValues(value1: any, value2: any): boolean;
        static compareArrays(a: any[], b: any[]): boolean;
    }
}
export namespace Stimulsoft.Base.Helpers {
    import Guid = Stimulsoft.System.Guid;
    import DateTime = Stimulsoft.System.DateTime;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import DateTimeOffset = Stimulsoft.System.DateTimeOffset;
    import DateOnly = Stimulsoft.System.DateOnly;
    import TimeOnly = Stimulsoft.System.TimeOnly;
    class StiValueHelper {
        static isZero(value: any): boolean;
        static equalDecimal(value1: any, value2: any): boolean;
        static tryToString(value: any): string;
        static tryToChar(value: any): string;
        static tryToInt(value: any): number;
        static tryToNumber(value: any): number;
        static tryToBool(value: any): boolean;
        static tryToDateTime(value: any): DateTime;
        static tryToDateTimeOffset(value: any): DateTimeOffset;
        static tryToTimeSpan(value: any): TimeSpan;
        static tryToDateOnly(value: any): DateOnly;
        static tryToTimeOnly(value: any): TimeOnly;
        static tryToGuid(value: any): Guid;
        static tryToNullableNumber(value: any): number | null;
        static tryToNullableDateTime(value: any): DateTime | null;
        static tryToNullableDateTimeOffset(value: any): DateTimeOffset | null;
        static tryToNullableTimeSpan(value: any): TimeSpan | null;
        static tryToNullableDateOnly(value: any): DateOnly | null;
        static tryToNullableTimeOnly(value: any): TimeOnly | null;
        static parseNumber(value: string): number;
        private static normalizeFloatingPointValue;
    }
}
export namespace Stimulsoft.Base {
    enum StiJsonSaveMode {
        Report = 0,
        Document = 1
    }
}
export namespace Stimulsoft.Base.StiJsonReportObjectHelper {
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    import StiCap = Stimulsoft.Base.Drawing.StiCap;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Font = Stimulsoft.System.Drawing.Font;
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    import GraphicsUnit = Stimulsoft.System.Drawing.GraphicsUnit;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import Size = Stimulsoft.System.Drawing.Size;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    class Serialize {
        static fontArial8(font: Font): string;
        static fontArial10(font: Font): string;
        static fontArial13(font: Font): string;
        static fonSegoeUI20(font: Font): string;
        static font(font: Font, defaultFamily?: string, defaultEmSize?: number, defaultStyle?: FontStyle, defaultUnit?: GraphicsUnit): string;
        static rectangleD(rect: Rectangle): string;
        static sizeD(size: Size): string;
        static jColor(color: Color, defColor?: Color): string;
        static colorArray(array: Color[]): StiJson;
        static stringArray(array: string[]): StiJson;
        static boolArray(array: boolean[]): StiJson;
        static numberArray(array: number[]): StiJson;
        static objectArray(list: IStiJsonReportObject[], mode: StiJsonSaveMode): StiJson;
        static size(size: Size): StiJson;
        static point(pos: Point): StiJson;
        static jCap(cap: StiCap): string;
        static jBrush(brush: StiBrush, defaultBrush?: StiBrush): string;
        static jBorderSide(side: StiBorderSide): string;
        static jBorder(border: StiBorder): string;
        static jBorder2(border: StiSimpleBorder): string;
        static jShadow(shadow: StiSimpleShadow): string;
    }
    class Deserialize {
        static stringArray(jObject: StiJson): string[];
        static numberArray(jObject: StiJson): number[];
        static boolArray(jObject: StiJson): boolean[];
        static font(text: string, defaultFont: Font): Font;
        static jBorderSide(text: string): StiBorderSide;
        static jCap(text: string): StiCap;
        static border(text: string): StiBorder;
        static simpleBorder(text: string): StiSimpleBorder;
        static simpleSahdow(text: string): StiSimpleShadow;
        static color(value: string): Color;
        static brush(text: string): StiBrush;
        static colorArray(jObject: StiJson): Color[];
        static size(jObject: StiJson): Size;
        static rectangleD(text: string): Rectangle;
        static sizeD(text: string): Size;
        static point(jObject: StiJson): Point;
    }
}
export namespace Stimulsoft.Base {
    import DataSet = Stimulsoft.System.Data.DataSet;
    import JsonRelationDirection = Stimulsoft.System.Data.JsonRelationDirection;
    class StiJsonToDataSetConverter {
        static getDataSet(param: string | number[] | any, jsonRelationDirection?: JsonRelationDirection, maxDataRows?: number): DataSet;
        static getDataSetFromXml(param: any, relationDirection?: StiRelationDirection, maxDataRows?: number): DataSet;
    }
}
export namespace Stimulsoft.Base.Licenses {
    enum StiProductIdent {
        Ultimate = 1,
        Net = 2,
        Wpf = 3,
        Web = 4,
        Silverlight = 5,
        Js = 6,
        Java = 7,
        Php = 8,
        NetCore = 9,
        Uwp = 10,
        Flex = 11,
        BIDesigner = 12,
        DbsJs = 13,
        DbsWin = 14,
        DbsWeb = 15,
        BIDesktop = 16,
        BIServer = 17,
        BICloud = 18,
        CloudReports = 20,
        CloudDashboards = 21,
        Angular = 22,
        DbsAngular = 23,
        DbsPhp = 24,
        FormsWin = 25,
        FormsWeb = 26,
        FormsJs = 27,
        FormsPhp = 28,
        AppsWin = 29,
        AppsWeb = 30,
        AppsJs = 31,
        AppsPhp = 32,
        CloudForms = 33,
        CloudApps = 34,
        Avalonia = 35,
        Python = 36,
        DbsPython = 37
    }
}
export namespace Stimulsoft.Base.Licenses {
    class StiCryptHelper {
        private static encryptionKey;
        static decrypt(str: string, password?: string): string;
        static encrypt(str: string, password?: string): string;
        static recrypt(str: string, oldPassword: string, newPassword: string): string;
    }
}
export namespace Stimulsoft.Base.Licenses {
    class StiRsaPublicKey {
        static getKey(): any;
    }
}
export namespace Stimulsoft.Base.Licenses {
    class StiLicenseObject {
        encryptKey: string;
        loadFromString(str: string): void;
        saveToString(): string;
        loadFromBytes(bytes: number[]): void;
        decryptFromBytes(bytes: number[]): void;
        decryptFromString(str: string): void;
    }
}
export namespace Stimulsoft.Base.Licenses {
    import List = Stimulsoft.System.Collections.List;
    import DateTime = Stimulsoft.System.DateTime;
    class StiLicenseKey extends StiLicenseObject {
        activationDate: DateTime;
        signature: string;
        owner: string;
        userName: string;
        startDate: DateTime;
        endDate: DateTime;
        seviceId: string;
        planId: StiPlanIdent;
        products: List<StiLicenseProduct>;
        productName: string;
        productLogo: number[];
        productFavIcon: number[];
        productDescription: string;
        productUrl: string;
        clone(): StiLicenseKey;
        static get1(bytes: number[]): StiLicenseKey;
        static get2(str: string): StiLicenseKey;
        constructor();
    }
}
export namespace Stimulsoft.Base {
    class StiLicense {
        static licenseKey: any;
        static _key: string;
        static get key(): string;
        static set key(value: string);
        static get Key(): string;
        static set Key(value: string);
        static setNewLicenseKey(value: string, throwException?: boolean): void;
        private static isValidLicenseKey;
        private static isValidUserName;
        static loadFromFile(file: string): void;
        static loadFromString(licenseKey: string): void;
    }
}
export namespace Stimulsoft.Base.Licenses {
    class StiLicenseActivationResponse extends StiLicenseObject {
        encryptKey: string;
        licenseKey: StiLicenseKey;
        exception: string;
        resultSuccess: boolean;
        resultNotice: StiNotice;
    }
}
export namespace Stimulsoft.Base.Licenses {
    import StiProductIdent = Stimulsoft.Base.Licenses.StiProductIdent;
    class StiLicenseKeyValidator {
        private static indexValidator;
        static isValidOn(ident: StiProductIdent): boolean;
        static isValidOnDbsJS(): boolean;
        static isValidOnAnyDbs(): boolean;
        static isValidOnJS(): boolean;
        static isValidOnAnyReports(): boolean;
        static isValidOnAnyPlatform(): boolean;
        static isValidOnBI(): boolean;
        private static isJSPlatform;
        private static isAnyDbsPlatform;
        private static isAnyReportsPlatform;
        private static isDbsJSPlatform;
        private static isBIPlatform;
        private static getLicenseKey;
    }
}
export namespace Stimulsoft.Base.Licenses {
    import DateTime = Stimulsoft.System.DateTime;
    class StiLicenseProduct {
        expirationDate: DateTime;
        ident: StiProductIdent;
    }
}
export namespace Stimulsoft.Base.Map {
    let IStiMapKeyHelper: System.Interface<IStiMapKeyHelper>;
    interface IStiMapKeyHelper {
        getMapIdents(key: string): string[];
        getIsoAlpha2FromName(country: string, mapId: string, lang: string): string;
        getIsoAlpha3FromName(country: string, mapId: string, lang: string): string;
        getNameFromIsoAlpha2(alpha3: string, mapId: string, lang: string): string;
        getNameFromIsoAlpha3(alpha3: string, mapId: string, lang: string): string;
        normalizeName(name: string, mapId: string, lang: string, report: IStiReport): string;
    }
}
export namespace Stimulsoft.Base.Meta {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiMeta<T = any> {
        jsName: string;
        getValue: (mode?: StiJsonSaveMode) => T | StiJson;
        checkValue: (mode?: StiJsonSaveMode) => boolean;
        setValue: (property: StiJson) => void;
        setValueXml: (node: XmlNode) => void;
        filterSaveMode: StiJsonSaveMode;
        originalName: string[];
        saveToJsonObject(jObject: StiJson, obj: any, mode?: StiJsonSaveMode): void;
        loadFromJsonObject(property: StiJson, obj: IStiJsonReportObject): void;
        loadFromXml(node: XmlNode, obj: IStiJsonReportObject): void;
        get(getValue: (mode?: StiJsonSaveMode) => T | StiJson): StiMeta<T>;
        check(checkValue: (mode?: StiJsonSaveMode) => boolean): StiMeta<T>;
        set(setValue: (property: StiJson) => void): StiMeta<T>;
        setXml(setValueXml: (value: XmlNode) => void): StiMeta<T>;
        constructor(originalName: string | string[], jsName?: string, getValue?: (mode?: StiJsonSaveMode) => T | StiJson, checkValue?: (mode?: StiJsonSaveMode) => boolean, setValue?: (property: StiJson) => void, setValueXml?: (node: XmlNode) => void, filterSaveMode?: StiJsonSaveMode);
    }
}
export namespace Stimulsoft.Base.Meta {
    import StiJson = Stimulsoft.Base.StiJson;
    class StiBoolMeta extends StiMeta<boolean> {
        defaultValue: boolean;
        ignoreDefaultValues: boolean;
        saveToJsonObject(jObject: StiJson, obj: any): void;
        constructor(originalName: string | string[], jsName?: string, defaultValue?: boolean, ignoreDefaultValues?: boolean);
    }
}
export namespace Stimulsoft.Base.Meta {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiBrushMeta extends StiMeta<StiBrush> {
        defaultValue: StiBrush;
        saveToJsonObject(jObject: StiJson, obj: any): void;
        constructor(originalName: string | string[], jsName?: string, defaultValue?: StiBrush);
    }
}
export namespace Stimulsoft.Base.Meta {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiColorMeta extends StiMeta<Color> {
        defaultValue: Color;
        saveToJsonObject(jObject: StiJson, obj: any, mode?: StiJsonSaveMode): void;
        constructor(originalName: string, jsName?: string, defaultValue?: Color, filterSaveMode?: StiJsonSaveMode);
    }
}
export namespace Stimulsoft.Base.Meta {
    import StiJson = Stimulsoft.Base.StiJson;
    class StiEnumMeta extends StiMeta {
        enumType: any;
        defaultValue: any;
        saveToJsonObject(jObject: StiJson, obj: any): void;
        constructor(originalName: string | string[], jsName: string, enumType: any, defaultValue?: any);
    }
}
export namespace Stimulsoft.Base.Meta {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiEventMeta extends StiMeta {
        saveToJsonObject(jObject: StiJson, obj: any, mode: StiJsonSaveMode): void;
        constructor(originalName: string);
    }
}
export namespace Stimulsoft.Base.Meta {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiExpressionMeta extends StiMeta {
        saveToJsonObject(jObject: StiJson, obj: any, mode: StiJsonSaveMode): void;
        constructor(originalName: string | string[], jsName?: string);
    }
}
export namespace Stimulsoft.Base.Meta {
    import GraphicsUnit = Stimulsoft.System.Drawing.GraphicsUnit;
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    import StiJson = Stimulsoft.Base.StiJson;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiFontMeta extends StiMeta<Font> {
        defaultFamily: string;
        defaultEmSize: number;
        defaultStyle: FontStyle;
        defaultUnit: GraphicsUnit;
        saveToJsonObject(jObject: StiJson, obj: any): void;
        constructor(originalName: string | string[], jsName?: string, defaultFamily?: string, defaultEmSize?: number, defaultStyle?: FontStyle, defaultUnit?: GraphicsUnit);
    }
}
export namespace Stimulsoft.Base.Meta {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiMetaHelper {
        static saveToJsonObject(mode: StiJsonSaveMode, obj: {
            meta(): StiMeta[];
        }, jObject?: StiJson): StiJson;
        static loadFromJsonObject(jObject: StiJson, obj: any): void;
        static loadFromXml(xmlNode: XmlNode, obj: any): void;
    }
}
export namespace Stimulsoft.Base.Meta {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiNumberMeta extends StiMeta<number> {
        defaultValue: number;
        saveToJsonObject(jObject: StiJson, obj: any): void;
        constructor(originalName: string | string[], jsName?: string, defaultValue?: number);
    }
}
export namespace Stimulsoft.Base.Meta {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiObjectMeta extends StiMeta<IStiJsonReportObject> {
        constructor(originalName: string | string[], jsName?: string);
    }
}
export namespace Stimulsoft.Base.Meta {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiRemoveMeta extends StiMeta {
        saveToJsonObject(jObject: StiJson, obj?: any): void;
        loadFromJsonObject(property: StiJson, obj: IStiJsonReportObject): void;
        loadFromXml(node: XmlNode, obj: IStiJsonReportObject): void;
        constructor(originalName: string | string[]);
    }
}
export namespace Stimulsoft.Base.Meta {
    import Size = Stimulsoft.System.Drawing.Size;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiSizeMeta extends StiMeta<Size> {
        defaultValue: Size;
        saveToJsonObject(jObject: StiJson, obj: any): void;
        constructor(originalName: string, jsName?: string, defaultValue?: Size);
    }
}
export namespace Stimulsoft.Base.Meta {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiStringMeta extends StiMeta<string> {
        defaulString: string;
        saveToJsonObject(jObject: StiJson, obj: any): void;
        constructor(originalName: string | string[], jsName?: string, defaulString?: string);
    }
}
export namespace Stimulsoft.Base.Meta {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiStringNullOrEmptyMeta extends StiMeta<string> {
        saveToJsonObject(jObject: StiJson, obj: any, mode?: StiJsonSaveMode): void;
        constructor(originalName: string | string[], jsName?: string, filterSaveMode?: StiJsonSaveMode);
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiArgumentMeter: System.Interface<IStiArgumentMeter>;
    interface IStiArgumentMeter {
    }
}
export namespace Stimulsoft.Base.Meters {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiBubbleColumn: System.Interface<IStiBubbleColumn>;
    interface IStiBubbleColumn {
        allowCustomColors: boolean;
        positiveColor: Color;
        negativeColor: Color;
    }
}
export namespace Stimulsoft.Base.Meters {
    import StiCardsColumnVisibility = Stimulsoft.Base.Drawing.StiCardsColumnVisibility;
    let IStiCardsColumn: System.Interface<IStiCardsColumn>;
    interface IStiCardsColumn {
        visibility: StiCardsColumnVisibility;
        visibilityExpression: string;
        height: number;
        wrapLine: boolean;
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiColorMapMeter: System.Interface<IStiColorMapMeter>;
    interface IStiColorMapMeter {
    }
}
export namespace Stimulsoft.Base.Meters {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiColorScaleColumn: System.Interface<IStiColorScaleColumn>;
    interface IStiColorScaleColumn {
        minimumColor: Color;
        maximumColor: Color;
    }
}
export namespace Stimulsoft.Base.Meters {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiDataBarsColumn: System.Interface<IStiDataBarsColumn>;
    interface IStiDataBarsColumn {
        width: number;
        positiveColor: Color;
        negativeColor: Color;
        overlappedColor: Color;
        fillColor: Color;
        minimum: string;
        maximum: string;
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiDimensionCardsColumn: System.Interface<IStiDimensionCardsColumn>;
    interface IStiDimensionCardsColumn {
        wordWrap: boolean;
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiDimensionColumn: System.Interface<IStiDimensionColumn>;
    interface IStiDimensionColumn {
        showHyperlink: boolean;
        hyperlinkPattern: string;
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiDimensionMeter: System.Interface<IStiDimensionMeter>;
    interface IStiDimensionMeter extends IStiMeter {
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiGroupMapMeter: System.Interface<IStiGroupMapMeter>;
    interface IStiGroupMapMeter {
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiIndicatorColumn: System.Interface<IStiIndicatorColumn>;
    interface IStiIndicatorColumn {
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiKeyMapMeter: System.Interface<IStiKeyMapMeter>;
    interface IStiKeyMapMeter {
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiLocalizedMeter: System.Interface<IStiLocalizedMeter>;
    interface IStiLocalizedMeter {
        localizedName: string;
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiMaxGaugeMeter: System.Interface<IStiMaxGaugeMeter>;
    interface IStiMaxGaugeMeter extends IStiMeter {
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiMeasureCardsColumn: System.Interface<IStiDimensionCardsColumn>;
    interface IStiMeasureCardsColumn {
        wordWrap: boolean;
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiMeasureColumn: System.Interface<IStiMeasureColumn>;
    interface IStiMeasureColumn {
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiMeasureMeter: System.Interface<IStiMeasureMeter>;
    interface IStiMeasureMeter extends IStiMeter {
    }
}
export namespace Stimulsoft.Base.Meters {
    import ICloneable = Stimulsoft.System.ICloneable;
    import IAsIs = Stimulsoft.System.IAsIs;
    let IStiMeter: System.Interface<IStiMeter>;
    interface IStiMeter extends IAsIs, ICloneable {
        getUniqueCode(): number;
        key: string;
        expression: string;
        label: string;
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiMinGaugeMeter: System.Interface<IStiMinGaugeMeter>;
    interface IStiMinGaugeMeter extends IStiMeter {
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiNameMapMeter: System.Interface<IStiNameMapMeter>;
    interface IStiNameMapMeter {
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiPivotColumn: System.Interface<IStiPivotColumn>;
    interface IStiPivotColumn {
        showTotal: boolean;
        totalLabel: string;
        strSortDirection: string;
        expandExpression: string;
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiPivotRow: System.Interface<IStiPivotRow>;
    interface IStiPivotRow {
        showTotal: boolean;
        totalLabel: string;
        strSortDirection: string;
        expandExpression: string;
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiPivotSummary: System.Interface<IStiPivotSummary>;
    interface IStiPivotSummary {
        hideZeros: boolean;
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiSeriesMeter: System.Interface<IStiSeriesMeter>;
    interface IStiSeriesMeter {
    }
}
export namespace Stimulsoft.Base.Meters {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiSparklinesColumn: System.Interface<IStiSparklinesColumn>;
    interface IStiSparklinesColumn {
        allowCustomColors: boolean;
        showHighLowPoints: boolean;
        showFirstLastPoints: boolean;
        positiveColor: Color;
        negativeColor: Color;
    }
}
export namespace Stimulsoft.Base.Meters {
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    let IStiTableColumn: System.Interface<IStiTableColumn>;
    interface IStiTableColumn {
        visible: boolean;
        showTotalSummary: boolean;
        summaryType: StiSummaryColumnType;
        visibility: StiTableColumnVisibility;
        visibilityExpression: string;
        summaryAlignment: StiHorAlignment;
        headerAlignment: StiHorAlignment;
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiTargetMeter: System.Interface<IStiTargetMeter>;
    interface IStiTargetMeter {
    }
}
export namespace Stimulsoft.Base.Meters {
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    let IStiTextMeasureMeter: System.Interface<IStiTextMeasureMeter>;
    interface IStiTextMeasureMeter extends IStiMeter {
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiValueMapMeter: System.Interface<IStiValueMapMeter>;
    interface IStiValueMapMeter {
    }
}
export namespace Stimulsoft.Base.Meters {
    let IStiValueMeter: System.Interface<IStiValueMeter>;
    interface IStiValueMeter {
    }
}
export namespace Stimulsoft.Base {
    enum StiNoticeIdent {
        ActivationMaxActivationsReached = 1,
        ActivationExpiriedBeforeFirstRelease = 2,
        ActivationLicenseIsNotCorrect = 3,
        ActivationLockedAccount = 4,
        ActivationServerVersionNotAllowed = 5,
        ActivationServerIsNotAvailableNow = 6,
        ActivationSomeTroublesOccurred = 7,
        ActivationUserNameOrPasswordIsWrong = 8,
        ActivationWrongAccountType = 9,
        AuthAccountCantBeUsedNow = 10,
        AuthAccountIsNotActivated = 11,
        AuthCantChangeSystemRole = 12,
        AuthCantChangeRoleBecauseLastAdministratorUser = 13,
        AuthCantChangeRoleBecauseLastSupervisorUser = 14,
        AuthCantDeleteHimselfUser = 15,
        AuthCantDeleteLastAdministratorUser = 16,
        AuthCantDeleteLastSupervisorUser = 17,
        AuthCantDeleteSystemRole = 18,
        AuthCantDisableUserBecauseLastAdministratorUser = 19,
        AuthCantDisableUserBecauseLastSupervisorUser = 20,
        AuthOAuthIdNotSpecified = 21,
        AuthPasswordIsTooShort = 22,
        AuthPasswordIsNotSpecified = 23,
        AuthPasswordIsNotCorrect = 24,
        AuthRequestsLimitIsExceeded = 25,
        AuthRoleCantBeDeletedBecauseUsedByUsers = 26,
        AuthRoleNameAlreadyExists = 27,
        AuthRoleNameIsSystemRole = 28,
        AuthUserHasLoggedOut = 29,
        AuthUserNameAlreadyExists = 30,
        AuthUserNameIsNotSpecified = 31,
        AuthUserNameOrPasswordIsNotCorrect = 32,
        AuthUserNameShouldLookLikeAnEmailAddress = 33,
        AuthWorkspaceNameAlreadyInUse = 34,
        CommandTimeOut = 35,
        CustomMessage = 36,
        ExecutionError = 37,
        IsNotAuthorized = 38,
        IsNotDeleted = 39,
        IsNotCorrect = 40,
        IsNotEqual = 41,
        IsNotFound = 42,
        IsNotRecognized = 43,
        IsNotSpecified = 44,
        ItemCantBeDeletedBecauseItemIsAttachedToOtherItems = 45,
        ItemCantBeMovedToSpecifiedPlace = 46,
        ItemDoesNotSupport = 47,
        KeyAndToKeyIsEqual = 48,
        NotificationFailed = 49,
        NotificationFileUploading = 50,
        NotificationFilesUploadingComplete = 51,
        NotificationItemDelete = 52,
        NotificationItemDeleteComplete = 53,
        NotificationItemRestore = 54,
        NotificationItemRestoreComplete = 55,
        NotificationItemTransfer = 56,
        NotificationItemTransferComplete = 57,
        NotificationItemWaitingProcessing = 58,
        NotificationOperationAborted = 59,
        NotificationRecycleBinCleaning = 60,
        NotificationRecycleBinCleaningComplete = 61,
        NotificationRecycleBinWaitingProcessing = 62,
        NotificationReportCompiling = 63,
        NotificationReportDataProcessing = 64,
        NotificationReportExporting = 65,
        NotificationReportExportingComplete = 66,
        NotificationReportRendering = 67,
        NotificationReportRenderingComplete = 68,
        NotificationReportSaving = 69,
        NotificationReportWaitingProcessing = 70,
        NotificationSchedulerRunning = 71,
        NotificationSchedulerRunningComplete = 72,
        NotificationSchedulerWaitingProcessing = 73,
        NotificationTransferring = 74,
        NotificationTransferringComplete = 75,
        NotificationTitleFilesUploading = 76,
        NotificationTitleItemRefreshing = 77,
        NotificationTitleItemTransferring = 78,
        NotificationTitleReportExporting = 79,
        NotificationTitleReportRendering = 80,
        NotificationTitleSchedulerRunning = 81,
        QuotaMaximumComputingCyclesCountExceeded = 82,
        QuotaMaximumFileSizeExceeded = 83,
        QuotaMaximumItemsCountExceeded = 84,
        QuotaMaximumReportPagesCountExceeded = 85,
        QuotaMaximumUsersCountExceeded = 86,
        QuotaMaximumWorkspacesCountExceeded = 87,
        AccessDenied = 88,
        OutOfRange = 89,
        ParsingCommandException = 90,
        SchedulerCantRunItSelf = 91,
        SessionTimeOut = 92,
        SnapshotAlreadyProcessed = 93,
        SpecifiedItemIsNot = 94,
        WithSpecifiedKeyIsNotFound = 95,
        VersionCopyFromItem = 96,
        VersionCreatedFromFile = 97,
        VersionCreatedFromItem = 98,
        VersionNewItemCreation = 99,
        VersionLoadedFromFile = 100
    }
}
export namespace Stimulsoft.Base {
    class StiNotice {
        ident: StiNoticeIdent;
        arguments: string[];
        customMessage: string;
    }
}
export namespace Stimulsoft.Base {
    import StiToken = Stimulsoft.Base.StiToken;
    import IRefOut = Stimulsoft.System.IRefOut;
    interface IExternalObjectsProvider {
        containsObject(name: string): boolean;
        isReadOnlyObject(name: string): boolean;
        getObject(name: string): any;
        isObjectSupportsNesting(value: any): boolean;
        containsNestedObject(value: any, path: string): boolean;
        getNestedObject(value: any, path: string, result: IRefOut<any>): boolean;
        setObject(name: string, value: any): void;
        containsFunction(name: string, parameterTypes: any[]): boolean;
        invokeFunction(name: string, parameters: any[], parameterTypes: any[]): any;
    }
    class TokenPosition {
        line: number;
        column: number;
        constructor(line: number, column: number);
        toString(): string;
    }
    export class StiCSharpScriptParser {
        private thisObject;
        private executionStart;
        private timeoutMilliseconds;
        private externalObjects;
        private namespaces;
        private functions;
        private variables;
        private nameToType;
        private currentToken;
        private currentTokenIndex;
        private tokens;
        private tokenPositions;
        result: any;
        allowUsingDirective: boolean;
        static execute(script: string): any;
        execute(timeoutMilliseconds?: number): any;
        private checkTimeout;
        private parsePropertyChain;
        private parseAssignPropertyChain;
        setThisObject(thisObject: any): void;
        private parseExpression;
        private setElementExpression;
        private parseTypeExpression;
        private parseLogicalOrExpression;
        private parseLogicalAndExpression;
        private parseDoublePlusOrMinusExpression;
        private parseDoubleMinusExpression;
        private parseDoublePlusExpression;
        private parseEqualityExpression;
        private parseIsOperatorExpression;
        private parseAsOperatorExpression;
        private parseComparisonExpression;
        private parseAdditionExpression;
        private parseMultiplicationExpression;
        private parseUnaryExpression;
        private parsePrimaryExpression;
        private convertKeywordTypeToStandardType;
        private processInterpolatedString;
        private tryExtractFormatSpecifier;
        private parseAnonymousTypeExpression;
        private parseFunctionCallExpression;
        private parseNestedExpression;
        private skipExpression;
        private parseArrayIndexingExpression;
        private parseTypeOfExpression;
        private parseTypeExplicitCastExpression;
        private isExplicitCastExpression;
        private parseArrayCreationExpression;
        private parseArrayInitialization;
        private parseObjectCreationExpression;
        private parseObjectInitialization;
        setExternalObjectsProvider(provider: IExternalObjectsProvider): void;
        registerFunction(name: string, func: (...args: any[]) => any): void;
        private initializeStandardFunctions;
        private setArrayElement;
        private setIntegerIndexerElement;
        private setStringIndexerElement;
        private hasStringIndexer;
        private hasIntegerIndexer;
        private getStringIndexerValue;
        private getIntegerIndexerValue;
        private setStringIndexerValue;
        private setIntegerIndexerValue;
        private checkIndexRange;
        registerNamespace(name: string): void;
        private addDefaultNamespaces;
        private parseAssignOperation;
        private isAssignOperation;
        private compareOperation;
        private bitwiseUnaryOperation;
        private bitwiseAndOperation;
        private bitwiseOrOperation;
        private bitwiseXorOperation;
        private addOperation;
        private subtractOperation;
        private multiplyOperation;
        private divideOperation;
        private moduloOperation;
        private equalsOperation;
        private parsePropertyOrMethodCall;
        private parseMethodCall;
        private parseMethodArguments;
        private invokeMethod;
        private setPropertyOrField;
        private getPropertyOrField;
        private setChainedPropertyOrField;
        private parseStatement;
        private parseKeywordOrIdentStatement;
        private parseKeywordStatement;
        private parseFunctionOrVariableDeclarationStatement;
        private parseStaticObjectStatement;
        private parseIdentStatement;
        private parseUsingStatement;
        private processBreakStatement;
        private parseContinueStatement;
        private skipBlockStatement;
        private parseVariableDeclarationStatement;
        private parseBlockStatement;
        private parseThisStatement;
        private parseIfStatement;
        private parseWhileStatement;
        private parseDoWhileStatement;
        private parseForStatement;
        private parseForeachStatement;
        private parseReturnStatement;
        private parseFunctionDeclarationStatement;
        private skipStatement;
        private loadTokensWithPositions;
        private getTokenAfterFullIdent;
        private getTokenPosition;
        private saveState;
        private restoreState;
        private nextToken;
        private moveNext;
        private moveNextIfSemiColon;
        private moveNextIfRPar;
        private savePosition;
        private restorePosition;
        private waitAssign;
        private waitColon;
        private waitComma;
        private waitSemiColon;
        private waitLeft;
        private waitRight;
        private waitLBracket;
        private waitRBracket;
        private waitLBrace;
        private waitRBrace;
        private waitLPar;
        private waitRPar;
        private waitAnyIdentOrKeyword;
        private waitAnyIdent;
        private waitIdent;
        private waitDot;
        private waitKeyword;
        private waitIdentOrKeywordType;
        getTokens(): StiToken[];
        getTokenPositions(): TokenPosition[];
        private isIntegerType;
        private isFloatingType;
        private createArray;
        private convertToType;
        private convertToReturnType;
        private getType;
        private getGenericCollectionType;
        private getStandardType;
        private getNameToTypeCache;
        setExternalTypesCache(nameToType: {
            [key: string]: any;
        }): void;
        setVariable(name: string, value: any): void;
        private setVariableByPath;
        private tryGetVariable;
        getVariable(name: string): any;
        getVariableAsBool(name: string): boolean | null;
        getVariableAsInt(name: string): number | null;
        getVariableAsLong(name: string): number | null;
        getVariableAsFloat(name: string): number | null;
        getVariableAsDouble(name: string): number | null;
        getVariableAsDecimal(name: string): number | null;
        private externalVariablesContains;
        constructor(scriptText: string);
        constructor(script: string, cachedTokens?: StiToken[], cachedPositions?: TokenPosition[]);
    }
    export {};
}
export namespace Stimulsoft.Base.Services {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiRepositoryItems = Stimulsoft.Base.StiRepositoryItems;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiService implements ICloneable, IAsIs {
        clone(cloneProperties?: boolean, cloneComponents?: boolean, base?: boolean): any;
        memberwiseClone(base?: boolean): StiService;
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        isPropertyPresent(key: any): boolean;
        private _properties;
        get properties(): StiRepositoryItems;
        set properties(value: StiRepositoryItems);
        protected isPropertiesInitializedProtected(): boolean;
        get serviceCategory(): string;
        get serviceName(): string;
        get serviceInfo(): string;
        get serviceType(): Stimulsoft.System.Type;
        get serviceEnabled(): boolean;
        set serviceEnabled(value: boolean);
    }
}
export namespace Stimulsoft.Base.SignatureFonts {
    enum StiSignatureStyle {
        Style1 = 0,
        Style2 = 1,
        Style3 = 2
    }
}
export namespace Stimulsoft.Base {
    import StiSignatureStyle = Stimulsoft.Base.SignatureFonts.StiSignatureStyle;
    class StiSignatureFontsHelper {
        static getFontName(style: StiSignatureStyle): string;
    }
}
export namespace Stimulsoft.Base {
    class StiGZipHelper {
        private static DefaultLevel;
        private static DefaultMethod;
        private static ID1;
        private static ID2;
        private static _crcTable;
        static get crcTable(): number[];
        static crc32(data: Uint8Array): number;
        private static putByte;
        private static putShort;
        private static putLong;
        private static putString;
        private static readByte;
        private static readShort;
        private static readLong;
        private static readString;
        private static readBytes;
        static pack(data: string | number[] | Uint8Array, name?: string): string | number[];
        static unpack<B extends boolean>(data: string | number[] | Uint8Array, returnString: B): B extends true ? string : number[];
    }
}
export namespace Stimulsoft.Base.Zip {
    import DateTime = Stimulsoft.System.DateTime;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiZipWriter20 {
        static convertToArray(useUnicode: boolean, str: string): number[];
        static getDosTime(dt: DateTime): number;
        private _mainStream;
        private zipFiles;
        begin(stream: MemoryStream, leaveOpen: boolean): void;
        addFile(fileName: string, dataStream: MemoryStream, closeDataStream?: boolean): void;
        end(): void;
        constructor();
    }
}
export namespace Stimulsoft.Data.Helpers {
    import DateTime = Stimulsoft.System.DateTime;
    class StiDateTimeCorrector {
        static correct(dateTime: DateTime): DateTime;
    }
}
export namespace Stimulsoft.Data.Comparers {
    class StiObjectComparer {
        equals(x: any, y: any): boolean;
        getHashCode(x: any): number;
        static readonly default: StiObjectComparer;
        static compare(x: any, y: any): number;
        private static defaultCompare;
        private static dateTimeCompare;
        private static arrayCompare;
    }
}
export namespace Stimulsoft.Data.Comparers {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    class StiArrayComparer implements IComparer<any[]> {
        compare(x: any[], y: any[]): number;
    }
}
export namespace Stimulsoft.Data.Comparers {
    import IEqualityComparer = Stimulsoft.System.Collections.IEqualityComparer;
    class StiArrayEqualityComparer implements IEqualityComparer<any[]> {
        equals(x: any[], y: any[]): boolean;
        getHashCode(x: any[]): number;
    }
}
export namespace Stimulsoft.Data.Comparers {
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    class StiDataActionComparer implements IComparer<StiDataActionRule> {
        compare(x: StiDataActionRule, y: StiDataActionRule): number;
    }
}
export namespace Stimulsoft.Data.Comparers {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import DataRow = Stimulsoft.System.Data.DataRow;
    class StiDataRowComparer implements IComparer<DataRow> {
        compare(x: DataRow, y: DataRow): number;
    }
}
export namespace Stimulsoft.Data.Engine {
    enum StiDataSortDirection {
        Ascending = 1,
        Descending = 2,
        None = 3
    }
    enum StiDataFilterCondition {
        EqualTo = 0,
        NotEqualTo = 1,
        GreaterThan = 2,
        GreaterThanOrEqualTo = 3,
        LessThan = 4,
        LessThanOrEqualTo = 5,
        Between = 6,
        NotBetween = 7,
        Containing = 8,
        NotContaining = 9,
        BeginningWith = 10,
        EndingWith = 11,
        IsNull = 12,
        IsNotNull = 13,
        IsBlank = 14,
        IsNotBlank = 15,
        IsBlankOrNull = 16,
        IsFalse = 17,
        PairEqualTo = 18,
        MapEqualTo = 19,
        Any = 20
    }
    enum StiDataFilterOperation {
        AND = 0,
        OR = 1
    }
    enum StiDataActionType {
        Limit = 0,
        Replace = 1,
        RunningTotal = 2,
        Percentage = 3
    }
    enum StiDataFilterConditionGroupType {
        Equal = 0,
        NotEqual = 1,
        Custom = 2,
        Empty = 3
    }
    enum StiDataRequestOption {
        None = 0,
        AllowOpenConnections = 1,
        AllowDataSort = 2,
        DisallowTransform = 4,
        DisallowFilters = 8,
        All = 3
    }
    enum StiDataTopNMode {
        None = 0,
        Top = 1,
        Bottom = 2
    }
    enum StiDataFormatKind {
        General = 0,
        Boolean = 1,
        Currency = 2,
        Date = 3,
        Number = 4,
        Percentage = 5,
        Time = 6
    }
    enum StiDataJoinEngine {
        V1 = 0,
        V2 = 1,
        V3 = 2,
        V4 = 3,
        V5 = 4
    }
    enum StiTableFiltersGroupsType {
        None = 0,
        Simple = 1,
        Complex = 2
    }
    enum StiDataActionPriority {
        BeforeTransformation = 0,
        AfterGroupingData = 1,
        AfterSortingData = 2
    }
}
export namespace Stimulsoft.Data.Engine {
    let IStiAllowSortByVariation: System.Interface<IStiAllowSortByVariation>;
    let ImplementsIStiAllowSortByVariation: any[];
    interface IStiAllowSortByVariation {
    }
}
export namespace Stimulsoft.Data.Engine {
    let IStiCrossFiltering: System.Interface<IStiCrossFiltering>;
    let ImplementsIStiCrossFiltering: any[];
    interface IStiCrossFiltering {
        crossFiltering: boolean;
    }
}
export namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    let IStiDataFilters: System.Interface<IStiDataFilters>;
    let ImplementsIStiDataFilters: any[];
    interface IStiDataFilters {
        dataFilters: List<StiDataFilterRule>;
    }
}
export namespace Stimulsoft.Data.Engine {
    let IStiDataFormat: System.Interface<IStiDataFormat>;
    interface IStiDataFormat {
        getDataFormat(): StiDataFormatKind;
    }
}
export namespace Stimulsoft.Data.Engine {
    let IStiDataTopN: System.Interface<IStiDataTopN>;
    let ImplementsIStiDataTopN: any[];
    interface IStiDataTopN {
        topN: StiDataTopN;
    }
}
export namespace Stimulsoft.Data.Engine {
    let IStiDataTransformationElement: System.Interface<IStiDataTransformationElement>;
    let ImplementsIStiDataTransformationElement: any[];
    interface IStiDataTransformationElement {
        dataTransformation: any;
    }
}
export namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    let IStiDrillDownElement: System.Interface<IStiDrillDownElement>;
    let ImplementsIStiDrillDownElement: any[];
    interface IStiDrillDownElement {
        drillDownFilters: List<StiDataFilterRule>;
        drillDownFiltersList: List<List<StiDataFilterRule>>;
        drillDownCurrentLevel: number;
        drillDownLevelCount: number;
    }
}
export namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    let IStiRetrieval: System.Interface<IStiRetrieval>;
    let ImplementsIStiRetrieval: any[];
    interface IStiRetrieval {
        retrieveUsedDataNames(group: string): List<string>;
    }
}
export namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    import IStiRetrieval = Stimulsoft.Data.Engine.IStiRetrieval;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    let IStiQueryObject: System.Interface<IStiQueryObject>;
    let ImplementsIStiQueryObject: any[];
    interface IStiQueryObject extends IStiRetrieval {
        getDictionary(): IStiAppDictionary;
        getDataSources(dataNames: List<string>): List<IStiAppDataSource>;
    }
}
export namespace Stimulsoft.Data.Engine {
    let IStiSkipNormalizeDate: System.Interface<IStiSkipNormalizeDate>;
    interface IStiSkipNormalizeDate {
    }
}
export namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    let IStiTransformActions: System.Interface<IStiTransformActions>;
    let ImplementsIStiTransformActions: any[];
    interface IStiTransformActions {
        transformActions: List<StiDataActionRule>;
    }
}
export namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    let IStiTransformFilters: System.Interface<IStiTransformFilters>;
    let ImplementsIStiTransformFilters: any[];
    interface IStiTransformFilters {
        transformFilters: List<StiDataFilterRule>;
    }
}
export namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    let IStiTransformSorts: System.Interface<IStiTransformSorts>;
    let ImplementsIStiTransformSorts: any[];
    interface IStiTransformSorts {
        transformSorts: List<StiDataSortRule>;
    }
}
export namespace Stimulsoft.Data.Engine {
    import IAsIs = Stimulsoft.System.IAsIs;
    import List = Stimulsoft.System.Collections.List;
    let IStiUserFilters: System.Interface<IStiUserFilters>;
    let ImplementsIStiUserFilters: any[];
    interface IStiUserFilters extends IAsIs {
        userFilters: List<StiDataFilterRule>;
    }
}
export namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    let IStiUserSorts: System.Interface<IStiUserSorts>;
    let ImplementsIStiUserSorts: any[];
    interface IStiUserSorts {
        userSorts: List<StiDataSortRule>;
    }
}
export namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    abstract class LogicalExpressionVisitor {
        abstract visit1(expression: LogicalExpression): any;
        abstract visit2(expression: TernaryExpression): any;
        abstract visit3(expression: BinaryExpression): any;
        abstract visit4(expression: UnaryExpression): any;
        abstract visit5(expression: ValueExpression): any;
        abstract visit6(expression: Functionn): any;
        abstract visit7(expression: Identifier): any;
    }
}
export namespace Stimulsoft.Data.Helpers {
    import IStiReport = Stimulsoft.Base.IStiReport;
    import LogicalExpression = Stimulsoft.Data.Expressions.NCalc.Domain.LogicalExpression;
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    class StiExpressionHelper {
        private static expressionToArguments;
        static newExpression(expression: string): Stimulsoft.Data.Expressions.NCalc.Expression;
        static prepareExpression(expression: string): string;
        static escapeExpression(expression: string): string;
        static removeRelations(expression: string, dataSources: List<IStiAppDataSource>): string;
        static replaceFunction(expression: string, newFunction: string): string;
        static removeFunction(expression: string): string;
        static isPercentOfGrandTotal(expression: string): boolean;
        static isAggregationFunctionPresent(expression: string): boolean;
        static isFunctionPresent(expression: string): boolean;
        static getFunction(expression: string): string;
        static getArguments(expression: string): List<string>;
        static compile(expression: string): LogicalExpression;
        static getFirstArgumentFromExpression(expression: string): string;
        static parseReportExpression(report: IStiReport, text: string, withBraces: boolean, allowReturnNull?: boolean): string;
        static fetchBlocksFromExpression(inputExpression: string): List<string>;
        static replaceExpressionBlocksByValues(inputExpression: string, values: List<string>): string;
        static isTimeExpression(str: string): boolean;
        static isThisExpression(str: string): boolean;
        static isExpression(str: string): boolean;
    }
}
export namespace Stimulsoft.Data.Extensions {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import DataRelation = Stimulsoft.System.Data.DataRelation;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    class DataTableExt {
        static nullTable: DataTable;
        static getUniqueName(table: DataTable, meter: IStiMeter): string;
        static getUniqueName2(table: DataTable, meter: IStiMeter, baseName: string): string;
        static getUniqueName3(table: DataTable, baseName: string): string;
        static parentRelationList(table: DataTable): List<DataRelation>;
        static childRelationList(table: DataTable): List<DataRelation>;
    }
}
export namespace Stimulsoft.Data.Extensions {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiDataTableExt {
        static toNetTable(table: StiDataTable, onlyColumns?: boolean, convertsArray?: boolean): DataTable;
    }
}
export namespace Stimulsoft.Data.Engine {
    import IStiReport = Stimulsoft.Base.IStiReport;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import List = Stimulsoft.System.Collections.List;
    class StiDataActionOperator {
        private static lockObject;
        private static netCache;
        private static meterCache;
        static applyBeforeGrouping(inTable: DataTable, actions: List<StiDataActionRule>, report: IStiReport, hash: number): DataTable;
        static applyAfterGrouping(inTable: StiDataTable, actions: List<StiDataActionRule>, report: IStiReport, hash: number): StiDataTable;
        static cleanCache(appKey: string): void;
        private static getCacheKey;
        private static getCacheKey2;
        private static getFromCache;
        private static getFromCache2;
        private static addToCache;
        private static addToCache2;
    }
}
export namespace Stimulsoft.Data.Engine {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    abstract class StiDataRule implements ICloneable {
        clone(): any;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        abstract getUniqueCode(): number;
    }
}
export namespace Stimulsoft.Data.Engine {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiDataActionPriority = Stimulsoft.Data.Engine.StiDataActionPriority;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDataActionRule extends StiDataRule implements IStiJsonReportObject {
        meta(): StiMeta[];
        type: StiDataActionType;
        key: string;
        path: string;
        startIndex: number;
        rowsCount: number;
        initialValue: string;
        valueFrom: string;
        valueTo: string;
        matchCase: boolean;
        matchWholeWord: boolean;
        priority: StiDataActionPriority;
        static loadFromJson(json: StiJson): StiDataActionRule;
        static loadFromXml(xmlNode: XmlNode): StiDataActionRule;
        getUniqueCode(): number;
        static create1(key: string, path: string): StiDataActionRule;
        static create2(key: string, path: string, startIndex: number, rowsCount: number, priority?: StiDataActionPriority): StiDataActionRule;
        static create3(key: string, path: string, valueFrom: string, valueTo: string, matchCase: boolean, matchWholeWord: boolean): StiDataActionRule;
        static create4(key: string, path: string, initialValue: string): StiDataActionRule;
        constructor(key?: string, path?: string, type?: StiDataActionType, startIndex?: number, rowsCount?: number, priority?: StiDataActionPriority, valueFrom?: string, valueTo?: string, matchCase?: boolean, matchWholeWord?: boolean, initialValue?: string);
    }
}
export namespace Stimulsoft.Data.Engine {
    import IStiReport = Stimulsoft.Base.IStiReport;
    import List = Stimulsoft.System.Collections.List;
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiDataActionRuleHelper {
        static toList(...rules: StiDataActionRule[]): List<StiDataActionRule>;
        static validate(rules: List<StiDataActionRule>, columnKeys: List<string>): List<StiDataActionRule>;
        private static getColumnIndex;
        static applyActions(table: DataTable, actions: List<StiDataActionRule>, columnKeys: List<string>, columnNames: List<string>, report: IStiReport): void;
        private static applyLimitAction;
        private static applyReplaceAction;
        private static applyRunningTotalAction;
        private static applyPercentageAction;
    }
}
export namespace Stimulsoft.Data.Engine {
    import StiDataAnalyzerOptions = Stimulsoft.Data.Engine.StiDataAnalyzerOptions;
    class StiDataAnalyzer {
        static analyze(options: StiDataAnalyzerOptions): Promise<StiDataTable>;
        private static fetchAllTables;
        private static createEmptyTable;
        private static joinTables;
        private static applyFiltersBeforeGrouping;
        private static applyDataActionsBeforeGrouping;
        private static applyGrouping;
        private static applyDataActionsAfterGrouping;
        private static applyTransformFiltering;
        private static applyTransformActionsBeforeSorting;
        private static applyTransformSorting;
        private static applyTransformActionsAfterSorting;
        private static applyUserSorting;
        private static applyDataActionsAfterUserSorting;
        private static getDataActions;
        private static getTransformActions;
        private static isNull;
    }
}
export namespace Stimulsoft.Data.Engine {
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiReport = Stimulsoft.Base.IStiReport;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiDataAnalyzerOptions {
        query: IStiQueryObject;
        get report(): IStiReport;
        get dictionary(): IStiAppDictionary;
        hashCode: number;
        private _group;
        get group(): string;
        set group(value: string);
        meters: List<IStiMeter>;
        userSorts: List<StiDataSortRule>;
        userFilters: List<StiDataFilterRule>;
        dataFilters: List<StiDataFilterRule>;
        dataActions: List<StiDataActionRule>;
        transformSorts: List<StiDataSortRule>;
        transformFilters: List<StiDataFilterRule>;
        transformActions: List<StiDataActionRule>;
        drillDownFilters: List<StiDataFilterRule>;
        dataRequestOption: StiDataRequestOption;
        getFilters(): List<StiDataFilterRule>;
        getNames(): List<string>;
        private unionNames;
        initializeHash(): void;
        updateHashCode(rules: List<StiDataRule>): void;
        updateHashCode2(meters: List<IStiMeter>): void;
    }
}
export namespace Stimulsoft.Data.Engine {
    class StiDataColumnRuleHelper {
        static isGoodColumnName(columnName: string): boolean;
        static getGoodColumnName(columnName: string): string;
        private static keywords;
    }
}
export namespace Stimulsoft.Data.Engine {
    import IStiAppConnection = Stimulsoft.Base.IStiAppConnection;
    import List = Stimulsoft.System.Collections.List;
    class StiDataConnections {
        private static connections;
        static isConnectionActive(connection: IStiAppConnection): boolean;
        static registerConnection(connection: IStiAppConnection, items: List<object>): void;
        static unRegisterConnections(connections: List<IStiAppConnection>): List<object>;
        static unRegisterConnection(connection: IStiAppConnection): List<object>;
    }
}
export namespace Stimulsoft.Data.Extensions {
    import List = Stimulsoft.System.Collections.List;
    import DateTime = Stimulsoft.System.DateTime;
    class ListExt extends List<any> {
        static compare(a: any, b: any): any;
        private static compareValues;
        static isList(value: any): boolean;
        static isBoolList(value: any): boolean;
        static toList(value: any): List<any>;
        static toStringList(value: any): List<string>;
        static toNumberList(value: any): List<number>;
        static toBoolList(value: any): List<boolean>;
        static toNullableDateTimeList(value: any): List<DateTime | null>;
        static toArray(value: any): any[];
        static toStringArray(value: any): string[];
        static toNumberArray(value: any): number[];
        static add(a: any, b: any): List<any>;
    }
}
export namespace Stimulsoft.Data.Exceptions {
    abstract class StiDataException {
        message: string;
        constructor(message?: string);
    }
}
export namespace Stimulsoft.Data.Exceptions {
    class StiArgumentNotFoundException extends StiDataException {
        private _functionName;
        get functionName(): string;
        private _argumentName;
        get argumentName(): string;
        constructor(functionName: string, argumentName: string);
    }
}
export namespace Stimulsoft.Data.Exceptions {
    class StiArgumentCountException extends StiDataException {
        private _functionName;
        get functionName(): string;
        constructor(functionName: string);
    }
}
export namespace Stimulsoft.Data.Exceptions {
    class StiFunctionNotFoundException extends StiDataException {
        private _name;
        get name(): string;
        constructor(name: string);
    }
}
export namespace Stimulsoft.Data.Types {
    class SimpleValue {
        private _value;
        get value(): any;
        constructor(value: any);
    }
}
export namespace Stimulsoft.Data.Options {
    import MidpointRounding = Stimulsoft.System.MidpointRounding;
    class StiDataOptions {
        static allowNulls: boolean;
        static roundType: MidpointRounding;
    }
}
export namespace Stimulsoft.Data.Types {
    import DateTime = Stimulsoft.System.DateTime;
    class DateTimeValue {
        value: DateTime;
        constructor(value: any);
    }
}
export namespace Stimulsoft.Data.Functions {
    import DateTime = Stimulsoft.System.DateTime;
    class StiMonthToStrHelper {
        private static months;
        private static defaultUpperCaseList;
        private static cultureIndexes;
        static monthName(dateTime: DateTime): string;
        static monthName2(dateTime: DateTime, localized: boolean): string;
        static monthName3(dateTime: DateTime, culture: string): string;
        static monthName4(dateTime: DateTime, culture: string, upperCase: boolean): string;
        static monthName5(month: StiMonth, culture: string): string;
        static addCulture(monthNames: string[], cultureNames: string[], defaultUpperCase: boolean): void;
        static month2(value: number): StiMonth;
        static month(str: string): StiMonth | null;
        static initialize(): void;
    }
}
export namespace Stimulsoft.Data.Types {
    import StiMonth = Stimulsoft.Data.Functions.StiMonth;
    class StiFiscalMonth {
        month: StiMonth;
        startMonth: StiMonth;
        get actualMonthIndex(): number;
        toString(): string;
        getHashCode(): number;
        stiFiscalMonth(month: StiMonth, startMonth: StiMonth): void;
        constructor(month: StiMonth, startMonth: StiMonth);
    }
}
export namespace Stimulsoft.Data.Functions {
    import StiFiscalMonth = Stimulsoft.Data.Types.StiFiscalMonth;
    import Type = Stimulsoft.System.Type;
    import IStiAppFunction = Stimulsoft.Base.IStiAppFunction;
    import DayOfWeek = Stimulsoft.System.DayOfWeek;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import List = Stimulsoft.System.Collections.List;
    import DateTime = Stimulsoft.System.DateTime;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    class Funcs {
        static count(value: any): number;
        static countIf(value: any, condition: any): number;
        static distinct(value: any): any;
        static distinctCount(value: any): number;
        static distinctCountIf(value: any, condition: any): number;
        static first(value: any): any;
        static last(value: any): any;
        static all(value: any): any;
        static isAggregationFunction(functionn: string): boolean;
        static avg(value: any): number;
        static avgNulls(value: any): number;
        static avgDate(value: any): DateTime | null;
        static avgTime(value: any): TimeSpan | null;
        private static getTimeSpan;
        static max(value: any): number;
        static maxNulls(value: number): number;
        static maxD(value: any): number;
        static maxI(value: any): number;
        static maxDate(value: any): DateTime | null;
        static maxTime(value: any): TimeSpan | null;
        static maxStr(value: any): string;
        static median(value: any): number;
        static min(value: any): number;
        static minNulls(value: any): number;
        static minDate(value: any): DateTime | null;
        static minTime(value: any): TimeSpan | null;
        static minMaxDateString(value: any): string;
        static minStr(value: any): string;
        static mode(value: any): number;
        static sum(value: any): number;
        static sumNulls(value: any): number;
        static sumD(value: any): number;
        static sumI(value: any): number;
        static sumTime(value: any): TimeSpan;
        static sumDistinct(value: any): number;
        static sumIf(value: any, condition: any): number;
        static sumDIf(value: any, condition: any): number;
        static sumIIf(value: any, condition: any): number;
        static sumTimeIf(value: any, condition: any): TimeSpan;
        static sumDistinctIf(value: any, condition: any): number;
        private static getCondition;
        private static getConditions;
        static stDev(value: any): number;
        static stDevP(value: any): number;
        static dayOfWeekIdent(dateTime: DateTime | null): DayOfWeek | null;
        static dayOfWeekIdentObject(value: any): any;
        static dayOfWeekIndex(dateTime: DateTime | null): number;
        static dayOfWeekIndexObject(value: any): any;
        static dayOfWeek(date: DateTime | null): string;
        static dayOfWeekObject(value: any): any;
        static dayOfWeek2(date: DateTime | null, localized: boolean): string;
        static dayOfWeekObject2(value: any, localized: boolean): any;
        static dayOfWeek3(date: DateTime | null, culture: string): string;
        static dayOfWeekObject3(value: any, culture: string): any;
        static dayOfWeek4(date: DateTime | null, culture: string, upperCase: boolean): string;
        static dayOfWeekObject4(value: any, culture: string, upperCase: boolean): any;
        static daysInMonth(year: number, month: number): number;
        static daysInMonthObject(value1: any, value2: any): any;
        static daysInMonth2(date: DateTime | null): number;
        static daysInMonthObject2(value: any): any;
        static daysInYear(year: number): number;
        static daysInYear2(date: DateTime | null): number;
        static daysInYearObject(value: any): any;
        static monthIdent(dateTime: DateTime | null): StiMonth | null;
        static monthIdentObject(value: any): any;
        static fiscalMonthIdent(dateTime: DateTime, startMonth: any): StiFiscalMonth;
        static fiscalMonthIdentObject(value: any, startMonth: any): any;
        private static objectToMonthIdent;
        static month(dateTime: DateTime | null): number;
        static monthObject(value: any): any;
        static monthName(date: DateTime | null): string;
        static monthNameObject(value: any): any;
        static monthName2(date: DateTime | null, localized: boolean): string;
        static monthNameObject2(value: any, localized: boolean): any;
        static monthName3(date: DateTime | null, culture: string): string;
        static monthNameObject3(value: any, culture: string): any;
        static monthName4(date: DateTime | null, culture: string, upperCase: boolean): string;
        static monthNameObject4(value: any, culture: string, upperCase: boolean): any;
        static addMonthsObject(date: any, months: number): any;
        static addYears(date: DateTime, years: number): DateTime;
        static addYearsObject(date: any, years: number): any;
        static day(dateTime: DateTime | null): number;
        static dayObject(value: any): any;
        static dateDiff(date1: DateTime | null, date2: DateTime | null): TimeSpan | null;
        static dateDiffObject(value1: any, value2: any): any;
        static dateTime(value: any): any;
        static dayOfYear(dateTime: DateTime | null): number;
        static dayOfYearObject(value: any): any;
        static financialQuarter(dateTime: DateTime | null): StiQuarter | null;
        static financialQuarterObject(value: any): any;
        static financialQuarterIndex(dateTime: DateTime | null): number;
        static financialQuarterIndexObject(value: any): any;
        static hour(dateTime: DateTime | null): number;
        static hourObject(value: any): any;
        static makeDate(year: number, month?: number, day?: number): DateTime;
        static makeDateObject(year: any, month?: any, day?: any): any;
        static makeDateTime(year: number, month?: number, day?: number, hour?: number, minute?: number, second?: number): DateTime;
        static makeDateTimeObject(year: any, month?: any, day?: any, hour?: any, minute?: any, second?: any): any;
        static makeTime(hour: number, minute?: number, second?: number): DateTime;
        static makeTimeObject(hour: any, minute?: any, second?: any): any;
        static minute(dateTime: DateTime | null): number;
        static minuteObject(value: any): any;
        static now(): DateTime;
        static quarterName(dateTime: DateTime | null, localized?: boolean): string;
        static quarterNameObject(value: any, localized?: boolean): any;
        static quarter(dateTime: DateTime | null): StiQuarter | null;
        static quarterObject(value: any): any;
        static quarterIndex(dateTime: DateTime | null): number;
        static quarterIndexObject(value: any): any;
        static second(dateTime: DateTime | null): number;
        static secondObject(value: any): any;
        static time(value: any): any;
        static year(dateTime: DateTime | null): number;
        static yearObject(value: any): any;
        static yearMonth(dateTime: DateTime | null): string;
        static yearMonthObject(value: any): any;
        static getDateDimensionFunctions(): string[];
        static image(value: any, width?: number, height?: number): any;
        static isValidUrl(hyperlink: string): boolean;
        static localize(func: string): string;
        static abs(value: number): number;
        static absObject(value: any): any;
        static acos(value: number): number;
        static acosObject(value: any): any;
        static asin(value: number): number;
        static asinObject(value: any): any;
        static atan(value: number): any;
        static atanObject(value: any): any;
        static ceiling(value: number): number;
        static ceilingObject(value: any): any;
        static cos(value: number): number;
        static cosObject(value: any): any;
        static div(value1: number, value2: number, zeroResult?: number | null): number | null;
        static divObject(value1: any, value2: any, zeroResult?: any): number;
        static exp(value: number): number;
        static expObject(value: any): any;
        static floor(value: number): number;
        static floorObject(value: any): any;
        static log(value: number): number;
        static logObject(value: any): any;
        static round(value: number, decimals?: number): number;
        static roundObject(value: any, decimals?: number): any;
        static sign(value: number): number;
        static signObject(value: any): any;
        static sin(value: number): number;
        static sinObject(value: any): any;
        static sqrt(value: number): number;
        static sqrtObject(value: any): any;
        static tan(value: number): number;
        static tanObject(value: any): any;
        static truncate(value: number): number;
        static truncateObject(value: any): any;
        static isMeasureFunction(expression: string): boolean;
        static getMeasureFunctions(): string[];
        static getAggregateMeasureFunctions(): string[];
        static getCommonMeasureFunctions(): string[];
        static calculate(functionn: string, values: List<object>): any;
        private static iso2Cache;
        static getMapIdents(key: string): string[];
        static getIso2ConvertedValues(name: string): string[];
        static iso2(name: string, mapId: string, lang: string): string;
        static iso2Object(value: any, mapId: string, lang: string): any;
        static iso2ToName(alpha2: string, mapId: string, lang: string): string;
        static iso2ToNameObject(value: any, mapId: string, lang: string): any;
        static iso3(name: string, mapId: string, lang: string): string;
        static iso3Object(value: any, mapId: string, lang: string): any;
        static iso3ToName(alpha3: string, mapId: string, lang: string): string;
        static iso3ToNameObject(value: any, mapId: string, lang: string): any;
        static normalizeName(alpha3: string, mapId: string, lang: string): string;
        static normalizeNameObject(value: any, mapId: string, lang: string): any;
        private static toProperCaseCache;
        private static toLowerCaseCache;
        private static toUpperCaseCache;
        private static toDataNameCache;
        static format(format: string, value: any): string;
        static formatObject(format: string, value: any): any;
        static insert(str: string, startIndex: number, subStr: string): string;
        static insertObject(value: any, startIndex: number, subStr: string): any;
        static isDataEqual(dataSource: IStiAppDataSource, dataColumnName: string, searchColumnName: string): boolean;
        static left(str: string, length?: number): string;
        static leftObject(value: any, length?: number): any;
        static length2(str: string): number;
        static lengthObject(value: any): any;
        static remove(str: string, startIndex: number, count: number): string;
        static removeObject(value: any, startIndex: number, count: number): any;
        static replace(str: string, oldValue: string, newValue: string): string;
        static replaceObject(value: any, oldValue: string, newValue: string): any;
        static right(str: string, length?: number): string;
        static rightObject(value: any, length?: number): any;
        static toDataName(name: string): string;
        static toDataNameWithoutRelation(name: string, dataSources: List<IStiAppDataSource>): string;
        static toExpression(name: string): string;
        static toExpression2(sourceName: string, columnName: string): string;
        static toLowerCase(str: string): string;
        static toLowerCaseObject(value: any): any;
        static toProperCase(str: string): string;
        static toProperCaseObject(value: any): any;
        static toString(value: any): string;
        static toStringObject(value: any): any;
        static toUpperCase(str: string): string;
        static toUpperCaseObject(value: any): any;
        static trim(str: string): string;
        static trimObject(value: any): any;
        static trimStart(str: string): string;
        static trimStartObject(value: any): any;
        static trimEnd(str: string): string;
        static trimEndObject(value: any): any;
        static substring(str: string, startIndex: number, length?: number): string;
        static substringObject(value: any, startIndex: number, length?: number): any;
        static getSystemVariable(variable: StiSystemVariableObject, line: number): any;
        static existsCustomFunction(funcName: string): boolean;
        static getCustomFunctions(funcName: string): List<IStiAppFunction>;
        static getCustomFunction(funcName: string, argumentTypes: Type[]): IStiAppFunction;
        static invokeCustomFunction(funcName: string, argumentss: any[]): any;
        static skipNulls(values: List<any>): List<any>;
        static optionalSkipNulls(values: List<object>): List<object>;
        private static arabics;
        private static romans;
        private static subs;
        private static abc;
        private static abcRu;
        static toRoman(value: number): string;
        static toABC(value: number): string;
        static toABCNumeric(value: number): string;
        static toABCRu(value: number): string;
        static toArabic(value: string | number, useEasternDigits: boolean): string;
    }
}
export namespace Stimulsoft.Data.Functions {
    import Enum = Stimulsoft.System.Enum;
    enum StiQuarter {
        Q1 = 1,
        Q2 = 2,
        Q3 = 3,
        Q4 = 4
    }
    class StiMonth extends Enum {
        static January: StiMonth;
        static February: StiMonth;
        static March: StiMonth;
        static April: StiMonth;
        static May: StiMonth;
        static June: StiMonth;
        static July: StiMonth;
        static August: StiMonth;
        static September: StiMonth;
        static October: StiMonth;
        static November: StiMonth;
        static December: StiMonth;
        static 1: StiMonth;
        static 2: StiMonth;
        static 3: StiMonth;
        static 4: StiMonth;
        static 5: StiMonth;
        static 6: StiMonth;
        static 7: StiMonth;
        static 8: StiMonth;
        static 9: StiMonth;
        static 10: StiMonth;
        static 11: StiMonth;
        static 12: StiMonth;
    }
    class StiDayOfWeek extends Enum {
        static Sunday: StiDayOfWeek;
        static Monday: StiDayOfWeek;
        static Tuesday: StiDayOfWeek;
        static Wednesday: StiDayOfWeek;
        static Thursday: StiDayOfWeek;
        static Friday: StiDayOfWeek;
        static Saturday: StiDayOfWeek;
        static 0: StiDayOfWeek;
        static 1: StiDayOfWeek;
        static 2: StiDayOfWeek;
        static 3: StiDayOfWeek;
        static 4: StiDayOfWeek;
        static 5: StiDayOfWeek;
        static 6: StiDayOfWeek;
    }
    class StiSystemVariableObject {
        static Line: StiSystemVariableObject;
        static LineABC: StiSystemVariableObject;
        static LineRoman: StiSystemVariableObject;
        private value;
        constructor(value: string);
    }
}
export namespace Stimulsoft.Data.Parsers {
    import FunctionArgs = Stimulsoft.Data.Expressions.NCalc.FunctionArgs;
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    abstract class StiDataParser {
        protected runFunction(funcName: string, args: FunctionArgs): any;
        protected getVariableValue(name: string): any;
        protected isVariable(name: string): boolean;
        protected isSystemVariable(name: string): any;
        protected getSystemVariableValue(name: string): any;
        private static getObjectFromArg;
        private static evaluateArgs;
        private static getObjectFromArg0;
        private static getObjectFromArg1;
        private static getObjectFromArg2;
        private static getDataColumnFromArg0;
        protected getDataColumnIndex(columnName: string): number;
        private dataEqual;
        protected getDimensionIndex(dimension: IStiDimensionMeter): number;
        dictionary: IStiAppDictionary;
        table: DataTable;
        meters: List<IStiMeter>;
        isGrandTotal: boolean;
        private nameToIndex;
        private nameToValue;
        private nameToVariable;
        constructor(dictionary: IStiAppDictionary, table: DataTable, meters: List<IStiMeter>);
    }
}
export namespace Stimulsoft.Data.Parsers {
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import Grouping = Stimulsoft.System.Collections.Grouping;
    class StiMeasureDataParser extends StiDataParser {
        calculate(): List<any[]>;
        calculateMeter(meter: IStiMeter, keys?: any[], rows?: List<object[]>): any;
        private calculateDimension;
        private calculateMeasureFunction;
        private calculateMeasureExpression;
        private getMeasureColumn;
        private getExpression;
        private getDataRowValue;
        private grandRows;
        private currentRows;
        private queryToExpression;
        private expressionToPair;
        constructor(dictionary: IStiAppDictionary, table: DataTable, meters: List<IStiMeter>, grandRows: List<Grouping<any[], any[]>>);
    }
}
export namespace Stimulsoft.Data.Parsers {
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiDimensionDataParser extends StiDataParser {
        calculate(row: any[], meters: List<IStiMeter>): any[];
        private static normalizeDates;
        private static getMeter;
        private static normalizeDate;
        private calculateDimension;
        private getDimensionGroupColumn;
        private calculateDimensionExpression;
        private calculateDimensionGroup;
        private normalizeEnum;
        private getExpression;
        protected dimensions: List<IStiDimensionMeter>;
        private currentRow;
        private queryToExpression;
        private expressionToColumn;
        constructor(dictionary: IStiAppDictionary, table: DataTable, meters: List<IStiMeter>);
    }
}
export namespace Stimulsoft.Data.Engine {
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    class StiDataCreator {
        static create(dict: IStiAppDictionary, meters: List<IStiMeter>): StiDataTable;
        private static convert;
        private static getData;
    }
}
export namespace Stimulsoft.Data.Engine {
    import IStiAppDataColumn = Stimulsoft.Base.IStiAppDataColumn;
    class StiDataExpressionHelper {
        static getDataColumnFromExpression(query: IStiQueryObject, expression: string): IStiAppDataColumn;
        static isDateDataColumnInExpression(query: IStiQueryObject, expression: string): boolean;
        static isNumericDataColumnInExpression(query: IStiQueryObject, expression: string): boolean;
    }
}
export namespace Stimulsoft.Data.Engine {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    class StiDataFilterComparer implements IComparer<any> {
        convertStrings: boolean;
        compare(x: any, y: any): number;
        constructor(convertStrings?: boolean);
    }
}
export namespace Stimulsoft.Data.Engine {
    class StiDataFilterHelper {
        static convertStringToCondition(condition: string): StiDataFilterCondition;
        static convertConditionToString(condition: StiDataFilterCondition): string;
    }
}
export namespace Stimulsoft.Data.Engine {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import List = Stimulsoft.System.Collections.List;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDataFilterRule extends StiDataRule implements IStiJsonReportObject {
        meta(): StiMeta[];
        static loadFromJson(json: StiJson): StiDataFilterRule;
        static loadFromXml(xmlNode: XmlNode): StiDataFilterRule;
        toString(): string;
        getUniqueCode(): number;
        toList(): List<StiDataFilterRule>;
        getStringRepresentation(): string;
        private getValue;
        key: string;
        elementKey: string;
        path: string;
        path2: string;
        condition: StiDataFilterCondition;
        operation: StiDataFilterOperation;
        value: string;
        value2: string;
        isEnabled: boolean;
        isExpression: boolean;
        constructor(key?: string, path?: string, condition?: StiDataFilterCondition, value?: string, value2?: string, isEnabled?: boolean, isExpression?: boolean, path2?: string, operation?: StiDataFilterOperation);
    }
}
export namespace Stimulsoft.Data.Exceptions {
    class StiTypeNotRecognizedException extends StiDataException {
        constructor(type: any);
    }
}
export namespace Stimulsoft.Data.Engine {
    import IStiApp = Stimulsoft.Base.IStiApp;
    import IStiReport = Stimulsoft.Base.IStiReport;
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDataColumn = Stimulsoft.Base.IStiAppDataColumn;
    import Type = Stimulsoft.System.Type;
    import StiDataFilerRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    class StiDataFilterRuleHelper {
        private static currentCulture;
        static toList(...rules: StiDataFilterRule[]): List<StiDataFilterRule>;
        static validate(rules: List<StiDataFilerRule>, columnKeys: List<string>): List<StiDataFilterRule>;
        static getDataTableFilterQuery(rules: List<StiDataFilterRule>, columns: List<IStiAppDataColumn>, report: IStiReport): string;
        static getTableFiltersGroupsType(rules: List<StiDataFilterRule>): StiTableFiltersGroupsType;
        static getDataTableFilterQuery2(rules: List<StiDataFilterRule>, columnNames: List<string>, columnTypes: List<Type>, report: IStiReport): string;
        private static getFullPath;
        private static getFilterGroupQuery;
        private static parseExpression;
        private static getColumnIndex3;
        private static getCleanedPath;
        private static getColumnName;
        private static getColumnType;
        private static getValue;
        private static getColumnIndex;
        private static getCondition;
        private static getQueryValue;
        private static getFilterOperation;
        static getFilterRulesHash(app: IStiApp, rules: List<StiDataFilterRule>): number;
        private static getFilterRulesHash2;
        private static getFilterRuleHash3;
    }
}
export namespace Stimulsoft.Data.Engine {
    import IStiReport = Stimulsoft.Base.IStiReport;
    import List = Stimulsoft.System.Collections.List;
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiDataFiltrator {
        private static lockObject;
        private static meterCache;
        private static netCache;
        static filter(inTable: DataTable, filters: List<StiDataFilterRule>, report: IStiReport, hash: number): DataTable;
        static filter2(inTable: StiDataTable, filters: List<StiDataFilterRule>, report: IStiReport, hash: number): StiDataTable;
        private static filterMapIdents;
        private static simplify;
        static cleanCache(appKey: string): void;
        private static getCacheKey;
        private static getCacheKey2;
        private static getFromCache;
        private static getFromCache2;
        private static addToCache;
        private static addToCache2;
    }
}
export namespace Stimulsoft.Data.Engine {
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiDataGrouper {
        static group(dictionary: IStiAppDictionary, joinedTable: DataTable, meters: List<IStiMeter>): StiDataTable;
    }
}
export namespace Stimulsoft.Data.Engine {
    class StiDataIndicatorValue {
        private static cache;
        static getFromCache(key: string): number;
        static existsInCache(key: string): boolean;
        static addToCache(key: string, value: number): void;
        static cleanCache(): void;
    }
}
export namespace Stimulsoft.Data.Engine {
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import IStiApp = Stimulsoft.Base.IStiApp;
    class StiDataJoiner {
        private static cache;
        static joinEngine: StiDataJoinEngine;
        static join(tables: List<DataTable>, links: List<StiDataLink>, meters: List<IStiMeter>, app: IStiApp): DataTable;
        private static copyColumns;
        private static mergeInSequence;
        private static findLink;
        private static getCacheKey;
        private static getFromCache;
        private static addToCache;
        static cleanCache(appKey: string): void;
    }
}
export namespace Stimulsoft.Data.Engine {
    import StiDataJoinType = Stimulsoft.Base.StiDataJoinType;
    import List = Stimulsoft.System.Collections.List;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiDataLink implements IStiJsonReportObject {
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        parentTable: string;
        childTable: string;
        parentColumns: List<string>;
        childColumns: List<string>;
        get parentKeys(): List<string>;
        get childKeys(): List<string>;
        key: string;
        active: boolean;
        joinType: StiDataJoinType;
        static loadFromJson(json: StiJson): StiDataLink;
        static loadFromXml(xmlNode: XmlNode): StiDataLink;
        toString(): string;
        private nullStr;
        private nullStr2;
        constructor(parentTable?: string, childTable?: string, parentColumns?: List<string>, childColumns?: List<string>, active?: boolean, joinType?: StiDataJoinType, key?: string);
    }
}
export namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    class StiDataLinkHelper {
        static getLinks(dictionary: IStiAppDictionary): List<StiDataLink>;
    }
}
export namespace Stimulsoft.Data.Engine {
    import IStiApp = Stimulsoft.Base.IStiApp;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import List = Stimulsoft.System.Collections.List;
    class StiDataPicker {
        private static lockObject;
        private static cache;
        static fetchAsync(query: IStiQueryObject, group: string, option?: StiDataRequestOption, filterNames?: List<string>, links?: List<StiDataLink>): Promise<List<DataTable>>;
        private static getRelationLevel;
        static retrieveUsedDataSources(query: IStiQueryObject, group: string, filterNames: List<string>): List<IStiAppDataSource>;
        static fetch2(app: IStiApp, dataSourceName: string, option?: StiDataRequestOption): DataTable;
        static fetch2Async(app: IStiApp, dataSourceName: string, option?: StiDataRequestOption): Promise<DataTable>;
        static fetch3(app: IStiApp, dataSource: IStiAppDataSource, option?: StiDataRequestOption): DataTable;
        static fetch3Async(app: IStiApp, dataSource: IStiAppDataSource, option?: StiDataRequestOption): Promise<DataTable>;
        static isAllBICached(query: IStiQueryObject, group: string, option?: StiDataRequestOption): boolean;
        static getDataTable(app: IStiApp, dataSource: IStiAppDataSource, option?: StiDataRequestOption): DataTable;
        static getDataTableAsync(app: IStiApp, dataSource: IStiAppDataSource, option?: StiDataRequestOption): Promise<DataTable>;
        static getDataTable2(option: StiDataRequestOption, dataSource: IStiAppDataSource): DataTable;
        static getDataTable2Async(option: StiDataRequestOption, dataSource: IStiAppDataSource): Promise<DataTable>;
        static processCalculatedColumns(dataTable: DataTable, dataSource: IStiAppDataSource): DataTable;
        static processCalculatedColumnsAsync(dataTable: DataTable, dataSource: IStiAppDataSource): Promise<DataTable>;
        static addTableNameToColumnNames(table: DataTable, dataSource: IStiAppDataSource): void;
        static getFromCache(dataSource: IStiAppDataSource): DataTable;
        static existsInCache(dataSource: IStiAppDataSource): boolean;
        static addToCache(dataSource: IStiAppDataSource, dataTable: {
            ref: DataTable;
        }): void;
        private static getCacheKey;
        static cleanCache(appKey: string): void;
    }
}
export namespace Stimulsoft.Data.Engine {
    import StiDataJoinType = Stimulsoft.Base.StiDataJoinType;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import DataRow = Stimulsoft.System.Data.DataRow;
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiDataRowJoiner {
        join(type: StiDataJoinType, link: StiDataLink, meters: List<IStiMeter>): List<DataRow>;
        private leftJoinRows;
        private innerJoinRows;
        private leftJoinRowsV1V4;
        private leftJoinRowsV5;
        private leftJoinRowsV2V3;
        private rightJoinRows;
        private calculateIndexes;
        private isNumericType;
        private crossJoinRows;
        private fullJoinRows;
        private getHashCode;
        private getHashCode2;
        private splitRows;
        private getFieldIndex;
        private getFieldIndex2;
        private getFieldIndexes;
        private getItem;
        private resultTable;
        private table1;
        private table2;
        private resultColumnIndexes;
        private column1Indexes;
        private column2Indexes;
        constructor(resultTable: DataTable, table1: DataTable, table2: DataTable);
    }
}
export namespace Stimulsoft.Data.Engine {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDataSortRule extends StiDataRule implements IStiJsonReportObject {
        meta(): StiMeta[];
        static loadFromJson(json: StiJson): StiDataSortRule;
        static loadFromXml(xmlNode: XmlNode): StiDataSortRule;
        toString(): string;
        getUniqueCode(): number;
        key: string;
        direction: StiDataSortDirection;
        constructor(key?: string, direction?: StiDataSortDirection);
    }
}
export namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDataColumn = Stimulsoft.Base.IStiAppDataColumn;
    class StiDataSortRuleHelper {
        static toList(...rules: StiDataSortRule[]): List<StiDataSortRule>;
        static validate(rules: List<StiDataSortRule>, columnKeys: List<string>): List<StiDataSortRule>;
        static getDataTableSortQuery(rules: List<StiDataSortRule>, columns: List<IStiAppDataColumn>): string;
        static getDataTableSortQuery2(rules: List<StiDataSortRule>, columnKeys: List<string>, columnNames: List<string>): string;
        static getSortDirection(rules: List<StiDataSortRule>, columnKey: string): StiDataSortDirection;
        static setSortDirection(rules: List<StiDataSortRule>, columnKeys: List<string>, columnKey: string, direction: StiDataSortDirection): List<StiDataSortRule>;
    }
}
export namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    class StiDataSortVariation {
        static ident: string;
        static isVariationSort(sort: List<StiDataSortRule>): boolean;
        static createVariationSort(direction: StiDataSortDirection): List<StiDataSortRule>;
    }
}
export namespace Stimulsoft.Data.Engine {
    import IStiApp = Stimulsoft.Base.IStiApp;
    import List = Stimulsoft.System.Collections.List;
    class StiDataSorter {
        private static lockObject;
        private static hashCache;
        static sort(inTable: StiDataTable, sorts: List<StiDataSortRule>, app: IStiApp, hash: number, option?: StiDataRequestOption): StiDataTable;
        private static getFixedDataSortRules;
        static cleanCache(appKey: string): void;
        private static getCacheKey;
        private static getFromCache;
        private static addToCache;
    }
}
export namespace Stimulsoft.Data.Engine {
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import List = Stimulsoft.System.Collections.List;
    class StiDataSourceChainFinder {
        static find(dataSources: List<IStiAppDataSource>): List<IStiAppDataSource>;
        private static find3;
        static findInParent(dataSource1: IStiAppDataSource, dataSource2: IStiAppDataSource, dataPath?: List<string>): List<IStiAppDataSource>;
        static findInChild(dataSource1: IStiAppDataSource, dataSource2: IStiAppDataSource, dataPath?: List<string>): List<IStiAppDataSource>;
        static findInBoth(dataSource1: IStiAppDataSource, dataSource2: IStiAppDataSource): List<IStiAppDataSource>;
        private static getDataPoint;
        private static getActiveRelations;
    }
}
export namespace Stimulsoft.Data.Engine {
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    class StiDataSourcePicker {
        static fetch(query: IStiQueryObject, group: string, dataNames: List<string>, dataSources: List<IStiAppDataSource>): List<IStiAppDataSource>;
        static fetchSiblingDataSources(dataSources: List<IStiAppDataSource>, dictionary: IStiAppDictionary): List<IStiAppDataSource>;
    }
}
export namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiDataTable {
        static nullTable: StiDataTable;
        meters: List<IStiMeter>;
        rows: List<any[]>;
        get isNull(): boolean;
        get isEmpty(): boolean;
        constructor(meters?: List<IStiMeter>, rows?: List<any[]>);
    }
}
export namespace Stimulsoft.Data.Engine {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiDataTopN implements IStiJsonReportObject, ICloneable {
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        static createFromJsonObject(jObject: StiJson): StiDataTopN;
        static createFromXml(xmlNode: XmlNode): StiDataTopN;
        clone(): StiDataTopN;
        mode: StiDataTopNMode;
        count: number;
        showOthers: boolean;
        othersText: string;
        measureField: string;
        toString(): string;
        getUniqueCode(): number;
        constructor(mode?: StiDataTopNMode, count?: number, showOthers?: boolean, othersText?: string, measureField?: string);
    }
}
export namespace Stimulsoft.Data.Engine {
    class StiErrorStack {
        private static keyToError;
        static setOk(key: string): void;
        static setError(key: string, error: string): void;
        static getError(key: string): string;
        static isFail(key: string): boolean;
    }
}
export namespace Stimulsoft.Data.Exceptions {
    class StiBingException extends StiDataException {
        constructor(message: string);
    }
}
export namespace Stimulsoft.Data.Exceptions {
    class StiColumnNotFoundException extends StiDataException {
        private _name;
        get name(): string;
        constructor(name: string);
    }
}
export namespace Stimulsoft.Data.Exceptions {
    class StiSystemVariableNotRecognizedException extends StiDataException {
        constructor(name: string);
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class ANTLRStringStream implements ICharStream {
        implements(): any[];
        protected data: string[];
        protected n: number;
        protected p: number;
        protected markDepth: number;
        protected markers: CharStreamState[];
        protected lastMarker: number;
        name: string;
        constructor(input?: string, data?: string[], numberOfActualCharsInArray?: number, sourceName?: string);
        get index(): number;
        line: number;
        charPositionInLine: number;
        reset(): void;
        consume(): void;
        la(i: number): number;
        lt(i: number): number;
        get count(): number;
        mark(): number;
        rewind(m?: number): void;
        release(marker: number): void;
        seek(index: number): void;
        substring(start: number, length: number): string;
        get sourceName(): string;
        toString(): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class ANTLRReaderStream extends ANTLRStringStream {
        readBufferSize: number;
        initialBufferSize: number;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class ANTLRInputStream extends ANTLRReaderStream {
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class ParserRuleReturnScope<TToken> implements IRuleReturnScope<TToken> {
        implements(): any[];
        start: TToken;
        stop: TToken;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class AstParserRuleReturnScope<TTree, TToken> extends ParserRuleReturnScope<TToken> implements IAstRuleReturnScope<TTree>, IAstRuleReturnScope<any> {
        implements(): any[];
        tree: TTree;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class BaseRecognizer {
        memoRuleFailed: number;
        memoRuleUnknown: number;
        static initialFollowStackSize: number;
        defaultTokenChannel: number;
        hidden: number;
        nextTokenRuleName: string;
        state: RecognizerSharedState;
        constructor(state?: RecognizerSharedState);
        setState(value: RecognizerSharedState): void;
        protected initDFAs(): void;
        reset(): void;
        match(input: IIntStream, ttype: number, follow: BitSet): any;
        matchAny(input: IIntStream): void;
        mismatchIsUnwantedToken(input: IIntStream, ttype: number): boolean;
        mismatchIsMissingToken(input: IIntStream, follow: BitSet): boolean;
        reportError(e: RecognitionException): void;
        displayRecognitionError(tokenNames: string[], e: RecognitionException): void;
        getErrorMessage(e: RecognitionException, tokenNames: string[]): string;
        get numberOfSyntaxErrors(): number;
        getErrorHeader(e: RecognitionException): string;
        getTokenErrorDisplay(t: IToken): string;
        emitErrorMessage(msg: string): void;
        recover(input: IIntStream, re: RecognitionException): void;
        beginResync(): void;
        endResync(): void;
        protected computeErrorRecoverySet(): BitSet;
        protected computeContextSensitiveRuleFOLLOW(): BitSet;
        protected combineFollows(exact: boolean): BitSet;
        protected recoverFromMismatchedToken(input: IIntStream, ttype: number, follow: BitSet): any;
        recoverFromMismatchedSet(input: IIntStream, e: RecognitionException, follow: BitSet): any;
        protected getCurrentInputSymbol(input: IIntStream): any;
        protected getMissingSymbol(input: IIntStream, e: RecognitionException, expectedTokenType: number, follow: BitSet): any;
        consumeUntil(input: IIntStream, tokenType: number): void;
        consumeUntil2(input: IIntStream, set: BitSet): void;
        protected pushFollow(fset: BitSet): void;
        protected popFollow(): void;
        get backtrackingLevel(): number;
        set backtrackingLevel(value: number);
        get failed(): boolean;
        tokenNames: string[];
        grammarFileName: string;
        get sourceName(): string;
        toStrings(tokens: IToken[]): string[];
        getRuleMemoization(ruleIndex: number, ruleStartIndex: number): number;
        alreadyParsedRule(input: IIntStream, ruleIndex: number): boolean;
        memoize(input: IIntStream, ruleIndex: number, ruleStartIndex: number): void;
        getRuleMemoizationCacheSize(): number;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class BitSet {
        private static BITS;
        private static LOG_BITS;
        private static MOD_MASK;
        _bits: number[];
        static create(bits: number[]): BitSet;
        constructor(nbits?: number);
        static of(el: number): BitSet;
        static of2(a: number, b: number): BitSet;
        static of3(a: number, b: number, c: number): BitSet;
        static of4(a: number, b?: number, c?: number, d?: number): BitSet;
        or(a: BitSet): BitSet;
        add(el: number): void;
        growToInclude(bit: number): void;
        orInPlace(a: BitSet): void;
        private setSize;
        private static bitMask;
        clone(): any;
        size(): number;
        getHashCode(): number;
        equals(other: any): boolean;
        member(el: number): boolean;
        remove(el: number): void;
        isNil(): boolean;
        private static numWordsToHold;
        numBits(): number;
        lengthInLongWords(): number;
        toArray(): number[];
        private static wordNumber;
        toString(tokenNames?: string[]): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class BufferedTokenStream implements ITokenStream, ITokenStreamInformation {
        implements(): any[];
        private _tokenSource;
        _tokens: IToken[];
        private _lastMarker;
        protected _p: number;
        constructor(tokenSource?: ITokenSource);
        get tokenSource(): ITokenSource;
        set tokenSource(value: ITokenSource);
        get index(): number;
        range: number;
        get count(): number;
        get sourceName(): string;
        get lastToken(): IToken;
        get lastRealToken(): IToken;
        maxLookBehind: number;
        mark(): number;
        release(marker: number): void;
        rewind(marker?: number): void;
        reset(): void;
        seek(index: number): void;
        consume(): void;
        protected sync(i: number): void;
        protected fetch(n: number): void;
        get(i: number): IToken;
        la(i: number): number;
        protected lb(k: number): IToken;
        lt(k: number): IToken;
        protected setup(): void;
        getTokens(start: number, stop: number, types: BitSet): IToken[];
        toString(): string;
        toString2(start: number, stop: number): string;
        fill(): void;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class CharStreamConstants {
        static endOfFile: number;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class CharStreamState {
        p: number;
        line: number;
        charPositionInLine: number;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class ClassicToken implements IToken {
        implements(): any[];
        index: number;
        constructor(type: number, text: string, channel: number);
        text: string;
        type: number;
        line: number;
        charPositionInLine: number;
        channel: number;
        startIndex: number;
        stopIndex: number;
        get tokenIndex(): number;
        set tokenIndex(value: number);
        inputStream: ICharStream;
        toString(): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class CommonToken implements IToken {
        implements(): any[];
        input: ICharStream;
        _text: string;
        index: number;
        start: number;
        stop: number;
        constructor();
        static create1(type: number): CommonToken;
        static create2(input: ICharStream, type: number, channel: number, start: number, stop: number): CommonToken;
        static create3(type: number, text: string): CommonToken;
        static create4(oldToken: IToken): CommonToken;
        get text(): string;
        set text(value: string);
        type: number;
        line: number;
        charPositionInLine: number;
        channel: number;
        get startIndex(): number;
        set startIndex(value: number);
        get stopIndex(): number;
        set stopIndex(value: number);
        get tokenIndex(): number;
        set tokenIndex(value: number);
        get inputStream(): ICharStream;
        set inputStream(value: ICharStream);
        toString(): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class CommonTokenStream extends BufferedTokenStream {
        channel: number;
        constructor(tokenSource?: ITokenSource, channel?: number);
        consume(): void;
        lb(k: number): IToken;
        lt(k: number): IToken;
        skipOffTokenChannels(i: number): number;
        protected skipOffTokenChannelsReverse(i: number): number;
        reset(): void;
        setup(): void;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class DFA {
        protected eot: number[];
        protected eof: number[];
        protected min: string[];
        protected max: string[];
        protected accept: number[];
        protected special: number[];
        protected transition: number[][];
        protected decisionNumber: number;
        protected recognizer: BaseRecognizer;
        debug: boolean;
        constructor();
        description: string;
        predict(input: IIntStream): number;
        private dfaDebugMessage;
        private dfaDebugInvalidSymbol;
        protected noViableAlt(s: number, input: IIntStream): void;
        error(nvae: NoViableAltException): void;
        static specialStateTransitionDefault(dfa: DFA, s: number, input: IIntStream): number;
        static unpackEncodedString(encodedString: string): number[];
        static unpackEncodedStringToUnsignedChars(encodedString: string): string[];
        protected debugRecognitionException(ex: RecognitionException): void;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class BaseTree implements ITree {
        implements(): any[];
        constructor(node?: ITree);
        children: ITree[];
        get childCount(): number;
        parent: ITree;
        childIndex: number;
        get isNil(): boolean;
        protected _tokenStartIndex: number;
        get tokenStartIndex(): number;
        set tokenStartIndex(value: number);
        protected _tokenStopIndex: number;
        get tokenStopIndex(): number;
        set tokenStopIndex(value: number);
        protected _type: number;
        get type(): number;
        set type(value: number);
        protected _text: string;
        get text(): string;
        set text(value: string);
        line: number;
        charPositionInLine: number;
        getChild(i: number): ITree;
        getFirstChildWithType(type: number): ITree;
        addChild(t: ITree): void;
        addChildren(kids: ITree[]): void;
        setChild(i: number, t: ITree): void;
        insertChild(i: number, t: ITree): void;
        deleteChild(i: number): any;
        replaceChildren(startChildIndex: number, stopChildIndex: number, t: any): void;
        createChildrenList(): ITree[];
        freshenParentAndChildIndexes(offset?: number): void;
        freshenParentAndChildIndexesDeeply(offset?: number): void;
        sanityCheckParentAndChildIndexes(parent?: ITree, i?: number): void;
        hasAncestor(ttype: number): boolean;
        getAncestor(ttype: number): ITree;
        getAncestors(): ITree[];
        toStringTree(): string;
        toString(): string;
        dupNode(): ITree;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class CommonTree extends BaseTree {
        private _token;
        protected startIndex: number;
        protected stopIndex: number;
        parent: CommonTree;
        childIndex: number;
        constructor(node?: CommonTree | IToken);
        get isNil(): boolean;
        get text(): string;
        token: IToken;
        get tokenStartIndex(): number;
        set tokenStartIndex(value: number);
        get tokenStopIndex(): number;
        set tokenStopIndex(value: number);
        get type(): number;
        dupNode(): ITree;
        setUnknownTokenBoundaries(): void;
        toString(): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    let ITreeNodeStream: System.Interface<ITreeNodeStream>;
    interface ITreeNodeStream extends IIntStream {
        get(i: number): ITreeNodeStream;
        lt(k: number): any;
        treeSource: any;
        tokenStream: ITokenStream;
        treeAdaptor: ITreeAdaptor;
        uniqueNavigationNodes: boolean;
        toString(start: any, stop: any): string;
        replaceChildren(parent: any, startChildIndex: number, stopChildIndex: number, t: any): any;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    import ITreeNodeStream = Stimulsoft.Data.Expressions.Antlr.Runtime.Tree.ITreeNodeStream;
    class RecognitionException extends Exception {
        private _k;
        private _c;
        constructor(message?: string, input?: IIntStream, k?: number, innerException?: Exception);
        get unexpectedType(): number;
        approximateLineInfo: boolean;
        input: IIntStream;
        get lookahead(): number;
        token: IToken;
        node: any;
        get character(): string;
        set character(value: string);
        index: number;
        line: number;
        charPositionInLine: number;
        protected extractInformationFromTreeNodeStream(input: ITreeNodeStream): void;
        protected extractInformationFromTreeNodeStream2(input: ITreeNodeStream, k: number): void;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    class EarlyExitException extends RecognitionException {
        constructor(message?: string, decisionNumber?: number, input?: IIntStream, innerException?: Exception);
        decisionNumber: number;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    class FailedPredicateException extends RecognitionException {
        constructor(message?: string, input?: IIntStream, ruleName?: string, predicateText?: string, innerException?: Exception);
        ruleName: string;
        predicateText: string;
        toString(): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Attribute = Stimulsoft.System.Attribute;
    class GrammarRuleAttribute extends Attribute {
        constructor(name: string);
        name: string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    let IAstRuleReturnScope: IAstRuleReturnScope<any>;
    interface IAstRuleReturnScope<TAstLabel> {
        tree: TAstLabel;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    let ICharStream: System.Interface<ICharStream>;
    interface ICharStream extends IIntStream {
        substring(start: number, length: number): string;
        lt(i: number): number;
        line: number;
        charPositionInLine: number;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    let IIntStream: System.Interface<IIntStream>;
    interface IIntStream {
        consume(): any;
        la(i: number): number;
        mark(): number;
        index: number;
        rewind(marker?: number): any;
        release(marker: number): any;
        seek(index: number): any;
        count: number;
        sourceName: string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    let IRuleReturnScope: IRuleReturnScope<any>;
    interface IRuleReturnScope<TLabel> {
        start: TLabel;
        stop: TLabel;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    let ITemplateRuleReturnScope: ITemplateRuleReturnScope<any>;
    interface ITemplateRuleReturnScope<TTemplate> {
        template: TTemplate;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    let IToken: System.Interface<IToken>;
    interface IToken {
        text: string;
        type: number;
        line: number;
        charPositionInLine: number;
        channel: number;
        startIndex: number;
        stopIndex: number;
        tokenIndex: number;
        inputStream: ICharStream;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    let ITokenSource: System.Interface<ITokenSource>;
    interface ITokenSource {
        nextToken(): IToken;
        sourceName: string;
        tokenNames: string[];
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    let ITokenStream: System.Interface<ITokenStream>;
    interface ITokenStream extends IIntStream {
        lt(k: number): IToken;
        range: number;
        get(i: number): IToken;
        tokenSource: ITokenSource;
        toString(start: number, stop: number): string;
        toString(start: IToken, stop: IToken): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    let ITokenStreamInformation: System.Interface<ITokenStreamInformation>;
    interface ITokenStreamInformation {
        lastToken: IToken;
        lastRealToken: IToken;
        maxLookBehind: number;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    class LegacyCommonTokenStream implements ITokenStream {
        implements(): any[];
        _tokenSource: ITokenSource;
        protected tokens: IToken[];
        protected channelOverrideMap: Dictionary<number, number>;
        protected discardSet: number[];
        protected channel: number;
        protected discardOffChannelTokens: boolean;
        protected lastMarker: number;
        protected p: number;
        constructor(tokenSource?: ITokenSource, channel?: number);
        get index(): number;
        range: number;
        setTokenSource(tokenSource: ITokenSource): void;
        fillBuffer(): void;
        consume(): void;
        protected skipOffTokenChannels(i: number): number;
        protected skipOffTokenChannelsReverse(i: number): number;
        setTokenTypeChannel(ttype: number, channel: number): void;
        discardTokenType(ttype: number): void;
        setDiscardOffChannelTokens(discardOffChannelTokens: boolean): void;
        getTokens(): IToken[];
        getTokens2(start: number, stop: number, types?: BitSet): IToken[];
        lt(k: number): IToken;
        protected lb(k: number): IToken;
        get(i: number): IToken;
        la(i: number): number;
        mark(): number;
        release(marker: number): void;
        get count(): number;
        rewind(marker?: number): void;
        reset(): void;
        seek(index: number): void;
        tokenSource: ITokenSource;
        get sourceName(): string;
        toString(): string;
        toString2(start: number, stop: number): string;
        toString3(start: IToken, stop: IToken): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class Lexer extends BaseRecognizer implements ITokenSource {
        implements(): any[];
        protected input: ICharStream;
        constructor(input?: ICharStream, state?: RecognizerSharedState);
        get text(): string;
        set text(value: string);
        get line(): number;
        set line(value: number);
        get charPositionInLine(): number;
        set charPositionInLine(value: number);
        reset(): void;
        nextToken(): IToken;
        getEndOfFileToken(): IToken;
        skip(): void;
        mTokens(): void;
        get charStream(): ICharStream;
        set charStream(value: ICharStream);
        get sourceName(): string;
        emit2(token: IToken): void;
        emit(): IToken;
        match3(s: string): void;
        matchAny(): void;
        match2(c: number): void;
        matchRange(a: number, b: number): void;
        get charIndex(): number;
        reportError(e: RecognitionException): void;
        getErrorMessage(e: RecognitionException, tokenNames: string[]): string;
        getCharErrorDisplay(c: number): string;
        recover2(re: RecognitionException): void;
        protected parseNextToken(): void;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    class MismatchedSetException extends RecognitionException {
        constructor(message?: string, expecting?: BitSet, input?: IIntStream, innerException?: Exception);
        expecting: BitSet;
        toString(): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    class MismatchedNotSetException extends MismatchedSetException {
        constructor(message?: string, expecting?: BitSet, input?: IIntStream, innerException?: Exception);
        toString(): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    class MismatchedRangeException extends RecognitionException {
        constructor(message?: string, a?: number, b?: number, input?: IIntStream, innerException?: Exception);
        a: number;
        b: number;
        toString(): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    class MismatchedTokenException extends RecognitionException {
        constructor(message?: string, expecting?: number, input?: IIntStream, tokenNames?: string[], innerException?: Exception);
        expecting: number;
        tokenNames: string[];
        toString(): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    import ITreeNodeStream = Stimulsoft.Data.Expressions.Antlr.Runtime.Tree.ITreeNodeStream;
    class MismatchedTreeNodeException extends RecognitionException {
        constructor(message?: string, expecting?: number, input?: ITreeNodeStream, innerException?: Exception);
        expecting: number;
        toString(): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    class MissingTokenException extends MismatchedTokenException {
        private _inserted;
        constructor(message?: string, expecting?: number, input?: IIntStream, inserted?: any, tokenNames?: string[], innerException?: Exception);
        get missingType(): number;
        toString(): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    class NoViableAltException extends RecognitionException {
        constructor(message: string, grammarDecisionDescription: string, decisionNumber: number, stateNumber: number, input: IIntStream, k?: number, innerException?: Exception);
        decisionNumber: number;
        grammarDecisionDescription: string;
        stateNumber: number;
        toString(): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class Parser extends BaseRecognizer {
        input: ITokenStream;
        constructor(input: ITokenStream, state?: RecognizerSharedState);
        reset(): void;
        protected getCurrentInputSymbol(input: IIntStream): any;
        protected getMissingSymbol(input: IIntStream, e: RecognitionException, expectedTokenType: number, follow: BitSet): any;
        get tokenStream(): ITokenStream;
        set tokenStream(value: ITokenStream);
        get sourceName(): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    class RecognizerSharedState {
        following: BitSet[];
        _fsp: number;
        errorRecovery: boolean;
        lastErrorIndex: number;
        failed: boolean;
        syntaxErrors: number;
        backtracking: number;
        ruleMemo: Array<Dictionary<number, number>>;
        token: IToken;
        tokenStartCharIndex: number;
        tokenStartLine: number;
        tokenStartCharPositionInLine: number;
        channel: number;
        type: number;
        text: string;
        constructor();
        static recognizerSharedState(state: RecognizerSharedState): RecognizerSharedState;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class TemplateParserRuleReturnScope<TTemplate, TToken> extends ParserRuleReturnScope<TToken> implements ITemplateRuleReturnScope<TTemplate>, ITemplateRuleReturnScope<any> {
        implements(): any[];
        template: TTemplate;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class TokenChannels {
        static default: number;
        static hidden: number;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Type = Stimulsoft.System.Type;
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    class TokenRewriteStream extends CommonTokenStream {
        DEFAULT_PROGRAM_NAME: string;
        PROGRAM_INIT_SIZE: number;
        MIN_TOKEN_INDEX: number;
        protected programs: Dictionary<string, RewriteOperation[]>;
        protected lastRewriteTokenIndexes: Dictionary<string, number>;
        protected init(): void;
        constructor(tokenSource?: ITokenSource, channel?: number);
        rollback(programName: string, instructionIndex: number): void;
        deleteProgram(programName?: string): void;
        unsertAfter(programName: string, index: number, text: string): void;
        insertBefore(programName: string, index: number, text: string): void;
        replace(programName: string, from: number, to: number, text: any): void;
        replace2(programName: string, from: IToken, to: IToken, text: any): void;
        delete(programName: string, from: IToken, to: IToken): void;
        protected getLastRewriteTokenIndex(programName: string): number;
        protected setLastRewriteTokenIndex(programName: string, i: number): void;
        protected getProgram(name: string): RewriteOperation[];
        private initializeProgram;
        toOriginalString(): string;
        toOriginalString2(start: number, end: number): string;
        toString(): string;
        toString3(programName: string, start: number, end: number): string;
        protected reduceToSingleOperationPerIndex(rewrites: RewriteOperation[]): Dictionary<number, RewriteOperation>;
        protected catOpText(a: string, b: string): string;
        protected getKindOfOps(rewrites: RewriteOperation[], kind: Type, before?: number): RewriteOperation[];
        toDebugString(start?: number, end?: number): string;
    }
    class RewriteOperation {
        instructionIndex: number;
        index: number;
        text: string;
        protected stream: TokenRewriteStream;
        constructor(stream: TokenRewriteStream, index: number, text?: string);
        execute(buf: string): number;
        toString(): string;
    }
    class InsertBeforeOp extends RewriteOperation {
        constructor(stream: TokenRewriteStream, index: number, text: string);
        execute(buf: string): number;
    }
    class ReplaceOp extends RewriteOperation {
        lastIndex: number;
        constructor(stream: TokenRewriteStream, from: number, to: number, text: string);
        execute(buf: string): number;
        toString(): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class TokenTypes {
        static endOfFile: number;
        static invalid: number;
        static endOfRule: number;
        static down: number;
        static up: number;
        static min: number;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class Tokens {
        static skip: IToken;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Misc {
    class ListStack<T> extends Array<T> {
        peek(depth?: number): T;
        tryPeek(ref: {
            item: T;
        }): boolean;
        tryPeek2(depth: number, ref: {
            item: T;
        }): boolean;
        pop(): T;
        tryPop(ref: {
            item: T;
        }): boolean;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Misc {
    class FastQueue<T> {
        _data: T[];
        _p: number;
        get count(): number;
        range: number;
        get(i: number): T;
        dequeue(): T;
        enqueue(o: T): void;
        peek(): T;
        clear(): void;
        toString(): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Misc {
    class LookaheadStream<T> extends FastQueue<T> {
        private _currentElementIndex;
        private _previousElement;
        _eof: T;
        _lastMarker: number;
        _markDepth: number;
        get endOfFile(): T;
        set endOfFile(value: T);
        get previousElement(): T;
        reset(): void;
        nextElement(): T;
        isEndOfFile(o: T): boolean;
        dequeue(): T;
        consume(): void;
        syncAhead(need: number): void;
        fill(n: number): void;
        get count(): number;
        lt(k: number): T;
        get index(): number;
        mark(): number;
        release(marker: number): void;
        rewind2(marker: number): void;
        rewind(): void;
        seek(index: number): void;
        lb(k: number): T;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import LookaheadStream = Stimulsoft.Data.Expressions.Antlr.Runtime.Misc.LookaheadStream;
    class UnbufferedTokenStream extends LookaheadStream<IToken> implements ITokenStream, ITokenStreamInformation {
        implements(): any[];
        tokenSource: ITokenSource;
        protected tokenIndex: number;
        protected channel: number;
        private _realTokens;
        constructor(tokenSource: ITokenSource);
        get sourceName(): string;
        get lastToken(): IToken;
        get lastRealToken(): IToken;
        maxLookBehind: number;
        mark(): number;
        release(marker: number): void;
        clear(): void;
        consume(): void;
        extElement(): IToken;
        isEndOfFile(o: IToken): boolean;
        get(i: number): IToken;
        la(i: number): number;
        toString2(start: IToken | number, stop: IToken | number): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    class UnwantedTokenException extends MismatchedTokenException {
        constructor(message?: string, expecting?: number, input?: IIntStream, tokenNames?: string[], innerException?: Exception);
        get unexpectedToken(): IToken;
        toString(): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Misc {
    class Action {
    }
    class Func<TResult> extends Function {
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Misc {
    class RegexOptionsHelper {
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import ITree = Stimulsoft.Data.Expressions.Antlr.Runtime.Tree.ITree;
    class AntlrRuntime_BaseTreeDebugView {
        private _tree;
        constructor(tree: BaseTree);
        get children(): ITree[];
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class TreeRuleReturnScope<TTree> implements IRuleReturnScope<TTree> {
        implements(): any[];
        private _start;
        start: TTree;
        stop: TTree;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class AstTreeRuleReturnScope<TOutputTree, TInputTree> extends TreeRuleReturnScope<TInputTree> implements IAstRuleReturnScope<TOutputTree>, IAstRuleReturnScope<any> {
        implements(): any[];
        tree: TOutputTree;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    class BaseTreeAdaptor implements ITreeAdaptor {
        implements(): any[];
        protected treeToUniqueIDMap: Dictionary<any, number>;
        protected uniqueNodeID: number;
        nil(): any;
        errorNode(input: ITokenStream, start: IToken, stop: IToken, e: RecognitionException): any;
        isNil(tree: any): boolean;
        dupNode(type?: number, treeNode?: any, text?: string): any;
        dupTree(t: any, parent?: any): any;
        addChild(t: any, child: any): void;
        becomeRoot(newRoot: any, oldRoot: any): any;
        rulePostProcessing(root: any): any;
        becomeRoot2(newRoot: IToken, oldRoot: any): any;
        create5(tokenType: number, fromToken: IToken): any;
        create2(tokenType: number, fromToken: IToken, text: string): any;
        create3(fromToken: IToken, text: string): any;
        create4(tokenType: number, text: string): any;
        getType(t: number): number;
        setType(t: any, type: number): void;
        getText(t: any): string;
        setText(t: any, text: string): void;
        getChild(t: any, i: number): any;
        setChild(t: any, i: number, child: any): void;
        deleteChild(t: any, i: number): any;
        getChildCount(t: any): number;
        getUniqueID(node: any): number;
        createToken2(tokenType: number, text: string): IToken;
        createToken(fromToken: IToken): IToken;
        create(payload: IToken): any;
        dupNode2(treeNode: any): any;
        getToken(t: any): IToken;
        setTokenBoundaries(t: any, startToken: IToken, stopToken: IToken): void;
        getTokenStartIndex(t: any): number;
        getTokenStopIndex(t: any): number;
        getParent(t: any): any;
        setParent(t: any, parent: any): any;
        getChildIndex(t: any): number;
        setChildIndex(t: any, index: number): void;
        replaceChildren(parent: any, startChildIndex: number, stopChildIndex: number, t: any): void;
        getTree(t: any): ITree;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Stack = Stimulsoft.System.Collections.Stack;
    class BufferedTreeNodeStream implements ITreeNodeStream, ITokenStreamInformation {
        implements(): any[];
        DEFAULT_INITIAL_BUFFER_SIZE: number;
        INITIAL_CALL_STACK_SIZE: number;
        down: any;
        up: any;
        eof: any;
        nodes: any[];
        protected root: any;
        protected tokens: ITokenStream;
        adaptor: ITreeAdaptor;
        uniqueNavigationNodes: boolean;
        protected p: number;
        protected lastMarker: number;
        protected calls: Stack<number>;
        constructor(adaptor?: ITreeAdaptor, tree?: any, initialBufferSize?: number);
        get count(): number;
        get treeSource(): any;
        get sourceName(): string;
        get tokenStream(): ITokenStream;
        set tokenStream(value: ITokenStream);
        get treeAdaptor(): ITreeAdaptor;
        set treeAdaptor(value: ITreeAdaptor);
        get lastToken(): IToken;
        get lastRealToken(): IToken;
        maxLookBehind: number;
        fillBuffer(): void;
        fillBuffer2(t: any): void;
        protected getNodeIndex(node: any): number;
        protected addNavigationNode(ttype: number): void;
        get(i: number): any;
        lt(k: number): any;
        getCurrentSymbol(): any;
        protected lb(k: number): any;
        consume(): void;
        la(i: number): number;
        mark(): number;
        release(marker: number): void;
        get index(): number;
        rewind2(marker: number): void;
        rewind(): void;
        seek(index: number): void;
        push(index: number): void;
        pop(): number;
        reset(): void;
        iterator(): any[];
        replaceChildren(parent: any, startChildIndex: number, stopChildIndex: number, t: any): void;
        toTokenTypeString(): string;
        toTokenString(start: number, stop: number): string;
        toString(start: any, stop: any): string;
    }
    class StreamIterator extends Array<any> {
        _outer: BufferedTreeNodeStream;
        _index: number;
        constructor(outer: BufferedTreeNodeStream);
        get current(): any;
        dispose(): void;
        moveNext(): boolean;
        reset(): void;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class CommonErrorNode extends CommonTree {
        input: IIntStream;
        start: IToken;
        stop: IToken;
        trappedException: RecognitionException;
        constructor(input: ITokenStream, start: IToken, stop: IToken, e: RecognitionException);
        get isNil(): boolean;
        get text(): string;
        get type(): number;
        toString(): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class CommonTreeAdaptor extends BaseTreeAdaptor {
        create(payload: IToken): CommonTree;
        createToken2(tokenType: number, text: string): IToken;
        createToken(fromToken: IToken): IToken;
        getToken(t: any): IToken;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import LookaheadStream = Stimulsoft.Data.Expressions.Antlr.Runtime.Misc.LookaheadStream;
    class CommonTreeNodeStream extends LookaheadStream<any> implements ITreeNodeStream, IPositionTrackingStream {
        implements(): any[];
        DEFAULT_INITIAL_BUFFER_SIZE: number;
        INITIAL_CALL_STACK_SIZE: number;
        private _root;
        protected tokens: ITokenStream;
        private _adaptor;
        private _it;
        private _calls;
        private _hasNilRoot;
        private _level;
        private _previousLocationElement;
        constructor(adaptor: ITreeAdaptor, tree: any);
        get sourceName(): string;
        get tokenStream(): ITokenStream;
        set tokenStream(value: ITokenStream);
        get treeAdaptor(): ITreeAdaptor;
        set treeAdaptor(value: ITreeAdaptor);
        get treeSource(): any;
        uniqueNavigationNodes: boolean;
        reset(): void;
        nextElement(): any;
        dequeue(): any;
        isEndOfFile(o: any): boolean;
        la(i: number): number;
        push(index: number): void;
        pop(): number;
        getKnownPositionElement(allowApproximateLocation: boolean): any;
        hasPositionInformation(node: any): boolean;
        replaceChildren(parent: any, startChildIndex: number, stopChildIndex: number, t: any): void;
        toString1(start: any, stop: any): string;
        toTokenTypeString(): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    class DotTreeGenerator {
        headerLines: string[];
        footer: string;
        nodeFormat: string;
        edgeFormat: string;
        nodeToNumberMap: Dictionary<any, number>;
        nodeNumber: number;
        toDot2(tree: any, adaptor: ITreeAdaptor): string;
        toDot(tree: ITree): string;
        protected defineNodes(tree: any, adaptor: ITreeAdaptor): string[];
        defineEdges(tree: any, adaptor: ITreeAdaptor): string[];
        protected getNodeText(adaptor: ITreeAdaptor, t: any): string;
        protected getNodeNumber(t: any): number;
        protected fixString(text: string): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    let IPositionTrackingStream: System.Interface<IPositionTrackingStream>;
    interface IPositionTrackingStream {
        getKnownPositionElement(allowApproximateLocation: boolean): any;
        hasPositionInformation(element: any): boolean;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    let ITree: System.Interface<ITree>;
    interface ITree {
        getChild(i: number): ITree;
        childCount: number;
        parent: ITree;
        hasAncestor(ttype: number): boolean;
        getAncestor(ttype: number): ITree;
        getAncestors(): ITree[];
        childIndex: number;
        freshenParentAndChildIndexes(): any;
        addChild(t: ITree): any;
        setChild(i: number, t: ITree): any;
        deleteChild(i: number): any;
        replaceChildren(startChildIndex: number, stopChildIndex: number, t: any): any;
        isNil: boolean;
        tokenStartIndex: number;
        tokenStopIndex: number;
        dupNode(): ITree;
        type: number;
        text: string;
        line: number;
        charPositionInLine: number;
        toStringTree(): string;
        toString(): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    let ITreeAdaptor: System.Interface<ITreeAdaptor>;
    interface ITreeAdaptor {
        create(payload: IToken): any;
        create2(tokenType: number, fromToken: IToken, text: string): any;
        create3(fromToken: IToken, text: string): any;
        create4(tokenType: number, text: string): any;
        dupNode2(treeNode: any): any;
        dupNode(type?: number, treeNode?: any, text?: string): any;
        dupTree(tree: any): any;
        nil(): any;
        errorNode(input: ITokenStream, start: IToken, stop: IToken, e: RecognitionException): any;
        isNil(tree: any): boolean;
        addChild(t: any, child: any): any;
        becomeRoot(newRoot: IToken | any, oldRoot: any): any;
        rulePostProcessing(root: any): any;
        getUniqueID(node: any): number;
        getType(t: any): number;
        setType(t: any, type: number): any;
        getText(t: any): string;
        setText(t: any, text: string): any;
        getToken(t: any): IToken;
        setTokenBoundaries(t: any, startToken: IToken, stopToken: IToken): any;
        getTokenStartIndex(t: any): number;
        getTokenStopIndex(t: any): number;
        getChild(t: any, i: number): any;
        setChild(t: any, i: number, child: any): any;
        deleteChild(t: any, i: number): any;
        getChildCount(t: any): number;
        getParent(t: any): any;
        setParent(t: any, parent: any): any;
        getChildIndex(t: any): number;
        setChildIndex(t: any, index: number): any;
        replaceChildren(parent: any, startChildIndex: number, stopChildIndex: number, t: any): any;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    let ITreeVisitorAction: System.Interface<ITreeVisitorAction>;
    interface ITreeVisitorAction {
        pre(t: any): any;
        post(t: any): any;
    }
    class TreeVisitorAction implements ITreeVisitorAction {
        implements(): any[];
        pre(t: any): any;
        post(t: any): any;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class ParseTree extends BaseTree {
        payload: any;
        hiddenTokens: IToken[];
        constructor(label: any);
        get text(): string;
        _tokenStartIndex: number;
        _tokenStopIndex: number;
        _type: number;
        dupNode(): ITree;
        toString(): string;
        toStringWithHiddenTokens(): string;
        toInputString(): string;
        protected toStringLeaves(buf: string): void;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Exception = Stimulsoft.System.Exception;
    class RewriteCardinalityException extends Exception {
        private _elementDescription;
        constructor(message?: string, elementDescription?: string, innerException?: Exception);
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Exception = Stimulsoft.System.Exception;
    class RewriteEarlyExitException extends RewriteCardinalityException {
        constructor(message?: string, elementDescription?: string, innerException?: Exception);
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Exception = Stimulsoft.System.Exception;
    class RewriteEmptyStreamException extends RewriteCardinalityException {
        constructor(message?: string, elementDescription?: string, innerException?: Exception);
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class RewriteRuleElementStream {
        protected cursor: number;
        protected singleElement: any;
        protected elements: any[];
        protected dirty: boolean;
        protected elementDescription: string;
        protected adaptor: ITreeAdaptor;
        constructor(adaptor: ITreeAdaptor, elementDescription: string, oneElement?: any, elements?: any[]);
        reset(): void;
        add(el: any): void;
        nextTree(): any;
        nextCore(): any;
        protected dup(el: any): any;
        protected toTree(el: any): any;
        get hasNext(): boolean;
        get count(): number;
        get description(): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class RewriteRuleNodeStream extends RewriteRuleElementStream {
        constructor(adaptor: ITreeAdaptor, elementDescription: string, oneElement?: any, elements?: any[]);
        nextNode(): any;
        protected toTree(el: any): any;
        protected dup(el: any): any;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class RewriteRuleSubtreeStream extends RewriteRuleElementStream {
        constructor(adaptor: ITreeAdaptor, elementDescription: string, oneElement?: any, elements?: any[]);
        nextNode(): any;
        protected dup(el: any): any;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class RewriteRuleTokenStream extends RewriteRuleElementStream {
        constructor(adaptor: ITreeAdaptor, elementDescription: string, oneElement?: any, elements?: any[]);
        nextNode(): any;
        nextToken(): IToken;
        toTree(el: any): any;
        protected dup(el: any): any;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class TemplateTreeRuleReturnScope<TTemplate, TTree> extends TreeRuleReturnScope<TTree> implements ITemplateRuleReturnScope<TTemplate>, ITemplateRuleReturnScope<any> {
        implements(): any[];
        template: TTemplate;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class TreeParser extends BaseRecognizer {
        DOWN: number;
        UP: number;
        static dotdot: string;
        static doubleEtc: string;
        protected input: ITreeNodeStream;
        constructor(input: ITreeNodeStream, state?: RecognizerSharedState);
        reset(): void;
        setTreeNodeStream(input: ITreeNodeStream): void;
        getTreeNodeStream(): ITreeNodeStream;
        get sourceName(): string;
        protected getCurrentInputSymbol(input: IIntStream): any;
        protected getMissingSymbol(input: IIntStream, e: RecognitionException, expectedTokenType: number, follow: BitSet): any;
        matchAny(ignore: IIntStream): void;
        protected recoverFromMismatchedToken(input: IIntStream, ttype: number, follow: BitSet): any;
        getErrorHeader(e: RecognitionException): string;
        getErrorMessage(e: RecognitionException, tokenNames: string[]): string;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Action = Stimulsoft.Data.Expressions.Antlr.Runtime.Misc.Action;
    class TreeFilter extends TreeParser {
        protected originalTokenStream: ITokenStream;
        protected originalAdaptor: ITreeAdaptor;
        constructor(input: ITreeNodeStream, state?: RecognizerSharedState);
        applyOnce(t: any, whichRule: Action): void;
        downup(t: any): void;
        protected topdown(): void;
        protected bottomup(): void;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import List = Stimulsoft.System.Collections.List;
    import Queue = Stimulsoft.System.Collections.Queue;
    class TreeIterator extends List<any> {
        protected adaptor: ITreeAdaptor;
        protected root: any;
        protected tree: any;
        protected firstTime: boolean;
        private reachedEof;
        up: any;
        down: any;
        eof: any;
        protected nodes: Queue<any>;
        constructor(adaptor: ITreeAdaptor, tree: any);
        current: any;
        dispose(): void;
        moveNext(): boolean;
        reset(): void;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class TreePatternLexer {
        static begin: number;
        static end: number;
        static id: number;
        static arg: number;
        static percent: number;
        static colon: number;
        static dot: number;
        protected pattern: string;
        protected p: number;
        protected c: number;
        protected n: number;
        sval: string;
        error: boolean;
        constructor(pattern: string);
        nextToken(): number;
        consume(): void;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class TreePatternParser {
        protected tokenizer: TreePatternLexer;
        protected ttype: number;
        protected wizard: TreeWizard;
        protected adaptor: ITreeAdaptor;
        constructor(tokenizer: TreePatternLexer, wizard: TreeWizard, adaptor: ITreeAdaptor);
        pattern(): any;
        parseTree(): any;
        parseNode(): any;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class TreeRewriter extends TreeParser {
        protected showTransformations: boolean;
        protected originalTokenStream: ITokenStream;
        protected originalAdaptor: ITreeAdaptor;
        constructor(input: ITreeNodeStream, state: RecognizerSharedState);
        applyOnce(t: any, whichRule: Misc.Func<IAstRuleReturnScope<any>>): any;
        applyRepeatedly(t: any, whichRule: Misc.Func<IAstRuleReturnScope<any>>): any;
        downup(t: any, showTransformations?: boolean): any;
        protected topdown(): IAstRuleReturnScope<any>;
        protected bottomup(): IAstRuleReturnScope<any>;
        protected reportTransformation(oldTree: any, newTree: any): void;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class TreeVisitor {
        protected adaptor: ITreeAdaptor;
        constructor(adaptor?: ITreeAdaptor);
        visit(t: any, action: ITreeVisitorAction): any;
    }
}
export namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    import Action = Stimulsoft.Data.Expressions.Antlr.Runtime.Misc.Action;
    class TreeWizard {
        protected adaptor: ITreeAdaptor;
        protected tokenNameToTypeMap: Dictionary<string, number>;
        computeTokenTypes(tokenNames: string[]): Dictionary<string, number>;
        getTokenType(tokenName: string): number;
        index(t: any): Dictionary<number, any[]>;
        protected indexCore(t: any, m: Dictionary<number, any[]>): void;
        find(t: any, ttype: number): any[];
        find2(t: any, pattern: string): any[];
        findFirst(t: any, ttype: number): any;
        findFirst2(t: any, pattern: string): any;
        visit(t: any, ttype: number, visitor: IContextVisitor): void;
        visit2(t: any, ttype: number, action: Action): void;
        protected visitCore(t: any, parent: any, childIndex: number, ttype: number, visitor: IContextVisitor): void;
        visit3(t: any, pattern: string, visitor: IContextVisitor): void;
        parse(t: any, pattern: string, labels: Dictionary<string, any>): boolean;
        parse2(t: any, pattern: string): boolean;
        parseCore(t1: any, tpattern: TreePattern, labels: Dictionary<string, any>): boolean;
        create(pattern: string): any;
        static equals(t1: any, t2: any, adaptor: ITreeAdaptor): boolean;
        protected static equalsCore(t1: any, t2: any, adaptor: ITreeAdaptor): boolean;
    }
    let IContextVisitor: System.Interface<IContextVisitor>;
    interface IContextVisitor {
        visit(t: any, parent: any, childIndex: number, labels: Dictionary<string, any>): any;
    }
    class Visitor implements IContextVisitor {
        implements(): any[];
        visit2(t: any, parent: any, childIndex: number, labels: Dictionary<string, any>): void;
        visit(t: any): void;
    }
    class ActionVisitor extends Visitor {
        _action: Action;
        constructor(action: Action);
        visit(t: any): void;
    }
    class TreePattern extends CommonTree {
        label: string;
        hasTextArg: boolean;
        constructor(payload: IToken);
        toString(): string;
    }
    class WildcardTreePattern extends TreePattern {
        constructor(payload: IToken);
    }
    class TreePatternTreeAdaptor extends CommonTreeAdaptor {
        create(payload: IToken): any;
    }
    class FindTreeWizardVisitor extends Visitor {
        _nodes: any[];
        constructor(nodes: any[]);
        visit(t: any): void;
    }
    class FindTreeWizardContextVisitor implements IContextVisitor {
        implements(): any[];
        _outer: TreeWizard;
        _tpattern: TreePattern;
        _subtrees: any[];
        constructor(outer: TreeWizard, tpattern: TreePattern, subtrees: any[]);
        visit(t: any, parent: any, childIndex: number, labels: Dictionary<string, any>): void;
    }
    class VisitTreeWizardContextVisitor implements IContextVisitor {
        implements(): any[];
        _outer: TreeWizard;
        _visitor: IContextVisitor;
        _labels: Dictionary<string, any>;
        _tpattern: TreePattern;
        constructor(outer: TreeWizard, visitor: IContextVisitor, labels: Dictionary<string, any>, tpattern: TreePattern);
        visit(t: any, parent: any, childIndex: number, unusedlabels: Dictionary<string, any>): void;
    }
}
export namespace Stimulsoft.Data.Expressions.NCalc {
    import Exception = Stimulsoft.System.Exception;
    class EvaluationException extends Exception {
        constructor(message: string, innerException?: Exception);
    }
}
export namespace Stimulsoft.Data.Expressions.NCalc {
    enum EvaluateOptions {
        None = 1,
        IgnoreCase = 2,
        NoCache = 4,
        IterateParameters = 8,
        RoundAwayFromZero = 16
    }
}
export namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class LogicalExpression {
        static bs: string;
        private static extractString;
        and(operand: LogicalExpression | any): BinaryExpression;
        dividedBy(operand: LogicalExpression | any): BinaryExpression;
        equalsTo(operand: LogicalExpression | any): BinaryExpression;
        greaterThan(operand: LogicalExpression | any): BinaryExpression;
        greaterOrEqualThan(operand: LogicalExpression | any): BinaryExpression;
        lesserThan(operand: LogicalExpression | any): BinaryExpression;
        lesserOrEqualThan(operand: LogicalExpression | any): BinaryExpression;
        minus(operand: LogicalExpression | any): BinaryExpression;
        modulo(operand: LogicalExpression | any): BinaryExpression;
        notEqual(operand: LogicalExpression | any): BinaryExpression;
        or(operand: LogicalExpression | any): BinaryExpression;
        plus(operand: LogicalExpression | any): BinaryExpression;
        mult(operand: LogicalExpression | any): BinaryExpression;
        bitwiseOr(operand: LogicalExpression | any): BinaryExpression;
        bitwiseAnd(operand: LogicalExpression | any): BinaryExpression;
        bitwiseXOr(operand: LogicalExpression | any): BinaryExpression;
        leftShift(operand: LogicalExpression | any): BinaryExpression;
        rightShift(operand: LogicalExpression | any): BinaryExpression;
        toString(): string;
        accept(visitor: LogicalExpressionVisitor): void;
    }
}
export namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    import LogicalExpressionVisitor = Stimulsoft.Data.Expressions.NCalc.Domain.LogicalExpressionVisitor;
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    class EvaluationVisitor extends LogicalExpressionVisitor {
        private _options;
        private get ignoreCase();
        constructor(options: EvaluateOptions);
        result: any;
        evaluate(expression: LogicalExpression): any;
        visit1(expression: LogicalExpression): void;
        private static commonTypes;
        private static getMostPreciseType;
        compareUsingMostPreciseType(a: any, b: any): any;
        visit2(expression: TernaryExpression): void;
        private static isReal;
        visit3(expression: BinaryExpression): void;
        visit4(expression: UnaryExpression): void;
        visit5(expression: ValueExpression): void;
        visit6(functionn: Functionn): void;
        private checkCase;
        evaluateFunction: (name: string, args: FunctionArgs) => void;
        private onEvaluateFunction;
        visit7(parameter: Identifier): void;
        evaluateParameter: (...args: any[]) => void;
        private onEvaluateParameter;
        parameters: Dictionary<string, any>;
    }
}
export namespace Stimulsoft.Data.Expressions.NCalc {
    import BaseRecognizer = Stimulsoft.Data.Expressions.Antlr.Runtime.BaseRecognizer;
    import DFA = Stimulsoft.Data.Expressions.Antlr.Runtime.DFA;
    import NoViableAltException = Stimulsoft.Data.Expressions.Antlr.Runtime.NoViableAltException;
    import RecognizerSharedState = Stimulsoft.Data.Expressions.Antlr.Runtime.RecognizerSharedState;
    import Lexer = Stimulsoft.Data.Expressions.Antlr.Runtime.Lexer;
    import ICharStream = Stimulsoft.Data.Expressions.Antlr.Runtime.ICharStream;
    export class NCalcLexer extends Lexer {
        EOF: number;
        DATETIME: number;
        DIGIT: number;
        E: number;
        EscapeSequence: number;
        FALSE: number;
        FLOAT: number;
        HexDigit: number;
        ID: number;
        INTEGER: number;
        LETTER: number;
        NAME: number;
        STRING: number;
        TRUE: number;
        UnicodeEscape: number;
        WS: number;
        T__19: number;
        T__20: number;
        T__21: number;
        T__22: number;
        T__23: number;
        T__24: number;
        T__25: number;
        T__26: number;
        T__27: number;
        T__28: number;
        T__29: number;
        T__30: number;
        T__31: number;
        T__32: number;
        T__33: number;
        T__34: number;
        T__35: number;
        T__36: number;
        T__37: number;
        T__38: number;
        T__39: number;
        T__40: number;
        T__41: number;
        T__42: number;
        T__43: number;
        T__44: number;
        T__45: number;
        T__46: number;
        T__47: number;
        T__48: number;
        constructor(input?: ICharStream, state?: RecognizerSharedState);
        mT__19(): void;
        mT__20(): void;
        mT__21(): void;
        mT__22(): void;
        mT__23(): void;
        mT__24(): void;
        mT__25(): void;
        mT__26(): void;
        mT__27(): void;
        mT__28(): void;
        mT__29(): void;
        mT__30(): void;
        mT__31(): void;
        mT__32(): void;
        mT__33(): void;
        enterRule_T__34(): void;
        leaveRule_T__34(): void;
        mT__34(): void;
        mT__35(): void;
        mT__36(): void;
        mT__37(): void;
        mT__38(): void;
        mT__39(): void;
        mT__40(): void;
        mT__41(): void;
        mT__42(): void;
        mT__43(): void;
        mT__44(): void;
        enterRule_T__45(): void;
        leaveRule_T__45(): void;
        mT__45(): void;
        mT__46(): void;
        mT__47(): void;
        mT__48(): void;
        mTRUE(): void;
        mFALSE(): void;
        mID(): void;
        mINTEGER(): void;
        mFLOAT(): void;
        mSTRING(): void;
        mDATETIME(): void;
        mNAME(): void;
        mE(): void;
        mLETTER(): void;
        mDIGIT(): void;
        mEscapeSequence(): void;
        mHexDigit(): void;
        mUnicodeEscape(): void;
        mWS(): void;
        mTokens(): void;
        dfa7: DFA7;
        dfa14: DFA14;
        initDFAs(): void;
    }
    class DFA7 extends DFA {
        static DFA7_eotS: string;
        static DFA7_eofS: string;
        static DFA7_minS: string;
        static DFA7_maxS: string;
        static DFA7_acceptS: string;
        static DFA7_specialS: string;
        private static DFA7_transitionS;
        private static DFA7_eot;
        private static DFA7_eof;
        private static DFA7_min;
        private static DFA7_max;
        private static DFA7_accept;
        private static DFA7_special;
        private static DFA7_transition;
        static initialize(): void;
        constructor(recognizer: BaseRecognizer);
        description: string;
        error(nvae: NoViableAltException): void;
    }
    class DFA14 extends DFA {
        static DFA14_eotS: string;
        static DFA14_eofS: string;
        static DFA14_minS: string;
        static DFA14_maxS: string;
        static DFA14_acceptS: string;
        static DFA14_specialS: string;
        private static DFA14_transitionS;
        private static DFA14_eot;
        private static DFA14_eof;
        private static DFA14_min;
        private static DFA14_max;
        private static DFA14_accept;
        private static DFA14_special;
        private static DFA14_transition;
        static initialize(): void;
        constructor(recognizer: BaseRecognizer);
        description: string;
        error(nvae: NoViableAltException): void;
    }
    export {};
}
export namespace Stimulsoft.Data.Expressions.NCalc {
    import LogicalExpression = Stimulsoft.Data.Expressions.NCalc.Domain.LogicalExpression;
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    class ReaderWriterLock {
        releaseReaderLock(): void;
        releaseWriterLock(): void;
        acquireReaderLock(t: number): void;
        acquireWriterLock(t: number): void;
    }
    class WeakReference {
        constructor(t: LogicalExpression);
        isAlive: boolean;
    }
    class Expression {
        static Timeout: {
            Infinite: number;
        };
        options: EvaluateOptions;
        protected originalExpression: string;
        constructor();
        static create1(expression: string, options?: EvaluateOptions): Expression;
        static create2(expression: LogicalExpression, options?: EvaluateOptions): Expression;
        private static _cacheEnabled;
        private static _compiledExpressions;
        private static rwl;
        static get cacheEnabled(): boolean;
        static set cacheEnabled(value: boolean);
        private static cleanCache;
        static compile(expression: string, nocache: boolean): LogicalExpression;
        hasErrors(): boolean;
        error: string;
        parsedExpression: LogicalExpression;
        protected parameterEnumerators: Dictionary<string, any[]>;
        protected parametersBackup: Dictionary<string, any>;
        evaluate(): any;
        evaluateFunction: any;
        evaluateParameter: any;
        parameters: Dictionary<string, any>;
    }
}
export namespace Stimulsoft.Data.Expressions.NCalc {
    import EventArgs = Stimulsoft.System.EventArgs;
    class FunctionArgs extends EventArgs {
        private _result;
        get result(): any;
        set result(value: any);
        hasResult: boolean;
        parameters: Expression[];
        evaluateParameters(): any[];
    }
}
export namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class Functionn extends LogicalExpression {
        constructor(identifier: Identifier, expressions: LogicalExpression[]);
        identifier: Identifier;
        expressions: LogicalExpression[];
        accept(visitor: LogicalExpressionVisitor): void;
    }
}
export namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class UnaryExpression extends LogicalExpression {
        constructor(type: UnaryExpressionType, expression: LogicalExpression);
        expression: LogicalExpression;
        type: UnaryExpressionType;
        accept(visitor: LogicalExpressionVisitor): void;
    }
    enum UnaryExpressionType {
        Not = 0,
        Negate = 1,
        BitwiseNot = 2
    }
}
export namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class BinaryExpression extends LogicalExpression {
        constructor(type: BinaryExpressionType, leftExpression: LogicalExpression, rightExpression: LogicalExpression);
        leftExpression: LogicalExpression;
        rightExpression: LogicalExpression;
        type: BinaryExpressionType;
        accept(visitor: LogicalExpressionVisitor): void;
    }
    enum BinaryExpressionType {
        And = 0,
        Or = 1,
        NotEqual = 2,
        LesserOrEqual = 3,
        GreaterOrEqual = 4,
        Lesser = 5,
        Greater = 6,
        Equal = 7,
        Minus = 8,
        Plus = 9,
        Modulo = 10,
        Div = 11,
        Times = 12,
        BitwiseOr = 13,
        BitwiseAnd = 14,
        BitwiseXOr = 15,
        LeftShift = 16,
        RightShift = 17,
        Unknown = 18
    }
}
export namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class TernaryExpression extends LogicalExpression {
        constructor(leftExpression: LogicalExpression, middleExpression: LogicalExpression, rightExpression: LogicalExpression);
        leftExpression: LogicalExpression;
        middleExpression: LogicalExpression;
        rightExpression: LogicalExpression;
        accept(visitor: LogicalExpressionVisitor): void;
    }
}
export namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class ValueExpression extends LogicalExpression {
        constructor(value: any, type?: ValueType);
        value: any;
        type: ValueType;
        accept(visitor: LogicalExpressionVisitor): void;
    }
    enum ValueType {
        Integer = 0,
        String = 1,
        DateTime = 2,
        Float = 3,
        Boolean = 4
    }
}
export namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class Identifier extends LogicalExpression {
        constructor(name: string);
        name: string;
        accept(visitor: LogicalExpressionVisitor): void;
    }
}
export namespace Stimulsoft.Data.Expressions.NCalc {
    import ValueExpression = Stimulsoft.Data.Expressions.NCalc.Domain.ValueExpression;
    import Identifier = Stimulsoft.Data.Expressions.NCalc.Domain.Identifier;
    import RecognitionException = Stimulsoft.Data.Expressions.Antlr.Runtime.RecognitionException;
    import RecognizerSharedState = Stimulsoft.Data.Expressions.Antlr.Runtime.RecognizerSharedState;
    import Parser = Stimulsoft.Data.Expressions.Antlr.Runtime.Parser;
    import ITokenStream = Stimulsoft.Data.Expressions.Antlr.Runtime.ITokenStream;
    import AstParserRuleReturnScope = Stimulsoft.Data.Expressions.Antlr.Runtime.AstParserRuleReturnScope;
    import IToken = Stimulsoft.Data.Expressions.Antlr.Runtime.IToken;
    import LogicalExpression = Stimulsoft.Data.Expressions.NCalc.Domain.LogicalExpression;
    import ITreeAdaptor = Stimulsoft.Data.Expressions.Antlr.Runtime.Tree.ITreeAdaptor;
    export class NCalcParser extends Parser {
        tokenNames: string[];
        EOF: number;
        DATETIME: number;
        DIGIT: number;
        E: number;
        EscapeSequence: number;
        FALSE: number;
        FLOAT: number;
        HexDigit: number;
        ID: number;
        INTEGER: number;
        LETTER: number;
        NAME: number;
        STRING: number;
        TRUE: number;
        UnicodeEscape: number;
        WS: number;
        T__19: number;
        T__20: number;
        T__21: number;
        T__22: number;
        T__23: number;
        T__24: number;
        T__25: number;
        T__26: number;
        T__27: number;
        T__28: number;
        T__29: number;
        T__30: number;
        T__31: number;
        T__32: number;
        T__33: number;
        T__34: number;
        T__35: number;
        T__36: number;
        T__37: number;
        T__38: number;
        T__39: number;
        T__40: number;
        T__41: number;
        T__42: number;
        T__43: number;
        T__44: number;
        T__45: number;
        T__46: number;
        T__47: number;
        T__48: number;
        constructor(input: ITokenStream, state?: RecognizerSharedState);
        createTreeAdaptor(adaptor: {
            ref: ITreeAdaptor;
        }): void;
        adaptor: ITreeAdaptor;
        grammarFileName: string;
        private bs;
        private extractString;
        errors: string[];
        displayRecognitionError(tokenNames: string[], e: RecognitionException): void;
        onCreated(): void;
        enterRule(ruleName: string, ruleIndex: number): void;
        leaveRule(ruleName: string, ruleIndex: number): void;
        traceIn(ruleName: string, ruleIndex: number): void;
        enterRule_ncalcExpression(): void;
        leaveRule_ncalcExpression(): void;
        ncalcExpression(): ncalcExpression_return;
        enterRule_logicalExpression(): void;
        leaveRule_logicalExpression(): void;
        private logicalExpression;
        enterRule_conditionalExpression(): void;
        leaveRule_conditionalExpression(): void;
        private conditionalExpression;
        enterRule_booleanAndExpression(): void;
        leaveRule_booleanAndExpression(): void;
        booleanAndExpression(): booleanAndExpression_return;
        enterRule_bitwiseOrExpression(): void;
        leaveRule_bitwiseOrExpression(): void;
        bitwiseOrExpression(): bitwiseOrExpression_return;
        enterRule_bitwiseXOrExpression(): void;
        leaveRule_bitwiseXOrExpression(): void;
        bitwiseXOrExpression(): bitwiseXOrExpression_return;
        enterRule_bitwiseAndExpression(): void;
        leaveRule_bitwiseAndExpression(): void;
        bitwiseAndExpression(): bitwiseAndExpression_return;
        enterRule_equalityExpression(): void;
        leaveRule_equalityExpression(): void;
        equalityExpression(): equalityExpression_return;
        enterRule_relationalExpression(): void;
        leaveRule_relationalExpression(): void;
        relationalExpression(): relationalExpression_return;
        enterRule_shiftExpression(): void;
        leaveRule_shiftExpression(): void;
        shiftExpression(): shiftExpression_return;
        enterRule_additiveExpression(): void;
        leaveRule_additiveExpression(): void;
        additiveExpression(): additiveExpression_return;
        enterRule_multiplicativeExpression(): void;
        leaveRule_multiplicativeExpression(): void;
        multiplicativeExpression(): multiplicativeExpression_return;
        enterRule_unaryExpression(): void;
        leaveRule_unaryExpression(): void;
        unaryExpression(): unaryExpression_return;
        enterRule_primaryExpression(): void;
        leaveRule_primaryExpression(): void;
        primaryExpression(): primaryExpression_return;
        enterRule_value(): void;
        leaveRule_value(): void;
        value(): value_return;
        enterRule_identifier(): void;
        leaveRule_identifier(): void;
        identifier(): identifier_return;
        enterRule_expressionList(): void;
        leaveRule_expressionList(): void;
        expressionList(): expressionList_return;
        enterRule_arguments(): void;
        leaveRule_arguments(): void;
        arguments(): arguments_return;
    }
    class ncalcExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class booleanAndExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: any): void;
    }
    class bitwiseOrExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class bitwiseXOrExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class bitwiseAndExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class equalityExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class relationalExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class shiftExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class additiveExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class multiplicativeExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class unaryExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class primaryExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class value_return extends AstParserRuleReturnScope<any, IToken> {
        value: ValueExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class identifier_return extends AstParserRuleReturnScope<any, IToken> {
        value: Identifier;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class expressionList_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression[];
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class arguments_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression[];
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    export {};
}
export namespace Stimulsoft.Data.Expressions.NCalc {
    class Numbers {
        private static convertIfString;
        static add(a: any, b: any): any;
        static soustract(a: any, b: any): any;
        static multiply(a: any, b: any): any;
        static divide(a: any, b: any): any;
        static modulo(a: any, b: any): any;
        static max(a: any, b: any): any;
        static min(a: any, b: any): any;
    }
}
export namespace Stimulsoft.Data.Expressions.NCalc {
    import EventArgs = Stimulsoft.System.EventArgs;
    class ParameterArgs extends EventArgs {
        private _result;
        get result(): any;
        set result(value: any);
        hasResult: boolean;
    }
}
export namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class SerializationVisitor extends LogicalExpressionVisitor {
        private _numberFormatInfo;
        constructor();
        result: string;
        visit1(expression: LogicalExpression): void;
        visit2(expression: TernaryExpression): void;
        visit3(expression: BinaryExpression): void;
        visit4(expression: UnaryExpression): void;
        visit5(expression: ValueExpression): void;
        visit6(functionn: Functionn): void;
        visit7(parameter: Identifier): void;
        encapsulateNoValue(expression: LogicalExpression): void;
    }
}
export namespace Stimulsoft.Data.Helpers {
    class StiHumanReadableHelper {
        static getSize(size: number): string;
        static getHumanReadableName(name: string): string;
    }
}
export namespace Stimulsoft.Data.Helpers {
    class StiMoneyNameHelper {
        static isMoneyName(name: string): boolean;
    }
}
export namespace Stimulsoft.Data.Extensions {
    import DataColumn = Stimulsoft.System.Data.DataColumn;
    class DataColumnExt {
        static isNumericType(column: DataColumn): boolean;
        static isDateType(column: DataColumn): boolean;
        static isIntegerType(column: DataColumn): boolean;
        static isMoneyName(column: DataColumn): boolean;
        static getHumanReadableName(column: DataColumn): string;
    }
}
export namespace Stimulsoft.Data.Extensions {
    class DataTimeExt {
    }
}
export namespace Stimulsoft.Data.Extensions {
    class EnumerableRowCollectionExt {
    }
}
export namespace Stimulsoft.Data.Extensions {
}
export namespace Stimulsoft.Data.Helpers {
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiLabelHelper {
        private static cache;
        static getLabel(meter: IStiMeter): string;
    }
}
export namespace Stimulsoft.Data.Extensions {
    import List = Stimulsoft.System.Collections.List;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class ListTableExt {
        static toNetTable(source: List<any[]>, meters: List<IStiMeter>, onlyColumns?: boolean, convertsArray?: boolean): DataTable;
        private static loadDataRow;
        private static findType;
        private static findTypeInRows;
    }
}
export namespace Stimulsoft.Data.Extensions {
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    class StiMeterExt {
        static indexOf(meters: List<IStiMeter>, meter: IStiMeter): number;
        static getDimensions(meters: List<IStiMeter>): List<IStiDimensionMeter>;
    }
}
export namespace Stimulsoft.Data.Extensions {
    class TOuterExt {
    }
}
export namespace Stimulsoft.Data.Functions {
    import DateTime = Stimulsoft.System.DateTime;
    class StiDayOfWeekToStrHelper {
        private static days;
        private static defaultUpperCaseList;
        private static cultureIndexes;
        static dayOfWeek(date: DateTime): string;
        static dayOfWeek2(date: DateTime, localized: boolean): string;
        static dayOfWeek3(dayOfWeek: StiDayOfWeek, culture: string): string;
        static dayOfWeek4(dateTime: DateTime, culture: string, upperCase: boolean): string;
        static dayOfWeek5(str: string): StiDayOfWeek | null;
        static dayOfWeek6(dateTime: DateTime, culture: string): string;
        static addCulture(monthNames: string[], cultureNames: string[], defaultUpperCase: boolean): void;
        static initialize(): void;
    }
}
export namespace Stimulsoft.Data.Functions {
    class StiExtValueConverter {
        static isEligable(value: any, culture: string): boolean;
        static convert(value: any, culture: string): string;
    }
}
export namespace Stimulsoft.Data.Helpers {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import Type = Stimulsoft.System.Type;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiDataTableConverter {
        static toNetTable(dataTable: StiDataTable, types?: Type[]): DataTable;
        private static getDataType;
    }
}
export namespace Stimulsoft.Data.Helpers {
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiUsedDataHelper {
        static getMany(...meters: IStiMeter[]): List<string>;
        static getMany2(meters: List<IStiMeter>): List<string>;
        static getSingle(meter: IStiMeter): List<string>;
        static getSingle2(expression: string): List<string>;
    }
}
export namespace Stimulsoft.Data.Parsers {
    class StiFunctionColumnPair {
        private _function;
        get function(): string;
        set function(value: string);
        private _columnName;
        get columnName(): string;
        set columnName(value: string);
    }
}
export namespace Stimulsoft.Report {
    enum StiParserType {
        ReportParser = 0,
        DataParser = 1
    }
    enum StiNestedFactor {
        High = 0,
        Normal = 1,
        Low = 2
    }
    enum StiOrientation {
        Horizontal = 0,
        Vertical = 1
    }
    enum StiResizeReportOptions {
        ProcessAllPages = 1,
        RebuildReport = 2,
        RescaleContent = 4,
        PageOrientationChanged = 8,
        ShowProgressOnRebuildReport = 16,
        AllowPageMarginsRescaling = 32
    }
    enum StiCalculationMode {
        Compilation = 0,
        Interpretation = 1
    }
    enum StiReportLanguageType {
        CSharp = 0,
        VB = 1,
        JS = 2
    }
    enum StiReportUnitType {
        Centimeters = 0,
        HundredthsOfInch = 1,
        Inches = 2,
        Millimeters = 3
    }
    enum StiGridMode {
        Lines = 0,
        Dots = 1
    }
    enum StiReportPass {
        None = 0,
        First = 1,
        Second = 2
    }
    enum StiNumberOfPass {
        SinglePass = 0,
        DoublePass = 1
    }
    enum StiExportFormat {
        None = 0,
        Pdf = 1,
        Xps = 2,
        HtmlTable = 3,
        HtmlSpan = 4,
        HtmlDiv = 5,
        Rtf = 6,
        RtfTable = 7,
        RtfFrame = 8,
        RtfWinWord = 9,
        RtfTabbedText = 10,
        Text = 11,
        Excel = 14,
        Excel2007 = 14,
        Word = 15,
        Word2007 = 15,
        Xml = 16,
        Csv = 17,
        Dif = 18,
        Sylk = 19,
        Image = 20,
        ImageGif = 21,
        ImageBmp = 22,
        ImagePng = 23,
        ImageTiff = 24,
        ImageJpeg = 25,
        ImagePcx = 26,
        ImageEmf = 27,
        ImageSvg = 28,
        ImageSvgz = 29,
        Mht = 30,
        Dbf = 31,
        Html = 32,
        Ods = 33,
        Odt = 34,
        PowerPoint = 35,
        Ppt2007 = 35,
        Html5 = 36,
        Data = 37,
        Json = 38,
        Document = 1000
    }
    enum StiReportCacheMode {
        Off = 0,
        On = 1,
        Auto = 2
    }
    enum StiReportCacheThreadMode {
        Off = 0,
        On = 1,
        Auto = 2
    }
    enum StiReportResourceType {
        Bitmap = 0,
        Metafile = 1,
        Report = 2
    }
    enum StiRangeType {
        All = 1,
        CurrentPage = 2,
        Pages = 3
    }
    enum StiHtmlType {
        Html = 1,
        Html5 = 2,
        Mht = 3
    }
    enum ImageFormat {
        Bmp = 0,
        Emf = 1,
        Exif = 2,
        Gif = 3,
        Guid = 4,
        Icon = 5,
        Jpeg = 6,
        MemoryBmp = 7,
        Png = 8,
        Tiff = 9,
        Wmf = 10
    }
    enum StiArabicDigitsType {
        Standard = 0,
        Eastern = 1
    }
    enum StiBrushType {
        Solid = 0,
        Glare = 1,
        Gradient0 = 2,
        Gradient90 = 3,
        Gradient180 = 4,
        Gradient270 = 5,
        Gradient45 = 6
    }
    enum StiRenderedWith {
        Unknown = 0,
        Net = 1,
        Wpf = 2,
        Silverlight = 3,
        WinRT = 4,
        Flex = 5,
        Java = 6,
        JS = 7
    }
    enum StiRankOrder {
        Asc = 0,
        Desc = 1
    }
    enum StiXmlType {
        AdoNetXml = 0,
        Xml = 1
    }
    enum StiStyleElements {
        Font = 1,
        Border = 2,
        Brush = 4,
        TextBrush = 8,
        TextOptions = 16,
        HorAlignment = 32,
        VertAlignment = 64,
        All = 127
    }
    enum StiDateRangeKind {
        CurrentMonth = 0,
        CurrentQuarter = 1,
        CurrentWeek = 2,
        CurrentYear = 3,
        NextMonth = 4,
        NextQuarter = 5,
        NextWeek = 6,
        NextYear = 7,
        PreviousMonth = 8,
        PreviousQuarter = 9,
        PreviousWeek = 10,
        PreviousYear = 11,
        FirstQuarter = 12,
        SecondQuarter = 13,
        ThirdQuarter = 14,
        FourthQuarter = 15,
        MonthToDate = 16,
        QuarterToDate = 17,
        WeekToDate = 18,
        YearToDate = 19,
        Today = 20,
        Tomorrow = 21,
        Yesterday = 22,
        Last7Days = 23,
        Last14Days = 24,
        Last30Days = 25
    }
    enum StiDashboardViewerSettings {
        None = 0,
        ShowToolBar = 1,
        ShowRefreshButton = 2,
        ShowOpenButton = 4,
        ShowFullScreenButton = 8,
        ShowMenuButton = 16,
        ShowEditButton = 32,
        ShowReportSnapshots = 64,
        ShowExports = 128,
        ShowResetAllFilters = 256,
        ShowParametersButton = 512,
        All = 1023
    }
    enum StiElementMeterAction {
        None = 0,
        Rename = 1,
        Delete = 2,
        ClearAll = 3
    }
    enum StiDataMode {
        UsingDataFields = 0,
        ManuallyEnteringData = 1
    }
    enum StiDesignerStartScreen {
        Welcome = 0,
        BlankReport = 1,
        BlankDashboard = 2,
        NotAssigned = 3
    }
    enum StiHtmlPreviewMode {
        Div = 0,
        Table = 1
    }
    enum StiEventEvalAccess {
        Allow = 0,
        Ask = 1,
        Deny = 2
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiBusinessObjectsCollection extends CollectionBase<StiBusinessObject> implements IStiJsonReportObject, ICloneable, IComparer<any> {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private directionFactor;
        compare(x: any, y: any): number;
        protected onSet(index: number, oldValue: any, newValue: any): void;
        protected onInsert(index: number, value: any): void;
        remove(source: StiBusinessObject): void;
        _cachedBusinessObjects: Hashtable;
        get cachedBusinessObjects(): Hashtable;
        getByName(name: string): StiBusinessObject;
        setByName(name: string, value: StiBusinessObject): void;
        findByName(name: string): StiBusinessObject;
        clone(): any;
        sort(order?: StiSortOrder, sortColumns?: boolean): void;
        connect(): void;
        disconnect(): void;
        dictionary: StiDictionary;
        parentBusinessObject: StiBusinessObject;
        constructor(dictionary: StiDictionary, parentBusinessObject: StiBusinessObject);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IAsIs = Stimulsoft.System.IAsIs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBusinessObjectsCollection = Stimulsoft.Report.Dictionary.StiBusinessObjectsCollection;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IEnumerator = Stimulsoft.System.Collections.IEnumerator;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiBusinessObject implements ICloneable, IStiStateSaveRestore, IStiEnumerator, IStiInherited, IStiJsonReportObject, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _states;
        protected get states(): StiStatesManager;
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        clearAllStates(): void;
        inherited: boolean;
        protected positionValue: number;
        get position(): number;
        set position(value: number);
        countFiltered: number;
        get count(): number;
        protected isBofValue: boolean;
        get isBof(): boolean;
        set isBof(value: boolean);
        protected isEofValue: boolean;
        get isEof(): boolean;
        set isEof(value: boolean);
        isEmpty: boolean;
        private enumeratorReset;
        firstAsync(): Promise<void>;
        first(): void;
        prior(): void;
        nextAsync(): Promise<void>;
        next(): void;
        last(): void;
        clone(): StiBusinessObject;
        currentObject: any;
        get current(): any;
        private get report();
        businessObjects: StiBusinessObjectsCollection;
        columns: StiDataColumnsCollection;
        guid: string;
        category: string;
        name: string;
        alias: string;
        private _businessObjectValue;
        get businessObjectValue(): any;
        set businessObjectValue(value: any);
        private _dictionary;
        get dictionary(): StiDictionary;
        set dictionary(value: StiDictionary);
        parentBusinessObject: StiBusinessObject;
        ownerBand: StiDataBand;
        key: string;
        static fieldsIgnoreList: Hashtable<any, any>;
        getLevel(): number;
        private checkEnumerator;
        setPrevValue(): void;
        setNextValue(): void;
        restoreCurrentValue(): void;
        getTopParentBusinessObject(): StiBusinessObject;
        createEnumerator(): void;
        private sortData;
        private sortDataByGroups;
        filterData(): void;
        private destroyEnumerator;
        setDetails(): void;
        private updateChilds;
        private getBusinessObjectDataFromParent;
        getColumnIndex(columnName: string): number;
        getBusinessObjectData(isColumnsRetrieve?: boolean): any;
        getFullName(): string;
        getCorrectFullName(): string;
        toString(): string;
        connect(): void;
        disconnect(): void;
        private isEnumeratorCreated;
        private specPrevValue;
        private specNextValue;
        private specNextValueRead;
        private specMoveNextResult;
        private specStoredCurrentValue;
        enumerator: IEnumerator;
        protected rowToLevel: Hashtable;
        specSetPrevValue: boolean;
        specSetNextValue: boolean;
        specFilterData: boolean;
        specSortGroup: boolean;
        specTotalsCalculation: boolean;
        previousResetException: boolean;
        getByName(name: string): any;
        constructor(category?: string, name?: string, alias?: string, guid?: string, key?: string);
    }
}
export namespace Stimulsoft.Report.Events {
    class StiEventHandler {
        static run(event: StiEvent, report: StiReport, args?: any[]): any;
        static run2(script: string, report: StiReport, argsName?: string[], argsValue?: any[]): any;
        private static fixName;
    }
}
export namespace Stimulsoft.Report.Events {
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiValueEventArgs extends EventArgs {
        value: any;
        displayValue: string;
        constructor(value?: any);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    import StiBusinessObjectsCollection = Stimulsoft.Report.Dictionary.StiBusinessObjectsCollection;
    class StiBusinessObjectHelper {
        static getElementType(arrayType: Type): Type;
        private static getElement;
        static getAlias(valueProp: string): string;
        static isAllowUseProperty(valueProp: string): boolean;
        private static getType;
        private static getDataColumn;
        private static getDataColumn2;
        private static getColumnsFromObject;
        private static getColumnsFromClass;
        static getColumnsFromData(data: any, includeChildDataSources?: boolean): StiDataColumnsCollection;
        static isDataColumn(type: Type): boolean;
        static getBusinessObjectFromGuid(report: StiReport, guid: string): StiBusinessObject;
        static getBusinessObjectsFromReport(data: StiBusinessObjectsCollection | StiReport): StiBusinessObject[];
    }
}
export namespace Stimulsoft.Report.Events {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiEvent implements ICloneable {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        get isScript(): boolean;
        get isBlockly(): boolean;
        script: string;
    }
}
export namespace Stimulsoft.Report.Helpers {
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    import StiUserFunction = Stimulsoft.Report.Dictionary.StiUserFunction;
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    class StiBlocklyHelper {
        static invokeBlockly(report: StiReport, sender: any, stiEvent: StiEvent, e?: EventArgs): void;
        static invokeBlocklyAsync(report: StiReport, sender: any, stiEvent: StiEvent, e?: EventArgs): Promise<void>;
        static invokeUserFunctionBlockly(report: StiReport, functionn: StiUserFunction, argumentss: Dictionary<string, any>): any;
    }
}
export namespace Stimulsoft.Report.Expressions {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IAsIs = Stimulsoft.System.IAsIs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiExpression implements ICloneable, IStiJsonReportObject, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private val;
        get value(): string;
        set value(value: string);
        protected getValueProp(): string;
        protected setValueProp(value: string): void;
        parentComponent: any;
        fullConvert: boolean;
        get applyFormat(): boolean;
        genAddEvent: boolean;
        toString(): string;
        clone(): any;
        constructor(value?: string);
    }
}
export namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiConditionsCollection extends CollectionBase<StiBaseCondition> implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private isBorderSides;
        private convertIconSetItemFromString;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiConditionsCollection;
        addRange(conditions: StiConditionsCollection, addOnlyNotEqual?: boolean): void;
    }
}
export namespace Stimulsoft.Report {
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiBase extends StiService implements IStiName {
        memberwiseClone(baseClone?: boolean): StiBase;
        private _name;
        get name(): string;
        set name(value: string);
        getName(): string;
        setName(value: string): void;
        implements(): any[];
        get localizedName(): string;
        get localizedCategory(): string;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import StiPaintEventArgs = Stimulsoft.Report.Events.StiPaintEventArgs;
    import StiGetDrillDownReportEventArgs = Stimulsoft.Report.Events.StiGetDrillDownReportEventArgs;
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import StiBase = Stimulsoft.Report.StiBase;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiConditionsCollection = Stimulsoft.Report.Components.StiConditionsCollection;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import IStiReportComponent = Stimulsoft.Base.IStiReportComponent;
    import IStiApp = Stimulsoft.Base.IStiApp;
    import IStiReport = Stimulsoft.Base.IStiReport;
    import IStiAppExpressionCollection = Stimulsoft.Base.IStiAppExpressionCollection;
    import StiAppExpressionCollection = Stimulsoft.Base.StiAppExpressionCollection;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiComponent extends StiBase implements IStiComponentGuid, IStiCanGrow, IStiCanShrink, IStiUnitConvert, IStiShift, IStiGrowToHeight, IStiAnchor, IStiConditions, IStiPrintOn, IStiInherited, IStiStateSaveRestore, IStiJsonReportObject, IStiReportComponent, IStiComponent, IStiGetFonts, IStiAppExpressionCollection {
        implements(): any[];
        meta(): StiMeta[];
        protected loadRectangleDFromXml(text: string): RectangleD;
        infographicsDisplayRectangle: RectangleD;
        private _isSelected;
        get isSelected(): boolean;
        set isSelected(value: boolean);
        select(): void;
        invert(): void;
        reset(): void;
        getApp(): IStiApp;
        getKey(): string;
        setKey(key: string): void;
        getReport(): IStiReport;
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        private _states;
        get states(): StiStatesManager;
        getStates(): StiStatesManager;
        clearAllStates(): void;
        get shift(): boolean;
        set shift(value: boolean);
        getShift(): boolean;
        private _shiftMode;
        get shiftMode(): StiShiftMode;
        set shiftMode(value: StiShiftMode);
        guid: string;
        newGuid(): void;
        printOn: StiPrintOnType;
        clone(cloneProperties?: boolean, cloneComponents?: boolean, base?: boolean): any;
        memberwiseClone(base?: boolean): StiComponent;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        private _canShrink;
        get canShrink(): boolean;
        set canShrink(value: boolean);
        getCanShrink(): boolean;
        private _canGrow;
        get canGrow(): boolean;
        set canGrow(value: boolean);
        getCanGrow(): boolean;
        setCanGrow(value: boolean): void;
        private _growToHeight;
        get growToHeight(): boolean;
        set growToHeight(value: boolean);
        getGrowToHeight(): boolean;
        private _anchor;
        get anchor(): StiAnchorMode;
        set anchor(value: StiAnchorMode);
        private _conditions;
        get conditions(): StiConditionsCollection;
        set conditions(value: StiConditionsCollection);
        getConditions(): StiConditionsCollection;
        setConditions(value: StiConditionsCollection): void;
        private static propertyInherited;
        get inherited(): boolean;
        set inherited(value: boolean);
        getActualSize(): SizeD;
        get report(): StiReport;
        set report(value: StiReport);
        private _interaction;
        get interaction(): StiInteraction;
        set interaction(value: StiInteraction);
        getFonts(): Font[];
        expressions: StiAppExpressionCollection;
        doPointer(createNewGuid?: boolean): void;
        private doGetPointer;
        doBookmark(): boolean;
        private doGetBookmark;
        get printable(): boolean;
        set printable(value: boolean);
        isRendered: boolean;
        private static propertyRenderedCount;
        get renderedCount(): number;
        set renderedCount(value: number);
        allowPrintOn(): boolean;
        get isEnabled(): boolean;
        getIsEnabled(): Promise<boolean>;
        prepare(): void;
        unPrepare(): void;
        setReportVariables(): void;
        internalRenderAsync(): Promise<StiComponent>;
        internalRender(): StiComponent;
        renderAsync(): Promise<StiComponent>;
        render(): StiComponent;
        paint(g: Stimulsoft.System.Drawing.Graphics): void;
        get dockStyle(): StiDockStyle;
        set dockStyle(value: StiDockStyle);
        getDockStyle(): StiDockStyle;
        get isAutomaticDock(): boolean;
        getDockRegion(parent: StiComponent, useColumns?: boolean): RectangleD;
        dockToContainer(): void;
        dockToContainer2(rect: RectangleD): RectangleD;
        private checkWidth;
        private checkHeight;
        private disableCheckWidthHeight;
        private static propertyMinSize;
        get minSize(): SizeD;
        set minSize(value: SizeD);
        getMinSize(): SizeD;
        setMinSize(value: SizeD): void;
        private static propertyMaxSize;
        get maxSize(): SizeD;
        set maxSize(value: SizeD);
        getMaxSize(): SizeD;
        setMaxSize(value: SizeD): void;
        private _left;
        get left(): number;
        set left(value: number);
        getLeft(): number;
        setLeft(value: number): void;
        private _top;
        get top(): number;
        set top(value: number);
        getTop(): number;
        setTop(value: number): void;
        private _width;
        get width(): number;
        set width(value: number);
        getWidth(): number;
        setWidth(value: number): void;
        private _height;
        get height(): number;
        set height(value: number);
        getHeight(): number;
        setHeight(value: number): void;
        get right(): number;
        get bottom(): number;
        getBottom(): number;
        get clientRectangle(): RectangleD;
        set clientRectangle(value: RectangleD);
        protected setClientRectangle(value: RectangleD): void;
        get displayRectangle(): RectangleD;
        set displayRectangle(value: RectangleD);
        getDisplayRectangle(): RectangleD;
        setDisplayRectangle(value: RectangleD): void;
        setDirectDisplayRectangle(rect: RectangleD): void;
        get selectRectangle(): RectangleD;
        set selectRectangle(value: RectangleD);
        defaultClientRectangle: RectangleD;
        parentBookmark: StiBookmark;
        currentBookmark: StiBookmark;
        parentPointer: StiBookmark;
        currentPointer: StiBookmark;
        invokeEvents(): void;
        getToolTipEvent: StiEvent;
        protected onGetToolTip(): void;
        invokeGetToolTip(sender: any, e: StiValueEventArgs): void;
        getHyperlinkEvent: StiEvent;
        protected onGetHyperlink(e: StiValueEventArgs): void;
        invokeGetHyperlink(sender: any, e: StiValueEventArgs): void;
        getTagEvent: StiEvent;
        protected onGetTag(e: StiValueEventArgs): void;
        invokeGetTag(sender: any, e: StiValueEventArgs): void;
        getPointerEvent: StiEvent;
        protected onGetPointer(e: StiValueEventArgs): void;
        invokeGetPointer(sender: any, e: StiValueEventArgs): void;
        getBookmarkEvent: StiEvent;
        onGetBookmark(): void;
        invokeGetBookmark(sender: any, e: EventArgs): void;
        beforePrintEvent: StiEvent;
        protected onBeforePrint(e: EventArgs): void;
        invokeBeforePrint(sender: StiComponent, e: EventArgs): void;
        applyConditions(sender: StiComponent, conditions: {
            key: StiCondition;
            value: string;
        }[], e: EventArgs): void;
        afterPrintEvent: StiEvent;
        protected onAfterPrint(e: EventArgs): void;
        invokeAfterPrint(sender: any, e: EventArgs): void;
        getDrillDownReportEvent: StiEvent;
        protected onGetDrillDownReport(e: StiGetDrillDownReportEventArgs): void;
        invokeGetDrillDownReport(sender: any, e: StiGetDrillDownReportEventArgs): void;
        clickEvent: StiEvent;
        onClick: Function;
        invokeClick(sender: any, e: EventArgs): void;
        doubleClickEvent: StiEvent;
        onDoubleClick: Function;
        invokeDoubleClick(sender: any, e: EventArgs): void;
        mouseEnterEvent: StiEvent;
        onMouseEnter: Function;
        invokeMouseEnter(sender: any, e: EventArgs): void;
        mouseLeaveEvent: StiEvent;
        onMouseLeave: Function;
        invokeMouseLeave(sender: any, e: EventArgs): void;
        private static eventPainting;
        protected onPainting(e: StiPaintEventArgs): void;
        invokePainting(sender: StiComponent, e: StiPaintEventArgs): void;
        private static eventPainted;
        protected onPainted(e: StiPaintEventArgs): void;
        invokePainted(sender: StiComponent, e: StiPaintEventArgs): void;
        pointerValue: any;
        get pointer(): string;
        set pointer(value: string);
        get bookmarkValue(): any;
        set bookmarkValue(value: any);
        get bookmark(): string;
        set bookmark(value: string);
        get toolTipValue(): any;
        set toolTipValue(value: any);
        get toolTip(): string;
        set toolTip(value: string);
        get hyperlinkValue(): any;
        set hyperlinkValue(value: any);
        get hyperlink(): string;
        set hyperlink(value: string);
        get tagValue(): any;
        set tagValue(value: any);
        get tag(): string;
        set tag(value: string);
        alias: string;
        protected static propertyRestrictions: string;
        get restrictions(): StiRestrictions;
        set restrictions(value: StiRestrictions);
        getRestrictions(): StiRestrictions;
        setRestrictions(value: StiRestrictions): void;
        get ignoreNamingRule(): boolean;
        set ignoreNamingRule(value: boolean);
        setName(value: string): void;
        protected static propertyPlaceOnToolbox: string;
        get placeOnToolbox(): boolean;
        set placeOnToolbox(value: boolean);
        get toolboxPosition(): number;
        get isPrinting(): boolean;
        get isExporting(): boolean;
        get isDesigning(): boolean;
        allowDelete(): boolean;
        get priority(): number;
        get componentType(): StiComponentType;
        protected static propertyDockable: string;
        get dockable(): boolean;
        set dockable(value: boolean);
        get highlightState(): StiHighlightState;
        set highlightState(value: StiHighlightState);
        componentPlacement: string;
        private _drillDownParameters;
        get drillDownParameters(): any[];
        set drillDownParameters(value: any[]);
        protected static propertyComponentStyle: string;
        get componentStyle(): string;
        set componentStyle(value: string);
        getComponentStyle(): string;
        setComponentStyle(value: string): void;
        protected static propertyLocked: string;
        get locked(): boolean;
        set locked(value: boolean);
        protected static propertyLinked: string;
        get linked(): boolean;
        set linked(value: boolean);
        getLinked(): boolean;
        setLinked(value: boolean): void;
        get enabled(): boolean;
        set enabled(value: boolean);
        private static propertyUseParentStyles;
        get useParentStyles(): boolean;
        set useParentStyles(value: boolean);
        getUseParentStyles(): boolean;
        setUseParentStyles(value: boolean): void;
        private _page;
        get page(): StiPage;
        set page(value: StiPage);
        private _parent;
        get parent(): StiContainer;
        set parent(value: StiContainer);
        isExportAsImage(format: StiExportFormat): boolean;
        private lockOnResize;
        private invokeOnResizeComponent;
        onResizeComponent(oldSize: SizeD, newSize: SizeD): void;
        clearContents(): void;
        toString(): string;
        get isCross(): boolean;
        canContainIn(component: StiComponent): boolean;
        componentToPage(value: PointD | RectangleD): any;
        pageToComponent(value: PointD | RectangleD): any;
        static isParentSelect(component: StiComponent): boolean;
        static doOffsetRect(component: StiComponent, rect: RectangleD, offsetRect: RectangleD): RectangleD;
        getPaintRectangle(convertToHInches?: boolean, convertByZoom?: boolean, docking?: boolean): RectangleD;
        setPaintRectangle(rect: RectangleD): void;
        getDisplayRectangle2(): RectangleD;
        getDataBand(): StiDataBand;
        getGroupHeaderBand(): StiGroupHeaderBand;
        getContainer(): StiContainer;
        checkForParentComponent(comp: StiComponent): boolean;
        getComponentStyle2(): StiBaseStyle;
        private bits;
        constructor(rect?: RectangleD, isSuper?: boolean);
        protected construct(rect?: RectangleD): void;
    }
}
export namespace Stimulsoft.Report.Components {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Font = Stimulsoft.System.Drawing.Font;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    class StiComponentDivider {
        static breakText(g: Graphics, rect: RectangleD, REFtext: any, font: Font, textOptions: StiTextOptions, textQuality: StiTextQuality, allowHtmlTags: boolean, textComp: StiText): string;
        static breakContainer(maxAllowedHeight: number, renderedContainer: StiContainer): StiContainer;
        static breakContainerV2(maxAllowedHeight: number, renderedContainer: StiContainer): StiContainer;
        private static getDivideLine;
        private static searchDivideLine;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiContainer extends StiComponent implements IStiBorder, IStiBrush, IStiBreakable, IStiIgnoryStyle, IStiJsonReportObject, IStiGetFonts, IStiCornerRadius {
        implements(): any[];
        meta(): StiMeta[];
        parseContainerFromXml(xmlNode: XmlNode): void;
        loadFromXml(xmlNode: XmlNode): void;
        protected static propertyCanBreak: string;
        get canBreak(): boolean;
        set canBreak(value: boolean);
        break(dividedComponent: StiComponent, devideFactor: number, REFdivideLine: any): boolean;
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean, convertComponents?: boolean): void;
        border: StiBorder;
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        getActualSize(isFirstPass?: boolean, REFneedSecondPass?: any): SizeD;
        getFonts(): Font[];
        private _containerInfo;
        get containerInfo(): StiContainerInfo;
        get priority(): number;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get componentType(): StiComponentType;
        parentComponentIsBand: boolean;
        parentComponentIsCrossBand: boolean;
        collapsedValue: any;
        collapsingIndex: number;
        collapsingTreePath: string;
        get hasSelected(): boolean;
        defaultClientRectangle: Rectangle;
        private _components;
        get components(): StiComponentsCollection;
        set components(value: StiComponentsCollection);
        cornerRadius: StiCornerRadius;
        protected static propertyBlocked: string;
        get blocked(): boolean;
        set blocked(value: boolean);
        setParentStylesToChilds(style?: Stimulsoft.Report.Styles.StiBaseStyle): void;
        offsetLocation(offsetX: number, offsetY: number): void;
        changePosition(delta: Rectangle): void;
        normalize(): void;
        sortByPriority(): void;
        bringToFront(): void;
        sendToBack(): void;
        moveForward(): void;
        moveBackward(): void;
        alignTo(aligning: StiAligning): void;
        private getContainerInRectPrivate;
        getContainerInRect(rect: Rectangle, component: StiComponent): StiContainer;
        private getSizesTable;
        private getNodeSize;
        private getContainerInRect2Private;
        getContainerInRect2(rect: Rectangle, component: StiComponent, hash: Hashtable<StiComponent, Rectangle>): StiContainer;
        private getIncorrect2;
        correct2(onlySelect: boolean): void;
        getIncorrect(onlySelect?: boolean): StiComponentsCollection;
        correct(onlySelect?: boolean): void;
        checkLargeHeight(needFullCalculation?: boolean): void;
        resetSelection(): void;
        getSelectedComponents(comps?: StiComponentsCollection): StiComponentsCollection;
        getSelectedRectangle(): Rectangle;
        makeHorizontalSpacingEqual(): void;
        makeVerticalSpacingEqual(): void;
        makeSameSize(size: SizeD): void;
        makeSameWidth(width: number): void;
        makeSameHeight(height: number): void;
        setCenterHorizontally(): void;
        setCenterVertically(): void;
        selectAll(): void;
        containerToPage(value: Point | Rectangle): any;
        private containerToPageRectangle;
        private containerToPagePoint;
        pageToContainer(value: Point | Rectangle): any;
        getComponents(comps?: StiComponentsCollection): StiComponentsCollection;
        getComponentsList(): StiComponent[];
        moveComponentsToPage(): void;
        constructor(rect?: Rectangle, isSuper?: boolean);
        protected construct(rect?: Rectangle): void;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBand extends StiContainer implements IStiResetPageNumber, IStiJsonReportObject, IStiCanGrow, IStiConditions {
        implements(): any[];
        meta(): StiMeta[];
        canContainIn(component: StiComponent): boolean;
        get componentType(): StiComponentType;
        protected getComponentType(): StiComponentType;
        clone(cloneProperties: boolean, cloneComponents: boolean): StiBand;
        private _resetPageNumber;
        get resetPageNumber(): boolean;
        set resetPageNumber(value: boolean);
        private _bandInfo;
        get bandInfo(): StiBandInfo;
        getDockStyle(): StiDockStyle;
        setDockStyle(value: StiDockStyle): void;
        get isAutomaticDock(): boolean;
        get printable(): boolean;
        set printable(value: boolean);
        get minHeight(): number;
        set minHeight(value: number);
        getMinHeight(): number;
        setMinHeight(value: number): void;
        get maxHeight(): number;
        set maxHeight(value: number);
        getMaxHeight(): number;
        setMaxHeight(value: number): void;
        defaultClientRectangle: RectangleD;
        getDisplayRectangle(): RectangleD;
        setDisplayRectangle(value: RectangleD): void;
        setDirectDisplayRectangle(rect: RectangleD): void;
        get selectRectangle(): RectangleD;
        set selectRectangle(value: RectangleD);
        get nestedLevel(): number;
        rectangleMoveComponent: RectangleD;
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        getHeaderText(): string;
        get headerSize(): number;
        get footerSize(): number;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDynamicBand extends StiBand implements IStiPageBreak, IStiBreakable, IStiPrintAtBottom, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        private _printAtBottom;
        get printAtBottom(): boolean;
        set printAtBottom(value: boolean);
        break(dividedComponent: StiComponent, devideFactor: number, divLine: number): boolean;
        newPageBefore: boolean;
        newPageAfter: boolean;
        newColumnBefore: boolean;
        newColumnAfter: boolean;
        skipFirst: boolean;
        private _breakIfLessThan;
        get breakIfLessThan(): number;
        set breakIfLessThan(value: number);
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiDataBand extends StiDynamicBand implements IStiDataSource, Stimulsoft.Report.Dictionary.IStiEnumerator, IStiMasterComponent, IStiDataRelation, IStiOddEvenStyles, IStiSort, IStiFilter, IStiPrintOnAllPages, IStiPrintIfDetailEmpty, IStiKeepDetailsTogether, IStiResetPageNumber, IStiRenderMaster, IStiBusinessObject, IStiJsonReportObject {
        implements(): any[];
        jsonMasterComponentTemp: string;
        meta(): StiMeta[];
        static loadXmlSort(xmlNode: XmlNode): string[];
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        masterComponent: StiComponent;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        get keepDetailsTogether(): boolean;
        set keepDetailsTogether(value: boolean);
        keepDetails: StiKeepDetails;
        private _sort;
        get sort(): string[];
        set sort(value: string[]);
        clone(cloneProperties: boolean, cloneComponents: boolean): StiBand;
        private _printOnAllPages;
        get printOnAllPages(): boolean;
        set printOnAllPages(value: boolean);
        printIfDetailEmpty: boolean;
        get isDataSourceEmpty(): boolean;
        get dataSource(): StiDataSource;
        private _dataSourceName;
        get dataSourceName(): string;
        set dataSourceName(value: string);
        get isBusinessObjectEmpty(): boolean;
        get businessObject(): StiBusinessObject;
        private _businessObjectGuid;
        get businessObjectGuid(): string;
        set businessObjectGuid(value: string);
        firstAsync(): Promise<void>;
        first(): void;
        prior(): void;
        nextAsync(): Promise<void>;
        next(): void;
        last(): void;
        isEofValue: boolean;
        get isEof(): boolean;
        set isEof(value: boolean);
        isBofValue: boolean;
        get isBof(): boolean;
        set isBof(value: boolean);
        get isEmpty(): boolean;
        positionValue: number;
        get position(): number;
        set position(value: number);
        get count(): number;
        allowReconnectOnEachRowForDetails: boolean;
        get dataRelation(): StiDataRelation;
        dataRelationName: string;
        filterMode: StiFilterMode;
        filterEngine: StiFilterEngine;
        filterMethodHandler: Function;
        filters: StiFiltersCollection;
        get filter(): string;
        set filter(value: string);
        filterOn: boolean;
        static propertyEvenStyle: string;
        get evenStyle(): string;
        set evenStyle(value: string);
        static propertyOddStyle: string;
        get oddStyle(): string;
        set oddStyle(value: string);
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        getHeaderText(): string;
        doBookmark(): boolean;
        doPointer(createNewGuid?: boolean): void;
        invokeGroupRendering(): void;
        private _dataBandInfo;
        get dataBandInfo(): StiDataBandInfo;
        renderAsync(): Promise<StiComponent>;
        render(): StiComponent;
        renderMasterAsync(): Promise<void>;
        renderMaster(): void;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get priority(): number;
        protected getComponentType(): StiComponentType;
        beginRenderEvent: StiEvent;
        onBeginRender: Function;
        invokeBeginRender(): void;
        renderingEvent: StiEvent;
        onRendering: Function;
        invokeRendering(): void;
        endRenderEvent: StiEvent;
        onEndRender: Function;
        invokeEndRender(): void;
        getCollapsedEvent: StiEvent;
        onGetCollapsed: Function;
        invokeGetCollapsed(e: StiValueEventArgs): void;
        private _collapsed;
        get collapsed(): string;
        set collapsed(value: string);
        private _rightToLeft;
        get rightToLeft(): boolean;
        set rightToLeft(value: boolean);
        getRightToLeft(): boolean;
        setRightToLeft(value: boolean): void;
        getColumnWidth(): number;
        columnGaps: number;
        columnWidth: number;
        columns: number;
        minRowsInColumn: number;
        gapAfterLastColumn: boolean;
        private _columnDirection;
        get columnDirection(): StiColumnDirection;
        set columnDirection(value: StiColumnDirection);
        lineThrough: number;
        line: number;
        selectedLine: number;
        resetDataSource: boolean;
        multipleInitialization: boolean;
        calcInvisible: boolean;
        private _countData;
        get countData(): number;
        set countData(value: number);
        limitRows: string;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Helpers {
    import StiResource = Stimulsoft.Report.Dictionary.StiResource;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiHyperlinkProcessor {
        static getBytes(report: StiReport, hyperlink: string): number[];
        static getImage(report: StiReport, hyperlink: string): Image;
        static getString(report: StiReport, hyperlink: string): string;
        static getResourceByHyperlink(report: StiReport, hyperlink: string): StiResource;
        static getResource(report: StiReport, resourceName: string): StiResource;
        private static getVariable;
        static getServerNameFromHyperlink(hyperlink: string): string;
        static getResourceNameFromHyperlink(hyperlink: string): string;
        static getVariableNameFromHyperlink(hyperlink: string): string;
        static getDataColumnNameFromHyperlink(hyperlink: string): string;
        static getRealDataColumnFromHyperlink(report: StiReport, hyperlink: string): string;
        static getFileNameFromHyperlink(hyperlink: string): string;
        static isServerHyperlink(hyperlink: string): boolean;
        static isResourceHyperlink(hyperlink: string): boolean;
        static isVariableHyperlink(hyperlink: string): boolean;
        static isDataColumnHyperlink(hyperlink: string): boolean;
        static isFileHyperlink(hyperlink: string): boolean;
        static createResourceName(name: string): string;
        static createVariableName(name: string): string;
        static createFileName(path: string): string;
        static hyperlinkToString(hyperlink: string): string;
        static serverIdent: string;
        static resourceIdent: string;
        static variableIdent: string;
        static dataColumnIdent: string;
        static fileIdent: string;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiFillParametersEventArgs = Stimulsoft.Report.Events.StiFillParametersEventArgs;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiSubReport extends StiContainer implements IStiJsonReportObject {
        meta(): StiMeta[];
        get componentType(): StiComponentType;
        clone(): StiSubReport;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        setWidth(value: number): void;
        setClientRectangle(value: RectangleD): void;
        private updateSubReportPageWidth;
        getExternalSubReport(): StiReport;
        protected getSubReportFromUrl(url: string): StiReport;
        protected getSubReportFromFile(url: string): StiReport;
        fillParametersEvent: StiEvent;
        protected onFillParameters(e: StiFillParametersEventArgs): void;
        invokeFillParameters(sender: StiComponent, e: StiFillParametersEventArgs): void;
        get useExternalReport(): boolean;
        keepSubReportTogether: boolean;
        get subReportPage(): StiPage;
        set subReportPage(value: StiPage);
        subReportPageGuid: string;
        subReportUrl: string;
        parameters: StiParametersCollection;
        defaultClientRectangle: RectangleD;
        static getSubReportForPage(page: StiPage): StiSubReport;
    }
}
export namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiComponentsCollection extends CollectionBase<StiComponent> implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiComponentsCollection;
        memberwiseClone(): StiComponentsCollection;
        private addCore;
        add(component: StiComponent): void;
        indexOf(param: string | StiComponent | any): number;
        insertRange(index: number, components: StiComponentsCollection): void;
        insert(index: number, component: StiComponent): void;
        remove(component: StiComponent, clearParent?: boolean): void;
        getByName(name: string): StiComponent;
        setByName(name: string, component: StiComponent): void;
        findByName(name: string): StiComponent;
        sortByPriority(): void;
        sortByTopPosition(): void;
        sortByBottomPosition(): void;
        sortByLeftPosition(): void;
        sortByRightPosition(): void;
        sortBandsByTopPosition(): void;
        sortBandsByLeftPosition(): void;
        getComponentByName(componentName: string, container: StiContainer): StiComponent;
        getComponentByGuid(guid: string, container: StiContainer): StiComponent;
        getPageByAlias(alias: string): StiPage;
        setParent(parent: StiContainer): void;
        private parent;
        constructor(parent?: StiContainer);
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiComponentsOwnerRenderer: System.Interface<IStiComponentsOwnerRenderer>;
    interface IStiComponentsOwnerRenderer {
    }
}
export namespace Stimulsoft.Report.Components {
    class StiContainerHelper {
        static notCheckSizeMark: string;
        static checkSize(component: StiComponent): void;
        private static componentPlacedOnBand;
        static checkContainerGrowToHeight(component: StiComponent, force: boolean): void;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import EventArgs = Stimulsoft.System.EventArgs;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiEmptyBand extends StiBand implements IStiOddEvenStyles, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        clone(cloneProperties: boolean, cloneComponents: boolean): StiBand;
        getHeaderText(): string;
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get priority(): number;
        get evenStyle(): string;
        set evenStyle(value: string);
        get oddStyle(): string;
        set oddStyle(value: string);
        beginRenderEvent: StiEvent;
        protected onBeginRender(e: EventArgs): void;
        invokeBeginRender(): void;
        renderingEvent: StiEvent;
        protected onRendering(e: EventArgs): void;
        invokeRendering(): void;
        endRenderEvent: StiEvent;
        protected onEndRender(e: EventArgs): void;
        invokeEndRender(): void;
        sizeMode: StiEmptySizeMode;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import Font = Stimulsoft.System.Drawing.Font;
    let IStiFont: System.Interface<IStiFont>;
    let ImplementsIStiFont: any[];
    interface IStiFont {
        font: Font;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiBrush: System.Interface<IStiBrush>;
    interface IStiBrush {
        brush: StiBrush;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    let IStiBorder: System.Interface<IStiBorder>;
    interface IStiBorder {
        border: StiBorder;
    }
}
export namespace Stimulsoft.Report.Engine {
    import Type = Stimulsoft.System.Type;
    class StiBuilder {
        private static typeToBuilder;
        static getBuilder(componentType: Type): StiBuilder;
        setReportVariables(masterComp: Stimulsoft.Report.Components.StiComponent): void;
        prepare(masterComp: Stimulsoft.Report.Components.StiComponent): void;
        unPrepare(masterComp: Stimulsoft.Report.Components.StiComponent): void;
        internalRenderAsync(masterComp: Stimulsoft.Report.Components.StiComponent): Promise<Stimulsoft.Report.Components.StiComponent>;
        internalRender(masterComp: Stimulsoft.Report.Components.StiComponent): Stimulsoft.Report.Components.StiComponent;
        renderAsync(masterComp: Stimulsoft.Report.Components.StiComponent): Promise<Stimulsoft.Report.Components.StiComponent>;
        render(masterComp: Stimulsoft.Report.Components.StiComponent): Stimulsoft.Report.Components.StiComponent;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiTextBrush: System.Interface<IStiTextBrush>;
    interface IStiTextBrush {
        textBrush: StiBrush;
    }
}
export namespace Stimulsoft.Report.Components {
    class StiComponentHelper {
        static fillComponentPlacement(component: StiComponent): void;
    }
}
export namespace Stimulsoft.Report.Styles.Conditions {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiStyleConditionElement = Stimulsoft.Report.Styles.Conditions.Elements.StiStyleConditionElement;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiStyleConditionsCollection extends CollectionBase<StiStyleCondition> implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiStyleConditionsCollection;
        add(param: StiStyleCondition | StiStyleConditionElement[] | any): void;
        addRange(conditions: StiStyleCondition[] | StiStyleConditionsCollection | any): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiBaseStyle = Stimulsoft.Report.Styles.IStiBaseStyle;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiChartStyle: System.Interface<IStiChartStyle>;
    interface IStiChartStyle extends IStiBaseStyle, ICloneable, IStiJsonReportObject {
        styleIdent: StiElementStyleIdent;
        core: IStiStyleCoreXF;
        dashboardName: string;
        serviceEnabled: boolean;
        allowDashboard: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import IStiComponent = Stimulsoft.Report.Components.IStiComponent;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiFiltersCollection = Stimulsoft.Report.Components.StiFiltersCollection;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import IStiCanGrow = Stimulsoft.Report.Components.IStiCanGrow;
    import IStiCanShrink = Stimulsoft.Report.Components.IStiCanShrink;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiImageRotation = Stimulsoft.Report.Components.StiImageRotation;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    import List = Stimulsoft.System.Collections.List;
    let IStiChart: System.Interface<IStiChart>;
    interface IStiChart extends IStiComponent, IStiName, IStiCanGrow, IStiCanShrink, IStiGetFonts {
        seriesLabelsConditions: IStiChartConditionsCollection;
        series: IStiSeriesCollection;
        area: IStiArea;
        style: IStiChartStyle;
        seriesLabels: IStiSeriesLabels;
        legend: IStiLegend;
        labels: IStiSeriesLabels;
        title: IStiChartTitle;
        table: IStiChartTable;
        strips: IStiStripsCollection;
        constantLines: IStiConstantLinesCollection;
        horSpacing: number;
        vertSpacing: number;
        isDesigning: boolean;
        isAnimation: boolean;
        isAnimationChangingValues: boolean;
        brush: StiBrush;
        core: IStiChartCoreXF;
        allowApplyStyle: boolean;
        masterComponent: IStiComponent;
        jsonMasterComponentTemp: string;
        dataSourceName: string;
        chartInfo: IStiChartInfo;
        processAtEnd: boolean;
        convertToHInches(value: number): number;
        saveState(stateName: string): any;
        restoreState(stateName: string): any;
        customStyleName: string;
        name: string;
        border: StiBorder;
        filters: StiFiltersCollection;
        filterMode: StiFilterMode;
        filterOn: boolean;
        dataSource: StiDataSource;
        dataRelation: StiDataRelation;
        countData: number;
        businessObject: StiBusinessObject;
        canGrow: boolean;
        canShrink: boolean;
        rotation: StiImageRotation;
        editorType: StiChartEditorType;
        page: StiPage;
        previousAnimations: List<StiAnimation>;
        sortAnimation: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiCustomStyle: System.Interface<IStiCustomStyle>;
    interface IStiCustomStyle extends IStiChartStyle {
        customCore: IStiCustomStyleCoreXF;
    }
}
export namespace Stimulsoft.Report.Styles {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiStyleConditionsCollection = Stimulsoft.Report.Styles.Conditions.StiStyleConditionsCollection;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiBaseStyle extends StiService implements IStiBaseStyle, ICloneable, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        equals(obj: any, allowEqualName?: boolean, allowEqualDescription?: boolean): boolean;
        static getStyle(component: StiComponent, styleElements?: StiStyleElements | StiBaseStyle, componentStyle?: StiBaseStyle): StiBaseStyle;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
        getStyleFromComponents(comps: StiComponentsCollection, styleElements: StiStyleElements): void;
        toString(): string;
        private _collectionName;
        get collectionName(): string;
        set collectionName(value: string);
        private _conditions;
        get conditions(): StiStyleConditionsCollection;
        set conditions(value: StiStyleConditionsCollection);
        private _description;
        get description(): string;
        set description(value: string);
        private _name;
        get name(): string;
        set name(value: string);
        get dashboardName(): string;
        report: StiReport;
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
export namespace Stimulsoft.Report.Events {
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiGetExcelValueEventArgs extends EventArgs {
        value: string;
        storeToPrinted: boolean;
    }
}
export namespace Stimulsoft.Report.Components.TextFormats {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiService = Stimulsoft.Base.Services.StiService;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiFormatService extends StiService implements IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        static createFromJsonObject(jObject: StiJson): StiFormatService;
        static loadFormatFromXml(xmlNode: XmlNode, report?: StiReport): StiFormatService;
        static loadFromJsonObjectInternal(jObject: StiJson): StiFormatService;
        get position(): number;
        get sample(): any;
        get nativeFormatString(): string;
        get isFormatStringFromVariable(): boolean;
        stringFormat: string;
        format(arg: any): string;
        format2(format: string, arg: any): string;
    }
}
export namespace Stimulsoft.Report.Components.TextFormats {
    class StiCustomFormatService extends StiFormatService {
        get sample(): any;
        format2(format: string, arg: any): string;
        constructor(stringFormat?: string);
    }
}
export namespace Stimulsoft.Report.Components.TextFormats {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiTimeFormatService extends StiFormatService {
        meta(): StiMeta[];
        get sample(): any;
        format(arg: any): string;
        format2(stringFormat: string, arg: any): string;
        constructor(stringFormat?: string);
    }
}
export namespace Stimulsoft.Report.Components.TextFormats {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiDateFormatService extends StiFormatService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get sample(): any;
        format(arg: any): string;
        format2(stringFormat: string, arg: any): string;
        private static formatQuarter;
        nullDisplay: string;
        constructor(stringFormat?: string, nullDisplay?: string);
    }
}
export namespace Stimulsoft.Report.Components {
    enum StiTextFormatState {
        None = 0,
        DecimalDigits = 1,
        DecimalSeparator = 2,
        GroupSeparator = 4,
        GroupSize = 8,
        PositivePattern = 16,
        NegativePattern = 32,
        CurrencySymbol = 64,
        PercentageSymbol = 128,
        Abbreviation = 256,
        NegativeInRed = 512
    }
    enum StiIconSet {
        None = 0,
        Full = 1,
        ArrowsColored3 = 2,
        ArrowsColored4 = 3,
        ArrowsColored5 = 4,
        ArrowsGray3 = 5,
        ArrowsGray4 = 6,
        ArrowsGray5 = 7,
        Flags3 = 8,
        Latin4 = 9,
        Quarters5 = 10,
        QuartersGreen5 = 11,
        QuartersRed5 = 12,
        Ratings3 = 13,
        Ratings4 = 14,
        Ratings5 = 15,
        RedToBlack4 = 16,
        Signs3 = 17,
        Squares5 = 18,
        Stars3 = 19,
        Stars5 = 20,
        SymbolsCircled3 = 21,
        SymbolsUncircled3 = 22,
        TrafficLights4 = 23,
        TrafficLightsRimmed3 = 24,
        TrafficLightsUnrimmed3 = 25,
        Triangles3 = 26
    }
    enum StiIcon {
        None = 0,
        ArrowRightDownGray = 1,
        ArrowRightUpGray = 2,
        ArrowDownGray = 3,
        ArrowRightGray = 4,
        ArrowUpGray = 5,
        ArrowUpGreen = 6,
        ArrowDownRed = 7,
        ArrowRightYellow = 8,
        ArrowRightDownYellow = 9,
        ArrowRightUpYellow = 10,
        CheckGreen = 11,
        CircleBlack = 12,
        CircleGreen = 13,
        CircleCheckGreen = 14,
        CircleRed = 15,
        CircleCrossRed = 16,
        CircleYellow = 17,
        CircleExclamationYellow = 18,
        CrossRed = 19,
        ExclamationYellow = 20,
        FlagGreen = 21,
        FlagRed = 22,
        FlagYellow = 23,
        FromRedToBlackGray = 24,
        FromRedToBlackPink = 25,
        FromRedToBlackRed = 26,
        Latin1 = 27,
        Latin2 = 28,
        Latin3 = 29,
        Latin4 = 30,
        LightsGreen = 31,
        LightsRed = 32,
        LightsYellow = 33,
        MinusYellow = 34,
        QuarterFull = 35,
        QuarterFullGreen = 36,
        QuarterFullRed = 37,
        QuarterHalf = 38,
        QuarterHalfGreen = 39,
        QuarterHalfRed = 40,
        QuarterNone = 41,
        QuarterNoneGreen = 42,
        QuarterNoneRed = 43,
        QuarterQuarter = 44,
        QuarterQuarterGreen = 45,
        QuarterQuarterRed = 46,
        QuarterThreeFourth = 47,
        QuarterThreeFourthGreen = 48,
        QuarterThreeFourthRed = 49,
        Rating0 = 50,
        Rating1 = 51,
        Rating2 = 52,
        Rating3 = 53,
        Rating4 = 54,
        RhombRed = 55,
        Square0 = 56,
        Square1 = 57,
        Square2 = 58,
        Square3 = 59,
        Square4 = 60,
        StarFull = 61,
        StarHalf = 62,
        StarNone = 63,
        StarQuarter = 64,
        StarThreeFourth = 65,
        TriangleGreen = 66,
        TriangleRed = 67,
        TriangleYellow = 68
    }
    enum StiIconSetOperation {
        MoreThan = 0,
        MoreThanOrEqual = 1
    }
    enum StiIconSetValueType {
        Value = 0,
        Percent = 1
    }
    enum StiProcessAt {
        None = 0,
        EndOfReport = 1,
        EndOfPage = 2
    }
    enum StiMinimumType {
        Auto = 0,
        Value = 1,
        Percent = 2,
        Minimum = 3
    }
    enum StiMidType {
        Auto = 0,
        Value = 1,
        Percent = 2
    }
    enum StiMaximumType {
        Auto = 0,
        Value = 1,
        Percent = 2,
        Maximum = 3
    }
    enum StiDrillDownMode {
        SinglePage = 0,
        MultiPage = 1
    }
    enum StiConditionBorderSides {
        None = 0,
        All = 15,
        Top = 1,
        Left = 2,
        Right = 4,
        Bottom = 8,
        NotAssigned = 16
    }
    enum StiConditionPermissions {
        None = 0,
        Font = 1,
        FontSize = 2,
        FontStyleBold = 4,
        FontStyleItalic = 8,
        FontStyleUnderline = 16,
        FontStyleStrikeout = 32,
        TextColor = 64,
        BackColor = 128,
        Borders = 256,
        All = 511,
        Enabled = 512
    }
    enum StiQuickInfoType {
        None = 0,
        ShowComponentsNames = 1,
        ShowAliases = 2,
        ShowFieldsOnly = 3,
        ShowFields = 4,
        ShowEvents = 5,
        ShowContent = 6
    }
    enum StiAngle {
        Angle0 = 0,
        Angle90 = 90,
        Angle180 = 180,
        Angle270 = 270
    }
    enum StiDockStyle {
        Left = 0,
        Right = 1,
        Top = 2,
        Bottom = 3,
        None = 4,
        Fill = 5
    }
    enum StiFilterCondition {
        EqualTo = 0,
        NotEqualTo = 1,
        GreaterThan = 2,
        GreaterThanOrEqualTo = 3,
        LessThan = 4,
        LessThanOrEqualTo = 5,
        Between = 6,
        NotBetween = 7,
        Containing = 8,
        NotContaining = 9,
        BeginningWith = 10,
        EndingWith = 11,
        IsNull = 12,
        IsNotNull = 13
    }
    enum StiFilterItem {
        Argument = 0,
        Value = 1,
        ValueEnd = 2,
        Expression = 3,
        ValueOpen = 4,
        ValueClose = 5,
        ValueLow = 6,
        ValueHigh = 7
    }
    enum StiFilterDataType {
        String = 0,
        Numeric = 1,
        DateTime = 2,
        Boolean = 3,
        Expression = 4
    }
    enum StiFilterMode {
        And = 0,
        Or = 1
    }
    enum StiFilterEngine {
        ReportEngine = 0,
        SQLQuery = 1
    }
    enum StiKeepDetails {
        None = 0,
        KeepFirstRowTogether = 1,
        KeepFirstDetailTogether = 2,
        KeepDetailsTogether = 3
    }
    enum StiPrintOnType {
        AllPages = 0,
        ExceptFirstPage = 1,
        ExceptLastPage = 2,
        ExceptFirstAndLastPage = 3,
        OnlyFirstPage = 4,
        OnlyLastPage = 8,
        OnlyFirstAndLastPage = 12
    }
    enum StiPrintOnEvenOddPagesType {
        Ignore = 0,
        PrintOnEvenPages = 1,
        PrintOnOddPages = 2
    }
    enum StiShiftMode {
        None = 0,
        IncreasingSize = 1,
        DecreasingSize = 2,
        OnlyInWidthOfComponent = 4
    }
    enum StiAnchorMode {
        Top = 1,
        Bottom = 2,
        Left = 4,
        Right = 8
    }
    enum StiProcessingDuplicatesType {
        None = 0,
        Merge = 1,
        Hide = 2,
        RemoveText = 3,
        BasedOnTagMerge = 4,
        BasedOnTagHide = 5,
        BasedOnTagRemoveText = 6,
        GlobalMerge = 7,
        GlobalHide = 8,
        GlobalRemoveText = 9,
        BasedOnValueRemoveText = 10,
        BasedOnValueAndTagMerge = 11,
        BasedOnValueAndTagHide = 12,
        GlobalBasedOnValueRemoveText = 13,
        GlobalBasedOnValueAndTagMerge = 14,
        GlobalBasedOnValueAndTagHide = 15
    }
    enum StiImageProcessingDuplicatesType {
        None = 0,
        Merge = 1,
        Hide = 2,
        RemoveImage = 3,
        GlobalMerge = 4,
        GlobalHide = 5,
        GlobalRemoveImage = 6
    }
    enum StiCheckStyle {
        Cross = 0,
        Check = 1,
        CrossRectangle = 2,
        CheckRectangle = 3,
        CrossCircle = 4,
        DotCircle = 5,
        DotRectangle = 6,
        NoneCircle = 7,
        NoneRectangle = 8,
        None = 9
    }
    enum StiToolboxCategory {
        Bands = 0,
        Cross = 1,
        Components = 2,
        Shapes = 3,
        Controls = 4,
        Dashboards = 5
    }
    enum StiComponentToolboxPosition {
        Component = 0,
        ReportTitleBand = 1,
        ReportSummaryBand = 2,
        PageHeaderBand = 3,
        PageFooterBand = 4,
        GroupHeaderBand = 5,
        GroupFooterBand = 6,
        HeaderBand = 7,
        FooterBand = 8,
        ColumnHeaderBand = 9,
        ColumnFooterBand = 10,
        DataBand = 11,
        HierarchicalBand = 13,
        ChildBand = 14,
        EmptyBand = 15,
        OverlayBand = 16,
        CrossGroupHeaderBand = 21,
        CrossGroupFooterBand = 22,
        CrossHeaderBand = 23,
        CrossFooterBand = 24,
        CrossDataBand = 25,
        Text = 101,
        TextInCells = 102,
        SystemText = 103,
        ContourText = 104,
        RichText = 105,
        Image = 106,
        ElectronicSignature = 107,
        PdfDigitalSignature = 108,
        BarCode = 109,
        Shape = 110,
        Line = 111,
        Container = 112,
        Panel = 113,
        Clone = 114,
        CheckBox = 115,
        SubReport = 116,
        WinControl = 117,
        ZipCode = 118,
        TableOfContents = 119,
        HorizontalLinePrimitive = 150,
        VerticalLinePrimitive = 151,
        RectanglePrimitive = 152,
        RoundedRectanglePrimitive = 153,
        Chart = 200,
        Table = 201,
        CrossTab = 202,
        Map = 210,
        Sparkline = 225,
        Gauge = 220,
        TableElement = 301,
        ChartElement = 302,
        ComboBoxElement = 400,
        GaugeElement = 303,
        PivotTableElement = 304,
        IndicatorElement = 305,
        ProgressElement = 306,
        RegionMapElement = 307,
        ListBoxElement = 308,
        OnlineMapElement = 309,
        ImageElement = 310,
        WebContentElement = 311,
        TextElement = 312,
        PanelElement = 313,
        ShapeElement = 314,
        TreeViewElement = 315,
        TreeViewBoxElement = 316,
        DatePickerElement = 317,
        CardsElement = 318,
        NumberBoxElement = 319,
        ButtonElement = 320,
        UserCode = 1000
    }
    enum StiComponentPriority {
        Component = 0,
        CrossTab = 1500,
        SubReportsV1 = 1500,
        SubReportsV2 = 0,
        Container = 0,
        Panel = 0,
        ReportTitleBandBefore = -400,
        ReportTitleBandAfterV1 = -200,
        ReportTitleBandAfterV2 = 200,
        ReportSummaryBand = 500,
        PageHeaderBandBefore = -200,
        PageHeaderBandAfter = -400,
        PageFooterBandBottom = -300,
        PageFooterBandTop = 1000,
        GroupHeaderBand = 300,
        GroupFooterBand = 300,
        HeaderBand = 300,
        FooterBand = 300,
        ColumnHeaderBand = 300,
        ColumnFooterBand = 300,
        DataBand = 300,
        Table = 300,
        ChildBand = 300,
        EmptyBand = 300,
        TableOfContents = 300,
        OverlayBand = 700,
        Primitive = 1500,
        CrossGroupHeaderBand = 300,
        CrossGroupFooterBand = 300,
        CrossHeaderBand = 300,
        CrossFooterBand = 300,
        CrossDataBand = 300
    }
    enum StiComponentType {
        Simple = 0,
        Master = 1,
        Detail = 2,
        Static = 3
    }
    enum StiRestrictions {
        None = 0,
        AllowMove = 1,
        AllowResize = 2,
        AllowSelect = 4,
        AllowChange = 8,
        AllowDelete = 16,
        All = 31
    }
    enum StiHighlightState {
        Hide = 0,
        Show = 1,
        Active = 2
    }
    enum StiAligning {
        Left = 0,
        Center = 1,
        Right = 2,
        Top = 3,
        Middle = 4,
        Bottom = 5
    }
    enum StiColumnDirection {
        DownThenAcross = 0,
        AcrossThenDown = 1
    }
    enum StiEmptySizeMode {
        IncreaseLastRow = 0,
        DecreaseLastRow = 1,
        AlignFooterToBottom = 2,
        AlignFooterToTop = 3
    }
    enum StiGroupSortDirection {
        Ascending = 0,
        Descending = 1,
        None = 2
    }
    enum StiGroupSummaryType {
        Avg = 0,
        AvgDate = 1,
        AvgTime = 2,
        Count = 3,
        CountDistinct = 4,
        MaxDate = 5,
        MaxTime = 6,
        Max = 7,
        MinDate = 8,
        MinTime = 9,
        Min = 10,
        Median = 11,
        Mode = 12,
        Sum = 13,
        SumTime = 14
    }
    enum StiPageOrientation {
        Portrait = 0,
        Landscape = 1
    }
    enum StiTextQuality {
        Standard = 0,
        Typographic = 1,
        Wysiwyg = 2
    }
    enum StiSystemTextType {
        Totals = 0,
        SystemVariables = 1,
        Expression = 2,
        DataColumn = 3,
        None = 4
    }
    enum StiBrushType {
        Solid = 0,
        Gradient = 1
    }
    enum StiColorScaleType {
        Color2 = 0,
        Color3 = 1
    }
    enum StiDataBarDirection {
        Default = 0,
        LeftToRight = 1,
        RighToLeft = 2
    }
    enum StiDataBarTextPlacement {
        Overlay = 0,
        Inside = 1
    }
    enum StiInteractionSortDirection {
        Ascending = 0,
        Descending = 1,
        None = 2
    }
    enum StiImageRotation {
        None = 0,
        Rotate90CW = 1,
        Rotate90CCW = 2,
        Rotate180 = 3,
        FlipHorizontal = 4,
        FlipVertical = 5
    }
    enum StiDashboardViewMode {
        Desktop = 0,
        Mobile = 1
    }
    enum StiSurfaceViewMode {
        Desktop = 0,
        Mobile = 1
    }
    enum StiSparklineType {
        Line = 0,
        Area = 1,
        Column = 2,
        WinLoss = 3
    }
    enum StiSignatureMode {
        Type = 0,
        Draw = 1
    }
}
export namespace Stimulsoft.Report.Components.TextFormats {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import NumberFormatInfo = Stimulsoft.System.Globalization.NumberFormatInfo;
    import StiTextFormatState = Stimulsoft.Report.Components.StiTextFormatState;
    class StiNumberFormatService extends StiFormatService implements IStiJsonReportObject {
        meta(): StiMeta[];
        clone(): any;
        private bits;
        get nullDisplay(): string;
        set nullDisplay(value: string);
        get negativePattern(): number;
        set negativePattern(value: number);
        get decimalSeparator(): string;
        set decimalSeparator(value: string);
        get decimalDigits(): number;
        set decimalDigits(value: number);
        get groupSeparator(): string;
        set groupSeparator(value: string);
        get groupSize(): number;
        set groupSize(value: number);
        get useGroupSeparator(): boolean;
        set useGroupSeparator(value: boolean);
        get useLocalSetting(): boolean;
        set useLocalSetting(value: boolean);
        private _totalNumberCapacity;
        get totalNumberCapacity(): number;
        set totalNumberCapacity(value: number);
        get sample(): any;
        get nativeFormatString(): string;
        equals(obj: any): boolean;
        get state(): StiTextFormatState;
        set state(value: StiTextFormatState);
        fillLocalSetting(format: NumberFormatInfo): void;
        format(arg: any): string;
        format2(stringFormat: string, arg: any): string;
        constructor();
    }
}
export namespace Stimulsoft.Report.Components.TextFormats {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiCurrencyFormatService extends StiNumberFormatService implements IStiJsonReportObject {
        meta(): StiMeta[];
        positivePattern: number;
        symbol: string;
        get nativeFormatString(): string;
        get sample(): any;
        equals(obj: any): boolean;
        format(arg: any): string;
        format2(stringFormat: string, arg: any): string;
        private formatAsCurrency;
        constructor();
    }
}
export namespace Stimulsoft.Report.Components.TextFormats {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiPercentageFormatService extends StiCurrencyFormatService {
        meta(): StiMeta[];
        format(arg: any): string;
        format2(stringFormat: string, arg: any): string;
        constructor();
    }
}
export namespace Stimulsoft.Report.Components.TextFormats {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiGeneralFormatService extends StiFormatService {
        meta(): StiMeta[];
        get sample(): string;
        equals(obj: any): boolean;
        static default: StiGeneralFormatService;
        constructor();
    }
}
export namespace Stimulsoft.Report.Events {
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiGetValueEventArgs extends EventArgs {
        value: string;
        storeToPrinted: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiEditable: System.Interface<IStiEditable>;
    interface IStiEditable {
        editable: boolean;
        saveState(): string;
        restoreState(value: string): any;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    let IStiText: System.Interface<IStiText>;
    interface IStiText {
        text: string;
        textValue: string;
        setText(getValue: any): any;
        linesOfUnderline: StiPenStyle;
        hideZeros: boolean;
        processingDuplicates: StiProcessingDuplicatesType;
        onlyText: boolean;
        maxNumberOfLines: number;
        getTextInternal(): string;
        setTextInternal(value: string): any;
    }
}
export namespace Stimulsoft.Report.Engine {
    import Exception = Stimulsoft.System.Exception;
    class StiCustomFunctionHelper {
        static checkExceptionForCustomFunction(ex: Exception, report: StiReport, full?: boolean): string;
        private static checkExceptionStackForCustomFunction;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiEditable = Stimulsoft.Report.Components.IStiEditable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiSimpleText extends StiComponent implements IStiText, IStiEditable, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        protected static propertyGlobalizedName: string;
        get globalizedName(): string;
        set globalizedName(value: string);
        clone(cloneProperties?: boolean, cloneComponents?: boolean, base?: boolean): StiSimpleText;
        memberwiseClone(base?: boolean): StiSimpleText;
        getTextWithoutZero(text: string): string;
        setText(getValue?: any, value?: string): void;
        private setTextTo;
        static processEndRenderSetText(report: StiReport): void;
        linesOfUnderline: StiPenStyle;
        get linesOfUnderlining(): boolean;
        set linesOfUnderlining(value: boolean);
        hideZeros: boolean;
        get mergeDuplicates(): boolean;
        set mergeDuplicates(value: boolean);
        private static propertyProcessingDuplicates;
        get processingDuplicates(): StiProcessingDuplicatesType;
        set processingDuplicates(value: StiProcessingDuplicatesType);
        private static propertyMaxNumberOfLines;
        get maxNumberOfLines(): number;
        set maxNumberOfLines(value: number);
        processText(text: string): string;
        private static propertyOnlyText;
        get onlyText(): boolean;
        set onlyText(value: boolean);
        editable: boolean;
        saveState(): string;
        restoreState(value: string): void;
        get processAtEnd(): boolean;
        set processAtEnd(value: boolean);
        protected static propertyProcessAt: string;
        get processAt(): StiProcessAt;
        set processAt(value: StiProcessAt);
        invokeRenderTo(textBox: StiSimpleText): void;
        text: string;
        getTextInternal(): string;
        setTextInternal(value: string): void;
        private _textValue;
        get textValue(): string;
        set textValue(value: string);
        getValueEvent: StiEvent;
        protected onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiComponent, e: StiGetValueEventArgs): void;
        private checkForCustomFormatColor;
        checkDuplicates(sender: StiComponent, e: StiGetValueEventArgs): void;
        invokeTextProcess(sender: StiComponent, e: StiValueEventArgs): void;
        private applyConditionsAssignExpression;
        _totalValueHelp: string;
        get totalValueHelp(): string;
        set totalValueHelp(value: string);
        constructor(rect?: RectangleD, isSuper?: boolean);
        protected construct(rect?: RectangleD): void;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Image = Stimulsoft.System.Drawing.Image;
    import IStiEditable = Stimulsoft.Report.Components.IStiEditable;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    import StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiGetExcelValueEventArgs = Stimulsoft.Report.Events.StiGetExcelValueEventArgs;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    class StiText extends StiSimpleText implements IStiTextOptions, IStiAutoWidth, IStiTextHorAlignment, IStiVertAlignment, IStiBorder, IStiFont, IStiBrush, IStiTextBrush, IStiTextFormat, IStiBreakable, IStiGlobalizationProvider, IStiExportImageExtended, IStiExportImage, IStiEditable, IStiJsonReportObject, IStiGetFonts, IStiCornerRadius {
        implements(): any[];
        meta(): StiMeta[];
        indicator: StiIndicator;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        setString(propertyName: string, value: string): void;
        protected globalizationSetString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        protected globalizationGetString(propertyName: string): string;
        getAllStrings(): string[];
        protected globalizationGetAllStrings(): string[];
        private static propertyCanBreak;
        get canBreak(): boolean;
        set canBreak(value: boolean);
        break(dividedComponent: StiComponent, devideFactor: number, REFdivideLine: any): boolean;
        private static propertyAutoWidth;
        get autoWidth(): boolean;
        set autoWidth(value: boolean);
        protected static propertyRenderTo: string;
        get renderTo(): string;
        set renderTo(value: string);
        invokeRenderTo(textFrom: StiSimpleText): void;
        private getVisibleTextForRenderTo;
        private _horAlignment;
        get horAlignment(): StiTextHorAlignment;
        set horAlignment(value: StiTextHorAlignment);
        private _vertAlignment;
        get vertAlignment(): StiVertAlignment;
        set vertAlignment(value: StiVertAlignment);
        static defaultFont: Font;
        private _font;
        get font(): Font;
        set font(value: Font);
        border: StiBorder;
        brush: StiBrush;
        textBrush: StiBrush;
        private _textFormat;
        get textFormat(): StiFormatService;
        set textFormat(value: StiFormatService);
        format: string;
        textOptions: StiTextOptions;
        cornerRadius: StiCornerRadius;
        clone(cloneProperties?: boolean, cloneComponents?: boolean, base?: boolean): StiText;
        memberwiseClone(base?: boolean): StiText;
        getFonts(): Font[];
        convertTextMargins(rect: RectangleD, convert: boolean): RectangleD;
        convertTextBorders(rect: RectangleD, convert: boolean): RectangleD;
        getTextForPaint(): string;
        getActualSize(): SizeD;
        private rotateSize;
        prepare(): void;
        excelDataValue: string;
        get excelValue(): string;
        set excelValue(value: string);
        invokeEvents(): void;
        getExcelValueEvent: StiEvent;
        protected onGetExcelValue(e: StiGetExcelValueEventArgs): void;
        invokeGetExcelValue(sender: StiComponent, e: StiGetExcelValueEventArgs): void;
        protected static propertyNullValue: string;
        get nullValue(): string;
        set nullValue(value: string);
        protected static propertyType: string;
        get type(): StiSystemTextType;
        set type(value: StiSystemTextType);
        get wordWrap(): boolean;
        set wordWrap(value: boolean);
        get rightToLeft(): boolean;
        set rightToLeft(value: boolean);
        get trimming(): StringTrimming;
        set trimming(value: StringTrimming);
        get angle(): number;
        set angle(value: number);
        private static propertyLineSpacing;
        get lineSpacing(): number;
        set lineSpacing(value: number);
        private static propertyExportAsImage;
        get exportAsImage(): boolean;
        set exportAsImage(value: boolean);
        private static propertyTextQuality;
        get textQuality(): StiTextQuality;
        set textQuality(value: StiTextQuality);
        private static propertyAllowHtmlTags;
        get allowHtmlTags(): boolean;
        set allowHtmlTags(value: boolean);
        margins: StiMargins;
        private static propertyShrinkFontToFit;
        get shrinkFontToFit(): boolean;
        set shrinkFontToFit(value: boolean);
        private static propertyShrinkFontToFitMinimumSize;
        get shrinkFontToFitMinimumSize(): number;
        set shrinkFontToFitMinimumSize(value: number);
        checkAllowHtmlTags(): boolean;
        getActualFont(text: string, minFontSize?: number): Font;
        constructor(rect?: RectangleD, isSuper?: boolean);
        protected construct(rect?: RectangleD): void;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    let IStiTextHorAlignment: System.Interface<IStiTextHorAlignment>;
    let ImplementsIStiTextHorAlignment: any[];
    interface IStiTextHorAlignment {
        horAlignment: StiTextHorAlignment;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    let IStiVertAlignment: System.Interface<IStiVertAlignment>;
    let ImplementsIStiVertAlignment: any[];
    interface IStiVertAlignment {
        vertAlignment: StiVertAlignment;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiCrossTabField: System.Interface<IStiCrossTabField>;
    interface IStiCrossTabField {
    }
}
export namespace Stimulsoft.Report.CrossTab {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiConditionPermissions = Stimulsoft.Report.Components.StiConditionPermissions;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiText = Stimulsoft.Report.Components.StiText;
    import StiRestrictions = Stimulsoft.Report.Components.StiRestrictions;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import IStiBorder = Stimulsoft.Report.Components.IStiBorder;
    import IStiBrush = Stimulsoft.Report.Components.IStiBrush;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import IStiTextBrush = Stimulsoft.Report.Components.IStiTextBrush;
    import IStiTextHorAlignment = Stimulsoft.Report.Components.IStiTextHorAlignment;
    import IStiVertAlignment = Stimulsoft.Report.Components.IStiVertAlignment;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import IStiCrossTabField = Stimulsoft.Report.Components.IStiCrossTabField;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiCrossField extends StiText implements IStiTextHorAlignment, IStiVertAlignment, IStiBorder, IStiFont, IStiBrush, IStiTextBrush, IStiCrossTabField, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        loadFromXml(xmlNode: XmlNode): void;
        clone(cloneProperties?: boolean, cloneComponents?: boolean, base?: boolean): StiCrossField;
        protected get defaultHorAlignment(): StiTextHorAlignment;
        setName(value: string): void;
        get locked(): boolean;
        set locked(value: boolean);
        get linked(): boolean;
        set linked(value: boolean);
        protected onProcessCell(e: StiProcessCellEventArgs): void;
        invokeProcessCell(e: StiProcessCellEventArgs): void;
        processCellEvent: StiEvent;
        get helpUrl(): string;
        toString(): string;
        get localizedCategory(): string;
        getRestrictions(): StiRestrictions;
        setRestrictions(value: StiRestrictions): void;
        getTextBoxFromField(): StiText;
        get cellText(): string;
        mergeHeaders: boolean;
        originalValue: any;
        disabledByCondition: boolean;
        conditionBrush: StiBrush;
        conditionTextBrush: StiBrush;
        conditionPermissions: StiConditionPermissions;
        topNConditions: StiCrossTabTopNConditionList;
        constructor();
    }
}
export namespace Stimulsoft.Report.Dictionary.Design {
    import Type = Stimulsoft.System.Type;
    class StiDataColumnConverter {
        static convertTypeToString(type: Type): string;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import List = Stimulsoft.System.Collections.List;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiAppDataColumn = Stimulsoft.Base.IStiAppDataColumn;
    import Type = Stimulsoft.System.Type;
    import IStiAppAlias = Stimulsoft.Base.IStiAppAlias;
    class StiDataColumn implements IStiJsonReportObject, ICloneable, IStiName, IStiAppDataColumn, IStiAppAlias, IStiInherited {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiDataColumn;
        memberwiseClone(): StiDataColumn;
        getNameInSource(): string;
        getDataType(): Type;
        getName(): string;
        getAlias(): string;
        getKey(): string;
        setKey(key: string): void;
        private _name;
        get name(): string;
        set name(value: string);
        get inherited(): boolean;
        set inherited(value: boolean);
        dataColumnsCollection: StiDataColumnsCollection;
        dataSource: StiDataSource;
        businessObject: StiBusinessObject;
        index: number;
        nameInSource: string;
        alias: string;
        type: Stimulsoft.System.Type;
        key: string;
        getColumnPath(): string;
        toString(): string;
        static getDataColumnFromColumnName(dictionary: StiDictionary, column: string, allowRelationName?: boolean): StiDataColumn;
        static getRelationName(dictionary: StiDictionary, dataSource: StiDataSource, relationName: string): string;
        static getRelation(dictionary: StiDictionary, dataSource: StiDataSource, relationName: string): StiDataRelation;
        static getDataFromBusinessObject(dictionary: StiDictionary, column: string): any;
        static getBusinessObjectFromDataColumn(dictionary: StiDictionary, column: string): StiBusinessObject;
        static getDataFromDataColumn(dictionary: StiDictionary, column: string, useRelationName?: boolean): any;
        static getDataSourceFromDataColumn(dictionary: StiDictionary, column: string): StiDataSource;
        static getColumnNameFromDataColumn(dictionary: StiDictionary, column: string): string;
        static getDataListFromDataColumn(dictionary: StiDictionary, column: string, maxRows?: number, firstPositionInDataSource?: boolean): any[];
        static getDatasFromDataColumn(dictionary: StiDictionary, column: string, maxRows?: number, firstPositionInDataSource?: boolean, useRelationName?: boolean): any[];
        static getDatasFromDataSourceWithExpression(data: any, expression: string, maxRows?: number, firstPositionInDataSource?: boolean): List<string>;
        constructor(nameInSource?: string, name?: string, alias?: string, type?: Stimulsoft.System.Type, key?: string);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Color = Stimulsoft.System.Drawing.Color;
    import Image = Stimulsoft.System.Drawing.Image;
    import List = Stimulsoft.System.Collections.List;
    class StiSparkline extends StiComponent implements IStiExportImageExtended, IStiDataRelation, IStiBorder, IStiBrush {
        implements(): any[];
        meta(): StiMeta[];
        get dataRelation(): StiDataRelation;
        dataRelationName: string;
        getImage(REFzoom: any): Image;
        getImage2(): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        clone(cloneProperties: boolean): StiSparkline;
        brush: StiBrush;
        border: StiBorder;
        get priority(): number;
        get localizedCategory(): string;
        defaultClientRectangle: Rectangle;
        get componentType(): StiComponentType;
        get toolboxPosition(): number;
        toolboxCategory: () => StiToolboxCategory;
        get localizedName(): string;
        helpUrl: () => string;
        fetchValues(): List<any>;
        getDataSource(): StiDataSource;
        private _valueDataColumn;
        get valueDataColumn(): string;
        set valueDataColumn(value: string);
        _values: number[];
        get values(): number[];
        set values(value: number[]);
        get valuesContainer(): string;
        set valuesContainer(value: string);
        type: StiSparklineType;
        showHighLowPoints: boolean;
        showFirstLastPoints: boolean;
        positiveColor: Color;
        negativeColor: Color;
        protected construct(rect?: Rectangle): void;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiComponentBuilder extends StiBuilder {
        setReportVariables(masterComp: StiComponent): void;
        prepare(masterComp: StiComponent): void;
        unPrepare(masterComp: StiComponent): void;
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
        renderAsync(masterComp: StiComponent): Promise<StiComponent>;
        render(masterComp: StiComponent): StiComponent;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiPrintIfEmpty: System.Interface<IStiPrintIfEmpty>;
    interface IStiPrintIfEmpty {
        printIfEmpty: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    let IStiDataRelation: System.Interface<IStiDataRelation>;
    interface IStiDataRelation {
        dataRelation: StiDataRelation;
        dataRelationName: string;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiSort: System.Interface<IStiSort>;
    interface IStiSort {
        sort: string[];
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiCrossTab: System.Interface<IStiCrossTab>;
    interface IStiCrossTab {
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiFilter: System.Interface<IStiFilter>;
    interface IStiFilter {
        filterMethodHandler: Function;
        filterMode: StiFilterMode;
        filters: StiFiltersCollection;
        filterOn: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    let IStiDataSource: System.Interface<IStiDataSource>;
    interface IStiDataSource {
        dataSource: StiDataSource;
        dataSourceName: string;
        isDataSourceEmpty: boolean;
        first(): any;
        prior(): any;
        next(): any;
        last(): any;
        position: number;
        count: number;
        isEof: boolean;
        isBof: boolean;
        isEmpty: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    let IStiBusinessObject: System.Interface<IStiBusinessObject>;
    interface IStiBusinessObject {
        businessObject: StiBusinessObject;
        businessObjectGuid: string;
        isBusinessObjectEmpty: boolean;
        first(): any;
        prior(): any;
        next(): any;
        last(): any;
        position: number;
        count: number;
        isEof: boolean;
        isBof: boolean;
        isEmpty: boolean;
    }
}
export namespace Stimulsoft.Report.Events {
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiFillParametersEventArgs extends EventArgs {
        value: Array<{
            key: string;
            value: any;
        }>;
        constructor(value?: Array<{
            key: string;
            value: any;
        }>);
    }
}
export namespace Stimulsoft.Report {
    let IStiGlobalizationProvider: System.Interface<IStiGlobalizationProvider>;
    interface IStiGlobalizationProvider {
        setString(propertyName: string, value: string): any;
        getString(propertyName: string): string;
        getAllStrings(): string[];
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiResetPageNumber: System.Interface<IStiResetPageNumber>;
    interface IStiResetPageNumber {
        resetPageNumber: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    import PaperKind = Stimulsoft.System.Drawing.Printing.PaperKind;
    import PaperSize = Stimulsoft.System.Drawing.Printing.PaperSize;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiPageHelper {
        static getPaperSizeFromPaperKind(paperKind: PaperKind): PaperSize;
        static getPaperSize(page: StiPage, paperSize: PaperSize): SizeD;
    }
}
export namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiMargins implements IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode, defLeft?: number, defRight?: number, defTop?: number, defBotttom?: number): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromText(text: string): StiMargins;
        static loadFromXml(xmlNode: XmlNode): StiMargins;
        clone(): any;
        equals(obj: any): boolean;
        left: number;
        right: number;
        top: number;
        bottom: number;
        get isEmpty(): boolean;
        static get empty(): StiMargins;
        static create(all?: number): StiMargins;
        constructor(left?: number, right?: number, top?: number, bottom?: number);
    }
}
export namespace Stimulsoft.Report.Engine {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiComponentInfo implements ICloneable {
        implements(): any[];
        clone(): StiComponentInfo;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiPageInfo extends StiComponentInfo {
        overlays: StiComponentsCollection;
        indexOfStartRenderedPages: number;
        masterDataBand: StiDataBand;
        isReportTitlesRendered: boolean;
        renderedCount: number;
        positionFromTop: number;
        positionFromBottom: number;
    }
}
export namespace Stimulsoft.Report.Units {
    import IAsIs = Stimulsoft.System.IAsIs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Size = Stimulsoft.System.Drawing.Size;
    class StiUnit implements IAsIs {
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        static saveToJsonObject(unit: StiUnit): StiJson;
        static loadFromJsonObject(jObject: StiJson): StiUnit;
        static loadFromXml(xmlNode: XmlNode): StiUnit;
        static getUnitFromReportUnit(reportUnit: StiReportUnitType): StiUnit;
        private static _centimeters;
        static get Centimeters(): StiCentimetersUnit;
        private static _hundredthsOfInch;
        static get HundredthsOfInch(): StiHundredthsOfInchUnit;
        private static _inches;
        static get Inches(): StiInchesUnit;
        private static _millimeters;
        static get Millimeters(): StiMillimetersUnit;
        get rulerStep(): number;
        get factor(): number;
        get shortName(): string;
        get name(): string;
        convertToHInches(value: number): number;
        convertFromHInches(value: number): number;
        convertRectangleToHInches(rect: Rectangle): Rectangle;
        convertRectangleFromHInches(rect: Rectangle): Rectangle;
        convertSizeToHInches(size: Size): Size;
        convertSizeFromHInches(size: Size): Size;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ContentAlignment = Stimulsoft.System.Drawing.ContentAlignment;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiWatermark implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiWatermark;
        font: Font;
        textBrush: StiBrush;
        text: string;
        angle: number;
        enabled: boolean;
        showImageBehind: boolean;
        showBehind: boolean;
        rightToLeft: boolean;
        imageMultipleFactor: number;
        private _imageTransparency;
        get imageTransparency(): number;
        set imageTransparency(value: number);
        private _image;
        get image(): Image;
        set image(value: Image);
        private _imageHyperlink;
        get imageHyperlink(): string;
        set imageHyperlink(value: string);
        private cachedImage;
        getImage(report: StiReport): Image;
        imageAlignment: ContentAlignment;
        imageTiling: boolean;
        imageStretch: boolean;
        aspectRatio: boolean;
        enabledExpression: string;
        private getTransparentedImage;
        private disposeCachedImage;
        resetImage(): void;
        constructor(textBrush?: StiBrush, text?: string, angle?: number, font?: Font, showBehind?: boolean, enabled?: boolean, aspectRatio?: boolean, rightToLeft?: boolean);
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiBreakable: System.Interface<IStiBreakable>;
    interface IStiBreakable {
        canBreak: boolean;
        break(dividedComponent: StiComponent, devideFactor: number, REFdivideLine: any): boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiBreakable = Stimulsoft.Report.Components.IStiBreakable;
    class StiPanel extends StiContainer implements IStiBreakable, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        rightToLeft: boolean;
        columnGaps: number;
        columnWidth: number;
        columns: number;
        gapAfterLastColumn: boolean;
        getColumnWidth(): number;
    }
}
export namespace Stimulsoft.Report.Events {
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiGetExcelSheetEventArgs extends EventArgs {
        value: string;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetExcelSheetEventArgs = Stimulsoft.Report.Events.StiGetExcelSheetEventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiShiftMode = Stimulsoft.Report.Components.StiShiftMode;
    import StiMargins = Stimulsoft.Report.Components.StiMargins;
    import StiPageInfo = Stimulsoft.Report.Components.StiPageInfo;
    import StiPageOrientation = Stimulsoft.Report.Components.StiPageOrientation;
    import StiWatermark = Stimulsoft.Report.Components.StiWatermark;
    import PaperKind = Stimulsoft.System.Drawing.Printing.PaperKind;
    import IStiResetPageNumber = Stimulsoft.Report.Components.IStiResetPageNumber;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiReportPage = Stimulsoft.Base.IStiReportPage;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiPage extends StiPanel implements IStiResetPageNumber, IStiReportPage, IStiJsonReportObject, IStiGlobalizationProvider {
        implements(): any[];
        meta(): StiMeta[];
        loadFromXml(xmlNode: XmlNode): void;
        resetPageNumber: boolean;
        convertToHInches(unit: StiUnit, value: number): number;
        convertFromHInchesRect(unit: StiUnit, rect: RectangleD): RectangleD;
        convertFromHInches(unit: StiUnit, value: number): number;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        parseExpression(text: string, allowReturnNull?: boolean): string;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        private _pageInfo;
        get pageInfo(): StiPageInfo;
        get isAutomaticDock(): boolean;
        get left(): number;
        set left(value: number);
        get top(): number;
        set top(value: number);
        getWidth(): number;
        setWidth(value: number): void;
        getHeight(): number;
        setHeight(value: number): void;
        get right(): number;
        get bottom(): number;
        get clientRectangle(): RectangleD;
        set clientRectangle(value: RectangleD);
        getDisplayRectangle(): RectangleD;
        get shiftMode(): StiShiftMode;
        set shiftMode(value: StiShiftMode);
        get printable(): boolean;
        set printable(value: boolean);
        get page(): StiPage;
        set page(value: StiPage);
        get parent(): StiContainer;
        set parent(value: StiContainer);
        invokeEvents(): void;
        beginRenderEvent: StiEvent;
        protected onBeginRender(): void;
        invokeBeginRender(): void;
        renderingEvent: StiEvent;
        protected onRendering(): void;
        invokeRendering(): void;
        endRenderEvent: StiEvent;
        protected onEndRender(): void;
        invokeEndRender(): void;
        columnBeginRenderEvent: StiEvent;
        protected onColumnBeginRender(): void;
        invokeColumnBeginRender(sender?: any): void;
        columnEndRenderEvent: StiEvent;
        protected onColumnEndRender(): void;
        invokeColumnEndRender(sender?: any): void;
        getExcelSheetEvent: StiEvent;
        protected onGetExcelSheet(e: StiGetExcelSheetEventArgs): void;
        invokeGetExcelSheet(sender: StiComponent, e: StiGetExcelSheetEventArgs): void;
        excelSheetValue: string;
        excelSheet: string;
        get zoom(): number;
        get gridSize(): number;
        printOnPreviousPage: boolean;
        printHeadersFootersFromPreviousPage: boolean;
        private _paperSizeFromPaperKind;
        private _paperSize;
        get paperSize(): PaperKind;
        set paperSize(value: PaperKind);
        paperSourceOfFirstPage: string;
        paperSourceOfOtherPages: string;
        private _watermarkStyle;
        get watermarkStyle(): string;
        set watermarkStyle(value: string);
        private _numberOfCopies;
        get numberOfCopies(): number;
        set numberOfCopies(value: number);
        unlimitedBreakable: boolean;
        largeHeight: boolean;
        private _largeHeightFactor;
        get largeHeightFactor(): number;
        set largeHeightFactor(value: number);
        private _largeHeightAutoFactor;
        get largeHeightAutoFactor(): number;
        set largeHeightAutoFactor(value: number);
        currentWidthSegment: number;
        currentHeightSegment: number;
        stopBeforePrint: number;
        shrinkToFit: boolean;
        private _skip;
        get skip(): boolean;
        set skip(value: boolean);
        stretchToPrintArea: boolean;
        private _titleBeforeHeader;
        get titleBeforeHeader(): boolean;
        set titleBeforeHeader(value: boolean);
        unlimitedHeight: boolean;
        unlimitedWidth: boolean;
        offsetRectangle: RectangleD;
        private _orientation;
        get orientation(): StiPageOrientation;
        set orientation(value: StiPageOrientation);
        get locked(): boolean;
        set locked(value: boolean);
        get linked(): boolean;
        set linked(value: boolean);
        private _pageWidth;
        get pageWidth(): number;
        set pageWidth(value: number);
        private _pageHeight;
        get pageHeight(): number;
        set pageHeight(value: number);
        private _segmentPerWidth;
        get segmentPerWidth(): number;
        set segmentPerWidth(value: number);
        private _segmentPerHeight;
        get segmentPerHeight(): number;
        set segmentPerHeight(value: number);
        private _watermark;
        get watermark(): StiWatermark;
        set watermark(value: StiWatermark);
        margins: StiMargins;
        mirrorMargins: boolean;
        icon: number[];
        private _report;
        get report(): StiReport;
        set report(value: StiReport);
        get unit(): StiUnit;
        reportUnit: StiUnit;
        drillDownActivated: boolean;
        get isDashboard(): boolean;
        get isPage(): boolean;
        private _cacheGuid;
        get cacheGuid(): string;
        set cacheGuid(value: string);
        newCacheGuid(): void;
        prepare(): void;
        private getIsPageTotalDataBand;
        clearPage(): void;
        private shrinkPageToFit;
        disposeImagesAndClearComponents(): void;
        private removeNewPageContainers;
        private getComponentsCount2;
        getComponentsCount(): number;
        resizePage(factorX: number, factorY: number, allowPageMarginsRescaling?: boolean): void;
        toString(): string;
        constructor(report?: StiReport, isSuper?: boolean);
        protected construct(report?: StiReport | any): void;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiChildBand extends StiDynamicBand implements IStiKeepChildTogether, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        keepChildTogether: boolean;
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        protected getComponentType(): StiComponentType;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get priority(): number;
        printIfParentDisabled: boolean;
        getMaster(): StiBand;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiRenderMaster: System.Interface<IStiRenderMaster>;
    interface IStiRenderMaster {
        renderMasterAsync(): Promise<void>;
        renderMaster(): void;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiSubReport = Stimulsoft.Report.Components.StiSubReport;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiSubReportsHelper {
        static getMasterDataBand(parent: StiContainer): StiDataBand;
        static getParentBand(parent: StiContainer): StiBand;
        static renderSubReportAsync(containerOfSubReport: StiContainer, subReport: StiSubReport): Promise<void>;
        static renderSubReport(containerOfSubReport: StiContainer, subReport: StiSubReport): void;
        private static correctComponentRecursive;
        static specialSubReportHeight: number;
        private static renderInternalSubReportAsync;
        private static renderInternalSubReport;
        static renderExternalSubReportsWithoutHelpOfUnlimitedHeightPagesOldMode: boolean;
        static StiSubReportIdObject: any;
        private static renderExternalSubReportAsync;
        private static renderExternalSubReport;
        static renderDataBandsInContainerAsync(containerOfDataBands: StiContainer, container: StiContainer, skipStaticBands?: boolean): Promise<void>;
        static renderDataBandsInContainer(containerOfDataBands: StiContainer, container: StiContainer, skipStaticBands?: boolean): void;
    }
}
export namespace Stimulsoft.Report.Styles {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiTitleStyle: System.Interface<IStiTitleStyle>;
    interface IStiTitleStyle {
        allowUseTitle: boolean;
        titleForeColor: Color;
        titleBackColor: Color;
        titleFont: Font;
    }
}
export namespace Stimulsoft.Report.Styles {
    import Font = Stimulsoft.System.Drawing.Font;
    let IStiFontStyle: System.Interface<IStiFontStyle>;
    interface IStiFontStyle {
        allowUseFont: boolean;
        font: Font;
    }
}
export namespace Stimulsoft.Report.Styles {
    import IStiFontStyle = Stimulsoft.Report.Styles.IStiFontStyle;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCrossTabStyle extends StiBaseStyle implements IStiTitleStyle, IStiFontStyle, IStiGetFonts, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        backColor: Color;
        get color(): Color;
        set color(value: Color);
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        columnHeaderBackColor: Color;
        columnHeaderForeColor: Color;
        rowHeaderBackColor: Color;
        rowHeaderForeColor: Color;
        hotColumnHeaderBackColor: Color;
        hotRowHeaderBackColor: Color;
        cellForeColor: Color;
        lineColor: Color;
        _totalCellColumnBackColor: any;
        get totalCellColumnBackColor(): Color;
        set totalCellColumnBackColor(value: Color);
        _totalCellColumnForeColor: any;
        get totalCellColumnForeColor(): Color;
        set totalCellColumnForeColor(value: Color);
        _totalCellRowBackColor: any;
        get totalCellRowBackColor(): Color;
        set totalCellRowBackColor(value: Color);
        _totalCellRowForeColor: any;
        get totalCellRowForeColor(): Color;
        set totalCellRowForeColor(value: Color);
        getFonts(): Font[];
        allowUseFont: boolean;
        font: Font;
        allowUseTitle: boolean;
        titleForeColor: Color;
        titleBackColor: Color;
        titleFont: Font;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
    }
}
export namespace Stimulsoft.Report.CrossTab.Core {
    enum StiSortDirection {
        Asc = 0,
        Desc = 1,
        None = 2
    }
    enum StiSummaryType {
        None = 0,
        Sum = 1,
        Average = 2,
        Min = 3,
        Max = 4,
        Count = 5,
        CountDistinct = 6,
        Image = 7,
        Median = 8
    }
    enum StiSummaryValues {
        AllValues = 0,
        SkipZerosAndNulls = 1,
        SkipNulls = 2
    }
    enum StiSortType {
        ByValue = 0,
        ByDisplayValue = 1
    }
    enum StiFieldType {
        Column = 0,
        Row = 1,
        Cell = 2
    }
    enum StiSummaryDirection {
        LeftToRight = 0,
        UpToDown = 1
    }
    enum StiEnumeratorType {
        None = 0,
        Arabic = 1,
        Roman = 2,
        ABC = 3
    }
    enum StiEnumeratorSeparator {
        Dot = 0,
        Dash = 1,
        Colon = 2,
        RoundBrackets = 3,
        SquareBrackets = 4
    }
    enum StiCellType {
        HeaderCol = 0,
        HeaderColMain = 1,
        HeaderColTotal = 2,
        HeaderColTotalMain = 3,
        HeaderColSummary = 4,
        HeaderColSummaryTotal = 5,
        HeaderRow = 6,
        HeaderRowMain = 7,
        HeaderRowTotal = 8,
        HeaderRowTotalMain = 9,
        HeaderRowSummary = 10,
        HeaderRowSummaryTotal = 11,
        Cell = 12,
        CellTotal = 13,
        LeftTopLine = 14,
        LeftTopLineMain = 15,
        RightTopLine = 16,
        RightTopLineMain = 17,
        CornerCol = 18,
        CornerColMain = 19,
        CornerRow = 20,
        CornerRowMain = 21
    }
}
export namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFilter implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiFilter;
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        condition: StiFilterCondition;
        dataType: StiFilterDataType;
        column: string;
        item: StiFilterItem;
        private valueObj1;
        get value1(): string;
        set value1(value: string);
        private valueObj2;
        get value2(): string;
        set value2(value: string);
        expression: string;
        constructor(item?: StiFilterItem, column?: string, condition?: StiFilterCondition, value1?: string, value2?: string, dataType?: StiFilterDataType, expression?: string);
    }
}
export namespace Stimulsoft.Report.CrossTab {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import StiComponentType = Stimulsoft.Report.Components.StiComponentType;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiSummaryDirection = Stimulsoft.Report.CrossTab.Core.StiSummaryDirection;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import StiFilterEngine = Stimulsoft.Report.Components.StiFilterEngine;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import IStiDataSource = Stimulsoft.Report.Components.IStiDataSource;
    import IStiFilter = Stimulsoft.Report.Components.IStiFilter;
    import IStiCrossTab = Stimulsoft.Report.Components.IStiCrossTab;
    import IStiSort = Stimulsoft.Report.Components.IStiSort;
    import IStiDataRelation = Stimulsoft.Report.Components.IStiDataRelation;
    import IStiPrintIfEmpty = Stimulsoft.Report.Components.IStiPrintIfEmpty;
    import IStiBusinessObject = Stimulsoft.Report.Components.IStiBusinessObject;
    class StiCrossTab extends StiContainer implements IStiDataSource, IStiFilter, IStiCrossTab, IStiSort, IStiDataRelation, IStiPrintIfEmpty, IStiBusinessObject, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        get helpUrl(): string;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        printIfEmpty: boolean;
        get dataRelation(): StiDataRelation;
        dataRelationName: string;
        get dataSource(): StiDataSource;
        private _dataSourceName;
        get dataSourceName(): string;
        set dataSourceName(value: string);
        get isDataSourceEmpty(): boolean;
        get isBusinessObjectEmpty(): boolean;
        get businessObject(): StiBusinessObject;
        private _businessObjectGuid;
        get businessObjectGuid(): string;
        set businessObjectGuid(value: string);
        private _sort;
        get sort(): string[];
        set sort(value: string[]);
        get canBreak(): boolean;
        set canBreak(value: boolean);
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        get isEof(): boolean;
        set isEof(value: boolean);
        get isBof(): boolean;
        set isBof(value: boolean);
        get isEmpty(): boolean;
        get position(): number;
        set position(value: number);
        get count(): number;
        clone(): StiCrossTab;
        packService(): void;
        crossTabInfo: StiCrossTabInfo;
        filterEngine: StiFilterEngine;
        filterMode: StiFilterMode;
        filterMethodHandler: Function;
        private _filters;
        get filters(): Stimulsoft.Report.Components.StiFiltersCollection;
        set filters(value: Stimulsoft.Report.Components.StiFiltersCollection);
        get filter(): string;
        set filter(value: string);
        filterOn: boolean;
        canContainIn(component: StiComponent): boolean;
        get localizedCategory(): string;
        get priority(): number;
        defaultClientRectangle: RectangleD;
        get componentType(): StiComponentType;
        get localizedName(): string;
        private _crossTabStyleIndex;
        get crossTabStyleIndex(): number;
        set crossTabStyleIndex(value: number);
        crossTabStyleColor: any;
        get crossTabStyle(): string;
        set crossTabStyle(value: string);
        setComponentStyle(value: string): void;
        updateStyles(rewriteDefaultStyle?: boolean): void;
        getCellColor(): Color;
        applyFieldStyle(field: StiCrossField, rewriteDefaultStyle?: boolean): void;
        horAlignment: StiCrossHorAlignment;
        printTitleOnAllPages: boolean;
        summaryDirection: StiSummaryDirection;
        keepCrossTabTogether: boolean;
        emptyValue: string;
        wrap: boolean;
        wrapGap: number;
        private _rightToLeft;
        get rightToLeft(): boolean;
        set rightToLeft(value: boolean);
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiGroupHeaderBand extends StiDynamicBand implements IStiGroup, IStiPrintOnAllPages, IStiKeepGroupTogether, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        clone(cloneProperties: boolean, cloneComponents: boolean): StiGroupHeaderBand;
        keepGroupHeaderTogether: boolean;
        keepGroupTogether: boolean;
        private _startNewPage;
        get startNewPage(): boolean;
        set startNewPage(value: boolean);
        get startNewPageIfLessThan(): number;
        set startNewPageIfLessThan(value: number);
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        sortDirection: StiGroupSortDirection;
        summarySortDirection: StiGroupSortDirection;
        summaryType: StiGroupSummaryType;
        private _printOnAllPages;
        get printOnAllPages(): boolean;
        set printOnAllPages(value: boolean);
        private _groupHeaderBandInfo;
        get groupHeaderBandInfo(): StiGroupHeaderBandInfo;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        protected getComponentType(): StiComponentType;
        get priority(): number;
        getDataBand(): StiDataBand;
        line: number;
        getSummaryExpressionEvent: StiEvent;
        protected onGetSummaryExpression(e: StiValueEventArgs): void;
        invokeGetSummaryExpression(e: StiValueEventArgs): void;
        getValueEvent: StiEvent;
        protected onGetValue(e: StiValueEventArgs): void;
        invokeGetValue(e: StiValueEventArgs): void;
        getCollapsedEvent: StiEvent;
        protected onGetCollapsed(e: StiValueEventArgs): void;
        invokeGetCollapsed(e: StiValueEventArgs): void;
        beginRenderEvent: StiEvent;
        protected onBeginRender(): void;
        invokeBeginRender(): void;
        renderingEvent: StiEvent;
        protected onRendering(): void;
        invokeRendering(): void;
        endRenderEvent: StiEvent;
        protected onEndRender(): void;
        invokeEndRender(): void;
        private _condition;
        get condition(): string;
        set condition(value: string);
        private _summaryExpression;
        get summaryExpression(): string;
        set summaryExpression(value: string);
        private _collapsed;
        get collapsed(): string;
        set collapsed(value: string);
        getHeaderText(): string;
        getCurrentConditionValue(): any;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiContainerBuilder extends StiComponentBuilder {
        static getRenderContainer(comp: StiComponent, type?: Stimulsoft.System.Type): StiContainer;
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiBandBuilder extends StiContainerBuilder {
        static getChildBands(masterBand: StiBand): StiComponentsCollection;
        static getSubReports(masterBand: StiBand): StiComponentsCollection;
        prepare(masterComp: StiComponent): void;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiGroupHeaderBand = Stimulsoft.Report.Components.StiGroupHeaderBand;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiGroupHeaderBandBuilder extends StiBandBuilder {
        static getMaster(masterGroupHeaderBand: StiGroupHeaderBand): StiDataBand;
        static getCurrentConditionValue(masterGroupHeaderBand: StiGroupHeaderBand): any;
        static getCurrentSummaryExpressionValue(masterGroupHeaderBand: StiGroupHeaderBand): any;
        setReportVariables(masterComp: StiComponent): void;
        prepare(masterComp: StiComponent): void;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHierarchicalBand extends StiDataBand implements IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        keyDataColumn: string;
        masterKeyDataColumn: string;
        parentValue: string;
        indent: number;
        headers: string;
        footers: string;
        private _hierarchicalBandInfo;
        get hierarchicalBandInfo(): StiHierarchicalBandInfo;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiAppCell = Stimulsoft.Base.IStiAppCell;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import DataRow = Stimulsoft.System.Data.DataRow;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import Type = Stimulsoft.System.Type;
    import ICloneable = Stimulsoft.System.ICloneable;
    import List = Stimulsoft.System.Collections.List;
    import IEnumerator = Stimulsoft.System.Collections.IEnumerator;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiDataCollection = Stimulsoft.Report.Dictionary.StiDataCollection;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import StiPromise = Stimulsoft.System.StiPromise;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import IStiAppDataColumn = Stimulsoft.Base.IStiAppDataColumn;
    import IStiAppConnection = Stimulsoft.Base.IStiAppConnection;
    import IStiAppDataRelation = Stimulsoft.Base.IStiAppDataRelation;
    class StiDataSource implements ICloneable, IStiAppCell, IStiAppDataSource, IStiStateSaveRestore, IStiEnumerator, IStiName, IStiAlias, IStiInherited, IStiJsonReportObject {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        getNameInSource(): string;
        getName(): string;
        getDataTable2(allowConnectToData: boolean): DataTable;
        getDataTable2Async(allowConnectToData: boolean): Promise<DataTable>;
        private connectSqlSource;
        private connectSqlSourceAsync;
        getDictionary(): IStiAppDictionary;
        fetchColumns(): List<IStiAppDataColumn>;
        getConnection(): IStiAppConnection;
        fetchParentRelations(activePreferred: boolean): List<IStiAppDataRelation>;
        fetchChildRelations(activePreferred: boolean): List<IStiAppDataRelation>;
        fetchColumnValues(names: List<string>): List<any[]>;
        fetchColumnValuesAsync(names: List<string>): Promise<List<any[]>>;
        getKey(): string;
        setKey(key: string): void;
        inherited: boolean;
        get current(): any;
        moveNext(): boolean;
        reset(): void;
        getEnumerator(): IEnumerator;
        private _name;
        get name(): string;
        set name(value: string);
        protected positionValue: number;
        get position(): number;
        set position(value: number);
        get realCount(): number;
        get count(): number;
        protected isBofValue: boolean;
        get isBof(): boolean;
        set isBof(value: boolean);
        protected isEofValue: boolean;
        get isEof(): boolean;
        set isEof(value: boolean);
        get isEmpty(): boolean;
        firstAsync(): Promise<void>;
        first(): void;
        prior(): void;
        nextAsync(): Promise<void>;
        next(): void;
        last(): void;
        clone(): StiDataSource;
        memberwiseClone(): StiDataSource;
        private _states;
        protected get states(): StiStatesManager;
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        clearAllStates(): void;
        convertDataColumnType(dataTable: DataTable): void;
        private nameOfDataBandWhichInitDataSource;
        isInited: boolean;
        initForSubreport: boolean;
        xmlRefAttrValue: string;
        private relationNameStored;
        private resFilterMethod;
        private resSortColumns;
        private isEqualSort;
        setDataAsync(dataBand: StiDataBand, relationName: string, filterMethod: any, sortColumns: string[], reinit: boolean, component: StiComponent, allowReconnectOnEachRow?: boolean): Promise<void>;
        setData(dataBand: StiDataBand, relationName: string, filterMethod: any, sortColumns: string[], reinit: boolean, component: StiComponent, allowReconnectOnEachRow?: boolean): void;
        private filtersEqual;
        getConditions(dataBand: StiDataBand): any[][][];
        setDetailsAsync(relationName: string): Promise<void>;
        setDetails(relationName: string): void;
        setFilter(filterMethod: any): void;
        setSort(conditions: any[][][], sortColumns: string[], component: StiComponent, databand: StiDataBand, groupHeaders: StiComponentsCollection): void;
        resetDetailsRows(): void;
        resetData(): void;
        getDataRow(index: number): DataRow;
        getParentData(relation: string): StiDataRow;
        getParentRelations(): Stimulsoft.Report.Dictionary.StiDataRelationsCollection;
        getChildRelations(): Stimulsoft.Report.Dictionary.StiDataRelationsCollection;
        getParentDataSource(relationName: string, allowRelationName?: boolean): StiDataSource;
        getChildDataSource(relationName: string): StiDataSource;
        parseSqlQuery(baseSqlCommand: string, dataSource: StiSqlSource): string;
        protected invokeConnecting(): void;
        protected invokeDisconnecting(): void;
        connectAsync(datas: StiDataCollection, loadData: boolean): StiPromise<void>;
        connect(datas: StiDataCollection, loadData: boolean): void;
        getParsedSqlCommand(): string;
        protected getDataAdapterType(): Type;
        fillColumns(): void;
        getDataAdapter(): StiDataAdapterService;
        parameters: StiDataParametersCollection;
        getDataTable(table?: DataTable): DataTable;
        getByName(columnName: string): any;
        GetData(columnName: string, index?: number): any;
        getData(columnName: string, index?: number): any;
        getDataAsync(columnName: string, index?: number): Promise<any>;
        getColumnIndex(columnName: string): number;
        rows: StiRowsCollection;
        columnsIndexs: Hashtable<string, number>;
        calcColumns: Hashtable<string, StiCalcDataColumn>;
        detailRows: DataRow[];
        rowToLevel: Hashtable;
        synchronizeColumns(): void;
        checkColumnsIndexs(): void;
        toString(): string;
        getLevel(): number;
        getCategoryName(): string;
        private _isCloud;
        get isCloud(): boolean;
        dictionary: StiDictionary;
        private _dataTable;
        get dataTable(): Stimulsoft.System.Data.DataTable;
        set dataTable(value: Stimulsoft.System.Data.DataTable);
        get isConnected(): boolean;
        private _columns;
        get columns(): StiDataColumnsCollection;
        set columns(value: StiDataColumnsCollection);
        connectionOrder: number;
        disconnect(): void;
        connectOnStart: boolean;
        getByColumnName(columnName: string): any;
        alias: string;
        key: string;
        parentRelationList(activePreferred?: boolean): List<StiDataRelation>;
        childRelationList(activePreferred?: boolean): List<StiDataRelation>;
        constructor(name: string, alias: string, key?: string);
    }
}
export namespace Stimulsoft.Report.Func {
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    import ResourceManager = Stimulsoft.System.ResourceManager;
    import DateTime = Stimulsoft.System.DateTime;
    enum Gender {
        Masculine = 0,
        Feminine = 1,
        Neutral = 2
    }
    class BaseCurrency {
        get gender(): Gender;
        get centsGender(): Gender;
    }
    class Currency extends BaseCurrency {
        get dollars(): string[];
        get cents(): string[];
        get dollarOne(): string;
        get dollarTwo(): string;
        get dollarFive(): string;
        get centOne(): string;
        get centTwo(): string;
        get centFive(): string;
    }
    class NumToWordHelper {
        static maxValue: number;
        private static addWord;
        static addWords(integerString: string, decimalString: string, mainCurrency: string, centCurrency: string, postCurrency: string): string;
        static determinateCurrencies(culture: CultureInfo, currencyISO: string, integerPart: number, decimalPart: number, REFmainCurrency: any, REFcentCurrency: any): void;
    }
    function NumToWordException(message: string, num: number): string;
    class Resource {
        private static resourceMan;
        private static resourceCulture;
        static get resourceManager(): ResourceManager;
        static get culture(): CultureInfo;
        static set culture(value: CultureInfo);
        static get eurBigSeparator(): string;
        static get eurCentGender(): string;
        static get eurCentPlural(): string;
        static get EURCentSingle(): string;
        static get EURGender(): string;
        static get EURPlural(): string;
        static get EURSingle(): string;
        static get GBPBigSeparator(): string;
        static get GBPCentGender(): string;
        static get GBPCentPlural(): string;
        static get GBPCentSingle(): string;
        static get GBPGender(): string;
        static get GBPPlural(): string;
        static get GBPSingle(): string;
        static get TooLongError(): string;
    }
    class Convert {
        static toRoman(value: number): string;
        static toABC(value: number): string;
        static toABCNumeric(value: number): string;
        static toABCRu(value: number): string;
        static toArabic(value: number | string, useEasternDigits: boolean): string;
    }
    class EngineHelper {
        static joinColumnContent(source: StiBusinessObject | StiDataSource, columnName: string, delimiter: string, distinct?: boolean): string;
        static toQueryString<T>(list: T[], quotationMark: string, dateTimeFormat: string, needEscape?: boolean): string;
        static getRealPageNumber(sender: object): number;
    }
    class MonthToStr {
        private static months;
        private static defaultUpperCaseList;
        private static cultureIndexes;
        static monthName(dateTime: DateTime, cultureOrIsLocalized?: string | boolean, upperCase?: boolean): string;
        static addCulture(monthsNames: string[], cultureNames: string[], defaultUpperCase: boolean): void;
        static MonthToStr(): void;
    }
    class DayOfWeekToStr {
        private static days;
        private static defaultUpperCaseList;
        private static cultureIndexes;
        static dayOfWeek(date: DateTime, cultureOrLocalized?: string | boolean, upperCase?: boolean): string;
        static addCulture(monthsNames: string[], cultureNames: string[], defaultUpperCase: boolean): void;
        static DayOfWeekToStr(): void;
    }
}
export namespace Stimulsoft.Report {
    let IStiAlias: System.Interface<IStiName>;
    interface IStiAlias {
        alias: string;
    }
}
export namespace Stimulsoft.Report {
    let IStiIgnoryStyle: System.Interface<IStiIgnoryStyle>;
    interface IStiIgnoryStyle {
    }
}
export namespace Stimulsoft.Report {
    let IStiInherited: System.Interface<IStiInherited>;
    interface IStiInherited {
        inherited: boolean;
    }
}
export namespace Stimulsoft.Report {
    let IStiName: System.Interface<IStiName>;
    interface IStiName {
        name: string;
    }
}
export namespace Stimulsoft.Report {
    let IStiStateSaveRestore: System.Interface<IStiStateSaveRestore>;
    interface IStiStateSaveRestore {
        saveState(stateName: string): any;
        restoreState(stateName: string): any;
        clearAllStates(): any;
    }
}
export namespace Stimulsoft.Report {
    class StiCells {
        clear(): void;
        private getRow;
        private rows;
        gett(x: number, y: number): number;
        distX: number;
        distY: number;
        setCell(x: number, y: number, value: number): void;
        private report;
        constructor(report: StiReport);
    }
}
export namespace Stimulsoft.Report.Components {
    class StiBaseCondition extends StiFilter {
        implements(): any[];
        tag: any;
        constructor(item?: StiFilterItem, column?: string, condition?: StiFilterCondition, value1?: string, value2?: string, dataType?: StiFilterDataType, expression?: string);
    }
}
export namespace Stimulsoft.Report {
    import StiConditionsCollection = Stimulsoft.Report.Components.StiConditionsCollection;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiConditionsHelper {
        static getConditions(comps: StiComponentsCollection, REFglobalConditions?: any): StiConditionsCollection;
        static setConditions(comps: StiComponentsCollection, conditions: StiConditionsCollection, globalConditions: Hashtable): void;
        private static setConditionAllComponents;
    }
}
export namespace Stimulsoft.Report {
    class StiDpiHelper {
        private static LOGPIXELSX;
        private static LOGPIXELSY;
        private static _deviceCapsDpi;
        private static _graphicsDpi;
        private static _graphicsRichTextDpi;
        static get deviceCapsDpi(): number;
        static get graphicsDpi(): number;
        static get graphicsRichTextDpi(): number;
        private static getDpi;
        private static getRegistryValue;
        static get deviceCapsScale(): number;
        static get graphicsScale(): number;
        static get graphicsRichTextScale(): number;
        static get needDeviceCapsScale(): boolean;
        static get needGraphicsScale(): boolean;
        static get needGraphicsRichTextScale(): boolean;
    }
}
export namespace Stimulsoft.Report {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiEditableItem {
        pageIndex: number;
        position: number;
        componentName: string;
        textValue: string;
        constructor(pageIndex: number, position: number, componentName: string, textValue: string);
    }
    class StiEditableItemsContainer {
        loadFromXml(xmlNode: XmlNode): void;
        saveToXml(): string;
        items: StiEditableItem[];
    }
}
export namespace Stimulsoft.Report {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiFileImageCache {
        static getImageCacheName(report: StiReport, cacheImageGuid: string): string;
        static saveImage(report: StiReport, image: Image, path: string): void;
        static loadImage(report: StiReport, path: string): Image;
        static exist(report: StiReport, cacheGuid: string): boolean;
        static clear(report: StiReport): void;
        static remove(report: StiReport, path: string): void;
    }
}
export namespace Stimulsoft.Report {
    import Image = Stimulsoft.System.Drawing.Image;
    import Size = Stimulsoft.System.Drawing.Size;
    class StiImageCache {
        imageStore: Image[];
        imagePackedStore: number[][];
        imageMaskStore: number[][];
        imageIndex: number[];
        imageFormatStore: ImageFormat[];
        imageSizeStore: Size[];
        private imageHashTable;
        private _useImageComparer;
        private _useImageCompression;
        private _useImageTransparency;
        private _imageSaveFormat;
        private _imageQuality;
        private static crcSeed;
        private static crcTable;
        clear(): void;
        addImageIntRaw(image: Image, imageFormat: Stimulsoft.System.Drawing.Imaging.ImageFormat): number;
        addImageInt(image: Image, imageFormat?: ImageFormat): number;
        constructor(useImageComparer: boolean, useImageCompression?: boolean, imageFormat?: ImageFormat, imageQuality?: number, useImageTransparency?: boolean);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDatabaseCollection extends CollectionBase<StiDatabase> implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        indexOf(data: StiDatabase | string, ignoreCase?: boolean): number;
        remove(data: StiDatabase | string, ignoreCase?: boolean, throwException?: boolean): void;
        getByName(name: string): StiDatabase;
        setByName(name: string, value: StiDatabase): void;
        findByName(name: string): StiDatabase;
        clone(): StiDatabaseCollection;
        memberwiseClone(): StiDatabaseCollection;
        private dictionary;
        constructor(dictionary: StiDictionary);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    enum StiVariableInitBy {
        Value = 0,
        Expression = 1
    }
    enum StiVariableSortField {
        Key = 0,
        Label = 1
    }
    enum StiVariableSortDirection {
        None = 0,
        Asc = 1,
        Desc = 2
    }
    enum StiDateTimeType {
        Date = 0,
        DateAndTime = 1,
        Time = 2
    }
    enum StiItemsInitializationType {
        Items = 0,
        Columns = 1
    }
    enum StiTypeMode {
        Value = 0,
        NullableValue = 1,
        List = 2,
        Range = 3
    }
    enum StiSortOrder {
        Asc = 0,
        Desc = 1
    }
    enum StiRestrictionTypes {
        None = 0,
        DenyEdit = 1,
        DenyDelete = 2,
        DenyMove = 4,
        DenyShow = 8
    }
    enum StiDataType {
        BusinessObject = 0,
        DataSource = 1,
        DataRelation = 2,
        DataColumn = 3,
        Database = 4,
        Resource = 5,
        Variable = 6,
        Total = 7
    }
    enum StiTotalEvent {
        Never = 0,
        OnEachRecord = 1,
        OnGroupChanged = 2,
        OnPageChanged = 3,
        OnColumnChanged = 4,
        OnEachNewBand = 5,
        OnExpressionChanged = 6
    }
    enum StiResourceType {
        Image = 0,
        Csv = 1,
        Dbf = 2,
        Json = 3,
        Xml = 4,
        Xsd = 5,
        Excel = 6,
        Rtf = 7,
        Txt = 8,
        Report = 9,
        ReportSnapshot = 10,
        FontTtc = 11,
        FontTtf = 12,
        FontOtf = 13,
        FontEot = 14,
        FontWoff = 15,
        Pdf = 16,
        Word = 17,
        Map = 18,
        Gis = 19
    }
    enum StiPropertiesProcessingType {
        All = 0,
        Browsable = 1
    }
    enum StiFieldsProcessingType {
        All = 0,
        Browsable = 1
    }
    enum StiConnectionOrder {
        None = 0,
        Standard = 1,
        Sql = 2
    }
    enum StiSqlSourceType {
        Table = 0,
        StoredProcedure = 1
    }
    enum StiColumnsSynchronizationMode {
        KeepAbsentColumns = 0,
        RemoveAbsentColumns = 1
    }
    enum StiSelectionMode {
        FromVariable = 0,
        Nothing = 1,
        First = 2
    }
    enum StiColumnTypeProcessing {
        LeaveUnprocessed = 0,
        CastToColumnType = 1
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    import StiService = Stimulsoft.Base.Services.StiService;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiDataAdapterService extends StiService {
        get serviceCategory(): string;
        get serviceType(): Type;
        isObjectAdapter: boolean;
        get name(): string;
        getDatabaseSpecificName(name: string): string;
        getDataCategoryName(data: StiData): string;
        static getDataAdapter(dataSource: StiDataSource): StiDataAdapterService;
        static getDataAdapter2(data: StiData): StiDataAdapterService;
        create(dictionary: StiDictionary, addToDictionary?: boolean): StiDataSource;
        getDataSourceType(): Type;
        getDataTypes(): Type[];
        isAdapterDataType(type: Type): boolean;
        getColumnsFromDataAsync(data: StiData, dataSource: StiDataSource, connectionString: string): StiPromise<StiDataColumnsCollection>;
        getColumnsFromData(data: StiData, dataSource: StiDataSource, connectionString: string): StiDataColumnsCollection;
        getParametersFromDataAsync(data: StiData, dataSource: StiDataSource, connectionString: string): StiPromise<StiDataParametersCollection>;
        setDataSourceNames(data: StiData, dataSource: StiDataSource): void;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): StiPromise<void>;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
        toString(): string;
        static callRemoteDataAdaptersApi(command: ProcessSqlDataCommand, timeout: number): StiPromise<string>;
        callRemoteApi(command: ProcessSqlDataCommand, timeout: number): StiPromise<string>;
        private static callTurn;
        process(report: StiReport, command: ProcessSqlDataCommand): StiPromise<any>;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiDataStoreSource extends StiDataSource implements IStiJsonReportObject {
        meta(): StiMeta[];
        getCategoryName(): string;
        get dataName(): string;
        set dataName(value: string);
        nameInSource: string;
        getDataBaseName(): string;
        getDataBase(): StiDatabase;
        constructor(nameInSource?: string, name?: string, alias?: string, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Type = Stimulsoft.System.Type;
    class StiDataTableSource extends StiDataStoreSource implements IStiJsonReportObject {
        meta(): StiMeta[];
        getCategoryName(): string;
        getDataAdapterType(): Type;
        constructor(nameInSource?: string, name?: string, alias?: string, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiUndefinedDataSource extends StiDataTableSource {
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiPromise = Stimulsoft.System.StiPromise;
    import List = Stimulsoft.System.Collections.List;
    class StiDataSourcesCollection extends CollectionBase<StiDataSource> implements IStiJsonReportObject, ICloneable, IComparer<any> {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private dictionary;
        private directionFactor;
        compare(x: any, y: any): number;
        cachedDataSources: {
            [name: string]: StiDataSource;
        };
        fetchAllDataTransformations(): List<StiDataTransformation>;
        fetchAllVirtualDataSources(): List<StiVirtualSource>;
        add(dataSource: StiDataSource): void;
        contains(dataSource: StiDataSource | string): boolean;
        remove(dataSource: StiDataSource): void;
        getByName(name: string): StiDataSource;
        getByXmlRef(xmlRef: string): StiDataSource;
        setByName(name: string, value: StiDataSource): void;
        findByName(name: string): StiDataSource;
        clone(): any;
        sort(order?: StiSortOrder, sortColumns?: boolean): void;
        clearParametersExpression(): void;
        connectAsync(loadData: boolean, datas?: StiDataCollection): StiPromise<void>;
        connect(loadData: boolean, datas?: StiDataCollection): void;
        disconnect(): void;
        constructor(dictionary: StiDictionary);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiDataRelationsCollection extends CollectionBase<StiDataRelation> implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiDataRelationsCollection;
        private dictionary;
        cachedDataRelations: Hashtable;
        add(relation: StiDataRelation): void;
        contains(relation: StiDataRelation | string): boolean;
        remove(relation: StiDataRelation): void;
        setByIndex(index: number, value: StiDataRelation): void;
        getByName(name: string): StiDataRelation;
        setByName(name: string, value: StiDataRelation): void;
        findByName(name: string): StiDataRelation;
        constructor(dictionary: StiDictionary);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import List = Stimulsoft.System.Collections.List;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiVariablesCollection extends CollectionBase<StiVariable> implements IComparer<StiVariable>, ICloneable {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson, report: StiReport): void;
        loadFromXml(xmlNode: XmlNode, report: StiReport): void;
        private directionFactor;
        compare(x: StiVariable, y: StiVariable): number;
        sort(order?: StiSortOrder): void;
        add(variable: StiVariable): void;
        addRange(variables: StiVariablesCollection): void;
        contains(name: string): boolean;
        containsCategory(name: string): boolean;
        indexOf(data: string | StiVariable): number;
        remove(data: string | StiVariable): void;
        getByName(name: string): StiVariable;
        setByName(name: string, value: StiVariable): void;
        findByName(name: string): StiVariable;
        clone(): any;
        moveCategoryTo(fromCategory: string, toCategory: string): void;
        getFirstCategoryIndex(category: string): number;
        getLastCategoryIndex(category: string): number;
        renameCategory(oldName: string, newName: string): void;
        getAllVariablesOfCategory(category: string): List<StiVariable>;
        removeCategory(category: string): void;
        getVariablesCount(category: string): number;
    }
}
export namespace Stimulsoft.Report {
    class StiInheritedReportComparer {
        static compare(report: StiReport, masterReport: StiReport): void;
        private static compareComponents;
        private static getPositionForComponent;
        private static setParent;
        private static compareVariables;
        private static compareDataSources;
        private static compareRelations;
        private static compareDatabases;
        private static compareBusinessObjects;
        private static compareEvents;
    }
}
export namespace Stimulsoft.Report {
    import Type = Stimulsoft.System.Type;
    import Exception = Stimulsoft.System.Exception;
    class StiLogService {
        static logEnabled: boolean;
        static logString: string;
        static write(type: Type | object, e: Exception | string, asError?: boolean): void;
        private static write1;
    }
}
export namespace Stimulsoft.Report {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiMetaTag implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        name: string;
        tag: string;
        constructor(name: string, tag: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiMetaTagCollection extends CollectionBase<StiMetaTag> implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        add2(name: string, tag: string): void;
        add(metaTag: StiMetaTag): void;
        addRange(metaTags: StiMetaTag[]): void;
        addRange2(metaTags: StiMetaTagCollection): void;
        contains(metaTag: StiMetaTag): boolean;
        indexOf(metaTag: StiMetaTag): number;
        insert(index: number, metaTag: StiMetaTag): void;
        remove(metaTag: StiMetaTag): void;
        getByIndex(index: number): StiMetaTag;
        setByIndex(index: number, value: StiMetaTag): void;
        getByName(name: string): StiMetaTag;
        setByName(name: string, value: StiMetaTag): void;
        clone(): any;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import StiDataConnector = Stimulsoft.Base.StiDataConnector;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiAppCell = Stimulsoft.Base.IStiAppCell;
    import ICloneable = Stimulsoft.System.ICloneable;
    import EventArgs = Stimulsoft.System.EventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiService = Stimulsoft.Base.Services.StiService;
    import Type = Stimulsoft.System.Type;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiPromise = Stimulsoft.System.StiPromise;
    import IStiAppConnection = Stimulsoft.Base.IStiAppConnection;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    enum Order {
        Name = 100,
        Alias = 200,
        ConnectionString = 300,
        FirstRowIsHeader = 350,
        CastToColumnType = 370,
        PathSchema = 400,
        PathData = 500,
        XmlType = 600,
        PromptUserNameAndPassword = 700,
        SaveDataInReportResources = 800
    }
    class StiDatabase extends StiService implements IStiInherited, IStiAppConnection, IStiJsonReportObject, IStiName, IStiAlias, ICloneable, IStiAppCell {
        implements(): any[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        inherited: boolean;
        clone(cloneProperties?: boolean, cloneComponents?: boolean, base?: boolean): StiDatabase;
        getName(): string;
        fetchSiblingDataSources(dictionary: IStiAppDictionary): List<IStiAppDataSource>;
        getKey(): string;
        setKey(key: string): void;
        get serviceCategory(): string;
        get serviceType(): Type;
        protected onConnecting(e: EventArgs): void;
        invokeConnecting(): void;
        connectingEvent: StiEvent;
        protected onConnected(e: EventArgs): void;
        invokeConnected(): void;
        connectedEvent: StiEvent;
        protected onDisconnecting(e: EventArgs): void;
        invokeDisconnecting(): void;
        disconnectingEvent: StiEvent;
        protected onDisconnected(e: EventArgs): void;
        invokeDisconnected(): void;
        disconnectedEvent: StiEvent;
        get serviceName(): string;
        set serviceName(value: string);
        name: string;
        alias: string;
        key: string;
        get connectionType(): StiConnectionType;
        get canBeTypeChangeResult(): boolean;
        allowException: boolean;
        castToColumnType: StiColumnTypeProcessing;
        copyDataSourceFrom(dataSourceToCopy: StiDataSource): StiDataSource;
        applyDatabaseInformation(information: StiDatabaseInformation, report: StiReport, informationAll?: StiDatabaseInformation): void;
        getDatabaseInformationAsync(report: StiReport): StiPromise<StiDatabaseInformation>;
        getDatabaseInformation(report: StiReport): StiDatabaseInformation;
        getDataAdapterType(): Type;
        getDataAdapter(): StiDataAdapterService;
        toString(): string;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        regDataAsync(dictionary: StiDictionary, loadData: boolean): StiPromise<void>;
        createConnector(connectionString?: string): StiDataConnector;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiRelationDirection = Stimulsoft.Base.StiRelationDirection;
    import DataSet = Stimulsoft.System.Data.DataSet;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiAppCell = Stimulsoft.Base.IStiAppCell;
    class StiResource implements IStiName, IStiAlias, ICloneable, IStiAppCell, IStiInherited, IStiJsonReportObject {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        clone(): StiResource;
        getKey(): string;
        setKey(key: string): void;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get propName(): string;
        inherited: boolean;
        private _name;
        get name(): string;
        set name(value: string);
        alias: string;
        availableInTheViewer: boolean;
        private _content;
        get content(): number[] | string;
        set content(value: number[] | string);
        private _packAndEncryptContent;
        get packAndEncryptContent(): string;
        set packAndEncryptContent(value: string);
        key: string;
        type: StiResourceType;
        dataSet: DataSet;
        relationDirection: StiRelationDirection;
        getResourceAsImage(): Image;
        toString(): string;
        getContentType(): string;
        getFileExt(): string;
        createFileDatabase(): StiFileDatabase;
        static createFileDatabase(type: StiResourceType): StiFileDatabase;
        static isTextResourceType(type: StiResourceType): boolean;
        constructor(name?: string, alias?: string, inherited?: boolean, type?: StiResourceType, content?: number[] | string, availableInTheViewer?: boolean);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDialogInfo implements IStiJsonReportObject {
        jsonLoadedBindingVariableName: string;
        xmlLoadedBindingVariable: XmlNode;
        report: StiReport;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson, report?: StiReport): void;
        loadFromXml(xmlNode: XmlNode, report?: StiReport): void;
        dateTimeType: StiDateTimeType;
        sortDirection: StiVariableSortDirection;
        sortField: StiVariableSortField;
        itemsInitializationType: StiItemsInitializationType;
        keysColumn: string;
        valuesColumn: string;
        filterExpression: string;
        checkedColumn: string;
        bindingVariable: StiVariable;
        bindingValuesColumn: string;
        mask: string;
        allowUserValues: boolean;
        rememberSelection: boolean;
        bindingValue: boolean;
        keys: string[];
        values: string[];
        checkedStates: boolean[];
        valuesBindingList: any[][];
        static convert(value: any): string;
        getDialogInfoItems(type: Stimulsoft.System.Type): StiDialogInfoItem[];
        orderBy(items: StiDialogInfoItem[]): StiDialogInfoItem[];
        setDialogInfoItems(items: StiDialogInfoItem[], type: Stimulsoft.System.Type): void;
        constructor();
    }
    class StiDialogInfoItem {
        get propName(): string;
        keyObject: any;
        keyObjectTo: any;
        valueBinding: any[];
        value: string;
        checked: boolean;
        toString(dateTimeType: StiDateTimeType): string;
    }
    class StiRangeDialogInfoItem extends StiDialogInfoItem {
    }
    class StiStringDialogInfoItem extends StiDialogInfoItem {
        get key(): string;
        set key(value: string);
    }
    class StiGuidDialogInfoItem extends StiDialogInfoItem {
        get key(): Stimulsoft.System.Guid;
        set key(value: Stimulsoft.System.Guid);
        constructor();
    }
    class StiCharDialogInfoItem extends StiDialogInfoItem {
        get key(): Stimulsoft.System.Char;
        set key(value: Stimulsoft.System.Char);
        constructor();
    }
    class StiBoolDialogInfoItem extends StiDialogInfoItem {
        get key(): boolean;
        set key(value: boolean);
        constructor();
    }
    class StiImageDialogInfoItem extends StiDialogInfoItem {
        get key(): Stimulsoft.System.Drawing.Image;
        set key(value: Stimulsoft.System.Drawing.Image);
        constructor();
    }
    class StiDateTimeDialogInfoItem extends StiDialogInfoItem {
        get key(): Stimulsoft.System.DateTime;
        set key(value: Stimulsoft.System.DateTime);
        constructor();
    }
    class StiDateTimeOffsetDialogInfoItem extends StiDialogInfoItem {
        get key(): Stimulsoft.System.DateTimeOffset;
        set key(value: Stimulsoft.System.DateTimeOffset);
        constructor();
    }
    class StiDateOnlyDialogInfoItem extends StiDialogInfoItem {
        get key(): Stimulsoft.System.DateOnly;
        set key(value: Stimulsoft.System.DateOnly);
        constructor();
    }
    class StiTimeOnlyDialogInfoItem extends StiDialogInfoItem {
        get key(): Stimulsoft.System.TimeOnly;
        set key(value: Stimulsoft.System.TimeOnly);
        constructor();
    }
    class StiTimeSpanDialogInfoItem extends StiDialogInfoItem {
        get key(): Stimulsoft.System.TimeSpan;
        set key(value: Stimulsoft.System.TimeSpan);
        constructor();
    }
    class StiDoubleDialogInfoItem extends StiDialogInfoItem {
        get key(): Stimulsoft.System.Double;
        set key(value: Stimulsoft.System.Double);
        constructor();
    }
    class StiDecimalDialogInfoItem extends StiDialogInfoItem {
        get key(): Stimulsoft.System.Decimal;
        set key(value: Stimulsoft.System.Decimal);
        constructor();
    }
    class StiLongDialogInfoItem extends StiDialogInfoItem {
        get key(): Stimulsoft.System.Long;
        set key(value: Stimulsoft.System.Long);
        constructor();
    }
    class StiExpressionDialogInfoItem extends StiDialogInfoItem {
        get key(): string;
        set key(value: string);
        constructor();
    }
    class StiStringRangeDialogInfoItem extends StiRangeDialogInfoItem {
        get from(): string;
        set from(value: string);
        get to(): string;
        set to(value: string);
        constructor();
    }
    class StiGuidRangeDialogInfoItem extends StiRangeDialogInfoItem {
        get from(): Stimulsoft.System.Guid;
        set from(value: Stimulsoft.System.Guid);
        get to(): Stimulsoft.System.Guid;
        set to(value: Stimulsoft.System.Guid);
        constructor();
    }
    class StiByteArrayRangeDialogInfoItem extends StiRangeDialogInfoItem {
        get from(): number[];
        set form(value: number[]);
        get to(): number[];
        set to(value: number[]);
    }
    class StiCharRangeDialogInfoItem extends StiRangeDialogInfoItem {
        get from(): Stimulsoft.System.Char;
        set from(value: Stimulsoft.System.Char);
        get to(): Stimulsoft.System.Char;
        set to(value: Stimulsoft.System.Char);
        constructor();
    }
    class StiDateTimeRangeDialogInfoItem extends StiRangeDialogInfoItem {
        get from(): Stimulsoft.System.DateTime;
        set from(value: Stimulsoft.System.DateTime);
        get to(): Stimulsoft.System.DateTime;
        set to(value: Stimulsoft.System.DateTime);
        constructor();
    }
    class StiTimeSpanRangeDialogInfoItem extends StiRangeDialogInfoItem {
        get from(): Stimulsoft.System.TimeSpan;
        set from(value: Stimulsoft.System.TimeSpan);
        get to(): Stimulsoft.System.TimeSpan;
        set to(value: Stimulsoft.System.TimeSpan);
        constructor();
    }
    class StiDoubleRangeDialogInfoItem extends StiRangeDialogInfoItem {
        get from(): Stimulsoft.System.Double;
        set from(value: Stimulsoft.System.Double);
        get to(): Stimulsoft.System.Double;
        set to(value: Stimulsoft.System.Double);
        constructor();
    }
    class StiDecimalRangeDialogInfoItem extends StiRangeDialogInfoItem {
        get from(): Stimulsoft.System.Decimal;
        set from(value: Stimulsoft.System.Decimal);
        get to(): Stimulsoft.System.Decimal;
        set to(value: Stimulsoft.System.Decimal);
        constructor();
    }
    class StiLongRangeDialogInfoItem extends StiRangeDialogInfoItem {
        get from(): Stimulsoft.System.Long;
        set from(value: Stimulsoft.System.Long);
        get to(): Stimulsoft.System.Long;
        set to(value: Stimulsoft.System.Long);
        constructor();
    }
    class StiExpressionRangeDialogInfoItem extends StiRangeDialogInfoItem {
        get from(): string;
        set from(value: string);
        get to(): string;
        set to(value: string);
        constructor();
    }
}
export namespace Stimulsoft.Report {
    import Range = Stimulsoft.Report.Range;
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    class RangeConverter {
        private currentCulture;
        get getPropertiesSupported(): boolean;
        static rangeToString(range: Range): string;
        static stringToRange(str: string): Range;
        convertTo(context: any, culture: CultureInfo, value: any, destinationType: Stimulsoft.System.Type): any;
        canConvertFrom(context: any, sourceType: Stimulsoft.System.Type): boolean;
        canConvertTo(context: any, destinationType: Stimulsoft.System.Type): boolean;
        convertFrom(context: any, culture: CultureInfo, value: any): any;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiAppCell = Stimulsoft.Base.IStiAppCell;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiName = Stimulsoft.Report.IStiName;
    import StiExpression = Stimulsoft.Report.Expressions.StiExpression;
    import Type = Stimulsoft.System.Type;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiDialogInfo = Stimulsoft.Report.Dictionary.StiDialogInfo;
    import IStiAppVariable = Stimulsoft.Base.IStiAppVariable;
    import IStiAppAlias = Stimulsoft.Base.IStiAppAlias;
    class StiVariable extends StiExpression implements IStiName, IStiAlias, IStiInherited, ICloneable, IStiAppCell, IStiAppVariable, IStiAppAlias {
        implements(): any[];
        private report;
        private convertTypeToJsonString;
        private convertJsonStringToType;
        meta(): StiMeta[];
        loadFromJsonObject(jObject: StiJson, report?: StiReport): void;
        static loadFromXml(xmlNode: XmlNode, report: StiReport): StiVariable;
        private static decodeVariableValue;
        static convertFromStringToDialogInfo(str: string, report: StiReport): StiDialogInfo;
        private static parseStringArray;
        private static parseBoolArray;
        getValue(): any;
        getCellType(): Type;
        getName(): string;
        getKey(): string;
        setKey(key: string): void;
        getAlias(): string;
        inherited: boolean;
        private _name;
        get name(): string;
        set name(value: string);
        get applyFormat(): boolean;
        dialogInfo: StiDialogInfo;
        alias: string;
        type: Type;
        private _readOnly;
        get readOnly(): boolean;
        set readOnly(value: boolean);
        requestFromUser: boolean;
        get showOnParametersPanel(): boolean;
        set showOnParametersPanel(value: boolean);
        allowUseAsSqlParameter: boolean;
        allowNullableString: boolean;
        category: string;
        description: string;
        get isCategory(): boolean;
        get valueObject(): any;
        set valueObject(value: any);
        get initByExpressionFrom(): string;
        set initByExpressionFrom(value: string);
        get initByExpressionTo(): string;
        set initByExpressionTo(value: string);
        getValueProp(): string;
        setValueProp(value: string): void;
        get function(): boolean;
        set function(value: boolean);
        initBy: StiVariableInitBy;
        selection: StiSelectionMode;
        key: string;
        private getRangeValues;
        private static isNullValue;
        static getValue(str: string, type: Type): any;
        private setValue;
        getNativeValue(): string;
        eval(report: StiReport): any;
        toString(): string;
        constructor(category?: string, name?: string, alias?: string, description?: string, typeT?: Type, value?: any, readOnly?: boolean, initBy?: StiVariableInitBy, requestFromUser?: boolean, dialogInfo?: StiDialogInfo, key?: string, allowUseAsSqlParameter?: boolean, selection?: StiSelectionMode, allowNullableString?: boolean);
    }
}
export namespace Stimulsoft.Report {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    enum StiNamingRule {
        Simple = 0,
        Advanced = 1
    }
    class StiNameCreation {
        static get namingRule(): StiNamingRule;
        static set namingRule(value: StiNamingRule);
        private static removeSpacesFromName;
        static createSimpleName(report: StiReport, baseName: string): string;
        static createName(report: StiReport, baseName: string, addOne?: boolean, removeIncorrectSymbols?: boolean, forceAdvancedNamingRule?: boolean): string;
        static createResourceName(report: StiReport, baseName: string): string;
        static createConnectionName(report: StiReport, baseName: string): string;
        static createDataSourcesName(report: StiReport, baseName: string): string;
        static createRelationName(report: StiReport, dataRelation: StiDataRelation, baseName: string): string;
        static isRelationExists(report: StiReport, dataRelation: StiDataRelation, name: string): boolean;
        static isTableDataSourcesExists(report: StiReport, name: string): boolean;
        static isResourceNameExists(report: StiReport, name: string): boolean;
        static isConnectionNameExists(report: StiReport, name: string): boolean;
        static createColumnName(dataSource: StiDataSource, baseName: string): string;
        static isColumnNameExists(dataSource: StiDataSource, name: string): boolean;
        static isValidName(report: StiReport, name: string): boolean;
        static exists(checkedObject: any, report: StiReport, name: string): boolean;
        static checkName(checkedObject: any, report: StiReport, name: string, messageBoxCaption: string, isValid?: boolean): boolean;
        private static getObjectWithName;
        static generateName1(report: StiReport, localizedName: string, name: string): string;
        static generateName2(report: StiReport, localizedName: string, type: Stimulsoft.System.Type): string;
        static generateName(component: StiComponent): string;
        static generateName4(relation: StiDataRelation): string;
        static generateName5(dataSource: StiDataSource): string;
    }
}
export namespace Stimulsoft.Report.CodeDom {
    class StiCodeGenerator {
        private static keywordsHashtable;
        private static keywords;
        private static reservedWordsHashtable;
        private static reservedWords;
        static isReservedWordExist(value: string): boolean;
        static isKeywordExist(value: string): boolean;
        quoteSnippetString(value: string): string;
        static init(): void;
    }
}
export namespace Stimulsoft.Report {
    class StiNameValidator {
        private static cache;
        static correctName(str: string, checkKeywords?: boolean, report?: StiReport): string;
        private static checkKeyword;
        static correctBusinessObjectName(str: string): string;
    }
}
export namespace Stimulsoft.Report {
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    let IStiGlobalizationManager: System.Interface<IStiGlobalizationManager>;
    interface IStiGlobalizationManager {
        culture: CultureInfo;
        getString(name: string): string;
        getObject(name: string): any;
    }
}
export namespace Stimulsoft.Report {
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    class StiNullGlobalizationManager implements IStiGlobalizationManager {
        culture: CultureInfo;
        getString(name: string): string;
        getObject(name: string): any;
        constructor();
    }
}
export namespace Stimulsoft.Report {
    class StiNullValuesHelper {
        static isNull(report: StiReport, dataColumn: string): boolean;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import IAsIs = Stimulsoft.System.IAsIs;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    let IStiScaleBase: System.Interface<IStiScaleBase>;
    interface IStiScaleBase extends IAsIs {
        prepare(gauge: IStiGauge): any;
        items: CollectionBase<IStiGaugeElement>;
        majorInterval: number;
        minorInterval: number;
        minimum: number;
        maximum: number;
        calculateMinMaxScaleHelper(): any;
        calculateWidthScaleHelper(): any;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    let IStiRangeBase: System.Interface<IStiRangeBase>;
    interface IStiRangeBase {
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import IAsIs = Stimulsoft.System.IAsIs;
    let IStiGaugeElement: System.Interface<IStiGaugeElement>;
    interface IStiGaugeElement extends IAsIs {
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    let IStiCustomValueBase: System.Interface<IStiCustomValueBase>;
    interface IStiCustomValueBase {
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiDataStoreAdapterService extends StiDataAdapterService {
        setDataSourceNames(data: StiData, dataSource: StiDataSource): void;
        create(dictionary: StiDictionary, addToDictionary?: boolean): StiDataSource;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiFileDataOptions = Stimulsoft.Base.StiFileDataOptions;
    import StiFileDataConnector = Stimulsoft.Base.StiFileDataConnector;
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import DataSet = Stimulsoft.System.Data.DataSet;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiDataLeader {
        private static fetchAll;
        static regData(database: StiDatabase, dictionary: StiDictionary, loadData: boolean): void;
        static regDataAsync(database: StiDatabase, dictionary: StiDictionary, loadData: boolean): StiPromise<void>;
        private static regDataAfter;
        private static regDataAfterAsync;
        static existsInCache(database: StiDatabase, dictionary: StiDictionary): boolean;
        static retrieveSchema(connector: StiFileDataConnector, options: StiFileDataOptions): StiDataSchema;
        static getDataSet(connector: StiFileDataConnector, options: StiFileDataOptions): DataSet;
        static getColumnsFromData(adapter: StiDataAdapterService, data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        static getColumnsFromDataAsync(adapter: StiDataAdapterService, data: StiData, dataSource: StiDataSource): StiPromise<StiDataColumnsCollection>;
        static connectDataSourceToData(adapter: StiDataAdapterService, dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
        static connectDataSourceToDataAsync(adapter: StiDataAdapterService, dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): StiPromise<void>;
        static retrieveDataAsync(dataSource: StiSqlSource, schemaOnly?: boolean): StiPromise<void>;
        static connect(dataSource: StiDataSource, datas: StiDataCollection, loadData?: boolean): void;
        static connectAsync(dataSource: StiDataSource, datas: StiDataCollection, loadData?: boolean): StiPromise<void>;
        static connectAsync2(dataSource: StiDataSource, datas: StiDataCollection, loadData?: boolean): Promise<void>;
        static disconnect(dataSource: StiDataSource): void;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import StiPromise = Stimulsoft.System.StiPromise;
    type StiSqlAdapterResultType = {
        columns: string[];
        rows: {}[];
        types: string[];
    };
    class StiSqlAdapterService extends StiDataStoreAdapterService {
        parameters: Hashtable<string, {
            name: string;
            value: string | number;
        }>;
        get url(): string;
        get serviceName(): string;
        get name(): string;
        getDatabaseSpecificName(name: string): string;
        getDataCategoryName(data: StiData): string;
        getColumnsFromDataAsync(data: StiData, dataSource: StiDataSource, connectionString: string): StiPromise<StiDataColumnsCollection>;
        getParametersFromDataAsync(data: StiData, dataSource: StiDataSource, connectionString: string): StiPromise<StiDataParametersCollection>;
        getDataSourceType(): Stimulsoft.System.Type;
        applyParametersToSqlSourse(dictionary: StiDictionary, sqlSource: StiSqlSource): void;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): StiPromise<void>;
        static getStringCommand(command: any): string;
        static encodeCommand(command: any): string;
        static decodeCommandResult(value: string): any;
        testConnectionAsync(report: StiReport, connectionString: string, connectionName: string): StiPromise<string>;
        testConnectionAsync2(report: StiReport, connectionString: string, connectionName: string): Promise<string>;
        createConnectionInDataStore(dictionary: StiDictionary, database: StiSqlDatabase): void;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): StiPromise<StiDataSchema>;
        getNetType(dbType: string): Stimulsoft.System.Type;
        getSqlType(type: System.Type, source: StiSqlSource): number;
        private getSqlType2;
        retrieveDataAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString: string, maxDataRows: number): StiPromise<DataTable>;
        constructor();
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiMySqlAdapterService extends StiSqlAdapterService {
        get name(): string;
        getDatabaseSpecificName(name: string): string;
        getDataSourceType(): Stimulsoft.System.Type;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): StiPromise<StiDataSchema>;
        getNetType(dbType: string): Stimulsoft.System.Type;
    }
}
export namespace Stimulsoft.Report.Components {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    let IStiTextFormat: System.Interface<IStiTextFormat>;
    let ImplementsIStiTextFormat: any[];
    interface IStiTextFormat extends IAsIs {
        textFormat: StiFormatService;
    }
}
export namespace Stimulsoft.Report.Styles {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiStyle extends StiBaseStyle implements IStiJsonReportObject, IStiTextFormat {
        implements(): any[];
        meta(): StiMeta[];
        clone(): any;
        private _horAlignment;
        get horAlignment(): StiTextHorAlignment;
        set horAlignment(value: StiTextHorAlignment);
        private _vertAlignment;
        get vertAlignment(): StiVertAlignment;
        set vertAlignment(value: StiVertAlignment);
        private _font;
        get font(): Font;
        set font(value: Font);
        private _border;
        get border(): StiBorder;
        set border(value: StiBorder);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _textBrush;
        get textBrush(): StiBrush;
        set textBrush(value: StiBrush);
        textFormat: Stimulsoft.Report.Components.TextFormats.StiFormatService;
        private _allowUseHorAlignment;
        get allowUseHorAlignment(): boolean;
        set allowUseHorAlignment(value: boolean);
        private _allowUseVertAlignment;
        get allowUseVertAlignment(): boolean;
        set allowUseVertAlignment(value: boolean);
        private _allowUseImage;
        get allowUseImage(): boolean;
        set allowUseImage(value: boolean);
        private _allowUseFont;
        get allowUseFont(): boolean;
        set allowUseFont(value: boolean);
        get allowUseBorder(): boolean;
        set allowUseBorder(value: boolean);
        private _allowUseBorderFormatting;
        get allowUseBorderFormatting(): boolean;
        set allowUseBorderFormatting(value: boolean);
        private _allowUseBorderSides;
        get allowUseBorderSides(): boolean;
        set allowUseBorderSides(value: boolean);
        private _allowUseBorderSidesFromLocation;
        get allowUseBorderSidesFromLocation(): boolean;
        set allowUseBorderSidesFromLocation(value: boolean);
        private _allowUseBrush;
        get allowUseBrush(): boolean;
        set allowUseBrush(value: boolean);
        private _allowUseTextBrush;
        get allowUseTextBrush(): boolean;
        set allowUseTextBrush(value: boolean);
        allowUseNegativeTextBrush: boolean;
        allowUseTextFormat: boolean;
        private _allowUseTextOptions;
        get allowUseTextOptions(): boolean;
        set allowUseTextOptions(value: boolean);
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements, componentStyle?: StiBaseStyle): void;
        setStyleToComponent(component: StiComponent): void;
        private _image;
        get image(): Image;
        set image(value: Image);
        private _lineSpacing;
        get lineSpacing(): number;
        set lineSpacing(value: number);
        negativeTextBrush: StiBrush;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    let IStiIndicatorRangeInfo: System.Interface<IStiIndicatorRangeInfo>;
    interface IStiIndicatorRangeInfo {
    }
}
export namespace Stimulsoft.Report.Export {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    class StiExportUtils {
        static convertDigitsToArabic(inputString: string, digitsType: StiArabicDigitsType): string;
        private static reportVersion;
        static getReportVersion(report?: StiReport): string;
        static saveComponentToString(component: StiComponent, imageFormat?: ImageFormat, imageQuality?: number, imageResolution?: number): string;
        static trimEndWhiteSpace(inputString: string): string;
        static trimEndWhiteSpace2(inputString: string, removeControl: boolean): string;
        static splitString(inputString: string, removeControl: boolean): string[];
        static stringToUrl(input: string): string;
        private static wrongUrlSymbols;
        static additionalData: string;
        private static additionalData2;
        private static cachedAdditionalData2;
        static getAdditionalData2(opacity: number): Image;
        static checkPassive(pages: StiPagesCollection): void;
        private static positivePatterns;
        private static negativePatterns;
        static getPositivePattern(patternIndex: number): string;
        static getNegativePattern(patternIndex: number): string;
        static makePdfDeflateStream(data: Uint8Array | number[] | string): Stimulsoft.System.IO.MemoryStream;
        static toHex(num: number): string;
        static checkBoxToTextBox(component: StiComponent): StiComponent;
    }
}
export namespace Stimulsoft.Report.Export {
    enum StiTiffCompressionScheme {
        Default = 20,
        LZW = 2,
        CCITT3 = 3,
        CCITT4 = 4,
        Rle = 5,
        None = 6
    }
    enum StiHtmlExportMode {
        Span = 1,
        Div = 2,
        Table = 3,
        FromReport = 4
    }
    enum StiHtmlExportQuality {
        High = 1,
        Low = 2
    }
    enum StiUserAccessPrivileges {
        None = 0,
        PrintDocument = 1,
        ModifyContents = 2,
        CopyTextAndGraphics = 4,
        AddOrModifyTextAnnotations = 8,
        All = 15
    }
    enum StiPdfEncryptionKeyLength {
        Bit40 = 1,
        Bit128 = 2,
        Bit128_r4 = 3,
        Bit256_r5 = 4,
        Bit256_r6 = 5
    }
    enum StiPdfImageCompressionMethod {
        Jpeg = 1,
        Flate = 2,
        Indexed = 3
    }
    enum StiPdfAutoPrintMode {
        None = 1,
        Dialog = 2,
        Silent = 3
    }
    enum StiTxtBorderType {
        Simple = 1,
        UnicodeSingle = 2,
        UnicodeDouble = 3
    }
    enum StiPcxPaletteType {
        Monochrome = 1,
        Color = 2
    }
    enum StiMonochromeDitheringType {
        None = 1,
        FloydSteinberg = 2,
        Ordered = 3
    }
    enum StiImageType {
        Bmp = 1,
        Gif = 2,
        Jpeg = 3,
        Pcx = 4,
        Png = 5,
        Tiff = 6,
        Emf = 7,
        Svg = 8,
        Svgz = 9
    }
    enum StiHtmlType {
        Html = 1,
        Html5 = 2,
        Mht = 3
    }
    enum StiHtmlChartType {
        Image = 1,
        Vector = 2,
        AnimatedVector = 3
    }
    enum StiExcelType {
        ExcelBinary = 1,
        ExcelXml = 2,
        Excel2007 = 3
    }
    enum StiDataType {
        Csv = 1,
        Dbf = 2,
        Dif = 3,
        Sylk = 4,
        Xml = 5,
        Json = 6
    }
    enum StiExportPosition {
        Pdf = 0,
        Xps = 1,
        PowerPoint = 2,
        Html = 10,
        Html5 = 11,
        Mht = 12,
        Txt = 20,
        Rtf = 21,
        Word = 22,
        Odt = 23,
        Excel = 30,
        Ods = 33,
        Data = 40,
        Dbf = 41,
        Xml = 42,
        Dif = 43,
        Sylk = 44,
        Image = 50,
        Bmp = 50,
        Gif = 51,
        Jpeg = 52,
        Pcx = 53,
        Png = 54,
        Tiff = 55,
        Emf = 60,
        Svg = 61,
        Svgz = 62
    }
    enum StiHtmlExportBookmarksMode {
        BookmarksOnly = 1,
        ReportOnly = 2,
        All = 3
    }
    enum StiDbfCodePages {
        Default = 0,
        USDOS = 437,
        MazoviaDOS = 620,
        GreekDOS = 737,
        InternationalDOS = 850,
        EasternEuropeanDOS = 852,
        IcelandicDOS = 861,
        NordicDOS = 865,
        RussianDOS = 866,
        KamenickyDOS = 895,
        TurkishDOS = 857,
        EasternEuropeanWindows = 1250,
        RussianWindows = 1251,
        WindowsANSI = 1252,
        GreekWindows = 1253,
        TurkishWindows = 1254,
        StandardMacintosh = 10000,
        GreekMacintosh = 10006,
        RussianMacintosh = 10007,
        EasternEuropeanMacintosh = 10029
    }
    enum StiExportDataType {
        String = 0,
        Int = 1,
        Long = 2,
        Float = 3,
        Double = 4,
        Date = 5,
        Bool = 6
    }
    enum StiImageFormat {
        Color = 1,
        Grayscale = 2,
        Monochrome = 3
    }
    enum StiRtfExportMode {
        Table = 4,
        Frame = 1,
        WinWord = 2,
        TabbedText = 3
    }
    enum StiDataExportMode {
        Data = 1,
        Headers = 2,
        DataAndHeaders = 3,
        Footers = 4,
        HeadersFooters = 6,
        DataAndHeadersFooters = 7,
        AllBands = 15
    }
    enum StiWordRestrictEditing {
        No = 1,
        ExceptEditableFields = 2,
        Yes = 3
    }
    enum StiExcelRestrictEditing {
        No = 1,
        ExceptEditableFields = 2,
        Yes = 3
    }
    enum StiPdfAllowEditable {
        No = 1,
        Yes = 2
    }
    enum StiImageResolutionMode {
        Exactly = 1,
        NoMoreThan = 2,
        Auto = 3
    }
    enum StiPdfComplianceMode {
        None = 0,
        A1 = 1,
        A2 = 2,
        A3 = 3
    }
    enum StiExcelSheetViewMode {
        Normal = 1,
        PageLayout = 2,
        PageBreakPreview = 3
    }
    enum StiPdfZUGFeRDComplianceMode {
        None = 0,
        V1 = 1,
        V2 = 2,
        V2_1 = 3
    }
}
export namespace Stimulsoft.Report.Events {
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiExportEventArgs extends EventArgs {
        exportFormat: StiExportFormat;
        constructor(format: StiExportFormat);
    }
}
export namespace Stimulsoft.Report.Styles {
    enum StiStyleConditionType {
        ComponentType = 1,
        Placement = 2,
        PlacementNestedLevel = 4,
        ComponentName = 8,
        Location = 16
    }
    enum StiStyleComponentPlacement {
        None = 0,
        ReportTitle = 1,
        ReportSummary = 2,
        PageHeader = 4,
        PageFooter = 8,
        GroupHeader = 16,
        GroupFooter = 32,
        Header = 64,
        Footer = 128,
        ColumnHeader = 256,
        ColumnFooter = 512,
        Data = 1024,
        DataEvenStyle = 2048,
        DataOddStyle = 4096,
        Table = 8192,
        Hierarchical = 16384,
        Child = 32768,
        Empty = 65536,
        Overlay = 131072,
        Panel = 262144,
        Page = 524288,
        AllExeptStyles = 1042431
    }
    enum StiStyleComponentType {
        Text = 1,
        Primitive = 2,
        Image = 4,
        CrossTab = 8,
        Chart = 16,
        CheckBox = 32
    }
    enum StiStyleLocation {
        None = 0,
        TopLeft = 1,
        TopCenter = 2,
        TopRight = 4,
        MiddleLeft = 8,
        MiddleCenter = 16,
        MiddleRight = 32,
        BottomLeft = 64,
        BottomCenter = 128,
        BottomRight = 256,
        Left = 512,
        Right = 1024,
        Top = 2048,
        Bottom = 4096,
        CenterHorizontal = 8192,
        CenterVertical = 16384
    }
    enum StiStyleConditionOperation {
        EqualTo = 0,
        NotEqualTo = 1,
        GreaterThan = 2,
        GreaterThanOrEqualTo = 3,
        LessThan = 4,
        LessThanOrEqualTo = 5,
        Containing = 6,
        NotContaining = 7,
        BeginningWith = 8,
        EndingWith = 9
    }
    enum StiHeatmapFillMode {
        Lightness = 0,
        Darkness = 1
    }
}
export namespace Stimulsoft.Report {
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import IStiFontStyle = Stimulsoft.Report.Styles.IStiFontStyle;
    import IStiTitleStyle = Stimulsoft.Report.Styles.IStiTitleStyle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCardsStyle extends StiBaseStyle implements IStiTitleStyle, IStiFontStyle, IStiGetFonts, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        private static defaultSeriesColors;
        backColor: Color;
        foreColor: Color;
        lineColor: Color;
        seriesColors: Color[];
        toolTipBrush: StiBrush;
        toolTipTextBrush: StiBrush;
        toolTipCornerRadius: StiCornerRadius;
        toolTipBorder: StiSimpleBorder;
        getFonts(): Font[];
        allowUseFont: boolean;
        font: Font;
        allowUseTitle: boolean;
        titleForeColor: Color;
        titleBackColor: Color;
        titleFont: Font;
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
export namespace Stimulsoft.Report.Styles {
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import IStiCustomStyle = Stimulsoft.Report.Chart.IStiCustomStyle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiStylesCollection extends CollectionBase<StiBaseStyle> implements IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        load(param: string | number[] | XmlNode | any): void;
        loadFile(filePath: string): void;
        saveToJsonString(): string;
        add(style: StiBaseStyle): void;
        clear(): void;
        addRange(styles: StiBaseStyle[] | StiStylesCollection | any): void;
        contains(style: StiBaseStyle | string | any): boolean;
        insert(index: number, style: StiBaseStyle): void;
        remove(style: StiBaseStyle): void;
        setByIndex(index: number, style: StiBaseStyle): void;
        getByName(name: string): StiBaseStyle;
        setByName(name: string, value: StiBaseStyle): void;
        findByName(name: string): StiBaseStyle;
        private updateHash;
        getCustomChartStyle(customStyleName: string): IStiCustomStyle;
        getCustomGaugeStyle(customStyleName: string): IStiGaugeStyle;
        private report;
        private hash;
        private needUpdateHash;
        private lastCount;
        constructor(report?: StiReport);
    }
}
export namespace Stimulsoft.Report.Components.Table {
    enum StiTableStyleIdent {
        Style21 = 0,
        Style24 = 1,
        Style25 = 2,
        Style26 = 3,
        Style27 = 4
    }
    enum StiTableStyle {
        StyleNone = 0,
        Style11 = 11,
        Style12 = 12,
        Style13 = 13,
        Style14 = 14,
        Style15 = 15,
        Style16 = 16,
        Style17 = 17,
        Style18 = 18,
        Style19 = 19,
        Style31 = 31,
        Style32 = 32,
        Style33 = 33,
        Style34 = 34,
        Style35 = 35,
        Style36 = 36,
        Style37 = 37,
        Style38 = 38,
        Style39 = 39,
        Style41 = 41,
        Style42 = 42,
        Style43 = 43,
        Style44 = 44,
        Style45 = 45,
        Style46 = 46,
        Style47 = 47,
        Style48 = 48,
        Style49 = 49,
        Style51 = 51,
        Style52 = 52,
        Style53 = 53,
        Style54 = 54,
        Style55 = 55,
        Style56 = 56,
        Style57 = 57,
        Style58 = 58,
        Style59 = 59
    }
    enum StiTablceCellType {
        Text = 0,
        Image = 1,
        CheckBox = 2,
        RichText = 3
    }
    enum StiTableAutoWidth {
        None = 0,
        Page = 1,
        Table = 2
    }
    enum StiTableAutoWidthType {
        None = 0,
        LastColumns = 1,
        FullTable = 2
    }
}
export namespace Stimulsoft.Report.Components.Table {
    let IStiTableCell: System.Interface<IStiTableCell>;
    interface IStiTableCell {
        joinCells: number[];
        parentJoin: number;
        join: boolean;
        id: number;
        joinWidth: number;
        joinHeight: number;
        merged: boolean;
        changeTopPosition: boolean;
        changeLeftPosition: boolean;
        changeRightPosition: boolean;
        cellType: StiTablceCellType;
        cellDockStyle: StiDockStyle;
        column: number;
        fixedWidth: boolean;
        tableTag: any;
        parentJoinCell: StiComponent;
        getJoinComponentByGuid(id: number): StiComponent;
        getJoinComponentByIndex(index: number): StiComponent;
        containsGuid(id: number): boolean;
        setJoinSize(): any;
        getRealHeightAfterInsertRows(): number;
        getRealHeight(): number;
        getRealTop(): number;
        getRealWidth(): number;
        getRealLeft(): number;
    }
}
export namespace Stimulsoft.Report.Events {
    import EventArgs = Stimulsoft.System.EventArgs;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiGetImageDataEventArgs extends EventArgs {
        value: Image;
        constructor(image?: Image);
    }
}
export namespace Stimulsoft.Report.Helpers {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiExpressionHelper {
        static parseText(page: StiPage, text: string, allowReturnNull?: boolean): string;
        static parseBool(page: StiPage, text: string): boolean;
    }
}
export namespace Stimulsoft.Report.Import {
    export class BitConverter {
        static toInt16(value: number[], startIndex: number): number;
        static toUInt16(value: number[], startIndex: number): number;
        static toInt32(value: number[], startIndex: number): number;
        static toUInt32(value: number[], startIndex: number): number;
        static toUInt64(value: number[], startIndex: number): number;
        static toChar(value: number[], startIndex: number): string;
        static getBytesInt32(value: number): number[];
    }
    class DirEntry {
        name: string;
        type: number;
        dIDLeft: number;
        dIDRight: number;
        dIDRoot: number;
        sIDFirstSector: number;
        size: number;
    }
    export class OleContainer {
        data: number[];
        dir: DirEntry[];
        private bigSectorSize;
        private shortSectorSize;
        private minimumStreamSize;
        private bSAT;
        private sSAT;
        private headerSize;
        private sIDFree;
        private sIDEoC;
        private sIDSAT;
        private sIDMSAT;
        private getUInt16;
        private getUInt32;
        private getBigSectorOffset;
        private getShortSectorOffset;
        private getBSatChain;
        private getSSatChain;
        private getBigStreamData;
        private getShortStreamData;
        getStreamData(streamNumber: number): number[];
        clear(): void;
        constructor(inData: number[]);
    }
    export class ObjectHeader {
        private getString;
        private signature;
        private headerSize;
        private objectType;
        private nameLen;
        private classLen;
        private nameOffset;
        private classOffset;
        private objectSizeWidth;
        private objectSizeHeight;
        private oleVersion;
        private format;
        private oleInfoLen;
        name: string;
        class: string;
        oleInfo: string;
        headerLen: number;
        constructor(data: number[]);
    }
    export class OleUnit {
        static oleContainerIdentifier: number;
        static oleLinkIdentifier: number;
        static olePresHeaderLength: number;
        static isOleContainer(data: number[]): boolean;
        static isOleHeader(data: number[]): boolean;
        static checkForOlePres(data: number[]): boolean;
    }
    export {};
}
export namespace Stimulsoft.Report.Components {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImageHelper {
        static getImageFromObject(imageObject: any, width?: number, height?: number, stretch?: boolean, aspectRatio?: boolean): Image;
        static getImageBytesFromObject(imageObject: any): number[];
        private static getImageName;
        static isXml(data: number[]): boolean;
        static isSvg(data: number[]): boolean;
        static isIcon(data: number[]): boolean;
        static isWmf(data: number[]): boolean;
        static isEmf(data: number[]): boolean;
        static isBmp(data: number[]): boolean;
        static isJpeg(data: number[]): boolean;
        static isGif(data: number[]): boolean;
        static isPng(data: number[]): boolean;
        static isTiff(data: number[]): boolean;
        static isImage(data: any): boolean;
        static isImage2(data: number[]): boolean;
        static isImage3(str: string): boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiView extends StiComponent implements IStiHorAlignment, IStiVertAlignment, IStiBorder, IStiExportImage, IStiExportImageExtended, IStiBrush, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        clone(cloneProperties: boolean): StiView;
        private _horAlignment;
        get horAlignment(): StiHorAlignment;
        set horAlignment(value: StiHorAlignment);
        private _vertAlignment;
        get vertAlignment(): StiVertAlignment;
        set vertAlignment(value: StiVertAlignment);
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        private _border;
        get border(): StiBorder;
        set border(value: StiBorder);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        getActualSize(): SizeD;
        getRealSize(): SizeD;
        private _smoothing;
        get smoothing(): boolean;
        set smoothing(value: boolean);
        isCachedImage: boolean;
        private _objectToDraw;
        get objectToDraw(): any;
        set objectToDraw(value: any);
        private _imageToDraw;
        get imageToDraw(): Image;
        set imageToDraw(value: Image);
        private _stretch;
        get stretch(): boolean;
        set stretch(value: boolean);
        private _multipleFactor;
        get multipleFactor(): number;
        set multipleFactor(value: number);
        private _aspectRatio;
        get aspectRatio(): boolean;
        set aspectRatio(value: boolean);
        getImageFromSource(): Image;
        resetImageToDraw(): void;
    }
}
export namespace Stimulsoft.Report.Helpers {
    enum StiImageType {
        GdiImage = 0,
        SvgObject = 1
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetImageDataEventArgs = Stimulsoft.Report.Events.StiGetImageDataEventArgs;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import Image = Stimulsoft.System.Drawing.Image;
    import IStiBreakable = Stimulsoft.Report.Components.IStiBreakable;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiImage extends StiView implements IStiBreakable, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        clone(cloneProperties: boolean): StiImage;
        memberwiseClone(base?: boolean): StiImage;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        protected getImageFromFile(): Image;
        protected getImageFromUrl(): Image;
        protected getImageFromDataColumn(): Image;
        protected getImageFromIcon(): Image;
        getImageFromSource(): Image;
        private static propertyCanBreak;
        get canBreak(): boolean;
        set canBreak(value: boolean);
        break(dividedComponent: StiComponent, devideFactor: number, REFdivideLine: any): boolean;
        private _imageURLValue;
        get imageURLValue(): any;
        set imageURLValue(value: any);
        invokeEvents(): void;
        getImageURLEvent: StiEvent;
        protected onGetImageURL(e: StiValueEventArgs): void;
        invokeGetImageURL(sender: any, e: StiValueEventArgs): void;
        getImageDataEvent: StiEvent;
        protected onGetImageData(e: StiGetImageDataEventArgs): void;
        invokeGetImageData(sender: any, e: StiGetImageDataEventArgs): void;
        defaultClientRectangle: RectangleD;
        private static propertyProcessingDuplicates;
        get processingDuplicates(): StiImageProcessingDuplicatesType;
        set processingDuplicates(value: StiImageProcessingDuplicatesType);
        private _imageRotation;
        get imageRotation(): StiImageRotation;
        set imageRotation(value: StiImageRotation);
        private _image;
        get image(): Image;
        set image(value: Image);
        margins: StiMargins;
        private _file;
        get file(): string;
        set file(value: string);
        private _dataColumn;
        get dataColumn(): string;
        set dataColumn(value: string);
        private _imageURL;
        get imageURL(): string;
        set imageURL(value: string);
        private _imageData;
        get imageData(): string;
        set imageData(value: string);
        icon: StiFontIcons;
        iconColor: Color;
        convertImageMargins(rect: RectangleD, convert: boolean): RectangleD;
    }
}
export namespace Stimulsoft.Report.Components.Table {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiTableCellImage extends StiImage implements IStiTableCell, IStiTableComponent, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        private loadJoinCellsFromXml;
        clone(cloneProperties: boolean): StiTableCellImage;
        get locked(): boolean;
        get linked(): boolean;
        setCanGrow(value: boolean): void;
        cellDockStyle: StiDockStyle;
        parentJoinCell: StiComponent;
        joinCells: number[];
        parentJoin: number;
        _join: boolean;
        get join(): boolean;
        set join(value: boolean);
        id: number;
        joinWidth: number;
        joinHeight: number;
        get merged(): boolean;
        get changeTopPosition(): boolean;
        get changeLeftPosition(): boolean;
        get changeRightPosition(): boolean;
        tableTag: any;
        private _cellType;
        get cellType(): StiTablceCellType;
        set cellType(value: StiTablceCellType);
        fixedWidth: boolean;
        column: number;
        getJoinComponentByGuid(id: number): StiComponent;
        getJoinComponentByIndex(index: number): StiComponent;
        containsGuid(id: number): boolean;
        private createJoin;
        private deleteJoin;
        private getNewClientRectangle;
        setJoinSize(): void;
        getRealHeightAfterInsertRows(): number;
        getRealHeight(): number;
        getRealTop(): number;
        getRealWidth(): number;
        getRealLeft(): number;
    }
}
export namespace Stimulsoft.Report.Components.Table {
    class StiColumnSize {
        private _widths;
        private _fixedColumns;
        private _minWidths;
        setFixedColumn(indexCol: number, width: number): void;
        add(indexCol: number, width: number): void;
        addLastNotFixed(width: number): void;
        subtract(indexCol: number, width: number, checkMin?: boolean): void;
        setWidth(indexCol: number, width: number): void;
        setMinWidths(indexCol: number, minWidth: number): void;
        getFixed(index: number): boolean;
        get length(): number;
        getCountNotFixedColumn(): number;
        getCountNotFixedColumnAndWidth(): number;
        getCountNotFixedColumnAndNotMinSize(): number;
        getWidth(indexCol: number): number;
        normalize(): void;
        fitColumnsIntoSlotByAdjustingAllColumns(slotWidth: number): void;
        private getColumnsTotalWidth;
        constructor(size: number);
    }
}
export namespace Stimulsoft.Report.Components.Table {
    import IStiTableCell = Stimulsoft.Report.Components.Table.IStiTableCell;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTable extends StiDataBand implements IStiTableComponent, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        clone(cloneProperties: boolean, cloneComponents: boolean): StiTable;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        get localizedName(): string;
        get localizedCategory(): string;
        isConverted: boolean;
        dockableTable: boolean;
        autoWidth: StiTableAutoWidth;
        autoWidthType: StiTableAutoWidthType;
        private _rowCount;
        get rowCount(): number;
        set rowCount(value: number);
        private _columnCount;
        get columnCount(): number;
        set columnCount(value: number);
        private _footerRowsCount;
        get footerRowsCount(): number;
        set footerRowsCount(value: number);
        private _headerRowsCount;
        get headerRowsCount(): number;
        set headerRowsCount(value: number);
        get defaultHeightCell(): number;
        headerPrintOn: StiPrintOnType;
        headerCanGrow: boolean;
        headerCanShrink: boolean;
        headerCanBreak: boolean;
        headerPrintAtBottom: boolean;
        headerPrintIfEmpty: boolean;
        headerPrintOnAllPages: boolean;
        headerPrintOnEvenOddPages: StiPrintOnEvenOddPagesType;
        footerPrintOn: StiPrintOnType;
        footerCanGrow: boolean;
        footerCanShrink: boolean;
        footerCanBreak: boolean;
        footerPrintAtBottom: boolean;
        footerPrintIfEmpty: boolean;
        footerPrintOnAllPages: boolean;
        footerPrintOnEvenOddPages: StiPrintOnEvenOddPagesType;
        numberID: number;
        columns: number;
        columnWidth: number;
        columnGaps: number;
        minRowsInColumn: number;
        getMinSize(): SizeD;
        setWidth(value: number): void;
        setHeight(value: number): void;
        defaultClientRectangle: RectangleD;
        get dockable(): boolean;
        set dockable(value: boolean);
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        changeGrowToHeightAtCell(cell: StiComponent): void;
        private _tableStyleFX;
        get tableStyleFX(): StiTableStyleFX;
        set tableStyleFX(value: StiTableStyleFX);
        private applyCustomStyle;
        refreshTableStyle(): void;
        applyStyleNone(): void;
        private changeRowCount;
        private changeColumnCount;
        createJoin(REFsumWidth: any, REFsumHeight: any, REFjoinWidth: any, REFjoinHeight: any): number[];
        private getCountSelectedCells;
        private getCountJoinSelectedCells;
        private findLeftSelectedElement;
        private findRightSelectedElement;
        changeTableCellContentInImage(cell: StiTableCell | StiTableCellCheckBox | StiTableCellRichText): void;
        changeTableCellContentInText(cell: StiTableCellImage | StiTableCellCheckBox | StiTableCellRichText): void;
        changeTableCellContentInCheckBox(cell: StiTableCellImage | StiTableCell | StiTableCellRichText): void;
        changeTableCellContentInRichText(cell: StiTableCell | StiTableCellImage | StiTableCellCheckBox): void;
        getColumnForCell(cell: IStiTableCell): number;
        private setCellID;
        createCell(): void;
        private setStyleForCell;
        private addNewRows;
        private deleteLastRows;
        private addTableNewColumns;
        private deleteTableColumns;
        insertColumnToLeft(numberColumn: number): void;
        insertColumnToRight(numberColumn: number): void;
        insertRowAbove(numberRow: number): void;
        insertRowBelow(numberRow: number): void;
        deleteRows(firstRow: number, lastRow: number): StiComponent[];
        deleteColumns(firstColumn: number, lastColumn: number): StiComponent[];
        distributeRows(): void;
        distributeColumns(): void;
        autoSizeCells(): void;
        private resizeWidthCellsAfterChanges;
        private resizeHeightCellsAfterChanges;
        private resizeWidthCell;
        private resizeHeightCell;
        startRenderTableBand(REFnewTableComponents: any): StiDataBand;
        private startRenderTable;
        private reverseCells;
        private setFilter;
        private setInteraction;
        private getParentJoin;
        private isEqualRows;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import List = Stimulsoft.System.Collections.List;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTableOfContents extends StiDataBand implements IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        clone(cloneProperties: boolean): StiBand;
        get priority(): number;
        defaultClientRectangle: RectangleD;
        get toolboxPosition(): number;
        get localizedName(): string;
        helpUrl: () => string;
        get countData(): number;
        set countData(value: number);
        get canBreak(): boolean;
        set canBreak(value: boolean);
        get canGrow(): boolean;
        set canGrow(value: boolean);
        get canShrink(): boolean;
        set canShrink(value: boolean);
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        getHeaderText(): string;
        getStylesList(): List<Stimulsoft.Report.Styles.StiStyle>;
        wordWrap: boolean;
        get isFirstInReport(): boolean;
        styles: Styles.StiStylesCollection;
        indent: number;
        reportPointer: string;
        margins: StiMargins;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiBookmark {
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        add(name: string): void;
        private _bookmarks;
        get bookmarks(): StiBookmarksCollection;
        set bookmarks(value: StiBookmarksCollection);
        text: string;
        bookmarkText: string;
        parentComponent: any;
        componentGuid: string;
        isManualBookmark: boolean;
        pageIndex: number;
        constructor(text?: string, parentComponent?: any);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import Size = Stimulsoft.System.Drawing.Size;
    import ContentAlignment = Stimulsoft.System.Drawing.ContentAlignment;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiCondition extends StiBaseCondition implements IStiJsonReportObject, IStiGetFonts {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiCondition;
        getFonts(): Font[];
        enabled: boolean;
        textColor: Color;
        backColor: Color;
        font: Font;
        canAssignExpression: boolean;
        breakIfTrue: boolean;
        assignExpression: string;
        style: string;
        private _borderSides;
        get borderSides(): StiConditionBorderSides;
        set borderSides(value: StiConditionBorderSides);
        permissions: StiConditionPermissions;
        icon: number[];
        iconAlignment: ContentAlignment;
        iconSize: Size;
        equals(obj: any): boolean;
        constructor(item?: StiFilterItem, column?: string, condition?: StiFilterCondition, value1?: string, value2?: string, dataType?: StiFilterDataType, expression?: string, textColor?: Color, backColor?: Color, font?: Font, enabled?: boolean, canAssignExpression?: boolean, assignExpression?: string, style?: string, borderSides?: StiConditionBorderSides, permissions?: StiConditionPermissions, icon?: number[], iconAlignment?: ContentAlignment, iconSize?: Size);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiMultiCondition extends StiCondition implements IStiFilter, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        loadfromXmlDoc(xmlDoc: XmlNode): void;
        clone(): StiMultiCondition;
        filterMode: StiFilterMode;
        filters: StiFiltersCollection;
        get filterMethodHandler(): Function;
        set filterMethodHandler(value: Function);
        get filterOn(): boolean;
        equals(obj: any): boolean;
        constructor(textColor?: Color, backColor?: Color, font?: Font, enabled?: boolean, filterMode?: StiFilterMode, filters?: StiFilter[], canAssignExpression?: boolean, assignExpression?: string, style?: string, borderSides?: StiConditionBorderSides);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    let IStiEnumerator: System.Interface<IStiEnumerator>;
    interface IStiEnumerator {
        firstAsync(): any;
        first(): any;
        prior(): any;
        nextAsync(): any;
        next(): any;
        last(): any;
        position: number;
        count: number;
        isEof: boolean;
        isBof: boolean;
        isEmpty: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    class StiDataHelper {
        static setDataAsync(component: StiComponent, reinit: boolean, masterComponent?: StiComponent, allowReconnectOnEachRow?: boolean): Promise<void>;
        static setData(component: StiComponent, reinit: boolean, masterComponent?: StiComponent, allowReconnectOnEachRow?: boolean): void;
        static needGroupSort(band: StiDataBand): boolean;
        static getFilterEventHandler(component: StiComponent, dataSource: any): any;
        static getFilterExpression(filter: StiFilter, fullColumnName: string, report: StiReport): string;
    }
}
export namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiPagesCollection extends CollectionBase<StiPage> implements IStiStateSaveRestore, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        add(page: StiPage): void;
        addV2Internal(page: StiPage): void;
        remove(page: StiPage): any;
        remove(startIndex: number, endCount: number): any;
        getPageWithoutCache(pageIndex: number): StiPage;
        getByName(name: string): StiPage;
        setByName(name: string, page: StiPage): void;
        findByName(name: string): StiPage;
        getComponentByName(componentName: string): StiComponent;
        getComponentByGuid(guid: string): StiComponent;
        private static setParent;
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        clearAllStates(): void;
        canUseCacheMode: boolean;
        report: StiReport;
        cacheMode: boolean;
        get containsDashboards(): boolean;
        private quickCachedPages;
        notCachedPages: StiPage[];
        private cacheL2;
        private pageHashToCacheIndex;
        private addPageToQuickCache;
        isNotSavedPage(page: StiPage): boolean;
        markPageAsNotSaved(page: StiPage): void;
        getPage(page: StiPage): void;
        private getPageJson;
        savePage(page: StiPage, clearContent?: boolean): void;
        private serializePage;
        private loadPage;
        private getCacheIndexFromPageHash;
        private deserializePage;
        private saveQuickPagesToCache;
        flush(final?: boolean): void;
        checkCacheL2(): void;
        private savePageToCache;
        private loadPageFromCache;
        private loadPageFromServer;
        static copyEventsOfPagesCollection(sourcePages: StiPagesCollection, destinationPages: StiPagesCollection): void;
        constructor(report: StiReport, originalPages?: StiPagesCollection);
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiConditions: System.Interface<IStiConditions>;
    interface IStiConditions {
        conditions: StiConditionsCollection;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import IEnumerator = Stimulsoft.System.Collections.IEnumerator;
    class StiRowsCollection implements IEnumerator {
        getEnumerator(): IEnumerator;
        get current(): any;
        moveNext(): boolean;
        reset(): void;
        getbyIndex(rowIndex: number): StiRow;
        get count(): number;
        private dataSource;
        constructor(dataSource: StiDataSource);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import Type = Stimulsoft.System.Type;
    class StiFunctions {
        static removeFunction(functionName: string): void;
        static getFunctionsList(functionName: string): StiFunction[];
        static getFunctionsGrouppedInCategories(): Hashtable<string, StiFunction[]>;
        static getFunctions(categoryOrIsCompile: string | boolean): StiFunction[];
        static getFunctionsEx(report: StiReport, functionName: string, isCompile: boolean): StiFunction[];
        static getCategories(): string[];
        static getAssebliesOfFunctions(): string[];
        static addFunction(category: string, groupFunctionName: string, functionName: string, description: string, typeOfFunction: string, returnType: Type, returnDescription?: string, argumentTypes?: Type[], argumentNames?: string[], argumentDescriptions?: string[], jsFunction?: Function): StiFunction;
        private static isEqual;
        private static isEqualArray;
        static StiFunctions(): void;
    }
}
export namespace Stimulsoft.Report.Engine {
    enum StiTokenType {
        Empty = 0,
        Delimiter = 1,
        Variable = 2,
        SystemVariable = 3,
        DataSourceField = 4,
        BusinessObjectField = 5,
        Number = 6,
        Function = 7,
        Method = 8,
        Property = 9,
        Component = 10,
        Cast = 11,
        String = 12,
        Char = 13,
        RefVariable = 14,
        New = 15,
        CastAs = 16,
        Dot = 17,
        Comma = 18,
        Colon = 19,
        SemiColon = 20,
        Shl = 21,
        Shr = 22,
        Assign = 23,
        Equal = 24,
        NotEqual = 25,
        LeftEqual = 26,
        Left = 27,
        RightEqual = 28,
        Right = 29,
        Not = 30,
        Or = 31,
        And = 32,
        Xor = 33,
        DoubleOr = 34,
        DoubleAnd = 35,
        Question = 36,
        DoubleQuestion = 37,
        Plus = 38,
        Minus = 39,
        Mult = 40,
        Div = 41,
        Percent = 42,
        LParenthesis = 43,
        RParenthesis = 44,
        LBracket = 45,
        RBracket = 46,
        Identifier = 47,
        Unknown = 48
    }
    enum StiAsmCommandType {
        PushValue = 2000,
        PushVariable = 2001,
        PushSystemVariable = 2002,
        PushDataSourceField = 2003,
        PushBusinessObjectField = 2004,
        PushFunction = 2005,
        PushMethod = 2006,
        PushProperty = 2007,
        PushComponent = 2008,
        PushArrayElement = 2009,
        CopyToVariable = 2010,
        Add = 2020,
        Sub = 2021,
        Mult = 2022,
        Div = 2023,
        Mod = 2024,
        Power = 2025,
        Neg = 2026,
        Cast = 2027,
        Not = 2028,
        CompareLeft = 2029,
        CompareLeftEqual = 2030,
        CompareRight = 2031,
        CompareRightEqual = 2032,
        CompareEqual = 2033,
        CompareNotEqual = 2034,
        Shl = 2035,
        Shr = 2036,
        And = 2037,
        And2 = 2038,
        Or = 2039,
        Or2 = 2040,
        Xor = 2041,
        Jump = 2042,
        JumpTrue = 2043,
        JumpFalse = 2044,
        JumpNotNull = 2045
    }
    enum StiSystemVariableType {
        Column = 0,
        Line = 1,
        LineThrough = 2,
        LineABC = 3,
        LineRoman = 4,
        GroupLine = 5,
        PageNumber = 6,
        PageNumberThrough = 7,
        PageNofM = 8,
        PageNofMThrough = 9,
        TotalPageCount = 10,
        TotalPageCountThrough = 11,
        IsFirstPage = 12,
        IsFirstPageThrough = 13,
        IsLastPage = 14,
        IsLastPageThrough = 15,
        PageCopyNumber = 16,
        ReportAlias = 17,
        ReportAuthor = 18,
        ReportChanged = 19,
        ReportCreated = 20,
        ReportDescription = 21,
        ReportName = 22,
        Time = 23,
        Today = 24,
        ConditionValue = 25,
        ConditionValue2 = 26,
        Index = 27,
        ConditionTag = 28,
        Sender = 29,
        DateTimeNow = 30,
        DateTimeToday = 31
    }
    enum StiPropertyType {
        Year = 0,
        Month = 1,
        Day = 2,
        Hour = 3,
        Minute = 4,
        Second = 5,
        Date = 6,
        DayOfWeek = 7,
        Length = 8,
        From = 9,
        To = 10,
        FromDate = 11,
        ToDate = 12,
        FromTime = 13,
        ToTime = 14,
        SelectedLine = 15,
        Name = 16,
        TagValue = 17,
        Days = 18,
        Hours = 19,
        Milliseconds = 20,
        Minutes = 21,
        Seconds = 22,
        Ticks = 23,
        TotalDays = 24,
        TotalHours = 25,
        TotalMinutes = 26,
        TotalSeconds = 27,
        TotalMilliseconds = 28,
        Count = 29,
        BusinessObjectValue = 30,
        Position = 31,
        Line = 32,
        Rows = 33,
        SelectedIndex = 34,
        SelectedValue = 35,
        SelectedKey = 36,
        SelectedLabel = 37,
        Text = 38,
        Value = 39,
        Enabled = 40,
        Skip = 41,
        Alias = 42,
        Page = 43,
        Pages = 44,
        CrossColumnValue = 45,
        CrossRowValue = 46
    }
    enum StiFunctionType {
        NameSpace = 0,
        Count = 1,
        CountDistinct = 2,
        Avg = 3,
        AvgD = 4,
        AvgDate = 5,
        AvgI = 6,
        AvgTime = 7,
        Max = 8,
        MaxD = 9,
        MaxDate = 10,
        MaxI = 11,
        MaxStr = 12,
        MaxTime = 13,
        Median = 14,
        MedianD = 15,
        MedianI = 16,
        Min = 17,
        MinD = 18,
        MinDate = 19,
        MinI = 20,
        MinStr = 21,
        MinTime = 22,
        Mode = 23,
        ModeD = 24,
        ModeI = 25,
        Sum = 26,
        SumD = 27,
        SumDistinct = 28,
        SumI = 29,
        SumTime = 30,
        StDev = 31,
        StDevP = 32,
        First = 33,
        Last = 34,
        rCount = 35,
        rCountDistinct = 36,
        rAvg = 37,
        rAvgD = 38,
        rAvgDate = 39,
        rAvgI = 40,
        rAvgTime = 41,
        rMax = 42,
        rMaxD = 43,
        rMaxDate = 44,
        rMaxI = 45,
        rMaxStr = 46,
        rMaxTime = 47,
        rMedian = 48,
        rMedianD = 49,
        rMedianI = 50,
        rMin = 51,
        rMinD = 52,
        rMinDate = 53,
        rMinI = 54,
        rMinStr = 55,
        rMinTime = 56,
        rMode = 57,
        rModeD = 58,
        rModeI = 59,
        rSum = 60,
        rSumD = 61,
        rSumDistinct = 62,
        rSumI = 63,
        rSumTime = 64,
        rStDev = 65,
        rStDevP = 66,
        rFirst = 67,
        rLast = 68,
        iCount = 69,
        iCountDistinct = 70,
        iAvg = 71,
        iAvgD = 72,
        iAvgDate = 73,
        iAvgI = 74,
        iAvgTime = 75,
        iMax = 76,
        iMaxD = 77,
        iMaxDate = 78,
        iMaxI = 79,
        iMaxStr = 80,
        iMaxTime = 81,
        iMedian = 82,
        iMedianD = 83,
        iMedianI = 84,
        iMin = 85,
        iMinD = 86,
        iMinDate = 87,
        iMinI = 88,
        iMinStr = 89,
        iMinTime = 90,
        iMode = 91,
        iModeD = 92,
        iModeI = 93,
        iSum = 94,
        iSumD = 95,
        iSumDistinct = 96,
        iSumI = 97,
        iSumTime = 98,
        iStDev = 99,
        iStDevP = 100,
        iFirst = 101,
        iLast = 102,
        riCount = 103,
        riCountDistinct = 104,
        riAvg = 105,
        riAvgD = 106,
        riAvgDate = 107,
        riAvgI = 108,
        riAvgTime = 109,
        riMax = 110,
        riMaxD = 111,
        riMaxDate = 112,
        riMaxI = 113,
        riMaxStr = 114,
        riMaxTime = 115,
        riMedian = 116,
        riMedianD = 117,
        riMedianI = 118,
        riMin = 119,
        riMinD = 120,
        riMinDate = 121,
        riMinI = 122,
        riMinStr = 123,
        riMinTime = 124,
        riMode = 125,
        riModeD = 126,
        riModeI = 127,
        riSum = 128,
        riSumD = 129,
        riSumDistinct = 130,
        riSumI = 131,
        riSumTime = 132,
        riStDev = 133,
        riStDevP = 134,
        riFirst = 135,
        riLast = 136,
        cCount = 137,
        cCountDistinct = 138,
        cAvg = 139,
        cAvgD = 140,
        cAvgDate = 141,
        cAvgI = 142,
        cAvgTime = 143,
        cMax = 144,
        cMaxD = 145,
        cMaxDate = 146,
        cMaxI = 147,
        cMaxStr = 148,
        cMaxTime = 149,
        cMedian = 150,
        cMedianD = 151,
        cMedianI = 152,
        cMin = 153,
        cMinD = 154,
        cMinDate = 155,
        cMinI = 156,
        cMinStr = 157,
        cMinTime = 158,
        cMode = 159,
        cModeD = 160,
        cModeI = 161,
        cSum = 162,
        cSumD = 163,
        cSumDistinct = 164,
        cSumI = 165,
        cSumTime = 166,
        cStDev = 167,
        cStDevP = 168,
        cFirst = 169,
        cLast = 170,
        crCount = 171,
        crCountDistinct = 172,
        crAvg = 173,
        crAvgD = 174,
        crAvgDate = 175,
        crAvgI = 176,
        crAvgTime = 177,
        crMax = 178,
        crMaxD = 179,
        crMaxDate = 180,
        crMaxI = 181,
        crMaxStr = 182,
        crMaxTime = 183,
        crMedian = 184,
        crMedianD = 185,
        crMedianI = 186,
        crMin = 187,
        crMinD = 188,
        crMinDate = 189,
        crMinI = 190,
        crMinStr = 191,
        crMinTime = 192,
        crMode = 193,
        crModeD = 194,
        crModeI = 195,
        crSum = 196,
        crSumD = 197,
        crSumDistinct = 198,
        crSumI = 199,
        crSumTime = 200,
        crStDev = 201,
        crStDevP = 202,
        crFirst = 203,
        crLast = 204,
        ciCount = 205,
        ciCountDistinct = 206,
        ciAvg = 207,
        ciAvgD = 208,
        ciAvgDate = 209,
        ciAvgI = 210,
        ciAvgTime = 211,
        ciMax = 212,
        ciMaxD = 213,
        ciMaxDate = 214,
        ciMaxI = 215,
        ciMaxStr = 216,
        ciMaxTime = 217,
        ciMedian = 218,
        ciMedianD = 219,
        ciMedianI = 220,
        ciMin = 221,
        ciMinD = 222,
        ciMinDate = 223,
        ciMinI = 224,
        ciMinStr = 225,
        ciMinTime = 226,
        ciMode = 227,
        ciModeD = 228,
        ciModeI = 229,
        ciSum = 230,
        ciSumD = 231,
        ciSumDistinct = 232,
        ciSumI = 233,
        ciSumTime = 234,
        ciStDev = 235,
        ciStDevP = 236,
        ciFirst = 237,
        ciLast = 238,
        criCount = 239,
        criCountDistinct = 240,
        criAvg = 241,
        criAvgD = 242,
        criAvgDate = 243,
        criAvgI = 244,
        criAvgTime = 245,
        criMax = 246,
        criMaxD = 247,
        criMaxDate = 248,
        criMaxI = 249,
        criMaxStr = 250,
        criMaxTime = 251,
        criMedian = 252,
        criMedianD = 253,
        criMedianI = 254,
        criMin = 255,
        criMinD = 256,
        criMinDate = 257,
        criMinI = 258,
        criMinStr = 259,
        criMinTime = 260,
        criMode = 261,
        criModeD = 262,
        criModeI = 263,
        criSum = 264,
        criSumD = 265,
        criSumDistinct = 266,
        criSumI = 267,
        criSumTime = 268,
        criStDev = 269,
        criStDevP = 270,
        criFirst = 271,
        criLast = 272,
        pCount = 273,
        pCountDistinct = 274,
        pAvg = 275,
        pAvgD = 276,
        pAvgDate = 277,
        pAvgI = 278,
        pAvgTime = 279,
        pMax = 280,
        pMaxD = 281,
        pMaxDate = 282,
        pMaxI = 283,
        pMaxStr = 284,
        pMaxTime = 285,
        pMedian = 286,
        pMedianD = 287,
        pMedianI = 288,
        pMin = 289,
        pMinD = 290,
        pMinDate = 291,
        pMinI = 292,
        pMinStr = 293,
        pMinTime = 294,
        pMode = 295,
        pModeD = 296,
        pModeI = 297,
        pSum = 298,
        pSumD = 299,
        pSumDistinct = 300,
        pSumI = 301,
        pSumTime = 302,
        pStDev = 303,
        pStDevP = 304,
        pFirst = 305,
        pLast = 306,
        prCount = 307,
        prCountDistinct = 308,
        prAvg = 309,
        prAvgD = 310,
        prAvgDate = 311,
        prAvgI = 312,
        prAvgTime = 313,
        prMax = 314,
        prMaxD = 315,
        prMaxDate = 316,
        prMaxI = 317,
        prMaxStr = 318,
        prMaxTime = 319,
        prMedian = 320,
        prMedianD = 321,
        prMedianI = 322,
        prMin = 323,
        prMinD = 324,
        prMinDate = 325,
        prMinI = 326,
        prMinStr = 327,
        prMinTime = 328,
        prMode = 329,
        prModeD = 330,
        prModeI = 331,
        prSum = 332,
        prSumD = 333,
        prSumDistinct = 334,
        prSumI = 335,
        prSumTime = 336,
        prStDev = 337,
        prStDevP = 338,
        prFirst = 339,
        prLast = 340,
        piCount = 341,
        piCountDistinct = 342,
        piAvg = 343,
        piAvgD = 344,
        piAvgDate = 345,
        piAvgI = 346,
        piAvgTime = 347,
        piMax = 348,
        piMaxD = 349,
        piMaxDate = 350,
        piMaxI = 351,
        piMaxStr = 352,
        piMaxTime = 353,
        piMedian = 354,
        piMedianD = 355,
        piMedianI = 356,
        piMin = 357,
        piMinD = 358,
        piMinDate = 359,
        piMinI = 360,
        piMinStr = 361,
        piMinTime = 362,
        piMode = 363,
        piModeD = 364,
        piModeI = 365,
        piSum = 366,
        piSumD = 367,
        piSumDistinct = 368,
        piSumI = 369,
        piSumTime = 370,
        piStDev = 371,
        piStDevP = 372,
        piFirst = 373,
        piLast = 374,
        priCount = 375,
        priCountDistinct = 376,
        priAvg = 377,
        priAvgD = 378,
        priAvgDate = 379,
        priAvgI = 380,
        priAvgTime = 381,
        priMax = 382,
        priMaxD = 383,
        priMaxDate = 384,
        priMaxI = 385,
        priMaxStr = 386,
        priMaxTime = 387,
        priMedian = 388,
        priMedianD = 389,
        priMedianI = 390,
        priMin = 391,
        priMinD = 392,
        priMinDate = 393,
        priMinI = 394,
        priMinStr = 395,
        priMinTime = 396,
        priMode = 397,
        priModeD = 398,
        priModeI = 399,
        priSum = 400,
        priSumD = 401,
        priSumDistinct = 402,
        priSumI = 403,
        priSumTime = 404,
        priStDev = 405,
        priStDevP = 406,
        priFirst = 407,
        priLast = 408,
        CountAllLevels = 409,
        CountAllLevelsOnlyChilds = 410,
        CountOnlyChilds = 411,
        CountDistinctAllLevels = 412,
        CountDistinctAllLevelsOnlyChilds = 413,
        CountDistinctOnlyChilds = 414,
        SumAllLevels = 415,
        SumAllLevelsOnlyChilds = 416,
        SumOnlyChilds = 417,
        SumTimeAllLevels = 418,
        SumTimeAllLevelsOnlyChilds = 419,
        SumTimeOnlyChilds = 420,
        AvgAllLevels = 421,
        AvgAllLevelsOnlyChilds = 422,
        AvgOnlyChilds = 423,
        AvgDateAllLevels = 424,
        AvgDateAllLevelsOnlyChilds = 425,
        AvgDateOnlyChilds = 426,
        AvgTimeAllLevels = 427,
        AvgTimeAllLevelsOnlyChilds = 428,
        AvgTimeOnlyChilds = 429,
        MaxAllLevels = 430,
        MaxAllLevelsOnlyChilds = 431,
        MaxOnlyChilds = 432,
        MinAllLevels = 433,
        MinAllLevelsOnlyChilds = 434,
        MinOnlyChilds = 435,
        MedianAllLevels = 436,
        MedianAllLevelsOnlyChilds = 437,
        MedianOnlyChilds = 438,
        ModeAllLevels = 439,
        ModeAllLevelsOnlyChilds = 440,
        ModeOnlyChilds = 441,
        FirstAllLevels = 442,
        FirstAllLevelsOnlyChilds = 443,
        FirstOnlyChilds = 444,
        LastAllLevels = 445,
        LastAllLevelsOnlyChilds = 446,
        LastOnlyChilds = 447,
        MinDateAllLevels = 448,
        MinDateAllLevelsOnlyChilds = 449,
        MinDateOnlyChilds = 450,
        MinTimeAllLevels = 451,
        MinTimeAllLevelsOnlyChilds = 452,
        MinTimeOnlyChilds = 453,
        MinStrAllLevels = 454,
        MinStrAllLevelsOnlyChilds = 455,
        MinStrOnlyChilds = 456,
        MaxDateAllLevels = 457,
        MaxDateAllLevelsOnlyChilds = 458,
        MaxDateOnlyChilds = 459,
        MaxTimeAllLevels = 460,
        MaxTimeAllLevelsOnlyChilds = 461,
        MaxTimeOnlyChilds = 462,
        MaxStrAllLevels = 463,
        MaxStrAllLevelsOnlyChilds = 464,
        MaxStrOnlyChilds = 465,
        Rank = 466,
        Abs = 467,
        Acos = 468,
        Asin = 469,
        Atan = 470,
        Ceiling = 471,
        Clamp = 472,
        Cos = 473,
        Div = 474,
        Exp = 475,
        Floor = 476,
        Frac = 477,
        Log = 478,
        Maximum = 479,
        Minimum = 480,
        Round = 481,
        Sign = 482,
        Sin = 483,
        Sqrt = 484,
        Tan = 485,
        Truncate = 486,
        DateDiff = 487,
        DateSerial = 488,
        Day = 489,
        DayOfWeek = 490,
        DayOfYear = 491,
        DaysInMonth = 492,
        DaysInYear = 493,
        Hour = 494,
        Minute = 495,
        Month = 496,
        Second = 497,
        TimeSerial = 498,
        Year = 499,
        MonthName = 500,
        WeekOfYear = 501,
        WeekOfMonth = 502,
        FromOADate = 503,
        ToOADate = 504,
        ToJapaneseDateString = 505,
        AddYears = 506,
        AddMonths = 507,
        AddDays = 508,
        AddHours = 509,
        AddMinutes = 510,
        AddSeconds = 511,
        AddMilliseconds = 512,
        DateToStr = 513,
        DateToStrPl = 514,
        DateToStrRu = 515,
        DateToStrUa = 516,
        DateToStrPt = 517,
        DateToStrPtBr = 518,
        Insert = 519,
        Length = 520,
        Remove = 521,
        Replace = 522,
        Roman = 523,
        Substring = 524,
        ToCurrencyWords = 525,
        ToCurrencyWordsAr = 526,
        ToCurrencyWordsBg = 527,
        ToCurrencyWordsEnGb = 528,
        ToCurrencyWordsEnIn = 529,
        ToCurrencyWordsEs = 530,
        ToCurrencyWordsFr = 531,
        ToCurrencyWordsNl = 532,
        ToCurrencyWordsPl = 533,
        ToCurrencyWordsPt = 534,
        ToCurrencyWordsPtBr = 535,
        ToCurrencyWordsRu = 536,
        ToCurrencyWordsThai = 537,
        ToCurrencyWordsTr = 538,
        ToCurrencyWordsUa = 539,
        ToCurrencyWordsZh = 540,
        ToLowerCase = 541,
        ToProperCase = 542,
        ToUpperCase = 543,
        ToWords = 544,
        ToWordsAr = 545,
        ToWordsBg = 546,
        ToWordsEs = 547,
        ToWordsEnIn = 548,
        ToWordsFa = 549,
        ToWordsPl = 550,
        ToWordsPt = 551,
        ToWordsRu = 552,
        ToWordsTr = 553,
        ToWordsUa = 554,
        Trim = 555,
        TryParseDateTime = 556,
        TryParseDecimal = 557,
        TryParseDouble = 558,
        TryParseLong = 559,
        Arabic = 560,
        Persian = 561,
        ToOrdinal = 562,
        Left = 563,
        Mid = 564,
        Right = 565,
        StrToDateTime = 566,
        StrToNullableDateTime = 567,
        Compare = 568,
        IsNull = 569,
        Next = 570,
        NextIsNull = 571,
        Previous = 572,
        PreviousIsNull = 573,
        VLookup = 574,
        VLookupStr = 575,
        GetCrossTabColumnValue = 576,
        GetCrossTabRowValue = 577,
        Coalesce = 578,
        IIF = 579,
        Choose = 580,
        Eval = 581,
        EvalDecimal = 582,
        EvalDouble = 583,
        EvalLong = 584,
        Switch = 585,
        Rand = 586,
        ToString = 587,
        Format = 588,
        SystemConvertToBoolean = 589,
        SystemConvertToByte = 590,
        SystemConvertToChar = 591,
        SystemConvertToDateTime = 592,
        SystemConvertToDecimal = 593,
        SystemConvertToDouble = 594,
        SystemConvertToInt16 = 595,
        SystemConvertToInt32 = 596,
        SystemConvertToInt64 = 597,
        SystemConvertToSByte = 598,
        SystemConvertToSingle = 599,
        SystemConvertToString = 600,
        SystemConvertToUInt16 = 601,
        SystemConvertToUInt32 = 602,
        SystemConvertToUInt64 = 603,
        MathRound = 604,
        MathPow = 605,
        AddAnchor = 606,
        GetAnchorPageNumber = 607,
        GetAnchorPageNumberThrough = 608,
        ConvertRtf = 609,
        GetLabel = 610,
        GetParam = 611,
        Parse_Int = 612,
        Parse_Double = 613,
        Parse_Decimal = 614,
        Parse_DateTime = 615,
        Parse_TimeSpan = 616,
        ParseLong = 617,
        ParseDouble = 618,
        ParseDecimal = 619,
        ParseDateTime = 620,
        StringIsNullOrEmpty = 621,
        StringIsNullOrWhiteSpace = 622,
        EngineHelperJoinColumnContent = 623,
        EngineHelperToQueryString = 624,
        EngineHelperGetRealPageNumber = 625,
        NewType = 626,
        m_Substring = 1000,
        m_ToString = 1001,
        m_ToLower = 1002,
        m_ToUpper = 1003,
        m_IndexOf = 1004,
        m_StartsWith = 1005,
        m_EndsWith = 1006,
        m_Replace = 1007,
        m_PadLeft = 1008,
        m_PadRight = 1009,
        m_TrimStart = 1010,
        m_TrimEnd = 1011,
        m_Parse = 1012,
        m_Contains = 1013,
        m_GetData = 1014,
        m_ToQueryString = 1015,
        m_AddYears = 1016,
        m_AddMonths = 1017,
        m_AddDays = 1018,
        m_AddHours = 1019,
        m_AddMinutes = 1020,
        m_AddSeconds = 1021,
        m_AddMilliseconds = 1022,
        m_ToShortDateString = 1023,
        m_ToShortTimeString = 1024,
        m_ToLongDateString = 1025,
        m_ToLongTimeString = 1026,
        m_GetCurrentConditionValue = 1027,
        m_Add = 1028,
        m_Subtract = 1029,
        m_MethodNameSpace = 1030,
        op_Add = 2020,
        op_Sub = 2021,
        op_Mult = 2022,
        op_Div = 2023,
        op_Mod = 2024,
        op_Power = 2025,
        op_Neg = 2026,
        op_Cast = 2027,
        op_Not = 2028,
        op_CompareLeft = 2029,
        op_CompareLeftEqual = 2030,
        op_CompareRight = 2031,
        op_CompareRightEqual = 2032,
        op_CompareEqual = 2033,
        op_CompareNotEqual = 2034,
        op_Shl = 2035,
        op_Shr = 2036,
        op_And = 2037,
        op_And2 = 2038,
        op_Or = 2039,
        op_Or2 = 2040,
        op_Xor = 2041,
        UserFunction = 3000,
        UserFunction2 = 6000
    }
    enum StiMethodType {
        Substring = 1000,
        ToString = 1001,
        ToLower = 1002,
        ToUpper = 1003,
        IndexOf = 1004,
        StartsWith = 1005,
        EndsWith = 1006,
        Replace = 1007,
        PadLeft = 1008,
        PadRight = 1009,
        TrimStart = 1010,
        TrimEnd = 1011,
        Parse = 1012,
        Contains = 1013,
        GetData = 1014,
        ToQueryString = 1015,
        AddYears = 1016,
        AddMonths = 1017,
        AddDays = 1018,
        AddHours = 1019,
        AddMinutes = 1020,
        AddSeconds = 1021,
        AddMilliseconds = 1022,
        ToShortDateString = 1023,
        ToShortTimeString = 1024,
        ToLongDateString = 1025,
        ToLongTimeString = 1026,
        GetCurrentConditionValue = 1027,
        GetValueOrDefault = 1028,
        Add = 1029,
        Subtract = 1030,
        MethodNameSpace = 1031
    }
    enum StiParameterNumber {
        Param1 = 1,
        Param2 = 2,
        Param3 = 4,
        Param4 = 8
    }
}
export namespace Stimulsoft.Report.Engine.StiParser {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import Type = Stimulsoft.System.Type;
    class StiParserMethodInfo {
        name: StiFunctionType;
        number: number;
        arguments: Type[];
        returnType: Type;
        constructor(name: StiFunctionType, numberr: number, argumentss: Type[], returnType?: Type);
    }
    class StiParser_Properties {
        protected get_category(par: any): number;
        protected report: StiReport;
        protected syntaxCaseSensitive: boolean;
        protected checkSyntaxMode: boolean;
        protected expressionPosition: number;
        private static _typesList;
        static get typesList(): Hashtable;
        private static _systemVariablesList;
        static get systemVariablesList(): Hashtable;
        private static _propertiesList;
        static get propertiesList(): Hashtable;
        private static _functionsList;
        static get functionsList(): Hashtable;
        private static _methodsList;
        static get methodsList(): Hashtable;
        private static _parametersList;
        static get parametersList(): Hashtable;
        private _componentsList;
        get componentsList(): Hashtable;
        private static _methodsHash;
        static get methodsHash(): Map<StiFunctionType, StiParserMethodInfo[]>;
        get constantsList(): Hashtable;
        private static _constantsList;
        private static _constantsList_low;
        static check_constantsList(): void;
        protected static namespaceObj: any;
        private static _namespacesList;
        static get namespacesList(): Hashtable;
        get operatorsList(): Hashtable;
        private static _operatorsList;
        private static _operatorsList_low;
        private static _operatorsList_vb;
        static check_operatorsList(): void;
        private static _keywordsList;
        static get keywordsList(): Hashtable;
        private _variablesList;
        get variablesList(): Hashtable;
        private lockUserFunctionsList;
        private _userFunctionsList;
        get userFunctionsList(): Hashtable;
    }
}
export namespace Stimulsoft.Report.Engine.StiParser {
    import Type = Stimulsoft.System.Type;
    import Exception = Stimulsoft.System.Exception;
    enum ParserErrorCode {
        SyntaxError = 0,
        IntegralConstantIsTooLarge = 1,
        ExpressionIsEmpty = 2,
        DivisionByZero = 3,
        UnexpectedEndOfExpression = 4,
        NameDoesNotExistInCurrentContext = 5,
        UnprocessedLexemesRemain = 6,
        LeftParenthesisExpected = 7,
        RightParenthesisExpected = 8,
        FieldMethodOrPropertyNotFound = 9,
        OperatorCannotBeAppliedToOperands = 10,
        FunctionNotFound = 11,
        NoOverloadForMethodTakesNArguments = 12,
        FunctionHasInvalidArgument = 13,
        FunctionNotYetImplemented = 14,
        MethodHasInvalidArgument = 15,
        ItemDoesNotContainDefinition = 16,
        NoMatchingOverloadedMethod = 17,
        TheTypeOrNamespaceNotExistInTheNamespace = 18
    }
    class StiParserException extends Exception {
        baseMessage: string;
        position: number;
        length: number;
        toString(): string;
    }
    class StiParser_Check extends StiParser_Properties {
        private static errorsList;
        protected throwError(code: ParserErrorCode, token?: StiToken, message1?: string, message2?: string, message3?: string, message4?: string): void;
        checkTypes(asmList: StiAsmCommand[]): void;
        private getMethodResultType;
        private getPropertyType;
        private getArrayElementType;
        protected get_systemVariable(name: any): any;
        static isImplicitlyCastableTo(from: Type, to: Type, valueFrom: object): boolean;
        protected getTypeName(value: any): string;
        report: StiReport;
        protected checkParserMethodInfo(type: StiFunctionType, args: any[]): number;
        protected checkParserMethodInfo2(type: StiFunctionType, args: any[], asmCommand: StiAsmCommand): number;
        getParserMethodInfo(type: StiFunctionType, args: Type[], argValues?: object[]): StiParserMethodInfo;
    }
}
export namespace Stimulsoft.Report.Engine.StiParser {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiParser_Lexer extends StiParser_Check {
        protected position: number;
        protected useAliases: boolean;
        protected inputExpression: string;
        protected hashAliases: Hashtable;
        protected tokenPos: number;
        protected tokensList: StiToken[];
        protected component: StiComponent;
        protected runtimeConstants: Hashtable;
        protected runtimeConstantsHash: Hashtable;
        private getNextLexem;
        private static isWhiteSpace;
        private buildAliases;
        private buildBusinessObject;
        private static isValidName;
        private static getCorrectedAlias;
        private static replaceBackslash;
        private scanNumber;
        private postProcessTokensList;
        protected createRuntimeConstantsHash(): void;
        private getDataRelationByName;
        private getDataColumnByName;
        private preProcessNamespaces;
        protected makeTokensList(): void;
    }
}
export namespace Stimulsoft.Report.Engine.StiParser {
    class StiParser_AsmOperations extends StiParser_Lexer {
        protected op_Add(par1: any, par2: any): any;
        protected op_Sub(par1: any, par2: any): any;
        protected op_Mult(par1: any, par2: any): any;
        protected op_Div(par1: any, par2: any): any;
        protected op_Mod(par1: any, par2: any): any;
        protected op_Pow(par1: any, par2: any): any;
        protected op_Neg(par1: any): any;
        protected op_Not(par1: any): any;
        protected op_Cast(par1: any, par2: any): any;
        private toIntegerCheckChar;
        protected op_CompareLeft(par1: any, par2: any): any;
        protected op_CompareLeftEqual(par1: any, par2: any): any;
        protected op_CompareRight(par1: any, par2: any): any;
        protected op_CompareRightEqual(par1: any, par2: any): any;
        protected op_CompareEqual(par1: any, par2: any): any;
        protected op_CompareNotEqual(par1: any, par2: any): any;
        protected op_Shl(par1: any, par2: any): any;
        protected op_Shr(par1: any, par2: any): any;
        protected op_And(par1: any, par2: any): any;
        protected op_Or(par1: any, par2: any): any;
        protected op_Xor(par1: any, par2: any): any;
        protected op_And2(par1: any, par2: any): any;
        protected op_Or2(par1: any, par2: any): any;
    }
}
export namespace Stimulsoft.Report.Engine.StiParser {
    class StiParser_AsmProperties extends StiParser_AsmOperations {
        protected call_property(name: any, argsList: any[]): any;
    }
}
export namespace Stimulsoft.Report.Engine.StiParser {
    class StiParser_AsmMethods extends StiParser_AsmProperties {
        protected call_method(name: any, argsList: any[], asmCommand: StiAsmCommand): any;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import DateTime = Stimulsoft.System.DateTime;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import CalendarWeekRule = Stimulsoft.System.Globalization.CalendarWeekRule;
    import DayOfWeek = Stimulsoft.System.DayOfWeek;
    class StiFunctionsDateTime {
        private static isCreated;
        static create(): void;
        static dateDiff(date1: DateTime, date2: DateTime): TimeSpan;
        static year(date: DateTime): number;
        static month(date: DateTime): number;
        static monthIdent(value: DateTime): any;
        static hour(date: DateTime): number;
        static minute(date: DateTime): number;
        static second(date: DateTime): number;
        static day(date: DateTime): number;
        static dayOfWeek(date: DateTime, loc?: boolean | string, upperCase?: boolean): string;
        static monthName(date: DateTime, loc?: boolean | string, upperCase?: boolean): string;
        static dayOfYear(date: DateTime): number;
        static dateSerial(year: number, month: number, day: number): DateTime;
        static timeSerial(hours: number, minutes: number, seconds: number): TimeSpan;
        static daysInMonth(yearOrDate: number | DateTime, month: number): number;
        static daysInYear(yearOrDate: number | DateTime): number;
        static weekOfYear(date: DateTime, firstDayOfWeek?: DayOfWeek, calendarWeekRule?: CalendarWeekRule): number;
        static weekOfMonth(date: DateTime, firstDayOfWeek?: DayOfWeek, calendarWeekRule?: CalendarWeekRule): number;
        static addDays(date: DateTime, days: number): DateTime;
        static addMonths(date: DateTime, months: number): DateTime;
        static addYears(date: DateTime, years: number): DateTime;
        static addHours(date: DateTime, hours: number): DateTime;
        static addMinutes(date: DateTime, minutes: number): DateTime;
        static addSeconds(date: DateTime, seconds: number): DateTime;
        static addMilliseconds(date: DateTime, milliseconds: number): DateTime;
        static toJapaneseDateString(date: DateTime, format?: string): string;
        private static japaneseEras;
        private static japaneseErasName;
        static toOADate(date: DateTime): number;
    }
}
export namespace Stimulsoft.Report.Engine.StiParser {
    class StiParser_AsmFunctions extends StiParser_AsmMethods {
        protected call_func(name: any, argsList: any[], asmCommand: StiAsmCommand): any;
    }
}
export namespace Stimulsoft.Report.Engine.StiParser {
    class StiParser_Parser extends StiParser_AsmFunctions {
        protected currentToken: StiToken;
        protected asmList: StiAsmCommand[];
        protected eval_exp(): void;
        private eval_exp0;
        private eval_exp01;
        private eval_exp1;
        private eval_exp10;
        private eval_exp11;
        private eval_exp12;
        private eval_exp14;
        private eval_exp15;
        private eval_exp16;
        private eval_exp17;
        private eval_exp18;
        private eval_exp2;
        private eval_exp3;
        private eval_exp4;
        private eval_exp5;
        private eval_exp6;
        private eval_exp62;
        private eval_exp7;
        private atom;
        private get_args_count;
        private get_args;
        private get_token;
    }
}
export namespace Stimulsoft.Report.Engine {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiParser = Stimulsoft.Report.Engine.StiParser.StiParser;
    import StiParserGetDataFieldValueEventArgs = Stimulsoft.Report.Engine.StiParser.StiParserGetDataFieldValueEventArgs;
    import StiAsmCommand = Stimulsoft.Report.Engine.StiParser.StiAsmCommand;
    class StiParserParameters {
        storeToPrint: boolean;
        executeIfStoreToPrint: boolean;
        returnAsmList: boolean;
        checkSyntaxMode: boolean;
        syntaxCaseSensitive: boolean;
        parser: StiParser;
        conversionStore: Hashtable<string, StiAsmCommand[]>;
        globalizedNameExt: string;
        ignoreGlobalizedName: boolean;
        constants: Hashtable<string, any>;
        getDataFieldValue: (sender: any, args: StiParserGetDataFieldValueEventArgs) => void;
        useAliases: boolean;
        variablesRecursionCheck: Hashtable;
    }
}
export namespace Stimulsoft.Report.Engine.StiParser {
    import StiParserParameters = Stimulsoft.Report.Engine.StiParserParameters;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiText = Stimulsoft.Report.Components.StiText;
    import StiVariable = Stimulsoft.Report.Dictionary.StiVariable;
    import Type = Stimulsoft.System.Type;
    class StiParserData {
        data: any;
        asmList: StiAsmCommand[];
        asmList2: StiAsmCommand[];
        conditionAsmList: StiAsmCommand[];
        parser: StiParser;
        constructor(data: any, asmList: StiAsmCommand[], parser: StiParser, conditionAsmList?: StiAsmCommand[]);
    }
    class StiFilterParserData {
        component: StiComponent;
        expression: string;
        equals(obj: any): boolean;
        constructor(component: StiComponent, expression: string);
    }
    class StiParserDataSourceFieldInfo {
        path: string[];
        objects: any[];
        constructor();
    }
    class StiParserCheckMethodInfo {
        lastOverload: number;
        lastArgsTypes: Type[];
        constructor(lastOverload: number, lastArgsTypes: Type[]);
    }
    class StiToken {
        type: StiTokenType;
        value: string;
        valueObject: any;
        position: number;
        length: number;
        constructor(type?: StiTokenType, position?: number, length?: number);
        toString(): string;
    }
    class StiAsmCommand {
        type: StiAsmCommandType;
        argsCount: number;
        parameter1: any;
        parameter2: any;
        position: number;
        length: number;
        resultType: Type;
        constructor(type: StiAsmCommandType, parameter1?: any, argsCount?: number, parameter2?: any);
        toString(): string;
    }
    class StiParserGetDataFieldValueEventArgs {
        dataSourceName: string;
        dataColumnName: string;
        processed: boolean;
        value: any;
        asmCommand: StiAsmCommand;
        path: string[];
        constructor(dataSourceName: string, dataColumnName: string, path?: string[]);
    }
    class StiParser extends StiParser_Parser {
        private sender;
        private getDataFieldValue;
        private parameters;
        executeAsm(objectAsmList: any): any;
        private getDataSourceField;
        private getVariableValue;
        private checkVariableRecursion;
        private removeRecursionCheck;
        private call_arrayElement;
        protected get_systemVariable(name: any): any;
        static parseTextValue2(inputExpression: string, component: StiComponent, sender?: any, parameters?: StiParserParameters): any;
        static parseTextValue(inputExpression: string, component: StiComponent, sender?: any, REFstoreToPrint?: any, executeIfStoreToPrint?: boolean, returnAsmList?: boolean, parser?: StiParser, constants?: Hashtable, syntaxCaseSensitive?: boolean): any;
        private parseToAsm;
        private static checkForStoreToPrint;
        static checkExpression(inputExpression: string, component: StiComponent, useAliases?: boolean): StiParserException;
        static checkForDataBandsUsedInPageTotals(stiText: StiText, report?: StiReport): void;
        static prepareReportVariables(report: StiReport): void;
        static prepareVariableValue(varr: StiVariable, report: StiReport, textBox?: StiText, fillItems?: boolean, parameters?: StiParserParameters, processReadOnly?: boolean): any;
        private static getExpressionValue;
    }
}
export namespace Stimulsoft.Report.CrossTab {
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiCrossCell extends StiCrossField implements IStiJsonReportObject, IStiGlobalizationProvider {
        meta(): StiMeta[];
        clone(cloneProperties?: boolean, cloneComponents?: boolean, base?: boolean): StiCrossCell;
        paint(g: Stimulsoft.System.Drawing.Graphics): void;
        setString(propertyName: string, value: string): void;
        protected globalizationSetString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        protected globalizationGetString(propertyName: string): string;
        getAllStrings(): string[];
        protected globalizationGetAllStrings(): string[];
        protected onGetCrossValue(e: StiGetCrossValueEventArgs): void;
        invokeGetCrossValue(e: StiGetCrossValueEventArgs): void;
        getCrossValueEvent: StiEvent;
        private val;
        get value(): string;
        set value(value: string);
        getValue(): string;
        setValue(value: string): void;
    }
}
export namespace Stimulsoft.Report.CrossTab {
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiSortType = Stimulsoft.Report.CrossTab.Core.StiSortType;
    import StiSortDirection = Stimulsoft.Report.CrossTab.Core.StiSortDirection;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiCrossHeader extends StiCrossCell implements IStiJsonReportObject, IStiGlobalizationProvider {
        meta(): StiMeta[];
        clone(cloneProperties?: boolean, cloneComponents?: boolean, base?: boolean): StiCrossHeader;
        protected onGetDisplayCrossValue(e: StiGetCrossValueEventArgs): void;
        invokeGetDisplayCrossValue(e: StiGetCrossValueEventArgs): void;
        getDisplayCrossValueEvent: StiEvent;
        setString(propertyName: string, value: string): void;
        protected globalizationSetString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        protected globalizationGetString(propertyName: string): string;
        getAllStrings(): string[];
        protected globalizationGetAllStrings(): string[];
        setValue(value: string): void;
        displayValue: string;
        get total(): StiCrossTotal;
        set total(value: StiCrossTotal);
        get isTotalVisible(): boolean;
        headerLevel: number;
        headerValue: string;
        totalGuid: string;
        showTotal: boolean;
        sortDirection: StiSortDirection;
        sortType: StiSortType;
        printOnAllPages: boolean;
        topN: StiDataTopN;
        expandExpression: string;
        isExpanded: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetDataUrlEventArgs = Stimulsoft.Report.Events.StiGetDataUrlEventArgs;
    import IStiEditable = Stimulsoft.Report.Components.IStiEditable;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiRichText extends StiSimpleText implements IStiEditable, IStiBorder, IStiGlobalizationProvider, IStiBackColor, IStiJsonReportObject, IStiGetFonts {
        implements(): any[];
        static notSupportedText: string;
        meta(): StiMeta[];
        protected static propertyCanBreak: string;
        get canBreak(): boolean;
        set canBreak(value: boolean);
        clone(cloneProperties: boolean): StiRichText;
        getDataUrlEvent: StiEvent;
        protected onGetDataUrl(e: StiGetDataUrlEventArgs): void;
        invokeGetDataUrl(sender: StiComponent, e: StiGetDataUrlEventArgs): void;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        border: StiBorder;
        getFonts(): Font[];
        margins: StiMargins;
        defaultFont: Font;
        defaultColor: Color;
        wordWrap: boolean;
        detectUrls: boolean;
        backColor: Color;
        dataColumn: string;
        wysiwyg: boolean;
        rightToLeft: boolean;
        dataUrl: string;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiEnumAngle: System.Interface<IStiEnumAngle>;
    interface IStiEnumAngle {
        angle: StiAngle;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    let IStiHorAlignment: System.Interface<IStiHorAlignment>;
    let ImplementsIStiHorAlignment: any[];
    interface IStiHorAlignment {
        horAlignment: StiHorAlignment;
    }
}
export namespace Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiForeColor: System.Interface<IStiForeColor>;
    let ImplementsIStiForeColor: any[];
    interface IStiForeColor {
        foreColor: Color;
    }
}
export namespace Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiBackColor: System.Interface<IStiBackColor>;
    let ImplementsIStiBackColor: any[];
    interface IStiBackColor {
        backColor: Color;
    }
}
export namespace Stimulsoft.Report.Components {
    import IAsIs = Stimulsoft.System.IAsIs;
    import Image = Stimulsoft.System.Drawing.Image;
    let IStiExportImage: System.Interface<IStiExportImage>;
    interface IStiExportImage extends IAsIs {
        getImage(REFzoom: any, format?: StiExportFormat): Image;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiExportImageExtended: System.Interface<IStiExportImageExtended>;
    interface IStiExportImageExtended extends IStiExportImage {
        isExportAsImage(format: StiExportFormat): boolean;
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import StiAngle = Stimulsoft.Report.Components.StiAngle;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import IStiBackColor = Stimulsoft.Report.Components.IStiBackColor;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiExportImage = Stimulsoft.Report.Components.IStiExportImage;
    import IStiExportImageExtended = Stimulsoft.Report.Components.IStiExportImageExtended;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    import IStiVertAlignment = Stimulsoft.Report.Components.IStiVertAlignment;
    import IStiBorder = Stimulsoft.Report.Components.IStiBorder;
    import IStiEnumAngle = Stimulsoft.Report.Components.IStiEnumAngle;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiBarCode extends StiComponent implements IStiBarCode, IStiBackColor, IStiForeColor, IStiExportImage, IStiExportImageExtended, IStiVertAlignment, IStiHorAlignment, IStiEnumAngle, IStiBorder, IStiJsonReportObject, IStiGetFonts {
        implements(): any[];
        meta(): StiMeta[];
        clone(cloneProperties: boolean): any;
        get helpUrl(): string;
        get localizedCategory(): string;
        get localizedName(): string;
        isExportAsImage(format: StiExportFormat): boolean;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        angle: StiAngle;
        border: StiBorder;
        foreColor: Color;
        backColor: Color;
        autoScale: boolean;
        showLabelText: boolean;
        showQuietZones: boolean;
        private _barCodeType;
        get barCodeType(): StiBarCodeTypeService;
        set barCodeType(value: StiBarCodeTypeService);
        getBarCodeString(): string;
        private _font;
        get font(): Font;
        set font(value: Font);
        private _horAlignment;
        get horAlignment(): StiHorAlignment;
        set horAlignment(value: StiHorAlignment);
        private _vertAlignment;
        get vertAlignment(): StiVertAlignment;
        set vertAlignment(value: StiVertAlignment);
        codeValue: string;
        private _code;
        get code(): string;
        set code(value: string);
        getFonts(): Font[];
        invokeEvents(): void;
        getBarCodeEvent: StiEvent;
        onGetBarCode(e: StiValueEventArgs): void;
        invokeGetBarCode(sender: StiComponent, e: StiValueEventArgs): void;
        defaultClientRectangle: RectangleD;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetExcelValueEventArgs = Stimulsoft.Report.Events.StiGetExcelValueEventArgs;
    import IStiEditable = Stimulsoft.Report.Components.IStiEditable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiCheckBox extends StiComponent implements IStiBorder, IStiTextBrush, IStiBrush, IStiBreakable, IStiEditable, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        brush: StiBrush;
        border: StiBorder;
        textBrush: StiBrush;
        editable: boolean;
        saveState(): string;
        restoreState(value: string): void;
        clone(cloneProperties: boolean): StiCheckBox;
        private _canBreak;
        get canBreak(): boolean;
        set canBreak(value: boolean);
        break(dividedComponent: StiComponent, devideFactor: number, REFdivideLine: any): boolean;
        invokeEvents(): void;
        getCheckedEvent: StiEvent;
        protected onGetChecked(e: StiValueEventArgs): void;
        invokeGetChecked(sender: StiComponent, e: StiValueEventArgs): void;
        getExcelValueEvent: StiEvent;
        protected onGetExcelValue(e: StiGetExcelValueEventArgs): void;
        invokeGetExcelValue(sender: StiComponent, e: StiGetExcelValueEventArgs): void;
        checkedValue: any;
        contourColor: Color;
        size: number;
        private _checkStyle;
        get checkStyle(): StiCheckStyle;
        set checkStyle(value: StiCheckStyle);
        values: string;
        checkStyleForTrue: StiCheckStyle;
        checkStyleForFalse: StiCheckStyle;
        checked: string;
        excelDataValue: string;
        excelValue: string;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import List = Stimulsoft.System.Collections.List;
    class StiDataSourceHelper {
        static getDatabaseFromDataSource(dataSource: StiDataSource): StiDatabase;
        static getDatabaseFromDataSource2(dataSource: StiDataSource): StiDatabase;
        static getDataSourcesFromDatabase(report: StiReport, database: StiDatabase): List<StiDataSource>;
        static getUsedDataSourcesNamesList(report: StiReport): string[];
        static getUsedDataSourcesNames(report: StiReport): Hashtable;
        static checkExpression(expression: string, component: StiComponent, datasourcesNames: Hashtable): void;
        private static addDataSourceName;
        private static addDataSourceColumn;
        private static addRelation;
        private static addSort;
        static getDataSourcesUsedInRequestFromUsersVariables(report: StiReport): Hashtable;
    }
}
export namespace Stimulsoft.Report.Engine {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiRenderProvider {
        static renderAsync(report: StiReport, state: StiRenderState): Promise<void>;
        static render(report: StiReport, state: StiRenderState): void;
        private static StiRenderProvider_AddAnchor_Rendering;
        static connectToDataAsync(report: StiReport, isConnectToDataV2?: boolean): Promise<void>;
        static connectToData(report: StiReport, isConnectToDataV2?: boolean): void;
        private static disconnectFromData;
        private static isDialogsOnStartExist;
        private static renderFormsOnStart;
        private static renderFormsOnEnd;
        private static checkDialogsInPreview;
        static clearPagesWhichLessThenFromPageAndGreaterThenToPage(report: StiReport, state: StiRenderState): void;
        private static initCacheMode;
        private static removeAllPagesLessThenFromPageAndGreaterThenToPage;
        private static finishAllPagesInNotCachedPagesArray;
        static processPageToCache(report: StiReport, page: StiPage, final: boolean): void;
        static isFirstPage(report: StiReport, page: StiPage): boolean;
        static isLastPage(report: StiReport, page: StiPage): boolean;
        private static renderFirstPassAsync;
        private static renderFirstPass;
        static clearPagesForFirstPass(report: StiReport): void;
        private static getNumberOfPass;
        private static madeCollate;
        private static madeMirrorMargins;
        private static initReport;
        private static clearTotals;
        static prepareSubReportsAndDrillDownPages(report: StiReport): Hashtable;
        private static renderReportAsync;
        private static renderReport;
        static renderTable(report: StiReport): void;
        private static finishProgressForm;
    }
}
export namespace Stimulsoft.Report.Engine {
    class StiRenderState {
        latestProgressValue: number;
        private _fromPage;
        get fromPage(): number;
        private _toPage;
        get toPage(): number;
        showProgress: boolean;
        isSubReportMode: boolean;
        private _destroyPagesWhichNotInRange;
        get destroyPagesWhichNotInRange(): boolean;
        private _renderOnlyPagesFromRange;
        get renderOnlyPagesFromRange(): boolean;
        constructor(fromPage?: number, toPage?: number, showProgress?: boolean, destroyPagesWhichNotInRange?: boolean, renderOnlyPagesFromRange?: boolean);
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiBookmark = Stimulsoft.Report.Components.StiBookmark;
    class StiBookmarksHelper {
        static getBookmark(bookmark: StiBookmark, name: string): StiBookmark;
        static prepareBookmark(bookmark: StiBookmark): void;
        static createBookmark(text: string, componentGuid?: string): StiBookmark;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiBusinessObjectData {
        category: string;
        name: string;
        alias: string;
        businessObjectValue: any;
        constructor(category: string, name: string, alias: string, value: any);
    }
}
export namespace Stimulsoft.Report.Export {
    import IAsIs = Stimulsoft.System.IAsIs;
    class StiExportSettings implements IAsIs {
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        getExportFormat(): StiExportFormat;
        toParameters(): any;
        protected _returnType: any;
        get returnType(): any;
        set returnType(value: any);
    }
}
export namespace Stimulsoft.Report.Export {
    class StiPageRangeExportSettings extends StiExportSettings {
        pageRange: StiPagesRange;
        toParameters(): any;
    }
}
export namespace Stimulsoft.Report.Export {
    import StiTiffCompressionScheme = Stimulsoft.Report.Export.StiTiffCompressionScheme;
    import StiPageRangeExportSettings = Stimulsoft.Report.Export.StiPageRangeExportSettings;
    import StiExportFormat = Stimulsoft.Report.StiExportFormat;
    import StiImageFormat = Stimulsoft.Report.Export.StiImageFormat;
    import StiMonochromeDitheringType = Stimulsoft.Report.Export.StiMonochromeDitheringType;
    import StiImageType = Stimulsoft.Report.Export.StiImageType;
    class StiImageExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        imageType: StiImageType;
        imageZoom: number;
        imageResolution: number;
        cutEdges: boolean;
        imageFormat: StiImageFormat;
        multipleFiles: boolean;
        ditheringType: StiMonochromeDitheringType;
        tiffCompressionScheme: StiTiffCompressionScheme;
        compressToArchive: boolean;
        protected _returnType: any;
        get returnType(): any;
        set returnType(value: any);
        constructor(imageType?: StiImageType);
        toParameters(): any;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    abstract class StiExportService implements IStiExportService {
        get exportFormat(): StiExportFormat;
        isStopped: boolean;
        multipleFiles: boolean;
        renderedPagesCount: number;
        currentPassNumber: number;
        maximumPassNumber: number;
        exportServiceId: string;
        compressToArchive: boolean;
        invokeExporting(page: StiPage, pages: StiPagesCollection, currentPass: number, maximumPass: number): void;
        invokeExporting2(value: number, maximum: number, currentPass: number, maximumPass: number): void;
        abstract exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportTo2(report: StiReport, stream: MemoryStream, settings: StiExportSettings): Promise<void>;
        protected static getOrderFileName(baseName: string, index: number, totalPagesCount: number, extension: string): string;
    }
}
export namespace Stimulsoft.Report.Export {
    class StiExportAssembly {
        static get isAssemblyLoaded(): boolean;
    }
}
export namespace Stimulsoft.Report.Export {
    import ImageFormat = Stimulsoft.System.Drawing.Imaging.ImageFormat;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiImageExportService extends StiExportService {
        get defaultExtension(): string;
        getExtensionFromSettings(): string;
        get exportFormat(): StiExportFormat;
        get imageFormat(): ImageFormat;
        get groupCategory(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportTo2(report: StiReport, stream: MemoryStream, settings: StiExportSettings): Promise<void>;
        imageSettings: StiImageExportSettings;
        report: StiReport;
        private exportImage;
        private exportImageAsync;
        private getSettings;
        constructor();
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import List = Stimulsoft.System.Collections.List;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import Type = Stimulsoft.System.Type;
    import IStiQueryObject = Stimulsoft.Data.Engine.IStiQueryObject;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import StiDataRequestOption = Stimulsoft.Data.Engine.StiDataRequestOption;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiDataTransformation extends StiDataStoreSource implements IStiQueryObject, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        retrieveUsedDataNames(group: string): List<string>;
        getDataSources(dataNames: List<string>): List<IStiAppDataSource>;
        getKey(): string;
        isDataSource: true;
        getDataTable2Async(allowConnectToData: boolean): Promise<DataTable>;
        getDataAdapterType(): Type;
        sorts: List<StiDataSortRule>;
        filters: List<StiDataFilterRule>;
        actions: List<StiDataActionRule>;
        clone(): StiDataTransformation;
        retrieveDataTable(dataRequest: StiDataRequestOption): Promise<DataTable>;
        connectToData(option?: StiDataRequestOption): Promise<void>;
        getMeters(group?: string): List<IStiMeter>;
        getMeter(column: StiDataTransformationColumn): IStiMeter;
        constructor(nameInSource?: string, name?: string, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import Type = Stimulsoft.System.Type;
    import StiPromise = Stimulsoft.System.StiPromise;
    import StiFileDataOptions = Stimulsoft.Base.StiFileDataOptions;
    import StiFileDataConnector = Stimulsoft.Base.StiFileDataConnector;
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiFileDatabase extends StiDatabase implements IStiJsonReportObject {
        meta(): StiMeta[];
        dataSchema: StiDataSchema;
        pathData: string;
        get canBeTypeChangeResult(): boolean;
        copyDataSourceFrom(dataSourceToCopy: StiDataSource): StiDataSource;
        getDatabaseInformation(report: StiReport): StiDatabaseInformation;
        getDatabaseInformationAsync(report: StiReport): StiPromise<StiDatabaseInformation>;
        createDataSources(dictionary: StiDictionary): void;
        private createDataTableSource;
        static parsePath(path: string, report: StiReport): string;
        protected regDataSetInDataStore(dictionary: StiDictionary, dataSet: DataSet): void;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        regDataAsync(dictionary: StiDictionary, loadData: boolean): StiPromise<void>;
        createFileConnector(): StiFileDataConnector;
        protected getConnectorOptions(report: StiReport, isShema: boolean): StiFileDataOptions;
        protected getConnectorOptionsAsync(report: StiReport, isShema: boolean): Promise<StiFileDataOptions>;
        getDatasourceType(): Type;
        fetchSiblingDataSources(dictionary: IStiAppDictionary): List<IStiAppDataSource>;
        constructor(name?: string, pathData?: string, key?: string);
    }
}
export namespace Stimulsoft.Report.Helpers {
    import IStiApp = Stimulsoft.Base.IStiApp;
    class StiDataResourceHelper {
        static saveSnapshotAsync(app: IStiApp): Promise<void>;
        private static getRelationInformation;
        private static saveRelationSnapshot;
        private static replaceDatabase;
        private static databaseFromRecource;
        private static getListResourceSnapshot;
        private static dataSetToResourceXml;
        private static getNewResourceName;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    let IStiUnitConvert: System.Interface<IStiUnitConvert>;
    interface IStiUnitConvert {
        convert(oldUnit: StiUnit, newUnit: StiUnit): any;
    }
}
export namespace Stimulsoft.Report.Dashboard.Export {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiPageOrientation = Stimulsoft.Report.Components.StiPageOrientation;
    import PaperKind = Stimulsoft.System.Drawing.Printing.PaperKind;
    let IStiDashboardExportSettings: System.Interface<IStiDashboardExportSettings>;
    interface IStiDashboardExportSettings extends IAsIs {
        renderBorders: boolean;
        renderSingleElement: boolean;
        renderSinglePage: boolean;
        orientation: StiPageOrientation;
        paperSize: PaperKind;
        openAfterExport: boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard.Export {
    import StiDashboardScaleMode = Stimulsoft.Report.Dashboard.StiDashboardScaleMode;
    import StiImageType = Stimulsoft.Report.Export.StiImageType;
    let IStiImageDashboardExportSettings: System.Interface<IStiImageDashboardExportSettings>;
    interface IStiImageDashboardExportSettings extends IStiDashboardExportSettings {
        imageType: StiImageType;
        scale: number;
        scaleMode: StiDashboardScaleMode;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import StiExportSettings = Stimulsoft.Report.Export.StiExportSettings;
    class StiDashboardExport {
        static export(report: StiReport, stream: MemoryStream, settings: StiExportSettings): Promise<void>;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPrimitive extends StiComponent {
        meta(): StiMeta[];
        setCanShrink(value: boolean): void;
        setCanGrow(value: boolean): void;
        setShift(value: boolean): void;
        setDockStyle(value: StiDockStyle): void;
        setGrowToHeight(value: boolean): void;
        get localizedCategory(): string;
        get componentType(): StiComponentType;
        get priority(): number;
        get clientRectangle(): RectangleD;
        set clientRectangle(value: RectangleD);
        getDisplayRectangle(): RectangleD;
        setDisplayRectangle(value: RectangleD): void;
        setDirectDisplayRectangle(rect: RectangleD): void;
        constructor(rect?: RectangleD, isSuper?: boolean);
        protected construct(rect?: RectangleD | any): void;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLinePrimitive extends StiPrimitive implements IStiJsonReportObject {
        meta(): StiMeta[];
        get invalidateOnMouseOver(): boolean;
        defaultClientRectangle: RectangleD;
        style: StiPenStyle;
        color: Color;
        size: number;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCrossLinePrimitive extends StiLinePrimitive {
        static nullGuid: string;
        onRemoveComponent(): void;
        canContainIn(component: StiComponent): boolean;
        setLinked(value: boolean): void;
        getLeft(): number;
        setLeft(value: number): void;
        getTop(): number;
        setTop(value: number): void;
        getHeight(): number;
        setHeight(value: number): void;
        storedStartPoint: StiStartPointPrimitive;
        getStartPoint(cont?: StiContainer): StiStartPointPrimitive;
        storedEndPoint: StiEndPointPrimitive;
        getEndPoint(cont?: StiContainer): StiEndPointPrimitive;
        isParentContainerSelected(point: StiPointPrimitive): boolean;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiConditionsCollection = Stimulsoft.Report.Components.StiConditionsCollection;
    import StiCrossLinePrimitive = Stimulsoft.Report.Components.StiCrossLinePrimitive;
    import StiAppExpressionCollection = Stimulsoft.Base.StiAppExpressionCollection;
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    class StiCrossPrimitiveConditionsData {
        conditions: Dictionary<StiCrossLinePrimitive, StiConditionsCollection>;
        expressions: Dictionary<StiCrossLinePrimitive, StiAppExpressionCollection>;
    }
    class StiCrossLinePrimitiveHelper {
        static storeConditions(report: StiReport): StiCrossPrimitiveConditionsData;
        static restoreConditions(storeObj: StiCrossPrimitiveConditionsData): void;
    }
}
export namespace Stimulsoft.Report {
    import StiGetSubReportEventArgs = Stimulsoft.Report.Events.StiGetSubReportEventArgs;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiDatabase = Stimulsoft.Report.Dictionary.StiDatabase;
    import DataSet = Stimulsoft.System.Data.DataSet;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Header = Stimulsoft.System.Header;
    import StiGisDataType = Stimulsoft.Base.StiGisDataType;
    import StiRelationDirection = Stimulsoft.Base.StiRelationDirection;
    import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
    import IStiDesignerBase = Stimulsoft.Report.Design.IStiDesignerBase;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiMetaTagCollection = Stimulsoft.Report.Dictionary.StiMetaTagCollection;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiAppCell = Stimulsoft.Base.IStiAppCell;
    import IStiApp = Stimulsoft.Base.IStiApp;
    import StiExportSettings = Stimulsoft.Report.Export.StiExportSettings;
    import StiExportService = Stimulsoft.Report.Export.StiExportService;
    import StiExportEventArgs = Stimulsoft.Report.Events.StiExportEventArgs;
    import StiHtmlExportMode = Stimulsoft.Report.Export.StiHtmlExportMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiDialogInfo = Stimulsoft.Report.Dictionary.StiDialogInfo;
    import StiDataCollection = Stimulsoft.Report.Dictionary.StiDataCollection;
    import StiDataSourcesCollection = Stimulsoft.Report.Dictionary.StiDataSourcesCollection;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    import IStiUnitConvert = Stimulsoft.Report.Components.IStiUnitConvert;
    import StiEngine = Stimulsoft.Report.Engine.StiEngine;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiBookmark = Stimulsoft.Report.Components.StiBookmark;
    import StiStylesCollection = Stimulsoft.Report.Styles.StiStylesCollection;
    import StiAggregateFunctionService = Stimulsoft.Report.Dictionary.StiAggregateFunctionService;
    import Type = Stimulsoft.System.Type;
    import DateTime = Stimulsoft.System.DateTime;
    import StiBusinessObjectData = Stimulsoft.Report.Dictionary.StiBusinessObjectData;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiMasterComponent = Stimulsoft.Report.Components.IStiMasterComponent;
    import IStiReport = Stimulsoft.Base.IStiReport;
    import List = Stimulsoft.System.Collections.List;
    import IStiReportPage = Stimulsoft.Base.IStiReportPage;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import StiClone = Stimulsoft.Report.Components.StiClone;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    export type EventDataArgs = {
        event: string;
        sender: string;
    };
    export type ReportDataArgs = {
        report: StiReport;
    };
    export type AsyncDataArgs = {
        async: boolean;
        preventDefault: boolean;
    };
    export type PrepareVariablesObject = {
        name: string;
        value: any | string[];
        type: string;
    };
    export type PrepareVariablesArgs = EventDataArgs & ReportDataArgs & AsyncDataArgs & {
        success?: boolean;
        notice?: string;
        variables: PrepareVariablesObject[];
        callback: (result: PrepareVariablesObject[] | PrepareVariablesArgs) => void;
    };
    export type PrintReportEventArgs = EventDataArgs & ReportDataArgs & AsyncDataArgs & {
        printAction: string;
    };
    export type PrintedReportEventArgs = EventDataArgs & ReportDataArgs & AsyncDataArgs & {
        data: string | number[];
        callback: () => void;
    };
    export type EndProcessDataArgs = EndProcessDataCommand & ReportDataArgs & EventDataArgs;
    export type EndProcessDataCommand = {
        command: string;
        database: string;
        connection: string;
        dataSource: string;
        result: any;
    };
    export type ProcessDataCommand = AsyncDataArgs & {
        command: string;
        database: string;
        connection: string;
        withCredentials: boolean;
        headers: Header[];
    };
    export type BeginProcessDataArgs = ProcessDataCommand & ReportDataArgs & EventDataArgs;
    export type ProcessODataDataCommand = ProcessDataCommand & {
        connectionString: string;
        dataSource: string;
        collectionName: string;
        callback: (result: any) => void;
    };
    export type ProcessSqlDataCommand = ProcessDataCommand & {
        connectionString: string;
        dataSource: string;
        queryString: string;
        timeout: number;
        parameters: {
            name: string;
            value: string | number;
        }[];
        escapeQueryParameters: boolean;
        maxDataRows: number;
    };
    export type ProcessExcelDataCommand = ProcessDataCommand & {
        pathData: string;
        firstRowIsHeader: boolean;
    };
    export type ProcessGisDataArgs = ProcessDataCommand & {
        pathData: string;
        separator: string;
        dataType: StiGisDataType;
    };
    export type ProcessJsonDataArgs = ProcessDataCommand & {
        pathData: string;
        tryParseDateTime: boolean;
        relationDirection: StiRelationDirection;
    };
    export type ProcessCsvDataArgs = ProcessDataCommand & {
        pathData: string;
        separator: string;
        codePage: number;
    };
    export type ProcessDBaseDataArgs = ProcessDataCommand & {
        pathData: string;
        codePage: number;
    };
    export type ProcessXsdDataArgs = ProcessDataCommand & {
        pathSchema: string;
    };
    export type ProcessXmlDataArgs = ProcessDataCommand & {
        pathData: string;
        tryParseDateTime: boolean;
        relationDirection: StiRelationDirection;
    };
    type Buffer = Uint8Array;
    let Buffer: any;
    export class StiJsonLoaderHelper {
        masterComponents: IStiMasterComponent[];
        clones: StiClone[];
        dialogInfo: StiDialogInfo[];
        barcodeTypes: Stimulsoft.Report.BarCodes.StiBarCodeTypeService[];
        textFormatTypes: string[];
        gaugeStyles: IStiGaugeStyle[];
        refNames: string[];
        clean(): void;
        linkComponents(report: StiReport): void;
    }
    export class StiReport implements IStiUnitConvert, IStiReport, IStiApp, IStiAppCell, IStiGetFonts {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        clone(): StiReport;
        jsonLoaderHelper: StiJsonLoaderHelper;
        private storedCulture;
        private saveToJsonInternal;
        saveSnapshot(): Promise<string>;
        private loadFromJsonInternal;
        private loadFromXmlInternal;
        static isPackedFile(content: number[] | Uint8Array): boolean;
        static isEncryptedFile(bytes: number[] | Uint8Array): boolean;
        private static isEncryptedFile2;
        load(param: string | number[] | XmlNode | any): void;
        loadFile(filePath: string): void;
        loadPacked(param: string | number[] | any): void;
        loadPackedFile(filePath: string): void;
        loadEncryptedReport(param: string | number[] | any, key: string): void;
        loadEncryptedReportFile(filePath: string, key: string): void;
        private loadFontsFromResources;
        private applyCorrections;
        loadDocument(param: string | number[] | any): void;
        loadDocumentFile(filePath: string): void;
        loadPackedDocument(param: string | number[] | any): void;
        loadPackedDocumentFile(filePath: string): void;
        loadEncryptedDocument(param: string | number[] | any, key: string): void;
        loadEncryptedDocumentFile(filePath: string, key: string): void;
        saveEncryptedReportToByteArray(key: string): number[];
        saveEncryptedReportToString(key: string): string;
        saveEncryptedReportFile(path: string, key: string): void;
        savePackedFile(path: string): void;
        savePackedToString(): string;
        savePackedToByteArray(): number[];
        saveToJsonString(): string;
        saveFile(path: string): void;
        saveDocumentToJsonString(): string;
        saveDocumentFile(path: string): string;
        saveEncryptedDocumentToByteArray(key: string): number[];
        saveEncryptedDocumentToString(key: string): string;
        saveEncryptedDocumentFile(path: string, key: string): void;
        savePackedDocumentFile(path: string): void;
        savePackedDocumentToString(): string;
        savePackedDocumentToByteArray(): number[];
        saveEditableFieldsFile(path: string): StiReport;
        saveEditableFields(): string;
        loadEditableFieldsFile(path: string): StiReport;
        loadEditableFields(param: string | XmlNode): StiReport;
        mergeDocumentAsync(report: StiReport, needRendering?: boolean): Promise<void>;
        private clear;
        getDictionary(): IStiAppDictionary;
        getKey(): string;
        setKey(key: string): void;
        fetchPages(): List<IStiReportPage>;
        getFonts(): Font[];
        private _pageNumber;
        get pageNumber(): number;
        set pageNumber(value: number);
        get pageNumberThrough(): number;
        _totalPageCountValue: number;
        get totalPageCount(): number;
        set totalPageCount(value: number);
        get totalPageCountThrough(): number;
        get pageNofM(): string;
        get pageNofMThrough(): string;
        pageNofMLocalizationString: string;
        line: number;
        groupLine: number;
        get lineRoman(): string;
        get lineABC(): string;
        column: number;
        lineThrough: number;
        get date(): DateTime;
        get today(): DateTime;
        get time(): DateTime;
        cacheAllData: boolean;
        retrieveOnlyUsedData: boolean;
        reportCacheMode: StiReportCacheMode;
        htmlPreviewMode: StiHtmlPreviewMode;
        convertNulls: boolean;
        get isFirstPage(): boolean;
        get isLastPage(): boolean;
        get isFirstPageThrough(): boolean;
        get isLastPageThrough(): boolean;
        get isFirstPass(): boolean;
        get isSecondPass(): boolean;
        currentPage: number;
        currentPrintPage: number;
        pageCopyNumber: number;
        private _businessObjectsStore;
        get businessObjectsStore(): StiBusinessObjectData[];
        private fieldNames;
        variables: Hashtable<string, any>;
        getVariable(name: string, onlyVariable?: boolean): any;
        setVariable(name: string, value: any, onlyVariable?: boolean): void;
        private _aggregateFunctions;
        get aggregateFunctions(): StiAggregateFunctionService[];
        set aggregateFunctions(value: StiAggregateFunctionService[]);
        private _dictionary;
        get dictionary(): Stimulsoft.Report.Dictionary.StiDictionary;
        set dictionary(value: Stimulsoft.Report.Dictionary.StiDictionary);
        get dataSources(): StiDataSourcesCollection;
        get dataStore(): StiDataCollection;
        regData(name: string, alias: string, data: DataTable | DataSet | StiDataCollection | string | Object, synchronize?: boolean): void;
        regBusinessObject2(category: string, name: string, alias: string, value: any): void;
        regBusinessObject(businessObjects: StiBusinessObjectData[]): void;
        private storeBusinessObjectWithCheckExistingData;
        regMySqlConnection(name: string, connectionString: string, synchronize?: boolean): Promise<StiDatabase>;
        regPostgreSqlConnection(name: string, connectionString: string, synchronize?: boolean): Promise<StiDatabase>;
        regFirebirdConnection(name: string, connectionString: string, synchronize?: boolean): Promise<StiDatabase>;
        regOracleConnection(name: string, connectionString: string, synchronize?: boolean): Promise<StiDatabase>;
        regSqlServerConnection(name: string, connectionString: string, synchronize?: boolean): Promise<StiDatabase>;
        private regServerConnection;
        regJsonFile(name: string, fileName: string, synchronize?: boolean): StiDatabase;
        regExcelFile(name: string, fileName: string, synchronize?: boolean): StiDatabase;
        regCsvFile(name: string, fileName: string, synchronize?: boolean): StiDatabase;
        regDbfFile(name: string, fileName: string, synchronize?: boolean): StiDatabase;
        regXmlFile(name: string, fileNameSchema: string, fileNameData: string, synchronize?: boolean): StiDatabase;
        private regDataFile;
        regJsonData(name: string, data: number[] | string, synchronize?: boolean): StiDatabase;
        regExcelData(name: string, data: number[] | string, synchronize?: boolean): StiDatabase;
        regCsvData(name: string, data: number[] | string, synchronize?: boolean): StiDatabase;
        regDbfData(name: string, data: number[] | string, synchronize?: boolean): StiDatabase;
        regXmlData(name: string, schema: number[] | string, data: number[] | string, synchronize?: boolean): StiDatabase;
        regObjectData(name: string, fileType: StiResourceType, data: number[] | string, synchronize?: boolean): StiDatabase;
        private _script;
        get script(): string;
        set script(value: string);
        scriptNew(): void;
        private prepareVariablesFromURL;
        private getPrepareVariables;
        private getPrepareVariableValue;
        private setPrepareVariables;
        onPrepareVariables: (args: PrepareVariablesArgs, callback: (result: PrepareVariablesObject[] | PrepareVariablesArgs) => void) => void;
        invokePrepareVariablesAsync(): Promise<unknown>;
        onBeginProcessData: (args: BeginProcessDataArgs & ProcessODataDataCommand & ProcessSqlDataCommand & ProcessExcelDataCommand & ProcessGisDataArgs & ProcessJsonDataArgs & ProcessCsvDataArgs & ProcessDBaseDataArgs & ProcessXsdDataArgs & ProcessXmlDataArgs, callback: (result: any) => void) => void;
        invokeBeginProcessData(command: ProcessDataCommand, callback: (result: any) => void): void;
        onEndProcessData: (args: EndProcessDataArgs & ProcessODataDataCommand & ProcessSqlDataCommand & ProcessExcelDataCommand & ProcessGisDataArgs & ProcessJsonDataArgs & ProcessCsvDataArgs & ProcessDBaseDataArgs & ProcessXsdDataArgs & ProcessXmlDataArgs) => void;
        invokeEndProcessData(command: EndProcessDataCommand): void;
        invokeRefreshViewer(): void;
        invokeResetAllFilters(): void;
        beginRenderEvent: StiEvent;
        onBeginRender: () => void;
        invokeBeginRender(): void;
        invokeBeginRenderAsync(): Promise<void>;
        renderingEvent: StiEvent;
        onRendering: () => void;
        invokeRendering(): void;
        endRenderEvent: StiEvent;
        onEndRender: () => void;
        invokeEndRender(): void;
        invokeStatusChanged(): void;
        exportingEvent: StiEvent;
        onExporting: (args: StiExportEventArgs) => void;
        invokeExporting(exportFormat: StiExportFormat): void;
        exportedEvent: StiEvent;
        onExported: (args: StiExportEventArgs) => void;
        invokeExported(exportFormat: StiExportFormat): void;
        printingEvent: StiEvent;
        onPrinting: () => void;
        invokePrinting(): void;
        printedEvent: StiEvent;
        onPrinted: (args: PrintedReportEventArgs) => void;
        invokePrinted(data: string | number[], callback: (result: string | number[]) => void): void;
        refreshingEvent: StiEvent;
        onRefreshing: () => void;
        invokeRefreshing(): void;
        getSubReport: StiEvent;
        onGetSubReport: (e: StiGetSubReportEventArgs) => void;
        invokeGetSubReport(e: StiGetSubReportEventArgs): void;
        invokeReportCacheProcessing(): void;
        reportCacheProcessingEvent: StiEvent;
        get unit(): StiUnit;
        set unit(value: StiUnit);
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        static changeType(value: any, conversionType: Type, convertNulls?: boolean): any;
        applyStyleCollection(collectionName: string): void;
        applyStyles(): void;
        updateInheritedReport(masterReport?: StiReport): void;
        private _masterReport;
        get masterReport(): string;
        set masterReport(value: string);
        setInheritedMode(inherited: boolean): void;
        getCurrentPage(): StiPage;
        static getReportVersion(): string;
        private updateReportVersion;
        writeToReportRenderingMessages(str: string): void;
        getComponentByName(componentName: string): StiComponent;
        getComponentByGuid(guid: string): StiComponent;
        toString2(obj: any): string;
        checkExcelValue(sender: any, value: any): any;
        toString3(sender: any, obj: any, allowExcelCheck?: boolean): string;
        private generateReportGuid;
        addAnchor(value: any, component?: any): void;
        getAnchorPageNumber(value: any): number;
        getAnchorPageNumberThrough(value: any): number;
        private getAnchor;
        getComponents(): StiComponentsCollection;
        getRenderedComponents(): StiComponentsCollection;
        getComponentsCount(): number;
        renameStyle(oldStylename: string, newStyleName: string): void;
        localizeReport(cultureName: string): void;
        getParsedCulture(): string;
        private anchors;
        subReportsMasterReport: StiReport;
        subReportsResetPageNumber: boolean;
        subReportsPrintOnPreviousPage: boolean;
        subReportsUrls: Hashtable;
        indexName: number;
        containsTables: boolean;
        cachedTotals: Hashtable;
        cachedTotalsLocked: boolean;
        preparedExportImages: Hashtable<StiComponent, Image>;
        modifiedVariables: Hashtable;
        metaTags: StiMetaTagCollection;
        reportVersion: string;
        engine: StiEngine;
        private _reportRenderingMessages;
        get reportRenderingMessages(): string[];
        set reportRenderingMessages(value: string[]);
        interactionCollapsingStates: any;
        subReports: StiReportsCollection;
        key: string;
        reportGuid: string;
        tag: any;
        reportCachePath: string;
        imageCache: Hashtable;
        parentReport: StiReport;
        globalizationManager: IStiGlobalizationManager;
        pages: StiPagesCollection;
        private _renderedPages;
        get renderedPages(): StiPagesCollection;
        set renderedPages(value: StiPagesCollection);
        private _info;
        get info(): Stimulsoft.Report.Design.StiDesignerInfo;
        set info(value: Stimulsoft.Report.Design.StiDesignerInfo);
        designer: IStiDesignerBase;
        private pointerValue;
        get pointer(): StiBookmark;
        set pointer(value: StiBookmark);
        bookmarkValue: StiBookmark;
        get bookmark(): StiBookmark;
        set bookmark(value: StiBookmark);
        private _manualBookmark;
        get manualBookmark(): StiBookmark;
        set manualBookmark(value: StiBookmark);
        private _totals;
        get totals(): Hashtable;
        set totals(value: Hashtable);
        private _cells;
        get cells(): StiCells;
        password: string;
        private _dataBandsUsedInPageTotals;
        get dataBandsUsedInPageTotals(): string[];
        set dataBandsUsedInPageTotals(value: string[]);
        private _listOfUsedData;
        get listOfUsedData(): string[];
        set listOfUsedData(value: string[]);
        renderedWith: StiRenderedWith;
        reportPass: StiReportPass;
        httpHeadersContainer: Header[];
        isRendered: boolean;
        isRendering: boolean;
        private _isModified;
        get isModified(): boolean;
        set isModified(value: boolean);
        isStopped: boolean;
        isExporting: boolean;
        isSerializing: boolean;
        isPageDesigner: boolean;
        private isPrintingValue;
        get isPrinting(): boolean;
        set isPrinting(value: boolean);
        get containsDashboard(): boolean;
        get containsOnlyDashboard(): boolean;
        get isDesigning(): boolean;
        get isPreviewDialogs(): boolean;
        isReportRenderingAfterSubmit: boolean;
        isDocument: boolean;
        isInteractionRendering: boolean;
        private _reportName;
        get reportName(): string;
        set reportName(value: string);
        reportAlias: string;
        reportAuthor: string;
        reportDescription: string;
        reportImage: string;
        reportIcon: string;
        reportCreated: DateTime;
        reportChanged: DateTime;
        styles: StiStylesCollection;
        private _numberOfPass;
        get numberOfPass(): StiNumberOfPass;
        set numberOfPass(value: StiNumberOfPass);
        private _calculationMode;
        get calculationMode(): StiCalculationMode;
        private _reportUnit;
        get reportUnit(): StiReportUnitType;
        set reportUnit(value: StiReportUnitType);
        private _stopBeforePage;
        get stopBeforePage(): number;
        set stopBeforePage(value: number);
        previewSettings: number;
        dashboardViewerSettings: StiDashboardViewerSettings;
        previewToolBarOptions: StiPreviewToolBarOptions;
        private _collate;
        get collate(): number;
        set collate(value: number);
        globalizationStrings: StiGlobalizationContainerCollection;
        autoLocalizeReportOnRun: boolean;
        scriptLanguage: StiReportLanguageType;
        parametersOrientation: StiOrientation;
        private _parameterWidth;
        get parameterWidth(): number;
        set parameterWidth(value: number);
        parameterAlignment: StiHorAlignment;
        requestParameters: boolean;
        cacheTotals: boolean;
        private _culture;
        get culture(): string;
        set culture(value: string);
        private _refreshTime;
        get refreshTime(): number;
        set refreshTime(value: number);
        private _scrollTime;
        get scrollTime(): number;
        set scrollTime(value: number);
        compiledReport: StiReport;
        private _allowEvalEvent;
        get allowEvalEvent(): boolean;
        set allowEvalEvent(value: boolean);
        resetAggregateFunctions(): void;
        resetRenderedState(): this;
        getLabel(variableName: string): string;
        getParam(paramName: string): any;
        licenseKey: string;
        dispose(): void;
        constructor();
        renderAsync(onRender: (report: StiReport, error?: any) => void, fromPage?: number, toPage?: number): void;
        renderAsync2(fromPage?: number, toPage?: number): Promise<void>;
        render(showProgress?: boolean, fromPage?: number, toPage?: number): void;
        processAutoLocalizeReportOnRun(): void;
        private renderReportAsync;
        private renderReport;
        print(pageRange?: StiPagesRange, exportMode?: StiHtmlExportMode): void;
        printToPdf(pageRange?: StiPagesRange, element?: HTMLElement): void;
        reportFile: string;
        reportFilePath: string;
        exportDocumentAsync(onExport: (result: string | number[] | Buffer, error: any) => void, exportFormat: StiExportFormat, exportService?: StiExportService, settings?: StiExportSettings): void;
        exportDocumentAsync2(exportFormat: StiExportFormat, exportService?: StiExportService, settings?: StiExportSettings): Promise<string | number[] | Buffer>;
        exportDocument(exportFormat: StiExportFormat, exportService?: StiExportService, settings?: StiExportSettings, onExport?: (result: string | number[] | Buffer, error?: any) => void): string | number[] | Buffer;
        static createNewReport(): StiReport;
        static createNewDashboard(): StiReport;
    }
    export {};
}
export namespace Stimulsoft.Report.BarCodes {
    enum CodeSet {
        None = 0,
        A = 1,
        B = 2,
        C = 3
    }
    enum ControlCodes {
        FNC1 = 129,
        FNC2 = 130,
        FNC3 = 131,
        FNC4 = 132,
        CodeA = 133,
        CodeB = 134,
        CodeC = 135,
        Shift = 136
    }
    enum BarcodeCommands {
        FNC1 = 102,
        FNC2 = 97,
        FNC3 = 96,
        FNC4A = 101,
        FNC4B = 100,
        CodeA = 101,
        CodeB = 100,
        CodeC = 99,
        Shift = 98,
        StartA = 103,
        StartB = 104,
        StartC = 105,
        Stop = 106
    }
    enum StiCheckSum {
        Yes = 0,
        No = 1
    }
    enum StiPlesseyCheckSum {
        None = 0,
        Modulo10 = 1,
        Modulo11 = 2
    }
    enum StiDataMatrixSize {
        Automatic = -1,
        s10x10 = 0,
        s12x12 = 1,
        s8x18 = 2,
        s14x14 = 3,
        s8x32 = 4,
        s16x16 = 5,
        s12x26 = 6,
        s18x18 = 7,
        s20x20 = 8,
        s12x36 = 9,
        s22x22 = 10,
        s16x36 = 11,
        s24x24 = 12,
        s26x26 = 13,
        s16x48 = 14,
        s32x32 = 15,
        s36x36 = 16,
        s40x40 = 17,
        s44x44 = 18,
        s48x48 = 19,
        s52x52 = 20,
        s64x64 = 21,
        s72x72 = 22,
        s80x80 = 23,
        s88x88 = 24,
        s96x96 = 25,
        s104x104 = 26,
        s120x120 = 27,
        s132x132 = 28,
        s144x144 = 29
    }
    enum StiDataMatrixEncodingType {
        Ascii = 0,
        C40 = 1,
        Text = 2,
        X12 = 3,
        Edifact = 4,
        Binary = 5
    }
    enum StiPdf417EncodingMode {
        Text = 0,
        Numeric = 1,
        Byte = 2
    }
    enum StiPdf417ErrorsCorrectionLevel {
        Automatic = -1,
        Level0 = 0,
        Level1 = 1,
        Level2 = 2,
        Level3 = 3,
        Level4 = 4,
        Level5 = 5,
        Level6 = 6,
        Level7 = 7,
        Level8 = 8
    }
    enum StiEanSupplementType {
        None = 0,
        TwoDigit = 1,
        FiveDigit = 2
    }
    enum StiCode11CheckSum {
        None = 0,
        OneDigit = 1,
        TwoDigits = 2,
        Auto = 3
    }
    enum StiQRCodeSize {
        Automatic = 0,
        v1 = 1,
        v2 = 2,
        v3 = 3,
        v4 = 4,
        v5 = 5,
        v6 = 6,
        v7 = 7,
        v8 = 8,
        v9 = 9,
        v10 = 10,
        v11 = 11,
        v12 = 12,
        v13 = 13,
        v14 = 14,
        v15 = 15,
        v16 = 16,
        v17 = 17,
        v18 = 18,
        v19 = 19,
        v20 = 20,
        v21 = 21,
        v22 = 22,
        v23 = 23,
        v24 = 24,
        v25 = 25,
        v26 = 26,
        v27 = 27,
        v28 = 28,
        v29 = 29,
        v30 = 30,
        v31 = 31,
        v32 = 32,
        v33 = 33,
        v34 = 34,
        v35 = 35,
        v36 = 36,
        v37 = 37,
        v38 = 38,
        v39 = 39,
        v40 = 40
    }
    enum StiQRCodeErrorCorrectionLevel {
        Level1 = 0,
        Level2 = 1,
        Level3 = 2,
        Level4 = 3
    }
    enum StiQRCodeECIMode {
        ISO_8859_1 = 3,
        Windows_1250 = 21,
        Windows_1251 = 22,
        Windows_1252 = 23,
        Windows_1256 = 24,
        UTF_8 = 26
    }
    enum StiMaxicodeMode {
        Mode2 = 2,
        Mode3 = 3,
        Mode4 = 4,
        Mode5 = 5,
        Mode6 = 6
    }
    enum StiAztecSize {
        Automatic = 0,
        Compact1 = -1,
        Compact2 = -2,
        Compact3 = -3,
        Compact4 = -4,
        v1 = 1,
        v2 = 2,
        v3 = 3,
        v4 = 4,
        v5 = 5,
        v6 = 6,
        v7 = 7,
        v8 = 8,
        v9 = 9,
        v10 = 10,
        v11 = 11,
        v12 = 12,
        v13 = 13,
        v14 = 14,
        v15 = 15,
        v16 = 16,
        v17 = 17,
        v18 = 18,
        v19 = 19,
        v20 = 20,
        v21 = 21,
        v22 = 22,
        v23 = 23,
        v24 = 24,
        v25 = 25,
        v26 = 26,
        v27 = 27,
        v28 = 28,
        v29 = 29,
        v30 = 30,
        v31 = 31,
        v32 = 32
    }
    enum StiQRCodeBodyShapeType {
        Square = 0,
        RoundedSquare = 1,
        Dot = 2,
        Circle = 3,
        Diamond = 4,
        Star = 5,
        ZebraHorizontal = 6,
        ZebraVertical = 7,
        ZebraCross1 = 8,
        ZebraCross2 = 9,
        Circular = 10,
        DockedDiamonds = 11
    }
    enum StiQRCodeEyeFrameShapeType {
        Square = 0,
        Dots = 1,
        Circle = 2,
        Round = 3,
        Round1 = 4,
        Round3 = 5
    }
    enum StiQRCodeEyeBallShapeType {
        Square = 0,
        Dots = 1,
        Circle = 2,
        Round = 3,
        Round1 = 4,
        Round3 = 5,
        Star = 6,
        ZebraHorizontal = 7,
        ZebraVertical = 8
    }
}
export namespace Stimulsoft {
    import StiParserType = Stimulsoft.Report.StiParserType;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiColumnsSynchronizationMode = Stimulsoft.Report.Dictionary.StiColumnsSynchronizationMode;
    import StiWordRestrictEditing = Stimulsoft.Report.Export.StiWordRestrictEditing;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import PaperSizeCollection = Stimulsoft.System.Drawing.Printing.PrinterSettings.PaperSizeCollection;
    import StiTextQuality = Stimulsoft.Report.Components.StiTextQuality;
    import StiNamingRule = Stimulsoft.Report.StiNamingRule;
    import StiPropertiesProcessingType = Stimulsoft.Report.Dictionary.StiPropertiesProcessingType;
    import StiFieldsProcessingType = Stimulsoft.Report.Dictionary.StiFieldsProcessingType;
    import StiExcelRestrictEditing = Stimulsoft.Report.Export.StiExcelRestrictEditing;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiArabicDigitsType = Stimulsoft.Report.StiArabicDigitsType;
    import StiPdfAutoPrintMode = Stimulsoft.Report.Export.StiPdfAutoPrintMode;
    import IStiIndicatorRangeInfo = Stimulsoft.Report.Components.Gauge.IStiIndicatorRangeInfo;
    import IStiCustomValueBase = Stimulsoft.Report.Components.Gauge.IStiCustomValueBase;
    import IStiGaugeElement = Stimulsoft.Report.Components.Gauge.IStiGaugeElement;
    import IStiRangeBase = Stimulsoft.Report.Components.Gauge.IStiRangeBase;
    import IStiScaleBase = Stimulsoft.Report.Components.Gauge.IStiScaleBase;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    const StiOptions: {
        Designer: {
            Editors: {
                allowConnectToDataInGallery: boolean;
            };
            CrossTab: {
                styleColors: Color[];
            };
            maxLevelOfDictionaryObjects: number;
            useComponentPlacementOptimization: boolean;
            autoCorrectDataSourceName: boolean;
            autoCorrectDataRelationName: boolean;
            autoCorrectDataColumnName: boolean;
            autoCorrectComponentName: boolean;
            autoCorrectReportName: boolean;
            autoLargeHeight: boolean;
            sortDictionaryByAliases: boolean;
            runWizardAfterLoad: boolean;
            runSpecificWizardAfterLoad: string;
            startScreen: Report.StiDesignerStartScreen;
            eventEvalAccess: Report.StiEventEvalAccess;
            maxDataRowsOfDashboardElementInDesigner: number;
            readonly styles: Stimulsoft.Report.Styles.StiStylesCollection;
        };
        Engine: {
            ReportCache: {
                amountOfQuickAccessPages: number;
                limitForStartUsingCache: number;
                cachePath: string;
                disposeImagesOnPageClear: boolean;
                optimizeEndRenderSetText: boolean;
            };
            Image: {
                absolutePathOfImages: string;
                useImageCloning: boolean;
            };
            Watermark: {
                allowExpression: boolean;
            };
            printIfDetailEmptyDefaultValue: boolean;
            baseReportType: typeof Report.StiReport;
            fullTrust: boolean;
            allowUseResetMethodInBusinessObject: boolean;
            allowResetValuesAtComponent: boolean;
            defaultTextQualityMode: StiTextQuality;
            forceGenerationLocalizedName: boolean;
            useAdvancedPrintOnEngine: boolean;
            forceGenerationNonLocalizedName: boolean;
            forceNewPageForExtraColumns: boolean;
            useRoundForToCurrencyWordsFunctions: boolean;
            forceNewPageInSubReports: boolean;
            useTemplateForPagePrintEvents: boolean;
            namingRule: StiNamingRule;
            useCheckSizeForContinuedContainers: boolean;
            emulateData: boolean;
            allowThrowExceptionWhenColumnDoesNotExists: boolean;
            allowCacheForGetActualSize: boolean;
            allowBreakContainerOptimization: boolean;
            removeBottomBorderOfSplitContainer: boolean;
            checkDockToContainerIfComponentDisabled: boolean;
            usePrintOnAllPagesPropertyOfHeadersInSubreports: boolean;
            useParentStylesOldMode: boolean;
            useCollateOldMode: boolean;
            dpiAware: boolean;
            dockPageFooterToBottom: boolean;
            defaultValueOfAllowApplyStyleProperty: boolean;
            allowFixPieChartMarkerAlignment: boolean;
            applyStylesInAutoSeries: boolean;
            allowInvokeProcessChartEventForTemplateOfChart: boolean;
            allowInteractionInChartWithComponents: boolean;
            dontSaveDataSourceBeforeChartRendering: boolean;
            wordWrapAxisLabelsForPlacementAutoRotation: boolean;
            measureTrailingSpaces: boolean;
            allowClipChartArea: boolean;
            renderExternalSubReportsWithHelpOfUnlimitedHeightPages: boolean;
            escapeQueryParameters: boolean;
            optimizeDetailDataFiltering: boolean;
            CrossTab: {
                defaultWidth: number;
                defaultHeight: number;
                memoryOptimization: boolean;
            };
            printIfDetailEmptyNesting: boolean;
            printIfDetailEmptyForDetails: boolean;
            allowForceCanBreakForCrossTabPrintOnAllPages: boolean;
            Globalization: {
                allowUseText: boolean;
                allowUseTag: boolean;
                allowUseToolTip: boolean;
                allowUseHyperlink: boolean;
                allowUseVariableAlias: boolean;
                allowUseValue: boolean;
                allowUseDisplayValue: boolean;
            };
            ImageCache: {
                enabled: boolean;
            };
            reportResources: {
                maximumSize: number;
            };
            filterDataInDataSourceBeforeSorting: boolean;
            allowConvertingInFormatting: boolean;
            negativeColor: Color;
            barcodeQRCodeDefaultByteModeEncoding: Report.BarCodes.StiQRCodeECIMode;
            barcodeQRCodeAllowUnicodeBOM: boolean;
            retrieveSchemaNamePostgreSql: string;
            hideExceptions: boolean;
            allExceptions: boolean;
            fixPageNumberInEvents: boolean;
            dashboardTextElementExpressionParser: StiParserType;
            useSyncRenderMode: boolean;
            loadDataOnce: boolean;
            useNewHtmlEngine: boolean;
            htmlAllowListItemSecondLineIndent: boolean;
            disconnectFromDataBeforeEndRender: boolean;
        };
        Viewer: {
            Map: {
                showZoomPanel: boolean;
            };
            allowOpenDocumentWithEvent: boolean;
            parametersNotAssignedString: string;
        };
        Print: {
            customPaperSizes: PaperSizeCollection;
            allowUsePaperSizesFromPrinterSettings: boolean;
        };
        Dictionary: {
            Databases: {
                showQuickBooksDatabase: boolean;
            };
            BusinessObjects: {
                allowUseDataColumn: boolean;
                allowUseFields: boolean;
                allowUseProperties: boolean;
                propertiesProcessingType: StiPropertiesProcessingType;
                fieldsProcessingType: StiFieldsProcessingType;
                columnsSynchronizationMode: StiColumnsSynchronizationMode;
            };
            showOnlyAliasForDatabase: boolean;
            showOnlyAliasForData: boolean;
            showOnlyAliasForDataColumn: boolean;
            showOnlyAliasForDataRelation: boolean;
            showOnlyAliasForVariable: boolean;
            hideRelationExceptions: boolean;
            useAdvancedDataSearch: boolean;
            showOnlyAliasForComponents: boolean;
            showOnlyAliasForDataSource: boolean;
            allowRestConnections: boolean;
            allowConnectToFirstTableForEmptyDataSource: boolean;
            useNullableDateTime: boolean;
            useNullableTimeSpan: boolean;
            columnsSynchronizationMode: StiColumnsSynchronizationMode;
            showOnlyAliasForResource: boolean;
        };
        Export: {
            Word: {
                divideSegmentPages: boolean;
                allowImageComparer: boolean;
                removeEmptySpaceAtBottom: boolean;
                spaceBetweenCharacters: number;
                lineHeightExactly: boolean;
                lineHeightExactlyForPHFMode: boolean;
                forceLineHeight: boolean;
                rightMarginCorrection: number;
                bottomMarginCorrection: number;
                renderRichTextAsImage: boolean;
                renderHtmlTagsAsImage: boolean;
                allowCorrectFontSize11Problem: boolean;
                normalStyleDefaultFontSize: number;
                lineSpacing: number;
                divideBigCells: boolean;
                restrictEditing: StiWordRestrictEditing;
                watermarkOnlyBehind: boolean;
                imageFormat: Stimulsoft.Report.ImageFormat;
                compatibilityModeValue: number;
                specifyGrammarAndSpellCheckingAsClean: boolean;
            };
            OpenDocumentWriter: {
                removeEmptySpaceAtBottom: boolean;
                allowImageComparer: boolean;
                divideSegmentPages: boolean;
            };
            OpenDocumentCalc: {
                removeEmptySpaceAtBottom: boolean;
                allowImageComparer: boolean;
                divideSegmentPages: boolean;
                divideBigCells: boolean;
                maximumSheetHeight: number;
            };
            Html: {
                convertDigitsToArabic: boolean;
                arabicDigitsType: StiArabicDigitsType;
                allowImageComparer: boolean;
                forceWysiwygWordwrap: boolean;
                replaceSpecialCharacters: boolean;
                preserveWhiteSpaces: boolean;
                useImageResolution: boolean;
                useWordWrapBreakWordMode: boolean;
                useStrictTableCellSize: boolean;
                useStrictTableCellSizeV2: boolean;
                forceIE6Compatibility: boolean;
                allowStrippedImages: boolean;
                removeEmptySpaceAtBottom: boolean;
                useExtendedStyle: boolean;
                printLayoutOptimization: boolean;
                useComponentStyleName: boolean;
                exportComponentsFromPageMargins: boolean;
                disableJavascriptInHyperlinks: boolean;
                openLinksTarget: string;
                embeddedCustomFontsData: boolean;
            };
            Excel: {
                AllowExportDateTime: boolean;
                ColumnsRightToLeft: boolean;
                ShowGridLines: boolean;
                MaximumSheetHeight: number;
                RemoveEmptySpaceAtBottom: boolean;
                DivideBigCells: boolean;
                imageFormat: Stimulsoft.Report.ImageFormat;
                TrimTrailingSpaces: boolean;
                AllowExportFootersInDataOnlyMode: boolean;
                AllowImageComparer: boolean;
                AllowFreezePanes: boolean;
                RenderHtmlTagsAsImage: boolean;
                RestrictEditing: StiExcelRestrictEditing;
                FitToOnePageWide: boolean;
                ImageMoveAndSizeWithCells: boolean;
                AllowNativeImageBorders: boolean;
            };
            PowerPoint: {
                AllowImageComparer: boolean;
                StoreImagesAsPng: boolean;
                imageFormat: Stimulsoft.Report.ImageFormat;
                ReplaceTransparentPageBackground: boolean;
            };
            Pdf: {
                divideSegmentPages: boolean;
                convertDigitsToArabic: boolean;
                arabicDigitsType: StiArabicDigitsType;
                reduceFontFileSize: boolean;
                useEditableFieldName: boolean;
                useEditableFieldAlias: boolean;
                useEditableFieldTag: boolean;
                allowImageComparer: boolean;
                allowImageTransparency: boolean;
                allowInheritedPageResources: boolean;
                allowExtGState: boolean;
                creatorString: string;
                keywordsString: string;
                defaultCoordinatesPrecision: number;
                defaultAutoPrintMode: StiPdfAutoPrintMode;
                useProperCaseFontNamesFromHtml: boolean;
            };
            Text: {
                useFullTextBoxWidth: boolean;
                useFullVerticalBorder: boolean;
                useFullHorizontalBorder: boolean;
                checkBoxTextForTrue: string;
                checkBoxTextForFalse: string;
                trimTrailingSpaces: boolean;
                removeLastNewLineMarker: boolean;
            };
            Xps: {
                allowImageComparer: boolean;
                allowImageTransparency: boolean;
                reduceFontFileSize: boolean;
            };
            RichText: {
                usePageRefField: boolean;
                convertDigitsToArabic: boolean;
                arabicDigitsType: StiArabicDigitsType;
                divideSegmentPages: boolean;
                useTemplatePageSize: boolean;
                lineHeightExactly: boolean;
                forceLineHeight: boolean;
                removeEmptySpaceAtBottom: boolean;
                lineSpacing: number;
                rightMarginCorrection: number;
                bottomMarginCorrection: number;
                divideBigCells: boolean;
                useCanBreakProperty: boolean;
                spaceBetweenCharacters: number;
                forceEmptyCellsOptimization: boolean;
                useNewPageCommandInsteadOfNewSection: boolean;
            };
            CheckBoxReplacementForExcelValue: {
                Font: Font;
                HorAlignment: StiTextHorAlignment;
                VertAlignment: StiVertAlignment;
            };
            useCacheModeForStiMatrix: boolean;
            optimizeDataOnlyMode: boolean;
            checkBoxTextForTrue: string;
            checkBoxTextForFalse: string;
            useAlternativeFontNames: boolean;
            readonly alternativeFontNames: Hashtable;
        };
        Services: {
            readonly components: Stimulsoft.System.Type[];
            readonly aggregateFunctions: Stimulsoft.Report.Dictionary.StiAggregateFunctionService[];
            databases: Stimulsoft.Report.Dictionary.StiDatabase[];
            dataAdapters: Stimulsoft.Report.Dictionary.StiDataAdapterService[];
            readonly dataSource: Stimulsoft.Report.Dictionary.StiDataSource[];
            readonly formats: Stimulsoft.Report.Components.TextFormats.StiFormatService[];
            readonly styles: Stimulsoft.Report.Styles.StiBaseStyle[];
            readonly chartAreas: Stimulsoft.Report.Chart.IStiArea[];
            readonly chartSeries: Stimulsoft.Report.Chart.IStiSeries[];
            readonly chartLegends: Stimulsoft.Report.Chart.IStiLegend[];
            readonly chartTrendLines: Stimulsoft.Report.Chart.IStiTrendLine[];
            readonly chartSerieLabels: Stimulsoft.Report.Chart.IStiSeriesLabels[];
            readonly chartStyles: Stimulsoft.Report.Chart.IStiChartStyle[];
            readonly shapes: Stimulsoft.Report.Components.StiShapeTypeService[];
            readonly barCodes: Stimulsoft.Report.BarCodes.StiBarCodeTypeService[];
            readonly indicatorRanges: IStiIndicatorRangeInfo[];
            readonly customValues: IStiCustomValueBase[];
            readonly gaugeElements: IStiGaugeElement[];
            readonly ranges: IStiRangeBase[];
            readonly gaugeScales: IStiScaleBase[];
            readonly gaugeStyles: IStiGaugeStyle[];
            readonly mapStyles: Stimulsoft.Report.Maps.StiMapStyleFX[];
            readonly tableStyles: Stimulsoft.Report.Components.Table.StiTableStyleFX[];
            Dashboards: {
                readonly dashboardStyles: Stimulsoft.Report.Dashboard.Styles.StiDashboardStyle[];
                readonly controlStyles: Stimulsoft.Report.Dashboard.Styles.StiControlElementStyle[];
                readonly indicatorStyles: Stimulsoft.Report.Dashboard.Styles.StiIndicatorElementStyle[];
                readonly pivotStyles: Stimulsoft.Report.Dashboard.Styles.StiPivotElementStyle[];
                readonly progressStyles: Stimulsoft.Report.Dashboard.Styles.StiProgressElementStyle[];
                readonly tableStyles: Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle[];
                readonly cardsStyles: Stimulsoft.Report.Dashboard.Styles.StiCardsElementStyle[];
            };
        };
        WebServer: {
            url: string;
            timeout: number;
            encryptData: boolean;
            passQueryParametersToReport: boolean;
            checkDataAdaptersVersion: boolean;
        };
    };
}
declare let StiOptions: typeof Stimulsoft.StiOptions;
export namespace Stimulsoft.Report {
    class StiOptionsFontHelperAttribute {
        index: number;
        constructor(index: number);
    }
}
export namespace Stimulsoft.Report {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    class StiPreviewToolBarOptions {
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        dashboardToolbarHorAlignment: StiHorAlignment;
        dashboardToolbarReverse: boolean;
        reportToolbarHorAlignment: StiHorAlignment;
        reportToolbarReverse: boolean;
    }
}
export namespace Stimulsoft.Report {
    class StiReportCache {
        static createNewCache(): string;
        static deleteCache(path: string): void;
        static getPageCacheName(cache: string, cachePageGuid: string): string;
        static loadPage(path: string): string;
        static savePage(path: string, pageJsonString: string): void;
        private static cachedStrings;
    }
}
export namespace Stimulsoft.Report {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiReportsCollection extends CollectionBase<StiReport> {
        add(report: StiReport, resetPageNumber?: boolean, printOnPreviousPage?: boolean): void;
        private owner;
        constructor(owner: StiReport);
    }
}
export namespace Stimulsoft.Report {
    import PaperKind = Stimulsoft.System.Drawing.Printing.PaperKind;
    import StiPageOrientation = Stimulsoft.Report.Components.StiPageOrientation;
    import StiMargins = Stimulsoft.Report.Components.StiMargins;
    import StiResizeReportOptions = Stimulsoft.Report.StiResizeReportOptions;
    class StiResizeReportHelper {
        private static setPageParameters;
        static resizeReportAsync(report: StiReport, orientation: StiPageOrientation, paperSize: PaperKind, margins: StiMargins, pageWidth: number, pageHeight: number, options: StiResizeReportOptions, indexOfRenderedPage?: number): Promise<void>;
    }
}
export namespace Stimulsoft.Report {
    import StiSimpleText = Stimulsoft.Report.Components.StiSimpleText;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiRuntimeVariables {
        clone(): StiRuntimeVariables;
        page: StiPage;
        textBox: StiSimpleText;
        line: number;
        column: number;
        lineThrough: number;
        dataSourcesPosition: Hashtable;
        private _pageIndex;
        get pageIndex(): number;
        set pageIndex(value: number);
        private _currentPrintPage;
        get currentPrintPage(): number;
        set currentPrintPage(value: number);
        setVariables(report: StiReport): void;
        constructor(report: StiReport);
    }
}
export namespace Stimulsoft.Report {
    class StiStatesManager {
        private static ValueBoolFalse;
        private static ValueBoolTrue;
        private states;
        push(stateName: string, obj: any, property: string, value: any): void;
        pushBool(stateName: string, obj: any, property: string, value: boolean): void;
        pushInt(stateName: string, obj: any, property: string, value: number): void;
        pushInt64(stateName: string, obj: any, property: string, value: number): void;
        pushFloat(stateName: string, obj: any, property: string, value: number): void;
        pushDouble(stateName: string, obj: any, property: string, value: number): void;
        pushDecimal(stateName: string, obj: any, property: string, value: number): void;
        pushRange(stateName: string, obj: any, property: string, value: Range): void;
        pop(stateName: string, obj: any, property: string): any;
        popBool(stateName: string, obj: any, property: string): boolean;
        popInt(stateName: string, obj: any, property: string): number;
        popInt64(stateName: string, obj: any, property: string): number;
        popDouble(stateName: string, obj: any, property: string): number;
        popFloat(stateName: string, obj: any, property: string): number;
        popDecimal(stateName: string, obj: any, property: string): number;
        popRange(stateName: string, obj: any, property: string): Range;
        isExist(stateName: string, obj: any): boolean;
        clearState(stateName: string): void;
        clear(): void;
    }
}
export namespace Stimulsoft.Report {
    class StiSystemVariableLocHelper {
        static getPageNofM(report: StiReport): string;
        static getPageNofMThrough(report: StiReport): string;
        static getPageNofMIdent(report: StiReport): string;
        private static getIdent;
        private static locs;
    }
}
export namespace Stimulsoft.Report {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiText = Stimulsoft.Report.Components.StiText;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiFitTextInfo {
        hashText: Hashtable;
        hashComponent: Hashtable;
        private hashFontString;
        getFontString(font: Font): string;
        getFontSizeObject(textBox: StiText, rect: RectangleD, text: string, REFfontSize: {
            ref: number;
        }, REFhashSt: {
            ref: string;
        }): any;
        clear(): void;
    }
    class StiViewerFitTextHelper {
        private static hashes;
        private static _enabled;
        static get enabled(): boolean;
        static set enabled(value: boolean);
        static addReport(report: StiReport): void;
        static removeReport(report: StiReport): void;
        static clearReportInfo(report: StiReport): void;
        static getReportInfo(report: StiReport): StiFitTextInfo;
        static clear(): void;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IAsIs = Stimulsoft.System.IAsIs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionSortDirection = Stimulsoft.Report.Components.StiInteractionSortDirection;
    import StiDrillDownMode = Stimulsoft.Report.Components.StiDrillDownMode;
    class StiInteraction implements ICloneable, IStiJsonReportObject, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        static loadInteractionFromJsonObject(jObject: StiJson): StiInteraction;
        static loadInteractionFromXml(xmlNode: XmlNode): Stimulsoft.Report.Components.StiInteraction;
        getReport(): any;
        clone(): StiInteraction;
        isDefault(): boolean;
        sortingEnabled: boolean;
        sortingColumn: string;
        sortingIndex: number;
        sortingDirection: StiInteractionSortDirection;
        drillDownEnabled: boolean;
        drillDownReport: string;
        drillDownMode: StiDrillDownMode;
        private _drillDownParameter1;
        get drillDownParameter1(): StiDrillDownParameter;
        set drillDownParameter1(value: StiDrillDownParameter);
        private _drillDownParameter2;
        get drillDownParameter2(): StiDrillDownParameter;
        set drillDownParameter2(value: StiDrillDownParameter);
        private _drillDownParameter3;
        get drillDownParameter3(): StiDrillDownParameter;
        set drillDownParameter3(value: StiDrillDownParameter);
        private _drillDownParameter4;
        get drillDownParameter4(): StiDrillDownParameter;
        set drillDownParameter4(value: StiDrillDownParameter);
        private _drillDownParameter5;
        get drillDownParameter5(): StiDrillDownParameter;
        set drillDownParameter5(value: StiDrillDownParameter);
        private _drillDownParameter6;
        get drillDownParameter6(): StiDrillDownParameter;
        set drillDownParameter6(value: StiDrillDownParameter);
        private _drillDownParameter7;
        get drillDownParameter7(): StiDrillDownParameter;
        set drillDownParameter7(value: StiDrillDownParameter);
        private _drillDownParameter8;
        get drillDownParameter8(): StiDrillDownParameter;
        set drillDownParameter8(value: StiDrillDownParameter);
        private _drillDownParameter9;
        get drillDownParameter9(): StiDrillDownParameter;
        set drillDownParameter9(value: StiDrillDownParameter);
        private _drillDownParameter10;
        get drillDownParameter10(): StiDrillDownParameter;
        set drillDownParameter10(value: StiDrillDownParameter);
        get drillDownPage(): StiPage;
        set drillDownPage(value: StiPage);
        drillDownPageGuid: string;
        get bookmark(): string;
        set bookmark(value: string);
        get hyperlink(): string;
        set hyperlink(value: string);
        get tag(): string;
        set tag(value: string);
        get toolTip(): string;
        set toolTip(value: string);
        getSortDataBandName(): string;
        getSortColumns(): string[];
        getSortColumnsString(): string;
        parentComponent: StiComponent;
        constructor();
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiBandInteraction extends StiInteraction implements IStiJsonReportObject {
        meta(): StiMeta[];
        isDefault(): boolean;
        collapsingEnabled: boolean;
        selectionEnabled: boolean;
        collapseGroupFooter: boolean;
        get collapsed(): string;
        set collapsed(value: string);
        selectedLine: number;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiGroupFooterBand extends StiDynamicBand implements IStiKeepGroupFooterTogether, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        clone(cloneProperties: boolean, cloneComponents: boolean): StiGroupFooterBand;
        keepGroupFooterTogether: boolean;
        private _groupFooterBandInfo;
        get groupFooterBandInfo(): StiGroupFooterBandInfo;
        get line(): number;
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        protected getComponentType(): StiComponentType;
        get priority(): number;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiPageBreak: System.Interface<IStiPageBreak>;
    interface IStiPageBreak {
        newColumnBefore: boolean;
        newColumnAfter: boolean;
        newPageBefore: boolean;
        newPageAfter: boolean;
        breakIfLessThan: number;
        skipFirst: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    import IAsIs = Stimulsoft.System.IAsIs;
    let IStiMasterComponent: System.Interface<IStiMasterComponent>;
    interface IStiMasterComponent extends IAsIs {
        masterComponent: StiComponent;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiPrintOnAllPages: System.Interface<IStiPrintOnAllPages>;
    interface IStiPrintOnAllPages {
        printOnAllPages: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHeaderBand extends StiDynamicBand implements IStiPrintIfEmpty, IStiPrintOnAllPages, IStiPrintOnEvenOddPages, IStiKeepHeaderTogether, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        clone(cloneProperties: boolean, cloneComponents: boolean): StiHeaderBand;
        keepHeaderTogether: boolean;
        private _startNewPage;
        get startNewPage(): boolean;
        set startNewPage(value: boolean);
        get startNewPageIfLessThan(): number;
        set startNewPageIfLessThan(value: number);
        private _printIfEmpty;
        get printIfEmpty(): boolean;
        set printIfEmpty(value: boolean);
        private _printOnAllPages;
        get printOnAllPages(): boolean;
        set printOnAllPages(value: boolean);
        private _printOnEvenOddPages;
        get printOnEvenOddPages(): StiPrintOnEvenOddPagesType;
        set printOnEvenOddPages(value: StiPrintOnEvenOddPagesType);
        private _headerBandInfo;
        get headerBandInfo(): StiHeaderBandInfo;
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get priority(): number;
        protected getComponentType(): StiComponentType;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import EventArgs = Stimulsoft.System.EventArgs;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiFooterBand extends StiDynamicBand implements IStiPrintOnAllPages, IStiPrintIfEmpty, IStiKeepFooterTogether, IStiPrintOnEvenOddPages, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        keepFooterTogether: boolean;
        clone(cloneProperties: boolean, cloneComponents: boolean): StiFooterBand;
        private _startNewPage;
        get startNewPage(): boolean;
        set startNewPage(value: boolean);
        get startNewPageIfLessThan(): number;
        set startNewPageIfLessThan(value: number);
        printIfEmpty: boolean;
        printOnEvenOddPages: StiPrintOnEvenOddPagesType;
        private _printOnAllPages;
        get printOnAllPages(): boolean;
        set printOnAllPages(value: boolean);
        private _footerBandInfo;
        get footerBandInfo(): StiFooterBandInfo;
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get priority(): number;
        protected getComponentType(): StiComponentType;
        private static eventMoveFooterToBottom;
        protected onMoveFooterToBottom(e: EventArgs): void;
        invokeMoveFooterToBottom(): void;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiGroupHeaderBand = Stimulsoft.Report.Components.StiGroupHeaderBand;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiFooterBand = Stimulsoft.Report.Components.StiFooterBand;
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiDataBandBuilder extends StiBandBuilder {
        getGroupHeaders(masterDataBand: StiDataBand): StiComponentsCollection;
        getGroupFooters(masterDataBand: StiDataBand): StiComponentsCollection;
        groupsComparison(masterDataBand: StiDataBand): void;
        findHeaders(masterDataBand: StiDataBand): void;
        findHierarchicalHeaders(masterDataBand: StiDataBand): void;
        findFooters(masterDataBand: StiDataBand): void;
        findHierarchicalFooters(masterDataBand: StiDataBand): void;
        findEmptyBands(masterDataBand: StiDataBand): void;
        findGroupHeaders(masterDataBand: StiDataBand): void;
        findGroupFooters(masterDataBand: StiDataBand): void;
        findDetailDataBands(masterDataBand: StiDataBand): void;
        private isParentOrCurrentBO;
        findSubReports(masterDataBand: StiDataBand): void;
        findDetails(masterDataBand: StiDataBand): void;
        resetHeaders(masterDataBand: StiDataBand): void;
        resetHierarchicalHeaders(masterDataBand: StiDataBand): void;
        resetFooters(masterDataBand: StiDataBand): void;
        resetHierarchicalFooters(masterDataBand: StiDataBand): void;
        resetEmptyBands(masterDataBand: StiDataBand): void;
        resetGroupHeaders(masterDataBand: StiDataBand): void;
        resetGroupFooters(masterDataBand: StiDataBand): void;
        resetDetailDataBands(masterDataBand: StiDataBand): void;
        resetDetails(masterDataBand: StiDataBand): void;
        addKeepLevelAtLatestDataBandAsync(masterDataBand: StiDataBand): Promise<void>;
        addKeepLevelAtLatestDataBand(masterDataBand: StiDataBand): void;
        addKeepLevelAsync(masterDataBand: StiDataBand): Promise<void>;
        addKeepLevel(masterDataBand: StiDataBand): void;
        removeKeepLevelAsync(masterDataBand: StiDataBand): Promise<void>;
        removeKeepLevel(masterDataBand: StiDataBand): void;
        removeKeepGroupHeadersAsync(masterDataBand: StiDataBand): Promise<void>;
        removeKeepGroupHeaders(masterDataBand: StiDataBand): void;
        removeKeepHeadersAsync(masterDataBand: StiDataBand, keepHeaders: boolean[]): Promise<void>;
        removeKeepHeaders(masterDataBand: StiDataBand, keepHeaders: boolean[]): void;
        allowKeepDetails(masterDataBand: StiDataBand): boolean;
        addKeepDetailsAsync(masterDataBand: StiDataBand): Promise<void>;
        addKeepDetails(masterDataBand: StiDataBand): void;
        removeKeepDetailsAsync(masterDataBand: StiDataBand): Promise<void>;
        removeKeepDetails(masterDataBand: StiDataBand): void;
        removeKeepDetailsRowAsync(masterDataBand: StiDataBand): Promise<void>;
        removeKeepDetailsRow(masterDataBand: StiDataBand): void;
        startBands(masterDataBand: StiDataBand, bands: StiComponentsCollection): void;
        startBand(masterDataBand: StiDataBand, band: StiBand): void;
        endBands(masterDataBand: StiDataBand): void;
        getGroupHeaderResult(masterDataBand: StiDataBand, groupHeaderBand: StiGroupHeaderBand): boolean;
        getGroupFooterResult(masterDataBand: StiDataBand, groupHeaderBand: StiGroupHeaderBand): boolean;
        linkGroupHeadersAndGroupFooters(masterDataBand: StiDataBand): void;
        resetLinkGroupHeadersAndGroupFooters(masterDataBand: StiDataBand): void;
        static prepareGroupResults(masterDataBand: StiDataBand): void;
        renderGroupHeadersAsync(masterDataBand: StiDataBand): Promise<void>;
        renderGroupHeaders(masterDataBand: StiDataBand): void;
        renderGroupFootersAsync(masterDataBand: StiDataBand): Promise<void>;
        renderGroupFooters(masterDataBand: StiDataBand): void;
        static setDetailsAsync(masterDataBand: StiDataBand): Promise<void>;
        static setDetails(masterDataBand: StiDataBand): void;
        renderDetailDataBandsAsync(masterDataBand: StiDataBand): Promise<void>;
        renderDetailDataBands(masterDataBand: StiDataBand): void;
        private getParentDataBand;
        private isAllow;
        allowDetailDataBands(masterDataBand: StiDataBand): boolean;
        isDenyDetailsOnFirstPage(masterDataBand: StiDataBand): boolean;
        static isDetailDataSourcesEmpty(masterDataBand: StiDataBand): boolean;
        static isPrintIfDetailEmpty(masterDataBand: StiDataBand): boolean;
        renderHeadersAsync(masterDataBand: StiDataBand, keepHeaders: boolean[]): Promise<void>;
        renderHeaders(masterDataBand: StiDataBand, keepHeaders: boolean[]): void;
        renderHierarchicalHeadersAsync(masterDataBand: StiDataBand, allowIndent: boolean, level: number): Promise<void>;
        renderHierarchicalHeaders(masterDataBand: StiDataBand, allowIndent: boolean, level: number): void;
        addFooterMarkerAsync(masterDataBand: StiDataBand, footerMaster: StiFooterBand): Promise<void>;
        addFooterMarker(masterDataBand: StiDataBand, footerMaster: StiFooterBand): void;
        renderMarkerFootersOnAllPagesAsync(masterDataBand: StiDataBand): Promise<void>;
        renderMarkerFootersOnAllPages(masterDataBand: StiDataBand): void;
        renderFootersOnLastPageAsync(masterDataBand: StiDataBand): Promise<void>;
        renderFootersOnLastPage(masterDataBand: StiDataBand): void;
        renderFootersOnAllPagesAsync(masterDataBand: StiDataBand): Promise<void>;
        renderFootersOnAllPages(masterDataBand: StiDataBand): void;
        renderHierarchicalFootersAsync(masterDataBand: StiDataBand, allowIndent: boolean, level: number): Promise<void>;
        renderHierarchicalFooters(masterDataBand: StiDataBand, allowIndent: boolean, level: number): void;
        renderReportTitlesAsync(masterDataBand: StiDataBand): Promise<void>;
        renderReportTitles(masterDataBand: StiDataBand): void;
        renderReportSummariesAsync(masterDataBand: StiDataBand): Promise<void>;
        renderReportSummaries(masterDataBand: StiDataBand): void;
        checkKeepReportSummaryTogether(masterDataBand: StiDataBand): boolean;
        checkKeepFooterTogether(masterDataBand: StiDataBand): boolean;
        block(masterDataBand: StiDataBand): void;
        unBlock(masterDataBand: StiDataBand): void;
        checkHierarchicalHeadersAsync(masterDataBand: StiDataBand): Promise<void>;
        checkHierarchicalHeaders(masterDataBand: StiDataBand): void;
        checkHierarchicalFootersAsync(masterDataBand: StiDataBand): Promise<void>;
        checkHierarchicalFooters(masterDataBand: StiDataBand): void;
        renderBandAsync(masterDataBand: StiDataBand, band: StiBand, ignorePageBreaks?: boolean, allowRenderingEvents?: boolean): Promise<void>;
        renderBand(masterDataBand: StiDataBand, band: StiBand, ignorePageBreaks?: boolean, allowRenderingEvents?: boolean): void;
        renderColumnsAsync(masterDataBand: StiDataBand): Promise<void>;
        renderColumns(masterDataBand: StiDataBand): void;
        registerEmptyBands(masterDataBand: StiDataBand): void;
        static isCollapsed(masterDataBand: StiContainer, isRendering: boolean): boolean;
        setReportVariables(masterComp: StiComponent): void;
        prepare(masterComp: StiComponent): void;
        unPrepare(masterComp: StiComponent): void;
        private static invokeCollapsedEvent;
        renderAsync(masterComp: StiComponent): Promise<StiComponent>;
        render(masterComp: StiComponent): StiComponent;
        renderMasterAsync(masterDataBand: StiDataBand): Promise<void>;
        renderMaster(masterDataBand: StiDataBand): void;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiAggregateFunctionService {
        get serviceName(): string;
        init(): void;
        reset(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        isFirstInit: boolean;
        get recureParam(): boolean;
        runningTotal: boolean;
        constructor(runningTotal?: boolean);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiSumFunctionService extends StiAggregateFunctionService {
        private summary;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiSumTimeFunctionService extends StiAggregateFunctionService {
        private sumValue;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiAvgFunctionService extends StiAggregateFunctionService {
        private summary;
        private count;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiAvgDateFunctionService extends StiAggregateFunctionService {
        private avgValue;
        private count;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiAvgTimeFunctionService extends StiAggregateFunctionService {
        private avgValue;
        private count;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiMaxFunctionService extends StiAggregateFunctionService {
        private maximum;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiMinFunctionService extends StiAggregateFunctionService {
        private minimum;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiMedianFunctionService extends StiAggregateFunctionService {
        private values;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiModeFunctionService extends StiAggregateFunctionService {
        private values;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiFirstFunctionService extends StiAggregateFunctionService {
        private value;
        private first;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiLastFunctionService extends StiAggregateFunctionService {
        private value;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiCountFunctionService extends StiAggregateFunctionService {
        private counter;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiCountDistinctFunctionService extends StiAggregateFunctionService {
        private counter;
        private values;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiMinDateFunctionService extends StiAggregateFunctionService {
        private valueProcessed;
        private minimum;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiMinTimeFunctionService extends StiAggregateFunctionService {
        private valueProcessed;
        private minimum;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiMinStrFunctionService extends StiAggregateFunctionService {
        private values;
        static ascComparison(str1: string, str2: string): number;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiMaxDateFunctionService extends StiAggregateFunctionService {
        private valueProcessed;
        private maximum;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiMaxTimeFunctionService extends StiAggregateFunctionService {
        private valueProcessed;
        private maximum;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiMaxStrFunctionService extends StiAggregateFunctionService {
        private values;
        static ascComparison(str1: string, str2: string): number;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiSumDistinctFunctionService extends StiAggregateFunctionService {
        private summary;
        private values;
        get serviceName(): string;
        init(): void;
        calcItem(value: any, valueToSum?: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiSumNullableFunctionService extends StiAggregateFunctionService {
        private summary;
        private hasValues;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiRankOrder = Stimulsoft.Report.StiRankOrder;
    class StiRankFunctionService extends StiAggregateFunctionService {
        private hash;
        private sortOrder;
        private dense;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
        constructor(runningTotal: boolean, dense?: boolean, sortOrder?: StiRankOrder);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiStDevFunctionService extends StiAggregateFunctionService {
        get serviceName(): string;
        private values;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        getResultType(): Type;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiStDevPFunctionService extends StiAggregateFunctionService {
        get serviceName(): string;
        private values;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        getResultType(): Type;
        get recureParam(): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiSqlSource extends StiDataTableSource implements IStiJsonReportObject {
        meta(): StiMeta[];
        clone(): StiSqlSource;
        allowExpressions: boolean;
        type: StiSqlSourceType;
        commandTimeout: number;
        reconnectOnEachRow: boolean;
        private _sqlCommand;
        get sqlCommand(): string;
        set sqlCommand(v: string);
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        updateParametersAsync(): Promise<void>;
        updateParameters(): void;
        retrieveDataAsync(schemaOnly?: boolean): StiPromise<void>;
        getSqlFilterQuery(): string;
        getFinalSqlCommand(): string;
        getSqlCommandWithFilterQuery(): string;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report {
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import DateTime = Stimulsoft.System.DateTime;
    class Totals {
        static getMethod(report: StiReport, name: string): any;
        private static calculate;
        private static calculate1;
        private static calcItem;
        private static calculateByCondition;
        private static compareValue;
        private static calculateNullable;
        private static calculateRunning;
        static sum(data: any, report: StiReport, name: string): number;
        static sumNullable(data: any, report: StiReport, name: string): number;
        static sumDistinct(data: any, report: StiReport, name: string, name2?: string): number;
        static cSum(data: any, report: StiReport, name: string): number;
        static cSumRunning(data: any, report: StiReport, name: string): number;
        static sumAllLevels(data: any, report: StiReport, name: string): number;
        static sumAllLevelsByCondition(data: any, report: StiReport, name: string, filterCondition: StiFilterCondition, value1: number, value2: number): number;
        static sumAllLevelsOnlyChilds(data: any, report: StiReport, name: string): number;
        static sumOnlyChilds(data: any, report: StiReport, name: string): number;
        static sumTime(data: any, report: StiReport, name: string): TimeSpan;
        static cSumTime(data: any, report: StiReport, name: string): TimeSpan;
        static sumTimeAllLevels(data: any, report: StiReport, name: string): TimeSpan;
        static sumTimeAllLevelsOnlyChilds(data: any, report: StiReport, name: string): TimeSpan;
        static sumTimeOnlyChilds(data: any, report: StiReport, name: string): TimeSpan;
        static avg(data: any, report: StiReport, name: string): number;
        static cAvg(data: any, report: StiReport, name: string): number;
        static cAvgRunning(data: any, report: StiReport, name: string): number;
        static avgAllLevels(data: any, report: StiReport, name: string): number;
        static avgAllLevelsOnlyChilds(data: any, report: StiReport, name: string): number;
        static avgOnlyChilds(data: any, report: StiReport, name: string): number;
        static avgDate(data: any, report: StiReport, name: string): DateTime;
        static cAvgDate(data: any, report: StiReport, name: string): DateTime;
        static avgDateAllLevels(data: any, report: StiReport, name: string): DateTime;
        static avgDateAllLevelsOnlyChilds(data: any, report: StiReport, name: string): DateTime;
        static avgDateOnlyChilds(data: any, report: StiReport, name: string): DateTime;
        static avgTime(data: any, report: StiReport, name: string): TimeSpan;
        static cAvgTime(data: any, report: StiReport, name: string): TimeSpan;
        static avgTimeAllLevels(data: any, report: StiReport, name: string): TimeSpan;
        static avgTimeAllLevelsOnlyChilds(data: any, report: StiReport, name: string): TimeSpan;
        static avgTimeOnlyChilds(data: any, report: StiReport, name: string): TimeSpan;
        static max(data: any, report: StiReport, name: string): number;
        static cMax(data: any, report: StiReport, name: string): number;
        static cMaxRunning(data: any, report: StiReport, name: string): number;
        static maxAllLevels(data: any, report: StiReport, name: string): number;
        static maxAllLevelsOnlyChilds(data: any, report: StiReport, name: string): number;
        static maxOnlyChilds(data: any, report: StiReport, name: string): number;
        static min(data: any, report: StiReport, name: string): number;
        static cMin(data: any, report: StiReport, name: string): number;
        static cMinRunning(data: any, report: StiReport, name: string): number;
        static minAllLevels(data: any, report: StiReport, name: string): number;
        static minAllLevelsOnlyChilds(data: any, report: StiReport, name: string): number;
        static minOnlyChilds(data: any, report: StiReport, name: string): number;
        static median(data: any, report: StiReport, name: string): number;
        static cMedian(data: any, report: StiReport, name: string): number;
        static cMedianRunning(data: any, report: StiReport, name: string): number;
        static medianAllLevels(data: any, report: StiReport, name: string): number;
        static medianAllLevelsOnlyChilds(data: any, report: StiReport, name: string): number;
        static medianOnlyChilds(data: any, report: StiReport, name: string): number;
        static mode(data: any, report: StiReport, name: string): number;
        static cMode(data: any, report: StiReport, name: string): number;
        static cModeRunning(data: any, report: StiReport, name: string): number;
        static modeAllLevels(data: any, report: StiReport, name: string): number;
        static modeAllLevelsOnlyChilds(data: any, report: StiReport, name: string): number;
        static modeOnlyChilds(data: any, report: StiReport, name: string): number;
        static first(data: any, report: StiReport, name: string): any;
        static cFirst(data: any, report: StiReport, name: string): any;
        static cFirstRunning(data: any, report: StiReport, name: string): any;
        static firstAllLevels(data: any, report: StiReport, name: string): any;
        static firstAllLevelsOnlyChilds(data: any, report: StiReport, name: string): any;
        static firstOnlyChilds(data: any, report: StiReport, name: string): any;
        static last(data: any, report: StiReport, name: string): any;
        static cLast(data: any, report: StiReport, name: string): any;
        static cLastRunning(data: any, report: StiReport, name: string): any;
        static lastAllLevels(data: any, report: StiReport, name: string): any;
        static lastAllLevelsOnlyChilds(data: any, report: StiReport, name: string): any;
        static lastOnlyChilds(data: any, report: StiReport, name: string): any;
        static count(data: any, report?: StiReport, name?: string): number;
        static cCount(data: any, report?: StiReport, name?: string): number;
        static cCountRunning(data: any, report?: StiReport, name?: string): number;
        static countAllLevels(data: any): number;
        static countAllLevelsOnlyChilds(data: any): number;
        static countOnlyChilds(data: any): number;
        static countDistinct(data: any, report: StiReport, name: string): number;
        static cCountDistinct(data: any, report: StiReport, name: string): number;
        static cCountDistinctRunning(data: any, report: StiReport, name: string): number;
        static countDistinctAllLevels(data: any, report: StiReport, name: string): number;
        static countDistinctAllLevelsOnlyChilds(data: any, report: StiReport, name: string): number;
        static countDistinctOnlyChilds(data: any, report: StiReport, name: string): number;
        static minDate(data: any, report: StiReport, name: string): DateTime;
        static cMinDate(data: any, report: StiReport, name: string): DateTime;
        static minDateAllLevels(data: any, report: StiReport, name: string): DateTime;
        static minDateAllLevelsOnlyChilds(data: any, report: StiReport, name: string): DateTime;
        static minDateOnlyChilds(data: any, report: StiReport, name: string): DateTime;
        static minTime(data: any, report: StiReport, name: string): TimeSpan;
        static cMinTime(data: any, report: StiReport, name: string): TimeSpan;
        static minTimeAllLevels(data: any, report: StiReport, name: string): TimeSpan;
        static minTimeAllLevelsOnlyChilds(data: any, report: StiReport, name: string): TimeSpan;
        static minTimeOnlyChilds(data: any, report: StiReport, name: string): TimeSpan;
        static minStr(data: any, report: StiReport, name: string): string;
        static cMinStr(data: any, report: StiReport, name: string): string;
        static minStrAllLevels(data: any, report: StiReport, name: string): string;
        static minStrAllLevelsOnlyChilds(data: any, report: StiReport, name: string): string;
        static minStrOnlyChilds(data: any, report: StiReport, name: string): string;
        static maxDate(data: any, report: StiReport, name: string): DateTime;
        static cMaxDate(data: any, report: StiReport, name: string): DateTime;
        static maxDateAllLevels(data: any, report: StiReport, name: string): DateTime;
        static maxDateAllLevelsOnlyChilds(data: any, report: StiReport, name: string): DateTime;
        static maxDateOnlyChilds(data: any, report: StiReport, name: string): DateTime;
        static maxTime(data: any, report: StiReport, name: string): TimeSpan;
        static cMaxTime(data: any, report: StiReport, name: string): TimeSpan;
        static maxTimeAllLevels(data: any, report: StiReport, name: string): TimeSpan;
        static maxTimeAllLevelsOnlyChilds(data: any, report: StiReport, name: string): TimeSpan;
        static maxTimeOnlyChilds(data: any, report: StiReport, name: string): TimeSpan;
        static maxStr(data: any, report: StiReport, name: string): string;
        static cMaxStr(data: any, report: StiReport, name: string): string;
        static maxStrAllLevels(data: any, report: StiReport, name: string): string;
        static maxStrAllLevelsOnlyChilds(data: any, report: StiReport, name: string): string;
        static maxStrOnlyChilds(data: any, report: StiReport, name: string): string;
        static stDev(data: any, report: StiReport, name: string): number;
        static cStDev(data: any, report: StiReport, name: string): number;
        static cStDevRunning(data: any, report: StiReport, name: string): number;
        static stDevP(data: any, report: StiReport, name: string): number;
        static cStDevP(data: any, report: StiReport, name: string): number;
        static cStDevPRunning(data: any, report: StiReport, name: string): number;
        static rank(data: any, report: StiReport, name: string, dense?: boolean, sortOrder?: StiRankOrder): number;
        private static saveState;
        private static restoreState;
        private static storeCachedValue;
        private static getCachedValue;
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import IStiBackColor = Stimulsoft.Report.Components.IStiBackColor;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    let IStiBarCode: System.Interface<IStiBarCode>;
    interface IStiBarCode extends IStiBackColor, IStiForeColor {
        getBarCodeString(): string;
        autoScale: boolean;
        showLabelText: boolean;
        barCodeType: StiBarCodeTypeService;
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import List = Stimulsoft.System.Collections.List;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiService = Stimulsoft.Base.Services.StiService;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import Image = Stimulsoft.System.Drawing.Image;
    import IStiBarCodePainter = Stimulsoft.Report.Painters.IStiBarCodePainter;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    interface DrawBaseLinesDelegate {
        (cobtext: any, brush: StiBrush, barCode: StiBarCodeTypeService): any;
    }
    enum BarcodeCommandCode {
        Fnc1 = 65457,
        Fnc2 = 65458,
        Fnc3 = 65459,
        Fnc4 = 65460
    }
    class StiBarCodeTypeService extends StiService {
        getNetTypeName(): string;
        static loadFromJsonObjectInternal(jObject: StiJson): StiBarCodeTypeService;
        static loadFromXmlInternal(xmlNode: XmlNode): StiBarCodeTypeService;
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        visiblePropertiesCount: number;
        private _visibleProperties;
        get visibleProperties(): boolean[];
        set visibleProperties(value: boolean[]);
        get defaultCodeValue(): string;
        customPainter: IStiBarCodePainter;
        private _mainWidth;
        get mainWidth(): number;
        private _mainHeight;
        get mainHeight(): number;
        barCodeData: StiBarCodeData;
        get module(): number;
        set module(value: number);
        get height(): number;
        set height(value: number);
        protected get textAlignment(): StringAlignment;
        protected textSpacing: boolean;
        protected preserveAspectRatio: boolean;
        protected rectWindow: RectangleD;
        get labelFontHeight(): number;
        protected defaultLabelFontHeight: number;
        protected checkCodeSymbols(inputCode: string, tolerantSymbols: string): string;
        getCode(barCode: IStiBarCode): string;
        getCombinedCode(): string;
        static unpackTilde(input: number[], processTilde: boolean): number[];
        static unpackTildeString(input: string, processTilde: boolean): string;
        protected getSymbolWidth(symbol: string): number;
        protected isSymbolLong(symbol: string): boolean;
        protected isSymbolSpace(symbol: string): boolean;
        protected isSymbolPostDescend(symbol: string): boolean;
        protected getSymbolsStringWidth(symbolsString: string): number;
        protected drawBars(context: any, sym: string, foreBrush: StiBrush): void;
        protected drawBarCode(context: any, rect: RectangleD, barCode: StiBarCode): void;
        protected drawBarCode1(context: any, rect: RectangleD, barCode: StiBarCode, drawMethod: DrawBaseLinesDelegate): void;
        protected calculateSizeFull(spaceLeft: number, spaceRight: number, spaceTop: number, spaceBottom: number, lineHeightShort: number, lineHeightLong: number, TextPosition: number, TextHeight: number, mainHeight: number, lineHeightForCut: number, wideToNarrowRatio: number, zoom: number, code: string, textString: string, barsArray: string, rect: RectangleD, barCode: StiBarCode): void;
        protected calculateSize2(spaceLeft: number, spaceRight: number, spaceTop: number, spaceBottom: number, lineHeightShort: number, lineHeightLong: number, textPosition: number, textHeight: number, mainHeight: number, wideToNarrowRatio: number, zoom: number, barsArray: string, rect: RectangleD, barCode: StiBarCode): void;
        protected draw2DBarCode(context: any, rect: RectangleD, barCode: StiBarCode, zoom: number): void;
        protected drawMaxicode(context: any, rect: RectangleD, barCode: StiBarCode, zoom: number): void;
        protected drawBarCodeError(context: any, rect: RectangleD, barCode: StiBarCode): void;
        protected drawBarCodeError2(context: any, rect: RectangleD, barCode: StiBarCode, message: string, drawMessage?: boolean): void;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        protected translateRect(context: any, rect: RectangleD, barCode: StiBarCode): void;
        protected rollbackTransform(context: any): void;
        protected baseDrawString(context: any, st: string, font: Font, brush: StiBrush, x: number, y: number): void;
        protected baseTransform(context: any, x: number, y: number, angle: number, dx: number, dy: number): void;
        protected baseRollbackTransform(context: any): void;
        baseFillRectangle(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        protected baseFillRectangle2D(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        protected baseFillPolygon(context: any, brush: StiBrush, points: PointD[]): void;
        protected baseFillPolygons(context: any, brush: StiBrush, points: List<List<PointD>>): void;
        protected baseFillEllipse(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        protected baseDrawRectangle(context: any, penColor: Color, penSize: number, x: number, y: number, width: number, height: number): void;
        protected baseDrawImage(context: any, image: Image, report: StiReport, x: number, y: number, width: number, height: number): void;
        protected baseDrawString2(context: any, st: string, font: Font, brush: StiBrush, rect: RectangleD, sf: StringFormat): void;
        protected baseMeasureString3(context: any, st: string, font: Font): SizeD;
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAustraliaPost4StateBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        protected australiaPost4StateSymbolsC: string;
        protected australiaPost4StateSymbolsN: string;
        private australiaPost4StateStartCode;
        private australiaPost4StateStopCode;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        get labelFontHeight(): number;
        protected preserveAspectRatio: boolean;
        get visibleProperties(): boolean[];
        protected australiaPost4StateSpaceLeft: number;
        protected australiaPost4StateSpaceRight: number;
        protected australiaPost4StateSpaceTop: number;
        protected australiaPost4StateSpaceBottom: number;
        protected australiaPost4StateLineHeightLong: number;
        protected australiaPost4StateLineHeightShort: number;
        protected australiaPost4StateTextPosition: number;
        protected australiaPost4StateTextHeight: number;
        protected australiaPost4StateMainHeight: number;
        protected australiaPost4StateLineHeightForCut: number;
        protected get textAlignment(): StringAlignment;
        private mult;
        private gen;
        private rSInitialise;
        private rSEncode;
        private charTo4State;
        private stateToBar;
        private makeBarsArray;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAztecSize = Stimulsoft.Report.BarCodes.StiAztecSize;
    class BitArray {
        private bits;
        size: number;
        get aizeInBytes(): number;
        get(i: number): boolean;
        set(i: number, value: boolean): void;
        constructor();
        private ensureCapacity;
        appendBit(bit: boolean): void;
        appendBits(value: number, numBits: number): void;
        appendBitArray(other: BitArray): void;
        private makeArray;
    }
    export class HighLevelEncoder {
        static MODE_UPPER: number;
        static MODE_LOWER: number;
        static MODE_DIGIT: number;
        static MODE_MIXED: number;
        static MODE_PUNCT: number;
        static readonly LATCH_TABLE: number[][];
        static readonly CHAR_MAP: number[][];
        static readonly SHIFT_TABLE: number[][];
        private readonly text;
        private readonly eci;
        static staticConstructor(): void;
        constructor(text: number[], eci: number);
        encode(): BitArray;
        private updateStateListForChar;
        private updateStateForChar;
        private static updateStateListForPair;
        private static updateStateForPair;
        private static simplifyStates;
    }
    export class StiAztecBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _errorCorrectionLevel;
        get errorCorrectionLevel(): number;
        set errorCorrectionLevel(value: number);
        matrixSize: StiAztecSize;
        private _codePage;
        get codePage(): number;
        set codePage(value: number);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, errorCorrectionLevel?: number, matrixSize?: StiAztecSize, codePage?: number);
    }
    export {};
}
export namespace Stimulsoft.Report.BarCodes {
    class StiBarCodeData {
        spaceLeft: number;
        spaceRight: number;
        spaceTop: number;
        spaceBottom: number;
        lineHeightShort: number;
        lineHeightLong: number;
        lineWidth: number;
        textPosition: number;
        textHeight: number;
        mainHeight: number;
        mainWidth: number;
        wideToNarrowRatio: number;
        code: string;
        textString: string;
        barsArray: string;
        fullZoomY: number;
        spaceBeforeAdd: number;
        spaceTextTop: number;
        textPositionTop: number;
        textPositionBottom: number;
        eanBarsArray: EanBarInfo[];
        offsetY: number;
        matrixGrid: number[];
        matrixWidth: number;
        matrixHeight: number;
        matrixRatioY: number;
    }
}
export namespace Stimulsoft.Report.BarCodes.StiBarcodeUtils {
    export class GaloisFieldPolynomial {
        private field;
        private coefficients;
        constructor(field: GaloisField, coefficients: number[]);
        get getCoefficients(): number[];
        get getDegree(): number;
        get isZero(): boolean;
        getCoefficient(degree: number): number;
        addOrSubtract(other: GaloisFieldPolynomial): GaloisFieldPolynomial;
        multiply(other: GaloisFieldPolynomial): GaloisFieldPolynomial;
        multiplyByMonomial(degree: number, coefficient: number): GaloisFieldPolynomial;
        divide(other: GaloisFieldPolynomial): GaloisFieldPolynomial[];
    }
    export class GaloisField {
        static Aztec_Data_12: GaloisField;
        static Aztec_Data_10: GaloisField;
        static Aztec_Data_8: GaloisField;
        static Aztec_Data_6: GaloisField;
        static Aztec_Param: GaloisField;
        static QRCode_256: GaloisField;
        static Maxicode_64: GaloisField;
        static DataMatrix_256: GaloisField;
        private expTable;
        private logTable;
        private zero;
        private one;
        private size;
        private generatorBase;
        constructor(primitive: number, size: number, genBase: number);
        get getZero(): GaloisFieldPolynomial;
        get getOne(): GaloisFieldPolynomial;
        get getGeneratorBase(): number;
        buildMonomial(degree: number, coefficient: number): GaloisFieldPolynomial;
        static addOrSubtract(a: number, b: number): number;
        exp(a: number): number;
        inverse(a: number): number;
        multiply(a: number, b: number): number;
    }
    export class ReedSolomonEncoder {
        private field;
        private cachedGenerators;
        constructor(field: GaloisField);
        private buildGenerator;
        encode(toEncode: number[], ecBytes: number): void;
    }
    export class BitMatrix {
        width: number;
        height: number;
        private rowSize;
        private bits;
        constructor(width: number, height?: number);
        get(x: number, y: number): boolean;
        set(x: number, y: number, value: boolean): void;
    }
    class Node<T> {
        data: T;
        next: Node<T> | null;
        prev: Node<T> | null;
        constructor(data: T);
    }
    export class LinkedList<T> {
        private head;
        addLast(data: T): Node<T>;
        addFirst(data: T): Node<T>;
        removeNode(node: Node<T>): void;
        remove(data: T): void;
        search(data: T): Node<T> | null;
        list(): T[];
        size(): number;
    }
    export {};
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCodabarBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        private codabarSymbols;
        private codabarTable;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _ratio;
        get ratio(): number;
        set ratio(value: number);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        codabarSpaceLeft: number;
        codabarSpaceRight: number;
        codabarSpaceTop: number;
        codabarSpaceBottom: number;
        codabarLineHeightShort: number;
        codabarLineHeightLong: number;
        codabarTextPosition: number;
        codabarTextHeight: number;
        codabarMainHeight: number;
        codabarLineHeightForCut: number;
        codeToBar(inputCode: string): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, ratio?: number);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode11BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        code11Symbols: string;
        code11StartStopSymbolIndex: number;
        code11Table: string[];
        code11SpaceLeft: number;
        code11SpaceRight: number;
        code11SpaceTop: number;
        code11SpaceBottom: number;
        code11LineHeightShort: number;
        code11LineHeightLong: number;
        code11TextPosition: number;
        code11TextHeight: number;
        code11MainHeight: number;
        code11LineHeightForCut: number;
        defaultCode11Module: number;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        checksum: StiCode11CheckSum;
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, checksum?: StiCode11CheckSum);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiCode128BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        protected code128Table: string[];
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        protected code128SpaceLeft: number;
        protected code128SpaceRight: number;
        protected code128SpaceTop: number;
        protected code128SpaceBottom: number;
        protected code128LineHeightShort: number;
        protected code128LineHeightLong: number;
        protected code128TextPosition: number;
        protected code128TextHeight: number;
        protected code128MainHeight: number;
        protected code128LineHeightForCut: number;
        protected defaultCodeSetAB: CodeSet;
        protected codeToBar(inputCode: string): string;
        protected encodeAuto(inputText: string, encodeAsEan: boolean): string;
        private isDigit;
        private getSet;
        constructor(module?: number, height?: number);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode128AutoBarCodeType extends StiCode128BarCodeType {
        get serviceName(): string;
        get defaultCodeValue(): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode128aBarCodeType extends StiCode128BarCodeType {
        get serviceName(): string;
        get defaultCodeValue(): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode128bBarCodeType extends StiCode128BarCodeType {
        get serviceName(): string;
        get defaultCodeValue(): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode128cBarCodeType extends StiCode128BarCodeType {
        get serviceName(): string;
        get defaultCodeValue(): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode39BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        code39Symbols: string;
        code39StartStopSymbolIndex: number;
        code39Table: string[];
        get defaultCodeValue(): string;
        checkSum: StiCheckSum;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _ratio;
        get ratio(): number;
        set ratio(value: number);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        code39SpaceLeft: number;
        code39SpaceRight: number;
        code39SpaceTop: number;
        code39SpaceBottom: number;
        code39LineHeightShort: number;
        code39LineHeightLong: number;
        code39TextPosition: number;
        code39TextHeight: number;
        code39MainHeight: number;
        code39LineHeightForCut: number;
        codeToBar(inputCode: string): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, ratio?: number, checkSum?: StiCheckSum);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode39ExtBarCodeType extends StiCode39BarCodeType {
        get serviceName(): string;
        get defaultCodeValue(): string;
        protected code39ExtTable: string[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, ratio?: number, checkSum?: StiCheckSum);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode93BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        private code93Symbols;
        code93Table: string[];
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _ratio;
        get ratio(): number;
        set ratio(value: number);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        code93SpaceLeft: number;
        code93SpaceRight: number;
        code93SpaceTop: number;
        code93SpaceBottom: number;
        code93LineHeightShort: number;
        code93LineHeightLong: number;
        code93TextPosition: number;
        code93TextHeight: number;
        code93MainHeight: number;
        code93LineHeightForCut: number;
        codeToBar(inputCode: string): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, ratio?: number);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode93ExtBarCodeType extends StiCode93BarCodeType {
        get serviceName(): string;
        get defaultCodeValue(): string;
        private code93ExtSymbols;
        private code93ExtTable;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, ratio?: number);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDataMatrix {
        get matrix(): number[];
        get width(): number;
        get height(): number;
        get errorMessage(): string;
        private gridWidth;
        private gridHeight;
        private grid;
        private _errorMessage;
        private ecc200List;
        private _processTilde;
        private dataMatrixPlacementbit;
        private dataMatrixPlacementBlock;
        private dataMatrixPlacementCornerA;
        private dataMatrixPlacementCornerB;
        private dataMatrixPlacementCornerC;
        private dataMatrixPlacementCornerD;
        private dataMatrixPlacement;
        private makeEcc200Blocks;
        private dataMatrixEncode;
        private encodeB;
        private encodeA;
        private encodeE;
        private encodeCTX;
        private static isDigit;
        private static convertStringToBytes;
        private makeGrid;
        constructor(message: string, globalEncoding: StiDataMatrixEncodingType, useRectangularSymbols: boolean, matrixSize: StiDataMatrixSize, processTilde: boolean);
    }
    class StiDataMatrixBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        encodingType: StiDataMatrixEncodingType;
        matrixSize: StiDataMatrixSize;
        useRectangularSymbols: boolean;
        processTilde: boolean;
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, encodingType?: StiDataMatrixEncodingType, useRectangularSymbols?: boolean, matrixSize?: StiDataMatrixSize, processTilde?: boolean);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    class StiDutchKIXBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        dutchKIXSymbols: string;
        private dutchKIXCodes;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        get labelFontHeight(): number;
        protected preserveAspectRatio: boolean;
        get visibleProperties(): boolean[];
        dutchKIXSpaceLeft: number;
        dutchKIXSpaceRight: number;
        dutchKIXSpaceTop: number;
        dutchKIXSpaceBottom: number;
        dutchKIXLineHeightLong: number;
        dutchKIXLineHeightShort: number;
        dutchKIXTextPosition: number;
        dutchKIXTextHeight: number;
        dutchKIXMainHeight: number;
        dutchKIXLineHeightForCut: number;
        get textAlignment(): StringAlignment;
        private charTo4State;
        private stateToBar;
        private makeBarsArray;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEAN128AutoBarCodeType extends StiCode128BarCodeType {
        get serviceName(): string;
        get defaultCodeValue(): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEAN128aBarCodeType extends StiCode128BarCodeType {
        get serviceName(): string;
        get defaultCodeValue(): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEAN128bBarCodeType extends StiCode128BarCodeType {
        get serviceName(): string;
        get defaultCodeValue(): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEAN128cBarCodeType extends StiCode128BarCodeType {
        get serviceName(): string;
        get defaultCodeValue(): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class EanBarInfo {
        symbolType: Ean13Symbol;
        symbolText: string;
        textAtTop: boolean;
        makeLonger: boolean;
        constructor(symbolType: Ean13Symbol, symbolText: string, textAtTop: boolean, makeLonger?: boolean);
    }
    enum Ean13Symbol {
        ComboA0 = 0,
        ComboA1 = 1,
        ComboA2 = 2,
        ComboA3 = 3,
        ComboA4 = 4,
        ComboA5 = 5,
        ComboA6 = 6,
        ComboA7 = 7,
        ComboA8 = 8,
        ComboA9 = 9,
        ComboB0 = 10,
        ComboB1 = 11,
        ComboB2 = 12,
        ComboB3 = 13,
        ComboB4 = 14,
        ComboB5 = 15,
        ComboB6 = 16,
        ComboB7 = 17,
        ComboB8 = 18,
        ComboB9 = 19,
        ComboC0 = 20,
        ComboC1 = 21,
        ComboC2 = 22,
        ComboC3 = 23,
        ComboC4 = 24,
        ComboC5 = 25,
        ComboC6 = 26,
        ComboC7 = 27,
        ComboC8 = 28,
        ComboC9 = 29,
        GuardLeft = 30,
        GuardCenter = 31,
        GuardRight = 32,
        GuardSpecial = 33,
        GuardAddLeft = 34,
        GuardAddDelineator = 35,
        SpaceLeft = 36,
        SpaceRight = 37,
        SpaceBeforeAdd = 38
    }
    class StiEAN13BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        get defaultCodeValue(): string;
        get visibleProperties(): boolean[];
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        supplementType: StiEanSupplementType;
        supplementCode: string;
        showQuietZoneIndicator: boolean;
        get labelFontHeight(): number;
        protected get eanSpaceLeft(): number;
        protected get eanSpaceRight(): number;
        protected get eanSpaceTop(): number;
        protected get eanSpaceBottom(): number;
        protected get eanSpaceBeforeAdd(): number;
        protected get eanSpaceTextTop(): number;
        protected get eanLineHeightShort(): number;
        protected get eanLineHeightLong(): number;
        protected get eanTextPositionTop(): number;
        protected get eanTextPositionBottom(): number;
        protected get eanTextHeight(): number;
        protected get eanMainHeight(): number;
        protected get eanLineHeightForCut(): number;
        protected get eanWideToNarrowRatio(): number;
        protected symComboSet: string[];
        protected symParitySetAdd2: string[];
        protected symParitySetAdd5: string[];
        protected ean13SymData: string[];
        protected calculateSizeEan(offsetY: number, zoom: number, barsArray: EanBarInfo[], rect: RectangleD, barCode: StiBarCode): void;
        protected drawEanBars(context: any, barsArray: EanBarInfo[], barCode: StiBarCode): void;
        protected makeEan13Bars(REFcode: any, isLast: boolean): EanBarInfo[];
        protected makeEanAdd2Bars(code: string, baseArray: EanBarInfo[], isLast: boolean): EanBarInfo[];
        protected makeEanAdd5Bars(code: string, baseArray: EanBarInfo[], isLast: boolean): EanBarInfo[];
        protected makeLonger(symString: string): string;
        protected getSymbolWidth(symbol: string): number;
        protected isSymbolSpace(symbol: string): boolean;
        draw(context: number, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEAN8BarCodeType extends StiEAN13BarCodeType {
        get serviceName(): string;
        get defaultCodeValue(): string;
        get eanSpaceLeft(): number;
        get eanSpaceRight(): number;
        get eanLineHeightShort(): number;
        get eanMainHeight(): number;
        makeEan8Bars(code: string, isLast: boolean): EanBarInfo[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiFIMBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        fIMSymbols: string;
        fIMTable: string[];
        defaultFIMModule: number;
        get defaultCodeValue(): string;
        get visibleProperties(): boolean[];
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        addClearZone: boolean;
        get labelFontHeight(): number;
        protected preserveAspectRatio: boolean;
        get fIMSpaceLeft(): number;
        get fIMSpaceRight(): number;
        fIMSpaceTop: number;
        fIMSpaceBottom: number;
        fIMLineHeightShort: number;
        fIMLineHeightLong: number;
        fIMTextPosition: number;
        fIMTextHeight: number;
        fIMMainHeight: number;
        fIMLineHeightForCut: number;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, addClearZone?: boolean);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StringBuilder = Stimulsoft.System.Text.StringBuilder;
    class StiGS1ApplicationIdentifierItem {
        AICode: string;
        AILength: number;
        NumericMin: number;
        NumericMax: number;
        CharacterMin: number;
        CharacterMax: number;
        NeedFNC1: boolean;
        DataTitle: string;
        DataContent: string;
        constructor(AICode: string, AILength: number, NumericMin: number, NumericMax: number, CharacterMin: number, CharacterMax: number, NeedFNC1: boolean, DataTitle: string, DataContent: string);
    }
    export class StiGS1ApplicationIdentifiers {
        static GS1ApplicationIdentifiers: StiGS1ApplicationIdentifierItem[];
        private static AICodeToItem;
        static getApplicationIdentifierItemByCode(code: string): StiGS1ApplicationIdentifierItem;
        static parseCode(code: string, outputCode: StringBuilder, outputText: StringBuilder, fnc1: string, addLeadingFnc1: boolean): string;
    }
    export {};
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiGS1DataMatrixBarCodeType extends Stimulsoft.Report.BarCodes.StiDataMatrixBarCodeType implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        get defaultCodeValue(): string;
        encodingType: StiDataMatrixEncodingType;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, encodingType?: StiDataMatrixEncodingType, useRectangularSymbols?: boolean, matrixSize?: StiDataMatrixSize, processTilde?: boolean);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiQRCodeEyeBallShapeType = Stimulsoft.Report.BarCodes.StiQRCodeEyeBallShapeType;
    import StiQRCodeBodyShapeType = Stimulsoft.Report.BarCodes.StiQRCodeBodyShapeType;
    import StiQRCodeEyeFrameShapeType = Stimulsoft.Report.BarCodes.StiQRCodeEyeFrameShapeType;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Image = Stimulsoft.System.Drawing.Image;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiQRCodeBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        errorCorrectionLevel: StiQRCodeErrorCorrectionLevel;
        matrixSize: StiQRCodeSize;
        image: Image;
        imageMultipleFactor: number;
        bodyShape: StiQRCodeBodyShapeType;
        eyeFrameShape: StiQRCodeEyeFrameShapeType;
        eyeBallShape: StiQRCodeEyeBallShapeType;
        bodyBrush: StiBrush;
        eyeFrameBrush: StiBrush;
        eyeBallBrush: StiBrush;
        processTilde: boolean;
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        drawQRCode(context: any, rect: Rectangle, barCode: StiBarCode, zoom: number, bodyShape: StiQRCodeBodyShapeType, eyeFrameShape: StiQRCodeEyeFrameShapeType, eyeBallShape: StiQRCodeEyeBallShapeType): void;
        private addArcPoints;
        private drawBodyShapes;
        private drawBodyShapeCircleZebraHorizontal;
        private drawBodyShapeCircleZebraVertical;
        private drawBodyShapeCircleZebraCross1;
        private drawBodyShapeCircleZebraCross2;
        private drawEyeFrames;
        private drawEyeFrameSquare;
        private drawEyeFrameDots;
        private drawEyeFrameCircle;
        private drawEyeFrameRound;
        private drawEyeFrameRound1;
        private drawEyeFrameRound3;
        private drawEyeBalls;
        private drawEyeBallSquare;
        private drawEyeBallDots;
        private drawEyeBallCircle;
        private drawEyeBallRound;
        private drawEyeBallRound1;
        private drawEyeBallRound3;
        private drawEyeBallStar;
        private drawEyeBallCircleZebraHorizontal;
        private drawEyeBallCircleZebraVertical;
        constructor(module?: number, errorCorrectionLevel?: StiQRCodeErrorCorrectionLevel, matrixSize?: StiQRCodeSize, image?: Image, imageMultipleFactor?: number, processTilde?: boolean, bodyShape?: StiQRCodeBodyShapeType, eyeFrameShape?: StiQRCodeEyeFrameShapeType, eyeBallShape?: StiQRCodeEyeBallShapeType, bodyBrush?: StiBrush, eyeFrameBrush?: StiBrush, eyeBallBrush?: StiBrush);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiQRCodeEyeBallShapeType = Stimulsoft.Report.BarCodes.StiQRCodeEyeBallShapeType;
    import StiQRCodeBodyShapeType = Stimulsoft.Report.BarCodes.StiQRCodeBodyShapeType;
    import StiQRCodeEyeFrameShapeType = Stimulsoft.Report.BarCodes.StiQRCodeEyeFrameShapeType;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Image = Stimulsoft.System.Drawing.Image;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiGS1QRCodeBarCodeType extends StiQRCodeBarCodeType implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        get defaultCodeValue(): string;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, errorCorrectionLevel?: StiQRCodeErrorCorrectionLevel, matrixSize?: StiQRCodeSize, image?: Image, imageMultipleFactor?: number, processTilde?: boolean, bodyShape?: StiQRCodeBodyShapeType, eyeFrameShape?: StiQRCodeEyeFrameShapeType, eyeBallShape?: StiQRCodeEyeBallShapeType, bodyBrush?: StiBrush, eyeFrameBrush?: StiBrush, eyeBallBrush?: StiBrush);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiGS1_128BarCodeType extends StiCode128BarCodeType {
        get serviceName(): string;
        get defaultCodeValue(): string;
        protected textSpacing: boolean;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiITF14BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _ratio;
        get ratio(): number;
        set ratio(value: number);
        printVerticalBars: boolean;
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        protected symTableSet: string[];
        private itf14BearerBarWidth;
        private itf14SpaceLeft;
        private itf14SpaceRight;
        private itf14SpaceTop;
        private itf14SpaceBottom;
        private itf14LineHeightShort;
        private itf14LineHeightLong;
        private itf14TextHeight;
        private itf14MainHeight;
        private itf14TextPosition;
        private itf14LineHeightForCut;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, ratio?: number, printVerticalBars?: boolean);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    class IntelligentMail4State {
        private static table2Of13Size;
        private static table5Of13Size;
        private static entries2Of13;
        private static entries5Of13;
        private static table2Of13;
        private static table5Of13;
        private static codewordArray;
        private static barTopCharIndexArray;
        private static barBottomCharIndexArray;
        private static barTopCharShiftArray;
        private static barBottomCharShiftArray;
        static encode(source: string, refBars: {
            bars: string;
        }): string;
        private static mathAdd;
        private static mathDivide;
        private static mathFcs;
        private static mathMultiply;
        private static mathReverse;
        private static initializeNof13Table;
        static staticConstructor(): void;
    }
    class StiIntelligentMail4StateBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        protected intelligentMail4StateSpaceLeft: number;
        protected intelligentMail4StateSpaceRight: number;
        protected intelligentMail4StateSpaceTop: number;
        protected intelligentMail4StateSpaceBottom: number;
        protected intelligentMail4StateLineHeightLong: number;
        protected intelligentMail4StateLineHeightShort: number;
        protected intelligentMail4StateTextPosition: number;
        protected intelligentMail4StateTextHeight: number;
        protected intelligentMail4StateMainHeight: number;
        protected intelligentMail4StateLineHeightForCut: number;
        protected intelligentMail4StateWideToNarrowRatio: number;
        protected get textAlignment(): StringAlignment;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        get labelFontHeight(): number;
        protected textSpacing: boolean;
        protected preserveAspectRatio: boolean;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiInterleaved2of5BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _ratio;
        get ratio(): number;
        set ratio(value: number);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        protected symTableSet: string[];
        private interleaved2of5SpaceLeft;
        private interleaved2of5SpaceRight;
        private interleaved2of5SpaceTop;
        private interleaved2of5SpaceBottom;
        private interleaved2of5LineHeightShort;
        private interleaved2of5LineHeightLong;
        private interleaved2of5TextHeight;
        private interleaved2of5MainHeight;
        private interleaved2of5TextPosition;
        private interleaved2of5LineHeightForCut;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        StiInterleaved2of5BarCodeType(module?: number, height?: number, ratio?: number): void;
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiIsbn13BarCodeType extends StiEAN13BarCodeType {
        get serviceName(): string;
        get defaultCodeValue(): string;
        isbnOffsetY: number;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiIsbn10BarCodeType extends StiIsbn13BarCodeType {
        get visibleProperties(): boolean[];
        get serviceName(): string;
        get defaultCodeValue(): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiJan13BarCodeType extends StiEAN13BarCodeType {
        get serviceName(): string;
        get defaultCodeValue(): string;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiJan8BarCodeType extends StiEAN8BarCodeType {
        get serviceName(): string;
        get defaultCodeValue(): string;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiMaxicodeMode = Stimulsoft.Report.BarCodes.StiMaxicodeMode;
    class StiMaxicodeBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        get defaultCodeValue(): string;
        get module(): number;
        set module(value: number);
        get height(): number;
        set innerHeight(value: number);
        mode: StiMaxicodeMode;
        processTilde: boolean;
        structuredAppendPosition: number;
        structuredAppendTotal: number;
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(mode?: StiMaxicodeMode, structuredAppendPosition?: number, structuredAppendTotal?: number, processTilde?: boolean);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPlesseyBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        plesseySymbols: string;
        private plesseyTable;
        private plesseyStartCode;
        private plesseyStopCode;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _checkSum1;
        get checkSum1(): StiPlesseyCheckSum;
        set checkSum1(value: StiPlesseyCheckSum);
        private _checkSum2;
        get checkSum2(): StiPlesseyCheckSum;
        set checkSum2(value: StiPlesseyCheckSum);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        plesseySpaceLeft: number;
        plesseySpaceRight: number;
        plesseySpaceTop: number;
        plesseySpaceBottom: number;
        plesseyLineHeightShort: number;
        plesseyLineHeightLong: number;
        plesseyTextPosition: number;
        plesseyTextHeight: number;
        plesseyMainHeight: number;
        plesseyLineHeightForCut: number;
        private codeToBar;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, checkSum1?: StiPlesseyCheckSum, checkSum2?: StiPlesseyCheckSum);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiMsiBarCodeType extends StiPlesseyBarCodeType {
        meta(): StiMeta[];
        get serviceName(): string;
        get defaultCodeValue(): string;
        get visibleProperties(): boolean[];
        private msiTable;
        private msiStartCode;
        private msiStopCode;
        protected codeToBarMsi(inputCode: string): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, checkSum1?: StiPlesseyCheckSum, checkSum2?: StiPlesseyCheckSum);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class MacroMetadata {
        segmentIndex: number;
        segmentCount: number;
        fileId: string;
        sender: string;
        addressee: string;
        fileName: string;
        fileSize: number;
        checksum: number;
        timestamp: number;
    }
    class StiPdf417 {
        private max_data_codewords;
        private codeWordLength;
        private startPatternCode;
        private stopPatternCode;
        private static clustersData;
        private static errorLevelData;
        matrix: number[];
        matrixWidth: number;
        get matrixHeight(): number;
        get errorMessage(): string;
        private text;
        private codewords;
        private _errorMessage;
        private codeColumns;
        private codeRows;
        private errorLevel;
        private aspectRatio;
        private ratioY;
        private processTilde;
        private macroData;
        private makeOutBits;
        private outCodeword;
        private calculateErrorCorrection;
        private dataCompaction;
        private getSubMode;
        private textCompaction;
        private numberCompaction;
        private byteCompaction;
        private getMacroBlock;
        private appendMacroOptionalField;
        private encodeMacroField;
        constructor(inputData: string, mode: StiPdf417EncodingMode, errorCorrectionLevel?: StiPdf417ErrorsCorrectionLevel, columns?: number, rows?: number, autoColumns?: boolean, autoRows?: boolean, aspectRatio?: number, ratioY?: number, processTilde?: boolean, macroData?: MacroMetadata);
    }
    class StiPdf417BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        encodingMode: StiPdf417EncodingMode;
        errorsCorrectionLevel: StiPdf417ErrorsCorrectionLevel;
        private _dataColumns;
        get dataColumns(): number;
        set dataColumns(value: number);
        private _dataRows;
        get dataRows(): number;
        set dataRows(value: number);
        autoDataColumns: boolean;
        autoDataRows: boolean;
        private _aspectRatio;
        get aspectRatio(): number;
        set aspectRatio(value: number);
        private _ratioY;
        get ratioY(): number;
        set ratioY(value: number);
        processTilde: boolean;
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, encodingMode?: StiPdf417EncodingMode, errorsCorrectionLevel?: StiPdf417ErrorsCorrectionLevel, dataColumns?: number, dataRows?: number, autoDataColumns?: boolean, autoDataRows?: boolean, aspectRatio?: number, ratioY?: number, processTilde?: boolean);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPdf417MacroBarCodeType extends StiPdf417BarCodeType {
        meta(): StiMeta[];
        get serviceName(): string;
        private _segmentIndex;
        get segmentIndex(): number;
        set segmentIndex(value: number);
        private _segmentCount;
        get segmentCount(): number;
        set segmentCount(value: number);
        fileId: string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, encodingMode?: StiPdf417EncodingMode, errorsCorrectionLevel?: StiPdf417ErrorsCorrectionLevel, dataColumns?: number, dataRows?: number, autoDataColumns?: boolean, autoDataRows?: boolean, aspectRatio?: number, ratioY?: number, processTilde?: boolean, segmentIndex?: number, segmentCount?: number, fileId?: string);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPharmacodeBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        pharmacodeSymbols: string;
        defaultPharmacodeModule: number;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        pharmacodeSpaceLeft: number;
        pharmacodeSpaceRight: number;
        pharmacodeSpaceTop: number;
        pharmacodeSpaceBottom: number;
        pharmacodeLineHeightShort: number;
        pharmacodeLineHeightLong: number;
        pharmacodeTextPosition: number;
        pharmacodeTextHeight: number;
        pharmacodeMainHeight: number;
        pharmacodeLineHeightForCut: number;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPostnetBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        postnetSymbols: string;
        private postnetTable;
        private postnetStartCode;
        private postnetStopCode;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _space;
        get space(): number;
        set space(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        get labelFontHeight(): number;
        protected preserveAspectRatio: boolean;
        get visibleProperties(): boolean[];
        postnetSpaceLeft: number;
        postnetSpaceRight: number;
        postnetSpaceTop: number;
        postnetSpaceBottom: number;
        postnetLineHeightLong: number;
        postnetLineHeightShort: number;
        postnetTextPosition: number;
        postnetTextHeight: number;
        postnetMainHeight: number;
        postnetLineHeightForCut: number;
        private codeToBar;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, space?: number);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRoyalMail4StateBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        royalMail4StateSymbols: string;
        private royalMail4StateStartCode;
        private royalMail4StateStopCode;
        private royalMail4StateCodes;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        checkSum: StiCheckSum;
        get labelFontHeight(): number;
        protected preserveAspectRatio: boolean;
        get visibleProperties(): boolean[];
        royalMail4StateSpaceLeft: number;
        royalMail4StateSpaceRight: number;
        royalMail4StateSpaceTop: number;
        royalMail4StateSpaceBottom: number;
        royalMail4StateLineHeightLong: number;
        royalMail4StateLineHeightShort: number;
        royalMail4StateTextPosition: number;
        royalMail4StateTextHeight: number;
        royalMail4StateMainHeight: number;
        royalMail4StateLineHeightForCut: number;
        get textAlignment(): StringAlignment;
        private charTo4State;
        private stateToBar;
        private makeBarsArray;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, checkSum?: StiCheckSum);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiSSCC18BarCodeType extends StiCode128cBarCodeType implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        get defaultCodeValue(): string;
        companyPrefix: string;
        serialNumber: string;
        extensionDigit: string;
        protected textSpacing: boolean;
        get visibleProperties(): boolean[];
        getCombinedCode(): string;
        private getCheckDigit;
        private checkContens;
        draw(context: any, barCode: StiBarCode, rect: Rectangle, zoom: number): void;
        constructor(module?: number, height?: number);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStandard2of5BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        get serviceName(): string;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _ratio;
        get ratio(): number;
        set ratio(value: number);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        protected symTableSet: string[];
        private standard2of5SpaceLeft;
        private standard2of5SpaceRight;
        private standard2of5SpaceTop;
        private standard2of5SpaceBottom;
        private standard2of5LineHeightShort;
        private standard2of5LineHeightLong;
        private standard2of5TextHeight;
        private standard2of5MainHeight;
        private standard2of5TextPosition;
        private standard2of5LineHeightForCut;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, ratio?: number);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiUpcABarCodeType extends StiEAN13BarCodeType {
        get serviceName(): string;
        get eanSpaceLeft(): number;
        get eanSpaceRight(): number;
        get defaultCodeValue(): string;
        get visibleProperties(): boolean[];
        showQuietZoneIndicator: boolean;
        makeUpcABars(code: string, isLast: boolean): EanBarInfo[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    class StiUpcEBarCodeType extends StiEAN13BarCodeType {
        get serviceName(): string;
        protected symParitySet: string[];
        protected get eanSpaceLeft(): number;
        protected get eanSpaceRight(): number;
        get defaultCodeValue(): string;
        get visibleProperties(): boolean[];
        showQuietZoneIndicator: boolean;
        protected makeUpcEBars(code: string, isLast: boolean): EanBarInfo[];
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiUpcSup2BarCodeType extends StiEAN13BarCodeType {
        get serviceName(): string;
        get defaultCodeValue(): string;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiUpcSup5BarCodeType extends StiEAN13BarCodeType {
        get serviceName(): string;
        get defaultCodeValue(): string;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
export namespace Stimulsoft.Report.BarCodes {
    class ArrayHelper {
        static copy(sourceArray: any[], sourceIndex: number, destinationArray: any[], destinationIndex: number, length: number): void;
    }
}
export namespace Stimulsoft.Report.BarCodes {
    class BitVector {
        private sizeInBits;
        private array;
        constructor();
        at(index: number): number;
        size(): number;
        sizeInBytes(): number;
        appendBit(bit: number): void;
        appendBits(value: number, numBits: number): void;
        appendBitVector(bits: BitVector): void;
        xor(other: BitVector): void;
        toString(): string;
        getArray(): number[];
        private appendByte;
    }
}
export namespace Stimulsoft.Report.BarCodes {
    class BlockPair {
        private dataBytes;
        private errorCorrectionBytes;
        constructor(data: ByteArray, errorCorrection: ByteArray);
        getDataBytes(): ByteArray;
        getErrorCorrectionBytes(): ByteArray;
    }
}
export namespace Stimulsoft.Report.BarCodes {
    class ByteArray {
        private static INITIAL_SIZE;
        private _bytes;
        private _size;
        constructor(size?: number, byteArray?: number[]);
        at(index: number): number;
        set(index: number, value: number): void;
        size(): number;
        isEmpty(): boolean;
        appendByte(value: number): void;
        reserve(capacity: number): void;
        set1(source: number[], offset: number, count: number): void;
    }
}
export namespace Stimulsoft.Report.BarCodes {
    class ByteMatrix {
        private _bytes;
        private _width;
        private _height;
        getValueString(): string;
        constructor(width: number, height: number);
        getHeight(): number;
        getWidth(): number;
        get(x: number, y: number): number;
        getArray(): number[][];
        set(x: number, y: number, value: number): void;
        set2(x: number, y: number, value: number): void;
        clear(value: number): void;
    }
}
export namespace Stimulsoft.Report.BarCodes {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class CharacterSetECI {
        private static _name_to_eci;
        static get NAME_TO_ECI(): Hashtable;
        static set NAME_TO_ECI(value: Hashtable);
        private static Initialize;
        private _encodingName;
        private _value;
        private _codepage;
        constructor(value: number, encodingName: string, codepage: number);
        getEncodingName(): string;
        getValue(): number;
        getCodepage(): number;
        private static addCharacterSet;
        static getCharacterSetECIByName(name: string): CharacterSetECI;
        static getCharacterSetECIByCodepage(codepage: number): CharacterSetECI;
        static getEncodingCodePageByNumber(encodingNumber: number, defaultEncoding: number): number;
    }
}
export namespace Stimulsoft.Report.BarCodes {
    class ErrorCorrectionLevel {
        static L: ErrorCorrectionLevel;
        static M: ErrorCorrectionLevel;
        static Q: ErrorCorrectionLevel;
        static H: ErrorCorrectionLevel;
        private _ordinal;
        private _bits;
        private _name;
        constructor(ordinal: number, bits: number, name: string);
        ordinal(): number;
        getBits(): number;
        getName(): string;
        toString(): string;
        static forBits(bits: number): ErrorCorrectionLevel;
    }
}
export namespace Stimulsoft.Report.BarCodes {
    class FormatInformation {
        private FORMAT_INFO_MASK_QR;
        private static FORMAT_INFO_DECODE_LOOKUP;
        private static BITS_SET_IN_HALF_BYTE;
        private errorCorrectionLevel;
        private dataMask;
        constructor(formatInfo: number);
        static numBitsDiffering(a: number, b: number): number;
        static decodeFormatInformation(maskedFormatInfo1: number, maskedFormatInfo2: number): FormatInformation;
        private static doDecodeFormatInformation;
        getErrorCorrectionLevel(): ErrorCorrectionLevel;
        getDataMask(): number;
        equals(o: any): boolean;
    }
}
export namespace Stimulsoft.Report.BarCodes {
    class GF256 {
        static QR_CODE_FIELD: GF256;
        static DATA_MATRIX_FIELD: GF256;
        private _expTable;
        private _logTable;
        private _zero;
        private _one;
        constructor(primitive: number);
        getZero(): GF256Poly;
        getOne(): GF256Poly;
        buildMonomial(degree: number, coefficient: number): GF256Poly;
        static addOrSubtract(a: number, b: number): number;
        exp(a: number): number;
        log(a: number): number;
        inverse(a: number): number;
        multiply(a: number, b: number): number;
    }
}
export namespace Stimulsoft.Report.BarCodes {
    class GF256Poly {
        _field: GF256;
        _coefficients: number[];
        constructor(field: GF256, coefficients: number[]);
        getCoefficients(): number[];
        getDegree(): number;
        isZero(): boolean;
        getCoefficient(degree: number): number;
        evaluateAt(a: number): number;
        addOrSubtract(other: GF256Poly): GF256Poly;
        multiply(other: GF256Poly): GF256Poly;
        multiply1(scalar: number): GF256Poly;
        multiplyByMonomial(degree: number, coefficient: number): GF256Poly;
        divide(other: GF256Poly): GF256Poly[];
    }
}
export namespace Stimulsoft.Report.BarCodes {
    class MaskUtil {
        static applyMaskPenaltyRule1(matrix: ByteMatrix): number;
        static applyMaskPenaltyRule2(matrix: ByteMatrix): number;
        static applyMaskPenaltyRule3(matrix: ByteMatrix): number;
        static applyMaskPenaltyRule4(matrix: ByteMatrix): number;
        static getDataMaskBit(maskPattern: number, x: number, y: number): boolean;
        private static ApplyMaskPenaltyRule1Internal;
    }
}
export namespace Stimulsoft.Report.BarCodes {
    class MatrixUtil {
        private static POSITION_DETECTION_PATTERN;
        private static HORIZONTAL_SEPARATION_PATTERN;
        private static VERTICAL_SEPARATION_PATTERN;
        private static POSITION_ADJUSTMENT_PATTERN;
        private static POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE;
        private static TYPE_INFO_COORDINATES;
        private static VERSION_INFO_POLY;
        private static TYPE_INFO_POLY;
        private static TYPE_INFO_MASK_PATTERN;
        static ClearMatrix(matrix: ByteMatrix): void;
        static BuildMatrix(dataBits: BitVector, ecLevel: ErrorCorrectionLevel, version: number, maskPattern: number, matrix: ByteMatrix): void;
        static EmbedBasicPatterns(version: number, matrix: ByteMatrix): void;
        static EmbedTypeInfo(ecLevel: ErrorCorrectionLevel, maskPattern: number, matrix: ByteMatrix): void;
        static MaybeEmbedVersionInfo(version: number, matrix: ByteMatrix): void;
        static EmbedDataBits(dataBits: BitVector, maskPattern: number, matrix: ByteMatrix): void;
        static EmbedDataBits2(dataBits: BitVector, matrices: ByteMatrix[]): void;
        static FindMSBSet(value: number): number;
        static CalculateBCHCode(value: number, poly: number): number;
        static MakeTypeInfoBits(ecLevel: ErrorCorrectionLevel, maskPattern: number, bits: BitVector): void;
        static MakeVersionInfoBits(version: number, bits: BitVector): void;
        private static IsEmpty;
        private static IsValidValue;
        private static EmbedTimingPatterns;
        private static EmbedDarkDotAtLeftBottomCorner;
        private static EmbedHorizontalSeparationPattern;
        private static EmbedVerticalSeparationPattern;
        private static EmbedPositionAdjustmentPattern;
        private static EmbedPositionDetectionPattern;
        private static EmbedPositionDetectionPatternsAndSeparators;
        private static MaybeEmbedPositionAdjustmentPatterns;
    }
}
export namespace Stimulsoft.Report.BarCodes {
    class Mode {
        static TERMINATOR: Mode;
        static NUMERIC: Mode;
        static ALPHANUMERIC: Mode;
        static STRUCTURED_APPEND: Mode;
        static BYTE: Mode;
        static ECI: Mode;
        static KANJI: Mode;
        static FNC1_FIRST_POSITION: Mode;
        static FNC1_SECOND_POSITION: Mode;
        private characterCountBitsForVersions;
        private bits;
        private name;
        constructor(characterCountBitsForVersions: number[], bits: number, name: string);
        static ForBits(bits: number): Mode;
        GetCharacterCountBits(version: Version): number;
        GetBits(): number;
        GetName(): string;
        ToString(): string;
    }
}
export namespace Stimulsoft.Report.BarCodes {
    class QREncoder {
        private static ALPHANUMERIC_TABLE;
        private static defaultECIByteModeEncoding;
        private static BYTE_MODE_UTF8;
        private static QUESTION_MARK_CHAR;
        private static CalculateMaskPenalty;
        static Encode(content: string, ecLevel: ErrorCorrectionLevel, qrCode: StiQRCode, startVersion: StiQRCodeSize, processTilde: boolean, gs1?: boolean): void;
        private static GetEncodingCodepage;
        private static TryEncodeByte;
        private static GetAlphanumericCode;
        static ChooseMode1(content: string, encoding: number, gs1: boolean): Mode;
        private static ChooseMaskPattern;
        private static ChooseMaskPattern2;
        private static InitQRCode;
        private static TerminateBits;
        private static GetNumDataBytesAndNumECBytesForBlockID;
        private static InterleaveWithECBytes;
        private static GenerateECBytes;
        private static AppendModeInfo;
        private static AppendLengthInfo;
        private static AppendBytes;
        private static AppendNumericBytes;
        private static AppendAlphanumericBytes;
        private static Append8BitBytes;
        private static AppendKanjiBytes;
        private static AppendECI;
    }
}
export namespace Stimulsoft.Report.BarCodes {
    class ReedSolomonEncoder {
        private field;
        private cachedGenerators;
        constructor(field: GF256);
        private BuildGenerator;
        Encode(toEncode: number[], ecBytes: number): void;
    }
}
export namespace Stimulsoft.Report.BarCodes {
    class StiQRCode {
        static NUM_MASK_PATTERNS: number;
        private _mode;
        private _ecLevel;
        private _version;
        private _matrixWidth;
        private _maskPattern;
        private _numTotalBytes;
        private _numDataBytes;
        private _numECBytes;
        private _numRSBlocks;
        private _matrix;
        GetMode(): Mode;
        GetECLevel(): ErrorCorrectionLevel;
        GetVersion(): number;
        GetMatrixWidth(): number;
        GetMaskPattern(): number;
        GetNumTotalBytes(): number;
        GetNumDataBytes(): number;
        GetNumECBytes(): number;
        GetNumRSBlocks(): number;
        GetMatrix(): ByteMatrix;
        At(x: number, y: number): number;
        IsValid(): boolean;
        SetMode(value: Mode): void;
        SetECLevel(value: ErrorCorrectionLevel): void;
        SetVersion(value: number): void;
        SetMatrixWidth(value: number): void;
        SetMaskPattern(value: number): void;
        SetNumTotalBytes(value: number): void;
        SetNumDataBytes(value: number): void;
        SetNumECBytes(value: number): void;
        SetNumRSBlocks(value: number): void;
        SetMatrix(value: ByteMatrix): void;
        static IsValidMaskPattern(maskPattern: number): boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.BarCodes {
    class ECB {
        private _count;
        private _dataCodewords;
        constructor(count: number, dataCodewords: number);
        getCount(): number;
        getDataCodewords(): number;
    }
    class ECBlocks {
        private ecCodewordsPerBlock;
        private ecBlocks;
        constructor(ecCodewordsPerBlock: number, ecBlocks1: ECB, ecBlocks2?: ECB);
        getECCodewordsPerBlock(): number;
        getNumBlocks(): number;
        getTotalECCodewords(): number;
        getECBlocks(): ECB[];
    }
    class Version {
        private static VERSION_DECODE_INFO;
        private static BuildVersions;
        private static VERSIONS;
        private _versionNumber;
        private _alignmentPatternCenters;
        private _ecBlocks;
        private _totalCodewords;
        constructor(versionNumber: number, alignmentPatternCenters: number[], ecBlocks1: ECBlocks, ecBlocks2: ECBlocks, ecBlocks3: ECBlocks, ecBlocks4: ECBlocks);
        getVersionNumber(): number;
        getAlignmentPatternCenters(): number[];
        getTotalCodewords(): number;
        getDimensionForVersion(): number;
        getECBlocksForLevel(ecLevel: ErrorCorrectionLevel): ECBlocks;
        static getProvisionalVersionForDimension(dimension: number): Version;
        static getVersionForNumber(versionNumber: number): Version;
        static decodeVersionInformation(versionBits: number): Version;
        toString(): string;
    }
}
export namespace Stimulsoft.Report.Chart {
    enum StiColumnShape3D {
        Box = 0,
        Pyramid = 1,
        PartialPyramid = 2
    }
    enum StiPie3dLightingStyle {
        No = 0,
        Solid = 1,
        Gradient = 2
    }
    class StiTrendLinePropertyOrder {
        lineColor: number;
        lineStyle: number;
        lineWidth: number;
        showShadow: number;
    }
    class StiSeriesLabelsPropertyOrder {
        allowApplyStyle: number;
        angle: number;
        antialiasing: number;
        autoRotate: number;
        conditions: number;
        drawBorder: number;
        borderColor: number;
        brush: number;
        font: number;
        format: number;
        labelColor: number;
        legendValueType: number;
        lineColor: number;
        lineColorNegative: number;
        lineLength: number;
        markerAlignment: number;
        markerSize: number;
        markerVisible: number;
        preventIntersection: number;
        showInPercent: number;
        showNulls: number;
        showValue: number;
        showZeros: number;
        step: number;
        textAfter: number;
        textBefore: number;
        useSeriesColor: number;
        valueType: number;
        valueTypeSeparator: number;
        visible: number;
        width: number;
        wordWrap: number;
    }
    class StiSeriesPropertyOrder {
        allowSeries: number;
        allowSeriesElements: number;
        drillDownEnabled: number;
        drillDownPage: number;
        drillDownReport: number;
        hyperlinkDataColumn: number;
        tagDataColumn: number;
        toolTipDataColumn: number;
        weightDataColumn: number;
        hyperlink: number;
        tag: number;
        toolTip: number;
        weight: number;
        listOfHyperlinks: number;
        listOfTags: number;
        listOfToolTips: number;
        listOfWeights: number;
        valueValueDataColumn: number;
        valueValue: number;
        valueListOfValues: number;
        valueValueDataColumnEnd: number;
        valueValueEnd: number;
        valueListOfValuesEnd: number;
        valueValueDataColumnOpen: number;
        valueValueOpen: number;
        valueListOfValuesOpen: number;
        valueValueDataColumnClose: number;
        valueValueClose: number;
        valueListOfValuesClose: number;
        valueValueDataColumnHigh: number;
        valueValueHigh: number;
        valueListOfValuesHigh: number;
        valueValueDataColumnLow: number;
        valueValueLow: number;
        valueListOfValuesLow: number;
        argumentArgumentDataColumn: number;
        argumentArgument: number;
        argumentListOfArguments: number;
        weightWeightDataColumn: number;
        weightWeight: number;
        weightListOfWeights: number;
        appearanceAllowApplyBorderColor: number;
        appearanceAllowApplyBrush: number;
        appearanceAllowApplyBrushNegative: number;
        appearanceAllowApplyColorNegative: number;
        appearanceDiameter: number;
        appearanceBorderColor: number;
        appearanceBrush: number;
        appearanceBrushNegative: number;
        appearanceLighting: number;
        appearanceShowShadow: number;
        appearanceTopmostLine: number;
        appearanceFunnelSliceMode: number;
        dataConditions: number;
        dataFilters: number;
        dataFilterMode: number;
        dataTopN: number;
        dataFormat: number;
        dataSortBy: number;
        dataSortDirection: number;
        dataAutoSeriesKeyDataColumn: number;
        dataAutoSeriesColorDataColumn: number;
        dataAutoSeriesTitleDataColumn: number;
    }
    enum StiChartTitleDock {
        Top = 0,
        Right = 90,
        Bottom = 180,
        Left = 270
    }
    enum StiLegendDirection {
        LeftToRight = 0,
        RightToLeft = 1,
        TopToBottom = 2,
        BottomToTop = 3
    }
    enum StiDirection {
        LeftToRight = 0,
        RightToLeft = 1,
        TopToBottom = 2,
        BottomToTop = 3
    }
    enum StiLegendHorAlignment {
        LeftOutside = 0,
        Left = 1,
        Center = 2,
        Right = 3,
        RightOutside = 4
    }
    enum StiLegendVertAlignment {
        TopOutside = 0,
        Top = 1,
        Center = 2,
        Bottom = 3,
        BottomOutside = 4
    }
    enum StiMarkerAlignment {
        Left = 0,
        Center = 1,
        Right = 2
    }
    enum StiChartAreaPosition {
        ClusteredColumn = 0,
        StackedColumn = 1,
        FullStackedColumn = 2,
        Pareto = 3,
        Waterfall = 4,
        Histogram = 5,
        ClusteredBar = 10,
        StackedBar = 11,
        FullStackedBar = 12,
        Pie = 20,
        Doughnut = 21,
        Line = 30,
        SteppedLine = 31,
        StackedLine = 32,
        FullStackedLine = 33,
        Spline = 40,
        StackedSpline = 41,
        FullStackedSpline = 42,
        Area = 50,
        SteppedArea = 51,
        StackedArea = 52,
        FullStackedArea = 53,
        SplineArea = 60,
        StackedSplineArea = 61,
        FullStackedSplineArea = 62,
        Gantt = 70,
        Scatter = 80,
        Bubble = 81,
        RadarPoint = 82,
        RadarLine = 83,
        RadarArea = 84,
        Range = 90,
        SteppedRange = 91,
        RangeBar = 92,
        SplineRange = 93,
        Funnel = 100,
        Candlestick = 110,
        Stock = 120,
        BoxAndWhisker = 121,
        Heatmap = 125,
        Treemap = 130,
        Pictorial = 131,
        PictorialStacked = 132,
        Sunburst = 140,
        Pie3d = 200,
        ClusteredColumn3d = 201,
        StackedColumn3d = 202,
        FullStackedColumn3d = 202,
        Line3d = 205
    }
    enum StiChartSeriesOrientation {
        Horizontal = 0,
        Vertical = 1
    }
    enum StiArrowStyle {
        None = 0,
        Triangle = 1,
        Lines = 2,
        Circle = 3,
        Arc = 4,
        ArcAndCircle = 5
    }
    enum StiLabelsPlacement {
        None = 0,
        OneLine = 1,
        TwoLines = 2,
        AutoRotation = 3
    }
    enum StiXAxisDock {
        Top = 0,
        Bottom = 1
    }
    enum StiYAxisDock {
        Left = 0,
        Right = 1
    }
    enum StiTitlePosition {
        Inside = 0,
        Outside = 1
    }
    enum StiSeriesLabelsPosition {
        None = 0,
        InsideEndAxis = 1,
        InsideBaseAxis = 2,
        CenterAxis = 3,
        OutsideEndAxis = 4,
        OutsideBaseAxis = 5,
        OutsideAxis = 6,
        Left = 7,
        Value = 8,
        Right = 9,
        InsideEndPie = 10,
        CenterPie = 11,
        OutsidePie = 12,
        TwoColumnsPie = 13,
        CenterFunnel = 14,
        OutsideRightFunnel = 15,
        OutsideLeftFunnel = 16,
        CenterHeatmap = 17,
        CenterTreemap = 18,
        CenterPie3d = 19,
        CenterPictorialStacked = 20,
        OutsideRightPictorialStacked = 21,
        OutsideLeftPictorialStacked = 22,
        InsideEndPie3d = 23
    }
    enum StiSeriesLabelsType {
        Axis = 1,
        Pie = 2,
        Doughnut = 4,
        Radar = 8,
        Funnel = 10,
        Heatmap = 11,
        Treemap = 12,
        Pie3d = 13,
        PictorialStacked = 14,
        All = 15
    }
    enum StiSeriesLabelsValueType {
        Value = 0,
        SeriesTitle = 1,
        Argument = 2,
        Tag = 3,
        Weight = 4,
        ValueArgument = 5,
        ArgumentValue = 6,
        SeriesTitleValue = 7,
        SeriesTitleArgument = 8,
        Total = 9
    }
    enum StiMarkerType {
        Rectangle = 0,
        Triangle = 1,
        Circle = 2,
        HalfCircle = 3,
        Star5 = 4,
        Star6 = 5,
        Star7 = 6,
        Star8 = 7,
        Hexagon = 8
    }
    enum StiSeriesSortType {
        Value = 0,
        Argument = 1,
        None = 2
    }
    enum StiSeriesSortDirection {
        Ascending = 0,
        Descending = 1
    }
    enum StiSeriesXAxis {
        BottomXAxis = 0,
        TopXAxis = 1
    }
    enum StiSeriesYAxis {
        LeftYAxis = 0,
        RightYAxis = 1
    }
    enum StiShowSeriesLabels {
        None = 0,
        FromChart = 1,
        FromSeries = 2
    }
    enum StiShowYAxis {
        Left = 0,
        Center = 1,
        Both = 2
    }
    enum StiShowXAxis {
        Bottom = 0,
        Center = 1,
        Both = 2
    }
    enum StiRadarStyle {
        Polygon = 0,
        Circle = 1
    }
    enum StiTimeDateStep {
        None = 0,
        Second = 1,
        Minute = 2,
        Hour = 3,
        Day = 4,
        Month = 5,
        Year = 6
    }
    enum StiTopNMode {
        None = 0,
        Top = 1,
        Bottom = 2
    }
    enum StiChartStyleId {
        StiStyle01 = 0,
        StiStyle02 = 1,
        StiStyle03 = 2,
        StiStyle04 = 3,
        StiStyle05 = 4,
        StiStyle06 = 5,
        StiStyle07 = 6,
        StiStyle08 = 7,
        StiStyle09 = 8,
        StiStyle10 = 9,
        StiStyle11 = 10,
        StiStyle12 = 11,
        StiStyle13 = 12,
        StiStyle14 = 13,
        StiStyle15 = 14,
        StiStyle16 = 15,
        StiStyle17 = 16,
        StiStyle18 = 17,
        StiStyle19 = 18,
        StiStyle20 = 19,
        StiStyle21 = 20,
        StiStyle22 = 21,
        StiStyle23 = 22,
        StiStyle24 = 23,
        StiStyle25 = 24,
        StiStyle26 = 25,
        StiStyle27 = 26,
        StiStyle28 = 27,
        StiStyle29 = 28,
        StiStyle30 = 29,
        StiStyle31 = 30,
        StiStyle32 = 31,
        StiStyle33 = 32,
        StiStyle34 = 33,
        StiStyle35 = 34,
        StiStyle36 = 35,
        StiStyle37 = 36
    }
    enum StiStrips_StiOrientation {
        Horizontal = 0,
        Vertical = 1,
        HorizontalRight = 2
    }
    enum StiConstantLines_StiOrientation {
        Horizontal = 0,
        Vertical = 1,
        HorizontalRight = 2
    }
    enum StiConstantLines_StiTextPosition {
        LeftTop = 0,
        LeftBottom = 1,
        CenterTop = 2,
        CenterBottom = 3,
        RightTop = 4,
        RightBottom = 5
    }
    enum StiTrendLine_StiTextPosition {
        LeftTop = 0,
        LeftBottom = 1,
        RightTop = 2,
        RightBottom = 3
    }
    enum StiExtendedStyleBool {
        FromStyle = 0,
        True = 1,
        False = 2
    }
    enum StiChartConditionalField {
        Value = 0,
        Argument = 1,
        Series = 2,
        EndValue = 3
    }
    enum StiShowEmptyCellsAs {
        Gap = 0,
        Zero = 1,
        ConnectPointsWithLine = 2
    }
    enum StiChartEditorType {
        Simple = 0,
        Advanced = 1
    }
    enum StiDateTimeStepAggregation {
        Average = 0,
        Sum = 1,
        Min = 2,
        Max = 3,
        Count = 4
    }
    enum StiSeriesAnimationType {
        None = 0,
        Column = 1,
        Line = 2,
        Bar = 3,
        Range = 4
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiRectangle3D: System.Interface<IStiRectangle3D>;
    interface IStiRectangle3D {
        x: number;
        y: number;
        z: number;
        length: number;
        height: number;
        width: number;
    }
}
export namespace Stimulsoft.Report.Chart {
    import PointF = Stimulsoft.System.Drawing.Point;
    let IStiRender3D: System.Interface<IStiRender3D>;
    interface IStiRender3D {
        width: number;
        height: number;
        halfWidth: number;
        halfHeight: number;
        globalRotationX: number;
        globalRotationY: number;
        globalScale: number;
        contextScale: number;
        contextTranslate: PointF;
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiChartAssembly {
        static get isAssemblyLoaded(): boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiApplyStyle: System.Interface<IStiApplyStyle>;
    interface IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiApplyStyleSeries: System.Interface<IStiApplyStyleSeries>;
    interface IStiApplyStyleSeries {
        applyStyle(style: IStiChartStyle, color: Color): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    let IStiCellGeom: System.Interface<IStiCellGeom>;
    interface IStiCellGeom {
        drawGeom(context: StiContext): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    let IStiChartCoreXF: System.Interface<IStiChartCoreXF>;
    interface IStiChartCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
        render(context: StiContext, rect: RectangleD, useMargins: boolean): IStiCellGeom;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiText = Stimulsoft.Report.Components.StiText;
    let IStiChartInfo: System.Interface<IStiChartInfo>;
    interface IStiChartInfo {
        interactiveComps: StiText[];
        storedForProcessAtEndChart: IStiChart;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiSeriesElement: System.Interface<IStiSeriesElement>;
    interface IStiSeriesElement {
        elementIndex: string;
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    let IStiSeriesInteraction: System.Interface<IStiSeriesInteraction>;
    interface IStiSeriesInteraction extends ICloneable, IStiJsonReportObject {
        drillDownEnabled: boolean;
        allowSeries: boolean;
        allowSeriesElements: boolean;
        loadFromXml(xmlNode: XmlNode): any;
        drillDownPageGuid: string;
        drillDownPage: StiPage;
    }
}
export namespace Stimulsoft.Report.Chart {
    let ISti3dOptions: System.Interface<ISti3dOptions>;
    interface ISti3dOptions {
        opacity: number;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiPie3dOptions: System.Interface<IStiPie3dOptions>;
    interface IStiPie3dOptions extends ISti3dOptions {
        lighting: StiPie3dLightingStyle;
        height: number;
        distance: number;
    }
}
export namespace Stimulsoft.Report.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiArea: System.Interface<IStiArea>;
    interface IStiArea extends ICloneable, IStiJsonReportObject, IAsIs {
        core: IStiAreaCoreXF;
        chart: IStiChart;
        allowApplyStyle: boolean;
        colorEach: boolean;
        showShadow: boolean;
        borderColor: Color;
        borderThickness: number;
        brush: StiBrush;
        isDefaultSeriesTypeFullStackedColumnSeries: boolean;
        isDefaultSeriesTypeFullStackedBarSeries: boolean;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
    }
}
export namespace Stimulsoft.Report.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    let IStiAreaCoreXF: System.Interface<IStiAreaCoreXF>;
    interface IStiAreaCoreXF extends IStiApplyStyle, IAsIs {
        isAcceptableSeries(seriesType: Stimulsoft.System.Type): boolean;
        isAcceptableSeriesLabels(seriesLabelsType: Stimulsoft.System.Type): boolean;
        render(context: StiContext, rect: RectangleD): IStiCellGeom;
        checkInLabelsTypes(typeForCheck: Stimulsoft.System.Type): boolean;
        seriesOrientation: StiChartSeriesOrientation;
        getSeries(): IStiSeries[];
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiAxisArea: System.Interface<IStiAxisArea>;
    interface IStiAxisArea extends IStiArea {
        axisCore: IStiAxisAreaCoreXF;
        interlacingHor: IStiInterlacingHor;
        interlacingVert: IStiInterlacingVert;
        gridLinesHor: IStiGridLinesHor;
        gridLinesHorRight: IStiGridLinesHor;
        gridLinesVert: IStiGridLinesVert;
        yAxis: IStiYAxis;
        yRightAxis: IStiYAxis;
        xAxis: IStiXAxis;
        xTopAxis: IStiXAxis;
        reverseHor: boolean;
        reverseVert: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiAxisAreaCoreXF: System.Interface<IStiAxisAreaCoreXF>;
    interface IStiAxisAreaCoreXF extends IStiAreaCoreXF {
        switchOff(): any;
        getDividerX(): number;
        getDividerTopX(): number;
        getDividerY(): number;
        getDividerRightY(): number;
        valuesCount: number;
        scrollRangeX: number;
        scrollRangeY: number;
        scrollDpiX: number;
        scrollDpiY: number;
        getArgumentLabel(line: IStiStripLineXF, series: IStiSeries): string;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiRoundValuesArea: System.Interface<IStiRoundValuesArea>;
    interface IStiRoundValuesArea {
        roundValues: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiBoxAndWhiskerArea: System.Interface<IStiBoxAndWhiskerArea>;
    interface IStiBoxAndWhiskerArea extends IStiAxisArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiBubbleArea: System.Interface<IStiBubbleArea>;
    interface IStiBubbleArea extends IStiScatterArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiCandlestickArea: System.Interface<IStiCandlestickArea>;
    interface IStiCandlestickArea extends IStiClusteredColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiClusteredBarArea: System.Interface<IStiClusteredBarArea>;
    interface IStiClusteredBarArea extends IStiClusteredColumnArea, IStiRoundValuesArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiAreaArea: System.Interface<IStiAreaArea>;
    interface IStiAreaArea extends IStiClusteredColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiClusteredColumnArea: System.Interface<IStiClusteredColumnArea>;
    interface IStiClusteredColumnArea extends IStiAxisArea, IStiRoundValuesArea {
        sideBySide: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiLineArea: System.Interface<IStiLineArea>;
    interface IStiLineArea extends IStiClusteredColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiParetoArea: System.Interface<IStiParetoArea>;
    interface IStiParetoArea extends IStiClusteredColumnArea, IStiRoundValuesArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiSplineArea: System.Interface<IStiSplineArea>;
    interface IStiSplineArea extends IStiClusteredColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiSplineAreaArea: System.Interface<IStiSplineAreaArea>;
    interface IStiSplineAreaArea extends IStiClusteredColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiSteppedAreaArea: System.Interface<IStiSteppedAreaArea>;
    interface IStiSteppedAreaArea extends IStiClusteredColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiSteppedLineArea: System.Interface<IStiSteppedLineArea>;
    interface IStiSteppedLineArea extends IStiClusteredColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiWaterfallArea: System.Interface<IStiWaterfallArea>;
    interface IStiWaterfallArea extends IStiAxisArea, IStiRoundValuesArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiDoughnutArea: System.Interface<IStiDoughnutArea>;
    interface IStiDoughnutArea extends IStiPieArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiFullStackedBarArea: System.Interface<IStiFullStackedBarArea>;
    interface IStiFullStackedBarArea extends IStiStackedBarArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiFullStackedAreaArea: System.Interface<IStiFullStackedAreaArea>;
    interface IStiFullStackedAreaArea extends IStiFullStackedColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiFullStackedColumnArea: System.Interface<IStiFullStackedColumnArea>;
    interface IStiFullStackedColumnArea extends IStiStackedColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiFullStackedLineArea: System.Interface<IStiFullStackedLineArea>;
    interface IStiFullStackedLineArea extends IStiFullStackedColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiFullStackedSplineArea: System.Interface<IStiFullStackedSplineArea>;
    interface IStiFullStackedSplineArea extends IStiFullStackedColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiFullStackedSplineAreaArea: System.Interface<IStiFullStackedSplineAreaArea>;
    interface IStiFullStackedSplineAreaArea extends IStiFullStackedColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiFunnelArea: System.Interface<IStiFunnelArea>;
    interface IStiFunnelArea extends IStiArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiGanttArea: System.Interface<IStiGanttArea>;
    interface IStiGanttArea extends IStiClusteredBarArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiHeatmapArea: System.Interface<IStiHeatmapArea>;
    interface IStiHeatmapArea extends IStiAxisArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiPictorialArea: System.Interface<IStiPictorialArea>;
    interface IStiPictorialArea extends IStiArea, IStiRoundValuesArea {
        actual: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiPieArea: System.Interface<IStiPieArea>;
    interface IStiPieArea extends IStiArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiRadarArea: System.Interface<IStiRadarArea>;
    interface IStiRadarArea extends IStiArea {
        radarStyle: StiRadarStyle;
        xAxis: IStiXRadarAxis;
        yAxis: IStiYRadarAxis;
        interlacingHor: IStiInterlacingHor;
        interlacingVert: IStiInterlacingVert;
        gridLinesHor: IStiRadarGridLinesHor;
        gridLinesVert: IStiRadarGridLinesVert;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiRadarAreaArea: System.Interface<IStiRadarAreaArea>;
    interface IStiRadarAreaArea extends IStiRadarArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiRadarLineArea: System.Interface<IStiRadarLineArea>;
    interface IStiRadarLineArea extends IStiRadarArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiRadarPointArea: System.Interface<IStiRadarPointArea>;
    interface IStiRadarPointArea extends IStiRadarArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiRangeArea: System.Interface<IStiRangeArea>;
    interface IStiRangeArea extends IStiClusteredColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiRangeBarArea: System.Interface<IStiRangeBarArea>;
    interface IStiRangeBarArea extends IStiClusteredColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiSplineRangeArea: System.Interface<IStiSplineRangeArea>;
    interface IStiSplineRangeArea extends IStiClusteredColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiSteppedRangeArea: System.Interface<IStiSteppedRangeArea>;
    interface IStiSteppedRangeArea extends IStiClusteredColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiScatterArea: System.Interface<IStiScatterArea>;
    interface IStiScatterArea extends IStiClusteredColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiStackedBarArea: System.Interface<IStiStackedBarArea>;
    interface IStiStackedBarArea extends IStiClusteredBarArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiRibbonArea: System.Interface<IStiRibbonArea>;
    interface IStiRibbonArea extends IStiAxisArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiStackedAreaArea: System.Interface<IStiStackedAreaArea>;
    interface IStiStackedAreaArea extends IStiStackedColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiStackedColumnArea: System.Interface<IStiStackedColumnArea>;
    interface IStiStackedColumnArea extends IStiAxisArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiStackedLineArea: System.Interface<IStiStackedLineArea>;
    interface IStiStackedLineArea extends IStiStackedColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiStackedSplineArea: System.Interface<IStiStackedSplineArea>;
    interface IStiStackedSplineArea extends IStiStackedColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiStackedSplineAreaArea: System.Interface<IStiStackedSplineAreaArea>;
    interface IStiStackedSplineAreaArea extends IStiStackedColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiStockArea: System.Interface<IStiStockArea>;
    interface IStiStockArea extends IStiClusteredColumnArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiSunburstArea: System.Interface<IStiSunburstArea>;
    interface IStiSunburstArea extends IStiArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiTreemapArea: System.Interface<IStiTreemapArea>;
    interface IStiTreemapArea extends IStiArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IAsIs = Stimulsoft.System.IAsIs;
    let IStiAxis: System.Interface<IStiAxis>;
    interface IStiAxis extends ICloneable, IStiJsonReportObject, IAsIs {
        logarithmicScale: boolean;
        core: IStiAxisCoreXF;
        allowApplyStyle: boolean;
        startFromZero: boolean;
        step: number;
        interaction: IStiAxisInteraction;
        labels: IStiAxisLabels;
        range: IStiAxisRange;
        title: IStiAxisTitle;
        ticks: IStiAxisTicks;
        arrowStyle: StiArrowStyle;
        lineStyle: StiPenStyle;
        lineColor: Color;
        lineWidth: number;
        visible: boolean;
        area: IStiAxisArea;
        info: IStiAxisInfoXF;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    let IStiAxisCoreXF: System.Interface<IStiAxisCoreXF>;
    interface IStiAxisCoreXF extends IStiApplyStyle {
        arrowHeight: number;
        arrowWidth: number;
        ticksMaxLength: number;
        renderView(context: StiContext, rect: RectangleD): IStiCellGeom;
        render(context: StiContext, rect: RectangleD): IStiCellGeom;
        applyStyle(style: IStiChartStyle): any;
        getStartFromZero(): boolean;
        calculateStripPositions(topPosition: number, bottomPosition: number): any;
        getFontGeom(context: StiContext): StiFontGeom;
        getStringFormatGeom(context: StiContext, wordWrap: boolean): StiStringFormatGeom;
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiAxisDateTimeStep: System.Interface<IStiAxisDateTimeStep>;
    interface IStiAxisDateTimeStep extends ICloneable, IStiJsonReportObject {
        step: StiTimeDateStep;
        numberOfValues: number;
        interpolation: boolean;
        aggregation: StiDateTimeStepAggregation;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    let IStiAxisInfoXF: System.Interface<IStiAxisInfoXF>;
    interface IStiAxisInfoXF extends ICloneable {
        minimum: number;
        maximum: number;
        stripLines: IStiStripLinesXF;
        stripPositions: number[];
        dpi: number;
        ticksCollection: IStiStripPositionXF[];
        labelsCollection: IStiStripPositionXF[];
        step: number;
        range: number;
        clone(): IStiAxisInfoXF;
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiAxisInteraction: System.Interface<IStiAxisInteraction>;
    interface IStiAxisInteraction extends ICloneable, IStiJsonReportObject {
        showScrollBar: boolean;
        rangeScrollEnabled: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiAxisLabels: System.Interface<IStiAxisLabels>;
    interface IStiAxisLabels extends ICloneable, IStiJsonReportObject {
        core: IStiAxisLabelsCoreXF;
        allowApplyStyle: boolean;
        format: string;
        angle: number;
        width: number;
        textBefore: string;
        textAfter: string;
        font: Font;
        antialiasing: boolean;
        placement: StiLabelsPlacement;
        color: Color;
        textAlignment: StiHorAlignment;
        step: number;
        calculatedStep: number;
        wordWrap: boolean;
        formatService: StiFormatService;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiAxisLabelsCoreXF: System.Interface<IStiAxisLabelsCoreXF>;
    interface IStiAxisLabelsCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiAxisRange: System.Interface<IStiAxisRange>;
    interface IStiAxisRange extends ICloneable, IStiJsonReportObject {
        minimum: number;
        maximum: number;
        auto: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiAxisTicks: System.Interface<IStiAxisTicks>;
    interface IStiAxisTicks extends ICloneable, IStiJsonReportObject {
        lengthUnderLabels: number;
        length: number;
        minorLength: number;
        minorCount: number;
        step: number;
        minorVisible: boolean;
        visible: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiAxisTitle: System.Interface<IStiAxisTitle>;
    interface IStiAxisTitle extends ICloneable, IStiJsonReportObject {
        core: IStiAxisTitleCoreXF;
        allowApplyStyle: boolean;
        font: Font;
        text: string;
        color: Color;
        antialiasing: boolean;
        alignment: StringAlignment;
        direction: StiDirection;
        position: StiTitlePosition;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiAxisTitleCoreXF: System.Interface<IStiAxisTitleCoreXF>;
    interface IStiAxisTitleCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    let IStiXAxis: System.Interface<IStiXAxis>;
    interface IStiXAxis extends IStiAxis {
        showEdgeValues: boolean;
        showXAxis: StiShowXAxis;
        dateTimeStep: IStiAxisDateTimeStep;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiXBottomAxis: System.Interface<IStiXBottomAxis>;
    interface IStiXBottomAxis extends IStiXAxis {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiXTopAxis: System.Interface<IStiXTopAxis>;
    interface IStiXTopAxis extends IStiXAxis {
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    let IStiYAxis: System.Interface<IStiYAxis>;
    interface IStiYAxis extends IStiAxis {
        showYAxis: StiShowYAxis;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiYLeftAxis: System.Interface<IStiYLeftAxis>;
    interface IStiYLeftAxis extends IStiYAxis {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiYRightAxis: System.Interface<IStiYRightAxis>;
    interface IStiYRightAxis extends IStiYAxis {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiStripLineXF: System.Interface<IStiStripLineXF>;
    interface IStiStripLineXF {
        valueObject: any;
        value: number;
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    let IStiStripLinesXF: System.Interface<IStiStripLinesXF>;
    interface IStiStripLinesXF extends ICollection<IStiStripLineXF> {
        add2(valueObject: any, value: number): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiStripPositionXF: System.Interface<IStiStripPositionXF>;
    interface IStiStripPositionXF {
        stripLine: IStiStripLineXF;
        position: number;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiChartTitle: System.Interface<IStiChartTitle>;
    interface IStiChartTitle extends ICloneable, IStiJsonReportObject {
        core: IStiChartTitleCoreXF;
        allowApplyStyle: boolean;
        font: Font;
        text: string;
        brush: StiBrush;
        antialiasing: boolean;
        alignment: StringAlignment;
        dock: StiChartTitleDock;
        spacing: number;
        visible: boolean;
        chart: IStiChart;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    let IStiChartTitleCoreXF: System.Interface<IStiChartTitleCoreXF>;
    interface IStiChartTitleCoreXF extends IStiApplyStyle {
        render(context: StiContext, chartTitle: IStiChartTitle, rect: RectangleD): IStiCellGeom;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiChartCondition: System.Interface<IStiChartCondition>;
    interface IStiChartCondition extends IStiChartFilter {
        color: Color;
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    let IStiChartConditionsCollection: System.Interface<IStiChartConditionsCollection>;
    interface IStiChartConditionsCollection extends ICollection<IStiChartCondition> {
        add(condition: IStiChartCondition): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiConstantLines: System.Interface<IStiConstantLines>;
    interface IStiConstantLines extends ICloneable, IStiJsonReportObject {
        core: IStiConstantLinesCoreXF;
        allowApplyStyle: boolean;
        antialiasing: boolean;
        position: StiConstantLines_StiTextPosition;
        font: Font;
        text: string;
        titleVisible: boolean;
        orientation: StiConstantLines_StiOrientation;
        lineWidth: number;
        lineStyle: StiPenStyle;
        lineColor: Color;
        showInLegend: boolean;
        showBehind: boolean;
        axisValue: string;
        visible: boolean;
        chart: IStiChart;
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    let IStiConstantLinesCollection: System.Interface<IStiConstantLinesCollection>;
    interface IStiConstantLinesCollection extends ICollection<IStiConstantLines>, IStiApplyStyle {
        add(value: IStiConstantLines): any;
        insert(index: number, value: IStiConstantLines): any;
        getByIndex(index: number): IStiConstantLines;
        applyStyle(style: IStiChartStyle): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    let IStiConstantLinesCoreXF: System.Interface<IStiConstantLinesCoreXF>;
    interface IStiConstantLinesCoreXF extends IStiApplyStyle {
        render(context: StiContext, geom: IStiCellGeom, rect: RectangleD): any;
        applyStyle(style: IStiChartStyle): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    import StiFilterItem = Stimulsoft.Report.Components.StiFilterItem;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    let IStiChartFilter: System.Interface<IStiChartFilter>;
    interface IStiChartFilter extends IStiJsonReportObject, ICloneable {
        clone(): any;
        condition: StiFilterCondition;
        dataType: StiFilterDataType;
        item: StiFilterItem;
        value: string;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    let IStiChartFiltersCollection: System.Interface<IStiChartFiltersCollection>;
    interface IStiChartFiltersCollection extends ICollection<IStiChartFilter> {
        add(value: IStiChartFilter): any;
        getByIndex(index: number): IStiChartFilter;
        insert(index: number, value: IStiChartFilter): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiGridLines: System.Interface<IStiGridLines>;
    interface IStiGridLines extends ICloneable, IStiJsonReportObject {
        core: IStiGridLinesCoreXF;
        allowApplyStyle: boolean;
        color: Color;
        minorColor: Color;
        style: StiPenStyle;
        minorStyle: StiPenStyle;
        visible: boolean;
        minorVisible: boolean;
        minorCount: number;
        area: IStiArea;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiGridLinesCoreXF: System.Interface<IStiGridLinesCoreXF>;
    interface IStiGridLinesCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiGridLinesHor: System.Interface<IStiGridLinesHor>;
    interface IStiGridLinesHor extends IStiGridLines {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiGridLinesVert: System.Interface<IStiGridLinesVert>;
    interface IStiGridLinesVert extends IStiGridLines {
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiRadarGridLines: System.Interface<IStiRadarGridLines>;
    interface IStiRadarGridLines extends ICloneable, IStiJsonReportObject {
        core: IStiRadarGridLinesCoreXF;
        allowApplyStyle: boolean;
        color: Color;
        style: StiPenStyle;
        visible: boolean;
        area: IStiArea;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiRadarGridLinesCoreXF: System.Interface<IStiRadarGridLinesCoreXF>;
    interface IStiRadarGridLinesCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiRadarGridLinesHor: System.Interface<IStiRadarGridLinesHor>;
    interface IStiRadarGridLinesHor extends IStiRadarGridLines {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiRadarGridLinesVert: System.Interface<IStiRadarGridLinesVert>;
    interface IStiRadarGridLinesVert extends IStiRadarGridLines {
    }
}
export namespace Stimulsoft.Report.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiInterlacing: System.Interface<IStiInterlacing>;
    interface IStiInterlacing extends ICloneable, IStiJsonReportObject, IAsIs {
        core: IStiInterlacingCoreXF;
        allowApplyStyle: boolean;
        interlacedBrush: StiBrush;
        visible: boolean;
        area: IStiArea;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiInterlacingCoreXF: System.Interface<IStiInterlacingCoreXF>;
    interface IStiInterlacingCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiInterlacingHor: System.Interface<IStiInterlacingHor>;
    interface IStiInterlacingHor extends IStiInterlacing {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiInterlacingVert: System.Interface<IStiInterlacingVert>;
    interface IStiInterlacingVert extends IStiInterlacing {
    }
}
export namespace Stimulsoft.Report.Chart {
    import SizeD = Stimulsoft.System.Drawing.Size;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiLegend: System.Interface<IStiLegend>;
    interface IStiLegend extends ICloneable, IStiJsonReportObject {
        core: IStiLegendCoreXF;
        allowApplyStyle: boolean;
        chart: IStiChart;
        hideSeriesWithEmptyTitle: boolean;
        showShadow: boolean;
        borderColor: Color;
        brush: StiBrush;
        titleColor: Color;
        labelsColor: Color;
        direction: StiLegendDirection;
        horAlignment: StiLegendHorAlignment;
        vertAlignment: StiLegendVertAlignment;
        titleFont: Font;
        font: Font;
        visible: boolean;
        markerVisible: boolean;
        markerBorder: boolean;
        markerSize: SizeD;
        markerAlignment: StiMarkerAlignment;
        columns: number;
        horSpacing: number;
        vertSpacing: number;
        size: SizeD;
        title: string;
        columnWidth: number;
        wordWrap: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    let IStiLegendCoreXF: System.Interface<IStiLegendCoreXF>;
    interface IStiLegendCoreXF extends IStiApplyStyle {
        render(context: StiContext, rect: RectangleD): IStiCellGeom;
        isAcceptableSeries(type: Stimulsoft.System.Type): boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    let IStiLegendMarker: System.Interface<IStiLegendMarker>;
    interface IStiLegendMarker {
        draw(context: StiContext, series: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiLineMarker: System.Interface<IStiLineMarker>;
    interface IStiLineMarker extends IStiMarker {
        step: number;
    }
}
export namespace Stimulsoft.Report.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiMarker: System.Interface<IStiMarker>;
    interface IStiMarker extends IStiFontIconsSeries, ICloneable, IStiJsonReportObject, IAsIs {
        core: IStiMarkerCoreXF;
        showInLegend: boolean;
        visible: boolean;
        brush: StiBrush;
        borderColor: Color;
        size: number;
        angle: number;
        type: StiMarkerType;
        icon: StiFontIcons;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    let IStiMarkerCoreXF: System.Interface<IStiMarkerCoreXF>;
    interface IStiMarkerCoreXF {
        draw(context: StiContext, marker: IStiMarker, position: PointD, zoom: number, showShadow: boolean, isMouseOver: boolean, isTooltipMode: boolean, isAnimation: boolean, toolTip: string, tag: any, interaction: StiInteractionDataGeom): any;
        drawLine(context: StiContext, x1: number, y1: number, x2: number, y2: number, scale: number, brushMarker: StiBrush, penMarker: StiPenGeom, markerType: StiMarkerType, markerStep: number, markerSize: number, angle: number): any;
        drawLines(context: StiContext, points: PointD[], scale: number, brushMarker: any, penMarker: StiPenGeom, markerType: StiMarkerType, markerStep: number, markerSize: number, angle: number): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiRadarAxis: System.Interface<IStiRadarAxis>;
    interface IStiRadarAxis extends ICloneable, IStiJsonReportObject {
        core: IStiRadarAxisCoreXF;
        allowApplyStyle: boolean;
        area: IStiRadarArea;
        visible: boolean;
        range: IStiAxisRange;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiRadarAxisCoreXF: System.Interface<IStiRadarAxisCoreXF>;
    interface IStiRadarAxisCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiRadarAxisLabels: System.Interface<IStiRadarAxisLabels>;
    interface IStiRadarAxisLabels extends ICloneable, IStiJsonReportObject {
        core: IStiRadarAxisLabelsCoreXF;
        rotationLabels: boolean;
        allowApplyStyle: boolean;
        drawBorder: boolean;
        textBefore: string;
        textAfter: string;
        format: string;
        font: Font;
        antialiasing: boolean;
        color: Color;
        borderColor: Color;
        brush: StiBrush;
        width: number;
        wordWrap: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiRadarAxisLabelsCoreXF: System.Interface<IStiRadarAxisLabelsCoreXF>;
    interface IStiRadarAxisLabelsCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiXRadarAxis: System.Interface<IStiXRadarAxis>;
    interface IStiXRadarAxis extends IStiRadarAxis {
        xCore: IStiXRadarAxisCoreXF;
        labels: IStiRadarAxisLabels;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    let IStiXRadarAxisCoreXF: System.Interface<IStiXRadarAxisCoreXF>;
    interface IStiXRadarAxisCoreXF {
        renderLabel(context: StiContext, series: IStiSeries, point: PointD, argument: any, angle: number, colorIndex: number, colorCount: number): IStiCellGeom;
        getLabelRect(context: StiContext, point: PointD, text: string, angle: number): RectangleD;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiYRadarAxis: System.Interface<IStiYRadarAxis>;
    interface IStiYRadarAxis extends IStiRadarAxis {
        yCore: IStiYRadarAxisCoreXF;
        labels: IStiAxisLabels;
        ticks: IStiAxisTicks;
        lineStyle: StiPenStyle;
        lineColor: Color;
        lineWidth: number;
        info: IStiAxisInfoXF;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    let IStiYRadarAxisCoreXF: System.Interface<IStiYRadarAxisCoreXF>;
    interface IStiYRadarAxisCoreXF {
        render(context: StiContext, rect: RectangleD): IStiCellGeom;
        ticksMaxLength: number;
        getFontGeom(context: StiContext): StiFontGeom;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        calculateStripPositions(topPosition: number, bottomPosition: number): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiAllowApplyBorderColor: System.Interface<IStiAllowApplyBorderColor>;
    interface IStiAllowApplyBorderColor {
        allowApplyBorderColor: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiAllowApplyBrush: System.Interface<IStiAllowApplyBrush>;
    interface IStiAllowApplyBrush {
        allowApplyBrush: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiAllowApplyBrushNegative: System.Interface<IStiAllowApplyBrushNegative>;
    interface IStiAllowApplyBrushNegative {
        allowApplyBrushNegative: boolean;
        brushNegative: StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiAllowApplyColorNegative: System.Interface<IStiAllowApplyColorNegative>;
    interface IStiAllowApplyColorNegative {
        allowApplyColorNegative: boolean;
        lineColorNegative: Color;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    let IStiFontIconsSeries: System.Interface<IStiFontIconsSeries>;
    interface IStiFontIconsSeries {
        icon: StiFontIcons;
    }
}
export namespace Stimulsoft.Report.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import IStiTrendLinesCollection = Stimulsoft.Report.Chart.IStiTrendLinesCollection;
    let IStiSeries: System.Interface<IStiSeries>;
    interface IStiSeries extends ICloneable, IStiJsonReportObject, IAsIs {
        core: IStiSeriesCoreXF;
        allowApplyStyle: boolean;
        format: string;
        coreTitle: string;
        titleValue: string;
        sortBy: StiSeriesSortType;
        sortDirection: StiSeriesSortDirection;
        showInLegend: boolean;
        showSeriesLabels: StiShowSeriesLabels;
        showShadow: boolean;
        filters: IStiChartFiltersCollection;
        topN: IStiSeriesTopN;
        conditions: IStiChartConditionsCollection;
        yAxis: StiSeriesYAxis;
        seriesLabels: IStiSeriesLabels;
        chart: IStiChart;
        valuesStart: number[];
        values: number[];
        arguments: any[];
        originalArguments: any[];
        originalTopNValues: any[];
        toolTips: string[];
        tags: any[];
        hyperlinks: string[];
        interaction: IStiSeriesInteraction;
        argumentDataColumn: string;
        argument: string;
        title: string;
        filterMode: StiFilterMode;
        trendLines: IStiTrendLinesCollection;
        trendLine: IStiTrendLine;
        isTotalLabel: boolean;
        drillDownEnabled: boolean;
        isDashboard: boolean;
        legendColor: Color;
        value: string;
        valueDataColumn: string;
        listOfValues: string;
        listOfArguments: string;
        processSeriesColors(pointIndex: number, seriesColor: Color): Color;
        processSeriesBrushes(pointIndex: number, seriesBrush: StiBrush): StiBrush;
        processSeriesMarkerType(pointIndex: number, markerType: StiMarkerType): StiMarkerType;
        processSeriesMarkerAngle(pointIndex: number, markerAngle: number): number;
        processSeriesMarkerVisible(pointIndex: number): boolean;
        getDefaultAreaType(): Stimulsoft.System.Type;
        getDefaultLegendType(): Stimulsoft.System.Type;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiSeriesBorderThickness: System.Interface<IStiSeriesBorderThickness>;
    interface IStiSeriesBorderThickness {
        borderThickness: number;
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    import List = Stimulsoft.System.Collections.List;
    let IStiSeriesCollection: System.Interface<IStiSeriesCollection>;
    interface IStiSeriesCollection extends ICollection<IStiSeries>, IStiApplyStyle {
        add(value: IStiSeries): any;
        getByIndex(index: number): IStiSeries;
        insert(index: number, value: IStiSeries): any;
        indexOf(value: IStiSeries): number;
        toList(): List<IStiSeries>;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiSeriesCoreXF: System.Interface<IStiSeriesCoreXF>;
    interface IStiSeriesCoreXF {
        renderSeries(context: StiContext, rect: RectangleD, geom: IStiCellGeom, seriesArray: IStiSeries[]): any;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        getSeriesLabels(): IStiAxisSeriesLabels;
        isDateTimeValues: boolean;
        applyStyle(style: IStiChartStyle, color: Color): any;
        getTag(tagIndex: number): string;
        interaction: IStiSeriesInteraction;
        seriesColors: Color[];
        isDateTimeArguments: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiShowNullsSeries: System.Interface<IStiShowNullsSeries>;
    interface IStiShowNullsSeries {
        showNulls: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiShowEmptyCellsAs = Stimulsoft.Report.Chart.StiShowEmptyCellsAs;
    let IStiShowNullsSeriesAs: System.Interface<IStiShowNullsSeriesAs>;
    interface IStiShowNullsSeriesAs {
        showNullsAs: StiShowEmptyCellsAs;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiShowZerosSeries: System.Interface<IStiShowZerosSeries>;
    interface IStiShowZerosSeries {
        showZeros: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiShowEmptyCellsAs = Stimulsoft.Report.Chart.StiShowEmptyCellsAs;
    let IStiShowZerosSeriesAs: System.Interface<IStiShowZerosSeriesAs>;
    interface IStiShowZerosSeriesAs {
        showZerosAs: StiShowEmptyCellsAs;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiBoxAndWhiskerSeries: System.Interface<IStiBoxAndWhiskerSeries>;
    interface IStiBoxAndWhiskerSeries extends IStiSeries, IStiAllowApplyBrush, IStiSeriesBorderThickness {
        brush: StiBrush;
        showMeanMarkers: boolean;
        showInnerPoints: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiBubbleSeries: System.Interface<IStiBubbleSeries>;
    interface IStiBubbleSeries extends IStiScatterSeries, IStiSeriesBorderThickness {
        weights: number[];
        borderColor: Color;
        brush: StiBrush;
        bubbleScale: number;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiClusteredBarSeries: System.Interface<IStiClusteredBarSeries>;
    interface IStiClusteredBarSeries extends IStiClusteredColumnSeries {
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiAreaSeries: System.Interface<IStiAreaSeries>;
    interface IStiAreaSeries extends IStiLineSeries, IStiAllowApplyBrushNegative {
        topmostLine: boolean;
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiBaseLineSeries: System.Interface<IStiBaseLineSeries>;
    interface IStiBaseLineSeries extends IStiSeries, IStiAllowApplyColorNegative, IStiShowNullsSeries, IStiShowZerosSeries, IStiShowNullsSeriesAs, IStiShowZerosSeriesAs {
        marker: IStiMarker;
        lineMarker: IStiLineMarker;
        lineColor: Color;
        lineStyle: StiPenStyle;
        lighting: boolean;
        lineWidth: number;
        labelsOffset: number;
        lineColorNegative: Color;
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiClusteredColumnSeries: System.Interface<IStiClusteredColumnSeries>;
    interface IStiClusteredColumnSeries extends IStiSeries, IStiFontIconsSeries, IStiAllowApplyBrushNegative, IStiSeriesBorderThickness, IStiCornerRadius, IStiShowZerosSeries {
        width: number;
        borderColor: Color;
        brush: StiBrush;
        brushNegative: StiBrush;
        showZeros: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiHistogramSeries: System.Interface<IStiHistogramSeries>;
    interface IStiHistogramSeries extends IStiClusteredColumnSeries {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiLineSeries: System.Interface<IStiLineSeries>;
    interface IStiLineSeries extends IStiBaseLineSeries {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiParetoSeries: System.Interface<IStiParetoSeries>;
    interface IStiParetoSeries extends IStiClusteredColumnSeries, IStiBaseLineSeries {
        allowApplyLineColor: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiSplineAreaSeries: System.Interface<IStiSplineAreaSeries>;
    interface IStiSplineAreaSeries extends IStiSplineSeries, IStiAllowApplyBrushNegative {
        topmostLine: boolean;
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiSplineSeries: System.Interface<IStiSplineSeries>;
    interface IStiSplineSeries extends IStiBaseLineSeries, IStiAllowApplyColorNegative {
        tension: number;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiSteppedAreaSeries: System.Interface<IStiSteppedAreaSeries>;
    interface IStiSteppedAreaSeries extends IStiSteppedLineSeries, IStiAllowApplyBrushNegative {
        topmostLine: boolean;
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiSteppedLineSeries: System.Interface<IStiSteppedLineSeries>;
    interface IStiSteppedLineSeries extends IStiBaseLineSeries, IStiAllowApplyColorNegative {
        pointAtCenter: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiWaterfallSeries: System.Interface<IStiWaterfallSeries>;
    interface IStiWaterfallSeries extends IStiClusteredColumnSeries {
        connectorLine: IStiWaterfallConnectorLine;
        total: IStiWaterfallTotal;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiDoughnutSeries: System.Interface<IStiDoughnutSeries>;
    interface IStiDoughnutSeries extends IStiPieSeries {
        width: number;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiCandlestickSeries: System.Interface<IStiCandlestickSeries>;
    interface IStiCandlestickSeries extends IStiSeries, IStiFinancialSeries {
        borderColor: Color;
        borderColorNegative: Color;
        borderWidth: number;
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiFinancialSeries: System.Interface<IStiFinancialSeries>;
    interface IStiFinancialSeries {
        valuesOpen: number[];
        valuesClose: number[];
        valuesHigh: number[];
        valuesLow: number[];
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiStockSeries: System.Interface<IStiStockSeries>;
    interface IStiStockSeries extends IStiSeries, IStiFinancialSeries, IStiAllowApplyColorNegative {
        lineColor: Color;
        lineStyle: StiPenStyle;
        lineWidth: number;
        lineColorNegative: Color;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiFullStackedBarSeries: System.Interface<IStiFullStackedBarSeries>;
    interface IStiFullStackedBarSeries extends IStiStackedBarSeries {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiFullStackedAreaSeries: System.Interface<IStiFullStackedAreaSeries>;
    interface IStiFullStackedAreaSeries extends IStiStackedAreaSeries, IStiShowNullsSeries {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiFullStackedColumnSeries: System.Interface<IStiFullStackedColumnSeries>;
    interface IStiFullStackedColumnSeries extends IStiStackedColumnSeries {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiFullStackedLineSeries: System.Interface<IStiFullStackedLineSeries>;
    interface IStiFullStackedLineSeries extends IStiStackedLineSeries {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiFullStackedSplineAreaSeries: System.Interface<IStiFullStackedSplineAreaSeries>;
    interface IStiFullStackedSplineAreaSeries extends IStiStackedSplineAreaSeries, IStiShowNullsSeries {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiFullStackedSplineSeries: System.Interface<IStiFullStackedSplineSeries>;
    interface IStiFullStackedSplineSeries extends IStiStackedSplineSeries {
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiFunnelSeries: System.Interface<IStiFunnelSeries>;
    interface IStiFunnelSeries extends IStiSeries, IStiFontIconsSeries, IStiSeriesBorderThickness, IStiShowZerosSeries {
        showZeros: boolean;
        allowApplyBrush: boolean;
        allowApplyBorderColor: boolean;
        borderColor: Color;
        brush: StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiFunnelWeightedSlicesSeries: System.Interface<IStiFunnelWeightedSlicesSeries>;
    interface IStiFunnelWeightedSlicesSeries extends IStiFunnelSeries {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiGanttSeries: System.Interface<IStiGanttSeries>;
    interface IStiGanttSeries extends IStiClusteredBarSeries, IStiRangeSeries {
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiHeatmapSeries: System.Interface<IStiHeatmapSeries>;
    interface IStiHeatmapSeries extends IStiSeries, IStiSeriesBorderThickness {
        borderColor: Color;
        xValues: any[];
        yValues: any[];
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiPictorialSeries: System.Interface<IStiPictorialSeries>;
    interface IStiPictorialSeries extends IStiSeries, IStiFontIconsSeries {
        brush: StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiPictorialStackedSeries: System.Interface<IStiPictorialStackedSeries>;
    interface IStiPictorialStackedSeries extends IStiSeries, IStiFontIconsSeries {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiPie3dSeries: System.Interface<IStiPie3dSeries>;
    interface IStiPie3dSeries extends IStiPieSeries {
        options3D: IStiPie3dOptions;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiPieSeries: System.Interface<IStiPieSeries>;
    interface IStiPieSeries extends IStiSeries, IStiFontIconsSeries, IStiAllowApplyBorderColor, IStiSeriesBorderThickness, IStiAllowApplyBrush, IStiShowZerosSeries {
        startAngle: number;
        borderColor: Color;
        brush: StiBrush;
        lighting: boolean;
        diameter: number;
        distance: number;
        cutPieListValues: number[];
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiRadarAreaSeries: System.Interface<IStiRadarAreaSeries>;
    interface IStiRadarAreaSeries extends IStiRadarLineSeries {
        brush: StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiRadarLineSeries: System.Interface<IStiRadarLineSeries>;
    interface IStiRadarLineSeries extends IStiRadarSeries {
        lineColor: Color;
        lineStyle: StiPenStyle;
        lighting: boolean;
        lineWidth: number;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiRadarPointSeries: System.Interface<IStiRadarPointSeries>;
    interface IStiRadarPointSeries extends IStiRadarSeries {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiRadarSeries: System.Interface<IStiRadarSeries>;
    interface IStiRadarSeries extends IStiSeries, IStiShowNullsSeries {
        marker: IStiMarker;
        showNulls: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiLineRangeSeries: System.Interface<IStiLineRangeSeries>;
    interface IStiLineRangeSeries extends IStiLineSeries, IStiRangeSeries, IStiAllowApplyBrushNegative {
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiRangeBarSeries: System.Interface<IStiRangeBarSeries>;
    interface IStiRangeBarSeries extends IStiClusteredColumnSeries, IStiRangeSeries {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiRangeSeries: System.Interface<IStiRangeSeries>;
    interface IStiRangeSeries {
        valuesEnd: number[];
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiSplineRangeSeries: System.Interface<IStiSplineRangeSeries>;
    interface IStiSplineRangeSeries extends IStiSplineSeries, IStiRangeSeries {
        brush: StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiSteppedRangeSeries: System.Interface<IStiSteppedRangeSeries>;
    interface IStiSteppedRangeSeries extends IStiSteppedLineSeries, IStiRangeSeries, IStiAllowApplyBrushNegative {
        brush: StiBrush;
        brushNegative: StiBrush;
        allowApplyBrushNegative: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiScatterLineSeries: System.Interface<IStiScatterLineSeries>;
    interface IStiScatterLineSeries extends IStiScatterSeries {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiScatterSeries: System.Interface<IStiScatterSeries>;
    interface IStiScatterSeries extends IStiBaseLineSeries {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiScatterSplineSeries: System.Interface<IStiScatterSplineSeries>;
    interface IStiScatterSplineSeries extends IStiScatterLineSeries {
        tension: number;
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiStackedBarSeries: System.Interface<IStiStackedBarSeries>;
    interface IStiStackedBarSeries extends IStiSeries, IStiFontIconsSeries, IStiSeriesBorderThickness, IStiAllowApplyBrushNegative, IStiShowZerosSeries, IStiCornerRadius {
        width: number;
        borderColor: Color;
        brush: StiBrush;
        showZeros: boolean;
        brushNegative: StiBrush;
        allowApplyBrushNegative: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    let IStiRibbonSeries: System.Interface<IStiRibbonSeries>;
    interface IStiRibbonSeries extends IStiSeries, IStiSeriesBorderThickness, IStiCornerRadius {
        width: number;
        borderColor: Color;
        brush: StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiStackedAreaSeries: System.Interface<IStiStackedAreaSeries>;
    interface IStiStackedAreaSeries extends IStiStackedLineSeries, IStiAllowApplyBrushNegative {
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiStackedBaseLineSeries: System.Interface<IStiStackedBaseLineSeries>;
    interface IStiStackedBaseLineSeries extends IStiSeries, IStiShowNullsSeries {
        marker: IStiMarker;
        lineMarker: IStiLineMarker;
        lighting: boolean;
        lineColor: Color;
        lineWidth: number;
        lineStyle: StiPenStyle;
        showNulls: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiStackedColumnSeries: System.Interface<IStiStackedColumnSeries>;
    interface IStiStackedColumnSeries extends IStiSeries, IStiFontIconsSeries, IStiSeriesBorderThickness, IStiAllowApplyBrushNegative, IStiShowZerosSeries, IStiCornerRadius {
        width: number;
        borderColor: Color;
        brush: StiBrush;
        showZeros: boolean;
        brushNegative: StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiStackedLineSeries: System.Interface<IStiStackedLineSeries>;
    interface IStiStackedLineSeries extends IStiStackedBaseLineSeries {
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiStackedSplineAreaSeries: System.Interface<IStiStackedSplineAreaSeries>;
    interface IStiStackedSplineAreaSeries extends IStiStackedSplineSeries, IStiAllowApplyBrushNegative {
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiStackedSplineSeries: System.Interface<IStiStackedSplineSeries>;
    interface IStiStackedSplineSeries extends IStiStackedBaseLineSeries, IStiAllowApplyColorNegative {
        tension: number;
        lineColorNegative: Color;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiSunburstSeries: System.Interface<IStiSunburstSeries>;
    interface IStiSunburstSeries extends IStiSeries, IStiSeriesBorderThickness {
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiTreemapSeries: System.Interface<IStiTreemapSeries>;
    interface IStiTreemapSeries extends IStiSeries, IStiSeriesBorderThickness, IStiFontIconsSeries, IStiCornerRadius {
        borderColor: Color;
        brush: StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiNoneLabels: System.Interface<IStiNoneLabels>;
    interface IStiNoneLabels extends IStiSeriesLabels {
    }
}
export namespace Stimulsoft.Report.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiSeriesLabels: System.Interface<IStiSeriesLabels>;
    interface IStiSeriesLabels extends ICloneable, IStiJsonReportObject, IAsIs {
        allowApplyStyle: boolean;
        showZeros: boolean;
        showNulls: boolean;
        markerVisible: boolean;
        step: number;
        valueTypeSeparator: string;
        textBefore: string;
        textAfter: string;
        angle: number;
        format: string;
        antialiasing: boolean;
        visible: boolean;
        drawBorder: boolean;
        useSeriesColor: boolean;
        markerAlignment: StiMarkerAlignment;
        valueType: StiSeriesLabelsValueType;
        legendValueType: StiSeriesLabelsValueType;
        markerSize: SizeD;
        labelColor: Color;
        borderColor: Color;
        brush: StiBrush;
        font: Font;
        chart: IStiChart;
        core: IStiSeriesLabelsCoreXF;
        preventIntersection: boolean;
        wordWrap: boolean;
        width: number;
        formatService: StiFormatService;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    let IStiSeriesLabelsCoreXF: System.Interface<IStiSeriesLabelsCoreXF>;
    interface IStiSeriesLabelsCoreXF extends IStiApplyStyle {
        recalcValue(value: number, signs: number): number;
        getLabelColor(series: IStiSeries, colorIndex: number, colorCount: number): Color;
        getLabelText(series: IStiSeries, value: number, argument: string, tag: string, seriesName: string, useLegendValueType: boolean): string;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiAxisSeriesLabels: System.Interface<IStiAxisSeriesLabels>;
    interface IStiAxisSeriesLabels extends IStiSeriesLabels {
        showInPercent: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiCenterAxisLabels: System.Interface<IStiCenterAxisLabels>;
    interface IStiCenterAxisLabels extends IStiAxisSeriesLabels {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiInsideBaseAxisLabels: System.Interface<IStiInsideBaseAxisLabels>;
    interface IStiInsideBaseAxisLabels extends IStiAxisSeriesLabels {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiInsideEndAxisLabels: System.Interface<IStiInsideEndAxisLabels>;
    interface IStiInsideEndAxisLabels extends IStiCenterAxisLabels {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiLeftAxisLabels: System.Interface<IStiLeftAxisLabels>;
    interface IStiLeftAxisLabels extends IStiCenterAxisLabels {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiOutsideAxisLabels: System.Interface<IStiOutsideAxisLabels>;
    interface IStiOutsideAxisLabels extends IStiAxisSeriesLabels {
        lineLength: number;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiOutsideBaseAxisLabels: System.Interface<IStiOutsideBaseAxisLabels>;
    interface IStiOutsideBaseAxisLabels extends IStiCenterAxisLabels {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiOutsideEndAxisLabels: System.Interface<IStiOutsideEndAxisLabels>;
    interface IStiOutsideEndAxisLabels extends IStiCenterAxisLabels {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiRightAxisLabels: System.Interface<IStiRightAxisLabels>;
    interface IStiRightAxisLabels extends IStiCenterAxisLabels {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiValueAxisLabels: System.Interface<IStiValueAxisLabels>;
    interface IStiValueAxisLabels extends IStiCenterAxisLabels {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiCenterFunnelLabels: System.Interface<IStiCenterFunnelLabels>;
    interface IStiCenterFunnelLabels extends IStiFunnelSeriesLabels {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiFunnelSeriesLabels: System.Interface<IStiFunnelSeriesLabels>;
    interface IStiFunnelSeriesLabels extends IStiSeriesLabels {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiOutsideLeftFunnelLabels: System.Interface<IStiOutsideLeftFunnelLabels>;
    interface IStiOutsideLeftFunnelLabels extends IStiCenterFunnelLabels {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiOutsideRightFunnelLabels: System.Interface<IStiOutsideRightFunnelLabels>;
    interface IStiOutsideRightFunnelLabels extends IStiCenterFunnelLabels {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiCenterPieLabels: System.Interface<IStiCenterPieLabels>;
    interface IStiCenterPieLabels extends IStiPieSeriesLabels {
        autoRotate: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiInsideEndPieLabels: System.Interface<IStiInsideEndPieLabels>;
    interface IStiInsideEndPieLabels extends IStiCenterPieLabels {
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiOutsidePieLabels: System.Interface<IStiOutsidePieLabels>;
    interface IStiOutsidePieLabels extends IStiCenterPieLabels {
        showValue: boolean;
        lineLength: number;
        lineColor: Color;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiPieSeriesLabels: System.Interface<IStiPieSeriesLabels>;
    interface IStiPieSeriesLabels extends IStiSeriesLabels {
        showInPercent: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiTwoColumnsPieLabels: System.Interface<IStiTwoColumnsPieLabels>;
    interface IStiTwoColumnsPieLabels extends IStiOutsidePieLabels {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiRadarSeriesLabels: System.Interface<IStiRadarSeriesLabels>;
    interface IStiRadarSeriesLabels extends IStiSeriesLabels {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiTangentRadarLabels: System.Interface<IStiTangentRadarLabels>;
    interface IStiTangentRadarLabels extends IStiRadarSeriesLabels {
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiStrips: System.Interface<IStiStrips>;
    interface IStiStrips extends ICloneable, IStiJsonReportObject {
        core: IStiStripsCoreXF;
        allowApplyStyle: boolean;
        showBehind: boolean;
        stripBrush: StiBrush;
        antialiasing: boolean;
        font: Font;
        text: string;
        titleVisible: boolean;
        titleColor: Color;
        orientation: StiStrips_StiOrientation;
        showInLegend: boolean;
        maxValue: string;
        minValue: string;
        visible: boolean;
        chart: IStiChart;
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    let IStiStripsCollection: System.Interface<IStiStripsCollection>;
    interface IStiStripsCollection extends ICollection<IStiStrips>, IStiApplyStyle {
        add(value: IStiStrips): any;
        insert(index: number, value: IStiStrips): any;
        getByIndex(index: number): IStiStrips;
        applyStyle(style: IStiChartStyle): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    let IStiStripsCoreXF: System.Interface<IStiStripsCoreXF>;
    interface IStiStripsCoreXF extends IStiApplyStyle {
        render(context: StiContext, geom: IStiCellGeom, rect: RectangleD): any;
        applyStyle(style: IStiChartStyle): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiChartStyle = Stimulsoft.Report.Styles.StiChartStyle;
    let IStiCustomStyleCoreXF: System.Interface<IStiCustomStyleCoreXF>;
    interface IStiCustomStyleCoreXF extends IStiStyleCoreXF {
        reportStyle: StiChartStyle;
        reportStyleName: string;
        reportChartStyle: Stimulsoft.Report.Styles.StiChartStyle;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    let IStiStyleCoreXF: System.Interface<IStiStyleCoreXF>;
    interface IStiStyleCoreXF {
        seriesBorderThickness: number;
        seriesCornerRadius: StiCornerRadius;
        chart: IStiChart;
        chartBrush: StiBrush;
        chartAreaBrush: StiBrush;
        chartAreaBorderColor: Color;
        chartAreaBorderThickness: number;
        chartAreaShowShadow: boolean;
        seriesShowShadow: boolean;
        seriesShowBorder: boolean;
        seriesBorderColor: Color;
        seriesLighting: boolean;
        seriesLabelsFont: Font;
        seriesLabelsColor: Color;
        seriesLabelsLineColor: Color;
        seriesLabelsBrush: StiBrush;
        seriesLabelsBorderColor: Color;
        axisLineColor: Color;
        axisLabelsColor: Color;
        axisTitleColor: Color;
        gridLinesHorColor: Color;
        gridLinesVertColor: Color;
        interlacingHorBrush: StiBrush;
        interlacingVertBrush: StiBrush;
        legendBrush: StiBrush;
        legendLabelsColor: Color;
        legendBorderColor: Color;
        legendTitleColor: Color;
        legendShowShadow: boolean;
        legendFont: Font;
        getAreaBrush(color: Color): StiBrush;
        getColumnBrush(color: Color): StiBrush;
        getColumnBorder(color: Color): Color;
        getColors(seriesCount: number, seriesColors: Color[]): Color[];
        getColorByIndex(index: number, count: number, seriesColor: Color[]): Color;
        getColorBySeries(series: IStiSeries, seriesColor: Color[]): Color;
        basicStyleColor: Color;
        markerVisible: boolean;
        styleColors: Color[];
        trendLineColor: Color;
        toolTipBrush: StiBrush;
        toolTipTextBrush: StiBrush;
        toolTipCornerRadius: StiCornerRadius;
        toolTipBorder: StiSimpleBorder;
        fillColumn(context: StiContext, rect: RectangleD, brush: StiBrush, interaction: StiInteractionDataGeom): any;
        fillCicledColumn(context: StiContext, rect: RectangleD, cornerRadius: StiCornerRadius, brush: StiBrush, interaction: StiInteractionDataGeom, tooltip: string): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiChartTable: System.Interface<IStiChartTable>;
    interface IStiChartTable extends ICloneable, IStiJsonReportObject {
        core: IStiChartTableCoreXF;
        chart: IStiChart;
        allowApplyStyle: boolean;
        font: Font;
        markerVisible: boolean;
        gridLineColor: Color;
        textColor: Color;
        gridLinesHor: boolean;
        gridLinesVert: boolean;
        gridOutline: boolean;
        visible: boolean;
        format: string;
        header: IStiChartTableHeader;
        dataCells: IStiChartTableDataCells;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    let IStiChartTableCoreXF: System.Interface<IStiChartTableCoreXF>;
    interface IStiChartTableCoreXF extends IStiApplyStyle {
        showTable(): boolean;
        getWidthCellLegend(context: StiContext): number;
        getHeightTable(context: StiContext, widthTable: number): number;
        render(context: StiContext, rect: RectangleD): IStiCellGeom;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiChartTableDataCells: System.Interface<IStiChartTableDataCells>;
    interface IStiChartTableDataCells extends ICloneable, IStiJsonReportObject {
        font: Font;
        textColor: Color;
        shrinkFontToFit: boolean;
        shrinkFontToFitMinimumSize: number;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiChartTableHeader: System.Interface<IStiChartTableHeader>;
    interface IStiChartTableHeader extends ICloneable, IStiJsonReportObject {
        textAfter: string;
        brush: StiBrush;
        font: Font;
        textColor: Color;
        wordWrap: boolean;
        format: string;
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiSeriesTopN: System.Interface<IStiSeriesTopN>;
    interface IStiSeriesTopN extends ICloneable, IStiJsonReportObject {
        mode: StiTopNMode;
        count: number;
        showOthers: boolean;
        othersText: string;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Font = Stimulsoft.System.Drawing.Font;
    let IStiTrendLine: System.Interface<IStiTrendLine>;
    interface IStiTrendLine extends ICloneable, IStiJsonReportObject, IAsIs {
        core: IStiTrendLineCoreXF;
        lineWidth: number;
        lineStyle: StiPenStyle;
        lineColor: Color;
        font: Font;
        showShadow: boolean;
        titleVisible: boolean;
        text: string;
        position: StiTrendLine_StiTextPosition;
        serviceEnabled: boolean;
        allowApplyStyle: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    let IStiTrendLineCoreXF: System.Interface<IStiTrendLineCoreXF>;
    interface IStiTrendLineCoreXF {
        renderTrendLine(geom: IStiCellGeom, points: PointD[], posY: number): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiTrendLineExponential: System.Interface<IStiTrendLineExponential>;
    interface IStiTrendLineExponential extends IStiTrendLine {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiTrendLineLinear: System.Interface<IStiTrendLineLinear>;
    interface IStiTrendLineLinear extends IStiTrendLine {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiTrendLineLogarithmic: System.Interface<IStiTrendLineLogarithmic>;
    interface IStiTrendLineLogarithmic extends IStiTrendLine {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiTrendLineNone: System.Interface<IStiTrendLineNone>;
    interface IStiTrendLineNone extends IStiTrendLine {
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    let IStiTrendLinesCollection: System.Interface<IStiTrendLinesCollection>;
    interface IStiTrendLinesCollection extends ICollection<IStiTrendLine> {
        add(value: IStiTrendLine): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    let IStiWaterfallConnectorLine: System.Interface<IStiWaterfallConnectorLine>;
    interface IStiWaterfallConnectorLine extends ICloneable, IStiJsonReportObject {
        lineColor: Color;
        lineStyle: StiPenStyle;
        lineWidth: number;
        visible: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiWaterfallTotal: System.Interface<IStiWaterfallTotal>;
    interface IStiWaterfallTotal extends ICloneable, IStiJsonReportObject {
        text: string;
        visible: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiArea3D: System.Interface<IStiArea>;
    interface IStiArea3D extends IStiArea {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiAxisArea3D: System.Interface<IStiAxisArea3D>;
    interface IStiAxisArea3D extends IStiArea3D {
        axisCore: IStiAxisAreaCoreXF3D;
        interlacingHor: IStiInterlacingHor;
        interlacingVert: IStiInterlacingVert;
        xAxis: IStiXAxis3D;
        yAxis: IStiYAxis3D;
        zAxis: IStiAxis3D;
        gridLinesHor: IStiGridLinesHor;
        gridLinesVert: IStiGridLinesVert;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiAxisAreaCoreXF3D: System.Interface<IStiAxisAreaCoreXF3D>;
    interface IStiAxisAreaCoreXF3D {
        valuesCount: number;
        getDividerY(): number;
        switchOff(): any;
        getArgumentLabel(line: IStiStripLineXF, series: IStiSeries): string;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiClusteredColumnArea3D: System.Interface<IStiClusteredColumnArea3D>;
    interface IStiClusteredColumnArea3D extends IStiAxisArea3D {
        sideBySide: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiLineArea3D: System.Interface<IStiLineArea3D>;
    interface IStiLineArea3D extends IStiClusteredColumnArea3D {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiFullStackedColumnArea3D: System.Interface<IStiFullStackedColumnArea3D>;
    interface IStiFullStackedColumnArea3D extends IStiStackedColumnArea3D {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiStackedColumnArea3D: System.Interface<IStiStackedColumnArea3D>;
    interface IStiStackedColumnArea3D extends IStiAxisArea3D {
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiAxis3D: System.Interface<IStiAxis3D>;
    interface IStiAxis3D extends ICloneable {
        core: IStiAxisCoreXF3D;
        info: IStiAxisInfoXF3D;
        allowApplyStyle: boolean;
        lineColor: Color;
        visible: boolean;
        labels: IStiAxisLabels3D;
        area: IStiAxisArea3D;
        title: IStiAxisTitle3D;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Size = Stimulsoft.System.Drawing.Size;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    let IStiAxisCoreXF3D: System.Interface<IStiAxisCoreXF3D>;
    interface IStiAxisCoreXF3D {
        getFontGeom(context: Base.Context.StiContext): Base.Context.StiFontGeom;
        calculateStripPositions(topPosition: number, bottomPosition: number): any;
        render3D(context: Base.Context.StiContext, rect3D: IStiRectangle3D, render3d: IStiRender3D): IStiCellGeom;
        applyStyle(style: IStiChartStyle): any;
        getAxisTitleSize(context: Base.Context.StiContext): Size;
        getStringFormatGeom(context: StiContext, wordWrap: boolean): StiStringFormatGeom;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiAxisInfoXF3D: System.Interface<IStiAxisInfoXF3D>;
    interface IStiAxisInfoXF3D {
        minimum: number;
        maximum: number;
        range: number;
        labelsCollection: IStiStripPositionXF[];
        dpi: number;
        stripLines: IStiStripLinesXF;
        stripPositions: number[];
        step: number;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiAxisLabels3D: System.Interface<IStiAxisLabels>;
    interface IStiAxisLabels3D extends ICloneable, IStiJsonReportObject {
        core: IStiAxisLabelsCoreXF3D;
        allowApplyStyle: boolean;
        color: Color;
        font: Font;
        textBefore: string;
        textAfter: string;
        format: string;
        formatService: StiFormatService;
        calculatedStep: number;
        angle: number;
        width: number;
        wordWrap: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiAxisLabelsCoreXF3D: System.Interface<IStiAxisLabelsCoreXF3D>;
    interface IStiAxisLabelsCoreXF3D {
        applyStyle(style: IStiChartStyle): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiAxisTitle3D: System.Interface<IStiAxisLabels>;
    interface IStiAxisTitle3D extends ICloneable, IStiJsonReportObject {
        core: IStiAxisTitleCoreXF3D;
        allowApplyStyle: boolean;
        font: Font;
        text: string;
        color: Color;
        direction: StiDirection;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    let IStiAxisTitleCoreXF3D: System.Interface<IStiAxisTitleCoreXF3D>;
    interface IStiAxisTitleCoreXF3D {
        applyStyle(style: IStiChartStyle): any;
        render(context: StiContext, titleRect: Rectangle, axis: IStiAxis3D): any;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiXAxis3D: System.Interface<IStiXAxis3D>;
    interface IStiXAxis3D extends IStiAxis3D {
        showEdgeValues: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiYAxis3D: System.Interface<IStiYAxis3D>;
    interface IStiYAxis3D extends IStiAxis3D {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiZAxis3D: System.Interface<IStiZAxis3D>;
    interface IStiZAxis3D extends IStiAxis3D {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiDrawSidesGeom3D: System.Interface<IStiDrawSidesGeom3D>;
    interface IStiDrawSidesGeom3D {
        drawLeft: boolean;
        drawBack: boolean;
        drawTop: boolean;
        drawBottom: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiColumnShape3D: System.Interface<IStiColumnShape3D>;
    interface IStiColumnShape3D {
        columnShape: StiColumnShape3D;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiBaseLineSeries3D: System.Interface<IStiBaseLineSeries3D>;
    interface IStiBaseLineSeries3D extends IStiSeries {
        lineColor: Color;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiClusteredColumnSeries3D: System.Interface<IStiClusteredColumnSeries3D>;
    interface IStiClusteredColumnSeries3D extends IStiSeries, IStiColumnShape3D {
        length: number;
        width: number;
        borderColor: Color;
        color: Color;
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiLineSeries3D: System.Interface<IStiLineSeries3D>;
    interface IStiLineSeries3D extends IStiBaseLineSeries3D {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiFullStackedColumnSeries3D: System.Interface<IStiFullStackedColumnSeries3D>;
    interface IStiFullStackedColumnSeries3D extends IStiStackedColumnSeries3D {
    }
}
export namespace Stimulsoft.Report.Chart {
    let IStiStackedColumnSeries3D: System.Interface<IStiStackedColumnSeries3D>;
    interface IStiStackedColumnSeries3D extends IStiClusteredColumnSeries3D {
    }
}
export namespace Stimulsoft.Report.CodeDom {
    import StiRichText = Stimulsoft.Report.Components.StiRichText;
    class StiCodeDomExpressionHelper {
        private static parseRtf;
        static readString(codeGenerator: StiCodeGenerator, REFpos: any, REFlexem: any, script: string, REFal: {
            ref: string[];
        }, isRichText: boolean, fullRtf: boolean): void;
        private static readChar;
        static getLexemSimple(codeGenerator: StiCodeGenerator, script: string, richText: StiRichText): string[];
        static getLexem(script: string): string[];
        private static replaceBackslash;
    }
}
export namespace Stimulsoft.Report.CodeDom {
    class StiCodeDomSerializator {
        static reservedWords: string[];
    }
}
export namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiBookmarksCollection extends CollectionBase<StiBookmark> {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        indexOf(param: StiBookmark | string | any): number;
        getByName(name: string): StiBookmark;
        findByName(name: string): StiBookmark;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiCrossHeaderInteraction extends StiInteraction implements IStiJsonReportObject {
        meta(): StiMeta[];
        isDefault(): boolean;
        collapsingEnabled: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDrillDownParameter implements IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        isDefault(): boolean;
        name: string;
        expression: string;
        interaction: StiInteraction;
    }
}
export namespace Stimulsoft.Report.Components {
    class StiFilterHelper {
        static convertStringToCondition(condition: string): StiFilterCondition;
        static convertConditionToString(condition: StiFilterCondition): string;
        static convertStringToDataType(dataType: string): StiFilterDataType;
        static convertDataTypeToString(dataType: StiFilterDataType): string;
        static setFilter(comp: StiComponent): void;
    }
}
export namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiFiltersCollection extends CollectionBase<StiFilter> implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiFiltersCollection;
    }
}
export namespace Stimulsoft.Report.Components {
    import Size = Stimulsoft.System.Drawing.Size;
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Font = Stimulsoft.System.Drawing.Font;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiOutlineTextMetric {
        otmAscent: number;
        otmDescent: number;
        otmExternalLeading: number;
        otmsStrikeoutSize: number;
        otmsStrikeoutPosition: number;
        otmsUnderscoreSize: number;
        otmsUnderscorePosition: number;
        baseFont: Font;
        private fontScale;
        widths: number[];
        getWidth(sym: number): number;
        constructor();
    }
    export class StiHtmlTextRender {
        private static outlineTextMetricsCache;
        static getOutlineTextMetricsCached(fontName: string, fontStyle: FontStyle): StiOutlineTextMetric;
        static drawString(g: Graphics, rect: Rectangle, text: string, textBox: StiText): void;
        static measureString(textBox: StiText): Size;
        static breakText(rect: Rectangle, text: string, textBox: StiText): string[];
        static drawTextForOutput(textBox: StiText, outRunsList: any, outFontsList: any): void;
    }
    export {};
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiParameter implements IStiJsonReportObject {
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        name: string;
        expression: string;
        constructor();
    }
}
export namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiParametersCollection extends CollectionBase<StiParameter> implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiParametersCollection;
        indexOf2(name: string): number;
        insertRange(index: number, parameters: StiParametersCollection): void;
        remove2(parameter: StiParameter): void;
        getByName(name: string): StiParameter;
        setByName(name: string, value: any): void;
        findByName(name: string): StiParameter;
        copyTo(array: any[], index: number): void;
        constructor();
    }
}
export namespace Stimulsoft.Report.Components {
    class StiRestrictionsHelper {
        static isAllowChange(comp: StiComponent): boolean;
        static isAllowDelete2(restrictions: StiRestrictions): boolean;
        static isAllowDelete(comp: StiComponent): boolean;
        static isAllowMove(comp: StiComponent): boolean;
        static isAllowSelect(comp: StiComponent): boolean;
        static isAllowResize(comp: StiComponent): boolean;
        static isAllowChangePosition(comp: StiComponent): boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    class StiSortHelper {
        static getColumnIndexInSorting(sorts: string[], columnName: string): number;
        static getColumnSortDirection(sorts: string[], columnName: string): StiInteractionSortDirection;
        static changeColumnSortDirection(sorts: string[], columnName: string): string[];
        static isColumnExistInSorting(sorts: string[], columnName: string): boolean;
        static addColumnToSorting(sorts: string[], columnName: string, isAscending: boolean): string[];
    }
}
export namespace Stimulsoft.Report.Components {
    import Font = Stimulsoft.System.Drawing.Font;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiStandardTextRenderer {
        static measureString(maxWidth: number, font: Font, textBox: StiText): SizeD;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiColumnFooterBand extends StiFooterBand implements IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get priority(): number;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiColumnHeaderBand extends StiHeaderBand {
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    class StiDataBandSQLFilterHelper {
        static getFilter(band: StiDataBand, useDataSourceNames: boolean): string;
        private static getFilterExpression;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStaticBand extends StiBand implements IStiBreakable, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        protected getComponentType(): StiComponentType;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOverlayBand extends StiStaticBand implements IStiVertAlignment, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        vertAlignment: StiVertAlignment;
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        protected getComponentType(): StiComponentType;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get priority(): number;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiPageFooterBand extends StiStaticBand implements IStiPrintOnEvenOddPages, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        printOnEvenOddPages: StiPrintOnEvenOddPagesType;
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get priority(): number;
        canContainIn(component: StiComponent): boolean;
        protected getComponentType(): StiComponentType;
        getDisplayRectangle(): RectangleD;
        setDisplayRectangle(value: RectangleD): void;
        getMaster(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPageHeaderBand extends StiStaticBand implements IStiBreakable, IStiPrintOnEvenOddPages, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get priority(): number;
        canContainIn(component: StiComponent): boolean;
        protected getComponentType(): StiComponentType;
        printOnEvenOddPages: StiPrintOnEvenOddPagesType;
        get printOnFirstPage(): boolean;
        set printOnFirstPage(value: boolean);
        getMaster(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiReportSummaryBand extends StiDynamicBand implements IStiPrintIfEmpty, IStiKeepReportSummaryTogether, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        keepReportSummaryTogether: boolean;
        printIfEmpty: boolean;
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        canContainIn(component: StiComponent): boolean;
        get priority(): number;
        protected getComponentType(): StiComponentType;
        getMaster(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiReportTitleBand extends StiStaticBand implements IStiBreakable, IStiPrintIfEmpty, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        printIfEmpty: boolean;
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        protected getComponentType(): StiComponentType;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get priority(): number;
        canContainIn(component: StiComponent): boolean;
        getMaster(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import EventArgs = Stimulsoft.System.EventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiClone extends StiContainer implements IStiClone {
        implements(): any[];
        jsonContainerValueTemp: string;
        meta(): StiMeta[];
        loadFromXml(xmlNode: XmlNode): void;
        setSanShrink(value: boolean): void;
        setCanGrow(value: boolean): void;
        container: StiContainer;
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get componentType(): StiComponentType;
        canContainIn(component: StiComponent): boolean;
        private _components2;
        get components(): StiComponentsCollection;
        set components(value: StiComponentsCollection);
        onBeforePrint(e: EventArgs): void;
        onAfterPrint(e: EventArgs): void;
        constructor(rect?: RectangleD, isSuper?: boolean);
        protected construct(rect?: RectangleD): void;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiColorScaleCondition extends StiBaseCondition implements IStiIndicatorCondition, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        createIndicator(component: StiText): StiIndicator;
        reset(): void;
        scaleType: StiColorScaleType;
        minimumColor: Color;
        midColor: Color;
        maximumColor: Color;
        minimumType: StiMinimumType;
        minimumValue: number;
        midType: StiMidType;
        midValue: number;
        maximumType: StiMaximumType;
        maximumValue: number;
        equals(obj: any): boolean;
        private minimum;
        private maximum;
        constructor(column?: string, scaleType?: StiColorScaleType, minimumColor?: Color, midColor?: Color, maximumColor?: Color, minimumType?: StiMinimumType, minimumValue?: number, midType?: StiMidType, midValue?: number, maximumType?: StiMaximumType, maximumValue?: number);
    }
}
export namespace Stimulsoft.Report.Components {
    import Font = Stimulsoft.System.Drawing.Font;
    class StiConditionHelper extends StiFilter {
        implements(): any[];
        static apply(comp: any, styleName: string): void;
        private static applyParentStyle;
        static applyFont(component: any, font: Font, perms: StiConditionPermissions): void;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    import StiDataTopNMode = Stimulsoft.Data.Engine.StiDataTopNMode;
    class StiCrossTabTopNCondition extends StiCondition {
        count: number;
        mode: StiDataTopNMode;
        measureField: string;
        conditionCell: boolean;
        conditionHeader: boolean;
        conditionTotal: boolean;
        get topN(): StiDataTopN;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiDataBarTextPlacement = Stimulsoft.Report.Components.StiDataBarTextPlacement;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrushType = Stimulsoft.Report.Components.StiBrushType;
    class StiDataBarCondition extends StiBaseCondition implements IStiDataBarIndicator, IStiIndicatorCondition, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        createIndicator(component: StiText): StiIndicator;
        reset(): void;
        brushType: StiBrushType;
        positiveColor: Color;
        negativeColor: Color;
        positiveBorderColor: Color;
        negativeBorderColor: Color;
        showBorder: boolean;
        direction: StiDataBarDirection;
        padding: number;
        cornerRadius: number;
        textPlacement: StiDataBarTextPlacement;
        minimumType: StiMinimumType;
        minimumValue: number;
        maximumType: StiMaximumType;
        maximumValue: number;
        get areAdditionalOptionsInDefaultState(): boolean;
        equals(obj: any): boolean;
        private minimum;
        private maximum;
        constructor(column?: string, brushType?: StiBrushType, positiveColor?: Color, negativeColor?: Color, showBorder?: boolean, positiveBorderColor?: Color, negativeBorderColor?: Color, direction?: StiDataBarDirection, minimumType?: StiMinimumType, minimumValue?: number, maximumType?: StiMaximumType, maximumValue?: number, padding?: number, cornerRadius?: number, textPlacement?: StiDataBarTextPlacement);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import ContentAlignment = Stimulsoft.System.Drawing.ContentAlignment;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiIconSetCondition extends StiBaseCondition implements IStiIndicatorCondition, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        createIndicator(component: StiText): StiIndicator;
        private inRange;
        reset(): void;
        iconSet: StiIconSet;
        contentAlignment: ContentAlignment;
        iconSetItem1: StiIconSetItem;
        iconSetItem2: StiIconSetItem;
        iconSetItem3: StiIconSetItem;
        iconSetItem4: StiIconSetItem;
        iconSetItem5: StiIconSetItem;
        equals(obj: any): boolean;
        private minimum;
        private maximum;
        constructor(column?: string, iconSet?: StiIconSet, contentAlignment?: ContentAlignment, item1?: StiIconSetItem, item2?: StiIconSetItem, item3?: StiIconSetItem, item4?: StiIconSetItem, item5?: StiIconSetItem);
    }
}
export namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiIconSetItem implements IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        icon: StiIcon;
        operation: StiIconSetOperation;
        valueType: StiIconSetValueType;
        value: number;
        constructor(icon?: StiIcon, operation?: StiIconSetOperation, valueType?: StiIconSetValueType, value?: number);
    }
}
export namespace Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiMultiConditionContainer {
        filters: StiFiltersCollection;
        filterMode: StiFilterMode;
        enabled: boolean;
        textColor: Color;
        backColor: Color;
        font: Font;
        canAssignExpression: boolean;
        assignExpression: string;
        style: string;
        borderSides: StiConditionBorderSides;
        permissions: StiConditionPermissions;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCrossDataBand extends StiDataBand implements IStiJsonReportObject {
        meta(): StiMeta[];
        get helpUrl(): string;
        get growToHeight(): boolean;
        set growToHeight(value: boolean);
        get resetPageNumber(): boolean;
        set resetPageNumber(value: boolean);
        get startNewPage(): boolean;
        set startNewPage(value: boolean);
        get startNewPageIfLessThan(): number;
        set startNewPageIfLessThan(value: number);
        restoreState(stateName: string): void;
        get keepHeaderTogether(): boolean;
        set keepHeaderTogether(value: boolean);
        get keepFooterTogether(): boolean;
        set keepFooterTogether(value: boolean);
        get keepChildTogether(): boolean;
        set keepChildTogether(value: boolean);
        get keepGroupTogether(): boolean;
        set keepGroupTogether(value: boolean);
        get printAtBottom(): boolean;
        set printAtBottom(value: boolean);
        get printOnAllPages(): boolean;
        set printOnAllPages(value: boolean);
        setColumnModeToParent(): void;
        getColumnModeFromParent(): void;
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        get localizedCategory(): string;
        get localizedName(): string;
        get isCross(): boolean;
        isRightToLeft: boolean;
        getDockStyle(): StiDockStyle;
        get minWidth(): number;
        set minWidth(value: number);
        get maxWidth(): number;
        set maxWidth(value: number);
        defaultClientRectangle: RectangleD;
        get selectRectangle(): RectangleD;
        set selectRectangle(value: RectangleD);
        get displayRectangle(): RectangleD;
        set displayRectangle(value: RectangleD);
        columnCurrent: number;
        get headerSize(): number;
        columnMode: boolean;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCrossFooterBand extends StiFooterBand implements IStiJsonReportObject {
        meta(): StiMeta[];
        get helpUrl(): string;
        get growToHeight(): boolean;
        set growToHeight(value: boolean);
        get resetPageNumber(): boolean;
        set resetPageNumber(value: boolean);
        get startNewPage(): boolean;
        set startNewPage(value: boolean);
        get startNewPageIfLessThan(): number;
        set startNewPageIfLessThan(value: number);
        get printAtBottom(): boolean;
        set printAtBottom(value: boolean);
        get printOnAllPages(): boolean;
        set printOnAllPages(value: boolean);
        get localizedCategory(): string;
        get localizedName(): string;
        get isCross(): boolean;
        getDockStyle(): StiDockStyle;
        setDockStyle(value: StiDockStyle): void;
        get minWidth(): number;
        set minWidth(value: number);
        get maxWidth(): number;
        set maxWidth(value: number);
        defaultClientRectangle: RectangleD;
        get selectRectangle(): RectangleD;
        set selectRectangle(value: RectangleD);
        get displayRectangle(): RectangleD;
        set displayRectangle(value: RectangleD);
        get headerSize(): number;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCrossGroupFooterBand extends StiGroupFooterBand implements IStiJsonReportObject {
        meta(): StiMeta[];
        get helpUrl(): string;
        get growToHeight(): boolean;
        set growToHeight(value: boolean);
        get resetPageNumber(): boolean;
        set resetPageNumber(value: boolean);
        get printAtBottom(): boolean;
        set printAtBottom(value: boolean);
        get localizedCategory(): string;
        get localizedName(): string;
        get isCross(): boolean;
        getDockStyle(): StiDockStyle;
        setDockStyle(value: StiDockStyle): void;
        get minWidth(): number;
        set minWidth(value: number);
        get maxWidth(): number;
        set maxWidth(value: number);
        defaultClientRectangle: RectangleD;
        get selectRectangle(): RectangleD;
        set selectRectangle(value: RectangleD);
        get displayRectangle(): RectangleD;
        set displayRectangle(value: RectangleD);
        get headerSize(): number;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCrossGroupHeaderBand extends StiGroupHeaderBand implements IStiJsonReportObject {
        meta(): StiMeta[];
        get helpUrl(): string;
        get growToHeight(): boolean;
        set growToHeight(value: boolean);
        get resetPageNumber(): boolean;
        set resetPageNumber(value: boolean);
        get startNewPage(): boolean;
        set startNewPage(value: boolean);
        get printOnAllPages(): boolean;
        set printOnAllPages(value: boolean);
        get printAtBottom(): boolean;
        set printAtBottom(value: boolean);
        get localizedCategory(): string;
        get localizedName(): string;
        get isCross(): boolean;
        getDockStyle(): StiDockStyle;
        setDockStyle(value: StiDockStyle): void;
        get minWidth(): number;
        set minWidth(value: number);
        get maxWidth(): number;
        set maxWidth(value: number);
        defaultClientRectangle: RectangleD;
        get selectRectangle(): RectangleD;
        set selectRectangle(value: RectangleD);
        get displayRectangle(): RectangleD;
        set displayRectangle(value: RectangleD);
        get headerSize(): number;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCrossHeaderBand extends StiHeaderBand implements IStiJsonReportObject {
        meta(): StiMeta[];
        get helpUrl(): string;
        get growToHeight(): boolean;
        set growToHeight(value: boolean);
        get resetPageNumber(): boolean;
        set resetPageNumber(value: boolean);
        get startNewPage(): boolean;
        set startNewPage(value: boolean);
        get startNewPageIfLessThan(): number;
        set startNewPageIfLessThan(value: number);
        get printAtBottom(): boolean;
        set printAtBottom(value: boolean);
        get printOnAllPages(): boolean;
        set printOnAllPages(value: boolean);
        get localizedCategory(): string;
        get localizedName(): string;
        get isCross(): boolean;
        getDockStyle(): StiDockStyle;
        setDockStyle(value: StiDockStyle): void;
        get minWidth(): number;
        set minWidth(value: number);
        get maxWidth(): number;
        set maxWidth(value: number);
        defaultClientRectangle: RectangleD;
        get selectRectangle(): RectangleD;
        set selectRectangle(value: RectangleD);
        get displayRectangle(): RectangleD;
        set displayRectangle(value: RectangleD);
        get headerSize(): number;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiIndicator implements IStiJsonReportObject, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        static loadFromJsonObjectInternal(jObject: StiJson): StiIndicator;
        static loadFromXml(text: string): StiIndicator;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrushType = Stimulsoft.Report.Components.StiBrushType;
    class StiDataBarIndicator extends StiIndicator implements IStiDataBarIndicator, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        brushType: StiBrushType;
        positiveColor: Color;
        negativeColor: Color;
        positiveBorderColor: Color;
        negativeBorderColor: Color;
        showBorder: boolean;
        value: number;
        minimum: number;
        maximum: number;
        direction: StiDataBarDirection;
        padding: number;
        cornerRadius: number;
        textPlacement: StiDataBarTextPlacement;
        constructor(brushType?: StiBrushType, positiveColor?: Color, negativeColor?: Color, showBorder?: boolean, positiveBorderColor?: Color, negativeBorderColor?: Color, direction?: StiDataBarDirection, value?: number, minimum?: number, maximum?: number, padding?: number, cornerRadius?: number, textPlacement?: StiDataBarTextPlacement);
    }
}
export namespace Stimulsoft.Report.Components {
    import Image = Stimulsoft.System.Drawing.Image;
    import StiIcon = Stimulsoft.Report.Components.StiIcon;
    class StiIconSetHelper {
        static getIconSet(iconSet: StiIconSet): StiIcon[];
        static getIcons(iconSet: StiIconSet): Image[];
        static getIcon2(icon: StiIcon): Image;
        static getIcon(indicator: StiIconSetIndicator): Image;
        private static _icons;
        private static get icons();
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Size = Stimulsoft.System.Drawing.Size;
    import ContentAlignment = Stimulsoft.System.Drawing.ContentAlignment;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiIconSetIndicator extends StiIndicator implements IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        icon: StiIcon;
        alignment: ContentAlignment;
        customIcon: number[];
        customIconSize: Size;
        constructor(icon?: StiIcon, alignment?: ContentAlignment, customIcon?: number[], customIconSize?: Size);
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiAnchor: System.Interface<IStiAnchor>;
    interface IStiAnchor {
        anchor: StiAnchorMode;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiAutoWidth: System.Interface<IStiAutoWidth>;
    interface IStiAutoWidth {
        autoWidth: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiBorderColor: System.Interface<IStiBorderColor>;
    interface IStiBorderColor {
        borderColor: Color;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiCanGrow: System.Interface<IStiCanGrow>;
    interface IStiCanGrow {
        canGrow: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiCanShrink: System.Interface<IStiCanShrink>;
    interface IStiCanShrink {
        canShrink: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiClone: System.Interface<IStiClone>;
    interface IStiClone {
        container: StiContainer;
    }
}
export namespace Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiColor: System.Interface<IStiColor>;
    interface IStiColor {
        color: Color;
    }
}
export namespace Stimulsoft.Report.Components {
    import IAsIs = Stimulsoft.System.IAsIs;
    import ICloneable = Stimulsoft.System.ICloneable;
    let IStiComponent: System.Interface<IStiComponent>;
    interface IStiComponent extends ICloneable, IStiGrowToHeight, IStiPrintOn, IStiName, IAsIs {
        report: StiReport;
        parent: StiContainer;
        growToHeight: boolean;
        printOn: StiPrintOnType;
        printable: boolean;
        enabled: boolean;
        dockStyle: StiDockStyle;
        name: string;
        isDesigning: boolean;
        guid: string;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiComponentGuid: System.Interface<IStiComponentGuid>;
    interface IStiComponentGuid {
        guid: string;
        newGuid(): any;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    let IStiCornerRadius: System.Interface<IStiCornerRadius>;
    let ImplementsIStiCornerRadius: any[];
    interface IStiCornerRadius {
        cornerRadius: StiCornerRadius;
    }
}
export namespace Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrushType = Stimulsoft.Report.Components.StiBrushType;
    let IStiDataBarIndicator: System.Interface<IStiDataBarIndicator>;
    interface IStiDataBarIndicator {
        brushType: StiBrushType;
        positiveColor: Color;
        negativeColor: Color;
        positiveBorderColor: Color;
        negativeBorderColor: Color;
        showBorder: boolean;
        direction: StiDataBarDirection;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiGroup: System.Interface<IStiGroup>;
    interface IStiGroup {
        sortDirection: StiGroupSortDirection;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiGrowToHeight: System.Interface<IStiGrowToHeight>;
    interface IStiGrowToHeight {
        growToHeight: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiIgnoreBorderWhenExport: System.Interface<IStiIgnoreBorderWhenExport>;
    interface IStiIgnoreBorderWhenExport {
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiIndicatorCondition: System.Interface<IStiIndicatorCondition>;
    interface IStiIndicatorCondition {
        createIndicator(component: StiText): StiIndicator;
        reset(): any;
    }
}
export namespace Stimulsoft.Report.Components {
    interface IStiInteractionClass {
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiKeepChildTogether: System.Interface<IStiKeepChildTogether>;
    interface IStiKeepChildTogether {
        keepChildTogether: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiKeepDetailsTogether: System.Interface<IStiKeepDetailsTogether>;
    interface IStiKeepDetailsTogether {
        keepDetailsTogether: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiKeepFooterTogether: System.Interface<IStiKeepFooterTogether>;
    interface IStiKeepFooterTogether {
        keepFooterTogether: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiKeepGroupFooterTogether: System.Interface<IStiKeepGroupFooterTogether>;
    interface IStiKeepGroupFooterTogether {
        keepGroupFooterTogether: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiKeepGroupTogether: System.Interface<IStiKeepGroupTogether>;
    interface IStiKeepGroupTogether {
        keepGroupTogether: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiKeepHeaderTogether: System.Interface<IStiKeepHeaderTogether>;
    interface IStiKeepHeaderTogether {
        keepHeaderTogether: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiKeepReportSummaryTogether: System.Interface<IStiKeepReportSummaryTogether>;
    interface IStiKeepReportSummaryTogether {
        keepReportSummaryTogether: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    let IStiNumberFormat: System.Interface<IStiNumberFormat>;
    interface IStiNumberFormat {
        valueFormat: StiFormatService;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiOddEvenStyles: System.Interface<IStiOddEvenStyles>;
    interface IStiOddEvenStyles {
        evenStyle: string;
        oddStyle: string;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiPrintAtBottom: System.Interface<IStiPrintAtBottom>;
    interface IStiPrintAtBottom {
        printAtBottom: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiPrintIfDetailEmpty: System.Interface<IStiPrintIfDetailEmpty>;
    interface IStiPrintIfDetailEmpty {
        printIfDetailEmpty: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiPrintOn: System.Interface<IStiPrintOn>;
    interface IStiPrintOn {
        printOn: StiPrintOnType;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiPrintOnEvenOddPages: System.Interface<IStiPrintOnEvenOddPages>;
    interface IStiPrintOnEvenOddPages {
        printOnEvenOddPages: StiPrintOnEvenOddPagesType;
    }
}
export namespace Stimulsoft.Report.Components {
    interface IStiSeriesParent {
        parent: StiComponent;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiShape: System.Interface<IStiShape>;
    interface IStiShape {
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiShift: System.Interface<IStiShift>;
    interface IStiShift {
        shift: boolean;
        shiftMode: StiShiftMode;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiShowBlanks: System.Interface<IStiShowBlanks>;
    interface IStiShowBlanks {
        showBlanks: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    let IStiSimpleBorder: System.Interface<IStiSimpleBorder>;
    let ImplementsIStiSimpleBorder: any[];
    interface IStiSimpleBorder {
        border2: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    let IStiSimpleShadow: System.Interface<IStiSimpleShadow>;
    let ImplementsIStiSimpleShadow: any[];
    interface IStiSimpleShadow {
        shadow: StiSimpleShadow;
    }
}
export namespace Stimulsoft.Report.Components {
    import Font = Stimulsoft.System.Drawing.Font;
    let IStiTextFont: System.Interface<IStiTextFont>;
    interface IStiTextFont {
        getFont(): Font;
        setFontName(fontName: string): any;
        setFontSize(fontSize: number): any;
        growFontSize(): any;
        shrinkFontSize(): any;
        setFontBoldStyle(isBold: boolean): any;
        setFontItalicStyle(isItalic: boolean): any;
        setFontUnderlineStyle(isUnderline: boolean): any;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    let IStiTextOptions: System.Interface<IStiTextOptions>;
    interface IStiTextOptions {
        textOptions: StiTextOptions;
    }
}
export namespace Stimulsoft.Report.Components {
    let IStiWordWrap: System.Interface<IStiWordWrap>;
    interface IStiWordWrap {
        wordWrap: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    class StiMathFormula extends StiComponent implements IStiFont, IStiBorder, IStiBrush, IStiTextBrush, IStiHorAlignment, IStiVertAlignment {
        implements(): any[];
        meta(): StiMeta[];
        clone(cloneProperties: boolean): object;
        horAlignment: StiHorAlignment;
        vertAlignment: StiVertAlignment;
        brush: StiBrush;
        border: StiBorder;
        textBrush: StiBrush;
        private _font;
        get font(): Font;
        set font(value: Font);
        laTexExpression: string;
        get priority(): number;
        get localizedCategory(): string;
        defaultClientRectangle: RectangleD;
        get localizedName(): string;
        getFormulaString(): string;
        protected construct(rect?: RectangleD): void;
    }
}
export namespace Stimulsoft.Report.Components {
    enum StiShapeDirection {
        Up = 0,
        Down = 1,
        Left = 2,
        Right = 3
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiShapeTypeService extends StiService implements IStiJsonReportObject {
        meta(): StiMeta[];
        static loadFromJsonObjectInternal(jObject: StiJson): StiShapeTypeService;
        static createFromJsonObject(jObject: StiJson): StiShapeTypeService;
        static convertFromXml(xmlNode: XmlNode): StiShapeTypeService;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiArrowShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        direction: StiShapeDirection;
        private _arrowWidth;
        get arrowWidth(): number;
        set arrowWidth(value: number);
        private _arrowHeight;
        get arrowHeight(): number;
        set arrowHeight(value: number);
        constructor(direction?: StiShapeDirection, arrowWidth?: number, arrowHeight?: number);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiBentArrowShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        direction: StiShapeDirection;
        constructor(direction?: StiShapeDirection);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiChevronShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        direction: StiShapeDirection;
        constructor(direction?: StiShapeDirection);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiComplexArrowShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        direction: StiShapeDirection;
        constructor(direction?: StiShapeDirection);
    }
}
export namespace Stimulsoft.Report.Components {
    class StiDiagonalDownLineShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    class StiDiagonalUpLineShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    class StiDivisionShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    class StiEqualShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    class StiFlowchartCardShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiFlowchartCollateShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        direction: StiShapeDirection;
        constructor(direction?: StiShapeDirection);
    }
}
export namespace Stimulsoft.Report.Components {
    class StiFlowchartDecisionShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    class StiFlowchartManualInputShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiFlowchartOffPageConnectorShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        direction: StiShapeDirection;
        constructor(direction?: StiShapeDirection);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiFlowchartPreparationShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        direction: StiShapeDirection;
        constructor(direction?: StiShapeDirection);
    }
}
export namespace Stimulsoft.Report.Components {
    class StiFlowchartSortShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    class StiFrameShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    class StiHorizontalLineShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    class StiLeftAndRightLineShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    class StiMinusShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    class StiMultiplyShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiOctagonShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        autoSize: boolean;
        private _bevel;
        get bevel(): number;
        set bevel(value: number);
        constructor(autoSize?: boolean, bevel?: number);
    }
}
export namespace Stimulsoft.Report.Components {
    class StiOvalShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    class StiParallelogramShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    class StiPlusShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    class StiRectangleShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    class StiRegularPentagonShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiRoundedRectangleShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        private _round;
        get round(): number;
        set round(value: number);
        constructor(round?: number);
    }
}
export namespace Stimulsoft.Report.Components {
    class StiSnipDiagonalSideCornerRectangleShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    class StiSnipSameSideCornerRectangleShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    class StiTopAndBottomLineShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    class StiTrapezoidShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiTriangleShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        meta(): StiMeta[];
        clone(): any;
        direction: StiShapeDirection;
        constructor(direction?: StiShapeDirection);
    }
}
export namespace Stimulsoft.Report.Components {
    class StiVerticalLineShapeType extends StiShapeTypeService {
    }
}
export namespace Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiSignatureDraw implements IStiSignatureDraw {
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        static createFromJsonObject(j: StiJson): StiSignatureDraw;
        static createFromXml(xmlNode: XmlNode): StiSignatureDraw;
        clone(): any;
        image: number[];
        aspectRatio: boolean;
        horAlignment: StiHorAlignment;
        vertAlignment: StiVertAlignment;
        stretch: boolean;
        isDefault(): boolean;
        constructor(image?: number[], aspectRatio?: boolean, horAlignment?: StiHorAlignment, vertAlignment?: StiVertAlignment, stretch?: boolean);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiSignatureImage implements IStiSignatureImage {
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        static createFromJsonObject(j: StiJson): StiSignatureImage;
        static createFromXml(xmlNode: XmlNode): StiSignatureImage;
        clone(): any;
        image: number[];
        aspectRatio: boolean;
        horAlignment: StiHorAlignment;
        vertAlignment: StiVertAlignment;
        stretch: boolean;
        isDefault(): boolean;
        constructor(image?: number[], aspectRatio?: boolean, horAlignment?: StiHorAlignment, vertAlignment?: StiVertAlignment, stretch?: boolean);
    }
}
export namespace Stimulsoft.Report.Components {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiSignatureText implements IStiSignatureText {
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        static createFromJsonObject(j: StiJson): StiSignatureText;
        static createFromXml(xmlNode: XmlNode): StiSignatureText;
        clone(): any;
        text: string;
        horAlignment: StiTextHorAlignment;
        vertAlignment: StiVertAlignment;
        font: Font;
        color: Color;
        isDefault(): boolean;
        constructor(text?: string, horAlignment?: StiTextHorAlignment, vertAlignment?: StiVertAlignment, font?: Font, color?: Color);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiSignatureStyle = Stimulsoft.Base.SignatureFonts.StiSignatureStyle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiSignatureType implements IStiSignatureType {
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        static createFromJsonObject(j: StiJson): StiSignatureType;
        static createFromXml(xmlNode: XmlNode): StiSignatureType;
        clone(): any;
        fullName: string;
        initials: string;
        style: StiSignatureStyle;
        customFont: string;
        isDefault(): boolean;
        constructor(fullName?: string, initials?: string, style?: StiSignatureStyle);
    }
}
export namespace Stimulsoft.Report.Components {
    import Image = Stimulsoft.System.Drawing.Image;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiSignature extends StiComponent implements IStiBorder, IStiExportImage, IStiExportImageExtended, IStiBrush, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        clone(cloneProperties: boolean): any;
        helpUrl: string;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        brush: StiBrush;
        border: StiBorder;
        get toolboxCategory(): StiToolboxCategory;
        get localizedCategory(): string;
        defaultClientRectangle: Rectangle;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Report.Components {
    import Image = Stimulsoft.System.Drawing.Image;
    import IStiSignatureDraw = Stimulsoft.Report.Components.IStiSignatureDraw;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiSignatureMode = Stimulsoft.Report.Components.StiSignatureMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiElectronicSignature extends StiSignature implements IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        clone(cloneProperties: boolean): any;
        get toolboxPosition(): number;
        get localizedName(): string;
        alreadySigned: boolean;
        allowCleanSignature: boolean;
        mode: StiSignatureMode;
        draw: IStiSignatureDraw;
        image: IStiSignatureImage;
        text: IStiSignatureText;
        type: IStiSignatureType;
        bitmapImageForExport: Image;
        bitmapDrawForExport: Image;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Report.Components {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiPdfDigitalSignature extends StiSignature implements IStiJsonReportObject {
        meta(): StiMeta[];
        get toolboxPosition(): number;
        get localizedName(): string;
        private defaultSignaturePlaceholder;
        placeholder: string;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    let IStiSignatureDraw: System.Interface<IStiSignatureDraw>;
    interface IStiSignatureDraw {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): any;
        image: number[];
        aspectRatio: boolean;
        horAlignment: StiHorAlignment;
        vertAlignment: StiVertAlignment;
        stretch: boolean;
        isDefault(): boolean;
        clone(): any;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    let IStiSignatureImage: System.Interface<IStiSignatureImage>;
    interface IStiSignatureImage {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): any;
        image: number[];
        aspectRatio: boolean;
        horAlignment: StiHorAlignment;
        vertAlignment: StiVertAlignment;
        stretch: boolean;
        isDefault(): boolean;
        clone(): any;
    }
}
export namespace Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    let IStiSignatureText: System.Interface<IStiSignatureText>;
    interface IStiSignatureText {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): any;
        text: string;
        horAlignment: StiTextHorAlignment;
        vertAlignment: StiVertAlignment;
        font: Font;
        color: Color;
        isDefault(): boolean;
        clone(): any;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiSignatureStyle = Stimulsoft.Base.SignatureFonts.StiSignatureStyle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    let IStiSignatureType: System.Interface<IStiSignatureType>;
    interface IStiSignatureType {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): any;
        fullName: string;
        initials: string;
        style: StiSignatureStyle;
        customFont: string;
        isDefault(): boolean;
        clone(): any;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiContourText extends StiText implements IStiJsonReportObject {
        meta(): StiMeta[];
        contourColor: Color;
        size: number;
        constructor(rect?: RectangleD, text?: string);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPointPrimitive extends StiPrimitive implements IStiJsonReportObject {
        meta(): StiMeta[];
        get isSelected(): boolean;
        set isSelected(value: boolean);
        referenceToGuid: string;
        get width(): number;
        set width(value: number);
        get height(): number;
        set height(value: number);
        storedColumn: number;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEndPointPrimitive extends StiPointPrimitive {
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiCap = Stimulsoft.Base.Drawing.StiCap;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHorizontalLinePrimitive extends StiLinePrimitive implements IStiBorder, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        clone(cloneProperties?: boolean): any;
        private _border;
        get border(): StiBorder;
        set border(value: StiBorder);
        startCap: StiCap;
        endCap: StiCap;
        get height(): number;
        set height(value: number);
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRectanglePrimitive extends StiCrossLinePrimitive implements IStiBorder, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        private _border;
        get border(): StiBorder;
        set border(value: StiBorder);
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        getWidth(): number;
        setWidth(value: number): void;
        topSide: boolean;
        leftSide: boolean;
        bottomSide: boolean;
        rightSide: boolean;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRoundedRectanglePrimitive extends StiRectanglePrimitive implements IStiJsonReportObject {
        meta(): StiMeta[];
        private _round;
        get round(): number;
        set round(value: number);
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import IStiBorderColor = Stimulsoft.Report.Components.IStiBorderColor;
    import IStiShape = Stimulsoft.Report.Components.IStiShape;
    class StiShape extends StiComponent implements IStiBrush, IStiBorderColor, IStiExportImageExtended, IStiExportImage, IStiShape, IStiForeColor, IStiFont, IStiTextHorAlignment, IStiVertAlignment, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        clone(cloneProperties: boolean): StiShape;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        text: string;
        getParsedText(): string;
        font: Font;
        horAlignment: StiTextHorAlignment;
        vertAlignment: StiVertAlignment;
        foreColor: Color;
        margins: StiMargins;
        backgroundColor: Color;
        brush: StiBrush;
        borderColor: Color;
        defaultClientRectangle: RectangleD;
        style: StiPenStyle;
        private _size;
        get size(): number;
        set size(value: number);
        shapeType: StiShapeTypeService;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStartPointPrimitive extends StiPointPrimitive {
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiTextInCells extends StiText {
        implements(): any[];
        meta(): StiMeta[];
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        protected static propertyCellWidth: string;
        get cellWidth(): number;
        set cellWidth(value: number);
        protected static propertyCellHeight: string;
        get cellHeight(): number;
        set cellHeight(value: number);
        protected static propertyHorSpacing: string;
        get horSpacing(): number;
        set horSpacing(value: number);
        protected static propertyVertSpacing: string;
        get vertSpacing(): number;
        set vertSpacing(value: number);
        get wordWrap(): boolean;
        set wordWrap(value: boolean);
        get rightToLeft(): boolean;
        set rightToLeft(value: boolean);
        protected static propertyContinuousText: string;
        get continuousText(): boolean;
        set continuousText(value: boolean);
        getActualSize(): SizeD;
        static splitByCells(masterTextInCells: StiTextInCells, renderedComponent: StiComponent, textString: string): StiContainer;
        static splitByCells2(masterTextInCells: StiTextInCells, renderedComponent: StiComponent, textString: string, measure: boolean): StiContainer;
        static replaceContainerWithContentCells(comp: StiComponent, cont: StiContainer): void;
        constructor(rect?: RectangleD, text?: string);
    }
}
export namespace Stimulsoft.Report.Components {
    class StiTextInCellsHelper {
        static trimEndWhiteSpace(inputString: string): string;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiCap = Stimulsoft.Base.Drawing.StiCap;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiVerticalLinePrimitive extends StiCrossLinePrimitive implements IStiBorder, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        clone(cloneProperties: boolean): any;
        private _border;
        get border(): StiBorder;
        set border(value: StiBorder);
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        startCap: StiCap;
        endCap: StiCap;
        getWidth(): number;
        setWidth(value: number): void;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiWebContent extends StiComponent {
        meta(): StiMeta[];
        embedCode: string;
        url: string;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Components.Table {
    let IStiTableComponent: System.Interface<IStiTableComponent>;
    interface IStiTableComponent {
    }
}
export namespace Stimulsoft.Report.Components.Table {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiTableCell extends StiText implements IStiTableCell, IStiTableComponent, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        loadFromJsonObject(jObject: StiJson): void;
        private loadJoinCellsFromXml;
        clone(cloneProperties: boolean): StiTableCell;
        get locked(): boolean;
        set locked(value: boolean);
        get linked(): boolean;
        set linked(value: boolean);
        setCanGrow(value: boolean): void;
        get autoWidth(): boolean;
        set autoWidth(value: boolean);
        cellDockStyle: StiDockStyle;
        parentJoinCell: StiComponent;
        joinCells: number[];
        parentJoin: number;
        _join: boolean;
        get join(): boolean;
        set join(value: boolean);
        id: number;
        joinWidth: number;
        joinHeight: number;
        get merged(): boolean;
        get changeTopPosition(): boolean;
        get changeLeftPosition(): boolean;
        get changeRightPosition(): boolean;
        tableTag: any;
        private _cellType;
        get cellType(): StiTablceCellType;
        set cellType(value: StiTablceCellType);
        fixedWidth: boolean;
        column: number;
        getJoinComponentByGuid(id: number): StiComponent;
        getJoinComponentByIndex(index: number): StiComponent;
        containsGuid(id: number): boolean;
        private createJoin;
        private deleteJoin;
        private getNewClientRectangle;
        setJoinSize(): void;
        getRealHeightAfterInsertRows(): number;
        getRealHeight(): number;
        getRealTop(): number;
        getRealWidth(): number;
        getRealLeft(): number;
    }
}
export namespace Stimulsoft.Report.Components.Table {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiTableCellCheckBox extends StiCheckBox implements IStiTableCell, IStiTableComponent, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        private loadJoinCellsFromXml;
        clone(cloneProperties: boolean): StiTableCellCheckBox;
        get locked(): boolean;
        get linked(): boolean;
        get canShrink(): boolean;
        set canShrink(value: boolean);
        setCanGrow(value: boolean): void;
        cellDockStyle: StiDockStyle;
        parentJoinCell: StiComponent;
        joinCells: number[];
        parentJoin: number;
        _join: boolean;
        get join(): boolean;
        set join(value: boolean);
        id: number;
        joinWidth: number;
        joinHeight: number;
        get merged(): boolean;
        get changeTopPosition(): boolean;
        get changeLeftPosition(): boolean;
        get changeRightPosition(): boolean;
        tableTag: any;
        private _cellType;
        get cellType(): StiTablceCellType;
        set cellType(value: StiTablceCellType);
        fixedWidth: boolean;
        column: number;
        getJoinComponentByGuid(id: number): StiComponent;
        getJoinComponentByIndex(index: number): StiComponent;
        containsGuid(id: number): boolean;
        private createJoin;
        private deleteJoin;
        private getNewClientRectangle;
        setJoinSize(): void;
        getRealHeightAfterInsertRows(): number;
        getRealHeight(): number;
        getRealTop(): number;
        getRealWidth(): number;
        getRealLeft(): number;
    }
}
export namespace Stimulsoft.Report.Components.Table {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiTableCellRichText extends StiRichText implements IStiTableCell, IStiTableComponent, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        private loadJoinCellsFromXml;
        clone(cloneProperties: boolean): StiTableCellRichText;
        get locked(): boolean;
        get linked(): boolean;
        setCanGrow(value: boolean): void;
        cellDockStyle: StiDockStyle;
        parentJoinCell: StiComponent;
        joinCells: number[];
        parentJoin: number;
        _join: boolean;
        get join(): boolean;
        set join(value: boolean);
        id: number;
        joinWidth: number;
        joinHeight: number;
        get merged(): boolean;
        get changeTopPosition(): boolean;
        get changeLeftPosition(): boolean;
        get changeRightPosition(): boolean;
        tableTag: any;
        private _cellType;
        get cellType(): StiTablceCellType;
        set cellType(value: StiTablceCellType);
        fixedWidth: boolean;
        column: number;
        getJoinComponentByGuid(id: number): StiComponent;
        getJoinComponentByIndex(index: number): StiComponent;
        containsGuid(id: number): boolean;
        private createJoin;
        private deleteJoin;
        private getNewClientRectangle;
        setJoinSize(): void;
        getRealHeightAfterInsertRows(): number;
        getRealHeight(): number;
        getRealTop(): number;
        getRealWidth(): number;
        getRealLeft(): number;
        constructor();
    }
}
export namespace Stimulsoft.Report {
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import IStiFontStyle = Stimulsoft.Report.Styles.IStiFontStyle;
    import IStiTitleStyle = Stimulsoft.Report.Styles.IStiTitleStyle;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiTableStyle extends StiBaseStyle implements IStiTitleStyle, IStiFontStyle, IStiGetFonts, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        backColor: Color;
        dataColor: Color;
        dataForeground: Color;
        selectedDataColor: Color;
        selectedDataForeground: Color;
        alternatingDataColor: Color;
        alternatingDataForeground: Color;
        headerColor: Color;
        headerForeground: Color;
        hotHeaderColor: Color;
        footerColor: Color;
        footerForeground: Color;
        gridColor: Color;
        dataBarsOverlapped: Color;
        dataBarsPositive: Color;
        dataBarsNegative: Color;
        winLossPositive: Color;
        winLossNegative: Color;
        sparkline: Color;
        indicatorPositive: Color;
        indicatorNegative: Color;
        indicatorNeutral: Color;
        getFonts(): Font[];
        allowUseFont: boolean;
        font: Font;
        allowUseTitle: boolean;
        titleForeColor: Color;
        titleBackColor: Color;
        titleFont: Font;
        private getColor;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
export namespace Stimulsoft.Report.Components.Table {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiTableStyleIdent = Stimulsoft.Report.Components.Table.StiTableStyleIdent;
    import StiTableStyle = Stimulsoft.Report.StiTableStyle;
    class StiTableStyleFX extends StiTableStyle {
        static createFromJson(styleId: string): StiTableStyleFX;
        static createFromXml(xmlNode: XmlNode): StiTableStyleFX;
        get styleId(): StiTableStyleIdent;
    }
}
export namespace Stimulsoft.Report.Components.Table {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTableStyleIdent = Stimulsoft.Report.Components.Table.StiTableStyleIdent;
    class StiTable21StyleFX extends StiTableStyleFX {
        get styleId(): StiTableStyleIdent;
        headerColor: Color;
        footerColor: Color;
        dataColor: Color;
        dataForeground: Color;
        headerForeground: Color;
        footerForeground: Color;
        gridColor: Color;
    }
}
export namespace Stimulsoft.Report.Components.Table {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTableStyleIdent = Stimulsoft.Report.Components.Table.StiTableStyleIdent;
    class StiTable24StyleFX extends StiTableStyleFX {
        get styleId(): StiTableStyleIdent;
        headerColor: Color;
        footerColor: Color;
        dataColor: Color;
        dataForeground: Color;
        headerForeground: Color;
        footerForeground: Color;
        gridColor: Color;
    }
}
export namespace Stimulsoft.Report.Components.Table {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTableStyleIdent = Stimulsoft.Report.Components.Table.StiTableStyleIdent;
    class StiTable25StyleFX extends StiTableStyleFX {
        get styleId(): StiTableStyleIdent;
        headerColor: Color;
        footerColor: Color;
        dataColor: Color;
        dataForeground: Color;
        headerForeground: Color;
        footerForeground: Color;
        gridColor: Color;
    }
}
export namespace Stimulsoft.Report.Components.Table {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTableStyleIdent = Stimulsoft.Report.Components.Table.StiTableStyleIdent;
    class StiTable26StyleFX extends StiTableStyleFX {
        get styleId(): StiTableStyleIdent;
        headerColor: Color;
        footerColor: Color;
        dataColor: Color;
        dataForeground: Color;
        headerForeground: Color;
        footerForeground: Color;
        gridColor: Color;
    }
}
export namespace Stimulsoft.Report.Components.Table {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTableStyleIdent = Stimulsoft.Report.Components.Table.StiTableStyleIdent;
    class StiTable27StyleFX extends StiTableStyleFX {
        get styleId(): StiTableStyleIdent;
        headerColor: Color;
        footerColor: Color;
        dataColor: Color;
        dataForeground: Color;
        headerForeground: Color;
        footerForeground: Color;
        gridColor: Color;
    }
}
export namespace Stimulsoft.Report.Components.TextFormats {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiBooleanFormatService extends StiFormatService implements IStiJsonReportObject {
        meta(): StiMeta[];
        clone(): any;
        private bits;
        get falseValue(): string;
        set falseValue(value: string);
        get trueValue(): string;
        set trueValue(value: string);
        get falseDisplay(): string;
        set falseDisplay(value: string);
        get trueDisplay(): string;
        set trueDisplay(value: string);
        get nullDisplay(): string;
        set nullDisplay(value: string);
        get sample(): any;
        equals(obj: any): boolean;
        format(arg: any): string;
        format2(stringFormat: string, arg: any): string;
        constructor(falseValue?: string, trueValue?: string, falseDisplay?: string, trueDisplay?: string, nullDisplay?: string);
    }
}
export namespace Stimulsoft.Report.Components.TextFormats {
    class StiNegativeColorChecker {
        static isNegativeInRed(format: StiFormatService): boolean;
    }
}
export namespace Stimulsoft.Report.CrossTab {
    enum StiCrossHorAlignment {
        Left = 0,
        Center = 1,
        Right = 2,
        None = 3,
        Width = 4
    }
}
export namespace Stimulsoft.Report.CrossTab {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiEnumeratorType = Stimulsoft.Report.CrossTab.Core.StiEnumeratorType;
    class StiCrossColumn extends StiCrossHeader implements IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        get localizedName(): string;
        enumeratorType: StiEnumeratorType;
        enumeratorSeparator: string;
    }
}
export namespace Stimulsoft.Report.CrossTab {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiCrossTotal extends StiCrossField {
        implements(): any[];
        meta(): StiMeta[];
        get cellText(): string;
        constructor();
    }
}
export namespace Stimulsoft.Report.CrossTab {
    class StiCrossColumnTotal extends StiCrossTotal {
        get localizedName(): string;
        constructor();
    }
}
export namespace Stimulsoft.Report.CrossTab {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiEnumeratorType = Stimulsoft.Report.CrossTab.Core.StiEnumeratorType;
    class StiCrossRow extends StiCrossHeader implements IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        get localizedName(): string;
        enumeratorType: StiEnumeratorType;
        enumeratorSeparator: string;
        keepMergedCellsTogether: boolean;
        getCrossRowTitle(): StiCrossTitle;
        getCrossRowTotal(): StiCrossRowTotal;
    }
}
export namespace Stimulsoft.Report.CrossTab {
    class StiCrossRowTotal extends StiCrossTotal {
        get localizedName(): string;
        constructor();
    }
}
export namespace Stimulsoft.Report.CrossTab {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiSummaryType = Stimulsoft.Report.CrossTab.Core.StiSummaryType;
    import StiSummaryValues = Stimulsoft.Report.CrossTab.Core.StiSummaryValues;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiCrossSummary extends StiCrossCell implements IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        clone(cloneProperties: boolean): StiCrossSummary;
        protected get defaultHorAlignment(): StiTextHorAlignment;
        aspectRatio: boolean;
        stretch: boolean;
        imageHorAlignment: StiHorAlignment;
        imageVertAlignment: StiVertAlignment;
        crossColumnValue: string;
        crossRowValue: string;
        arguments: Hashtable<string, string>;
        complexExpression: boolean;
        indexOfSelectValue: number;
        get cellText(): string;
        summary: StiSummaryType;
        summaryForFieldsInExpression: boolean;
        summaryValues: StiSummaryValues;
        useStyleOfSummaryInRowTotal: boolean;
        useStyleOfSummaryInColumnTotal: boolean;
        get localizedName(): string;
        showPercents: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.CrossTab {
    class StiCrossSummaryHeader extends StiCrossField {
        get cellText(): string;
        get localizedName(): string;
    }
}
export namespace Stimulsoft.Report.CrossTab.Core {
    import StiCrossTabTopNCondition = Stimulsoft.Report.Components.StiCrossTabTopNCondition;
    import List = Stimulsoft.System.Collections.List;
    import Point = Stimulsoft.System.Drawing.Point;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiGrid {
        private get gridSize();
        report: StiReport;
        fields: Hashtable<StiCrossField, Point>;
        designTime: boolean;
        widths: number[];
        heights: number[];
        coordX: number[];
        coordY: number[];
        cells: StiCell[][];
        get rowCount(): number;
        set rowCount(value: number);
        get colCount(): number;
        set colCount(value: number);
        maxWidth: number;
        maxHeight: number;
        setTextOfCell(x: number, y: number, value: string): void;
        private align;
        private getCellTotalWidth;
        private getCellTotalHeight;
        hasRightCrossTitle(): boolean;
        doAutoSize(): void;
        private getFieldWidth;
        private getFieldHeight;
        setCell(cellX: number, cellY: number, cellWidth: number, cellHeight: number, index: number, text: any, value: any, field: StiCrossField, isNumeric: boolean, hyperlink: any, toolTip: any, tag: any, drillDownParameters: any, level?: number, parentGuid?: string, guid?: string, keepMergedCellsTogether?: boolean, type?: StiCellType, topNConditions?: List<StiCrossTabTopNCondition>): StiCell;
        private addToConversionStore;
        private cellExists;
        setCellField(cellX: number, cellY: number, field: StiCrossField): void;
        init(colCount: number, rowCount: number): void;
    }
}
export namespace Stimulsoft.Report.CrossTab.Core {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiCross extends StiGrid {
        crossTab: StiCrossTab;
        private strNull;
        static emptyField: string;
        emptyField: string;
        private oneCellSize;
        private oneCellWidth;
        private oneCellHeight;
        private summaryDirection;
        private colsHeaderHeight;
        private rowsHeaderWidth;
        private widthCorrection;
        private heightCorrection;
        private colsWidth;
        private rowsHeight;
        private columnsCell;
        private rowsCell;
        private invokeEvents2;
        hasRightCrossTitle(): boolean;
        private invokeEvents;
        private addRowTotal;
        private addColTotal;
        private sortRows;
        private sortCols;
        private createRowTotals;
        private createRowTotals2;
        private createColTotals;
        private createColTotals2;
        private getDataFromDataRow;
        private getValueFromDataRow;
        private getValueFromDataRow2;
        private allowTotal;
        private getRow;
        private getColumn;
        private calculateTopN;
        private processTopNRows;
        private fillOtherRows;
        private processTopNColumns;
        private fillOtherColumns;
        private joinTopNConditions;
        private getSumFiledIndex;
        private getSumFiledIndex2;
        private calculateDataTable;
        private calculateDataRow;
        private copyRows;
        private copyCols;
        private convertToDecimal;
        private isAllowConvertToDecimal;
        private getSummary2;
        private getSummary3;
        private getSummaryResult;
        private getsSummaryResultImageAndNone;
        private getSummaryResultSum;
        private getsSummaryResultMax;
        private getsSummaryResultMin;
        private getsSummaryResultCount;
        private getSummaryResultAverage;
        private getSummaryResultCountDistinct;
        private copySummaries;
        private copySummary;
        private copyArguments;
        private isHideZeros;
        private isDateTime;
        private static convertValueToString;
        private setCellValue;
        private static checkNegativeColor;
        private getColumnTotalCell;
        private getRowTotalCell;
        private getRowsArray;
        private getRowsArray2;
        private getColsArray;
        private getColsArray2;
        private getRowsHeaderWidth;
        private getRowsHeaderWidth2;
        private getColsHeaderHeight;
        private getColsHeaderHeight2;
        private getRowsHeight;
        private getColsWidth;
        private enumerateRows;
        private enumerateColumns;
        private checkSeparators;
        create(table: DataTable, report: StiReport, direction: StiSummaryDirection, emptyValue: string): void;
        clear(): boolean;
        getCorrectedColumnsHeaderHeight(): number;
        private get isSummaryPresent();
        private get isRowTitlePresent();
        private get isTopLinePresent();
        get isTopCrossTitleVisible(): boolean;
        get isLeftCrossTitleVisible(): boolean;
        get isCrossTitleEnabled(): boolean;
        get isCrossTitlePrintOnAllPages(): boolean;
        private get isShowSummarySubHeaders();
        private get isSummarySubHeadersPresent();
        private get isLeftTopLinePresent();
        private get isRightTopLinePresent();
        get isRowsEmpty(): boolean;
        get isColsEmpty(): boolean;
        get isSummariesEmpty(): boolean;
        rows: StiRowCollection;
        cols: StiColumnCollection;
        colTitleFields: StiComponentsCollection;
        rowTitleFields: StiComponentsCollection;
        private _rowFields;
        get rowFields(): StiComponentsCollection;
        set rowFields(value: StiComponentsCollection);
        private _colFields;
        get colFields(): StiComponentsCollection;
        set colFields(value: StiComponentsCollection);
        private _sumFields;
        get sumFields(): StiComponentsCollection;
        set sumFields(value: StiComponentsCollection);
        private _sumHeaderFields;
        get sumHeaderFields(): StiComponentsCollection;
        set sumHeaderFields(value: StiComponentsCollection);
        summaryContainer: StiSummaryContainer;
        leftCrossTitle: StiCrossTitle;
        rightCrossTitle: StiCrossTitle;
        summaryCrossTitle: StiCrossTitle;
    }
}
export namespace Stimulsoft.Report.CrossTab.Core {
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiCell {
        clone(): StiCell;
        size: SizeD;
        isChangeWidthForRightToLeft: boolean;
        isNumeric: boolean;
        isNegativeColor: boolean;
        isImage: boolean;
        field: StiCrossField;
        text: string;
        hyperlinkValue: any;
        toolTipValue: any;
        tagValue: any;
        parentCell: StiCell;
        value: any;
        width: number;
        height: number;
        summaryIndex: number;
        level: number;
        parentGuid: string;
        guid: string;
        isCrossSummary: boolean;
        keepMergedCellsTogether: boolean;
        fieldCloned: boolean;
        cellType: StiCellType;
        drillDownParameters: any;
        constructor();
    }
}
export namespace Stimulsoft.Report.CrossTab {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiCrossTabHelper {
        static getCellRect(masterCrossTab: StiCrossTab, colIndex: number, rowIndex: number): RectangleD;
        static getCellsRect(masterCrossTab: StiCrossTab, startCol: number, startRow: number, endCol: number, endRow: number): SizeD;
        static renderCells(masterCrossTab: StiCrossTab, outContainer: StiContainer, startCol: number, startRow: number, endCol: number, endRow: number, rect: RectangleD): void;
        static createCrossForCrossTabDataSource(masterCrossTab: StiCrossTab): DataTable;
        static buildCrossForCrossTabDataSource(masterCrossTab: StiCrossTab, designTime: boolean): DataTable;
        static buildCross(masterCrossTab: StiCrossTab, designTime: boolean): void;
        static getEndCol(masterCrossTab: StiCrossTab, startCol: number, rect: RectangleD, forceNoBreak: boolean): number;
        static getEndRow(masterCrossTab: StiCrossTab, startRow: number, rect: RectangleD, forceNoBreak: boolean): number;
        static getPageSegmentsRequired(masterCrossTab: StiCrossTab): number;
        static checkMergedRowCells(masterCrossTab: StiCrossTab, startRow: number, endRow: number, startCol: number, endCol: number): number;
        static isColFieldsEmpty(masterCrossTab: StiCrossTab): boolean;
        static isRowFieldsEmpty(masterCrossTab: StiCrossTab): boolean;
        static createCross(masterCrossTab: StiCrossTab): void;
        static isCrossTabRendering: boolean;
        static makeRightToLeft(masterCrossTab: StiCrossTab): void;
        static calculateMaxAndMin(outContainer: StiContainer, REFmaxLeft: any, REFmaxRight: any, startIndex: number): void;
        static makeHorAlignmentByWidth(outContainer: StiContainer, startIndex: number): void;
        static clearCross(masterCrossTab: StiCrossTab): void;
    }
}
export namespace Stimulsoft.Report.CrossTab {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    import StiCross = Stimulsoft.Report.CrossTab.Core.StiCross;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiCrossTabInfo extends StiComponentInfo {
        defaultWidth: number;
        defaultHeight: number;
        startRow: number;
        startCol: number;
        hidedCells: Hashtable;
        cross: StiCross;
        renderRect: RectangleD;
        finishRender: boolean;
    }
}
export namespace Stimulsoft.Report.CrossTab {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCrossTabParams {
        startRow: number;
        startColumn: number;
        renderingIsFinished: boolean;
        allowRendering: boolean;
        destinationRectangle: RectangleD;
        destinationContainer: StiContainer;
        shiftX: number;
        forceNoBreak: boolean;
    }
}
export namespace Stimulsoft.Report.CrossTab {
    import StiCrossTabTopNCondition = Stimulsoft.Report.Components.StiCrossTabTopNCondition;
    import List = Stimulsoft.System.Collections.List;
    class StiCrossTabTopNConditionList {
        private topNConditions;
        private _headerTopNConditions;
        private _cellTopNConditions;
        private _totalTopNConditions;
        get length(): number;
        add(condition: StiCrossTabTopNCondition): void;
        get headerTopNConditions(): List<StiCrossTabTopNCondition>;
        get cellTopNConditions(): List<StiCrossTabTopNCondition>;
        get totalTopNConditions(): List<StiCrossTabTopNCondition>;
    }
}
export namespace Stimulsoft.Report.CrossTab {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiCrossTitle extends StiCrossField implements IStiJsonReportObject {
        meta(): StiMeta[];
        get localizedName(): string;
        printOnAllPages: boolean;
        typeOfComponent: string;
        get cellText(): string;
        constructor();
    }
}
export namespace Stimulsoft.Report.CrossTab.Core {
    class StiColumn {
        hyperlinkValue: any;
        tagValue: any;
        toolTipValue: any;
        drillDownParameters: any;
        isTotal: boolean;
        level: number;
        cols: StiColumnCollection;
        value: any;
        displayValue: any;
        othersText: string;
        parentCollection: StiColumnCollection;
        topNConditions: StiCrossTabTopNConditionList;
        constructor(value: any, displayValue: any);
    }
}
export namespace Stimulsoft.Report.CrossTab.Core {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiColumnCollection extends CollectionBase<StiColumn> {
        private directionFactor;
        private compare;
        private sortType;
        private items;
        add2(value: any, displayValue: any): void;
        add(col: StiColumn): void;
        sort(direction: StiSortDirection, sortType: StiSortType): void;
        clear(): void;
        getByValue(value: any): StiColumn;
    }
}
export namespace Stimulsoft.Report.CrossTab.Core {
    class StiRow {
        hyperlinkValue: any;
        tagValue: any;
        toolTipValue: any;
        drillDownParameters: any;
        isTotal: boolean;
        level: number;
        rows: StiRowCollection;
        value: any;
        displayValue: any;
        othersText: string;
        parentCollection: StiRowCollection;
        topNConditions: StiCrossTabTopNConditionList;
        constructor(value: any, displayValue: any);
    }
}
export namespace Stimulsoft.Report.CrossTab.Core {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiRowCollection extends CollectionBase<StiRow> {
        private directionFactor;
        private compare;
        private sortType;
        private items;
        add2(value: any, displayValue: any): void;
        add(row: StiRow): void;
        clear(): void;
        sort(direction: StiSortDirection, sortType: StiSortType): void;
        getByValue(value: any): StiRow;
    }
}
export namespace Stimulsoft.Report.CrossTab.Core {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiSummary {
        sums: any[][];
        arguments: Hashtable<number, Hashtable<string, any[]>>;
        hyperlinkValues: any[];
        tagValues: any[];
        toolTipValues: any[];
        drillDownParameters: any[];
        complexExpression: boolean;
        constructor(level: number);
    }
}
export namespace Stimulsoft.Report.CrossTab.Core {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiSummaryContainer {
        private level;
        private dataCol;
        getSummary(col: StiColumn, row: StiRow, create?: boolean): StiSummary;
        getArguments(argValues: Hashtable<string, string>): Hashtable<string, any[]>;
        getDataCol(): Hashtable;
        constructor(level: number);
    }
}
export namespace Stimulsoft.Report.CrossTab {
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiGetCrossValueEventArgs extends EventArgs {
        value: any;
    }
}
export namespace Stimulsoft.Report.CrossTab {
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiCell = Stimulsoft.Report.CrossTab.Core.StiCell;
    class StiProcessCellEventArgs extends EventArgs {
        cell: StiCell;
        column: number;
        row: number;
        value: number;
        text: string;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    enum StiElementStyleIdent {
        Auto = 1,
        Blue = 2,
        Orange = 3,
        Green = 4,
        Turquoise = 5,
        SlateGray = 6,
        DarkBlue = 7,
        DarkGray = 8,
        DarkGreen = 9,
        DarkTurquoise = 10,
        Silver = 11,
        AliceBlue = 12,
        Sienna = 13,
        Gray = 14,
        WhiteBlack = 15,
        Custom = 16
    }
    enum StiItemSelectionMode {
        One = 0,
        Multi = 1
    }
    enum StiDateSelectionMode {
        Single = 0,
        Range = 1,
        AutoRange = 2
    }
    enum StiInitialDateRangeSelectionSource {
        Selection = 0,
        Variable = 1
    }
    enum StiInitialDateRangeSelection {
        DayTomorrow = 0,
        DayToday = 1,
        DayYesterday = 2,
        WeekNext = 3,
        WeekCurrent = 4,
        WeekPrevious = 5,
        MonthNext = 6,
        MonthCurrent = 7,
        MonthPrevious = 8,
        QuarterNext = 9,
        QuarterCurrent = 10,
        QuarterPrevious = 11,
        QuarterFirst = 12,
        QuarterSecond = 13,
        QuarterThird = 14,
        QuarterFourth = 15,
        YearNext = 16,
        YearCurrent = 17,
        YearPrevious = 18,
        Last7Days = 19,
        Last14Days = 20,
        Last30Days = 21,
        DateToWeek = 22,
        DateToMonth = 23,
        DateToQuarter = 24,
        DateToYear = 25
    }
    enum StiProgressElementMode {
        Pie = 0,
        Circle = 1,
        DataBars = 2
    }
    enum StiDateCondition {
        EqualTo = 0,
        NotEqualTo = 1,
        GreaterThan = 2,
        GreaterThanOrEqualTo = 3,
        LessThan = 4,
        LessThanOrEqualTo = 5
    }
    enum StiNumberCondition {
        EqualTo = 0,
        NotEqualTo = 1,
        GreaterThan = 2,
        GreaterThanOrEqualTo = 3,
        LessThan = 4,
        LessThanOrEqualTo = 5
    }
    enum StiNumberSelectionMode {
        Single = 1,
        Range = 2
    }
    enum StiNumberMinMaxMode {
        Auto = 1,
        Custom = 2
    }
    enum StiTableSizeMode {
        AutoSize = 0,
        Fit = 1
    }
    enum StiChartLabelsPosition {
        None = 0,
        Center = 1,
        InsideBase = 2,
        InsideEnd = 3,
        Left = 4,
        Outside = 5,
        OutsideBase = 6,
        OutsideEnd = 7,
        OutsideLeft = 8,
        OutsideRight = 9,
        Right = 10,
        TwoColumns = 11,
        Value = 12,
        Total = 13
    }
    enum StiInteractionIdent {
        Chart = 1,
        CardsColumn = 2,
        Gauge = 3,
        Image = 4,
        Indicator = 5,
        OnlineMap = 6,
        Page = 7,
        PivotTable = 8,
        PivotTableItem = 9,
        Progress = 10,
        RegionMap = 11,
        Table = 12,
        TableColumn = 13,
        Text = 14,
        Cards = 15,
        Shape = 16,
        Filter = 17
    }
    enum StiAvailableInteractionOnHover {
        ShowToolTip = 1,
        ShowHyperlink = 2,
        None = 0,
        All = 3
    }
    enum StiAvailableInteractionOnClick {
        ShowDashboard = 1,
        OpenHyperlink = 2,
        ApplyFilter = 4,
        DrillDown = 8,
        None = 0,
        All = 15
    }
    enum StiAvailableInteractionOnDataManipulation {
        AllowSorting = 1,
        AllowFiltering = 2,
        AllowDrillDown = 4,
        All = 7,
        None = 0
    }
    enum StiInteractionOnHover {
        None = 0,
        ShowToolTip = 1,
        ShowHyperlink = 2
    }
    enum StiInteractionOnClick {
        None = 0,
        ShowDashboard = 1,
        OpenHyperlink = 2,
        ApplyFilter = 3,
        DrillDown = 4
    }
    enum StiInteractionOpenHyperlinkDestination {
        NewTab = 0,
        CurrectTab = 1
    }
    enum StiElementMeterAction {
        None = 0,
        Rename = 1,
        Delete = 2,
        ClearAll = 3
    }
    enum StiOnlineMapLocationType {
        Auto = 0,
        AdminDivision1 = 1,
        AdminDivision2 = 2,
        CountryRegion = 3,
        Neighborhood = 4,
        PopulatedPlace = 5,
        Postcode1 = 6,
        Postcode2 = 7,
        Postcode3 = 8,
        Postcode4 = 9
    }
    enum StiGeoMapProviderType {
        OpenStreetMap = 0,
        OpenCycleMap = 1,
        OpenCycleMapLandscape = 2,
        OpenCycleMapTransport = 3,
        Wikimapia = 4,
        Bing = 5,
        BingSatellite = 6,
        BingHybrid = 7,
        BingOS = 8,
        Google = 9,
        GoogleSatellite = 10,
        GoogleTerrain = 11,
        GoogleChina = 12,
        GoogleChinaSatellite = 13,
        GoogleChinaTerrain = 14,
        YandexMap = 15,
        YandexSatelliteMap = 16,
        Czech = 17,
        CzechSatellite = 18,
        CzechTurist = 19,
        CzechTuristWinter = 20,
        CzechGeographic = 21,
        ArcGISStreetMapWorld2D = 22
    }
    enum StiOnlineMapLocationColorType {
        Single = 0,
        ColorEach = 1,
        Group = 2,
        Value = 3
    }
    enum StiOnlineMapValueViewMode {
        Bubble = 0,
        Value = 1,
        Icon = 2,
        Chart = 3
    }
    enum StiOnlineMapCulture {
        ar_SA = 0,
        eu = 1,
        bg = 2,
        bg_BG = 3,
        ca = 4,
        ku_Arab = 5,
        zh_CN = 6,
        zh_HK = 7,
        zh_Hans = 8,
        zh_TW = 9,
        zh_Hant = 10,
        cs = 11,
        cs_CZ = 12,
        da = 13,
        da_DK = 14,
        nl_BE = 15,
        nl = 16,
        nl_NL = 17,
        en_AU = 18,
        en_CA = 19,
        en_IN = 20,
        en_GB = 21,
        en_US = 22,
        fi = 23,
        fi_FI = 24,
        fr_BE = 25,
        fr_CA = 26,
        fr = 27,
        fr_FR = 28,
        fr_CH = 29,
        gl = 30,
        de = 31,
        de_DE = 32,
        el = 33,
        he = 34,
        he_IL = 35,
        hi = 36,
        hi_IN = 37,
        hu = 38,
        hu_HU = 39,
        is_IS = 40,
        it = 41,
        it_IT = 42,
        ja = 43,
        ja_JP = 44,
        ko = 45,
        Ko_KR = 46,
        ky_Cyrl = 47,
        lv = 48,
        lv_LV = 49,
        lt = 50,
        lt_LT = 51,
        nb = 52,
        nb_NO = 53,
        nn = 54,
        pl = 55,
        pl_PL = 56,
        pt_BR = 57,
        pt_P = 58,
        ru = 59,
        ru_RU = 60,
        es_MX = 61,
        es = 62,
        es_ES = 63,
        es_US = 64,
        sv = 65,
        sv_SE = 66,
        tt_Cyrl = 67,
        th = 68,
        th_TH = 69,
        tr = 70,
        tr_TR = 71,
        uk = 72,
        uk_UA = 73,
        ug_Arab = 74,
        ca_ES_valencia = 75,
        vi = 76,
        vi_VN = 77
    }
    enum StiIconAlignment {
        None = 0,
        Left = 1,
        Right = 2,
        Top = 3,
        Bottom = 4,
        Center = 5
    }
    enum StiIndicatorFieldCondition {
        Value = 0,
        Series = 1,
        Target = 2,
        Variation = 3
    }
    enum StiProgressFieldCondition {
        Value = 0,
        Series = 1,
        Target = 2,
        Percentage = 3
    }
    enum StiProgressValueType {
        None = 0,
        Percentage = 1,
        Value = 2,
        ValueTarget = 3
    }
    enum StiProgressConditionPermissions {
        None = 0,
        Font = 1,
        FontSize = 2,
        FontStyleBold = 4,
        FontStyleItalic = 8,
        FontStyleUnderline = 16,
        FontStyleStrikeout = 32,
        TextColor = 64,
        Color = 128,
        TrackColor = 256,
        All = 511
    }
    enum StiIndicatorConditionPermissions {
        None = 0,
        Font = 1,
        FontSize = 2,
        FontStyleBold = 4,
        FontStyleItalic = 8,
        FontStyleUnderline = 16,
        FontStyleStrikeout = 32,
        TextColor = 64,
        BackColor = 128,
        Borders = 256,
        Icon = 512,
        TargetIcon = 1024,
        All = 2047
    }
    enum StiTableConditionPermissions {
        None = 0,
        Font = 1,
        FontSize = 2,
        FontStyleBold = 4,
        FontStyleItalic = 8,
        FontStyleUnderline = 16,
        FontStyleStrikeout = 32,
        ForeColor = 64,
        BackColor = 128,
        All = 255
    }
    enum StiTargetMode {
        Percentage = 0,
        Variation = 1
    }
    enum StiIndicatorValueType {
        Value = 0,
        ValueTarget = 1
    }
    enum StiChartTrendLineType {
        None = 0,
        Exponential = 1,
        Linear = 2,
        Logarithmic = 3
    }
    enum StiChartSeriesType {
        ClusteredColumn = 1,
        StackedColumn = 2,
        FullStackedColumn = 3,
        ClusteredColumn3D = 4,
        StackedColumn3D = 5,
        FullStackedColumn3D = 6,
        Pareto = 7,
        Histogram = 8,
        Line = 9,
        Line3D = 10,
        StackedLine = 11,
        FullStackedLine = 12,
        Spline = 13,
        StackedSpline = 14,
        FullStackedSpline = 15,
        SteppedLine = 16,
        Area = 17,
        StackedArea = 18,
        FullStackedArea = 19,
        SplineArea = 20,
        StackedSplineArea = 21,
        FullStackedSplineArea = 22,
        SteppedArea = 23,
        Range = 24,
        SplineRange = 25,
        SteppedRange = 26,
        RangeBar = 27,
        ClusteredBar = 28,
        StackedBar = 29,
        FullStackedBar = 30,
        Scatter = 31,
        ScatterLine = 32,
        ScatterSpline = 33,
        Ribbon = 34,
        Pie = 35,
        Pie3d = 36,
        RadarPoint = 37,
        RadarLine = 38,
        RadarArea = 39,
        Funnel = 40,
        FunnelWeightedSlices = 41,
        Candlestick = 42,
        Stock = 43,
        Heatmap = 44,
        Treemap = 45,
        Gantt = 46,
        Doughnut = 47,
        Bubble = 48,
        Pictorial = 49,
        PictorialStacked = 50,
        Sunburst = 51,
        Waterfall = 52,
        BoxAndWhisker = 53
    }
    enum StiEmptyCellsAs {
        Gap = 0,
        Zero = 1,
        ConnectPointsWithLine = 2
    }
    enum StiFontSizeMode {
        Auto = 0,
        Value = 1,
        Target = 2
    }
    enum StiLabelPlacement {
        Outside = 0,
        Inside = 1
    }
    enum StiItemFilterMode {
        SelectedOnly = 0,
        FullPath = 1
    }
    enum StiItemOrientation {
        Vertical = 0,
        Horizontal = 1
    }
    enum StiDashboardContentAlignment {
        Left = 0,
        Center = 1,
        Right = 2,
        StretchXY = 3,
        StretchX = 4
    }
    enum StiIndicatorIconMode {
        Auto = 1,
        Custom = 2
    }
    enum StiIndicatorIconRangeMode {
        Percentage = 1,
        Value = 2
    }
    enum StiTextSizeMode {
        Fit = 1,
        FitAndWordWrap = 2,
        WordWrap = 3,
        Trimming = 4
    }
    enum StiButtonStretch {
        StretchXY = 0,
        StretchX = 1
    }
    enum StiPivotTableConditionType {
        Condition = 0,
        TopN = 1
    }
    enum StiButtonType {
        Button = 0,
        CheckBox = 1,
        RadioButton = 2
    }
    enum StiInteractionViewsState {
        Always = 0,
        OnHover = 1
    }
    enum StiListBoxSelectionType {
        ListBox = 0,
        RadioButton = 1
    }
    enum StiDashboardScaleMode {
        PaperSize = 0,
        ViewSize = 1,
        DesignSize = 2
    }
    enum StiFilterInclusionMode {
        Always = 0,
        SelectionOnly = 1
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiAllowUserColumnSelectionDashboardInteraction: System.Interface<IStiAllowUserColumnSelectionDashboardInteraction>;
    interface IStiAllowUserColumnSelectionDashboardInteraction {
        allowUserColumnSelection: boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiAllowUserDrillDownDashboardInteraction: System.Interface<IStiAllowUserDrillDownDashboardInteraction>;
    interface IStiAllowUserDrillDownDashboardInteraction {
        allowUserDrillDown: boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiAllowUserFilteringDashboardInteraction: System.Interface<IStiAllowUserFilteringDashboardInteraction>;
    interface IStiAllowUserFilteringDashboardInteraction {
        allowUserFiltering: boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiAllowUserSortingDashboardInteraction: System.Interface<IStiAllowUserSortingDashboardInteraction>;
    interface IStiAllowUserSortingDashboardInteraction {
        allowUserSorting: boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    let IStiAltProperties: System.Interface<IStiAltProperties>;
    let ImplementsIStiAltProperties: any[];
    interface IStiAltProperties {
        altTitleVisible: boolean;
        altClientRectangle: RectangleD;
        altParentKey: string;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IAsIs = Stimulsoft.System.IAsIs;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import IStiReportComponent = Stimulsoft.Base.IStiReportComponent;
    import IStiQueryObject = Stimulsoft.Data.Engine.IStiQueryObject;
    let IStiElement: System.Interface<IStiElement>;
    let ImplementsIStiElement: any[];
    interface IStiElement extends IStiReportComponent, IStiQueryObject, IAsIs {
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        getNestedPages(): List<StiPage>;
        key: string;
        report: StiReport;
        page: StiPage;
        name: string;
        zoom: number;
        isDefined: boolean;
        isDesigning: boolean;
        isEnabledAsync(): Promise<boolean>;
        isQuerable: boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiDashboardElementStyle: System.Interface<IStiDashboardElementStyle>;
    let ImplementsIStiDashboardElementStyle: any[];
    interface IStiDashboardElementStyle {
        style: StiElementStyleIdent;
        customStyleName: string;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    let IStiConvertibleElement: System.Interface<IStiConvertibleElement>;
    let ImplementsIStiConvertibleElement: any[];
    interface IStiConvertibleElement {
        convertFrom(element: IStiElement): any;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiFilterInclusionMode = Stimulsoft.Report.Dashboard.StiFilterInclusionMode;
    import List = Stimulsoft.System.Collections.List;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import IStiConvertibleElement = Stimulsoft.Report.Dashboard.IStiConvertibleElement;
    import IStiAppCell = Stimulsoft.Base.IStiAppCell;
    let IStiFilterElement: System.Interface<IStiFilterElement>;
    let ImplementsIStiFilterElement: any[];
    interface IStiFilterElement extends IStiAppCell, IStiConvertibleElement {
        getParentKey(): string;
        setParentKey(key: string): any;
        applyDefaultFilters(): Promise<void>;
        getIdentityFilters(): List<StiDataFilterRule>;
        selectedValue: any;
        selectedKey: string;
        selectedLabel: string;
        selectedIndex: number;
        inclusionMode: StiFilterInclusionMode;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import IStiDashboardElementStyle = Stimulsoft.Report.Dashboard.IStiDashboardElementStyle;
    import IStiFilterElement = Stimulsoft.Report.Dashboard.IStiFilterElement;
    import IStiUserFilters = Stimulsoft.Data.Engine.IStiUserFilters;
    import IStiBackColor = Stimulsoft.Report.Components.IStiBackColor;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    let IStiControlElement: System.Interface<IStiControlElement>;
    let ImplementsIStiControlElement: any[];
    interface IStiControlElement extends IStiElement, IStiDashboardElementStyle, IStiUserFilters, IStiFilterElement, IStiFont, IStiForeColor, IStiBackColor, IStiTextFormat {
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiButtonElementIconSet = Stimulsoft.Report.Dashboard.IStiButtonElementIconSet;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiIconAlignment = Stimulsoft.Report.Dashboard.StiIconAlignment;
    import StiButtonType = Stimulsoft.Report.Dashboard.StiButtonType;
    import StiButtonShapeType = Stimulsoft.Base.Drawing.StiButtonShapeType;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import IStiSimpleBorder = Stimulsoft.Report.Components.IStiSimpleBorder;
    import IStiSimpleShadow = Stimulsoft.Report.Components.IStiSimpleShadow;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    let IStiButtonElement: System.Interface<IStiButtonElement>;
    let ImplementsIStiButtonElement: any[];
    interface IStiButtonElement extends IStiControlElement, IStiCornerRadius, IStiSimpleShadow, IStiSimpleBorder, IStiFont {
        text: string;
        group: string;
        checked: boolean;
        shapeType: StiButtonShapeType;
        type: StiButtonType;
        iconAlignment: StiIconAlignment;
        stretch: StiButtonStretch;
        iconBrush: StiBrush;
        getIconSet(): IStiButtonElementIconSet;
        getVisualStates(): IStiButtonVisualStates;
        invokeCheckedChanged(sender: any, e: any): any;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    let IStiButtonElementIconSet: System.Interface<IStiButtonElementIconSet>;
    let ImplementsIStiButtonElementIconSet: any[];
    interface IStiButtonElementIconSet {
        icon: StiFontIcons;
        checkedIcon: StiFontIcons;
        uncheckedIcon: StiFontIcons;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiButtonElementIconSet = Stimulsoft.Report.Dashboard.IStiButtonElementIconSet;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiButtonVisualState: System.Interface<IStiButtonVisualState>;
    let ImplementsIStiButtonVisualState: any[];
    interface IStiButtonVisualState {
        brush: StiBrush;
        textBrush: StiBrush;
        iconBrush: StiBrush;
        border: StiSimpleBorder;
        font: Font;
        getIconSet(): IStiButtonElementIconSet;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiButtonVisualState = Stimulsoft.Report.Dashboard.IStiButtonVisualState;
    let IStiButtonVisualStates: System.Interface<IStiButtonVisualStates>;
    let ImplementsIStiButtonVisualStates: any[];
    interface IStiButtonVisualStates {
        getHoverState(): IStiButtonVisualState;
        getPressedState(): IStiButtonVisualState;
        getCheckedState(): IStiButtonVisualState;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiGroupElement: System.Interface<IStiGroupElement>;
    let ImplementsIStiGroupElement: any[];
    interface IStiGroupElement {
        group: string;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    let IStiCardsElement: System.Interface<IStiCardsElement>;
    let ImplementsIStiCardsElement: any[];
    interface IStiCardsElement extends IStiElement, IStiDashboardElementStyle, IStiDataFilters, IStiConvertibleElement {
        createMeters(cardsElement: IStiCardsElement): any;
        createMeters2(dataSource: StiDataSource): any;
        createMeter(cell: IStiAppDataCell): any;
        removeMeter(index: number): any;
        removeAllMeters(): any;
        insertMeter(index: number, meter: IStiMeter): any;
        insertNewDimension(index: number): any;
        insertNewMeasure(index: number): any;
        getMeasure(cell: IStiAppDataCell): IStiMeter;
        getDimension(cell: IStiAppDataCell): IStiMeter;
        getCards(): IStiCardsItem;
        backColor: Color;
        columnCount: number;
        orientation: StiItemOrientation;
        crossFiltering: boolean;
        showBlanks: boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    let IStiCardsItem: System.Interface<IStiCardsItem>;
    let ImplementsIStiCardsItem: any[];
    interface IStiCardsItem {
        colorEach: boolean;
        cornerRadius: StiCornerRadius;
        padding: StiPadding;
        margin: StiMargin;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiChartArea: System.Interface<IStiChartArea>;
    let ImplementsIStiChartArea: any[];
    interface IStiChartArea {
        horSpacing: number;
        vertSpacing: number;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiChartConstantLines: System.Interface<IStiChartConstantLines>;
    let ImplementsIStiChartConstantLines: any[];
    interface IStiChartConstantLines {
        text: string;
        lineStyle: StiPenStyle;
        lineColor: Color;
        axisValue: string;
        lineWidth: number;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    let IStiChartDashboardInteraction: System.Interface<IStiChartDashboardInteraction>;
    let ImplementsIStiChartDashboardInteraction: System.Interface<IStiDashboardInteraction>[];
    interface IStiChartDashboardInteraction extends IStiDashboardInteraction {
        viewsState: StiInteractionViewsState;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    let IStiManuallyEnteredData: System.Interface<IStiManuallyEnteredData>;
    let ImplementsIStiManuallyEnteredData: any[];
    interface IStiManuallyEnteredData {
        dataMode: StiDataMode;
        manuallyEnteredData: string;
        getManuallyEnteredDataTable(): StiDataTable;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiColumnShape3D = Stimulsoft.Report.Chart.StiColumnShape3D;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    import IStiCrossFiltering = Stimulsoft.Data.Engine.IStiCrossFiltering;
    import StiMarkerType = Stimulsoft.Report.Chart.StiMarkerType;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiUserSorts = Stimulsoft.Data.Engine.IStiUserSorts;
    import IStiChartElementCondition = Stimulsoft.Report.Dashboard.IStiChartElementCondition;
    import IStiConvertibleElement = Stimulsoft.Report.Dashboard.IStiConvertibleElement;
    import IStiDataTransformationElement = Stimulsoft.Data.Engine.IStiDataTransformationElement;
    import IStiDataTopN = Stimulsoft.Data.Engine.IStiDataTopN;
    import IStiGroupElement = Stimulsoft.Report.Dashboard.IStiGroupElement;
    import IStiDashboardElementStyle = Stimulsoft.Report.Dashboard.IStiDashboardElementStyle;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiUserFilters = Stimulsoft.Data.Engine.IStiUserFilters;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiChartConditionalField = Stimulsoft.Report.Chart.StiChartConditionalField;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import IStiManuallyEnteredData = Stimulsoft.Report.Dashboard.IStiManuallyEnteredData;
    let IStiChartElement: System.Interface<IStiChartElement>;
    let ImplementsIStiChartElement: any[];
    interface IStiChartElement extends IStiElement, IStiUserFilters, IStiUserSorts, IStiDashboardElementStyle, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiDataTopN, IStiDataTransformationElement, IStiGroupElement, IStiCrossFiltering, IStiDataFilters, IStiConvertibleElement, IStiManuallyEnteredData {
        addValue(cell: IStiAppDataCell): any;
        getValue2(cell: IStiAppDataCell): IStiMeter;
        getValue(meter: IStiMeter): IStiMeter;
        getGanttStartValue(cell: IStiAppDataCell): IStiMeter;
        getGanttEndValue(cell: IStiAppDataCell): IStiMeter;
        getY(cell: IStiAppDataCell): IStiMeter;
        getX(cell: IStiAppDataCell): IStiMeter;
        getValueByIndex(index: number): IStiMeter;
        fetchAllValues(): List<IStiMeter>;
        insertValue(index: number, meter: IStiMeter): any;
        removeValue(index: number): any;
        removeAllValues(): any;
        createNewValue(): IStiMeter;
        addEndValue(cell: IStiAppDataCell): any;
        getEndValue2(cell: IStiAppDataCell): IStiMeter;
        getEndValue(meter: IStiMeter): IStiMeter;
        getEndValueByIndex(index: number): IStiMeter;
        insertEndValue(index: number, meter: IStiMeter): any;
        removeEndValue(index: number): any;
        removeAllEndValues(): any;
        createNewEndValue(): IStiMeter;
        addCloseValue(cell: IStiAppDataCell): any;
        getCloseValue2(cell: IStiAppDataCell): IStiMeter;
        getCloseValue(meter: IStiMeter): IStiMeter;
        getCloseValueByIndex(index: number): IStiMeter;
        insertCloseValue(index: number, meter: IStiMeter): any;
        removeCloseValue(index: number): any;
        removeAllCloseValues(): any;
        createNewCloseValue(): IStiMeter;
        addLowValue(cell: IStiAppDataCell): any;
        getLowValue2(cell: IStiAppDataCell): IStiMeter;
        getLowValue(meter: IStiMeter): IStiMeter;
        getLowValueByIndex(index: number): IStiMeter;
        insertLowValue(index: number, meter: IStiMeter): any;
        removeLowValue(index: number): any;
        removeAllLowValues(): any;
        createNewLowValue(): IStiMeter;
        addHighalue(cell: IStiAppDataCell): any;
        getHighValue2(cell: IStiAppDataCell): IStiMeter;
        getHighValue(meter: IStiMeter): IStiMeter;
        getHighValueByIndex(index: number): IStiMeter;
        insertHighValue(index: number, meter: IStiMeter): any;
        removeHighValue(index: number): any;
        removeAllHighValues(): any;
        createNewHighValue(): IStiMeter;
        addXValue(cell: IStiAppDataCell): any;
        getXValue2(cell: IStiAppDataCell): IStiMeter;
        getXValue(meter: IStiMeter): IStiMeter;
        getXValueByIndex(index: number): IStiMeter;
        insertXValue(index: number, meter: IStiMeter): any;
        removeXValue(index: number): any;
        removeAllXValues(): any;
        createNewXValue(): IStiMeter;
        fetchAllXValues(): List<IStiMeter>;
        addYValue(cell: IStiAppDataCell): any;
        getYValue2(cell: IStiAppDataCell): IStiMeter;
        getYValue(meter: IStiMeter): IStiMeter;
        getYValueByIndex(index: number): IStiMeter;
        insertYValue(index: number, meter: IStiMeter): any;
        removeYValue(index: number): any;
        removeAllYValues(): any;
        createNewYValue(): IStiMeter;
        fetchAllYValues(): List<IStiMeter>;
        addArgument(cell: IStiAppDataCell): any;
        getArgument2(cell: IStiAppDataCell): IStiMeter;
        getArgument(meter: IStiMeter): IStiMeter;
        getArgumentByIndex(index: number): IStiMeter;
        fetchAllArguments(): List<IStiMeter>;
        insertArgument(index: number, meter: IStiMeter): any;
        removeArgument(index: number): any;
        removeAllArguments(): any;
        createNewArgument(): any;
        addWeight(cell: IStiAppDataCell): any;
        getWeight2(cell: IStiAppDataCell): IStiMeter;
        getWeight(meter: IStiMeter): IStiMeter;
        getWeightByIndex(index: number): IStiMeter;
        insertWeight(index: number, meter: IStiMeter): any;
        removeWeight(index: number): any;
        removeAllWeights(): any;
        createNewWeight(): any;
        addSeries(cell: IStiAppDataCell): any;
        getSeries2(cell: IStiAppDataCell): IStiMeter;
        getSeries(meter: IStiMeter): IStiMeter;
        getSeries3(): IStiMeter;
        insertSeries(meter: IStiMeter): any;
        removeSeries(): any;
        createNewSeries(): any;
        addSortBy(cell: IStiAppDataCell): any;
        getSortBy2(cell: IStiAppDataCell): IStiMeter;
        getSortBy(meter: IStiMeter): IStiMeter;
        getSortBy3(): IStiMeter;
        insertSortBy(meter: IStiMeter): any;
        removeSortBy(): any;
        createNewSortBy(): any;
        addIndicatorValue(cell: IStiAppDataCell): any;
        getIndicatorValue2(cell: IStiAppDataCell): IStiMeter;
        getIndicatorValue(meter: IStiMeter): IStiMeter;
        getIndicatorValue3(): IStiMeter;
        insertIndicatorValue(meter: IStiMeter): any;
        removeIndicatorValue(): any;
        createNewIndicatorValue(): any;
        fetchConstantLines(): List<IStiChartConstantLines>;
        addConstantLine(): any;
        removeConstantLine(index: number): any;
        moveConstantLine(fromIndex: number, toIndex: number): any;
        fetchStrips(): List<IStiChartStrips>;
        addStrip(): any;
        removeStrip(index: number): any;
        moveStrip(fromIndex: number, toIndex: number): any;
        addTrendLines(keyValueMeter: string, type: StiChartTrendLineType, lineColor: Color, lineStyle: StiPenStyle, lineWidth: number): any;
        fetchTrendLines(): List<IStiChartTrendLine>;
        clearTrendLines(): any;
        addChartCondition(keyValueMeter: string, dataType: StiFilterDataType, condition: StiFilterCondition, value: string, color: Color, markerType: StiMarkerType, markerAngle: number, field: StiChartConditionalField, isExpression: boolean): any;
        fetchChartConditions(): List<IStiChartElementCondition>;
        clearChartConditions(): any;
        convertToBubble(): any;
        convertFromBubble(): any;
        convertToGantt(): any;
        checkBrowsableProperties(): any;
        getChartSeriesTypes(seriesTypeStr: string): List<string>;
        getChartSeries(): IStiSeries;
        getManuallyEnteredChartMeter(): IStiMeter;
        isAxisAreaChart: boolean;
        isAxisAreaChart3D: boolean;
        isClusteredBarChart: boolean;
        isClusteredColumnChart: boolean;
        isClusteredColumnChart3D: boolean;
        isScatterChart: boolean;
        isStackedChart: boolean;
        isLinesChart: boolean;
        isBubbleChart: boolean;
        isBarChart: boolean;
        isFinancial: boolean;
        isPieChart: boolean;
        isPie3dChart: boolean;
        isDoughnutChart: boolean;
        isFunnelChart: boolean;
        isTreemapChart: boolean;
        isParetoChart: boolean;
        isSunburstChart: boolean;
        isFullStackedChart: boolean;
        isWaterfallChart: boolean;
        isPictorialStackedChart: boolean;
        isRadarChart: boolean;
        isRange: boolean;
        isLineChart3D: boolean;
        isPictorialChart: boolean;
        isHeatmapChart: boolean;
        argumentFormat: StiFormatService;
        valueFormat: StiFormatService;
        colorEach: boolean;
        icon: StiFontIcons;
        roundValues: boolean;
        columnShape: StiColumnShape3D;
        previousAnimations: List<StiAnimation>;
        sortAnimation: boolean;
        showBlanks: boolean;
        showViewTitle: boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiMarkerType = Stimulsoft.Report.Chart.StiMarkerType;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    let IStiChartElementCondition: System.Interface<IStiChartElementCondition>;
    let ImplementsIStiChartElementCondition: any[];
    interface IStiChartElementCondition {
        keyValueMeter: string;
        dataType: StiFilterDataType;
        condition: StiFilterCondition;
        value: string;
        color: Color;
        markerType: StiMarkerType;
        markerAngle: number;
        isExpression: boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiChartLabels: System.Interface<IStiChartLabels>;
    let ImplementsIStiChartLabels: any[];
    interface IStiChartLabels {
        position: StiChartLabelsPosition;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiStrips_StiOrientation = Stimulsoft.Report.Chart.StiStrips_StiOrientation;
    let IStiChartStrips: System.Interface<IStiChartStrips>;
    let ImplementsIStiChartStrips: any[];
    interface IStiChartStrips {
        text: string;
        titleColor: Color;
        stripBrush: StiBrush;
        orientation: StiStrips_StiOrientation;
        minValue: string;
        maxValue: string;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    interface IStiChartTrendLine {
        keyValueMeter: string;
        type: StiChartTrendLineType;
        lineStyle: StiPenStyle;
        lineColor: Color;
        lineWidth: number;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiItemElement: System.Interface<IStiItemElement>;
    let ImplementsIStiItemElement: any[];
    interface IStiItemElement {
        selectionMode: StiItemSelectionMode;
        showAllValue: boolean;
        showBlanks: boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiItemElement = Stimulsoft.Report.Dashboard.IStiItemElement;
    import IStiGroupElement = Stimulsoft.Report.Dashboard.IStiGroupElement;
    import IStiControlElement = Stimulsoft.Report.Dashboard.IStiControlElement;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    let IStiComboBoxElement: System.Interface<IStiComboBoxElement>;
    let ImplementsIStiComboBoxElement: any[];
    interface IStiComboBoxElement extends IStiControlElement, IStiItemElement, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiDataFilters {
        addKeyMeter2(cell: IStiAppDataCell): any;
        addKeyMeter(meter: IStiMeter): any;
        getKeyMeter(): IStiMeter;
        removeKeyMeter(): any;
        createNewKeyMeter(): any;
        addNameMeter2(cell: IStiAppDataCell): any;
        addNameMeter(meter: IStiMeter): any;
        getNameMeter(): IStiMeter;
        removeNameMeter(): any;
        createNewNameMeter(): any;
        createNextMeter(cell: IStiAppDataCell): any;
        initialValue: string;
        fixedHeight: boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiBackColor = Stimulsoft.Report.Components.IStiBackColor;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    let IStiPanel: System.Interface<IStiPanel>;
    let ImplementsIStiPanel: any[];
    interface IStiPanel extends IStiElement, IStiBackColor {
        getElements(nested: boolean, group: string): List<IStiElement>;
        getMeters(nested?: boolean, group?: string): List<IStiMeter>;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IAsIs = Stimulsoft.System.IAsIs;
    import List = Stimulsoft.System.Collections.List;
    import IStiPanel = Stimulsoft.Report.Dashboard.IStiPanel;
    import IStiDashboardElementStyle = Stimulsoft.Report.Dashboard.IStiDashboardElementStyle;
    import IStiQueryObject = Stimulsoft.Data.Engine.IStiQueryObject;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDashboardViewMode = Stimulsoft.Report.Components.StiDashboardViewMode;
    import StiSurfaceViewMode = Stimulsoft.Report.Components.StiSurfaceViewMode;
    let IStiDashboard: System.Interface<IStiDashboard>;
    let ImplementsIStiDashboard: any[];
    interface IStiDashboard extends IStiPanel, IStiQueryObject, IStiDashboardElementStyle, IAsIs {
        getUserFilters(element: IStiElement): List<StiDataFilterRule>;
        dashboardViewMode: StiDashboardViewMode;
        getUnplacedElements(): List<IStiElement>;
        switchSurfaceViewMode(value: StiSurfaceViewMode): any;
        removeMobileSurface(): any;
        deviceWidth: number;
        isMobileSurfacePresent: boolean;
        width: number;
        height: number;
        contentAlignment: StiDashboardContentAlignment;
        invokeRefreshing(): any;
        invokeBeginRender(): any;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiDashboardDrillDownParameter: System.Interface<IStiDashboardDrillDownParameter>;
    let ImplementsIStiDashboardDrillDownParameter: any[];
    interface IStiDashboardDrillDownParameter {
        name: string;
        expression: string;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IAsIs = Stimulsoft.System.IAsIs;
    import List = Stimulsoft.System.Collections.List;
    import ICloneable = Stimulsoft.System.ICloneable;
    let IStiDashboardInteraction: System.Interface<IStiDashboardInteraction>;
    let ImplementsIStiDashboardInteraction: System.Interface<ICloneable>[];
    interface IStiDashboardInteraction extends ICloneable, IAsIs {
        ident: StiInteractionIdent;
        onHover: StiInteractionOnHover;
        onClick: StiInteractionOnClick;
        hyperlinkDestination: StiInteractionOpenHyperlinkDestination;
        toolTip: string;
        hyperlink: string;
        drillDownPageKey: string;
        isDefault(): boolean;
        getDrillDownParameters(): List<IStiDashboardDrillDownParameter>;
        setDrillDownParameters(drillDownParameters: any[]): any;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiAdvancedWatermark = Stimulsoft.Base.Drawing.StiAdvancedWatermark;
    import IStiApp = Stimulsoft.Base.IStiApp;
    let IStiDashboardWatermark: System.Interface<IStiDashboardWatermark>;
    let ImplementsIStiDashboardWatermark: any[];
    interface IStiDashboardWatermark {
        dashboardWatermark: StiAdvancedWatermark;
        watermarkStyle: string;
        getApp(): IStiApp;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import StiInitialDateRangeSelectionSource = Stimulsoft.Report.Dashboard.StiInitialDateRangeSelectionSource;
    let IStiDatePickerElement: System.Interface<IStiDatePickerElement>;
    let ImplementsIStiDatePickerElement: any[];
    interface IStiDatePickerElement extends IStiControlElement, IStiDataFilters {
        addValueMeter2(cell: IStiAppDataCell): any;
        addValueMeter(meter: IStiMeter): any;
        getValueMeter(): IStiMeter;
        removeValueMeter(): any;
        createNewValueMeter(): any;
        condition: StiDateCondition;
        selectionMode: StiDateSelectionMode;
        initialRangeSelection: StiInitialDateRangeSelection;
        initialRangeSelectionSource: StiInitialDateRangeSelectionSource;
        fixedHeight: boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    let IStiElementInteraction: System.Interface<IStiElementInteraction>;
    interface IStiElementInteraction {
        dashboardInteraction: IStiDashboardInteraction;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    let IStiElementLayout: System.Interface<IStiElementLayout>;
    let ImplementsIStiElementLayout: any[];
    interface IStiElementLayout {
        layout: StiElementLayout;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiFixedHeightElement: System.Interface<IStiFixedHeightElement>;
    let ImplementsIStiFixedHeightElement: any[];
    interface IStiFixedHeightElement {
        isFixedHeight: boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import DateTime = Stimulsoft.System.DateTime;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    import IStiCrossFiltering = Stimulsoft.Data.Engine.IStiCrossFiltering;
    import IStiUserSorts = Stimulsoft.Data.Engine.IStiUserSorts;
    import IStiConvertibleElement = Stimulsoft.Report.Dashboard.IStiConvertibleElement;
    import StiGaugeType = Stimulsoft.Report.Gauge.StiGaugeType;
    import StiGaugeCalculationMode = Stimulsoft.Report.Gauge.StiGaugeCalculationMode;
    import StiGaugeRangeMode = Stimulsoft.Report.Gauge.StiGaugeRangeMode;
    import StiGaugeRangeType = Stimulsoft.Report.Gauge.StiGaugeRangeType;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import IStiManuallyEnteredData = Stimulsoft.Report.Dashboard.IStiManuallyEnteredData;
    let IStiGaugeElement: System.Interface<IStiGaugeElement>;
    let ImplementsIStiGaugeElement: any[];
    interface IStiGaugeElement extends IStiElement, IStiUserSorts, IStiDashboardElementStyle, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiCrossFiltering, IStiDataFilters, IStiConvertibleElement, IStiManuallyEnteredData {
        addValue2(cell: IStiAppDataCell): any;
        addValue(meter: IStiMeter): any;
        removeValue(): any;
        getValue(): IStiMeter;
        getValue2(meter: IStiMeter): IStiMeter;
        createNewValue(): any;
        addSeries2(cell: IStiAppDataCell): any;
        addSeries(meter: IStiMeter): any;
        removeSeries(): any;
        getSeries(): IStiMeter;
        getSeries2(meter: IStiMeter): IStiMeter;
        createNewSeries(): any;
        addTarget2(cell: IStiAppDataCell): any;
        addTarget(meter: IStiMeter): any;
        removeTarget(): any;
        getTarget(): IStiMeter;
        getTarget2(meter: IStiMeter): IStiMeter;
        createNewTarget(): any;
        rangeType: StiGaugeRangeType;
        rangeMode: StiGaugeRangeMode;
        getRanges(): List<IStiGaugeRange>;
        addRange(): IStiGaugeRange;
        removeRange(index: number): any;
        createdDefaultRanges(): any;
        calculationMode: StiGaugeCalculationMode;
        type: StiGaugeType;
        minimumValue: string;
        maximumValue: string;
        minimumDateTime: DateTime;
        maximumDateTime: DateTime;
        shortValue: boolean;
        valueFormat: StiFormatService;
        showBlanks: boolean;
        dateTimeMode: boolean;
        previousAnimations: List<StiAnimation>;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiLabelRotationMode = Stimulsoft.Report.Gauge.StiLabelRotationMode;
    let IStiGaugeLabels: System.Interface<IStiGaugeLabels>;
    let ImplementsIStiGaugeLabels: any[];
    interface IStiGaugeLabels {
        visible: boolean;
        placement: StiLabelPlacement;
        rotationMode: StiLabelRotationMode;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiGaugeRange: System.Interface<IStiGaugeRange>;
    let ImplementsIStiGaugeRange: any[];
    interface IStiGaugeRange {
        color: Color;
        start: number;
        end: number;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    let IStiGaugeTarget: System.Interface<IStiGaugeTarget>;
    let ImplementsIStiGaugeTarget: any[];
    interface IStiGaugeTarget {
        showLabel: boolean;
        placement: StiPlacement;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    interface IStiHtmlTextHelper {
        setFontName(textObj: any, text: string, fontName: string, defaultColor: Color): string;
        setFontSize(textObj: any, text: string, fontSize: number, defaultColor: Color): string;
        growFontSize(textObj: any, text: string, defaultColor: Color): string;
        shrinkFontSize(textObj: any, text: string, defaultColor: Color): string;
        setFontBoldStyle(textObj: any, text: string, isBold: boolean, defaultColor: Color): string;
        setFontItalicStyle(textObj: any, text: string, isItalic: boolean, defaultColor: Color): string;
        setFontUnderlineStyle(textObj: any, text: string, isUnderline: boolean, defaultColor: Color): string;
        setColor(textObj: any, text: string, color: Color, defaultColor: Color): string;
        setHorAlignment(textObj: any, text: string, alignment: StiTextHorAlignment, defaultColor: Color): string;
        getFont(textObj: any, text: string, defaultColor: Color): Font;
        getColor(textObj: any, text: string, defaultColor: Color): Color;
        getHorAlign(textObj: any, text: string, defaultColor: Color): StiTextHorAlignment;
        getSimpleText(htmlText: string, defaultColor: Color): string;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiCrossFiltering = Stimulsoft.Data.Engine.IStiCrossFiltering;
    import Color = Stimulsoft.System.Drawing.Color;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    let IStiImageElement: System.Interface<IStiImageElement>;
    let ImplementsIStiImageElement: any[];
    interface IStiImageElement extends IStiElement, IStiGroupElement, IStiCrossFiltering {
        image: Image;
        imageHyperlink: string;
        aspectRatio: boolean;
        icon: StiFontIcons;
        iconColor: Color;
        style: string;
        copyAllImageProperties(element: IStiImageElement): any;
        isImageHyperlinkDataColumnDefined: boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiIndicatorIconRangeMode = Stimulsoft.Report.Dashboard.StiIndicatorIconRangeMode;
    import StiIndicatorIconMode = Stimulsoft.Report.Dashboard.StiIndicatorIconMode;
    import IStiCrossFiltering = Stimulsoft.Data.Engine.IStiCrossFiltering;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiUserSorts = Stimulsoft.Data.Engine.IStiUserSorts;
    import List = Stimulsoft.System.Collections.List;
    import StiIconAlignment = Stimulsoft.Report.Dashboard.StiIconAlignment;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import IStiDataTransformationElement = Stimulsoft.Data.Engine.IStiDataTransformationElement;
    import IStiDataTopN = Stimulsoft.Data.Engine.IStiDataTopN;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import StiFontIconSet = Stimulsoft.Report.Helpers.StiFontIconSet;
    import StiTargetMode = Stimulsoft.Report.Dashboard.StiTargetMode;
    import IStiManuallyEnteredData = Stimulsoft.Report.Dashboard.IStiManuallyEnteredData;
    let IStiIndicatorElement: System.Interface<IStiIndicatorElement>;
    let ImplementsIStiIndicatorElement: any[];
    interface IStiIndicatorElement extends IStiElement, IStiUserSorts, IStiDashboardElementStyle, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiDataTopN, IStiDataTransformationElement, IStiGroupElement, IStiCrossFiltering, IStiDataFilters, IStiManuallyEnteredData {
        addValue2(cell: IStiAppDataCell): any;
        addValue(meter: IStiMeter): any;
        removeValue(): any;
        getValue(): IStiMeter;
        getValue2(meter: IStiMeter): IStiMeter;
        createNewValue(): any;
        addTarget2(cell: IStiAppDataCell): any;
        addTarget(meter: IStiMeter): any;
        removeTarget(): any;
        getTarget(): IStiMeter;
        getTarget2(meter: IStiMeter): IStiMeter;
        createNewTarget(): any;
        addSeries2(cell: IStiAppDataCell): any;
        addSeries(meter: IStiMeter): any;
        removeSeries(): any;
        getSeries(): IStiMeter;
        getSeries2(meter: IStiMeter): IStiMeter;
        createNewSeries(): any;
        addIndicatorCondition(field: StiIndicatorFieldCondition, condition: StiFilterCondition, value: string, icon: StiFontIcons, iconColor: Color, targetIcon: StiFontIcons, targetIconColor: Color, customIcon: number[], iconAlignment: StiIconAlignment, targetIconAlignment: StiIconAlignment, permissions: StiIndicatorConditionPermissions, font: Font, textColor: Color, backColor: Color): any;
        fetchIndicatorConditions(): List<IStiIndicatorElementCondition>;
        clearIndicatorConditions(): any;
        iconSet: StiFontIconSet;
        icon: StiFontIcons;
        iconAlignment: StiIconAlignment;
        glyphColor: Color;
        customIcon: number[];
        targetMode: StiTargetMode;
        fontSizeMode: StiFontSizeMode;
        font: Font;
        iconMode: StiIndicatorIconMode;
        iconRangeMode: StiIndicatorIconRangeMode;
        showBlanks: boolean;
        targetFormat: StiFormatService;
        valueType: StiIndicatorValueType;
        getIconRanges(): List<IStiIndicatorIconRange>;
        addRange(): IStiIndicatorIconRange;
        removeRange(index: number): any;
        createdDefaultRanges(): any;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    let IStiIndicatorElementCondition: System.Interface<IStiIndicatorElementCondition>;
    let ImplementsIStiIndicatorElementCondition: any[];
    interface IStiIndicatorElementCondition {
        field: StiIndicatorFieldCondition;
        condition: StiFilterCondition;
        value: string;
        iconAlignment: StiIconAlignment;
        targetIconAlignment: StiIconAlignment;
        iconColor: Color;
        icon: StiFontIcons;
        customIcon: number[];
        permissions: StiIndicatorConditionPermissions;
        font: Font;
        textColor: Color;
        backColor: Color;
        targetIconColor: Color;
        targetIcon: StiFontIcons;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    let IStiIndicatorIconRange: System.Interface<IStiIndicatorIconRange>;
    let ImplementsStiIndicatorIconRange: any[];
    interface IStiIndicatorIconRange {
        icon: StiFontIcons;
        startExpression: string;
        endExpression: string;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiInteractionLayout: System.Interface<IStiInteractionLayout>;
    interface IStiInteractionLayout {
        showFullScreenButton: boolean;
        showSaveButton: boolean;
        showViewDataButton: boolean;
        headerText: string;
        footerText: string;
        fileName: string;
        isDefaultLayout: boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiInteractionPivotLayout: System.Interface<IStiInteractionPivotLayout>;
    interface IStiInteractionPivotLayout {
        showCollapseAllButton: boolean;
        showExpandAllButton: boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiListBoxSelectionType = Stimulsoft.Report.Dashboard.StiListBoxSelectionType;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    let IStiListBoxElement: System.Interface<IStiListBoxElement>;
    let ImplementsIStiListBoxElement: any[];
    interface IStiListBoxElement extends IStiControlElement, IStiItemElement, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiDataFilters {
        addKeyMeter2(cell: IStiAppDataCell): any;
        addKeyMeter(meter: IStiMeter): any;
        getKeyMeter(): IStiMeter;
        removeKeyMeter(): any;
        createNewKeyMeter(): any;
        addNameMeter2(cell: IStiAppDataCell): any;
        addNameMeter(meter: IStiMeter): any;
        getNameMeter(): IStiMeter;
        removeNameMeter(): any;
        createNewNameMeter(): any;
        createNextMeter(cell: IStiAppDataCell): any;
        orientation: StiItemOrientation;
        selectionType: StiListBoxSelectionType;
        initialValue: string;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiMargin: System.Interface<IStiMargin>;
    let ImplementsIStiMargin: any[];
    interface IStiMargin {
        margin: StiMargin;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiMeterRules: System.Interface<IStiMeterRules>;
    interface IStiMeterRules {
        checkRules(): void;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiNegativeSeriesColors: System.Interface<IStiNegativeSeriesColors>;
    let ImplementsIStiNegativeSeriesColors: any[];
    interface IStiNegativeSeriesColors {
        negativeSeriesColors: Color[];
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    let IStiNumberBoxElement: System.Interface<IStiNumberBoxElement>;
    let ImplementsIStiNumberBoxElement: any[];
    interface IStiNumberBoxElement extends IStiControlElement, IStiDataFilters {
        addValueMeter2(cell: IStiAppDataCell): any;
        addValueMeter(meter: IStiMeter): any;
        getValueMeter(): IStiMeter;
        removeValueMeter(): any;
        createNewValueMeter(): any;
        condition: StiNumberCondition;
        selectionMode: StiNumberSelectionMode;
        minMaxMode: StiNumberMinMaxMode;
        initialValue: string;
        initialToValue: string;
        min: string;
        max: string;
        decimalDigits: number;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiCrossFiltering = Stimulsoft.Data.Engine.IStiCrossFiltering;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiOnlineMapElement: System.Interface<IStiOnlineMapElement>;
    let ImplementsIStiOnlineMapElement: any[];
    interface IStiOnlineMapElement extends IStiElement, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiCrossFiltering, IStiDataFilters {
        createNextMeter(cell: IStiAppDataCell): any;
        addLatitudeMeter2(cell: IStiAppDataCell): any;
        addLatitudeMeter(meter: IStiMeter): any;
        getLatitudeMeter(): IStiMeter;
        removeLatitudeMeter(): any;
        createNewLatitudeMeter(): any;
        addLongitudeMeter2(cell: IStiAppDataCell): any;
        addLongitudeMeter(meter: IStiMeter): any;
        getLongitudeMeter(): IStiMeter;
        removeLongitudeMeter(): any;
        createNewLongitudeMeter(): any;
        addLocationMeter2(cell: IStiAppDataCell): any;
        addLocationMeter(meter: IStiMeter): any;
        getLocationMeter(): IStiMeter;
        removeLocationMeter(): any;
        createNewLocationMeter(): any;
        addLocationColorMeter2(cell: IStiAppDataCell): any;
        addLocationColorMeter(meter: IStiMeter): any;
        getLocationColorMeter(): IStiMeter;
        removeLocationColorMeter(): any;
        createNewLocationColorMeter(): any;
        addLocationValueMeter2(cell: IStiAppDataCell): any;
        addLocationValueMeter(meter: IStiMeter): any;
        getLocationValueMeter(): IStiMeter;
        removeLocationValueMeter(): any;
        createNewLocationValueMeter(): any;
        addLocationArgumentMeter(cell: IStiAppDataCell): any;
        addLocationArgumentMeter2(meter: IStiMeter): any;
        getLocationArgumentMeter(): IStiMeter;
        removeLocationArgumentMeter(): any;
        createNewLocationArgumentMeter(): any;
        locationType: StiOnlineMapLocationType;
        culture: StiOnlineMapCulture;
        locationColor: Color;
        locationColorType: StiOnlineMapLocationColorType;
        valueViewMode: StiOnlineMapValueViewMode;
        icon: StiFontIcons;
        iconColor: Color;
        customIcon: number[];
        onePointZoom: number;
        userBingKey: string;
        provider: StiGeoMapProviderType;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiPadding: System.Interface<IStiPadding>;
    let ImplementsIStiPadding: any[];
    interface IStiPadding {
        padding: StiPadding;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiPanelElement: System.Interface<IStiPanelElement>;
    let ImplementsIStiPanelElement: any[];
    interface IStiPanelElement {
        style: string;
        watermarkStyle: string;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiParetoSeriesColors: System.Interface<IStiParetoSeriesColors>;
    let ImplementsIStiParetoSeriesColors: any[];
    interface IStiParetoSeriesColors {
        paretoSeriesColors: Color[];
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    let IStiPivotTableCreator: System.Interface<IStiPivotTableCreator>;
    let ImplementsIStiPivotTableCreator: any[];
    interface IStiPivotTableCreator {
        create(element: IStiPivotTableElement, dataTable: StiDataTable): any;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiPivotGridContainer: System.Interface<IStiPivotGridContainer>;
    let ImplementsIStiPivotGridContainer: any[];
    interface IStiPivotGridContainer {
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    let IStiPivotItem: System.Interface<IStiPivotItem>;
    let ImplementsIStiPivotItem: any[];
    interface IStiPivotItem extends IStiElementInteraction {
        visibility: StiTableColumnVisibility;
        visibilityExpression: string;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiPivotTableCells: System.Interface<IStiTableSection>;
    let ImplementsIStiPivotTableCells: any[];
    interface IStiPivotTableCells {
        getColumns(): IStiTableSection;
        getRows(): IStiTableSection;
        getData(): IStiTableSection;
        getTotals(): IStiTableSection;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiPivotTableCells = Stimulsoft.Report.Dashboard.IStiPivotTableCells;
    import StiDataTopNMode = Stimulsoft.Data.Engine.StiDataTopNMode;
    import StiConditionPermissions = Stimulsoft.Report.Components.StiConditionPermissions;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiCrossFiltering = Stimulsoft.Data.Engine.IStiCrossFiltering;
    import StiSummaryDirection = Stimulsoft.Report.CrossTab.Core.StiSummaryDirection;
    import IStiConvertibleElement = Stimulsoft.Report.Dashboard.IStiConvertibleElement;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import List = Stimulsoft.System.Collections.List;
    let IStiPivotTableElement: System.Interface<IStiPivotTableElement>;
    let ImplementsIStiPivotTableElement: any[];
    interface IStiPivotTableElement extends IStiElement, IStiDashboardElementStyle, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiCrossFiltering, IStiDataFilters, IStiConvertibleElement {
        createNewColumn(): any;
        getColumn2(cell: IStiAppDataCell): IStiMeter;
        getColumn(meter: IStiMeter): IStiMeter;
        getColumnByIndex(index: number): IStiMeter;
        insertColumn(index: number, meter: IStiMeter): any;
        removeColumn(index: number): any;
        removeAllColumns(): any;
        createNewRow(): any;
        getRow2(cell: IStiAppDataCell): IStiMeter;
        getRow(meter: IStiMeter): IStiMeter;
        getRowByIndex(index: number): IStiMeter;
        insertRow(index: number, meter: IStiMeter): any;
        removeRow(index: number): any;
        removeAllRows(): any;
        createNewSummary(): any;
        getSummary2(cell: IStiAppDataCell): IStiMeter;
        getSummary(meter: IStiMeter): IStiMeter;
        getSummaryByIndex(index: number): IStiMeter;
        insertSummary(index: number, meter: IStiMeter): any;
        removeSummary(index: number): any;
        removeAllSummaries(): any;
        createNextMeter(cell: IStiAppDataCell): any;
        pivotTableConditions: List<IStiPivotTableElementCondition>;
        summaryDirection: StiSummaryDirection;
        getAllMeters(): List<IStiMeter>;
        addPivotTableCondition(keyValueMeter: string, destinationValueMeter: string, dataType: Stimulsoft.Report.Components.StiFilterDataType, condition: Stimulsoft.Report.Components.StiFilterCondition, value: string, font: Font, textColor: Color, backColor: Color, permissions: StiConditionPermissions, icon: StiFontIcons, iconAlignment: StiIconAlignment, customIcon: number[], iconColor: Color, conditionType: StiPivotTableConditionType, topNMode: StiDataTopNMode, topNCount: number, measureField: string, topNConditionCell: boolean, topNConditionHeader: boolean, topNConditionTotal: boolean): any;
        getUsedMeters(): List<IStiMeter>;
        getCells(): IStiPivotTableCells;
        getColumnFont(): Font;
        getRowFont(): Font;
        getDataFont(): Font;
        getTotalFont(): Font;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiDataTopNMode = Stimulsoft.Data.Engine.StiDataTopNMode;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Size = Stimulsoft.System.Drawing.Size;
    import StiConditionPermissions = Stimulsoft.Report.Components.StiConditionPermissions;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiPivotTableElementCondition: System.Interface<IStiPivotTableElementCondition>;
    let ImplementsIStiPivotTableElementCondition: System.Interface<IStiJsonReportObject>[];
    interface IStiPivotTableElementCondition extends IStiJsonReportObject, ICloneable {
        keyValueMeter: string;
        destinationValueMeter: string;
        dataType: StiFilterDataType;
        condition: StiFilterCondition;
        value: string;
        textColor: Color;
        backColor: Color;
        font: Font;
        permissions: StiConditionPermissions;
        customIcon: number[];
        icon: StiFontIcons;
        iconAlignment: StiIconAlignment;
        iconSize: Size;
        iconColor: Color;
        getIcon(): Promise<number[]>;
        conditionType: StiPivotTableConditionType;
        topNMode: StiDataTopNMode;
        topNCount: number;
        measureField: string;
        topNConditionCell: boolean;
        topNConditionHeader: boolean;
        topNConditionTotal: boolean;
        getUniqueCode(): number;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiCrossFiltering = Stimulsoft.Data.Engine.IStiCrossFiltering;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiUserSorts = Stimulsoft.Data.Engine.IStiUserSorts;
    import IStiConvertibleElement = Stimulsoft.Report.Dashboard.IStiConvertibleElement;
    import IStiDataTransformationElement = Stimulsoft.Data.Engine.IStiDataTransformationElement;
    import IStiDataTopN = Stimulsoft.Data.Engine.IStiDataTopN;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import List = Stimulsoft.System.Collections.List;
    import IStiManuallyEnteredData = Stimulsoft.Report.Dashboard.IStiManuallyEnteredData;
    let IStiProgressElement: System.Interface<IStiProgressElement>;
    let ImplementsIStiProgressElement: any[];
    interface IStiProgressElement extends IStiElement, IStiUserSorts, IStiDashboardElementStyle, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiDataTopN, IStiDataTransformationElement, IStiGroupElement, IStiCrossFiltering, IStiDataFilters, IStiConvertibleElement, IStiManuallyEnteredData {
        colorEach: boolean;
        addValue2(cell: IStiAppDataCell): any;
        addValue(meter: IStiMeter): any;
        removeValue(): any;
        getValue(): IStiMeter;
        getValue2(meter: IStiMeter): IStiMeter;
        createNewValue(): any;
        addTarget2(cell: IStiAppDataCell): any;
        addTarget(meter: IStiMeter): any;
        removeTarget(): any;
        getTarget(): IStiMeter;
        getTarget2(meter: IStiMeter): IStiMeter;
        createNewTarget(): any;
        addSeries2(cell: IStiAppDataCell): any;
        addSeries(meter: IStiMeter): any;
        removeSeries(): any;
        getSeries(): IStiMeter;
        getSeries2(meter: IStiMeter): IStiMeter;
        createNewSeries(): any;
        addProgressCondition(field: StiProgressFieldCondition, condition: StiFilterCondition, value: string, permissions: StiProgressConditionPermissions, font: Font, textColor: Color, color: Color, trackColor: Color): any;
        fetchProgressConditions(): List<IStiProgressElementCondition>;
        clearProgressConditions(): any;
        mode: StiProgressElementMode;
        font: Font;
        showBlanks: boolean;
        valueType: StiProgressValueType;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import Font = Stimulsoft.System.Drawing.Font;
    let IStiProgressElementCondition: System.Interface<IStiProgressElementCondition>;
    let ImplementsIStiProgressElementCondition: any[];
    interface IStiProgressElementCondition {
        condition: StiFilterCondition;
        field: StiProgressFieldCondition;
        value: string;
        permissions: StiProgressConditionPermissions;
        textColor: Color;
        color: Color;
        trackColor: Color;
        font: Font;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import IStiManuallyEnteredData = Stimulsoft.Report.Dashboard.IStiManuallyEnteredData;
    import IStiCrossFiltering = Stimulsoft.Data.Engine.IStiCrossFiltering;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import IStiUserFilters = Stimulsoft.Data.Engine.IStiUserFilters;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import StiMapSource = Stimulsoft.Report.Maps.StiMapSource;
    import StiMapType = Stimulsoft.Report.Maps.StiMapType;
    import StiMapData = Stimulsoft.Report.Maps.StiMapData;
    import StiDisplayNameType = Stimulsoft.Report.Maps.StiDisplayNameType;
    import StiMapLabels = Stimulsoft.Report.Maps.StiMapLabels;
    let IStiRegionMapElement: System.Interface<IStiRegionMapElement>;
    let ImplementsIStiRegionMapElement: any[];
    interface IStiRegionMapElement extends IStiElement, IStiDashboardElementStyle, IStiManuallyEnteredData, IStiUserFilters, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiCrossFiltering, IStiDataFilters {
        mapIdent: string;
        dataFrom: StiMapSource;
        mapData: string;
        mapType: StiMapType;
        showValue: boolean;
        colorEach: boolean;
        showBubble: boolean;
        shortValue: boolean;
        showZeros: boolean;
        show3D: boolean;
        valueFormat: StiFormatService;
        showName: StiDisplayNameType;
        language: string;
        labels: StiMapLabels;
        getMapData(): List<StiMapData>;
        createNextMeter(cell: IStiAppDataCell): any;
        addKeyMeter2(cell: IStiAppDataCell): any;
        addKeyMeter(meter: IStiMeter): any;
        getKeyMeter(): IStiMeter;
        removeKeyMeter(): any;
        createNewKeyMeter(): any;
        addNameMeter2(cell: IStiAppDataCell): any;
        addNameMeter(meter: IStiMeter): any;
        getNameMeter(): IStiMeter;
        removeNameMeter(): any;
        createNewNameMeter(): any;
        addValueMeter2(cell: IStiAppDataCell): any;
        addValueMeter(meter: IStiMeter): any;
        getValueMeter(): IStiMeter;
        removeValueMeter(): any;
        createNewValueMeter(): any;
        addGroupMeter2(cell: IStiAppDataCell): any;
        addGroupMeter(meter: IStiMeter): any;
        getGroupMeter(): IStiMeter;
        removeGroupMeter(): any;
        createNewGroupMeter(): any;
        addColorMeter2(cell: IStiAppDataCell): any;
        addColorMeter(meter: IStiMeter): any;
        getColorMeter(): IStiMeter;
        removeColorMeter(): any;
        createNewColorMeter(): any;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiSeriesColors: System.Interface<IStiSeriesColors>;
    let ImplementsIStiSeriesColors: any[];
    interface IStiSeriesColors {
        seriesColors: Color[];
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiShapeTypeService = Stimulsoft.Report.Components.StiShapeTypeService;
    let IStiShapeElement: System.Interface<IStiShapeElement>;
    let ImplementsIStiShapeElement: any[];
    interface IStiShapeElement extends IStiElement {
        shapeType: StiShapeTypeService;
        stroke: Color;
        fill: StiBrush;
        size: number;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiSkipOwnFilter: System.Interface<IStiSkipOwnFilter>;
    let ImplementsIStiSkipOwnFilter: any[];
    interface IStiSkipOwnFilter {
        allowSkipOwnFilter: boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiTableCells: System.Interface<IStiTableSection>;
    let ImplementsIStiTableCells: any[];
    interface IStiTableCells {
        getColumns(): IStiTableSection;
        getData(): IStiTableSection;
        getTotals(): IStiTableSection;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiTableColumnSize = Stimulsoft.Report.Dashboard.StiTableColumnSize;
    let IStiTableColumnSize: System.Interface<IStiTitle>;
    let ImplementsIStiTableColumnSize: any[];
    interface IStiTableColumnSize {
        size: StiTableColumnSize;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    let IStiTableDashboardInteraction: System.Interface<IStiTableDashboardInteraction>;
    let ImplementsIStiTableDashboardInteraction: System.Interface<IStiDashboardInteraction>[];
    interface IStiTableDashboardInteraction extends IStiDashboardInteraction {
        allowUserSorting: boolean;
        allowUserFiltering: boolean;
        drillDownFiltered: boolean;
        fullRowSelect: boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import IStiCrossFiltering = Stimulsoft.Data.Engine.IStiCrossFiltering;
    import List = Stimulsoft.System.Collections.List;
    import IStiConvertibleElement = Stimulsoft.Report.Dashboard.IStiConvertibleElement;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiUserFilters = Stimulsoft.Data.Engine.IStiUserFilters;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import IStiUserSorts = Stimulsoft.Data.Engine.IStiUserSorts;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTableSizeMode = Stimulsoft.Report.Dashboard.StiTableSizeMode;
    let IStiTableElement: System.Interface<IStiTableElement>;
    let ImplementsIStiTableElement: any[];
    interface IStiTableElement extends IStiElement, IStiUserSorts, IStiUserFilters, IStiDashboardElementStyle, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiCrossFiltering, IStiDataFilters, IStiFont, IStiConvertibleElement {
        createMeters(tableElement: IStiTableElement): any;
        createMeters2(dataSource: StiDataSource): any;
        createMeter3(cell: IStiAppDataCell): any;
        removeMeter(index: number): any;
        removeAllMeters(): any;
        insertMeter(index: number, meter: IStiMeter): any;
        insertNewDimension(index: number): any;
        insertNewMeasure(index: number): any;
        getMeasure(cell: IStiAppDataCell): IStiMeter;
        getDimension(cell: IStiAppDataCell): IStiMeter;
        headerFont: Font;
        headerForeColor: Color;
        sizeMode: StiTableSizeMode;
        rowsPerPage: number;
        pageTurnTime: number;
        foreColor: Color;
        footerFont: Font;
        footerForeColor: Color;
        tableConditions: List<IStiTableElementCondition>;
        currentPageIndex: number;
        addTableCondition(keyDataFieldMeters: string[], keyDestinationMeters: string[], dataType: Stimulsoft.Report.Components.StiFilterDataType, condition: Stimulsoft.Report.Components.StiFilterCondition, value: string, permissions: StiTableConditionPermissions, font: Font, foreColor: Color, backColor: Color, isExpression: boolean, icon?: StiFontIcons, iconAlignment?: StiIconAlignment, customIcon?: number[], iconColor?: Color): any;
        getCells(): IStiTableCells;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiTableElementAutoSizer: System.Interface<IStiTableElementAutoSizer>;
    let ImplementsIStiTableElementAutoSizer: any[];
    interface IStiTableElementAutoSizer {
        autoMeasureToTable(tableElement: IStiTableElement): any;
        autoMeasureToColumn(tableElement: IStiTableElement): any;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    let IStiTableElementCondition: System.Interface<IStiTableElementCondition>;
    let ImplementsIStiTableElementCondition: any[];
    interface IStiTableElementCondition {
        keyDataFieldMeters: string[];
        keyDestinationMeters: string[];
        dataType: StiFilterDataType;
        condition: StiFilterCondition;
        value: string;
        permissions: StiTableConditionPermissions;
        font: Font;
        foreColor: Color;
        backColor: Color;
        isExpression: boolean;
        icon: StiFontIcons;
        iconColor: Color;
        iconAlignment: StiIconAlignment;
        customIcon: number[];
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    let IStiTableSection: System.Interface<IStiTableSection>;
    let ImplementsIStiTableSection: any[];
    interface IStiTableSection {
        backColor: Color;
        foreColor: Color;
        font: Font;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import List = Stimulsoft.System.Collections.List;
    import IStiTextMeasureMeter = Stimulsoft.Base.Meters.IStiTextMeasureMeter;
    import StiTextSizeMode = Stimulsoft.Report.Dashboard.StiTextSizeMode;
    import IStiCrossFiltering = Stimulsoft.Data.Engine.IStiCrossFiltering;
    let IStiTextElement: System.Interface<IStiTextElement>;
    let ImplementsIStiTextElement: any[];
    interface IStiTextElement extends IStiElement, IStiGroupElement, IStiCrossFiltering {
        text: string;
        sizeMode: StiTextSizeMode;
        getSimpleText(): string;
        crossFiltering: boolean;
        style: string;
        rightToLeft: boolean;
        getMeasures(): List<IStiTextMeasureMeter>;
        addMeasure(): any;
        getMeasure(cell: IStiAppDataCell): IStiTextMeasureMeter;
        removeMeasure(index: number): any;
        removeAllMeasures(): any;
        insertMeasure(index: number, meter: IStiTextMeasureMeter): any;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiTextSizeMode = Stimulsoft.Report.Dashboard.StiTextSizeMode;
    import IStiBackColor = Stimulsoft.Report.Components.IStiBackColor;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    let IStiTitle: System.Interface<IStiTitle>;
    let ImplementsIStiTitle: any[];
    interface IStiTitle extends IStiFont, IStiHorAlignment, IStiForeColor, IStiBackColor {
        text: string;
        visible: boolean;
        sizeMode: StiTextSizeMode;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiTitleElement: System.Interface<IStiTitleElement>;
    let ImplementsIStiTitleElement: any[];
    interface IStiTitleElement {
        title: IStiTitle;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiTitlePadding = Stimulsoft.Report.Dashboard.StiTitlePadding;
    let IStiTitlePadding: System.Interface<IStiTitlePadding>;
    let ImplementsIStiTitlePadding: any[];
    interface IStiTitlePadding {
        padding: StiTitlePadding;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiItemFilterMode = Stimulsoft.Report.Dashboard.StiItemFilterMode;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    let IStiTreeViewBoxElement: System.Interface<IStiTreeViewBoxElement>;
    let ImplementsIStiTreeViewBoxElement: any[];
    interface IStiTreeViewBoxElement extends IStiControlElement, IStiItemElement, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiDataFilters {
        getKeyMeter(cell: IStiAppDataCell): IStiMeter;
        getKeyMeterByIndex(index: number): IStiMeter;
        insertKeyMeter(index: number, meter: IStiMeter): any;
        removeKeyMeter(index: number): any;
        removeAllKeyMeters(): any;
        addKey(cell: IStiAppDataCell): any;
        addNewKeyMeter(): IStiMeter;
        fixedHeight: boolean;
        filterMode: StiItemFilterMode;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiItemFilterMode = Stimulsoft.Report.Dashboard.StiItemFilterMode;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    let IStiTreeViewElement: System.Interface<IStiTreeViewElement>;
    let ImplementsIStiTreeViewElement: any[];
    interface IStiTreeViewElement extends IStiControlElement, IStiItemElement, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiDataFilters {
        getKeyMeter(cell: IStiAppDataCell): IStiMeter;
        getKeyMeterByIndex(index: number): IStiMeter;
        insertKeyMeter(index: number, meter: IStiMeter): any;
        removeKeyMeter(index: number): any;
        removeAllKeyMeters(): any;
        addKey(cell: IStiAppDataCell): any;
        addNewKeyMeter(): IStiMeter;
        filterMode: StiItemFilterMode;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import List = Stimulsoft.System.Collections.List;
    import StiJson = Stimulsoft.Base.StiJson;
    let IStiUserViewStates: System.Interface<IStiUserViewStates>;
    let ImplementsIStiUserViewStates: any[];
    interface IStiUserViewStates {
        userViewStates: List<StiUserViewState>;
        selectedViewStateKey: string;
        switchSelectedViewState(newKey: string): any;
        saveToJsonForViewState(): StiJson;
        loadFromJsonForViewState(jObject: StiJson): any;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    let IStiWebContentElement: System.Interface<IStiWebContentElement>;
    let ImplementsIStiWebContentElement: any[];
    interface IStiWebContentElement extends IStiElement {
        url: string;
        embedCode: string;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiOnlineMapLastImageCache {
        private static cache;
        private static getKey;
        static getLastImage(element: IStiOnlineMapElement): Image;
        static existsLastImage(element: IStiOnlineMapElement): boolean;
        static storeLastImage(element: IStiOnlineMapElement, image: Image): void;
        static clean(reportKey: string): void;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    class StiPivotToConvertedStateCache {
        private static cache;
        private static getIntKey;
        private static getKey;
        static isConverted(element: IStiPivotTableElement): boolean;
        static putTrue(element: IStiPivotTableElement): void;
        static putFalse(element: IStiPivotTableElement): void;
        private static put;
        static contains(element: IStiPivotTableElement): boolean;
        static clean(reportKey?: string): void;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiPivotTableElement = Stimulsoft.Report.Dashboard.IStiPivotTableElement;
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    class StiPivotTableToCrossTabCache {
        private static cache;
        private static getKey;
        static get(element: IStiPivotTableElement): StiCrossTab;
        static put(element: IStiPivotTableElement, crossTab: StiCrossTab): void;
        static contains(element: IStiPivotTableElement): boolean;
        static remove(element: IStiPivotTableElement): void;
        static clean(reportKey: string): void;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    class StiPivotToContainerCache {
        private static cache;
        static get(element: IStiPivotTableElement): IStiPivotGridContainer;
        static put(element: IStiPivotTableElement, container: IStiPivotGridContainer): void;
        static remove(element: IStiPivotTableElement): void;
        static contains(element: IStiPivotTableElement): boolean;
        static clean(reportKey: string): void;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiReport = Stimulsoft.Base.IStiReport;
    import StiParserGetDataFieldValueEventArgs = Stimulsoft.Report.Engine.StiParser.StiParserGetDataFieldValueEventArgs;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiReportComponent = Stimulsoft.Base.IStiReportComponent;
    class StiReportParser {
        private static cache;
        private static wrongCache;
        static parseNumber(expression: string, report: IStiReport, allowCache?: boolean, constants?: Hashtable, allowDataLoading?: boolean, onlyExpression?: boolean): number;
        static parse(expression: string, component: IStiReportComponent, allowCache?: boolean, constants?: Hashtable, allowDataLoading?: boolean, onlyExpression?: boolean): string;
        static parse2(expression: string, report: IStiReport, allowCache?: boolean, constants?: Hashtable, allowDataLoading?: boolean, onlyExpression?: boolean): string;
        static parseAsync(expression: string, component: IStiReportComponent, allowCache?: boolean, constants?: Hashtable, allowDataLoading?: boolean, onlyExpression?: boolean): Promise<string>;
        static parseAsync2(expression: string, report: IStiReport, allowCache?: boolean, constants?: Hashtable, allowDataLoading?: boolean, onlyExpression?: boolean): Promise<string>;
        static parseObject(expression: string, component: IStiReportComponent, allowCache?: boolean, constants?: Hashtable, allowDataLoading?: boolean, onlyExpression?: boolean): any;
        static parseObjectAsync(expression: string, component: IStiReportComponent, allowCache?: boolean, constants?: Hashtable, allowDataLoading?: boolean, onlyExpression?: boolean): Promise<any>;
        private static parseOrDefault;
        private static parseOrDefaultAsync;
        private static tryParse;
        private static tryParseAsync;
        private static prepareConstants;
        static getDataFieldValueProcessor(sender: any, e: StiParserGetDataFieldValueEventArgs): void;
        static getDataFieldValueProcessorAsync(sender: any, e: StiParserGetDataFieldValueEventArgs): Promise<void>;
        private static prepareExpression;
        private static getCacheKey;
        static addToCache(expression: string, result: string, component: IStiReportComponent): void;
        static addToWrongCache(expression: string, result: string, component: IStiReportComponent): void;
        static getFromCache(expression: string, component: IStiReportComponent): string;
        static getFromWrongCache(expression: string, component: IStiReportComponent): string;
        static cleanCache(reportKey: string): void;
    }
}
export namespace Stimulsoft.Report.Dashboard.Helpers {
    import Image = Stimulsoft.System.Drawing.Image;
    import IStiApp = Stimulsoft.Base.IStiApp;
    class StiDashboardImageHyperlinkCache {
        private static cache;
        static get(hyperlink: string, app: IStiApp): Image;
        private static getCacheKey;
        private static getFromCache;
        private static addToCache;
        static clean(appKey: string): void;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiApp = Stimulsoft.Base.IStiApp;
    class StiCacheCleaner {
        static clean(element?: IStiElement | IStiAppDictionary | IStiApp | string): void;
        static clean1(element: IStiElement): void;
        static clean2(dictionary: IStiAppDictionary): void;
        static clean3(app: IStiApp): void;
        static clean4(reportKey?: string): void;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiCardsColumn = Stimulsoft.Base.Meters.IStiCardsColumn;
    import IStiReport = Stimulsoft.Base.IStiReport;
    class StiCardsColumnVisibilityHelper {
        static getVisible(column: IStiCardsColumn, report: IStiReport): boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiChartSeriesType = Stimulsoft.Report.Dashboard.StiChartSeriesType;
    import List = Stimulsoft.System.Collections.List;
    class StiChartGroups {
        private static hash;
        private static isInit;
        static sameGroup(type1: StiChartSeriesType, type2: StiChartSeriesType): boolean;
        static getGroup(type: StiChartSeriesType): List<StiChartSeriesType>;
        static init(): void;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiChartSeriesType = Stimulsoft.Report.Dashboard.StiChartSeriesType;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    class StiChartSeriesCreator {
        static neww(typeName: string): IStiSeries;
        static neww2(type: StiChartSeriesType): IStiSeries;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    class StiDashboardAssembly {
        static get isAssemblyLoaded(): boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiDashboard = Stimulsoft.Report.Dashboard.IStiDashboard;
    class StiDashboardCreator {
        static createDashboard(report: StiReport): IStiDashboard;
        static createDashboardElement(typeComponent: string): StiComponent;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    class StiDashboardDesignAssembly {
        static getHtmlTextHelper(): IStiHtmlTextHelper;
    }
}
export namespace Stimulsoft.Report.Dashboards {
    import IStiCardsVisualSvgHelper = Stimulsoft.Report.Dashboard.Visuals.IStiCardsVisualSvgHelper;
    import IStiTableElementAutoSizer = Stimulsoft.Report.Dashboard.IStiTableElementAutoSizer;
    import IStiProgressVisualSvgHelper = Stimulsoft.Report.Dashboard.Visuals.IStiProgressVisualSvgHelper;
    import IStiIndicatorVisualSvgHelper = Stimulsoft.Report.Dashboard.Visuals.IStiIndicatorVisualSvgHelper;
    import IStiGaugeVisualSvgHelper = Stimulsoft.Report.Dashboard.Visuals.IStiGaugeVisualSvgHelper;
    class StiDashboardHelperCreator {
        static createTableElementAutoSizer(): IStiTableElementAutoSizer;
        static createProgressVisualSvgHelper(): IStiProgressVisualSvgHelper;
        static createIndicatorVisualSvgHelper(): IStiIndicatorVisualSvgHelper;
        static createCardsVisualSvgHelper(): IStiCardsVisualSvgHelper;
        static createGaugeVisualSvgHelper(): IStiGaugeVisualSvgHelper;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    class StiDataFilterCreator {
        static createEqualBasedOnValue(value: any, columnName: string, component: StiComponent): StiDataFilterRule;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiElementMeterAction = Stimulsoft.Report.StiElementMeterAction;
    class StiElementChangedArgs {
        action: StiElementMeterAction;
        oldName: string;
        newName: string;
        static createEmptyArgs(): StiElementChangedArgs;
        static createRenamingArgs(oldName: string, newName: string): StiElementChangedArgs;
        static createDeletingArgs(name: string): StiElementChangedArgs;
        static createClearingAllArgs(): StiElementChangedArgs;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    class StiElementChangedProcessor {
        static processElementChanging(element: any, args: StiElementChangedArgs): void;
        private static processElementRenaming;
        private static processElementClearing;
        private static processElementDeleting;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiDataRequestOption = Stimulsoft.Data.Engine.StiDataRequestOption;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiElementDataCache {
        private static worker;
        private static elements;
        private static cache;
        private static pivotCreator;
        static tryToGetOrCreate(element: IStiElement, option?: StiDataRequestOption): Promise<StiDataTable>;
        static getOrCreate(element: IStiElement, option?: StiDataRequestOption): Promise<StiDataTable>;
        static getOrCreatePivot(element: IStiPivotTableElement, creator: IStiPivotTableCreator, option?: StiDataRequestOption): Promise<IStiPivotGridContainer>;
        static getOrCreateWithProgress(element: IStiElement, option?: StiDataRequestOption): Promise<StiDataTable>;
        static getOrCreatePivotWithProgress(element: IStiPivotTableElement, creator: IStiPivotTableCreator, option?: StiDataRequestOption): Promise<IStiPivotGridContainer>;
        static get(element: IStiElement): StiDataTable;
        static create(element: IStiElement, dataRequestOption: StiDataRequestOption): Promise<StiDataTable>;
        static add(element: IStiElement, dataTable: StiDataTable): void;
        private static initWorker;
        static getKey(element: IStiElement): string;
        static cleanCache(reportKey: string): void;
        private static getUserFilters;
        private static getUserSorts;
        private static getDataFilters;
        private static getTransformActions;
        private static getTransformFilters;
        private static getTransformSorts;
        private static getDrillDownFilters;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiElementLayout implements IStiJsonReportObject, ICloneable {
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        static createFromJsonObject(jObject: StiJson): StiElementLayout;
        static createFromXml(xmlNode: XmlNode): StiElementLayout;
        clone(): StiElementLayout;
        fullScreenButton: boolean;
        saveButton: boolean;
        StiElementLayout(): void;
        constructor(saveButton?: boolean, fullScreenButton?: boolean);
    }
}
export namespace Stimulsoft.Report.Dashboard {
    class StiGroupElementHelper {
        static getGroup(element: IStiElement): string;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import Type = Stimulsoft.System.Type;
    class StiInvokeMethodsHelper {
        static invokeStaticMethod(assemblyName: string, className: string, methodName: string, parameters?: any[], parametersTypes?: Type[]): any;
        static setPropertyValue(obj: any, propertyName: string, value: any): void;
        static getPropertyValue(obj: any, propertyName: string): any;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiMargin implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(defLeft?: number, defTop?: number, defRight?: number, defBotttom?: number): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        left: number;
        top: number;
        right: number;
        bottom: number;
        get isEmpty(): boolean;
        equals(obj: any): boolean;
        static empty: StiMargin;
        static create(all?: number): StiMargin;
        constructor(left: number, top: number, right: number, bottom: number);
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiPadding implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(defLeft?: number, defTop?: number, defRight?: number, defBotttom?: number): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        left: number;
        top: number;
        right: number;
        bottom: number;
        get isEmpty(): boolean;
        equals(obj: any): boolean;
        static get empty(): StiPadding;
        static create(all?: number): StiPadding;
        constructor(left: number, top: number, right: number, bottom: number);
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    import List = Stimulsoft.System.Collections.List;
    class StiPredefinedColors {
        static sets: List<Color[]>;
        static negativeSets: List<Color[]>;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    class StiStringMeasureCache {
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiTableColumnSize implements IStiJsonReportObject, ICloneable {
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        static createFromJsonObject(jObject: StiJson): StiTableColumnSize;
        static createFromXml(xmlNode: XmlNode): StiTableColumnSize;
        clone(): StiTableColumnSize;
        private _width;
        get width(): number;
        set width(value: number);
        private _minWidth;
        get minWidth(): number;
        set minWidth(value: number);
        private _maxWidth;
        get maxWidth(): number;
        set maxWidth(value: number);
        wordWrap: boolean;
        checkRules(): void;
        getUniqueCode(): number;
        constructor(width?: number, minWidth?: number, maxWidth?: number, wordWrap?: boolean);
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiTableColumn = Stimulsoft.Base.Meters.IStiTableColumn;
    import IStiReport = Stimulsoft.Base.IStiReport;
    class StiTableColumnVisibilityHelper {
        static getVisible(column: IStiTableColumn, report: IStiReport): Promise<boolean>;
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiTitlePadding implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(defLeft?: number, defTop?: number, defRight?: number, defBotttom?: number): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        left: number;
        top: number;
        right: number;
        bottom: number;
        get isEmpty(): boolean;
        equals(obj: any): boolean;
        static create(all?: number): StiTitlePadding;
        constructor(left: number, top: number, right: number, bottom: number);
    }
}
export namespace Stimulsoft.Report.Dashboard {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import List = Stimulsoft.System.Collections.List;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiChartSeriesType = Stimulsoft.Report.Dashboard.StiChartSeriesType;
    class StiUserViewState implements IStiJsonReportObject, ICloneable {
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiUserViewState;
        saveToString(): string;
        toList(): List<StiUserViewState>;
        static loadFromJson(jObject: StiJson): StiUserViewState;
        static loadFromJson2(json: string): StiUserViewState;
        static loadFromXml(xmlNode: XmlNode): StiUserViewState;
        key: string;
        name: string;
        state: string;
        seriesType: StiChartSeriesType;
        constructor(key?: string, name?: string, state?: string, seriesType?: StiChartSeriesType);
    }
}
export namespace Stimulsoft.Report.Dashboard.Export {
    import StiDataType = Stimulsoft.Report.Export.StiDataType;
    let IStiDataDashboardExportSettings: System.Interface<IStiDataDashboardExportSettings>;
    interface IStiDataDashboardExportSettings extends IStiDashboardExportSettings {
        dataType: StiDataType;
    }
}
export namespace Stimulsoft.Report.Dashboard.Export {
    import StiDashboardScaleMode = Stimulsoft.Report.Dashboard.StiDashboardScaleMode;
    let IStiExcelDashboardExportSettings: System.Interface<IStiExcelDashboardExportSettings>;
    interface IStiExcelDashboardExportSettings extends IStiDashboardExportSettings {
        width: number;
        height: number;
        imageQuality: number;
        exportDataOnly: boolean;
        scaleMode: StiDashboardScaleMode;
    }
}
export namespace Stimulsoft.Report.Dashboard.Export {
    import StiDashboardScaleMode = Stimulsoft.Report.Dashboard.StiDashboardScaleMode;
    let IStiHtmlDashboardExportSettings: System.Interface<IStiHtmlDashboardExportSettings>;
    interface IStiHtmlDashboardExportSettings extends IStiDashboardExportSettings {
        imageQuality: number;
        scale: number;
        enableAnimation: boolean;
        scaleMode: StiDashboardScaleMode;
    }
}
export namespace Stimulsoft.Report.Dashboard.Export {
    import StiDashboardScaleMode = Stimulsoft.Report.Dashboard.StiDashboardScaleMode;
    let IStiPdfDashboardExportSettings: System.Interface<IStiPdfDashboardExportSettings>;
    interface IStiPdfDashboardExportSettings extends IStiDashboardExportSettings {
        autoPrint: boolean;
        imageQuality: number;
        scaleMode: StiDashboardScaleMode;
    }
}
export namespace Stimulsoft.Report.Dashboard.Helpers {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    class StiBorderElementHelper {
        static getBorderContentRect(rect: RectangleD, element: IStiElement, skipMinimalSize?: boolean): RectangleD;
        static getBorderContentRect2(rect: RectangleD, border: StiSimpleBorder, scale: number, skipMinimalSize?: boolean): RectangleD;
        static getBorderContentRect3(rect: RectangleD, border: StiBorder, scale: number, skipMinimalSize?: boolean): RectangleD;
    }
}
export namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiCardsElementMouseOverData {
        rowIndex: number;
        columnIndex: number;
        value: any;
    }
}
export namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiCardsElementMouseOverHelper {
    }
}
export namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiCrossLinkedFilterHelper {
        static isCrossLinkedFilter(filterElement: IStiFilterElement): boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard.Helpers {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDashboardExpressionHelper {
        static getBackColor(component: any, defaultColor: Color): Color;
        static getForeColor(component: any, defaultColor: Color): Color;
        static getColor(component: any, defaultColor: Color, propertyName: string): Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiDashboardRecentHelper {
        private static dbsFiles;
        private static reportFiles;
        private static getSettingsPath;
        private static getNewSettingsPath;
        static save(): boolean;
        private static load;
        static add(report: StiReport, path: string, autoSave?: boolean): void;
        static add2(containsDashboards: boolean, path: string, autoSave?: boolean): void;
        static remove(path: string): void;
        static containsDbs(path: string): boolean;
        static containsFile(path: string): boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard.Helpers {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiElementScale {
        static factor(element: IStiElement | StiComponent): number;
    }
}
export namespace Stimulsoft.Report.Dashboard.Helpers {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiIndicatorElementMouseOverHelper {
        private static indicatorElement;
        private static mouseOverPoint;
        static setMouseOverPoint(indicator: IStiIndicatorElement, point: PointD): void;
        static getMouseOverPoint(indicator: IStiIndicatorElement, useZoom?: boolean): PointD;
        static resetMouseOverPoint(indicator: IStiIndicatorElement): void;
    }
}
export namespace Stimulsoft.Report.Dashboard.Helpers {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiMarginHelper {
        static applyMargin(element: IStiElement, rect: RectangleD, scale?: number): RectangleD;
    }
}
export namespace Stimulsoft.Report.Dashboard.Helpers {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPaddingHelper {
        static applyPadding(element: IStiElement, rect: RectangleD, scale: number): RectangleD;
    }
}
export namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiSortMenuHelper {
        static isAllowUserSorting(element: IStiElement): boolean;
    }
}
export namespace Stimulsoft.Report.Dashboard.Helpers {
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTableElementClickEventArgs extends EventArgs {
        dataTable: StiDataTable;
        columnKey: string;
        rect: RectangleD;
    }
}
export namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiTableElementClickRightHelper {
    }
}
export namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiTableElementMouseOverHelper {
    }
}
export namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiTablePartDrawer {
    }
}
export namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiTableSizer {
    }
}
export namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiTableElementPagingHelper {
        static getNumberOfPages(numberOfRows: number, rowsPerPage: number): number;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiCellIndicatorStyle: System.Interface<IStiCellIndicatorStyle>;
    let ImplementsIStiCellIndicatorStyle: any[];
    interface IStiCellIndicatorStyle {
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
        cellIndicatorNeutral: Color;
    }
}
export namespace Stimulsoft.Report.Maps {
    enum StiMapSource {
        Manual = 0,
        DataColumns = 1
    }
    enum StiDisplayNameType {
        None = 1,
        Full = 2,
        Short = 3
    }
    enum StiMapMode {
        Choropleth = 0,
        Online = 1
    }
    enum StiMapID {
        World = 1,
        Australia = 2,
        Austria = 3,
        Brazil = 4,
        Canada = 5,
        China = 6,
        Taiwan = 7,
        EU = 8,
        Europe = 9,
        EuropeWithRussia = 10,
        EUWithUnitedKingdom = 11,
        France = 12,
        Germany = 13,
        Italy = 14,
        Netherlands = 15,
        Russia = 16,
        UK = 17,
        UKCountries = 18,
        USAAndCanada = 19,
        USAAndPuertoRico = 20,
        NorthAmerica = 21,
        SouthAmerica = 22,
        USA = 23,
        Albania = 24,
        Andorra = 25,
        Argentina = 26,
        ArgentinaFD = 27,
        Afghanistan = 28,
        Armenia = 29,
        Azerbaijan = 30,
        Belarus = 31,
        Belgium = 32,
        Bolivia = 33,
        BosniaAndHerzegovina = 34,
        Bulgaria = 35,
        Chile = 36,
        Colombia = 37,
        Croatia = 38,
        Cyprus = 39,
        CzechRepublic = 40,
        Denmark = 41,
        Ecuador = 42,
        Estonia = 43,
        FalklandIslands = 44,
        Finland = 45,
        Georgia = 46,
        Greece = 47,
        Guyana = 48,
        Hungary = 49,
        Iceland = 50,
        India = 51,
        Indonesia = 52,
        Ireland = 53,
        Israel = 54,
        Japan = 55,
        Kazakhstan = 56,
        Latvia = 57,
        Liechtenstein = 58,
        Lithuania = 59,
        Luxembourg = 60,
        Macedonia = 61,
        Malaysia = 62,
        Malta = 63,
        Mexico = 64,
        Moldova = 65,
        Monaco = 66,
        Montenegro = 67,
        NewZealand = 68,
        Norway = 69,
        Paraguay = 70,
        Peru = 71,
        Philippines = 72,
        Poland = 73,
        Portugal = 74,
        PuertoRico = 75,
        Romania = 76,
        SanMarino = 77,
        SaudiArabia = 78,
        Serbia = 79,
        Slovakia = 80,
        Slovenia = 81,
        Africa = 82,
        SouthAfrica = 83,
        SouthKorea = 84,
        Spain = 85,
        Suriname = 86,
        Sweden = 87,
        Switzerland = 88,
        Thailand = 89,
        Turkey = 90,
        Ukraine = 91,
        Uruguay = 92,
        Vatican = 93,
        Venezuela = 94,
        Vietnam = 95,
        MiddleEast = 96,
        Oman = 97,
        Qatar = 98,
        Benelux = 99,
        Scandinavia = 100,
        FranceDepartments = 101,
        France18Regions = 102,
        CentralAfricanRepublic = 103,
        Asia = 104,
        SoutheastAsia = 105,
        Oceania = 106,
        Algeria = 107,
        Angola = 108,
        Benin = 109,
        Botswana = 110,
        BurkinaFaso = 111,
        Burundi = 112,
        Cameroon = 113,
        CapeVerde = 114,
        Chad = 115,
        Comoros = 116,
        Djibouti = 117,
        Egypt = 118,
        EquatorialGuinea = 119,
        Eritrea = 120,
        Ethiopia = 121,
        Gabon = 122,
        Gambia = 123,
        Ghana = 124,
        Guinea = 125,
        GuineaBissau = 126,
        IvoryCoast = 127,
        Kenya = 128,
        Lesotho = 129,
        Liberia = 130,
        Libya = 131,
        Madagascar = 132,
        Malawi = 133,
        Mali = 134,
        Mauritania = 135,
        Mauritius = 136,
        Morocco = 137,
        Mozambique = 138,
        Namibia = 139,
        Niger = 140,
        Nigeria = 141,
        RepublicOfTheCongo = 142,
        Rwanda = 143,
        SaoTomeAndPrincipe = 144,
        Senegal = 145,
        Seychelles = 146,
        SierraLeone = 147,
        Somalia = 148,
        SouthSudan = 149,
        Sudan = 150,
        Swaziland = 151,
        Tanzania = 152,
        Togo = 153,
        Tunisia = 154,
        Uganda = 155,
        Zambia = 156,
        Zimbabwe = 157
    }
    enum StiMapStyleIdent {
        Style21 = 0,
        Style24 = 1,
        Style25 = 2,
        Style26 = 3,
        Style27 = 4,
        Style28 = 5,
        Style29 = 6,
        Style30 = 7,
        Style31 = 8,
        Style32 = 9,
        Style33 = 10,
        Style34 = 11,
        Style35 = 12,
        Style36 = 13,
        Style37 = 14
    }
    enum StiMapType {
        None = 0,
        Individual = 4,
        Group = 1,
        Heatmap = 2,
        HeatmapWithGroup = 3
    }
}
export namespace Stimulsoft.Report.Styles {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiFontStyle = Stimulsoft.Report.Styles.IStiFontStyle;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMapStyle extends StiBaseStyle implements IStiTitleStyle, IStiFontStyle, IStiGetFonts, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        clone(): any;
        private defaultColors;
        get heatmapColors(): Color[];
        set heatmapColors(value: Color[]);
        heatmap: StiHeatmapStyleData;
        heatmapWithGroup: StiHeatmapWithGroupStyleData;
        private _individualColor;
        get individualColor(): Color;
        set individualColor(value: Color);
        private _colors;
        get colors(): Color[];
        set colors(value: Color[]);
        private _defaultColor;
        get defaultColor(): Color;
        set defaultColor(value: Color);
        private _backColor;
        get backColor(): Color;
        set backColor(value: Color);
        private _foreColor;
        get foreColor(): Color;
        set foreColor(value: Color);
        borderSize: number;
        private _borderColor;
        get borderColor(): Color;
        set borderColor(value: Color);
        labelShadowForeground: Color;
        labelForeground: Color;
        bubbleBackColor: Color;
        bubbleBorderColor: Color;
        toolTipBrush: StiBrush;
        toolTipTextBrush: StiBrush;
        toolTipCornerRadius: StiCornerRadius;
        toolTipBorder: StiSimpleBorder;
        getFonts(): Font[];
        allowUseFont: boolean;
        font: Font;
        allowUseTitle: boolean;
        titleForeColor: Color;
        titleBackColor: Color;
        titleFont: Font;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
export namespace Stimulsoft.Report.Maps {
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiMapStyle = Stimulsoft.Report.Styles.StiMapStyle;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiMapStyleFX extends StiMapStyle {
        get localizeName(): string;
        allowDashboard: boolean;
        get styleId(): StiMapStyleIdent;
        styleIdent: StiElementStyleIdent;
        toolTipCornerRadius: StiCornerRadius;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiWhiteBlackStyleColors {
        static dashboardName: string;
        static foreColor: System.Drawing.Color;
        static backColor: System.Drawing.Color;
        static selectedCellBackColor: System.Drawing.Color;
        static cellAlternatingBackColor: System.Drawing.Color;
        static hotBackColor: System.Drawing.Color;
        static seriesColors: System.Drawing.Color[];
        static mapBorderColor: System.Drawing.Color;
        static mapDefaultColor: System.Drawing.Color;
        static cellOverlappedColor: System.Drawing.Color;
        static cellPositiveColor: System.Drawing.Color;
        static cellNegativeColor: System.Drawing.Color;
        static cellNeutralColor: System.Drawing.Color;
        static cellSparkline: System.Drawing.Color;
        static trackColor: System.Drawing.Color;
        static toolTipBackColor: System.Drawing.Color;
        static toolTipBorderColor: System.Drawing.Color;
        static toolTipForeColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Maps {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap37StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get borderColor(): Color;
        set borderColor(value: Color);
        get individualColor(): Color;
        set individualColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get backColor(): Color;
        set backColor(value: Color);
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
        constructor();
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGrayStyleColors {
        static foreColor: Color;
        static backColor: Color;
        static cellAlternatingBackColor: Color;
        static cellForeColor: Color;
        static cellOverlappedColor: Color;
        static cellPositiveColor: Color;
        static cellNegativeColor: Color;
        static cellNeutralColor: Color;
        static trackColor: Color;
        static tickColor: Color;
        static seriesColors: Color[];
        static mapBorderColor: Color;
        static mapDefaultColor: Color;
        static targetColor: Color;
        static toolTipBackColor: Color;
        static toolTipBorderColor: Color;
        static toolTipForeColor: Color;
        static markerColor: Color;
    }
}
export namespace Stimulsoft.Report.Maps {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap36StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get borderColor(): Color;
        set borderColor(value: Color);
        get individualColor(): Color;
        set individualColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get backColor(): Color;
        set backColor(value: Color);
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
        constructor();
    }
}
export namespace Stimulsoft.Report.Maps {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap35StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get borderColor(): Color;
        set borderColor(value: Color);
        get individualColor(): Color;
        set individualColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
        constructor();
    }
}
export namespace Stimulsoft.Report.Maps {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap34StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get borderColor(): Color;
        set borderColor(value: Color);
        get individualColor(): Color;
        set individualColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
        constructor();
    }
}
export namespace Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap33StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get borderColor(): Color;
        set borderColor(value: Color);
        get individualColor(): Color;
        set individualColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        constructor();
    }
}
export namespace Stimulsoft.Report.Maps {
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap32StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get borderColor(): Color;
        set borderColor(value: Color);
        get individualColor(): Color;
        set individualColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        toolTipBrush: StiSolidBrush;
        constructor();
    }
}
export namespace Stimulsoft.Report.Maps {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap31StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get borderColor(): Color;
        set borderColor(value: Color);
        get individualColor(): Color;
        set individualColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
        constructor();
    }
}
export namespace Stimulsoft.Report.Maps {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap30StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get borderColor(): Color;
        set borderColor(value: Color);
        get individualColor(): Color;
        set individualColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
        constructor();
    }
}
export namespace Stimulsoft.Report.Maps {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap29StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get colors(): Color[];
        set colors(value: Color[]);
        get individualColor(): Color;
        set individualColor(value: Color);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        get borderColor(): Color;
        set borderColor(value: Color);
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
        constructor();
    }
}
export namespace Stimulsoft.Report.Maps {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap28StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get colors(): Color[];
        set colors(value: Color[]);
        get individualColor(): Color;
        set individualColor(value: Color);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        get borderColor(): Color;
        set borderColor(value: Color);
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
        constructor();
    }
}
export namespace Stimulsoft.Report.Maps {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap27StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get individualColor(): Color;
        set individualColor(value: Color);
        get borderColor(): Color;
        set borderColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
        constructor();
    }
}
export namespace Stimulsoft.Report.Maps {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap26StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get individualColor(): Color;
        set individualColor(value: Color);
        get borderColor(): Color;
        set borderColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
        constructor();
    }
}
export namespace Stimulsoft.Report.Maps {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap25StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get individualColor(): Color;
        set individualColor(value: Color);
        get borderColor(): Color;
        set borderColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
        constructor();
    }
}
export namespace Stimulsoft.Report.Maps {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap24StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get individualColor(): Color;
        set individualColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        get borderColor(): Color;
        set borderColor(value: Color);
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
        constructor();
    }
}
export namespace Stimulsoft.Report.Styles {
    import IStiFontStyle = Stimulsoft.Report.Styles.IStiFontStyle;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDialogStyle extends StiBaseStyle implements IStiTitleStyle, IStiFontStyle, IStiGetFonts, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        clone(): any;
        private _font;
        get font(): Font;
        set font(value: Font);
        getFonts(): Font[];
        allowUseTitle: boolean;
        titleForeColor: Color;
        titleBackColor: Color;
        titleFont: Font;
        foreColor: Color;
        backColor: Color;
        glyphColor: Color;
        separatorColor: Color;
        selectedBackColor: Color;
        selectedForeColor: Color;
        selectedGlyphColor: Color;
        hotBackColor: Color;
        hotForeColor: Color;
        hotGlyphColor: Color;
        hotSelectedBackColor: Color;
        hotSelectedForeColor: Color;
        hotSelectedGlyphColor: Color;
        allowUseFont: boolean;
        allowUseBackColor: boolean;
        allowUseForeColor: boolean;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements, componentStyle?: StiBaseStyle): void;
        setStyleToComponent(component: StiComponent): void;
    }
}
export namespace Stimulsoft.Report.Styles {
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiFontStyle = Stimulsoft.Report.Styles.IStiFontStyle;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import IStiTitleStyle = Stimulsoft.Report.Styles.IStiTitleStyle;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrushType = Stimulsoft.Report.StiBrushType;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiChartStyle extends StiBaseStyle implements IStiTitleStyle, IStiFontStyle, IStiGetFonts, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        border: StiBorder;
        brush: StiBrush;
        chartAreaBrush: StiBrush;
        chartAreaBorderColor: Color;
        chartAreaBorderThickness: number;
        chartAreaShowShadow: boolean;
        seriesLighting: boolean;
        seriesShowShadow: boolean;
        seriesShowBorder: boolean;
        seriesBorderColor: Color;
        seriesBorderThickness: number;
        seriesCornerRadius: StiCornerRadius;
        seriesLabelsLineColor: Color;
        toolTipBrush: StiBrush;
        toolTipTextBrush: StiBrush;
        toolTipCornerRadius: StiCornerRadius;
        toolTipBorder: StiSimpleBorder;
        trendLineColor: Color;
        trendLineShowShadow: boolean;
        seriesLabelsBrush: StiBrush;
        seriesLabelsColor: Color;
        seriesLabelsBorderColor: Color;
        legendBrush: StiBrush;
        legendLabelsColor: Color;
        legendBorderColor: Color;
        legendTitleColor: Color;
        axisTitleColor: Color;
        axisLineColor: Color;
        axisLabelsColor: Color;
        markerVisible: boolean;
        interlacingHorBrush: StiBrush;
        interlacingVertBrush: StiBrush;
        gridLinesHorColor: Color;
        gridLinesVertColor: Color;
        brushType: StiBrushType;
        styleColors: Color[];
        basicStyleColor: Color;
        allowUseBorderFormatting: boolean;
        allowUseBorderSides: boolean;
        allowUseBrush: boolean;
        getFonts(): Font[];
        allowUseFont: boolean;
        font: Font;
        allowUseTitle: boolean;
        titleForeColor: Color;
        titleBackColor: Color;
        titleFont: Font;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements, componentStyle?: StiBaseStyle): void;
        setStyleToComponent(component: StiComponent): void;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import IStiTitleStyle = Stimulsoft.Report.Styles.IStiTitleStyle;
    import IStiFontStyle = Stimulsoft.Report.Styles.IStiFontStyle;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiCardsElementStyle = Stimulsoft.Report.Dashboard.Styles.StiCardsElementStyle;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTableStyle = Stimulsoft.Report.StiTableStyle;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiMapStyleFX = Stimulsoft.Report.Maps.StiMapStyleFX;
    import StiDialogStyle = Stimulsoft.Report.Styles.StiDialogStyle;
    import StiCrossTabStyle = Stimulsoft.Report.Styles.StiCrossTabStyle;
    import StiMapStyle = Stimulsoft.Report.Styles.StiMapStyle;
    import StiMapStyleIdent = Stimulsoft.Report.Maps.StiMapStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiChartStyle = Stimulsoft.Report.Chart.IStiChartStyle;
    import FontFamily = Stimulsoft.System.Drawing.FontFamily;
    import StiChartStyle = Stimulsoft.Report.Styles.StiChartStyle;
    class StiDashboardStyleHelper {
        private static iconFontFamily;
        private static cloneColors;
        static getCopyChartStyle(chartStyle: IStiChartStyle, element: IStiChartElement): StiChartStyle;
        static getCopyTableStyle(tableStyle: StiTableElementStyle): StiTableStyle;
        static convertToReportGaugeStyle(element: IStiGaugeElement): StiGaugeStyle;
        static convertToReportPivotTableStyle(element: IStiPivotTableElement): StiCrossTabStyle;
        static convertToReportIndicatorStyle(element: IStiIndicatorElement): StiIndicatorStyle;
        static convertToReportProgressStyle(element: IStiProgressElement): StiProgressStyle;
        static convertToReportRegionMapStyle(element: IStiRegionMapElement): StiMapStyle;
        static convertToReportControlStyle(element: IStiControlElement): StiDialogStyle;
        static getDashboardBackColor(dashboard: IStiDashboard, isViewer: boolean): Color;
        static isDarkStyle(dashboard: IStiDashboard): boolean;
        static isDarkStyle3(element: IStiElement): boolean;
        static isDarkStyle2(ident: StiElementStyleIdent): boolean;
        static getFont(element: any): Font;
        static getDataEmptyColor(element: IStiElement): Color;
        static getDataEmptyForeColor(element: IStiElement): Color;
        static getForeColor(element: IStiElement, defaultColor?: Color): Color;
        static getStyleForeColor(element: IStiElement): Color;
        static getForeColor2(ident: StiElementStyleIdent): Color;
        static getNativeForeColor(element?: IStiElement): Color;
        static getStyleForDataViewTable(element: IStiElement): StiTableElementStyle;
        private static tryGetAccentColorFromStyle;
        private static isColorLight;
        static getSelectedForeColor(element: IStiControlElement): Color;
        static getSelectedBackColor(element: IStiControlElement): Color;
        static getGlyphColor2(element: IStiControlElement): Color;
        static getGlyphColor(element: IStiIndicatorElement): Color;
        static getSeparatorColor(element: IStiControlElement): Color;
        static getBackColor(element: IStiElement, defaultColor?: Color, allowOpacity?: boolean): Color;
        static getStyleBackColor(element: IStiElement): Color;
        static getStyleHotBackColor(element: IStiElement): Color;
        static getHotBackColor(element: IStiElement): Color;
        static getBackColor2(style: StiElementStyleIdent): Color;
        static getTitleForeColor(element: IStiElement): Color;
        static getGaugeStyle(element: IStiGaugeElement): IStiGaugeStyle;
        static getGaugeStyle2(style: StiElementStyleIdent): IStiGaugeStyle;
        static getChartStyle(element: IStiChartElement): IStiChartStyle;
        static getChartStyle2(style: StiElementStyleIdent): IStiChartStyle;
        static getMapStyleIdent(element: IStiRegionMapElement): StiMapStyleIdent;
        static getMapStyle(element: IStiRegionMapElement): StiMapStyleFX;
        static getMapStyle2(style: StiElementStyleIdent): StiMapStyleFX;
        static getControlStyle(element: IStiElement): StiControlElementStyle;
        static getIndicatorStyle(element: IStiIndicatorElement): StiIndicatorElementStyle;
        static getProgressStyle(element: IStiProgressElement): StiProgressElementStyle;
        static getTableStyle(element: IStiTableElement): StiTableElementStyle;
        static getTableStyle2(style: StiElementStyleIdent): StiTableElementStyle;
        static getPivotTableStyle(element: IStiPivotTableElement): StiPivotElementStyle;
        static getCardsStyle(element: IStiCardsElement): StiCardsElementStyle;
        static getCardsStyle2(style: StiElementStyleIdent): StiCardsElementStyle;
        static getStyle(element: IStiElement): StiElementStyleIdent;
        static getElementFontFromStyle(element: any, defaultFont?: Font): Font;
        static getElementFontStyle(element: any): IStiFontStyle;
        static getElementTitleStyle(element: IStiElement): IStiTitleStyle;
        static getIconFontFamily(): FontFamily;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    class StiElementStyle extends StiBaseStyle {
        ident: StiElementStyleIdent;
        drawBox(g: Graphics, rect: Rectangle, paintValue: boolean, paintImage: boolean): void;
        drawStyle(g: Graphics, rect: Rectangle, paintValue: boolean, paintImage: boolean): void;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiElementStyle = Stimulsoft.Report.Dashboard.Styles.StiElementStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCardsElementStyle extends StiElementStyle {
        get localizedName(): string;
        cellBackColor: Color;
        lineColor: Color;
        cellForeColor: Color;
        backColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellWinLossNegative: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
        cellIndicatorNeutral: Color;
        seriesColors: Color[];
        toolTipBrush: StiBrush;
        toolTipTextBrush: StiBrush;
        toolTipCornerRadius: StiCornerRadius;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiAliceBlueCardsElementStyle extends StiCardsElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellForeColor: Color;
        cellBackColor: Color;
        lineColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
        seriesColors: Color[];
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBlueCardsElementStyle extends StiCardsElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        cellForeColor: Color;
        seriesColors: Color[];
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCustomCardsElementStyle extends StiCardsElementStyle {
        private name2;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        seriesColors: Color[];
        foreColor: Color;
        constructor(style: StiCardsStyle);
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkBlueCardsElementStyle extends StiCardsElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellForeColor: Color;
        cellBackColor: Color;
        backColor: Color;
        lineColor: Color;
        seriesColors: Color[];
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkGrayCardsElementStyle extends StiCardsElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellForeColor: Color;
        cellBackColor: Color;
        backColor: Color;
        lineColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
        seriesColors: Color[];
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkGreenCardsElementStyle extends StiCardsElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellForeColor: Color;
        cellBackColor: Color;
        backColor: Color;
        lineColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
        seriesColors: Color[];
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkTurquoiseCardsElementStyle extends StiCardsElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellForeColor: Color;
        cellBackColor: Color;
        backColor: Color;
        lineColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
        seriesColors: Color[];
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiGrayCardsElementStyle extends StiCardsElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
        cellDataBarsOverlapped: System.Drawing.Color;
        cellDataBarsPositive: System.Drawing.Color;
        cellDataBarsNegative: System.Drawing.Color;
        cellWinLossPositive: System.Drawing.Color;
        cellWinLossNegative: System.Drawing.Color;
        cellSparkline: System.Drawing.Color;
        cellIndicatorPositive: System.Drawing.Color;
        cellIndicatorNegative: System.Drawing.Color;
        cellIndicatorNeutral: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGreenCardsElementStyle extends StiCardsElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        cellSparkline: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        seriesColors: Color[];
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiOrangeCardsElementStyle extends StiCardsElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        cellSparkline: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        seriesColors: Color[];
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiSiennaCardsElementStyle extends StiCardsElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        cellForeColor: Color;
        lineColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
        seriesColors: Color[];
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSilverCardsElementStyle extends StiCardsElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellForeColor: Color;
        cellBackColor: Color;
        lineColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
        seriesColors: Color[];
        toolTipBrush: StiSolidBrush;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSlateGrayCardsElementStyle extends StiCardsElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellForeColor: Color;
        cellBackColor: Color;
        backColor: Color;
        lineColor: Color;
        seriesColors: Color[];
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiCardsElementStyle = Stimulsoft.Report.Dashboard.Styles.StiCardsElementStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTurquoiseCardsElementStyle extends StiCardsElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        cellSparkline: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
        seriesColors: Color[];
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiCardsElementStyle = Stimulsoft.Report.Dashboard.Styles.StiCardsElementStyle;
    class StiWhiteBlackCardsElementStyle extends StiCardsElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        lineColor: System.Drawing.Color;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
        cellDataBarsOverlapped: System.Drawing.Color;
        cellDataBarsPositive: System.Drawing.Color;
        cellDataBarsNegative: System.Drawing.Color;
        cellWinLossPositive: System.Drawing.Color;
        cellWinLossNegative: System.Drawing.Color;
        cellSparkline: System.Drawing.Color;
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiControlElementStyle extends StiElementStyle {
        get localizedName(): string;
        backColor: Color;
        foreColor: Color;
        glyphColor: Color;
        separatorColor: Color;
        selectedBackColor: Color;
        selectedForeColor: Color;
        selectedGlyphColor: Color;
        hotBackColor: Color;
        hotForeColor: Color;
        hotGlyphColor: Color;
        hotSelectedBackColor: Color;
        hotSelectedForeColor: Color;
        hotSelectedGlyphColor: Color;
        font: Font;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiAliceBlueControlElementStyle extends StiControlElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        backColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        separatorColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiBlueControlElementStyle extends StiControlElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiDialogStyle = Stimulsoft.Report.Styles.StiDialogStyle;
    class StiCustomControlElementStyle extends StiControlElementStyle {
        private styleName;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        constructor(style: StiDialogStyle);
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkBlueControlElementStyle extends StiControlElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        separatorColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkGrayControlElementStyle extends StiControlElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        backColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        separatorColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkGreenControlElementStyle extends StiControlElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        backColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        separatorColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkTurquoiseControlElementStyle extends StiControlElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        backColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        separatorColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGrayControlElementStyle extends StiControlElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        backColor: Color;
        foreColor: Color;
        glyphColor: Color;
        selectedBackColor: Color;
        selectedForeColor: Color;
        selectedGlyphColor: Color;
        separatorColor: Color;
        hotBackColor: Color;
        hotForeColor: Color;
        hotGlyphColor: Color;
        hotSelectedBackColor: Color;
        hotSelectedForeColor: Color;
        hotSelectedGlyphColor: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiGreenControlElementStyle extends StiControlElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        selectedBackColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiOrangeControlElementStyle extends StiControlElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        selectedBackColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSiennaControlElementStyle extends StiControlElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        backColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        separatorColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSilverControlElementStyle extends StiControlElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        backColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        separatorColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSlateGrayControlElementStyle extends StiControlElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        backColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        separatorColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiTurquoiseControlElementStyle extends StiControlElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        selectedBackColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiWhiteBlackControlElementStyle extends StiControlElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        separatorColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    class StiDashboardStyle extends StiElementStyle {
        get localizedName(): string;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
        get borderColor(): Color;
        drawStyleForGallery(g: Graphics, rect: Rectangle): void;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiAliceBlueDashboardStyle extends StiDashboardStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        get borderColor(): Color;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBlueDashboardStyle extends StiDashboardStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkBlueDashboardStyle extends StiDashboardStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
        titleBackColor: System.Drawing.Color;
        titleForeColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkGrayDashboardStyle extends StiDashboardStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleForeColor: Color;
        titleBackColor: Color;
        get borderColor(): Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkGreenDashboardStyle extends StiDashboardStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleForeColor: Color;
        titleBackColor: Color;
        get borderColor(): Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkTurquoiseDashboardStyle extends StiDashboardStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleForeColor: Color;
        titleBackColor: Color;
        get borderColor(): Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiGrayDashboardStyle extends StiDashboardStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
        titleBackColor: System.Drawing.Color;
        titleForeColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGreenDashboardStyle extends StiDashboardStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiOrangeDashboardStyle extends StiDashboardStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSiennaDashboardStyle extends StiDashboardStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        get borderColor(): Color;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSilverDashboardStyle extends StiDashboardStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        get borderColor(): Color;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSlateGrayDashboardStyle extends StiDashboardStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTurquoiseDashboardStyle extends StiDashboardStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiWhiteBlackDashboardStyle extends StiDashboardStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
        titleBackColor: System.Drawing.Color;
        titleForeColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiIndicatorElementStyle extends StiElementStyle {
        get localizedName(): string;
        glyphColor: Color;
        backColor: Color;
        foreColor: Color;
        hotBackColor: Color;
        positiveColor: Color;
        negativeColor: Color;
        toolTipBrush: StiBrush;
        toolTipTextBrush: StiBrush;
        toolTipCornerRadius: StiCornerRadius;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiAliceBlueIndicatorElementStyle extends StiIndicatorElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiBlueIndicatorElementStyle extends StiIndicatorElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: Color;
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCustomIndicatorElementStyle extends StiIndicatorElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: Color;
        foreColor: Color;
        constructor(style: StiIndicatorStyle);
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiDarkBlueIndicatorElementStyle extends StiIndicatorElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: Color;
        backColor: Color;
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkGrayIndicatorElementStyle extends StiIndicatorElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: Color;
        backColor: Color;
        positiveColor: Color;
        negativeColor: Color;
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiDarkGreenIndicatorElementStyle extends StiIndicatorElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: Color;
        backColor: Color;
        positiveColor: Color;
        negativeColor: Color;
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkTurquoiseIndicatorElementStyle extends StiIndicatorElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: Color;
        backColor: Color;
        positiveColor: Color;
        negativeColor: Color;
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiGrayIndicatorElementStyle extends StiIndicatorElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: System.Drawing.Color;
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
        positiveColor: System.Drawing.Color;
        negativeColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiGreenIndicatorElementStyle extends StiIndicatorElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: Color;
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiOrangeIndicatorElementStyle extends StiIndicatorElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: Color;
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiSiennaIndicatorElementStyle extends StiIndicatorElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        positiveColor: Color;
        negativeColor: Color;
        glyphColor: Color;
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiSilverIndicatorElementStyle extends StiIndicatorElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: Color;
        toolTipBrush: StiSolidBrush;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiSlateGrayIndicatorElementStyle extends StiIndicatorElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: Color;
        backColor: Color;
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiTurquoiseIndicatorElementStyle extends StiIndicatorElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: Color;
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiWhiteBlackIndicatorElementStyle extends StiIndicatorElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        glyphColor: Color;
        hotBackColor: Color;
        positiveColor: Color;
        negativeColor: Color;
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
        getGalleryBackColor(): Color;
        GetGalleryForeColor(): Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiPivotElementStyle extends StiElementStyle {
        get localizedName(): string;
        cellBackColor: Color;
        cellForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        columnHeaderBackColor: Color;
        columnHeaderForeColor: Color;
        rowHeaderBackColor: Color;
        rowHeaderForeColor: Color;
        hotColumnHeaderBackColor: Color;
        hotRowHeaderBackColor: Color;
        lineColor: Color;
        backColor: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiAliceBluePivotElementStyle extends StiPivotElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBluePivotElementStyle extends StiPivotElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        columnHeaderBackColor: Color;
        columnHeaderForeColor: Color;
        rowHeaderBackColor: Color;
        rowHeaderForeColor: Color;
        hotColumnHeaderBackColor: Color;
        hotRowHeaderBackColor: Color;
        cellForeColor: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiCrossTabStyle = Stimulsoft.Report.Styles.StiCrossTabStyle;
    class StiCustomPivotElementStyle extends StiPivotElementStyle {
        private name2;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        columnHeaderBackColor: Color;
        columnHeaderForeColor: Color;
        rowHeaderBackColor: Color;
        rowHeaderForeColor: Color;
        hotColumnHeaderBackColor: Color;
        hotRowHeaderBackColor: Color;
        cellForeColor: Color;
        lineColor: Color;
        constructor(style: StiCrossTabStyle);
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkBluePivotElementStyle extends StiPivotElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkGrayPivotElementStyle extends StiPivotElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkGreenPivotElementStyle extends StiPivotElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkTurquoisePivotElementStyle extends StiPivotElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiGrayPivotElementStyle extends StiPivotElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGreenPivotElementStyle extends StiPivotElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        columnHeaderBackColor: Color;
        rowHeaderBackColor: Color;
        hotColumnHeaderBackColor: Color;
        hotRowHeaderBackColor: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiOrangePivotElementStyle extends StiPivotElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        columnHeaderBackColor: Color;
        rowHeaderBackColor: Color;
        hotColumnHeaderBackColor: Color;
        hotRowHeaderBackColor: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSiennaPivotElementStyle extends StiPivotElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSilverPivotElementStyle extends StiPivotElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSlateGrayPivotElementStyle extends StiPivotElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTurquoisePivotElementStyle extends StiPivotElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        columnHeaderBackColor: Color;
        rowHeaderBackColor: Color;
        hotColumnHeaderBackColor: Color;
        hotRowHeaderBackColor: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiWhiteBlackPivotElementStyle extends StiPivotElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiProgressElementStyle extends StiElementStyle {
        get localizedName(): string;
        foreColor: Color;
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        backColor: Color;
        toolTipBrush: StiBrush;
        toolTipTextBrush: StiBrush;
        toolTipCornerRadius: StiCornerRadius;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiAliceBlueProgressElementStyle extends StiProgressElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiBlueProgressElementStyle extends StiProgressElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCustomProgressElementStyle extends StiProgressElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        foreColor: Color;
        backColor: Color;
        constructor(style: StiProgressStyle);
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiDarkBlueProgressElementStyle extends StiProgressElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        backColor: Color;
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiDarkGrayProgressElementStyle extends StiProgressElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        backColor: Color;
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiDarkGreenProgressElementStyle extends StiProgressElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        backColor: Color;
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiDarkTurquoiseProgressElementStyle extends StiProgressElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        backColor: Color;
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiGrayProgressElementStyle extends StiProgressElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiGreenProgressElementStyle extends StiProgressElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiOrangeProgressElementStyle extends StiProgressElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiSiennaProgressElementStyle extends StiProgressElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiSilverProgressElementStyle extends StiProgressElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        toolTipBrush: StiSolidBrush;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiSlateGrayProgressElementStyle extends StiProgressElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        backColor: Color;
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiTurquoiseProgressElementStyle extends StiProgressElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiWhiteBlackProgressElementStyle extends StiProgressElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: System.Drawing.Color;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
        toolTipBrush: StiSolidBrush;
        toolTipTextBrush: StiSolidBrush;
        toolTipBorder: StiSimpleBorder;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTableElementStyle extends StiElementStyle {
        get localizedName(): string;
        cellBackColor: Color;
        cellForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        headerBackColor: Color;
        headerForeColor: Color;
        hotHeaderBackColor: Color;
        lineColor: Color;
        footerBackColor: Color;
        footerForeColor: Color;
        backColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellWinLossNegative: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
        cellIndicatorNeutral: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiAliceBlueTableElementStyle extends StiTableElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        cellForeColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        headerBackColor: Color;
        headerForeColor: Color;
        footerBackColor: Color;
        footerForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        hotHeaderBackColor: Color;
        lineColor: Color;
        backColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBlueTableElementStyle extends StiTableElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        headerBackColor: Color;
        headerForeColor: Color;
        footerBackColor: Color;
        footerForeColor: Color;
        cellForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        hotHeaderBackColor: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiCustomTableElementStyle extends StiTableElementStyle {
        private name2;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        constructor(style: StiTableStyle);
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkBlueTableElementStyle extends StiTableElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        headerBackColor: System.Drawing.Color;
        headerForeColor: System.Drawing.Color;
        footerBackColor: System.Drawing.Color;
        footerForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        hotHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkGrayTableElementStyle extends StiTableElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        cellForeColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        headerBackColor: Color;
        headerForeColor: Color;
        footerBackColor: Color;
        footerForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        hotHeaderBackColor: Color;
        lineColor: Color;
        backColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkGreenTableElementStyle extends StiTableElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        cellForeColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        headerBackColor: Color;
        headerForeColor: Color;
        footerBackColor: Color;
        footerForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        hotHeaderBackColor: Color;
        lineColor: Color;
        backColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkTurquoiseTableElementStyle extends StiTableElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        cellForeColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        headerBackColor: Color;
        headerForeColor: Color;
        footerBackColor: Color;
        footerForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        hotHeaderBackColor: Color;
        lineColor: Color;
        backColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiGrayTableElementStyle extends StiTableElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        headerBackColor: System.Drawing.Color;
        headerForeColor: System.Drawing.Color;
        footerBackColor: System.Drawing.Color;
        footerForeColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        hotHeaderBackColor: System.Drawing.Color;
        cellDataBarsOverlapped: System.Drawing.Color;
        cellDataBarsPositive: System.Drawing.Color;
        cellDataBarsNegative: System.Drawing.Color;
        cellWinLossPositive: System.Drawing.Color;
        cellWinLossNegative: System.Drawing.Color;
        cellSparkline: System.Drawing.Color;
        cellIndicatorPositive: System.Drawing.Color;
        cellIndicatorNegative: System.Drawing.Color;
        cellIndicatorNeutral: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGreenTableElementStyle extends StiTableElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        selectedCellBackColor: Color;
        headerBackColor: Color;
        hotHeaderBackColor: Color;
        footerBackColor: Color;
        footerForeColor: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiOrangeTableElementStyle extends StiTableElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        selectedCellBackColor: Color;
        headerBackColor: Color;
        hotHeaderBackColor: Color;
        footerBackColor: Color;
        footerForeColor: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSiennaTableElementStyle extends StiTableElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        headerBackColor: System.Drawing.Color;
        headerForeColor: System.Drawing.Color;
        footerBackColor: System.Drawing.Color;
        footerForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        hotHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
        cellDataBarsOverlapped: System.Drawing.Color;
        cellDataBarsPositive: System.Drawing.Color;
        cellDataBarsNegative: System.Drawing.Color;
        cellWinLossPositive: System.Drawing.Color;
        cellSparkline: System.Drawing.Color;
        cellIndicatorPositive: System.Drawing.Color;
        cellIndicatorNegative: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSilverTableElementStyle extends StiTableElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        cellForeColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        headerBackColor: Color;
        headerForeColor: Color;
        footerBackColor: Color;
        footerForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        hotHeaderBackColor: Color;
        lineColor: Color;
        backColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSlateGrayTableElementStyle extends StiTableElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        headerBackColor: System.Drawing.Color;
        headerForeColor: System.Drawing.Color;
        footerBackColor: System.Drawing.Color;
        footerForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        hotHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTurquoiseTableElementStyle extends StiTableElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        selectedCellBackColor: Color;
        headerBackColor: Color;
        hotHeaderBackColor: Color;
        footerBackColor: Color;
        footerForeColor: Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Styles {
    class StiWhiteBlackTableElementStyle extends StiTableElementStyle {
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        headerBackColor: System.Drawing.Color;
        headerForeColor: System.Drawing.Color;
        footerBackColor: System.Drawing.Color;
        footerForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        hotHeaderBackColor: System.Drawing.Color;
        cellDataBarsOverlapped: System.Drawing.Color;
        cellDataBarsPositive: System.Drawing.Color;
        cellDataBarsNegative: System.Drawing.Color;
        cellWinLossPositive: System.Drawing.Color;
        cellWinLossNegative: System.Drawing.Color;
        cellSparkline: System.Drawing.Color;
        cellIndicatorPositive: System.Drawing.Color;
        cellIndicatorNegative: System.Drawing.Color;
        cellIndicatorNeutral: System.Drawing.Color;
    }
}
export namespace Stimulsoft.Report.Dashboard.Visuals {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    let IStiCardsVisualSvgHelper: System.Interface<IStiCardsVisualSvgHelper>;
    interface IStiCardsVisualSvgHelper {
        writeCards(writer: XmlTextWriter, svgData: StiSvgData, refNeedToScroll?: any, refContentHeight?: any, refContentWidth?: any): Promise<void>;
    }
}
export namespace Stimulsoft.Report.Dashboard.Visuals {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    let IStiGaugeVisualSvgHelper: System.Interface<IStiGaugeVisualSvgHelper>;
    interface IStiGaugeVisualSvgHelper {
        writeGauge(writer: XmlTextWriter, svgData: StiSvgData, needAnimation: boolean, refNeedToScroll?: any, refContentHeight?: any): Promise<void>;
    }
}
export namespace Stimulsoft.Report.Dashboard.Visuals {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    let IStiIndicatorVisualSvgHelper: System.Interface<IStiIndicatorVisualSvgHelper>;
    interface IStiIndicatorVisualSvgHelper {
        writeIndicator(writer: XmlTextWriter, svgData: StiSvgData, refNeedToScroll?: any, refContentHeight?: any): Promise<void>;
    }
}
export namespace Stimulsoft.Report.Dashboard.Visuals {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    let IStiProgressVisualSvgHelper: System.Interface<IStiProgressVisualSvgHelper>;
    interface IStiProgressVisualSvgHelper {
        writeProgress(writer: XmlTextWriter, svgData: StiSvgData, refNeedToScroll?: any, refContentHeight?: any): Promise<void>;
    }
}
export namespace Stimulsoft.Report.Design {
    let IStiCopyStyleExt: System.Interface<IStiCopyStyleExt>;
    interface IStiCopyStyleExt {
        invokeSetCopyStyle(): any;
        invokeGetCopyStyle(): any;
    }
}
export namespace Stimulsoft.Report.Design {
    let IStiDesignerBase: System.Interface<IStiDesignerBase>;
    interface IStiDesignerBase {
        useAliases: boolean;
    }
}
export namespace Stimulsoft.Report.Design {
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCopyStyleExtHub {
        static visualStateDefault: StiJson;
        static visualStateHover: StiJson;
        static visualStatePressed: StiJson;
        static visualStateChecked: StiJson;
        static visualStateDisabled: StiJson;
    }
}
export namespace Stimulsoft.Report.Units {
    class StiHundredthsOfInchUnit extends StiUnit {
        get rulerStep(): number;
        get factor(): number;
        get shortName(): string;
        get name(): string;
        convertToHInches(value: number): number;
        convertFromHInches(value: number): number;
    }
}
export namespace Stimulsoft.Report.Units {
    class StiCentimetersUnit extends StiUnit {
        get rulerStep(): number;
        get factor(): number;
        get shortName(): string;
        get name(): string;
        convertToHInches(value: number): number;
        convertFromHInches(value: number): number;
    }
}
export namespace Stimulsoft.Report.Units {
    class StiMillimetersUnit extends Stimulsoft.Report.Units.StiUnit {
        get rulerStep(): number;
        get factor(): number;
        get shortName(): string;
        get name(): string;
        convertToHInches(value: number): number;
        convertFromHInches(value: number): number;
    }
}
export namespace Stimulsoft.Report.Design {
    import StiAction = Stimulsoft.Base.Drawing.StiAction;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiQuickInfoType = Stimulsoft.Report.Components.StiQuickInfoType;
    class StiDesignerInfo {
        clone(report: StiReport): StiDesignerInfo;
        forceDesigningMode: boolean;
        quickInfoType: StiQuickInfoType;
        generateLocalizedName: boolean;
        showDimensionLines: boolean;
        quickInfoOverlay: boolean;
        isComponentsMoving: boolean;
        currentAction: StiAction;
        isTableMode: boolean;
        drawEventMarkers: boolean;
        drawMarkersWhenMoving: boolean;
        runDesignerAfterInsert: boolean;
        useLastFormat: boolean;
        autoSaveInterval: number;
        enableAutoSaveMode: boolean;
        showOrder: boolean;
        alignToGrid: boolean;
        autoSaveReportToReportClass: boolean;
        showHeaders: boolean;
        showGrid: boolean;
        showInteractive: boolean;
        zoom: number;
        showRulers: boolean;
        gridSizePoints: number;
        gridSizePixels: number;
        gridSizeCentimetres: number;
        gridSizeHundredthsOfInch: number;
        gridSizeInch: number;
        gridSizeMillimeters: number;
        get gridSize(): number;
        fillBands: boolean;
        fillCrossBands: boolean;
        fillContainer: boolean;
        fillComponent: boolean;
        useComponentColor: boolean;
        gridMode: StiGridMode;
        report: StiReport;
        getFillColor(color: Color): Color;
        constructor(report?: StiReport);
    }
}
export namespace Stimulsoft.Report.Design {
    class StiExpressionPacker {
        static packExpression(expressionStr: string, report: StiReport, useBraces: boolean): string;
        static unPackExpression(expressionStr: string, report: StiReport, useBraces: boolean): string;
        private static isValidName;
        static getCorrectedAlias(report: StiReport, alias: string): string;
        private static addWord;
        private static buildDictionary;
        private static buildBusinessObject;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiAliasAttribute {
        alias: string;
        constructor(alias: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    class StiBusinessObjectSort implements IComparer<any> {
        private sortColumns;
        private rowToConditions;
        private conditions;
        private businessObject;
        compare(x: any, y: any): number;
        compareValues(value1: any, value2: any, ascendary?: boolean): number;
        clear(): void;
        constructor(sortColumns: string[], businessObject: StiBusinessObject, rowToConditions: Hashtable, conditions: any[][][]);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiBusinessObjectToDataSet {
        private dataSet;
        private relations;
        private uniques;
        private level;
        convertBusinessObjectToDataSet(name: string, obj: any): DataSet;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiAppCalcDataColumn = Stimulsoft.Base.IStiAppCalcDataColumn;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Type = Stimulsoft.System.Type;
    class StiCalcDataColumn extends StiDataColumn implements IStiJsonReportObject, IStiAppCalcDataColumn {
        implements(): any[];
        meta(): StiMeta[];
        value: string;
        get expression(): string;
        set expression(value: string);
        constructor(name?: string, alias?: string, typeT?: Type, value?: string, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiData {
        viewData: any;
        data: any;
        private _name;
        get name(): string;
        set name(value: string);
        alias: string;
        isReportData: boolean;
        private _isBusinessObjectData;
        get isBusinessObjectData(): boolean;
        set isBusinessObjectData(value: boolean);
        OriginalConnectionState: any;
        toString(): string;
        constructor(name: string, data: any, viewData?: any);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiDataBuilder {
        static getColumnFromPath(path: string, dictionary: StiDictionary): StiDataColumn;
        static getColumnFromPath2(path: string, dataSource: StiDataSource): StiDataColumn;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import DataSet = Stimulsoft.System.Data.DataSet;
    import Type = Stimulsoft.System.Type;
    class StiDataCollection extends CollectionBase<StiData> {
        getByName(name: string): StiData;
        setByName(name: string, value: StiData): void;
        findByName(name: string): StiData;
        regData(name: string, alias: string, data: DataTable | DataSet | StiDataCollection | string | Object): void;
        private regDataDataTable;
        private regDataDataSet;
        private regDataDataTable2;
        private regDataDataSet2;
        regDataStiDataCollection(datas: StiDataCollection): void;
        clearReportDatabase(): void;
        contains(data: StiData | string): boolean;
        getData(typeData: Type): StiDataCollection;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiDataColumnExt {
        static getDataSourceByColumnKey(report: StiReport, columnKey: string): StiDataSource;
        static getColumnByKey(report: StiReport, columnKey: string): StiDataColumn;
        static isNumericType(column: StiDataColumn): boolean;
        static isDateType(column: StiDataColumn): boolean;
        static isIntegerType(column: StiDataColumn): boolean;
        static isArray(column: StiDataColumn): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import DataColumn = Stimulsoft.System.Data.DataColumn;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import Type = Stimulsoft.System.Type;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiDataColumnsCollection extends CollectionBase<StiDataColumn> implements IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private decodeTypeName;
        loadFromXml(node: XmlNode): void;
        static checkType(typeName: string, type: Type): Type;
        cachedDataColumns: Hashtable;
        private directionFactor;
        dataSource: StiDataSource;
        private businessObject;
        onInsert(value: any): void;
        add(column: StiDataColumn): any;
        add(name: string, typeT: Type): any;
        add(name: string, alias: string, type: Type): any;
        contains(column: StiDataColumn | string): boolean;
        insert(index: number, column: StiDataColumn): void;
        remove(column: StiDataColumn): void;
        getByName(name: string): StiDataColumn;
        setByName(name: string, value: StiDataColumn): void;
        findByName(name: string): StiDataColumn;
        sort(order: StiSortOrder): void;
        constructor(source?: StiBusinessObject | StiDataSource | StiDataColumn[] | DataColumn[]);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiPostgreSQLSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiExpression = Stimulsoft.Report.Expressions.StiExpression;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiDataParameter extends StiExpression implements IStiName, IStiInherited, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        dataParametersCollection: StiDataParametersCollection;
        private _inherited;
        get inherited(): boolean;
        set inherited(value: boolean);
        name: string;
        get applyFormat(): boolean;
        get expression(): string;
        set expression(value: string);
        getParameterValue(): any;
        parameterValue: any;
        dataSource: StiDataSource;
        type: number;
        size: number;
        key: string;
        toString(): string;
        isStringType(dataSource: StiDataSource): boolean;
        isNumberType(dataSource: StiDataSource): boolean;
        isDateType(dataSource: StiDataSource): boolean;
        isTimeType(dataSource: StiDataSource): boolean;
        isDateTimeType(dataSource: StiDataSource): boolean;
        constructor(name?: string, value?: string, type?: number, size?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDataParametersCollection extends CollectionBase<StiDataParameter> implements IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private dataSource;
        private cachedDataParameters;
        onInsert(index: number, value: any): void;
        contains(parameter: StiDataParameter | string): boolean;
        remove(parameter: StiDataParameter): void;
        clear(): void;
        getByName(name: string): StiDataParameter;
        setByName(name: string, value: StiDataParameter): void;
        findByName(name: string): StiDataParameter;
        constructor(dataSource?: StiDataSource);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiDataJoinType = Stimulsoft.Base.StiDataJoinType;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiAppCell = Stimulsoft.Base.IStiAppCell;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiAppDataRelation = Stimulsoft.Base.IStiAppDataRelation;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import List = Stimulsoft.System.Collections.List;
    class StiDataRelation implements IStiName, IStiAlias, IStiInherited, ICloneable, IStiAppCell, IStiAppDataRelation, IStiJsonReportObject {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private parseStringArray;
        inherited: boolean;
        private _name;
        get name(): string;
        set name(value: string);
        getName(): string;
        getDictionary(): IStiAppDictionary;
        getParentDataSource(): IStiAppDataSource;
        getChildDataSource(): IStiAppDataSource;
        fetchParentColumns(): List<string>;
        fetchChildColumns(): List<string>;
        getActiveState(): boolean;
        getJoinType(): StiDataJoinType;
        getKey(): string;
        setKey(key: string): void;
        clone(): any;
        dictionary: StiDictionary;
        parentSource: StiDataSource;
        childSource: StiDataSource;
        parentColumns: string[];
        childColumns: string[];
        relationName: string;
        nameInSource: string;
        alias: string;
        isCloud: boolean;
        active: boolean;
        key: string;
        private _joinType;
        get joinType(): StiDataJoinType;
        set joinType(value: StiDataJoinType);
        toString(): string;
        constructor(nameInSource?: string, name?: string, alias?: string, parentSource?: StiDataSource, childSource?: StiDataSource, parentColumns?: string[], childColumns?: string[], key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiDataRelationSetName {
        static setName(dataRelation: StiDataRelation, report: StiReport, dataSet: DataSet, name: string): void;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiDataRetrieval {
        dispose(): void;
        private buildTokens;
        usedColumns: Hashtable;
        usedRelations: Hashtable;
        usedDataSources: Hashtable;
        retrieval(report: StiReport): void;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import DataRow = Stimulsoft.System.Data.DataRow;
    class StiDataRow {
        createDataRow(dataRow: StiDataRow): StiDataRow;
        row: DataRow;
        private dataSource;
        get dictionary(): StiDictionary;
        getByColumnName(columnName: string): any;
        getParentData(relation: string): StiDataRow;
        constructor(dataSource: StiDataSource, dataRow: DataRow);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import DataRow = Stimulsoft.System.Data.DataRow;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiDataSort implements IComparer<DataRow> {
        private sortColumns;
        private rowToConditions;
        private conditions;
        private hashValues;
        private dataSource;
        private textComp;
        private static nullObject;
        compare(x: DataRow, y: DataRow): number;
        private compareRows;
        compareValues(value1: any, value2: any, ascendary?: boolean): number;
        clear(): void;
        constructor(rowToConditions: Hashtable, conditions: any[][][], sortColumns: string[], dataSource: StiDataSource);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiService = Stimulsoft.Base.Services.StiService;
    import Type = Stimulsoft.System.Type;
    import StiDataTableSource = Stimulsoft.Report.Dictionary.StiDataTableSource;
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiDataTableSetNameService extends StiService {
        get serviceCategory(): string;
        get serviceType(): Type;
        setName(dataTableSource: StiDataTableSource, report: StiReport, dataSet: DataSet, name: string): void;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import List = Stimulsoft.System.Collections.List;
    class StiDatabaseInformation {
        tables: List<DataTable>;
        views: List<DataTable>;
        storedProcedures: List<DataTable>;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiDataRequestOption = Stimulsoft.Data.Engine.StiDataRequestOption;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import IStiAppDataColumn = Stimulsoft.Base.IStiAppDataColumn;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiDatabaseCollection = Stimulsoft.Report.Dictionary.StiDatabaseCollection;
    import StiBusinessObjectsCollection = Stimulsoft.Report.Dictionary.StiBusinessObjectsCollection;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import DataSet = Stimulsoft.System.Data.DataSet;
    import StiDatabase = Stimulsoft.Report.Dictionary.StiDatabase;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPromise = Stimulsoft.System.StiPromise;
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import IStiAppDataRelation = Stimulsoft.Base.IStiAppDataRelation;
    import IStiAppVariable = Stimulsoft.Base.IStiAppVariable;
    import IStiApp = Stimulsoft.Base.IStiApp;
    import IStiAppConnection = Stimulsoft.Base.IStiAppConnection;
    class StiDictionary implements ICloneable, IStiAppDictionary, IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiDictionary;
        fetchDataSources(): List<IStiAppDataSource>;
        fetchDataRelations(): List<IStiAppDataRelation>;
        fetchVariables(): List<IStiAppVariable>;
        getDataSourceByName(name: string): IStiAppDataSource;
        getColumnByName(name: string): IStiAppDataColumn;
        getVariableByName(name: string): IStiAppVariable;
        getVariableValueByName(name: string): any;
        getVariableValueInternal(name: string): any;
        isSystemVariable(name: string): boolean;
        isReadOnlyVariable(name: string): boolean;
        getSystemVariableValue(name: string): any;
        getApp(): IStiApp;
        openConnectionsAsync(connections: List<IStiAppConnection>): Promise<List<IStiAppConnection>>;
        openConnections(connections: List<IStiAppConnection>): List<IStiAppConnection>;
        closeConnections(connections: List<IStiAppConnection>): void;
        existsUserFunction(functionName: string): boolean;
        invokeUserFunction(functionName: string, args: any[]): any;
        reconnectListForRequestFromUserVariables: string[];
        cachedUserNamesAndPasswords: Hashtable;
        useInternalData: boolean;
        restrictions: StiRestrictions;
        cacheDataSet: DataSet;
        report: StiReport;
        dataStore: StiDataCollection;
        variables: StiVariablesCollection;
        resources: StiResourcesCollection;
        dataSources: StiDataSourcesCollection;
        databases: StiDatabaseCollection;
        businessObjects: StiBusinessObjectsCollection;
        relations: StiDataRelationsCollection;
        userFunctions: StiUserFunctionsCollection;
        get isRequestFromUserVariablesPresent(): boolean;
        private equalsColumns;
        createDatabases(loadData: boolean): void;
        createDatabasesAsync(loadData: boolean): StiPromise<void>;
        merge(dictionary: StiDictionary): void;
        mergeFile(filePath: string): void;
        removeUnusedData(): void;
        removeUnusedDataSourcesV2(): void;
        retrievalData(REFusedRelations: any, REFusedDataSources: any, REFusedColumns: any): void;
        getUnusedRelationsFromDataStore(): StiDataRelationsCollection;
        private synchronize2;
        synchronize(): void;
        synchronizeAsync(): Promise<void>;
        synchronizeBusinessObjects(): void;
        synchronizeColumns(data: StiData, dataSource: StiDataSource): void;
        synchronizeColumnsAsync(data: StiData, dataSource: StiDataSource): StiPromise<void>;
        synchronizeColumns3(data: StiBusinessObjectData, source: StiBusinessObject): void;
        synchronizeColumns2(data: any, source: StiBusinessObject): void;
        clear(): void;
        private disposeCacheDataSet;
        renameDatabase(database: StiDatabase, newName: string): void;
        removeDatabase(data: string | StiDatabase): void;
        connectToDatabasesAsync(loadData?: boolean): StiPromise<void>;
        private connectToDatabases2Async;
        connectToDatabases(loadData?: boolean, throwException?: boolean): void;
        private connectToDatabases2;
        connectAsync(loadData?: boolean, dataSources?: StiDataSource[]): StiPromise<void>;
        connect(loadData?: boolean, dataSources?: StiDataSource[]): void;
        connectV2Async(baseReport: StiReport): Promise<void>;
        connectV2(baseReport: StiReport): void;
        private checkColumnForDataSourceName;
        connectVirtualDataSourcesAsync(secondPass?: boolean): StiPromise<void>;
        connectDataTransformationsAsync(option?: StiDataRequestOption): StiPromise<void>;
        connectCrossTabDataSources(): void;
        disconnect(): void;
        private disconnectingDatabases;
        private disconnectedDatabases;
        private disconnectingConnectionInDataStore;
        private checkRelation;
        private equalsRelationColumns;
        private getRelationName;
        regRelations(virtualSources?: boolean): void;
        regRelation(relation: StiDataRelation, virtualSources: boolean): void;
        constructor(report?: StiReport);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import DataRow = Stimulsoft.System.Data.DataRow;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiGroupSummaryDataSort implements IComparer<DataRow> {
        private groupSummaries;
        private groupLines;
        private baseRowOrder;
        private groupHeaders;
        compare(row1: DataRow, row2: DataRow): number;
        private compareValues;
        clear(): void;
        constructor(groupSummaries: Hashtable<string, Hashtable<number, any>>, groupLines: Hashtable<string, Hashtable<number, any>>, groupHeaders: StiComponentsCollection, baseRowOrder: Hashtable<number, any>);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import StiHierarchicalBand = Stimulsoft.Report.Components.StiHierarchicalBand;
    class StiHierarchicalBusinessObjectSort implements IComparer<any> {
        compare(x: any, y: any): number;
        private getParentValue;
        process(): void;
        private createTree;
        private setLevelAndSort;
        private createRowList;
        private businessObject;
        private keyColumn;
        private masterKeyColumn;
        private parentValue;
        private sortColumns;
        constructor(businessObject: StiBusinessObject, band: StiHierarchicalBand, sortColumns: string[]);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiHierarchicalBand = Stimulsoft.Report.Components.StiHierarchicalBand;
    class StiHierarchicalDataSort implements IComparer<any> {
        private dataSource;
        private keyColumn;
        private masterKeyColumn;
        private parentValue;
        private sortColumns;
        compare(x: any, y: any): number;
        private getParentValue;
        process(rowToConditions: Hashtable): void;
        private createTree;
        private setLevelAndSort;
        private createRowList;
        constructor(dataSource: StiDataSource, band: StiHierarchicalBand, sortColumns: string[]);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiResourcesCollection extends CollectionBase<StiResource> implements IComparer<StiResource>, IStiJsonReportObject {
        implements(): any[];
        clone(): StiResourcesCollection;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson, report?: StiReport): void;
        loadFromXml(xmlNode: XmlNode): void;
        private directionFactor;
        compare(x: StiResource, y: StiResource): number;
        sort(order?: StiSortOrder): void;
        contains(data: StiResource | string): boolean;
        indexOf(data: StiResource | string): number;
        remove(data: StiResource | string): void;
        getByName(name: string): StiResource;
        getByAlias(alias: string): StiResource;
        setByName(name: string, value: StiResource): void;
        findByName(name: string): StiResource;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiRestrictions {
        private restrictionsDataSource;
        private restrictionsDataRelation;
        private restrictionsDataColumn;
        private restrictionsDatabase;
        private restrictionsVariable;
        private restrictionsTotal;
        private restrictionsBusinessObject;
        clear(): void;
        private getHashtable;
        add(name: string, dataType: StiDataType, type: StiRestrictionTypes): void;
        isAllowEdit(name: string, dataType: StiDataType): boolean;
        isAllowDelete(name: string, dataType: StiDataType): boolean;
        isAllowShow(name: string, dataType: StiDataType): boolean;
        isAllowMove(name: string, dataType: StiDataType): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiRow {
        private dataSource;
        private rowIndex;
        getByName(columnName: string): any;
        constructor(dataSource: StiDataSource, rowIndex: number);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiStrFix {
        static Del_(str: string): string;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiSystemVariablesHelper {
        static getSystemVariableInfo(variable: string): string;
        static getSystemVariables(report: StiReport): string[];
        protected static systemVariablesV2: string[];
        static getSystemVariablesV2(): string[];
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiType {
        name: string;
        type: Stimulsoft.System.Type;
        static getTypes(): StiTypesCollection;
        static getBaseTypes(): StiTypesCollection;
        static getTypeModeFromType(type: Stimulsoft.System.Type, REFtypeMode: any): StringConstructor | BooleanConstructor | Type | typeof System.DateTime | typeof System.DateOnly | typeof System.Guid | typeof System.TimeOnly | typeof System.TimeSpan | typeof System.Byte | typeof System.Single;
        static getTypeFromTypeMode(type: Stimulsoft.System.Type, typeMode: StiTypeMode): Stimulsoft.System.Type;
        static isDateTimeType(type: Type): boolean;
        static isIntegerType(type: Type): boolean;
        static isFloatType(type: Type): boolean;
        toString(): string;
        constructor(name: string, type: Stimulsoft.System.Type);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiTypesCollection extends CollectionBase<StiType> {
        getByName(name: string): StiType;
        setByName(name: string, value: StiType): void;
        get(type: Stimulsoft.System.Type): StiType;
        set(type: Stimulsoft.System.Type, value: StiType): void;
        regType(name: string, type: Stimulsoft.System.Type): void;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiUserNameAndPassword {
        userName: string;
        password: string;
        constructor(userName: string, password: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiToken = Stimulsoft.Base.StiToken;
    class StiVariableAsParameterHelper {
        static parameterExists(tokens: StiToken[], name: string): boolean;
        static fetchAll(query: string, parameters: StiDataParameter[], report: StiReport): StiVariable[];
        private static parameterExists2;
    }
}
export namespace Stimulsoft.Report {
    import IStiAppVariable = Stimulsoft.Base.IStiAppVariable;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiVariableExpressionHelper {
        static getVariableSpecifiedAsExpression(element: IStiElement, expression: string): IStiAppVariable;
        static isVariableSpecifiedAsExpression(element: IStiElement, expression: string): boolean;
        static extractVariableName(exp: string): string;
        static getSimpleName(name: string): string;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import DateTimeOffset = Stimulsoft.System.DateTimeOffset;
    import DateTime = Stimulsoft.System.DateTime;
    import DateOnly = Stimulsoft.System.DateOnly;
    import TimeOnly = Stimulsoft.System.TimeOnly;
    class StiVariableValueConverter {
        static getDateTimeFromValue(value: string): DateTime;
        static getDateTimeOffsetFromValue(value: string): DateTimeOffset;
        static getDateOnlyFromValue(value: string): DateOnly;
        static getTimeOnlyFromValue(value: string): TimeOnly;
        static getTimeSpanFromValue(value: string): TimeSpan;
        static getValueFromDateTime(value: Stimulsoft.System.DateTime): string;
        static getValueFromDateTimeOffset(value: Stimulsoft.System.DateTimeOffset): string;
        static getValueFromDateOnly(value: DateOnly): string;
        static getValueFromTimeOnly(value: TimeOnly): string;
        static getValueFromTimeSpan(value: TimeSpan): string;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiPromise = Stimulsoft.System.StiPromise;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    class StiCustomAdapterService extends StiSqlAdapterService {
        private processUserFunction;
        static registerCustomAdapterService(options: {
            name: string;
            process: (command: ProcessSqlDataCommand, callback: (result: any) => void) => void;
        }): void;
        private _name;
        get name(): string;
        getDataSourceType(): Stimulsoft.System.Type;
        getDataAdapter(): StiSqlAdapterService;
        create(dictionary: StiDictionary, addToDictionary?: boolean): StiDataSource;
        callRemoteApi(command: ProcessSqlDataCommand, timeout: number): StiPromise<string>;
        retrieveDataAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString: string, maxDataRows: number): StiPromise<DataTable>;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): StiPromise<StiDataSchema>;
        constructor();
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiDataTableAdapterService extends StiDataStoreAdapterService {
        get serviceName(): string;
        isObjectAdapter: boolean;
        getDataCategoryName(data: StiData): string;
        getColumnsFromDataAsync(data: StiData, dataSource: StiDataSource): StiPromise<StiDataColumnsCollection>;
        getColumnsFromData(data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        getParametersFromDataAsync(data: StiData, dataSource: StiDataSource, connectionString: string): StiPromise<StiDataParametersCollection>;
        setDataSourceNames(data: StiData, dataSource: StiDataSource): void;
        create(dictionary: StiDictionary, addToDictionary?: boolean): StiDataSource;
        getDataSourceType(): Type;
        getDataTypes(): Type[];
        getDataFromDataSource(dictionary: StiDictionary, dataSource: StiDataSource): StiData;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): StiPromise<void>;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiFileAdapterService extends StiDataStoreAdapterService {
        get serviceName(): string;
        getDataCategoryName(data: StiData): string;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiCsvAdapterService extends StiFileAdapterService {
        get name(): string;
        getColumnsFromData(data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        getParametersFromDataAsync(data: StiData, dataSource: StiDataSource, connectionString: string): StiPromise<StiDataParametersCollection>;
        setDataSourceNames(data: StiData, dataSource: StiDataSource): void;
        getDataSourceType(): Stimulsoft.System.Type;
        getDataTypes(): Stimulsoft.System.Type[];
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
        checkConvertNulls(dataSource: StiCsvSource): void;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiNoSqlDatabase = Stimulsoft.Report.Dictionary.StiNoSqlDatabase;
    import StiPromise = Stimulsoft.System.StiPromise;
    type StiNoSqlAdapterResultType = {
        columns: string[];
        rows: {}[];
        types: string[];
    };
    class StiNoSqlAdapterService extends StiDataStoreAdapterService {
        getDataCategoryName(data: StiData): string;
        testConnectionAsync(report: StiReport, connectionString: string, connectionName: string): StiPromise<string>;
        createConnectionInDataStore(dictionary: StiDictionary, database: StiNoSqlDatabase): void;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import StiPromise = Stimulsoft.System.StiPromise;
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiMongoDbAdapterService extends StiNoSqlAdapterService {
        get name(): string;
        getDataSourceType(): Stimulsoft.System.Type;
        getColumnsFromDataAsync(data: StiData, dataSource: StiSqlSource, connectionString: string): StiPromise<StiDataColumnsCollection>;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): StiPromise<void>;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): StiPromise<StiDataSchema>;
        retrieveDataAsync(report: StiReport, dataSource: StiNoSqlSource, connectionString: string, maxDataRows: number): StiPromise<DataTable>;
        getNetType(dbType: string): Stimulsoft.System.Type;
        private prepareVariables;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiBusinessObjectAdapterService extends StiDataTableAdapterService {
        get serviceName(): string;
        isObjectAdapter: boolean;
        getDataSourceType(): Type;
        getDataTypes(): Type[];
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiCrossTabAdapterService extends StiDataStoreAdapterService {
        get serviceName(): string;
        isObjectAdapter: boolean;
        getDataSourceType(): Type;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiPromise = Stimulsoft.System.StiPromise;
    import Type = Stimulsoft.System.Type;
    class StiDataTransformationAdapterService extends StiDataStoreAdapterService {
        get serviceName(): string;
        isObjectAdapter: boolean;
        edit(dictionary: StiDictionary, dataSource: StiDataSource): boolean;
        new(dictionary: StiDictionary, dataSource: StiDataSource): boolean;
        getDataTypes(): Type[];
        getColumnsFromData(data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        getParametersFromDataAsync(data: StiData, dataSource: StiDataSource, connectionString: string): StiPromise<StiDataParametersCollection>;
        getDataCategoryName(data: StiData): string;
        getDataSourceType(): Type;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiDataViewAdapterService extends StiDataStoreAdapterService {
        get serviceName(): string;
        isObjectAdapter: boolean;
        getDataSourceType(): Type;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiUserAdapterService extends StiDataStoreAdapterService {
        get serviceName(): string;
        isObjectAdapter: boolean;
        getDataSourceType(): Type;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiPromise = Stimulsoft.System.StiPromise;
    import Type = Stimulsoft.System.Type;
    class StiVirtualAdapterService extends StiDataStoreAdapterService {
        get serviceName(): string;
        isObjectAdapter: boolean;
        getDataTypes(): Type[];
        getColumnsFromDataAsync(data: StiData, dataSource: StiDataSource, connectionString: string): StiPromise<StiDataColumnsCollection>;
        getColumnsFromData(data: StiData, dataSource: StiDataSource, connectionString: string): StiDataColumnsCollection;
        getParametersFromDataAsync(data: StiData, dataSource: StiDataSource, connectionString: string): StiPromise<StiDataParametersCollection>;
        getDataCategoryName(data: StiData): string;
        getDataSourceType(): Type;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): StiPromise<void>;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiCDataConnectCloudAdapterService extends StiSqlAdapterService {
        get name(): string;
        getDataSourceType(): Type;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiDataWorldConnector = Stimulsoft.Base.StiDataWorldConnector;
    import StiPromise = Stimulsoft.System.StiPromise;
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    class StiDataWorldAdapterService extends StiNoSqlAdapterService {
        getDataSourceType(): Stimulsoft.System.Type;
        createConnector(connectionString: string): StiDataWorldConnector;
        getColumnsFromData(data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        getParametersFromDataAsync(data: StiData, dataSource: StiDataSource, connectionString: string): StiPromise<StiDataParametersCollection>;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): StiPromise<void>;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
        testConnectionAsync(report: StiReport, connectionString: string): StiPromise<string>;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): StiPromise<StiDataSchema>;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import StiGraphQLConnector = Stimulsoft.Base.StiGraphQLConnector;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiGraphQLAdapterService extends StiNoSqlAdapterService {
        get name(): string;
        createConnector(connectionString: string): StiGraphQLConnector;
        getDataSourceType(): Stimulsoft.System.Type;
        getColumnsFromData(data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        getColumnsFromDataAsync(data: StiData, dataSource: StiDataSource): StiPromise<StiDataColumnsCollection>;
        getParametersFromDataAsync(data: StiData, dataSource: StiDataSource, connectionString: string): StiPromise<StiDataParametersCollection>;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): StiPromise<void>;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
        private getVariableNames;
        testConnectionAsync(report: StiReport, connectionString: string): StiPromise<string>;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): StiPromise<StiDataSchema>;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import StiPromise = Stimulsoft.System.StiPromise;
    import Header = Stimulsoft.System.Header;
    class StiODataAdapterService extends StiSqlAdapterService {
        get serviceName(): string;
        get name(): string;
        headers: Header[];
        getDataSourceType(): Stimulsoft.System.Type;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiSqlSource, loadData: boolean): StiPromise<void>;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiSqlSource, loadData: boolean): void;
        testConnectionAsync(report: StiReport, connectionString: string, connectionName: string): StiPromise<string>;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): StiPromise<StiDataSchema>;
        getColumnsFromDataAsync(data: StiData, dataSource: StiSqlSource, connectionString: string): StiPromise<StiDataColumnsCollection>;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiPromise = Stimulsoft.System.StiPromise;
    import StiQuickBooksConnector = Stimulsoft.Base.StiQuickBooksConnector;
    import Type = Stimulsoft.System.Type;
    import StiSqlAdapterService = Stimulsoft.Report.Dictionary.StiSqlAdapterService;
    class StiQuickBooksAdapterService extends StiSqlAdapterService {
        getDataSourceType(): Type;
        createConnector(connectionString?: string): StiQuickBooksConnector;
        getColumnsFromData(data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        getParametersFromDataAsync(data: StiData, dataSource: StiDataSource, connectionString: string): StiPromise<StiDataParametersCollection>;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
        createConnectionInDataStore(dictionary: StiDictionary, database: StiSqlDatabase): void;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiFirebirdAdapterService extends StiSqlAdapterService {
        get name(): string;
        getDatabaseSpecificName(name: string): string;
        getDataSourceType(): Stimulsoft.System.Type;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): StiPromise<StiDataSchema>;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiOdbcAdapterService extends StiSqlAdapterService {
        get name(): string;
        getDataSourceType(): Stimulsoft.System.Type;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiOracleAdapterService extends StiSqlAdapterService {
        get name(): string;
        getDataSourceType(): Stimulsoft.System.Type;
        getDatabaseSpecificName(name: string): string;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): StiPromise<StiDataSchema>;
        private getColumnType;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiPostgreSQLAdapterService extends StiSqlAdapterService {
        get name(): string;
        getDatabaseSpecificName(name: string): string;
        getDataSourceType(): Stimulsoft.System.Type;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): StiPromise<StiDataSchema>;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiBusinessObjectCategory {
        category: string;
        constructor(category: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiCustomSource extends StiSqlSource {
        meta(): StiMeta[];
        clone(): StiCustomSource;
        serviceName: string;
        static registerCustomSource(serviceName: string): void;
        getDataAdapter(): StiDataAdapterService;
        getDataAdapterType(): Stimulsoft.System.Type;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiSqlSource = Stimulsoft.Report.Dictionary.StiSqlSource;
    class StiDataSourceParserHelper {
        static connectSqlSource(sqlSource: StiSqlSource): void;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiNoSqlSource extends StiSqlSource {
        get query(): string;
        set query(value: string);
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiAzureTableStorageSource extends StiNoSqlSource {
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiCosmosDbSource extends StiNoSqlSource {
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiFileDataSource extends StiDataStoreSource {
        get path(): string;
        set path(value: string);
        codePage: number;
        constructor(path?: string, name?: string, alias?: string, codePage?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiCsvSource extends StiFileDataSource implements IStiJsonReportObject {
        meta(): StiMeta[];
        getDataAdapterType(): Stimulsoft.System.Type;
        separator: string;
        convertEmptyStringToNull: boolean;
        constructor(path?: string, name?: string, alias?: string, codePage?: number, separator?: string, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiDBaseSource extends StiFileDataSource {
        meta(): StiMeta[];
        constructor(path?: string, name?: string, alias?: string, codePage?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiBigQuerySource extends StiNoSqlSource {
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiFirebaseSource extends StiNoSqlSource {
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiGoogleAnalyticsSource extends StiNoSqlSource {
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiGoogleSheetsSource extends StiDataStoreSource {
        constructor(nameInSource?: string, name?: string, alias?: string, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiMongoDbSource extends StiNoSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiMsAnalysisServicesSource extends StiNoSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiBusinessObjectSource extends StiDataTableSource {
        constructor(nameInSource?: string, name?: string, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiCrossTabDataSource extends StiDataStoreSource {
        constructor(nameInSource?: string, name?: string, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiDataViewSource extends StiDataStoreSource {
        constructor(nameInSource?: string, name?: string, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiPromise = Stimulsoft.System.StiPromise;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiFilter = Stimulsoft.Report.Components.IStiFilter;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import Type = Stimulsoft.System.Type;
    class StiVirtualSource extends StiDataStoreSource implements IStiFilter, IStiJsonReportObject {
        meta(): StiMeta[];
        filterMethodHandler: Function;
        filterOn: boolean;
        filterMode: StiFilterMode;
        filters: Components.StiFiltersCollection;
        protected getDataAdapterType(): Type;
        groupColumns: string[];
        results: string[];
        sort: string[];
        connectToDataAsync(allowConnect?: boolean): StiPromise<void>;
        connectToData2(allowConnect?: boolean): void;
        connectToDataAsync2(allowConnect?: boolean): Promise<void>;
        private connectToDataInternal;
        private compare;
        private initTotals;
        private addRow;
        clone(): any;
        constructor(nameInSource?: string, name?: string, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiCDataConnectCloudSource extends StiSqlSource {
        getDataAdapterType(): Type;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiDataWorldSource extends StiNoSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiGraphQLSource extends StiNoSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiODataSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiQuickBooksSource extends StiSqlSource {
        getDataAdapterType(): Type;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiClickHouseSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiDB2Source extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiDotConnectUniversalSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiFirebirdSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiInformixSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiMSAccessSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiMySqlSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiMariaDbSource extends StiMySqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiOdbcSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiOleDbSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiOracleSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiSQLiteSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiSnowflakeSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiSqlCeSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiSybaseAdsSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiSybaseSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiTeradataSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiVistaDBSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    enum StiDataTransformationMode {
        Dimension = 0,
        Measure = 1
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Type = Stimulsoft.System.Type;
    class StiDataTransformationColumn extends StiDataColumn implements IStiJsonReportObject {
        meta(): StiMeta[];
        expression: string;
        mode: StiDataTransformationMode;
        getDictionaryColumn(): StiDataColumn;
        constructor(name?: string, alias?: string, type?: Type, expression?: string, key?: string, mode?: StiDataTransformationMode);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import ICloneable = Stimulsoft.System.ICloneable;
    import IAsIs = Stimulsoft.System.IAsIs;
    class StiDataTransformationMeter implements IAsIs, ICloneable {
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        implements(): any[];
        clone(): StiDataTransformationMeter;
        getUniqueCode(): number;
        expression: string;
        label: string;
        constructor(expression: string, label: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    class StiDimensionTransformationMeter extends StiDataTransformationMeter implements IStiDimensionMeter {
        implements(): any[];
        getUniqueCode(): number;
        key: string;
        constructor(expression: string, label: string, key: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import IStiMeasureMeter = Stimulsoft.Base.Meters.IStiMeasureMeter;
    class StiMeasureTransformationMeter extends StiDataTransformationMeter implements IStiMeasureMeter {
        implements(): any[];
        getUniqueCode(): number;
        key: string;
        constructor(expression: string, label: string, key: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiSqlDatabase extends StiDatabase implements IStiJsonReportObject {
        private static encryptedId;
        get serviceName(): string;
        set serviceName(value: string);
        get canBeTypeChangeResult(): boolean;
        meta(): StiMeta[];
        get connectionType(): StiConnectionType;
        connectionString: string;
        get connectionStringEncrypted(): string;
        set connectionStringEncrypted(value: string);
        promptUserNameAndPassword: boolean;
        copyDataSourceFrom(dataSourceToCopy: StiDataSource): StiDataSource;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        applyDatabaseInformation(information: StiDatabaseInformation, report: StiReport, informationAll?: StiDatabaseInformation): void;
        protected applyDatabaseInformationTables(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation): void;
        protected applyDatabaseInformationViews(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation): void;
        protected applyDatabaseInformationProcedures(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation): void;
        protected applyDatabaseInformationSource(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation, dataTable: DataTable, type?: StiSqlSourceType): void;
        getDatabaseInformationAsync(report: StiReport): StiPromise<StiDatabaseInformation>;
        private static getDatabaseInformationTables;
        private static getDatabaseInformationViews;
        private static getDatabaseInformationProcedures;
        getSampleConnectionString(): string;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiCustomDatabase extends StiSqlDatabase {
        meta(): StiMeta[];
        static registerCustomDatabase(options: {
            serviceName: string;
            sampleConnectionString: string;
            process: (command: any, callback: (result: any) => void) => void;
            designerCategory?: string;
        }): void;
        private _serviceName;
        get serviceName(): string;
        set serviceName(value: string);
        get connectionType(): StiConnectionType;
        designerCategory: string;
        createDataSource(nameInSource: string, name: string): StiCustomSource;
        getDataAdapter(): StiSqlAdapterService;
        getDataAdapterType(): Stimulsoft.System.Type;
        protected applyDatabaseInformationSource(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation, dataTable: DataTable, type?: StiSqlSourceType): void;
        private _sampleConnectionString;
        getSampleConnectionString(): string;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiMaxDataRowsHelper {
        static get(report: StiReport): number;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiUndefinedDatabase extends StiDatabase {
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    enum StiConnectionType {
        Sql = 0,
        NoSql = 1,
        Azure = 2,
        Google = 3,
        OnlineServices = 4,
        Other = 5,
        Rest = 6,
        Custom = 7
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiNoSqlDatabase extends StiDatabase implements IStiJsonReportObject {
        meta(): StiMeta[];
        get connectionType(): StiConnectionType;
        connectionString: string;
        get connectionStringEncrypted(): string;
        set connectionStringEncrypted(value: string);
        promptUserNameAndPassword: boolean;
        get canEditConnectionString(): boolean;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        applyDatabaseInformation(information: StiDatabaseInformation, report: StiReport, informationAll?: StiDatabaseInformation): void;
        protected applyDatabaseInformationSource(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation, dataTable: DataTable, type?: StiSqlSourceType): void;
        getDatabaseInformationAsync(report: StiReport): StiPromise<StiDatabaseInformation>;
        private static getDatabaseInformationTables;
        createDataSource(nameInSource: string, name: string): StiNoSqlSource;
        getConnectionStringHelper(): string;
        getSampleConnectionString(): string;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiAzureBlobStorageDatabase extends StiNoSqlDatabase {
        get connectionType(): StiConnectionType;
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiAzureSqlDatabase extends StiSqlDatabase {
        get connectionType(): StiConnectionType;
        getDataAdapterType(): Stimulsoft.System.Type;
        get serviceName(): string;
        getSampleConnectionString(): string;
        getConnectionStringHelper(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiAzureTableStorageDatabase extends StiNoSqlDatabase {
        get connectionType(): StiConnectionType;
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiCosmosDbDatabase extends StiNoSqlDatabase {
        get connectionType(): StiConnectionType;
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Helpers {
    import StiDataLoaderHelperData = Stimulsoft.Base.StiDataLoaderHelperData;
    import Header = Stimulsoft.System.Header;
    class StiUniversalDataLoader {
        static loadMutiple(report: StiReport, path: string, filter: string, binary: boolean, headers: Header[], withCredentials?: boolean): StiDataLoaderHelperData[];
        static loadSingle(report: StiReport, path: string, binary: boolean, headers: Header[], withCredentials?: boolean, allowException?: boolean): StiDataLoaderHelperData;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    import StiFileDataOptions = Stimulsoft.Base.StiFileDataOptions;
    import StiDataConnector = Stimulsoft.Base.StiDataConnector;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiCsvDatabase extends StiFileDatabase implements IStiJsonReportObject {
        meta(): StiMeta[];
        separator: string;
        codePage: number;
        get serviceName(): string;
        createConnector(connectionString?: string): StiDataConnector;
        protected getConnectorOptions(report: StiReport, isSchema: boolean): StiFileDataOptions;
        protected getConnectorOptionsAsync(report: StiReport, isSchema: boolean): Promise<StiFileDataOptions>;
        getDatasourceType(): Type;
        constructor(name?: string, pathData?: string, codePage?: number, separator?: string, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    import StiFileDataOptions = Stimulsoft.Base.StiFileDataOptions;
    import StiDataConnector = Stimulsoft.Base.StiDataConnector;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiDBaseDatabase extends StiFileDatabase {
        meta(): StiMeta[];
        codePage: number;
        get serviceName(): string;
        createConnector(connectionString?: string): StiDataConnector;
        protected getConnectorOptions(report: StiReport, isSchema: boolean): StiFileDataOptions;
        protected getConnectorOptionsAsync(report: StiReport, isSchema: boolean): Promise<StiFileDataOptions>;
        getDatasourceType(): Type;
        constructor(name?: string, pathData?: string, codePage?: number, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiFileDataOptions = Stimulsoft.Base.StiFileDataOptions;
    import StiDataConnector = Stimulsoft.Base.StiDataConnector;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiExcelDatabase extends StiFileDatabase {
        meta(): StiMeta[];
        firstRowIsHeader: boolean;
        get serviceName(): string;
        createConnector(connectionString?: string): StiDataConnector;
        protected getConnectorOptions(report: StiReport, isSchema: boolean): StiFileDataOptions;
        protected getConnectorOptionsAsync(report: StiReport, isSchema: boolean): Promise<StiFileDataOptions>;
        constructor(name?: string, pathData?: string, key?: string, firstRowIsHeader?: boolean);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiDataConnector = Stimulsoft.Base.StiDataConnector;
    import StiFileDataOptions = Stimulsoft.Base.StiFileDataOptions;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiGisDataType = Stimulsoft.Base.StiGisDataType;
    class StiGisDatabase extends StiFileDatabase {
        meta(): StiMeta[];
        get serviceName(): string;
        separator: string;
        dataType: StiGisDataType;
        get canBeTypeChangeResult(): boolean;
        copyDataSourceFrom(dataSourceToCopy: StiDataSource): StiDataSource;
        createConnector(connectionString?: string): StiDataConnector;
        protected getConnectorOptions(report: StiReport, isSchema: boolean): StiFileDataOptions;
        protected getConnectorOptionsAsync(report: StiReport, isSchema: boolean): Promise<StiFileDataOptions>;
        constructor(name?: string, pathData?: string, key?: string, dataType?: StiGisDataType);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiFileDataOptions = Stimulsoft.Base.StiFileDataOptions;
    import StiDataConnector = Stimulsoft.Base.StiDataConnector;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiRelationDirection = Stimulsoft.Base.StiRelationDirection;
    import Header = Stimulsoft.System.Header;
    class StiJsonDatabase extends StiFileDatabase {
        meta(): StiMeta[];
        relationDirection: StiRelationDirection;
        headers: Header[];
        get headersString(): string;
        set headersString(value: string);
        get serviceName(): string;
        createConnector(connectionString?: string): StiDataConnector;
        protected getConnectorOptions(report: StiReport, isSchema: boolean): StiFileDataOptions;
        protected getConnectorOptionsAsync(report: StiReport, isSchema: boolean): Promise<StiFileDataOptions>;
        constructor(name?: string, pathData?: string, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiDataConnector = Stimulsoft.Base.StiDataConnector;
    import StiFileDataOptions = Stimulsoft.Base.StiFileDataOptions;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiRelationDirection = Stimulsoft.Base.StiRelationDirection;
    class StiXmlDatabase extends StiFileDatabase implements IStiJsonReportObject {
        meta(): StiMeta[];
        pathSchema: string;
        xmlType: StiXmlType;
        relationDirection: StiRelationDirection;
        get serviceName(): string;
        createConnector(connectionString?: string): StiDataConnector;
        protected getConnectorOptions(report: StiReport, isSchema: boolean): StiFileDataOptions;
        protected getConnectorOptionsAsync(report: StiReport, isSchema: boolean): Promise<StiFileDataOptions>;
        private getCommandXsd;
        private getCommandXml;
        constructor(name?: string, pathSchema?: string, pathData?: string, key?: string, xmlType?: StiXmlType);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiBigQueryDatabase extends StiNoSqlDatabase {
        get connectionType(): StiConnectionType;
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiFirebaseDatabase extends StiNoSqlDatabase {
        get connectionType(): StiConnectionType;
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiGoogleAnalyticsDatabase extends StiNoSqlDatabase {
        get connectionType(): StiConnectionType;
        get base64EncodedAuthSecret(): string;
        get accountId(): string;
        get propertyId(): string;
        get viewId(): string;
        get metrics(): string;
        get dimensions(): string;
        get startDate(): string;
        get endDate(): string;
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndPassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiGoogleSheetsDatabase extends StiDatabase {
        clientId: string;
        clientSecret: string;
        spreadsheetId: string;
        firstRowIsHeader: boolean;
        get connectionType(): StiConnectionType;
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, key?: string, clientId?: string, clientSecret?: string, spreadsheetId?: string, firstRowIsHeader?: boolean);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiMongoDbDatabase extends StiNoSqlDatabase {
        get serviceName(): string;
        createDataSource(nameInSource: string, name: string): StiNoSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getSampleConnectionString(): string;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiMsAnalysisServicesDatabase extends StiNoSqlDatabase {
        get serviceName(): string;
        createDataSource(nameInSource: string, name: string): StiNoSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getSampleConnectionString(): string;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiCDataConnectCloudDatabase extends StiSqlDatabase {
        get connectionType(): StiConnectionType;
        get serviceName(): string;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDatasourceType(): Type;
        getDataAdapterType(): Type;
        getConnectionStringHelper(): string;
        getSampleConnectionString(): string;
        protected applyDatabaseInformationProcedures(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation): void;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiDataWorldConnector = Stimulsoft.Base.StiDataWorldConnector;
    import Type = Stimulsoft.System.Type;
    class StiDataWorldDatabase extends StiNoSqlDatabase {
        get serviceName(): string;
        get connectionType(): StiConnectionType;
        get owner(): string;
        get token(): string;
        get database(): string;
        getSampleConnectionString(): string;
        createConnector(connectionString?: string): StiDataWorldConnector;
        getDataAdapterType(): Stimulsoft.System.Type;
        createDataSource(nameInSource: string, name: string): StiNoSqlSource;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiGraphQLDatabase extends StiNoSqlDatabase {
        get serviceName(): string;
        createDataSource(nameInSource: string, name: string): StiNoSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getDataAdapter(): StiNoSqlAdapterService;
        getSampleConnectionString(): string;
        get connectionType(): StiConnectionType;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Type = Stimulsoft.System.Type;
    import Header = Stimulsoft.System.Header;
    class StiODataDatabase extends StiSqlDatabase {
        meta(): StiMeta[];
        headers: Header[];
        get headersString(): string;
        set headersString(value: string);
        get serviceName(): string;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getConnectionStringHelper(): string;
        mapUserNameAndPassword(userName: string, password: string): string;
        get connectionType(): StiConnectionType;
        getSampleConnectionString(): string;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    import StiSqlDatabase = Stimulsoft.Report.Dictionary.StiSqlDatabase;
    class StiQuickBooksDatabase extends StiSqlDatabase {
        get connectionType(): StiConnectionType;
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Type;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiClickHouseDatabase extends StiSqlDatabase {
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiDB2Database extends StiSqlDatabase {
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiDotConnectUniversalDatabase extends StiSqlDatabase {
        get serviceName(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiFirebirdDatabase extends StiSqlDatabase {
        get serviceName(): string;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getSampleConnectionString(): string;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiInformixDatabase extends StiSqlDatabase {
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiMSAccessDatabase extends StiSqlDatabase {
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiMariaDbDatabase extends StiSqlDatabase {
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import Type = Stimulsoft.System.Type;
    class StiMySqlDatabase extends StiSqlDatabase {
        get serviceName(): string;
        get canBeTypeChangeResult(): boolean;
        copyDataSourceFrom(dataSourceToCopy: StiDataSource): StiDataSource;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getSampleConnectionString(): string;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiOdbcDatabase extends StiSqlDatabase {
        get serviceName(): string;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getSampleConnectionString(): string;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiOleDbDatabase extends StiSqlDatabase {
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiOracleDatabase extends StiSqlDatabase {
        get serviceName(): string;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getSampleConnectionString(): string;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiPostgreSQLDatabase extends StiSqlDatabase {
        get serviceName(): string;
        get canBeTypeChangeResult(): boolean;
        copyDataSourceFrom(dataSourceToCopy: StiDataSource): StiDataSource;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getSampleConnectionString(): string;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiSQLiteDatabase extends StiSqlDatabase {
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiSnowflakeDatabase extends StiSqlDatabase {
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiSqlCeDatabase extends StiSqlDatabase {
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiSybaseAdsDatabase extends StiSqlDatabase {
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiSybaseDatabase extends StiSqlDatabase {
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiTeradataDatabase extends StiSqlDatabase {
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiVistaDBDatabase extends StiSqlDatabase {
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        getDatasourceType(): Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import IStiAppFunction = Stimulsoft.Base.IStiAppFunction;
    import IComparable = Stimulsoft.System.IComparable;
    import Type = Stimulsoft.System.Type;
    class StiFunction implements IComparable<StiFunction>, IStiAppFunction {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        compareTo(func: StiFunction): number;
        getKey(): string;
        setKey(key: string): void;
        getName(): string;
        invoke(args: any[]): any;
        key: string;
        useFullPath: boolean;
        category: string;
        groupFunctionName: string;
        functionName: string;
        description: string;
        typeOfFunction: string;
        returnType: Type;
        returnDescription: string;
        private _argumentTypes;
        get argumentTypes(): Type[];
        set argumentTypes(value: Type[]);
        private _argumentNames;
        get argumentNames(): string[];
        set argumentNames(value: string[]);
        private _argumentDescriptions;
        get argumentDescriptions(): string[];
        set argumentDescriptions(value: string[]);
        jsFunction: Function;
        toString(): string;
        getLongFunctionString(language: StiReportLanguageType): string;
        getFunctionString(language: StiReportLanguageType, addFunctionName?: boolean): string;
        convertTypeToString(typeT: Type, language: StiReportLanguageType): string;
        constructor(category: string, groupFunctionName: string, functionName: string, description: string, typeOfFunction: string, returnType: Type, returnDescription?: string, argumentTypes?: Type[], argumentNames?: string[], argumentDescriptions?: string[]);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiFunctionsData {
        private static isCreated;
        static create(): void;
        static isAllDataRowNullOrEmpty(dataSource: any, dataColumn: string): boolean;
        static isDataEmpty(dataSource: any): boolean;
        static isNull(dataSource: any, dataColumn: string): boolean;
        static isNullOrEmpty2(dataSource: any, dataColumn: string): boolean;
        static isNullOrEmpty(value: any): boolean;
        static isNullOrWhiteSpace2(dataSource: any, dataColumn: string): boolean;
        static isNullOrWhiteSpace(value: any): boolean;
        static isNumeric(value: any): boolean;
        static next(dataSource: any, dataColumn: string): any;
        static nextIsNull(dataSource: any, dataColumn: string): any;
        static previous(dataSource: any, dataColumn: string): any;
        static vLookupStr(value: any, dataObject: any, dataColumnToLook: string, dataColumnToReturn: string, exactMatch: boolean): any;
        static vLookup(value: any, dataObject: any, dataColumnToLook: string, dataColumnToReturn: string, asString?: boolean, exactMatch?: boolean): any;
        static previousIsNull(dataSource: any, dataColumn: string): any;
        static joinColumnContent(dataSource: StiBusinessObject | StiDataSource, dataColumn: string, delimiter: string, distinct?: boolean): string;
        static toQueryString<T>(list: T[], quotationMark: string, dateTimeFormat: string, needEscape?: boolean): string;
        static getRealPageNumber(sender: object): number;
        static getCrossTabColumnValue(sender: object): string;
        static getCrossTabRowValue(sender: object): string;
        static coalesce(...args: any[]): object;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    import Font = Stimulsoft.System.Drawing.Font;
    import HatchStyle = Stimulsoft.System.Drawing.Drawing2D.HatchStyle;
    import StiHatchBrush = Stimulsoft.Base.Drawing.StiHatchBrush;
    import StiGlassBrush = Stimulsoft.Base.Drawing.StiGlassBrush;
    import StiGlareBrush = Stimulsoft.Base.Drawing.StiGlareBrush;
    import StiGradientBrush = Stimulsoft.Base.Drawing.StiGradientBrush;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiFunctionsDrawing {
        private static isCreated;
        static create(): void;
        static aRGB(alpha: number, red: number, green: number, blue: number): Color;
        static rGB(red: number, green: number, blue: number): Color;
        static colorValue(value: string): Color;
        static colorFade(color: any, fadeAmount: number): Color;
        static solidBrushValue(color: any): StiSolidBrush;
        static gradientBrushValue(startColor: any, endColor: any, angle: number): StiGradientBrush;
        static glareBrushValue(startColor: any, endColor: any, angle: number, focus: number, scale: number): StiGlareBrush;
        static glassBrushValue(color: any, drawHatch: boolean, blendFactor: number): StiGlassBrush;
        static hatchBrushValue(style: HatchStyle, foreColor: any, backColor: any): StiHatchBrush;
        private static getColor;
        static fontValue(name: string, size: number, style?: FontStyle): Font;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiFunctionsMath {
        private static isCreated;
        static create(): void;
        static div(value1: number, value2: number): number;
        static divZeroResult(value1: number, value2: number, zeroResult: number): number;
        static truncate(value: number): number;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiFunctionsProgramming {
        private static isCreated;
        static create(): void;
        static rand(seed?: number): number;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import DateTime = Stimulsoft.System.DateTime;
    class StiFunctionsStrings {
        private static isCreated;
        static create(): void;
        static length2(str: any): number;
        static trim(str: any): string;
        static toLowerCase(str: any): string;
        static toUpperCase(str: any): string;
        static toProperCase(str: any): string;
        static substring(str: any, startIndex: number, length: number): string;
        static left(str: any, length: number): string;
        static right(str: any, length: number): string;
        static replace(str: any, oldValue: any, newValue: any): string;
        static remove(str: any, startIndex: number, count: number): string;
        static insert(str: any, startIndex: number, value: any): string;
        static mid(str: any, startIndex: number, length: number): string;
        static roman(value: number): string;
        static abc(value: number | string): string;
        static arabic(value: number | string): string;
        static persian(value: number | string): string;
        static toWords(value: number, upperCase?: boolean, femaleEs?: boolean): string;
        static dateToStr(value: DateTime, upperCase?: boolean): string;
        static toCurrencyWords(value: number, upperCase: boolean, showCents: boolean, dollars?: string, cents?: string): string;
        static toCurrencyWords2(value: number, upperCase?: boolean | string, showCents?: boolean | number | string, dollars?: string | boolean, cents?: string): string;
        static toOrdinal(value: number): string;
        static toWordsRu(value: number, upperCase?: boolean): string;
        static strToDateTime(value: string): DateTime;
        static strToNullableDateTime(value: string): DateTime;
        static tryParseDateTime(value: string): boolean;
        static tryParseLong(value: string): boolean;
        static tryParseDouble(value: string): boolean;
        static tryParseDecimal(value: string): boolean;
        static parseDateTime(value: string): DateTime;
        static parseDecimal(value: string): number;
        static parseDouble(value: string): number;
        static parseLong(value: string): number;
        static dateToStrRu(value: DateTime, upperCase?: boolean): string;
        static toCurrencyWordsRu(value: number, cents?: boolean, currency?: string, uppercase?: boolean): string;
        static toCurrencyWordsThai(value: number): string;
        static toWordsUa(value: number, uppercase?: boolean, gender?: Stimulsoft.Report.Func.Gender): string;
        static dateToStrUa(value: DateTime, upperCase?: boolean): string;
        static toCurrencyWordsUa(value: number, cents?: boolean, currency?: string, uppercase?: boolean): string;
        static toWordsPt(value: number, upperCase: boolean): string;
        static toCurrencyWordsPt(value: number, upperCase: boolean, showCents: boolean, dollars?: string, cents?: string | number): string;
        static toCurrencyWordsPtBr(value: number, uppercase?: boolean, dollars?: string, cents?: string): string;
        static DateToStrPt(value: DateTime): string;
        static dateToStrPtBr(value: DateTime): string;
        static toCurrencyWordsFr(numberr: number, currencyISO: string, decimals: number): string;
        static toCurrencyWordsEs(numberr: number, currencyISO: string, decimals: number, female?: boolean): string;
        static toWordsEs(value: number, upperCase: boolean, female?: boolean): string;
        static toWordsEs2(value: number, upperCase: boolean, female: boolean): string;
        static toCurrencyWordsNl(numberr: number, currencyISO: string, decimals: number): string;
        static toCurrencyWordsEnGb(numberr: number, currencyISO: string, decimals: number): string;
        static toWordsPl(value: number, upperCase: boolean): string;
        static dateToStrPl(value: DateTime, upperCase: boolean): string;
        static toCurrencyWordsPl(value: number, currencyISO: string, showCents: boolean, upperCase: boolean): string;
        static toWordsEnIn(value: number, blankIfZero: boolean): string;
        static toCurrencyWordsEnIn(currencyBasicUnit: string, currencyFractionalUnit: string, value: number, decimalPlaces: number, blankIfZero?: boolean): string;
        static toWordsFa(value: number): string;
        static toWordsZh(value: number): string;
        static toCurrencyWordsZh(value: number): string;
        static toWordsTr(value: number): string;
        static toCurrencyWordsTr(value: number, currencyName?: string, showZeroCents?: boolean): string;
        static toCurrencyWordsTr2(value: number, currencyName?: string, showZeroCents?: boolean): string;
        static toWordsAr(value: number): string;
        static toCurrencyWordsAr(value: number, currencyBasicUnit: string, currencyFractionalUnit: string): string;
        static convertToBase64String(value: string): string;
        static toWordsBg(value: number, upperCase: boolean): string;
        static toCurrencyWordsBg(value: number, currencyISO: string, showCents?: boolean, upperCase?: boolean): string;
        static compare(str1: string, str2: string): number;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    class StiFunctionsTotals {
        private static isCreated;
        static create(): void;
    }
}
export namespace Stimulsoft.Report.Dictionary.Helpers {
    import StiSqlSource = Stimulsoft.Report.Dictionary.StiSqlSource;
    import StiSqlDatabase = Stimulsoft.Report.Dictionary.StiSqlDatabase;
    import StiDataTableSource = Stimulsoft.Report.Dictionary.StiDataTableSource;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    class StiDatabaseTypeChangeHelper {
        static copyToSqlSource(dataSourceToCopy: StiDataSource, targetDatabase: StiSqlDatabase): StiSqlSource;
        static copyToFileSource(dataSourceToCopy: StiDataSource, targetDatabase: StiFileDatabase): StiDataTableSource;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    enum StiFunctionCategory {
        Data = 0,
        DateTime = 1,
        Drawing = 2,
        Math = 3,
        Programming = 4,
        Strings = 5,
        Totals = 6,
        Custom = 7
    }
    enum StiUserFunctionArgumentType {
        String = 0,
        Float = 1,
        Double = 2,
        Decimal = 3,
        DateTime = 4,
        DateTimeOffset = 5,
        DateOnly = 6,
        TimeSpan = 7,
        TimeOnly = 8,
        Sbyte = 9,
        Byte = 10,
        ByteArray = 11,
        Short = 12,
        Ushort = 13,
        Int = 14,
        Uint = 15,
        Long = 16,
        Ulong = 17,
        Bool = 18,
        Char = 19,
        Guid = 20,
        Object = 21,
        Text = 22
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiUserFunction {
        clone(): StiUserFunction;
        meta(): StiMeta[];
        name: string;
        description: string;
        category: StiFunctionCategory;
        customCategory: string;
        arguments: StiUserFunctionArgumentsCollection;
        returnType: StiUserFunctionArgumentType;
        scriptCSharp: string;
        scriptVB: string;
        scriptJS: string;
        scriptBlockly: string;
        set script(value: string);
        getFullScript(language: StiReportLanguageType): string;
        constructor(name?: string, category?: StiFunctionCategory, returnType?: StiUserFunctionArgumentType);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiUserFunctionArgument {
        clone(): StiUserFunctionArgument;
        meta(): StiMeta[];
        static loadFromXml(xmlNode: XmlNode): StiUserFunctionArgument;
        name: string;
        type: StiUserFunctionArgumentType;
        description: string;
        toString(): string;
        constructor(name?: string, type?: StiUserFunctionArgumentType, description?: string);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiUserFunctionArgumentsCollection extends CollectionBase<StiUserFunctionArgument> implements IStiJsonReportObject, ICloneable, IComparer<any> {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        compare(x: any, y: any): number;
        getByName(name: string): StiUserFunctionArgument;
        setByName(name: string, value: StiUserFunctionArgument): void;
        clone(): StiUserFunctionArgumentsCollection;
        existsName(name: string): boolean;
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiUserFunctionsCollection extends CollectionBase<StiUserFunction> implements IStiJsonReportObject, ICloneable, IComparer<any> {
        implements(): any[];
        private dictionary;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        compare(x: any, y: any): number;
        getByName(name: string): StiUserFunction;
        setByName(name: string, value: StiUserFunction): void;
        clone(): StiUserFunctionsCollection;
        existsName(name: string): boolean;
        generateEmptyFunctionName(): string;
        findByName(userFunctionName: string): StiUserFunction;
        constructor(dictionary: StiDictionary);
    }
}
export namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    class StiUserFunctionHelper {
        static invokeFunction(functionn: StiUserFunction, report: StiReport, argumentss?: Dictionary<string, object>): object;
        static getArgumentType(argumentType: StiUserFunctionArgumentType): Type;
        static getCategoryName(functionn: StiUserFunction): string;
        static getReturnTypeScript(language: StiReportLanguageType, functionn: StiUserFunction): string;
        static generateFirstLineScript(language: StiReportLanguageType, functionn: StiUserFunction): string;
        static generateFunctionNameForDictionary(functionn: StiUserFunction): string;
        static generateArguments(language: StiReportLanguageType, functionn: StiUserFunction): string;
        static convertArgumentTypeToString(type: StiUserFunctionArgumentType, language: StiReportLanguageType): string;
        static isNameCorrectly(name: string): boolean;
    }
}
export namespace Stimulsoft.Report.Engine {
    let IStiReportProperty: System.Interface<IStiReportProperty>;
    interface IStiReportProperty {
        getReport(): any;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiBand = Stimulsoft.Report.Components.StiBand;
    class StiBandsOnAllPages {
        private bands;
        engine: StiEngine;
        private _denyRendering;
        get denyRendering(): boolean;
        set denyRendering(value: boolean);
        add(dataBand: StiDataBand, band: StiBand): void;
        remove(dataBand: StiDataBand): void;
        private allowRenderBand;
        getBandsList(): StiDataBand[];
        renderAsync(): Promise<void>;
        render(): void;
        private renderBandAsync;
        private renderBand;
        isBandInBandsList(band: StiBand): boolean;
        constructor(engine: StiEngine);
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiBreakableHelper {
        engine: StiEngine;
        isCanBreak(container: StiContainer): boolean;
        isNeedBreak(container: StiContainer): boolean;
        breakAsync(originalContainer: StiContainer): Promise<StiContainer>;
        break(originalContainer: StiContainer): StiContainer;
        setCanBreak(container: StiContainer): void;
        processBreakableAsync(container: StiContainer): Promise<StiContainer>;
        processBreakable(container: StiContainer): StiContainer;
        constructor(engine: StiEngine);
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiColumnDirection = Stimulsoft.Report.Components.StiColumnDirection;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiColumnsContainer extends StiContainer {
        private countOfItems;
        columns: number;
        columnWidth: number;
        columnGaps: number;
        columnDirection: StiColumnDirection;
        rightToLeft: boolean;
        minRowsInColumn: number;
        private engine;
        addContainer(container: StiContainer): void;
        howMuchAdditionalSpaceNeeded(currentHeight: number, container: StiContainer): number;
        finishColumns(onlyCalc?: boolean): number;
        getCurrentColumn(): number;
        getLengthOfLastRow(): number;
        constructor(engine?: StiEngine);
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    class StiColumnsOnDataBand {
        engine: StiEngine;
        private _enabled;
        get enabled(): boolean;
        set enabled(value: boolean);
        renderColumnsAsync(dataBand: StiDataBand): Promise<StiColumnsContainer>;
        renderColumns(dataBand: StiDataBand): StiColumnsContainer;
        getColumns(): StiColumnsContainer;
        createColumns(dataBand: StiDataBand): StiColumnsContainer;
        constructor(engine: StiEngine);
    }
}
export namespace Stimulsoft.Report.Engine {
    class StiColumnsOnPanel {
        engine: StiEngine;
        get count(): number;
        get rightToLeft(): boolean;
        get columnGaps(): number;
        currentColumn: number;
        getColumnWidth(): number;
        constructor(engine: StiEngine);
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiEmptyBand = Stimulsoft.Report.Components.StiEmptyBand;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiEmptyBandsHelper {
        engine: StiEngine;
        private emptyBand;
        register(emptyBands: StiComponentsCollection): void;
        clear(): void;
        private createEmptyBandContainerAsync;
        private createEmptyBandContainer;
        findDataBand(emptyBand: StiEmptyBand): StiDataBand;
        renderAsync(containerForRender: StiContainer, selectedContainer: StiContainer): Promise<void>;
        render(containerForRender: StiContainer, selectedContainer: StiContainer): void;
        constructor(engine: StiEngine);
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiCondition = Stimulsoft.Report.Components.StiCondition;
    import StiBookmark = Stimulsoft.Report.Components.StiBookmark;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiFooterBand = Stimulsoft.Report.Components.StiFooterBand;
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import IStiPageBreak = Stimulsoft.Report.Components.IStiPageBreak;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiSimpleText = Stimulsoft.Report.Components.StiSimpleText;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiEngine {
        firstPassPointer: StiBookmark;
        isDynamicBookmarksMode: boolean;
        isCrossBandsMode: boolean;
        isFirstDataBandOnPage: boolean;
        isLastDataBandOnPage: boolean;
        printOnAllPagesIgnoreList: Hashtable;
        private printOnAllPagesIgnoreList2;
        bandsOnAllPages: StiBandsOnAllPages;
        denyRenderMasterComponentsInContainer: boolean;
        printAtBottom: StiPrintAtBottom;
        footersOnAllPages: StiFootersOnAllPages;
        staticBands: StiStaticBandsHelper;
        threads: StiThreads;
        breakable: StiBreakableHelper;
        denyChangeThread: boolean;
        slaveEngines: Hashtable<string, StiEngine>;
        masterEngine: StiEngine;
        emptyBands: StiEmptyBandsHelper;
        pageNumbers: StiPageNumberHelper;
        columnsOnDataBand: StiColumnsOnDataBand;
        columnsOnPanel: StiColumnsOnPanel;
        freeSpace: number;
        crossFreeSpace: number;
        positionX: number;
        positionY: number;
        positionBottomY: number;
        containerForRender: StiContainer;
        page: StiPage;
        templatePage: StiPage;
        templateContainer: StiContainer;
        report: StiReport;
        masterReport: StiReport;
        ignoreUnlimitedHeightForNewPage: boolean;
        keepFirstDetailTogetherList: Hashtable;
        keepFirstDetailTogetherTablesList: Hashtable;
        specialContainerHeight: number;
        specialContainerHeight2: number;
        static specialContainerHeight2: number;
        startIndexPageForPageTotal: number;
        indexPageForPageTotal: number;
        private childsBandHash;
        silentMode: boolean;
        renderState: StiRenderState;
        indexOfLatestDataBand: StiIndex;
        generateNewPageBeforeBand: boolean;
        ignoreSkipFirst: boolean;
        generateNewColumnBeforeBand: boolean;
        pageBreakSkipFirstCollection: Hashtable;
        indexOfStartList: number;
        skipFirstPageBeforePrintEvent: boolean;
        firstCallNewPage: boolean;
        denyClearPrintOnAllPagesIgnoreList: boolean;
        duplilcatesLastValues: Hashtable;
        anchorsArguments: Hashtable;
        private needResetPageNumberForNewPage;
        private _parserConversionStore;
        get parserConversionStore(): Hashtable<string, {
            key: StiCondition;
            value: string;
        }[] | any>;
        set parserConversionStore(value: Hashtable<string, {
            key: StiCondition;
            value: string;
        }[] | any>);
        hashParentStyles: Hashtable;
        private _hashUseParentStyles;
        get hashUseParentStyles(): Hashtable;
        set hashUseParentStyles(value: Hashtable);
        lastInvokeTextProcessValueEventArgsValue: any;
        lastInvokeTextProcessIndexEventArgsValue: any;
        atLeastOneDatabandRenderedOnPage: boolean;
        lastFreeSpaceOnPageAfterNewList: number;
        bandsInProgress: StiBand[];
        allowEndOfPageProcessing: boolean;
        private flagRenderColumnsOnDataBandOnNewPage;
        private componentPlacementRemakeTable;
        hashCheckSize: Hashtable;
        hashDataSourceReferencesCounter: Hashtable;
        hashDataBandLastLine: Hashtable;
        offsetNewColumnY: number;
        latestProgressValue: number;
        newListAsync(skipStaticBands?: boolean): Promise<void>;
        newList(skipStaticBands?: boolean): void;
        newColumnAsync(ignoreKeepContainers?: boolean): Promise<void>;
        newColumn(ignoreKeepContainers?: boolean): void;
        newPageTime: number;
        newPageAsync(ignoreKeepContainers?: boolean): Promise<void>;
        newPageAsync2(ignoreKeepContainers?: boolean): Promise<void>;
        NewPage(ignoreKeepContainers?: boolean): void;
        newPage(ignoreKeepContainers?: boolean): void;
        private newContainerAsync;
        private newContainer;
        newDestinationAsync(ignoreKeepContainers?: boolean): Promise<void>;
        newDestination(ignoreKeepContainers?: boolean): void;
        addFooterMarker(footerMaster: StiFooterBand): void;
        addKeepLevelAtLatestDataBand(): void;
        addLevel(): void;
        removeLevel(): void;
        private getChildBands;
        clearPageBreakSkipFirst(): void;
        canGenerateNewContainer(pageBreak: IStiPageBreak): boolean;
        removeBandFromPageBreakSkipList(pageBreak: IStiPageBreak): void;
        processPageAfterRendering(page: StiPage, final: boolean): void;
        processLastPageAfterRendering(): void;
        private processRendering;
        private reprocessRuntimeVariables;
        finalClearAsync(): Promise<void>;
        finalClear(): void;
        private isPrintAtBottomOrFooterOnAllPages;
        private changeEngineParamsByKeep;
        private setNewColumnParameters;
        setNewPageParameters(): void;
        private processNewContainerBeforeAsync;
        private processNewContainerBefore;
        private processNewContainerAfter;
        private processNewContainerInDetailBandsAsync;
        private processNewContainerInDetailBands;
        private searchStartOfKeepContainer;
        private moveKeepComponentsOnNextContainerAsync;
        private moveKeepComponentsOnNextContainer;
        private correctPrintOnAllPagesIgnoreListBeforeNewList;
        private isNeedToPrintOddEven;
        private isNeedToSkip;
        renderFootersOnAllPages(outContainer: StiContainer, startIndex?: number, REFmarkerContainer?: any): void;
        renderEmptyBandsAsync(containerForRender: StiContainer, selectedContainer: StiContainer): Promise<void>;
        renderEmptyBands(containerForRender: StiContainer, selectedContainer: StiContainer): void;
        renderPrintAtBottom(container: StiContainer, startIndex: number, markerContainer: StiContainer): void;
        finishContainer(containerForRender: StiContainer): void;
        finishResetPageNumberContainer(containerForRender: StiContainer, isFinal: boolean): void;
        finishColumns(containerForRender: StiContainer): void;
        addContainerToDestination(container: StiContainer): void;
        invokePageAfterPrint(): void;
        addPageToRenderedPages(page: StiPage): void;
        private checkFreeSpace1Async;
        private checkFreeSpace1;
        private checkFreeSpace2Async;
        private checkFreeSpace2;
        private storeLatestDataBand;
        private setReportVariables;
        checkForDuplicate(textName: string, value: string, tag: string): boolean;
        resetProcessingDuplicates1(componentName: string): void;
        resetProcessingDuplicates2(component: StiSimpleText): void;
        getSumTagsOnPage(page: StiPage, componentName: string): number;
        getComponentByNameFromRenderedPage(page: StiPage, componentName: string): StiComponent;
        renderBandAsync(band: StiBand, ignorePageBreaks?: boolean, allowRenderingEvents?: boolean): Promise<StiComponentsCollection>;
        renderBand(band: StiBand, ignorePageBreaks?: boolean, allowRenderingEvents?: boolean): StiComponentsCollection;
        private internalRenderBandAsync;
        private internalRenderBand;
        private checkContainerOnTable;
        renderContainerAsync(container: StiContainer, isPrintAtBottom?: boolean, isFooterOnAllPages?: boolean): Promise<StiContainer>;
        renderContainer(container: StiContainer, isPrintAtBottom?: boolean, isFooterOnAllPages?: boolean): StiContainer;
        private internalRenderColumnsContainer;
        checkBreakColumnsContainer(columns: StiColumnsContainer): void;
        private internalRenderContainerToColumnsAsync;
        private internalRenderContainerToColumns;
        private internalRenderContainerAsync;
        private internalRenderContainer;
        constructor(report: StiReport);
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiFooterMarkerContainer extends StiContainer {
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiFootersOnAllPages {
        private bands;
        engine: StiEngine;
        add(container: StiContainer): void;
        canProcess(band: StiBand): boolean;
        render(outContainer: StiContainer, startIndex: number, REFmarkerContainer: any): void;
        constructor(engine: StiEngine);
    }
}
export namespace Stimulsoft.Report.Engine {
    class StiIndex {
        index: number;
        indexInColumnContainer: number;
        constructor(index: number, indexInColumnContainer?: number);
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiLevelContainer extends StiContainer {
    }
}
export namespace Stimulsoft.Report.Engine {
    class StiLevelEndContainer extends StiLevelContainer {
        constructor();
    }
}
export namespace Stimulsoft.Report.Engine {
    class StiLevelStartContainer extends StiLevelContainer {
        constructor();
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiNewPageContainer extends StiContainer {
        constructor();
    }
}
export namespace Stimulsoft.Report.Engine {
    import IStiOddEvenStyles = Stimulsoft.Report.Components.IStiOddEvenStyles;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    class StiOddEvenStylesHelper {
        static applyOddEvenStyles(report: StiReport, styles: IStiOddEvenStyles, cont: StiContainer): StiBaseStyle;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiSubReport = Stimulsoft.Report.Components.StiSubReport;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiPageHelper {
        static createListOfDataBands(page: StiPage, dataBandsOnPage: StiDataBand[], dataBandsInContainers: StiDataBand[], subReportsOnPage: StiSubReport[], crossTabsOnPage: StiCrossTab[]): void;
        static getReportTitles(page: StiPage): Stimulsoft.Report.Components.StiReportTitleBand[];
        static getReportSummaries(page: StiPage): Stimulsoft.Report.Components.StiReportSummaryBand[];
        static renderSimpleComponentsAsync(page: StiPage, outContainer: StiContainer): Promise<void>;
        static renderSimpleComponents(page: StiPage, outContainer: StiContainer): void;
        private static checkContainerForBandsAndOtherContainers;
        static prepareBookmark(page: StiPage): void;
        static preparePointer(page: StiPage): void;
        static renderPageAsync(page: StiPage): Promise<void>;
        static renderPage(page: StiPage): void;
        static renderOverlaysAsync(masterPage: StiPage, renderedPage: StiPage): Promise<void>;
        static renderOverlays(masterPage: StiPage, renderedPage: StiPage): void;
        static getPageFromTemplateAsync(templatePage: StiPage): Promise<StiPage>;
        static getPageFromTemplate(templatePage: StiPage): StiPage;
    }
}
export namespace Stimulsoft.Report.Engine {
    class StiPageNumber {
        resetPageNumber: boolean;
        pageNumber: number;
        totalPageCount: number;
        pageNumberThrough: number;
        totalPageCountThrough: number;
        segmentPerWidth: number;
        segmentPerHeight: number;
        get step(): number;
        fixedPosition: boolean;
    }
}
export namespace Stimulsoft.Report.Engine {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiPageNumberCollection extends CollectionBase<StiPageNumber> {
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiPageNumberHelper {
        private engine;
        private finished;
        clearPageNumbersOnFinish: boolean;
        pageNumbers: StiPageNumberCollection;
        resetPageNumber(pageIndex?: number): void;
        addPageNumber(pageIndex: number, segmentPerWidth: number, segmentPerHeight: number): void;
        getPageNumber(param1: StiPage | number | any): number;
        getTotalPageCount(param1: StiPage | number | any): number;
        getPageNumberThrough(param1: StiPage | number | any): number;
        getTotalPageCountThrough(pageIndex: number): number;
        private setSystemVariables;
        processPageNumbers(): void;
        clear(): void;
        clearNotFixed(): void;
        constructor(engine: StiEngine);
    }
}
export namespace Stimulsoft.Report.Engine {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    enum TypeOfDuplicates {
        Text = 0,
        Image = 1
    }
    class StiMergeComparer implements IComparer<StiComponent> {
        compare(x: StiComponent, y: StiComponent): number;
    }
    class StiPostProcessDuplicatesHelper {
        private static isImageEqual;
        static postProcessDuplicates(comps: StiComponentsCollection, parentCont: Hashtable, typeOfDuplicates?: TypeOfDuplicates): void;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    import StiCrossLinePrimitive = Stimulsoft.Report.Components.StiCrossLinePrimitive;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiLinePrimitive = Stimulsoft.Report.Components.StiLinePrimitive;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiPostProcessProvider {
        private static nullGuid;
        static postProcessPages(pages: StiPagesCollection): void;
        private static removeAllPointPrimitives;
        static postProcessPrimitives(page: StiPagesCollection | Stimulsoft.Report.Components.StiPage): void;
        static postProcessPrimitivesInContainer(container: StiContainer): void;
        static postProcessPrimitivesInContainer2(container: StiContainer, pages: StiPagesCollection, REFstartPointsHash: any, REFendPointsHash: any, REFlines: any, REFendPoints: any): void;
        private static processOneEndPoint;
        private static processOnePrimitive;
        static addPrimitive(crossLine: StiCrossLinePrimitive, startPos: PointD, endPos: PointD, page: StiContainer): void;
        static copyStyles(dest: StiLinePrimitive, source: StiLinePrimitive): void;
        static postProcessPage(page: Stimulsoft.Report.Components.StiPage, isFirstPage: boolean, isLastPage: boolean, clearPage?: boolean): void;
        private static postProcessPrintOn;
        private static allowPrintOn;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiPrintAtBottom {
        private bands;
        engine: StiEngine;
        canProcess(band: StiBand): boolean;
        add(container: StiContainer): void;
        render(outContainer: StiContainer, startIndex: number, markerContainer: StiContainer): void;
        constructor(engine: StiEngine);
    }
}
export namespace Stimulsoft.Report.Engine {
    class StiStaticBandsHelper {
        private denyReportBands;
        private denyPageBands;
        engine: StiEngine;
        private _reservedFreeSpace;
        get reservedFreeSpace(): number;
        private _reservedCrossFreeSpace;
        get reservedCrossFreeSpace(): number;
        private _reservedPositionX;
        get reservedPositionX(): number;
        private _reservedPositionY;
        get reservedPositionY(): number;
        private _reservedPositionBottomY;
        get reservedPositionBottomY(): number;
        renderAsync(): Promise<void>;
        render(): void;
        private renderTitleBeforeHeaderAsync;
        private renderTitleBeforeHeader;
        private renderHeaderBeforeTitleAsync;
        private renderHeaderBeforeTitle;
        private renderReportTitleBandsAsync;
        private renderReportTitleBands;
        private renderPageHeaderBandsAsync;
        private renderPageHeaderBands;
        private renderPageFooterBandsAsync;
        private renderPageFooterBands;
        private getPageHeaders;
        private getPageFooters;
        private getPageHeadersFromPage;
        private getPageFootersFromPage;
        constructor(engine: StiEngine);
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiThreads {
        isActive: boolean;
        currentPage: number;
        currentColumn: number;
        destinationName: string;
        newPageAsync(): Promise<void>;
        newPage(): void;
        selectThreadFromContainerAsync(container: StiContainer): Promise<void>;
        selectThreadFromContainer(container: StiContainer): void;
        createContainerEngineAsync(destinationName: string, report: StiReport, masterEngine: StiEngine, indexOfStartRenderedPages: number): Promise<StiEngine>;
        createContainerEngine(destinationName: string, report: StiReport, masterEngine: StiEngine, indexOfStartRenderedPages: number): StiEngine;
        getTemplateContainer(template?: StiContainer, name?: string): StiContainer;
        getDestinationContainer(): StiContainer;
        private getDestinationContainer2;
        engine: StiEngine;
        constructor(engine: StiEngine);
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiVariable = Stimulsoft.Report.Dictionary.StiVariable;
    import StiDialogInfo = Stimulsoft.Report.Dictionary.StiDialogInfo;
    class StiVariableHelper {
        private static reportToLabels;
        static fillItemsOfVariables(compiledReport: StiReport, modeItems?: boolean): boolean;
        static fillItemsOfVariable(variable: StiVariable, compiledReport: StiReport, REFmodified: {
            ref: boolean;
        }, modeItems?: boolean): boolean;
        private static getItemsFromDataColumn;
        static filter(report: StiReport, info: StiDialogInfo, REFkeys: {
            ref: any[];
        }, REFvalues: {
            ref: any[];
        }, REFvaluesBinding: {
            ref: any[];
        }, REFcheckedStates: {
            ref: boolean[];
        }): void;
        private static getChecked;
        private static fillVariableList;
        private static isListType;
        private static isRangeType;
        static setDefaultValueForRequestFromUserVariables(report: StiReport, haveVars: boolean, allowParseQuery?: boolean, isConnectToDataV2?: boolean): void;
        static setDefaultValueForRequestFromUserVariablesAsync(report: StiReport, haveVars: boolean, allowParseQuery?: boolean, isConnectToDataV2?: boolean): Promise<void>;
        static setDefaultValueForRequestFromUserVariablesIfUserItems(report: StiReport): void;
        private static initDateTimeVariables;
        static getDataSourcesWithRequestFromUserVariablesInCommand(report: StiReport): string[];
        private static checkExpressionForVariables;
        static setVariableValue(report: StiReport, variable: StiVariable, variableValue: any): void;
        static setVariableLabel(report: StiReport, variable: StiVariable, label: string): void;
        static getVariableLabel(report: StiReport, variableName: string): string;
    }
}
export namespace Stimulsoft.Report.Engine {
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiChartBuilder extends StiComponentBuilder {
        static renderAtEnd(masterChart: IStiChart): void;
        static renderChart(masterChart: IStiChart): StiComponent;
        prepare(masterComp: StiComponent): void;
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCloneBuilder extends StiContainerBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
        private isParentClonation;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiFooterBand = Stimulsoft.Report.Components.StiFooterBand;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    class StiFooterBandBuilder extends StiBandBuilder {
        static getMaster(masterFooterBand: StiFooterBand): StiDataBand;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiColumnFooterBandBuilder extends StiFooterBandBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiHeaderBand = Stimulsoft.Report.Components.StiHeaderBand;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    class StiHeaderBandBuilder extends StiBandBuilder {
        static getMaster(masterHeaderBand: StiHeaderBand): StiDataBand;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiColumnHeaderBandBuilder extends StiHeaderBandBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCrossLinePrimitiveBuilder extends StiComponentBuilder {
        prepare(masterComp: StiComponent): void;
    }
}
export namespace Stimulsoft.Report.Engine {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    import StiCrossTabParams = Stimulsoft.Report.CrossTab.StiCrossTabParams;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiCrossHeader = Stimulsoft.Report.CrossTab.StiCrossHeader;
    class StiCrossTabBuilder extends StiContainerBuilder {
        static getCollapsingName(header: StiCrossHeader): string;
        static getCollapsingName2(componentName: string, level: number, value: string): string;
        static isCollapsed(masterHeader: StiCrossHeader): boolean;
        static isCollapsed2(masterHeader: StiCrossHeader, level: number, textValue: string): boolean;
        static setCollapsed(masterHeader: StiCrossHeader, isCollapsed: boolean): void;
        static makeHorAlignment(masterCrossTab: StiCrossTab, outContainer: StiContainer, startIndex: number, parentWidth: number, pageSegment: number): void;
        renderCrossTabOnPage(pars: StiCrossTabParams, master: StiCrossTab, destination: StiContainer, rect: Rectangle, endCol: any, endRow: any): void;
        makeHorAlignment(master: StiCrossTab, destination: StiContainer, startIndex: number, parentWidth: number, segmentPerWidth: number): void;
        finalizeCross(renderedComponent: StiContainer): void;
        private renderCrossTabSegment;
        private renderColHeaders;
        private allColFieldsPresentOnAllPages;
        private getEndColumn;
        private getEndRow;
        private renderRowHeaders;
        private renderCorner;
        renderCrossTabOnDataBand(pars: StiCrossTabParams, masterCrossTab: StiCrossTab, renderedComponent: StiContainer): StiComponent;
        renderCrossTabAsync(pars: StiCrossTabParams, masterCrossTab: StiCrossTab): Promise<StiComponent>;
        renderCrossTab(pars: StiCrossTabParams, masterCrossTab: StiCrossTab): StiComponent;
        renderCrossTabUnlimitedBreakable(pars: StiCrossTabParams, master: StiCrossTab, destination: StiContainer, rect: Rectangle): void;
        private getPageForCrossTab;
        private getActualHeaderRowCount;
        prepare(masterComp: StiComponent): void;
        unPrepare(masterComp: StiComponent): void;
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
export namespace Stimulsoft.Report.Engine {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    import StiCrossTabParams = Stimulsoft.Report.CrossTab.StiCrossTabParams;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiCrossTabV2Builder extends StiContainerBuilder {
        renderCrossTabWrapped(pars: StiCrossTabParams, master: StiCrossTab, destination: StiContainer, rect: Rectangle): void;
        renderCrossTabUnlimited(pars: StiCrossTabParams, master: StiCrossTab, destination: StiContainer, rect: Rectangle): void;
        renderCrossTabAsync(pars: StiCrossTabParams, master: StiCrossTab): Promise<StiComponent>;
        renderCrossTabOnPage(pars: StiCrossTabParams, master: StiCrossTab, destination: StiContainer, rect: Rectangle, endCol: {
            ref: number;
        }, endRow: {
            ref: number;
        }): void;
        private getPageForCrossTab;
        renderCrossTabUnlimitedBreakable(pars: StiCrossTabParams, master: StiCrossTab, destination: StiContainer, rect: Rectangle): void;
        renderCrossTabOnDataBand(pars: StiCrossTabParams, master: StiCrossTab, destination: StiContainer, rect: Rectangle): StiComponent;
        finalizeCross(renderedComponent: StiContainer): void;
        static makeHorAlignment(masterCrossTab: StiCrossTab, outContainer: StiContainer, startIndex: number, parentWidth: number, pageSegment: number): void;
        private getEndColumn;
        private getEndRow;
        private allColFieldsPresentOnAllPages;
        private renderColHeaders;
        private renderCrossTabSegment;
        private renderRowHeaders;
        private renderCorner;
        prepare(masterComp: StiComponent): void;
        unPrepare(masterComp: StiComponent): void;
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiGaugeBuilder extends StiComponentBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiGroupFooterBand = Stimulsoft.Report.Components.StiGroupFooterBand;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiGroupFooterBandBuilder extends StiBandBuilder {
        static getMaster(masterFooterBand: StiGroupFooterBand): StiDataBand;
        setReportVariables(masterComp: StiComponent): void;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiHierarchicalBand = Stimulsoft.Report.Components.StiHierarchicalBand;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiHierarchicalBandBuilder extends StiDataBandBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
        private isCollapsed;
        static createIndention(masterHierarchical: StiHierarchicalBand, container: StiContainer, level: number): void;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiViewBuilder extends StiComponentBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiImageBuilder extends StiViewBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiMap = Stimulsoft.Report.Maps.StiMap;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiMapBuilder extends StiComponentBuilder {
        static renderMap(masterMap: StiMap): StiMap;
        prepare(masterComp: StiComponent): void;
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
        static tryToDecimal(value: any): number;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiPageBuilder extends StiContainerBuilder {
        prepare(masterComp: StiComponent): void;
        unPrepare(masterComp: StiComponent): void;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiPointPrimitiveBuilder extends StiComponentBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
export namespace Stimulsoft.Report.Engine {
    class StiReportBuilder {
        static renderSingleReportAsync(masterReport: StiReport, renderState: StiRenderState): Promise<void>;
        static renderSingleReport(masterReport: StiReport, renderState: StiRenderState): void;
        static renderSubReportsAsync(ownerReport: StiReport, renderState: StiRenderState): Promise<void>;
        static renderSubReports(ownerReport: StiReport, renderState: StiRenderState): void;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiSimpleTextBuilder extends StiComponentBuilder {
        prepare(masterComp: StiComponent): void;
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiSparklineBuilder extends StiComponentBuilder {
        prepare(masterComp: StiComponent): void;
        internalRender(masterComp: StiComponent): StiComponent;
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        static getValuesFromValueDataColumnAsync(sparkline: Stimulsoft.Report.Components.StiSparkline, maxRows?: number): Promise<number[]>;
        static getValuesFromValueDataColumn(sparkline: Stimulsoft.Report.Components.StiSparkline, maxRows?: number): number[];
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiSubReportBuilder extends StiContainerBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
export namespace Stimulsoft.Report.Engine {
    import List = Stimulsoft.System.Collections.List;
    import StiBookmarksCollection = Stimulsoft.Report.Components.StiBookmarksCollection;
    import StiTableOfContents = Stimulsoft.Report.Components.StiTableOfContents;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiTableOfContentsBuilder extends StiDataBandBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
        private static renderTextWithNoInformation;
        private static renderPanelWithBookmarks;
        private static renderPointers;
        static postProcessTableOfContents(report: StiReport): void;
        private static getPointers;
        private static getPointersForPostProcessing;
        static postProcessBookmarks2(comps: List<StiComponent>, masterComp: StiTableOfContents, resultComp: StiComponent): void;
        static postProcessBookmarks(comps: List<StiComponent>, baseName: string, panel: StiComponent, bookmarks: StiBookmarksCollection): void;
        private static getHyperlink;
        private static setOffSides;
        private static setOffSide2;
        private static getStyle;
        private static fullSize;
        private static indent;
        private static dotsString_;
        static get dotsString(): string;
    }
}
export namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiTextInCellsBuilder extends StiSimpleTextBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiBandInfo extends StiComponentInfo {
        forceCanBreak: boolean;
        forceCanGrow: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiContainerInfo extends StiComponentInfo {
        dataBandPosition: number;
        dataSourceRow: Stimulsoft.System.Data.DataRow;
        businessObjectCurrent: any;
        isAutoRendered: boolean;
        ignoreResetPageNumber: boolean;
        isColumns: boolean;
        renderStep: number;
        setSegmentPerWidth: number;
        parentBand: StiBand;
    }
}
export namespace Stimulsoft.Report.Components {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiDataBandInfo extends StiComponentInfo {
        groupHeaders: StiComponentsCollection;
        groupFooters: StiComponentsCollection;
        groupHeaderComponents: StiComponentsCollection;
        groupFooterComponents: StiComponentsCollection;
        detailDataBands: StiComponentsCollection;
        details: StiComponentsCollection;
        subReports: StiComponentsCollection;
        emptyBands: StiComponentsCollection;
        headers: StiComponentsCollection;
        hierarchicalHeaders: StiComponentsCollection;
        footersOnAllPages: StiComponentsCollection;
        footersOnLastPage: StiComponentsCollection;
        hierarchicalFooters: StiComponentsCollection;
        groupHeaderResults: boolean[];
        groupFooterResults: boolean[];
        groupHeaderCachedResults: boolean[][];
        groupFooterCachedResults: boolean[][];
        reportTitles: StiReportTitleBand[];
        reportSummaries: StiReportSummaryBand[];
        detailDataBandsFromSubReports: Hashtable;
        storedParentBookmark: StiBookmark;
        storedParentPointer: StiBookmark;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiFooterBandInfo extends StiComponentInfo {
        isTableFooter: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiGroupFooterBandInfo extends StiComponentInfo {
        printAtBottomComponent: StiComponent;
        groupHeader: StiGroupHeaderBand;
        isTableGroupFooter: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiGroupHeaderBandInfo extends StiComponentInfo {
        skipKeepGroups: boolean;
        groupFooter: StiGroupFooterBand;
        silentModeEnabled: boolean;
        oldSilentMode: boolean;
        isTableGroupHeader: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiHeaderBandInfo extends StiComponentInfo {
        isTableHeader: boolean;
    }
}
export namespace Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiHierarchicalBandInfo extends StiComponentInfo {
        specifiedLevel: number;
        finalFooterCalculation: boolean;
    }
}
export namespace Stimulsoft.Report.Events {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiClickEventArgs extends EventArgs {
        sender: StiComponent;
        domComponent: HTMLElement;
        constructor(sender: StiComponent, domComponent: HTMLElement);
    }
}
export namespace Stimulsoft.Report.Events {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiDoubleClickEventArgs extends EventArgs {
        sender: StiComponent;
        domComponent: HTMLElement;
        constructor(sender: StiComponent, domComponent: HTMLElement);
    }
}
export namespace Stimulsoft.Report.Events {
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiGetDataUrlEventArgs extends EventArgs {
        value: string;
    }
}
export namespace Stimulsoft.Report.Events {
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiGetDrillDownReportEventArgs extends EventArgs {
        report: StiReport;
        cancel: boolean;
    }
}
export namespace Stimulsoft.Report.Events {
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiGetSubReportEventArgs extends EventArgs {
        report: StiReport;
        subReportName: string;
        constructor(subReportName: string);
    }
}
export namespace Stimulsoft.Report {
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiGotoCompEventArgs extends EventArgs {
        component: Stimulsoft.Report.Components.StiComponent;
        constructor(component: Stimulsoft.Report.Components.StiComponent);
    }
}
export namespace Stimulsoft.Report.Events {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiMouseEnterEventArgs extends EventArgs {
        sender: StiComponent;
        domComponent: HTMLElement;
        constructor(sender: StiComponent, domComponent: HTMLElement);
    }
}
export namespace Stimulsoft.Report.Events {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiMouseLeaveEventArgs extends EventArgs {
        sender: StiComponent;
        domComponent: HTMLElement;
        constructor(sender: StiComponent, domComponent: HTMLElement);
    }
}
export namespace Stimulsoft.Report.Events {
    import EventArgs = Stimulsoft.System.EventArgs;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiPaintEventArgs extends EventArgs implements ICloneable {
        clone(): any;
        context: any;
        get graphics(): Graphics;
        clipRectangle: RectangleD;
        drawChilds: boolean;
        cancel: boolean;
        drawBorderFormatting: boolean;
        drawTopmostBorderSides: boolean;
        constructor(context: any, clipRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Events {
    import StiExportService = Stimulsoft.Report.Export.StiExportService;
    import StiExportSettings = Stimulsoft.Report.Export.StiExportSettings;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiProcessExportEventArgs extends StiExportEventArgs {
        exportService: StiExportService;
        stream: MemoryStream;
        exportSettings: StiExportSettings;
        processed: boolean;
        constructor(format: StiExportFormat, exportService: StiExportService, stream: MemoryStream, settings: StiExportSettings);
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    let IStiExportService: System.Interface<IStiExportService>;
    interface IStiExportService {
        exportFormat: StiExportFormat;
        isStopped: boolean;
        multipleFiles: boolean;
        renderedPagesCount: number;
        currentPassNumber: number;
        maximumPassNumber: number;
        exportServiceId: string;
        compressToArchive: boolean;
        invokeExporting(page: StiPage, pages: StiPagesCollection, currentPass: number, maximumPass: number): any;
        invokeExporting2(value: number, maximum: number, currentPass: number, maximumPass: number): any;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportTo2(report: StiReport, stream: MemoryStream, settings: StiExportSettings): Promise<void>;
    }
}
export namespace Stimulsoft.Report {
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    class StiPagesRange {
        static All: StiPagesRange;
        rangeType: StiRangeType;
        pageRanges: string;
        currentPage: number;
        equals(obj: any): boolean;
        getSelectedPages(originalPages: StiPagesCollection): StiPagesCollection;
        constructor(rangeType?: StiRangeType, pageRanges?: string, currentPage?: number);
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiOdsExportService: System.Interface<IStiOdsExportService>;
    interface IStiOdsExportService extends StiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiOdtExportService: System.Interface<IStiOdtExportService>;
    interface IStiOdtExportService extends IStiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiRtfExportService: System.Interface<IStiRtfExportService>;
    interface IStiRtfExportService extends StiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiTxtExportService: System.Interface<IStiTxtExportService>;
    interface IStiTxtExportService extends IStiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiXpsExportService: System.Interface<IStiXpsExportService>;
    interface IStiXpsExportService extends StiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiCsvExportService: System.Interface<IStiCsvExportService>;
    interface IStiCsvExportService extends IStiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiDataExportService: System.Interface<IStiDataExportService>;
    interface IStiDataExportService extends IStiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiDbfExportService: System.Interface<IStiDbfExportService>;
    interface IStiDbfExportService extends IStiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiDifExportService: System.Interface<IStiDifExportService>;
    interface IStiDifExportService extends IStiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiJsonExportService: System.Interface<IStiJsonExportService>;
    interface IStiJsonExportService extends IStiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiSylkExportService: System.Interface<IStiSylkExportService>;
    interface IStiSylkExportService extends IStiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiXmlExportService: System.Interface<IStiXmlExportService>;
    interface IStiXmlExportService extends IStiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
export namespace Stimulsoft.Report.Export {
    import Image = Stimulsoft.System.Drawing.Image;
    import ImageFormat = Stimulsoft.System.Drawing.Imaging.ImageFormat;
    class StiBarCodeSvgHelper {
        static getImage(svgData: StiSvgData, imageFormat?: ImageFormat): Image;
    }
}
export namespace Stimulsoft.Report {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiCurveHelper {
        static cardinalSpline(pts: PointD[], closed: boolean): PointD[];
        private static calcCurveEnd;
        private static calcCurve;
    }
}
export namespace Stimulsoft.Base.Context {
    import IAsIs = Stimulsoft.System.IAsIs;
    class StiGeom implements IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        type: StiGeomType;
    }
}
export namespace Stimulsoft.Base.Context {
    class StiPushTranslateTransformGeom extends StiGeom {
        x: number;
        y: number;
        type: StiGeomType;
        constructor(x: number, y: number);
    }
}
export namespace Stimulsoft.Base.Context {
    class StiPushRotateTransformGeom extends StiGeom {
        angle: number;
        type: StiGeomType;
        constructor(angle: number);
    }
}
export namespace Stimulsoft.Base.Context {
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiAnimationGeom extends StiGeom {
        animation: StiAnimation;
        interaction: StiInteractionDataGeom;
        constructor(animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
export namespace Stimulsoft.Base.Context {
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiClusteredBarSeriesAnimationGeom extends StiAnimationGeom {
        background: any;
        borderPen: StiPenGeom;
        columnRect: any;
        upMove: boolean;
        tag: any;
        value: number;
        toolTip: string;
        type: StiGeomType;
        cornerRadius: StiCornerRadius;
        constructor(background: any, borderPen: StiPenGeom, columnRect: any, cornerRadius: StiCornerRadius, value: number, toolTip: string, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
export namespace Stimulsoft.Base.Context {
    class StiPopTransformGeom extends StiGeom {
        toolTip: string;
        type: StiGeomType;
    }
}
export namespace Stimulsoft.Base.Context {
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiBorderAnimationGeom extends StiAnimationGeom {
        background: any;
        borderPen: StiPenGeom;
        rect: any;
        cornerRadius: StiCornerRadius;
        tag: any;
        toolTip: string;
        type: StiGeomType;
        constructor(background: any, borderPen: StiPenGeom, rect: any, cornerRadius: StiCornerRadius, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom, toolTip: string);
    }
}
export namespace Stimulsoft.Base.Context {
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiBorderGeom extends StiGeom {
        background: any;
        backgroundMouseOver: any;
        borderPen: StiPenGeom;
        rect: Rectangle;
        interaction: StiInteractionDataGeom;
        type: StiGeomType;
        cornerRadius: StiCornerRadius;
        toolTip: string;
        constructor(background: any, backgroundMouseOver: any, borderPen: StiPenGeom, rect: Rectangle, cornerRadius: StiCornerRadius, interaction: StiInteractionDataGeom, tooltip: string);
    }
}
export namespace Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    class StiAnimation {
        duration: TimeSpan;
        beginTime: TimeSpan;
        beginTimeCorrect: TimeSpan;
        id: any;
        anotherAnimation: StiAnimation;
        type: StiAnimationType;
        constructor(duration: TimeSpan, beginTime?: TimeSpan);
    }
}
export namespace Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    class StiOpacityAnimation extends StiAnimation {
        type: StiAnimationType;
        constructor(duration: TimeSpan, beginTime: TimeSpan);
    }
}
export namespace Stimulsoft.Base.Context {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiPushClipGeom extends StiGeom {
        clipRectangle: Rectangle;
        type: StiGeomType;
        constructor(clipRectangle: Rectangle);
    }
}
export namespace Stimulsoft.Base.Context {
    class StiPopClipGeom extends StiGeom {
        toolTip: string;
        type: StiGeomType;
    }
}
export namespace Stimulsoft.Base.Context {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiCurveGeom extends StiGeom {
        pen: StiPenGeom;
        tension: number;
        points: Point[];
        type: StiGeomType;
        constructor(pen: StiPenGeom, points: Point[], tension: number);
    }
}
export namespace Stimulsoft.Base.Context {
    class StiEllipseGeom extends StiGeom {
        background: any;
        borderPen: StiPenGeom;
        rect: any;
        interaction: StiInteractionDataGeom;
        toolTip: string;
        type: StiGeomType;
        constructor(background: any, borderPen: StiPenGeom, rect: any, interaction: StiInteractionDataGeom, toolTip: string);
    }
}
export namespace Stimulsoft.Base.Context {
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiShadowSides = Stimulsoft.Base.Drawing.StiShadowSides;
    class StiCachedShadowGeom extends StiGeom {
        rect: Rectangle;
        clipRect: Rectangle;
        sides: StiShadowSides;
        isPrinting: boolean;
        type: StiGeomType;
        cornerRadius: StiCornerRadius;
        constructor(rect: Rectangle, sides: StiShadowSides, isPrinting: boolean, clipRect: Rectangle, cornerRadius: StiCornerRadius);
    }
}
export namespace Stimulsoft.Base.Context {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiShadowGeom extends StiGeom {
        rect: Rectangle;
        radius: number;
        shadowContext: StiContext;
        type: StiGeomType;
        constructor(shadowContext: StiContext, rect: Rectangle, radius: number);
    }
}
export namespace Stimulsoft.Base.Context {
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiTextGeom extends StiAnimationGeom {
        text: string;
        font: StiFontGeom;
        isRounded: boolean;
        isRotatedText: boolean;
        brush: Color | StiBrush;
        location: Point | Rectangle;
        stringFormat: StiStringFormatGeom;
        angle: number;
        antialiasing: boolean;
        maximalWidth: number;
        rotationMode: Stimulsoft.Base.Drawing.StiRotationMode;
        toolTip: string;
        type: StiGeomType;
        constructor(text: string, font: StiFontGeom, brush: any, location: any, stringFormat: StiStringFormatGeom, angle: number, antialiasing: boolean, maximalWidth: number, rotationMode: Stimulsoft.Base.Drawing.StiRotationMode, isRotatedText: boolean, toolTip: string, animation?: StiAnimation, interaction?: StiInteractionDataGeom);
    }
}
export namespace Stimulsoft.Base.Context {
    class StiPathGeom extends StiGeom {
        static getBoundsState: any;
        background: any;
        pen: StiPenGeom;
        rect: any;
        geoms: StiSegmentGeom[];
        interaction: StiInteractionDataGeom;
        toolTip: string;
        type: StiGeomType;
        constructor(background: any, pen: StiPenGeom, geoms: StiSegmentGeom[], rect: any, interaction: StiInteractionDataGeom, toolTip: string);
    }
}
export namespace Stimulsoft.Base.Context {
    enum StiGeomType {
        None = 0,
        Border = 1,
        CachedShadow = 2,
        Curve = 3,
        Ellipse = 4,
        Font = 5,
        Line = 6,
        Lines = 7,
        Path = 8,
        Pen = 9,
        PopSmothingMode = 10,
        PopTextRenderingHint = 11,
        PopTransform = 12,
        PopClip = 13,
        PushClip = 14,
        PushRotateTransform = 15,
        PushSmothingMode = 16,
        PushSmothingModeToAntiAlias = 17,
        PushTextRenderingHint = 18,
        PushTextRenderingHintToAntiAlias = 19,
        PushTranslateTransform = 20,
        Segment = 21,
        Shadow = 22,
        Text = 23,
        StringFormat = 24,
        AnimationBar = 25,
        AnimationBorder = 26,
        AnimationColumn = 27,
        AnimationEllipse = 28,
        AnimationPath = 29,
        AnimationPathElement = 30,
        AnimationLines = 31,
        AnimationCurve = 32,
        AnimationLabel = 33,
        AnimationShadow = 34,
        Image = 35,
        PushClipPath = 36
    }
    enum StiPenAlignment {
        Center = 0,
        Inset = 1,
        Outset = 2,
        Left = 3,
        Right = 4
    }
    enum StiPenLineCap {
        Flat = 0,
        Square = 1,
        Round = 2,
        Triangle = 3,
        NoAnchor = 4,
        SquareAnchor = 5,
        RoundAnchor = 6,
        DiamondAnchor = 7,
        ArrowAnchor = 8
    }
}
export namespace Stimulsoft.Base.Context {
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import StiGeomType = Stimulsoft.Base.Context.StiGeomType;
    class StiPushClipPathGeom extends StiGeom {
        geoms: StiSegmentGeom[];
        type: StiGeomType;
        constructor(geoms: StiSegmentGeom[]);
    }
}
export namespace Stimulsoft.Base.Context {
    class StiSegmentGeom extends StiGeom {
        type: StiGeomType;
    }
}
export namespace Stimulsoft.Base.Context {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiPieSegmentGeom extends StiSegmentGeom {
        rect: Rectangle;
        startAngle: number;
        sweepAngle: number;
        animation: StiAnimation;
        realStartAngle: number;
        realSweepAngle: number;
        crossElipseDraw: boolean;
        constructor(rect: Rectangle, startAngle: number, sweepAngle: number, realStartAngle: number, realSweepAngle: number, animation: StiAnimation);
    }
}
export namespace Stimulsoft.Base.Context {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiArcSegmentGeom extends StiSegmentGeom {
        rect: Rectangle;
        startAngle: number;
        sweepAngle: number;
        realStartAngle: number;
        realSweepAngle: number;
        crossElipseDraw: boolean;
        constructor(rect: Rectangle, startAngle: number, sweepAngle: number, realStartAngle?: number, realSweepAngle?: number);
    }
}
export namespace Stimulsoft.Base.Context {
    import Point = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiLineSegmentGeom extends StiSegmentGeom {
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        animation: StiAnimation;
        constructor(x1: number | Point, y1: number | Point, x2?: number, y2?: number, animation?: StiAnimation);
    }
}
export namespace Stimulsoft.Base.Context {
    import Point = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiLinesSegmentGeom extends StiSegmentGeom {
        points: Point[];
        animation: StiAnimation;
        constructor(points: Point[], animation?: StiAnimation);
    }
}
export namespace Stimulsoft.Base.Context {
    import Point = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCurveSegmentGeom extends StiSegmentGeom {
        tension: number;
        points: Point[];
        animation: StiAnimation;
        constructor(points: Point[], tension: number, animation?: StiAnimation);
    }
}
export namespace Stimulsoft.Base.Context {
    class StiCloseFigureSegmentGeom extends StiSegmentGeom {
    }
}
export namespace Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import List = Stimulsoft.System.Collections.List;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    class StiColumnAnimation extends StiAnimation {
        rectFrom: Rectangle;
        rectTo: Rectangle;
        type: StiAnimationType;
        static isAnimationChangingValues(series: IStiSeries, id?: any): boolean;
        private static getPreviousAnimation;
        applyPreviousAnimation(previousAnimations: List<StiAnimation>): void;
        constructor(rectFrom: Rectangle, rectTo: Rectangle, duration: TimeSpan, beginTime: TimeSpan);
    }
}
export namespace Stimulsoft.Base.Context {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiLabelAnimationGeom extends StiAnimationGeom {
        text: string;
        font: StiFontGeom;
        textBrush: any;
        labelBrush: any;
        penBorder: StiPenGeom;
        rectangle: Rectangle;
        stringFormat: StiStringFormatGeom;
        angle: number;
        rotationMode: StiRotationMode;
        drawBorder: boolean;
        type: StiGeomType;
        constructor(text: string, font: StiFontGeom, textBrush: any, LabelBrush: any, penBorder: StiPenGeom, rect: Rectangle, sf: StiStringFormatGeom, rotationMode: StiRotationMode, angle: number, drawBorder: boolean, animation: StiAnimation);
    }
}
export namespace Stimulsoft.Base.Context {
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiShadowAnimationGeom extends StiAnimationGeom {
        rect: Rectangle;
        radiusX: number;
        radiusY: number;
        shadowWidth: number;
        cornerRadius: StiCornerRadius;
        type: StiGeomType;
        constructor(rect: Rectangle, radiusX: number, radiusY: number, shadowWidth: number, cornerRadius: StiCornerRadius, animation: StiAnimation);
    }
}
export namespace Stimulsoft.Base.Context {
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiPathAnimationGeom extends StiAnimationGeom {
        static getBoundsState: any;
        background: any;
        pen: StiPenGeom;
        rect: any;
        geoms: StiSegmentGeom[];
        tag: any;
        type: StiGeomType;
        constructor(background: any, pen: StiPenGeom, geoms: StiSegmentGeom[], rect: any, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
export namespace Stimulsoft.Base.Context {
    import Point = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCurveAnimationGeom extends StiAnimationGeom {
        pen: StiPenGeom;
        points: Point[];
        tension: number;
        type: StiGeomType;
        constructor(pen: StiPenGeom, points: Point[], tension: number, animation: StiAnimation);
    }
}
export namespace Stimulsoft.Base.Context {
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiClusteredColumnSeriesAnimationGeom extends StiAnimationGeom {
        background: any;
        borderPen: StiPenGeom;
        columnRect: any;
        toolTip: string;
        tag: any;
        value: number;
        type: StiGeomType;
        cornerRadius: StiCornerRadius;
        constructor(background: any, borderPen: StiPenGeom, columnRect: any, cornerRadius: StiCornerRadius, value: number, toolTip: string, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
export namespace Stimulsoft.Base.Context {
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiEllipseAnimationGeom extends StiAnimationGeom {
        background: any;
        borderPen: StiPenGeom;
        rect: any;
        tag: any;
        toolTip: string;
        type: StiGeomType;
        constructor(background: any, borderPen: StiPenGeom, rect: any, toolTip: string, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
export namespace Stimulsoft.Base.Context {
    import Point = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiLinesAnimationGeom extends StiAnimationGeom {
        pen: StiPenGeom;
        points: Point[];
        type: StiGeomType;
        constructor(pen: StiPenGeom, points: Point[], animation: StiAnimation);
    }
}
export namespace Stimulsoft.Base.Context {
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiPathElementAnimationGeom extends StiAnimationGeom {
        background: any;
        borderPen: StiPenGeom;
        rect: any;
        pathGeoms: StiSegmentGeom[];
        tag: any;
        toolTip: string;
        type: StiGeomType;
        constructor(background: any, borderPen: StiPenGeom, pathGeoms: StiSegmentGeom[], rect: any, toolTip: string, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
export namespace Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiLabelAnimation extends StiAnimation {
        pointFrom: Point;
        point: Point;
        valueFrom: number;
        value: number;
        labelRect: Rectangle;
        type: StiAnimationType;
        constructor(valueFrom: number, value: number, pointFrom: Point, point: Point, duration: TimeSpan, beginTime: TimeSpan);
    }
}
export namespace Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Point = Stimulsoft.System.Drawing.Point;
    import List = Stimulsoft.System.Collections.List;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    class StiPointsAnimation extends StiAnimation {
        private isReverse;
        pointsFrom: Point[];
        pointsTo: Point[];
        pointsIds: string[];
        type: StiAnimationType;
        static isAnimationChangingValues(series: IStiSeries, pointsIds: string[], id?: any): boolean;
        private static getPreviousAnimation;
        private static getPointIndex;
        applyPreviousAnimation(previousAnimations: List<StiAnimation>, isSort: boolean): void;
        reverse(): void;
        constructor(pointsFrom: Point[], pointsTo: Point[], pointsIds: string[], duration: TimeSpan, beginTime: TimeSpan);
    }
}
export namespace Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiPieLabelAnimation extends StiAnimation {
        valueFrom: number;
        value: number;
        rectLabelFrom: Rectangle;
        rectLabel: Rectangle;
        clientRect: Rectangle;
        angleFrom: number;
        angle: number;
        type: StiAnimationType;
        constructor(valueFrom: number, value: number, angleFrom: number, angle: number, clientRect: Rectangle, rectLabelFrom: Rectangle, rectLabel: Rectangle, duration: TimeSpan, beginTime: TimeSpan);
    }
}
export namespace Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import List = Stimulsoft.System.Collections.List;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    class StiPieSegmentAnimation extends StiAnimation {
        rectFrom: Rectangle;
        rectTo: Rectangle;
        rectDtFrom: Rectangle;
        rectDtTo: Rectangle;
        startAngleFrom: number;
        endAngleFrom: number;
        startAngleTo: number;
        endAngleTo: number;
        type: StiAnimationType;
        static isAnimationChangingValues(series: IStiSeries, id?: any): boolean;
        private static getPreviousAnimation;
        applyPreviousAnimation(previousAnimations: List<StiAnimation>): void;
        constructor(rectFrom: Rectangle, rectTo: Rectangle, rectDtFrom: Rectangle, rectDtTo: Rectangle, startAngleFrom: number, endAngleFrom: number, startAngleTo: number, endAngleTo: number, duration: TimeSpan, beginTime: TimeSpan);
    }
}
export namespace Stimulsoft.Base.Context {
    class StiLineGeom extends StiGeom {
        pen: StiPenGeom;
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        type: StiGeomType;
        constructor(pen: StiPenGeom, x1: number, y1: number, x2: number, y2: number);
    }
}
export namespace Stimulsoft.Base.Context {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiLinesGeom extends StiGeom {
        pen: StiPenGeom;
        points: Point[];
        type: StiGeomType;
        constructor(pen: StiPenGeom, points: Point[]);
    }
}
export namespace Stimulsoft.Base.Context {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiImageGeom extends StiGeom {
        rect: Rectangle;
        image: number[];
        type: StiGeomType;
        constructor(rect: Rectangle, image: number[]);
    }
}
export namespace Stimulsoft.Base.Context {
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    import PointF = Stimulsoft.System.Drawing.Point;
    class StiBezierSegmentGeom extends StiSegmentGeom {
        pt1: PointF;
        pt2: PointF;
        pt3: PointF;
        pt4: PointF;
        animation: StiAnimation;
        constructor(pt1: PointF, pt2: PointF, pt3: PointF, pt4: PointF, animation?: StiAnimation);
    }
}
export namespace Stimulsoft.Base.Context {
    class StiInteractionData {
        value: number;
    }
}
export namespace Stimulsoft.Base.Context {
    import Point = Stimulsoft.System.Drawing.Point;
    import StiInteractionData = Stimulsoft.Base.Context.StiInteractionData;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import IStiArea = Stimulsoft.Report.Chart.IStiArea;
    class StiSeriesInteractionData extends StiInteractionData {
        isElements: boolean;
        tag: any;
        tooltip: string;
        hyperlink: string;
        argument: any;
        x: any;
        y: any;
        originalArgument: any;
        value: number;
        series: IStiSeries;
        pointIndex: number;
        point: Point;
        fill(area: IStiArea, series: IStiSeries, pointIndex: number): void;
        constructor(area?: IStiArea, series?: IStiSeries, pointIndex?: number);
    }
}
export namespace Stimulsoft.Base.Context {
    class StiIndicatorInteractionData extends StiInteractionData {
        target: number;
        seriesText: string;
    }
}
export namespace Stimulsoft.Base.Context {
    class StiProgressInteractionData extends StiInteractionData {
        target: number;
        seriesText: string;
    }
}
export namespace Stimulsoft.Base.Context {
    class StiGaugeInteractionData extends StiInteractionData {
        target: number;
        seriesText: string;
    }
}
export namespace Stimulsoft.Base.Context {
    class StiCardInteractionData extends StiInteractionData {
        valueText: string;
    }
}
export namespace Stimulsoft.Report.Painters {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import List = Stimulsoft.System.Collections.List;
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    class StiContextRoundedRectangleCreator {
        static createWithoutTopSide(rect: Rectangle, radius: StiCornerRadius, scale: number): List<StiSegmentGeom>;
        static createWithoutBottomSide(rect: Rectangle, radius: StiCornerRadius, scale: number): List<StiSegmentGeom>;
        static createWithoutLeftSide(rect: Rectangle, radius: StiCornerRadius, scale: number): List<StiSegmentGeom>;
        static createWithoutRightSide(rect: Rectangle, radius: StiCornerRadius, scale: number): List<StiSegmentGeom>;
        static create(rect: Rectangle, radius: StiCornerRadius, scale: number): List<StiSegmentGeom>;
        static getRadiusTopLeft(radius: StiCornerRadius, scale: number, rad: number): number;
        static getRadiusTopRight(radius: StiCornerRadius, scale: number, rad: number): number;
        static getRadiusBottomLeft(radius: StiCornerRadius, scale: number, rad: number): number;
        static getRadiusBottomRight(radius: StiCornerRadius, scale: number, rad: number): number;
    }
}
export namespace Stimulsoft.Report.Export.Services.Helpers {
    import SolidBrush = Stimulsoft.System.Drawing.SolidBrush;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    class StiContextSvgHelper {
        private static simpleGuid;
        private static getSimpleGuid;
        private static isAddStimulsoftIconFont;
        private static dx;
        private static dy;
        private static listTransformGeom;
        static writeGeoms(writer: XmlTextWriter, context: StiContext, needAnimation: boolean): void;
        private static writeClipPath;
        private static writeRect;
        private static writeCicledRectPath;
        static addAnimation(writer: XmlTextWriter, actions: string, begin: TimeSpan, duration: TimeSpan, numberr?: string): void;
        private static rectToCenterPoint;
        private static getValue;
        static writeInteraction(writer: XmlTextWriter, interaction: StiInteractionDataGeom): void;
        private static getPathData;
        private static addArcPath2;
        private static addArcPathCrossElipse;
        private static svgEllipseArc;
        private static matricTimes;
        private static rotateMatrix;
        private static vecAdd;
        private static addArcPath;
        private static addPiePath;
        private static addDoughnutPath;
        private static round;
        static correctRectLabel(rotationMode: StiRotationMode, textRect: Rectangle): Rectangle;
        private static convertArcToCubicBezier;
        static replaceJsonNotSupportedSymbols(tooltip: string): string;
        static writeTooltip(writer: XmlTextWriter, tooltip: string): void;
        static getFillBrush(writer: XmlTextWriter, brush: Color | StiBrush | SolidBrush, rect: Rectangle): string;
        static writeFillBrush(writer: XmlTextWriter, brush: any, rect: Rectangle, dx?: number, dy?: number): string;
        static writeFillBrushMouserOver(writer: XmlTextWriter, brush: any, brushOver: any, rect: Rectangle): void;
        private static writeBorderStroke;
        private static convertSplineToCubicBezier;
        private static calculateCurveBezier;
        private static calculateCurveBezierEndPoints;
        private static writeBrush;
        private static checkPenGeom;
        static p(f: number): string;
        static writeStimulsoftIconFont(): void;
    }
}
export namespace Stimulsoft.Report.Export {
    import StiLinearGradientBrush = Stimulsoft.Base.Drawing.StiLinearGradientBrush;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBrushSvgHelper {
        static hatchData: string[];
        static writeHatchBrush(writer: XmlTextWriter, brush: any): string;
        private static hexToByteString;
        static writeGlareBrush(writer: XmlTextWriter, brush: any, rect: RectangleD): string;
        static writeGradientBrush(writer: XmlTextWriter, brush: any, rect: RectangleD): string;
        static writeLinearGradientBrush(writer: XmlTextWriter, brush: StiLinearGradientBrush, rect: RectangleD): string;
        static writeGlassBrush(writer: XmlTextWriter, brush: any, rect: RectangleD): string;
        static getFillColor(color: Color): string;
        private static getGradientInfo;
    }
}
export namespace Stimulsoft.Base.Context {
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Size = Stimulsoft.System.Drawing.Size;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiShadowSides = Stimulsoft.Base.Drawing.StiShadowSides;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    import List = Stimulsoft.System.Collections.List;
    class StiContext {
        geoms: StiGeom[];
        contextPainter: StiContextPainter;
        options: StiContextOptions;
        animations: List<StiAnimation>;
        render(rect: Rectangle): void;
        getDefaultStringFormat(): StiStringFormatGeom;
        getGenericStringFormat(): StiStringFormatGeom;
        drawImage(image: number[], rect: Rectangle): void;
        drawString3(text: string, font: StiFontGeom, brush: any, rect: Rectangle, sf: StiStringFormatGeom, toolTip: string, interaction?: StiInteractionDataGeom): StiTextGeom;
        drawString2(text: string, font: StiFontGeom, brush: any, rect: Rectangle, sf: StiStringFormatGeom): StiTextGeom;
        drawString(text: string, font: StiFontGeom, brush: any, rect: Rectangle, sf: StiStringFormatGeom): StiTextGeom;
        drawRotatedString2(text: string, font: StiFontGeom, brush: any, rect: Rectangle, sf: StiStringFormatGeom, angle: number, antialiasing: boolean): StiTextGeom;
        drawRotatedString3(text: string, font: StiFontGeom, brush: any, rect: Rectangle, sf: StiStringFormatGeom, angle: number, antialiasing: boolean): StiTextGeom;
        drawRotatedString4(text: string, font: StiFontGeom, brush: any, pos: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean): StiTextGeom;
        drawRotatedString5(text: string, font: StiFontGeom, brush: any, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean): StiTextGeom;
        drawRotatedString6(text: string, font: StiFontGeom, brush: any, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean, maximalWidth: number, isRotated?: boolean): StiTextGeom;
        drawRotatedString7(text: string, font: StiFontGeom, brush: any, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean, maximalWidth: number): StiTextGeom;
        drawRotatedString8(text: string, font: StiFontGeom, brush: any, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean): StiTextGeom;
        drawRotatedString9(text: string, font: StiFontGeom, brush: any, pos: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean, maximalWidth: number): StiTextGeom;
        measureString(text: string, font: StiFontGeom): Size;
        measureString2(text: string, font: StiFontGeom, width: number, sf: StiStringFormatGeom): Size;
        measureRotatedString(text: string, font: StiFontGeom, rect: Rectangle, sf: StiStringFormatGeom, angle: number): Rectangle;
        measureRotatedString2(text: string, font: StiFontGeom, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, maximalWidth?: number): Rectangle;
        measureRotatedString3(text: string, font: StiFontGeom, point: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, maximalWidth: number): Rectangle;
        measureRotatedString4(text: string, font: StiFontGeom, point: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number): Rectangle;
        drawShadow(sg: StiContext, rect: Rectangle, radius: number): void;
        drawCachedShadow(rect: Rectangle, sides: StiShadowSides, isPrinting: boolean, clipRect?: Rectangle, cornerRadius?: StiCornerRadius): void;
        createShadowGraphics(): StiContext;
        pushTranslateTransform(x: number, y: number): void;
        pushRotateTransform(angle: number): void;
        popTransform(): void;
        pushClipPath(listGeoms: StiSegmentGeom[]): void;
        pushClip(clipRect: Rectangle): void;
        popClip(): void;
        drawAnimationText(text: string, font: StiFontGeom, brush: any, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean, maximalWidth: number, animation: StiAnimation): StiTextGeom;
        drawAnimationColumn(brush: any, borderPen: StiPenGeom, rect: any, value: number, toolTip: string, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        drawAnimationCicledColumn(brush: any, borderPen: StiPenGeom, rect: any, cornerRadius: StiCornerRadius, value: number, toolTip: string, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        drawAnimationBar(brush: any, borderPen: StiPenGeom, columnRect: any, value: number, toolTip: string, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        drawAnimationCicledBar(brush: any, borderPen: StiPenGeom, columnRect: any, cornerRadius: StiCornerRadius, value: number, toolTip: string, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        drawAnimationRectangle(brush: any, pen: StiPenGeom, rect: Rectangle, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom, tooltip: string): void;
        drawAnimationCicledRectangle(brush: any, pen: StiPenGeom, rect: Rectangle, cornerRadius: StiCornerRadius, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom, tooltip: string): void;
        drawAnimationPathElement(brush: any, borderPen: StiPenGeom, path: StiSegmentGeom[], rect: any, toolTip: string, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        drawAnimationLabel(text: string, font: StiFontGeom, textBrush: any, labelBrush: any, penBorder: StiPenGeom, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, drawBorder: boolean, animation: StiAnimation): void;
        drawAnimationLines(pen: StiPenGeom, points: Point[], animation: StiAnimation): void;
        drawAnimationCurve(pen: StiPenGeom, points: Point[], tension: number, animation: StiAnimation): void;
        fillDrawAnimationPath(brush: any, pen: StiPenGeom, path: StiSegmentGeom[], rect: any, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        fillDrawAnimationEllipse(brush: any, pen: StiPenGeom, x: number, y: number, width: number, height: number, toolTip: string, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        drawLine(pen: StiPenGeom, x1: number, y1: number, x2: number, y2: number): void;
        drawLines(pen: StiPenGeom, points: Point[]): void;
        drawRectangle(pen: StiPenGeom, rect: Rectangle): void;
        drawCicledRectangle(pen: StiPenGeom, rect: Rectangle, cornerRadius: StiCornerRadius): void;
        drawRectangle2(pen: StiPenGeom, x: number, y: number, width: number, height: number): void;
        drawEllipse(pen: StiPenGeom, x: number, y: number, width: number, height: number): void;
        drawEllipse2(pen: StiPenGeom, rect: Rectangle): void;
        fillEllipse(brush: any, x: number, y: number, width: number, height: number, interaction: StiInteractionDataGeom): void;
        fillEllipse2(brush: any, rect: Rectangle, interaction: StiInteractionDataGeom): void;
        fillEllipse3(brush: any, x: number, y: number, width: number, height: number, tooltip: string, interaction: StiInteractionDataGeom): void;
        drawPath(pen: StiPenGeom, path: StiSegmentGeom[], rect: any): void;
        fillPath(brush: any, path: StiSegmentGeom[], rect: any, interaction: StiInteractionDataGeom): void;
        fillPath2(brush: any, path: StiSegmentGeom[], rect: any, interaction: StiInteractionDataGeom, toolTip: string): void;
        drawCurve(pen: StiPenGeom, points: Point[], tension: number): void;
        fillRectangle(brush: any, rect: Rectangle, interaction: StiInteractionDataGeom): void;
        fillRectangle2(brush: any, x: number, y: number, width: number, height: number, interaction: StiInteractionDataGeom): void;
        fillRectangle3(brush: any, brushMouseOver: any, rect: Rectangle, interaction: StiInteractionDataGeom): void;
        fillCicledRectangle(brush: any, rect: Rectangle, cornerRadius: StiCornerRadius, interaction: StiInteractionDataGeom, tooltip: string): void;
        pushSmoothingModeToAntiAlias(): void;
        popSmoothingMode(): void;
        pushTextRenderingHintToAntiAlias(): void;
        popTextRenderingHint(): void;
        getPathBounds(geoms: StiSegmentGeom[]): Rectangle;
        drawShadowRect(rect: Rectangle, shadowWidth: number, cornerRadius: StiCornerRadius, animation: StiAnimation): void;
        drawShadowRect2(rect: Rectangle, radiusX: number, radiusY: number, shadowWidth: number, cornerRadius: StiCornerRadius, animation: StiAnimation): void;
        constructor(contextPainter: StiContextPainter, isGdi: boolean, isWpf: boolean, isPrinting: boolean, zoom: number);
    }
}
export namespace Stimulsoft.Base.Context {
    import Size = Stimulsoft.System.Drawing.Size;
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    class StiContextPainter {
        private _svgRect;
        private svgObj;
        get svgRect(): any;
        getDefaultStringFormat(): StiStringFormatGeom;
        getGenericStringFormat(): StiStringFormatGeom;
        createShadowGraphics(isPrinting: boolean, zoom: number): StiContext;
        getPathBounds(geoms: StiSegmentGeom[]): Rectangle;
        measureString(text: string, font: StiFontGeom, width?: number, sf?: StiStringFormatGeom): Size;
        measureRotatedString1(text: string, font: StiFontGeom, rect: Rectangle, sf: StiStringFormatGeom, angle: number): Rectangle;
        measureRotatedString2(text: string, font: StiFontGeom, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, maximalWidth?: number): Rectangle;
        measureRotatedString3(text: string, font: StiFontGeom, point: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, maximalWidth: number): Rectangle;
        private getTextSize;
        measureRotatedString4(text: string, font: StiFontGeom, point: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number): Rectangle;
        private getStartPoint;
        render(rect: Rectangle, geoms: StiGeom[]): void;
    }
}
export namespace Stimulsoft.Report.Export {
    import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
    class StiReportResourceHelper {
        static isFontResourceType(resourceType: StiResourceType): boolean;
        static getBase64DataFromFontResourceContent(resourceType: StiResourceType, content: number[] | string): string;
    }
}
export namespace Stimulsoft.Report.Export {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    class StiSvgWriter extends XmlTextWriter {
        private knownBinFonts;
        constructor(report: StiReport, ...rest: ConstructorParameters<typeof XmlTextWriter>);
        get fontStylesText(): string;
        writeEmbeddedFontsDefinitions(): void;
        writeAttributeString(localName: string, value: string): void;
    }
}
export namespace Stimulsoft.Report.Export {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiChartSvgHelper {
        static getImage(svgData: StiSvgData, embedFonts?: boolean): Image;
        static writeChart(writer: XmlTextWriter, svgData: StiSvgData, zoom: number, needAnimation: boolean): void;
        private static writeEmptyDataMessage;
        private static getEmptyDataImage;
        private static measureTextWidth;
    }
}
export namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiGaugeGeom implements IAsIs {
        get type(): StiGaugeGeomType;
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        animation: StiAnimation;
    }
}
export namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiPieGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly startAngle: number;
        readonly sweepAngle: number;
        get type(): StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number, startAngle: number, sweepAngle: number);
    }
}
export namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiEllipseGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        get type(): StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number);
    }
}
export namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiGraphicsArcGeometryGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly startAngle: number;
        readonly sweepAngle: number;
        readonly startWidth: number;
        readonly endWidth: number;
        get type(): StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number, startAngle: number, sweepAngle: number, startWidth: number, endWidth: number);
    }
}
export namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    class StiPopTranformGaugeGeom extends StiGaugeGeom {
        get type(): StiGaugeGeomType;
    }
}
export namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiPushMatrixGaugeGeom extends StiGaugeGeom {
        readonly angle: number;
        readonly centerPoint: Point;
        get type(): StiGaugeGeomType;
        constructor(angle: number, centerPoint: Point);
    }
}
export namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRadialRangeGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly centerPoint: Point;
        readonly startAngle: number;
        readonly sweepAngle: number;
        readonly radius1: number;
        readonly radius2: number;
        readonly radius3: number;
        readonly radius4: number;
        get type(): StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number, centerPoint: Point, startAngle: number, sweepAngle: number, radius1: number, radius2: number, radius3: number, radius4: number);
    }
}
export namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRectangleGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        get type(): StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number);
    }
}
export namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRoundedRectangleGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly leftTop: number;
        readonly rightTop: number;
        readonly rightBottom: number;
        readonly leftBottom: number;
        get type(): StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number, leftTop: number, rightTop: number, rightBottom: number, leftBottom: number);
    }
}
export namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    class StiTextGaugeGeom extends StiGaugeGeom {
        readonly text: string;
        readonly font: Font;
        readonly foreground: StiBrush;
        readonly rect: Rectangle;
        readonly stringFormat: StringFormat;
        get type(): StiGaugeGeomType;
        constructor(text: string, font: Font, foreground: StiBrush, rect: Rectangle, sf: StringFormat);
    }
}
export namespace Stimulsoft.Report.Painters {
    import List = Stimulsoft.System.Collections.List;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    import StiGaugeGeom = Stimulsoft.Report.Gauge.GaugeGeoms.StiGaugeGeom;
    import StiGraphicsPathGaugeGeom = Stimulsoft.Report.Gauge.GaugeGeoms.StiGraphicsPathGaugeGeom;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import RectangleF = Stimulsoft.System.Drawing.Rectangle;
    import Font = Stimulsoft.System.Drawing.Font;
    import SizeF = Stimulsoft.System.Drawing.Size;
    import PointF = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import IStiGauge = Stimulsoft.Report.Components.Gauge.IStiGauge;
    class StiGaugeContextPainter {
        zoom: number;
        rect: RectangleF;
        gauge: IStiGauge;
        geoms: StiGaugeGeom[];
        animations: List<StiAnimation>;
        static changeFontSize(font: Font, zoom: number): Font;
        measureString(text: string, font: Font): SizeF;
        addPieGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number, startAngle: number, sweepAngle: number): void;
        addEllipseGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number): void;
        addGraphicsArcGeometryGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number, startAngle: number, sweepAngle: number, startWidth: number, endWidth: number): void;
        addPopTranformGaugeGeom(): void;
        addPushMatrixGaugeGeom(angle: number, centerPoint: PointF): void;
        addRadialRangeGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number, centerPoint: PointF, startAngle: number, sweepAngle: number, radius1: number, radius2: number, radius3: number, radius4: number): void;
        addRectangleGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number): void;
        addRoundedRectangleGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number, leftTop: number, rightTop: number, rightBottom: number, leftBottom: number): void;
        addTextGaugeGeom(text: string, font: Font, foreground: StiBrush, rect: RectangleF, sf: StringFormat): void;
        addGraphicsPathGaugeGeom(geom: StiGraphicsPathGaugeGeom): void;
        render(): void;
        constructor(gauge: IStiGauge, rect: RectangleF, zoom: number);
    }
}
export namespace Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    class StiScaleAnimation extends StiAnimation {
        startScaleX: number;
        startScaleY: number;
        endScaleX: number;
        endScaleY: number;
        centerX: number;
        centerY: number;
        type: StiAnimationType;
        constructor(startScaleX: number, endScaleX: number, startScaleY: number, endScaleY: number, centerX: number, centerY: number, duration: TimeSpan, beginTime: TimeSpan);
    }
}
export namespace Stimulsoft.Base.Context.Animation {
    import List = Stimulsoft.System.Collections.List;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiRotationAnimation extends StiAnimation {
        startAngle: number;
        endAngle: number;
        centerPoint: Point;
        type: StiAnimationType;
        private static getPreviousAnimation;
        applyPreviousAnimation(previousAnimations: List<StiAnimation>): void;
        constructor(startAngle: number, endAngle: number, centerPoint: Point, duration: TimeSpan, beginTime: TimeSpan);
    }
}
export namespace Stimulsoft.Base.Context.Animation {
    import List = Stimulsoft.System.Collections.List;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiTranslationAnimation extends StiAnimation {
        startPoint: Point;
        endPoint: Point;
        type: StiAnimationType;
        private static getPreviousAnimation;
        applyPreviousAnimation(previousAnimations: List<StiAnimation>): void;
        constructor(startPoint: Point, endPoint: Point, duration: TimeSpan, beginTime: TimeSpan);
    }
}
export namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    class StiGraphicsPathArcGaugeGeom extends StiGaugeGeom {
        readonly x: number;
        readonly y: number;
        readonly width: number;
        readonly height: number;
        readonly startAngle: number;
        readonly sweepAngle: number;
        get type(): StiGaugeGeomType;
        constructor(x: number, y: number, width: number, height: number, startAngle: number, sweepAngle: number);
    }
}
export namespace Stimulsoft.Report.Gauge {
    enum StiGaugeGeomType {
        GraphicsPath = 0,
        GraphicsPathArc = 1,
        GraphicsPathCloseFigure = 2,
        RoundedRectangle = 3,
        Rectangle = 4,
        Pie = 5,
        Ellipse = 6,
        GraphicsArcGeometry = 7,
        PushMatrix = 8,
        PopTranform = 9,
        GraphicsPathLines = 10,
        GraphicsPathLine = 11,
        Text = 12,
        RadialRange = 13
    }
}
export namespace Stimulsoft.Report.Export {
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    class StiGaugeSvgHelper {
        static getImage(svgData: StiSvgData): Image;
        private static readonly PiDiv180;
        private static readonly FourDivThree;
        static writeGauge(writer: XmlTextWriter, svgData: StiSvgData, zoom?: number, needAnimation?: boolean, isSampleForStyles?: boolean, isExport?: boolean, interaction?: StiInteractionDataGeom, brushOver?: StiBrush): void;
        private static getPathData;
        static getArcPath(rect: Rectangle, path_: string, startAngle: number, sweepAngle: number, isSetStartPoint: boolean): string;
        private static convertArcToCubicBezier;
        private static addArcPath;
        private static addPiePath;
        private static convertArcToCubicBezier2;
        private static convertArcToCubicBezier3;
        private static round;
        static writeText(writer: XmlTextWriter, text: string, font: Font, foreground: StiBrush, point: Point, size: number): void;
        private static calculateCurveBezier;
        private static calculateCurveBezierEndPoints;
        static writeFillBrush(writer: XmlTextWriter, brush: Color | StiBrush, rect: Rectangle): string;
        private static writeBorderStroke;
        private static getOpacityString;
        private static rectToRectangle;
    }
}
export namespace Stimulsoft.Report.Maps.Gis {
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import Size = Stimulsoft.System.Drawing.Size;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGisMapData {
        size: Size;
        geometryColor: Color;
        geometryLineSize: number;
        points: StiGisPointMapGeometry[];
        colors: string[];
        lineSizes: any[];
        icon: StiFontIcons;
        iconColor: Color;
        zoom: number;
        constructor(icon: StiFontIcons, iconColor: Color, zoom: number);
    }
}
export namespace Stimulsoft.Report.Maps.Gis {
    class StiGisMapSimpleView {
        private core;
        private viewData;
        private points;
        private size;
        private zoom;
        isComplete: boolean;
        runAndWait(): Promise<void>;
        private initGeoCommands;
        private getRectOfAllGeoms;
        updateBounds(): void;
        goToCurrentPosition(): void;
        loadImages(): Promise<void>;
        loadImage(pos: StiGisPoint, zoom: number): Promise<void>;
        drawMap(): string;
        constructor(data: StiGisMapData);
    }
}
export namespace Stimulsoft.Report.Maps.Gis {
    import Point = Stimulsoft.System.Drawing.Point;
    import Size = Stimulsoft.System.Drawing.Size;
    class StiOnlineMapProvider {
        static getImage(size: Size, map: {
            mapImage: string;
        }, userBingKey: string, pushPins: Point[], onePointZoom: number): Promise<string>;
    }
}
export namespace Stimulsoft.Report.Painters {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiMap = Stimulsoft.Report.Maps.StiMap;
    class StiMapGdiPainter {
        useBackground: boolean;
        key: string;
        getImage(map: StiMap, zoom: number, x?: number, y?: number, width?: number, height?: number): Promise<string>;
        paintOnlineMap(rect: Rectangle, map: StiMap): Promise<string>;
    }
}
export namespace Stimulsoft.Report.Maps {
    import StiMapID = Stimulsoft.Report.Maps.StiMapID;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMapHelper {
        private static globalReport;
        private static globalMap;
        private static maps3D;
        static cache: {};
        static addToCahe(map: StiMap, x: number, y: number, width: number, height: number, wrappedSvg: string): string;
        static renderOnlineMap(str: string): Promise<string>;
        static isWorld(id: StiMapID): boolean;
        static isAfrica(id: StiMapID): boolean;
        static isNorthAmerica(id: StiMapID): boolean;
        static isSouthAmerica(id: StiMapID): boolean;
        static isEU(id: StiMapID): boolean;
        static isOceania(id: StiMapID): boolean;
        static isAsia(id: StiMapID): boolean;
        static getLangOriginalName(id: string): string;
        static getMapLanguagesInfos(): any;
        static allow3D(mapID: string): boolean;
        static allow3D2(mapID: StiMapID): boolean;
        static getStates(report: StiReport, id: StiMapID, lang: string): string[];
        static getMapSample(): StiMap;
        static getColors(): Color[];
        static prepareIsoCode(text: string): string;
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapData {
        constructor(key: string);
        key: string;
        gss: string;
        private _value;
        get value(): string;
        set value(value1: string);
        private _group;
        get group(): string;
        set group(value: string);
        name: string;
        private _color;
        get color(): string;
        set color(value: string);
        getValue(): number;
        toString(): string;
        private invokeValueChanged;
    }
}
export namespace Stimulsoft.Report.Maps {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    class StiMapSvg {
        key: string;
        data: string;
        data3D: string;
        englishName: string;
        iSOCode: string;
        rect: Rectangle;
        setMaxWidth: boolean;
        skipText: boolean;
        horAlignment: StiTextHorAlignment;
        vertAlignment: StiVertAlignment;
        rectIso: Rectangle;
        skipTextIso: boolean;
        horAlignmentIso: StiTextHorAlignment;
        vertAlignmentIso: StiVertAlignment;
        toString(): string;
    }
}
export namespace Stimulsoft.Report.Maps {
    import Font = Stimulsoft.System.Drawing.Font;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiMapLabels implements ICloneable, IStiFont, IStiGetFonts, IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        static createFromJsonObject(j: StiJson): StiMapLabels;
        static createFromXml(xmlNode: XmlNode): StiMapLabels;
        clone(): StiMapLabels;
        getFonts(): Font[];
        font: Font;
        foreColor: Color;
        shadowColor: Color;
        showShadow: boolean;
        constructor(font?: Font, foreColor?: Color, shadowColor?: Color, showShadow?: boolean);
    }
}
export namespace Stimulsoft.Report.Maps {
    import IStiExportImage = Stimulsoft.Report.Components.IStiExportImage;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import List = Stimulsoft.System.Collections.List;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiMapStyle = Stimulsoft.Report.Styles.StiMapStyle;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiExportImageExtended = Stimulsoft.Report.Components.IStiExportImageExtended;
    import IStiBorder = Stimulsoft.Report.Components.IStiBorder;
    import IStiBrush = Stimulsoft.Report.Components.IStiBrush;
    import IStiDataSource = Stimulsoft.Report.Components.IStiDataSource;
    import IStiBusinessObject = Stimulsoft.Report.Components.IStiBusinessObject;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiMapLabels = Stimulsoft.Report.Maps.StiMapLabels;
    class StiMap extends StiComponent implements IStiExportImageExtended, IStiBorder, IStiBrush, IStiDataSource, IStiBusinessObject, IStiExportImage, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        clone(cloneProperties?: boolean): StiMap;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        get isDataSourceEmpty(): boolean;
        get dataSource(): StiDataSource;
        private _dataSourceName;
        get dataSourceName(): string;
        set dataSourceName(value: string);
        get isBusinessObjectEmpty(): boolean;
        get businessObject(): StiBusinessObject;
        private _businessObjectGuid;
        get businessObjectGuid(): string;
        set businessObjectGuid(value: string);
        countData: number;
        userBingKey: string;
        pushPins: string;
        onePointZoom: number;
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        isEofValue: boolean;
        get isEof(): boolean;
        set isEof(value: boolean);
        isBofValue: boolean;
        get isBof(): boolean;
        set isBof(value: boolean);
        get isEmpty(): boolean;
        positionValue: number;
        get position(): number;
        set position(value: number);
        get count(): number;
        private isCacheValues;
        private cachedCount;
        private cachedIsBusinessObjectEmpty;
        private cachedIsDataSourceEmpty;
        private cachedDataSource;
        private cachedBusinessObject;
        cacheValues(cache: boolean): void;
        get font(): Font;
        set font(value: Font);
        getFonts(): Font[];
        border: StiBorder;
        brush: StiBrush;
        get localizedCategory(): string;
        get localizedName(): string;
        labels: StiMapLabels;
        defaultClientRectangle: RectangleD;
        mapStyle: StiMapStyleIdent;
        dataFrom: StiMapSource;
        colorEach: boolean;
        stretch: boolean;
        showValue: boolean;
        shortValue: boolean;
        showZeros: boolean;
        show3D: boolean;
        displayNameType: StiDisplayNameType;
        private _language;
        get language(): string;
        set language(value: string);
        mapIdent: string;
        mapType: StiMapType;
        private isMapDataChanged;
        private _mapData;
        get mapData(): string;
        set mapData(value: string);
        keyDataColumn: string;
        nameDataColumn: string;
        valueDataColumn: string;
        groupDataColumn: string;
        colorDataColumn: string;
        latitude: string;
        longitude: string;
        mapMode: StiMapMode;
        mapImage: string;
        dataTable: StiDataTable;
        showBubble: boolean;
        valueFormat: StiFormatService;
        private static getValueFormatDefault;
        private _isHashDataEmpty;
        get isHashDataEmpty(): boolean;
        private _hashData;
        static getDefaultMapData(report: StiReport, mapIdent: string, lang: string): List<StiMapData>;
        getMapData(): List<StiMapData>;
        getCurrentStyleColors(): Color[];
        static getStyleColors(style: StiMapStyleIdent): Color[];
        getStyleBackground(): StiBrush;
        static getMapStyle2(map: StiMap): StiMapStyle;
        static getMapStyle(style: StiMapStyleIdent): StiMapStyle;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Maps.Helpers {
    class StiCustomMapFinder {
        private static lastReport;
        private static defaultMaps;
        private static customMaps;
        static clear(): void;
        static init(report: StiReport): void;
        static isCustom(mapIdent: string): boolean;
        static getContainer(report: StiReport, mapIdent: string): StiMapSvgContainer;
        static stiPopulateObject(json: object, obj: StiMapSvgContainer | StiMapSvg): void;
        static StiCustomMapFinder(): void;
    }
}
export namespace Stimulsoft.Report.Export {
    import SolidBrush = Stimulsoft.System.Drawing.SolidBrush;
    import StiMap = Stimulsoft.Report.Maps.StiMap;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiMapSvgHelper {
        static getImage(svgData: StiSvgData, scale?: number, guid?: string): Image;
        static drawMap(xmlsWriter: XmlTextWriter, map: StiMap, x: number, y: number, width: number, height: number, animated: boolean, dontConnectToData: boolean, wrapSize?: boolean): void;
        static render(map: StiMap, xmlsWriter: XmlTextWriter, animated: boolean, sScale: number, dontConnectToData: boolean): void;
        private static getValues;
        private static getKeysFromMapKeys;
        private static addToolTipStyle;
        private static getPathText;
        private static getPathRect;
        private static getPathHorAlignment;
        private static getPathVertAlignment;
        private static getToolTipIdent;
        private static getToolTipValueText;
        private static getToolTipTotalText;
        private static normalizeDecimal;
        private static getBorderStroke;
        static getFillBrush(brush: SolidBrush): string;
        private static getBubbleSize;
    }
}
export namespace Stimulsoft.Report.Export {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    class StiMathFormulaSvgHelper {
        static writeMathFormula(writer: XmlTextWriter, svgData: StiSvgData): void;
    }
}
export namespace Stimulsoft.Report.Export.Office {
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiOfficeImageFormatHelper {
        static getImageFormatExtension(currImageFormat: ImageFormat): string;
        static getImageAndTag(component: StiComponent, exportFormat: StiExportFormat, zoom: number, imageFormat: ImageFormat, culture1: CultureInfo, culture2: CultureInfo): Image;
        static correctImageFormat(imageFormat: ImageFormat, rawFormat: Stimulsoft.System.Drawing.Imaging.ImageFormat): ImageFormat;
        static removeTransparency(destinationFormat: ImageFormat, rawFormat: Stimulsoft.System.Drawing.Imaging.ImageFormat, image: Image, component: StiComponent, dispose?: boolean): Image;
    }
}
export namespace Stimulsoft.Report.Painters {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiColumnSparklinesCellPainter {
        static draw(context: StiContext, rect: RectangleD, array: any[], positiveColor: Color, negativeColor: Color): void;
    }
}
export namespace Stimulsoft.Report.Painters {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLineSparklinesCellPainter {
        static draw(context: StiContext, rect: RectangleD, array: any[], sparklineColor: Color, showArea: boolean, showFirstLastMarker?: boolean, showHighLowMarker?: boolean): void;
        private static drawArea;
        private static drawLines;
        private static drawFirstLastMarkers;
        private static drawHighLowMarkers;
        private static drawMarker;
        private static simplifyPoints;
    }
}
export namespace Stimulsoft.Report.Painters {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiWinLossSparklinesCellPainter {
        static draw(context: StiContext, rect: RectangleD, array: any[], positiveColor: Color, negativeColor: Color): void;
    }
}
export namespace Stimulsoft.Report.Painters {
    import Type = Stimulsoft.System.Type;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiPainter {
        private static typePainter;
        static getPainter(componentType: Type): StiPainter;
        getImage(component: Stimulsoft.Report.Components.StiComponent, REFzoom: any, format: StiExportFormat): Image;
        paint(component: Stimulsoft.Report.Components.StiComponent, g: Stimulsoft.System.Drawing.Graphics): void;
    }
}
export namespace Stimulsoft.Report.Painters {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiComponentPainter extends StiPainter {
        paintBorder(component: StiComponent, g: Graphics, rect: RectangleD, zoom: number, drawBorderFormatting: boolean, drawBorderSides: boolean): void;
    }
}
export namespace Stimulsoft.Report.Painters {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Image = Stimulsoft.System.Drawing.Image;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiSparkline = Stimulsoft.Report.Components.StiSparkline;
    class StiSparklinePainter extends StiComponentPainter {
        getImage(component: Stimulsoft.Report.Components.StiComponent, REFzoom: any, format: StiExportFormat): Image;
        paint(component: Stimulsoft.Report.Components.StiComponent, g: Stimulsoft.System.Drawing.Graphics): void;
        paintBackground(sparkline: StiSparkline, g: Graphics, rect: Rectangle): void;
        static drawSparkline(g: Graphics, rect: Rectangle, sparkline: StiSparkline, zoom: number): void;
        static renderSparkline(context: StiContext, rect: Rectangle, sparkline: StiSparkline, zoom: number): void;
    }
}
export namespace Stimulsoft.Report.Export {
    import Image = Stimulsoft.System.Drawing.Image;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    class StiSparklineSvgHelper {
        static getImage(svgData: StiSvgData): Image;
        static writeSparkline(writer: XmlTextWriter, svgData: StiSvgData): void;
    }
}
export namespace Stimulsoft.Report.Export {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiSvgData {
        private _x;
        get x(): number;
        set x(value: number);
        private _y;
        get y(): number;
        set y(value: number);
        private _width;
        get width(): number;
        set width(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _right;
        get right(): number;
        private _bottom;
        get bottom(): number;
        component: StiComponent;
    }
}
export namespace Stimulsoft.Report.Export {
    import List = Stimulsoft.System.Collections.List;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import Pen = Stimulsoft.System.Drawing.Pen;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiSvgGeomWriter implements IStiExportGeomWriter {
        constructor(writer: XmlTextWriter);
        private writer;
        beginPath(): void;
        closeFigure(): void;
        endPath(): void;
        fillPath(brush: any): void;
        strokePath(pen: any): void;
        moveTo(point: PointD): void;
        drawLine(pointFrom: PointD, pointTo: PointD, pen: any): void;
        drawLineTo(pointTo: PointD, pen: any): void;
        drawRectangle(rect: RectangleD, pen: any): void;
        drawPolyline(points: PointD[], pen: Pen): void;
        drawPolylineTo(points: PointD[], pen: any): void;
        drawPolygon(points: PointD[], pen: any): void;
        fillPolygon(points: PointD[], brush: any): void;
        fillPolygons(points: List<List<PointD>>, brush: any): void;
        drawBezier(p1: PointD, p2: PointD, p3: PointD, p4: PointD, pen: any): void;
        drawBezierTo(p2: PointD, p3: PointD, p4: PointD, pen: any): void;
        drawArc2(rect: RectangleD, p1: PointD, p2: PointD, pen: Pen): void;
        setPixel(point: PointD, color: Color): void;
        drawImage(img: Image, rect: RectangleD): void;
        drawText(basePoint: PointD, text: string, charsOffset: number[], font: Font, textColor: Color, angle: number, textAlign: EmfTextAlignmentMode): void;
        drawString(st: string, font: Font, brush: any, rect: RectangleD, sf: StringFormat): void;
        saveState(): void;
        restoreState(): void;
        fillRectangle(rect: RectangleD, brush: any): void;
        fillRectangle2(rect: RectangleD, color: Color): void;
        rotateTransform(angle: number): void;
        translateTransform(x: number, y: number): void;
        endTransform(): void;
        measureString(st: string, font: Font): SizeD;
        drawEllipse(rect: RectangleD, pen: any): void;
        fillEllipse(rect: RectangleD, brush: any): void;
        drawFontIcon(color: Color, icon: StiFontIcons, rect: RectangleD): void;
    }
}
export namespace Stimulsoft.Report.Export {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiSvgHelper {
        private static correctFontSize;
        private static pdfCKT;
        static getLineStyleDash(penStyle: StiPenStyle, width: number): string;
        static toUnits(numberr: number): string;
        private static writeCoordinates;
        private static writeStrokeInfo;
        static writeFillInfo(writer: XmlTextWriter, color: Color): void;
        private static checkShape;
        private static writeDocument;
        static writeWatermark(writer: XmlTextWriter, xmlIndentation: number, page: StiPage, behind: boolean, pageWidth: number, pageHeight: number, imageResolution: number, zoom?: number): void;
        private static writeWatermarkImage;
        private static writeBorder1;
        private static writeBorder2;
        private static writeElectronicSignature;
        private static writePdfDigitalSignature;
        private static writeText2;
        private static writeText;
        static getStyleString(font: Font, textColor: Color): string;
        private static writeImage;
        static writeWebContent(writer: XmlTextWriter, svgData: StiSvgData): void;
        static writeBarCode(writer: XmlTextWriter, svgData: StiSvgData): void;
        static writeShape(writer: XmlTextWriter, svgData: StiSvgData, xmlIndentation: number, useClip: boolean, guids: Hashtable): void;
        static writeFillBrush(writer: XmlTextWriter, brush: Color | StiBrush, rect: RectangleD): string;
        private static writeBrush;
        private static writeRoundedRectanglePrimitive;
        private static getRectWithCornersString;
        private static getBorderWithCornersString;
        private static getClipPathName;
        private static getUniqueName;
        private static writeIndicator;
        private static writeIconSetIndicatorTypePainter;
        private static writeDataBarIndicator;
        static saveComponentToString(component: StiComponent, imageResolution?: number, isDesigner?: boolean, ignoreIsImage?: boolean, scaleCorrection?: number): string;
        static saveToString(report: StiReport, page: StiPage, standalone?: boolean, imageResolution?: number): string;
        static writeCheckBox(writer: XmlTextWriter, svgData: StiSvgData, checkedValue: any): void;
        private static getCheckBoxData;
        static writeTextInCells(writer: XmlTextWriter, svgData: StiSvgData): void;
    }
}
export namespace Stimulsoft.Report.Export {
    let IStiHtml5ExportService: System.Interface<IStiHtml5ExportService>;
    interface IStiHtml5ExportService extends IStiExportService {
        exportHtml(report: StiReport, htmlWriter: StiHtmlTextWriter, settings: StiHtmlExportSettings): any;
    }
}
export namespace Stimulsoft.Report.Export.Htmls.ChartScripts {
    import IStiComponent = Stimulsoft.Report.Components.IStiComponent;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiChartAnimation {
        private static animateSti;
        static renderChartAnimations: boolean;
        static chartData: Hashtable<IStiComponent, string>;
        static startAnimateCharts(): void;
        private static script;
        static getScriptString(): string;
    }
}
export namespace Stimulsoft.Report.Export {
    import StiSparkline = Stimulsoft.Report.Components.StiSparkline;
    import StiGlareBrush = Stimulsoft.Base.Drawing.StiGlareBrush;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiText = Stimulsoft.Report.Components.StiText;
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import IStiComponent = Stimulsoft.Report.Components.IStiComponent;
    class StiHtmlExportService extends StiExportService {
        private storedCulture;
        renderedPagesCount: number;
        currentPassNumber: number;
        maximumPassNumber: number;
        get exportFormat(): StiExportFormat;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private exportSettings;
        private reportTmp;
        private documentFileName;
        private sendEMail;
        multipleFiles: boolean;
        clearOnFinish: boolean;
        tableRender: StiHtmlTableRender;
        htmlWriter: StiHtmlTextWriter;
        private zip;
        report: StiReport;
        private fileName;
        private startPage;
        private imageNumber;
        zoom: number;
        imageFormat: ImageFormat;
        exportQuality: StiHtmlExportQuality;
        useStylesTable: boolean;
        private isFileStreamMode;
        private imageQuality;
        imageResolution: number;
        compressToArchive: boolean;
        private useEmbeddedImages;
        openLinksTarget: string;
        chartType: StiHtmlChartType;
        private coordX;
        private coordY;
        private strSpanDiv;
        private hyperlinksToTag;
        private pointerToBookmark;
        private pointerToTag;
        hashBookmarkGuid: Hashtable;
        get hiToPt(): number;
        get pxToPt(): number;
        get dpi96(): number;
        get dpi96corr(): number;
        renderStyles: boolean;
        styles: StiCellStyle[];
        renderWebInteractions: boolean;
        htmlImageHost: StiHtmlImageHost;
        totalPageWidth: number;
        totalPageHeight: number;
        renderAsDocument: boolean;
        removeEmptySpaceAtBottom: boolean;
        pageHorAlignment: StiHorAlignment;
        private static tr_Angle;
        private static tr_Opacity;
        static fontScale: Hashtable;
        static getFontScale(font: string | Font): number;
        private addCoord;
        private formatCoords;
        formatCoord(value: number): string;
        formatColor(color: Color): string;
        formatColorRgba(color: Color): string;
        private getBorderStyle;
        private static xssList;
        private static unsafeChars;
        checkXSS(input: string, escapeChars?: boolean): string;
        setCurrentCulture(): void;
        restoreCulture(): void;
        renderFont(cell: StiHtmlTableCell, font: Font): void;
        renderTextHorAlignment(cell: StiHtmlTableCell, textOptions: any, textHorAlignment: StiTextHorAlignment, useFlex?: boolean): void;
        renderVertAlignment(cell: StiHtmlTableCell, textVertAlignment: StiVertAlignment, textOptions?: any, allowHtml?: boolean): boolean;
        renderTextDirection(cell: StiHtmlTableCell, textOptions: StiTextOptions): void;
        renderBackColor(cell: StiHtmlTableCell, color: Color): void;
        renderTextColor(cell: StiHtmlTableCell, color: Color, forceAnyColor?: boolean): void;
        renderBorder(comp: StiComponent): void;
        private renderBorder2;
        renderBorder3(cell: StiHtmlTableCell, border: StiBorderSide, side: string, borderRadius?: number): void;
        private renderPosition;
        private getSizeStrings;
        private renderImage;
        private renderImage2;
        private renderImage3;
        renderHyperlink(comp: StiComponent): boolean;
        private renderPage;
        private renderEndPage;
        private renderStartDoc;
        private fillBitmapBackground;
        private renderBookmarkScript;
        private renderChartScripts;
        private renderMapsScripts;
        private renderGaugeScripts;
        getGuid(comp: IStiComponent): string;
        private renderEndDoc;
        private renderBookmarkTree;
        private addBookmarkNode;
        prepareTextForHtml(text: string, processWhiteSpaces: boolean, isJustify: boolean): string;
        static convertTextWithHtmlTagsToHtmlText(stiText: StiText, text: string, zoom: number, htmlExport?: StiHtmlExportService): string;
        private static getParagraphString;
        renderWatermarkText(sWriter: StiHtmlTextWriter, page: StiPage, topPos?: number): void;
        renderWatermarkImage(sWriter: StiHtmlTextWriter, page: StiPage, topPos?: number): void;
        static getImage(assemblyName: string, imageName: string, makeTransparent: boolean): Image;
        static getFile(assemblyName: string, fileName: string): Uint8Array;
        private assembleGuidUsedInBookmark;
        static prepareSvg(sWriter: StiHtmlTextWriter, width: number, height: number): void;
        prepareChartData(writer: StiHtmlTextWriter, chart: IStiChart, width: number, height: number): string;
        prepareSparklineData(writer: StiHtmlTextWriter, sparkline: StiSparkline, width: number, height: number): string;
        static getSparklineData(writer: StiHtmlTextWriter, sparkline: StiSparkline, width: number, height: number): string;
        prepareGaugeData(writer: StiHtmlTextWriter, gauge: any, width: number, height: number): string;
        prepareMapData(writer: StiHtmlTextWriter, map: any, width: number, height: number): string;
        getChartScript(): string;
        clear(): void;
        private isComponentHasInteraction;
        private isComponentHasEvent;
        exportHtml(report: StiReport, writer: StiHtmlTextWriter, settings: StiHtmlExportSettings, pages?: StiPagesCollection): void;
        getGlareBackgroundGradient(glb: StiGlareBrush): string;
        constructor();
    }
    class StiBookmarkTreeNode {
        parent: number;
        title: string;
        url: string;
        used: boolean;
    }
}
export namespace Stimulsoft.Report.Export {
    class StiBmpExportService extends StiImageExportService {
    }
}
export namespace Stimulsoft.Report.Export {
    class StiEmfExportService extends StiImageExportService {
    }
}
export namespace Stimulsoft.Report.Export {
    class StiGifExportService extends StiImageExportService {
    }
}
export namespace Stimulsoft.Report.Export {
    class StiJpegExportService extends StiImageExportService {
    }
}
export namespace Stimulsoft.Report.Export {
    class StiPcxExportService extends StiImageExportService {
    }
}
export namespace Stimulsoft.Report.Export {
    class StiPngExportService extends StiImageExportService {
    }
}
export namespace Stimulsoft.Report.Export {
    class StiSvgExportService extends StiImageExportService {
    }
}
export namespace Stimulsoft.Report.Export {
    class StiSvgzExportService extends StiImageExportService {
    }
}
export namespace Stimulsoft.Report.Export {
    class StiTiffExportService extends StiImageExportService {
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiExcelExportService: System.Interface<IStiExcelExportService>;
    interface IStiExcelExportService extends IStiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiPowerPointExportService: System.Interface<IStiPowerPointExportService>;
    interface IStiPowerPointExportService extends IStiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiWordExportService: System.Interface<IStiWordExportService>;
    interface IStiWordExportService extends IStiExportService {
        removeEmptySpaceAtBottom: boolean;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiPdfExportService: System.Interface<IStiPdfExportService>;
    interface IStiPdfExportService extends IStiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
export namespace Stimulsoft.Report.Export {
    class StiPdfEmbeddedFileData {
        name: string;
        description: string;
        data: number[] | Uint8Array | string;
        private mimeType;
        get MIMEType(): string;
        set MIMEType(value: string);
        constructor(name: string, description: string, data: number[] | Uint8Array | string, mimeType?: string);
    }
}
export namespace Stimulsoft.Report.Export {
    class StiOdsExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        imageQuality: number;
        imageResolution: number;
    }
}
export namespace Stimulsoft.Report.Export {
    class StiOdtExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        usePageHeadersAndFooters: boolean;
        imageQuality: number;
        imageResolution: number;
        removeEmptySpaceAtBottom: boolean;
    }
}
export namespace Stimulsoft.Report.Export {
    import List = Stimulsoft.System.Collections.List;
    class StiPdfExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        imageQuality: number;
        imageResolution: number;
        imageResolutionMode: StiImageResolutionMode;
        embeddedFonts: boolean;
        standardPdfFonts: boolean;
        compressed: boolean;
        useUnicode: boolean;
        useDigitalSignature: boolean;
        getCertificateFromCryptoUI: boolean;
        exportRtfTextAsImage: boolean;
        passwordInputUser: string;
        passwordInputOwner: string;
        userAccessPrivileges: StiUserAccessPrivileges;
        keyLength: StiPdfEncryptionKeyLength;
        creatorString: string;
        keywordsString: string;
        imageCompressionMethod: StiPdfImageCompressionMethod;
        imageIndexedColorPaletteSize: number;
        imageFormat: StiImageFormat;
        ditheringType: StiMonochromeDitheringType;
        get pdfACompliance(): boolean;
        set pdfACompliance(value: boolean);
        pdfComplianceMode: StiPdfComplianceMode;
        autoPrintMode: StiPdfAutoPrintMode;
        allowEditable: StiPdfAllowEditable;
        embeddedFiles: List<StiPdfEmbeddedFileData>;
        ZUGFeRDComplianceMode: StiPdfZUGFeRDComplianceMode;
        ZUGFeRDConformanceLevel: string;
        ZUGFeRDInvoiceData: number[] | Uint8Array | string;
        toParameters(): any;
    }
}
export namespace Stimulsoft.Report.Export {
    class StiRtfExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        codePage: number;
        exportMode: StiRtfExportMode;
        usePageHeadersAndFooters: boolean;
        imageQuality: number;
        imageResolution: number;
        removeEmptySpaceAtBottom: boolean;
        storeImagesAsPng: boolean;
    }
}
export namespace Stimulsoft.Report.Export {
    import Encoding = Stimulsoft.System.Text.Encoding;
    class StiTxtExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        encoding: Encoding;
        drawBorder: boolean;
        borderType: StiTxtBorderType;
        killSpaceLines: boolean;
        killSpaceGraphLines: boolean;
        putFeedPageCode: boolean;
        cutLongLines: boolean;
        zoomX: number;
        zoomY: number;
        useEscapeCodes: boolean;
        escapeCodesCollectionName: string;
        protected _returnType: StringConstructor;
        toParameters(): any;
    }
}
export namespace Stimulsoft.Report.Export {
    class StiXpsExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        imageQuality: number;
        imageResolution: number;
        exportRtfTextAsImage: boolean;
    }
}
export namespace Stimulsoft.Report.Export {
    import Encoding = Stimulsoft.System.Text.Encoding;
    class StiDataExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        dataType: StiDataType;
        dataExportMode: StiDataExportMode;
        encoding: Encoding;
        exportDataOnly: boolean;
        codePage: StiDbfCodePages;
        separator: string;
        tableName: string;
        skipColumnHeaders: boolean;
        useDefaultSystemEncoding: boolean;
        protected _returnType: StringConstructor;
        constructor(dataType?: StiDataType);
        toParameters(): any;
    }
}
export namespace Stimulsoft.Report.Export {
    class StiCsvExportSettings extends StiDataExportSettings {
        dataType: StiDataType;
        constructor();
    }
}
export namespace Stimulsoft.Report.Export {
    class StiDbfExportSettings extends StiDataExportSettings {
        dataType: StiDataType;
        constructor();
    }
}
export namespace Stimulsoft.Report.Export {
    class StiDifExportSettings extends StiDataExportSettings {
        dataType: StiDataType;
        constructor();
    }
}
export namespace Stimulsoft.Report.Export {
    class StiJsonExportSettings extends StiDataExportSettings {
        dataType: StiDataType;
        constructor();
    }
}
export namespace Stimulsoft.Report.Export {
    class StiSylkExportSettings extends StiDataExportSettings {
        dataType: StiDataType;
        constructor();
    }
}
export namespace Stimulsoft.Report.Export {
    class StiXmlExportSettings extends StiDataExportSettings {
        dataType: StiDataType;
        constructor();
    }
}
export namespace Stimulsoft.Report.Export {
    import Encoding = Stimulsoft.System.Text.Encoding;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    class StiHtmlExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        htmlType: StiHtmlType;
        imageQuality: number;
        imageResolution: number;
        imageFormat: ImageFormat;
        encoding: Encoding;
        zoom: number;
        exportMode: StiHtmlExportMode;
        exportQuality: StiHtmlExportQuality;
        addPageBreaks: boolean;
        bookmarksTreeWidth: number;
        exportBookmarksMode: StiHtmlExportBookmarksMode;
        useStylesTable: boolean;
        removeEmptySpaceAtBottom: boolean;
        pageHorAlignment: StiHorAlignment;
        compressToArchive: boolean;
        useEmbeddedImages: boolean;
        continuousPages: boolean;
        chartType: StiHtmlChartType;
        openLinksTarget: string;
        useWatermarkMargins: boolean;
        protected _returnType: StringConstructor;
        toParameters(): any;
        constructor(htmlType?: StiHtmlType);
    }
}
export namespace Stimulsoft.Report.Export {
    class StiHtml5ExportSettings extends StiHtmlExportSettings {
        constructor();
    }
}
export namespace Stimulsoft.Report.Export {
    class StiBmpExportSettings extends StiImageExportSettings {
        constructor();
    }
}
export namespace Stimulsoft.Report.Export {
    class StiEmfExportSettings extends StiImageExportSettings {
        constructor();
    }
}
export namespace Stimulsoft.Report.Export {
    class StiGifExportSettings extends StiImageExportSettings {
        constructor();
    }
}
export namespace Stimulsoft.Report.Export {
    class StiJpegExportSettings extends StiImageExportSettings {
        constructor();
    }
}
export namespace Stimulsoft.Report.Export {
    class StiPcxExportSettings extends StiImageExportSettings {
        constructor();
    }
}
export namespace Stimulsoft.Report.Export {
    class StiPngExportSettings extends StiImageExportSettings {
        constructor();
    }
}
export namespace Stimulsoft.Report.Export {
    class StiSvgExportSettings extends StiImageExportSettings {
        constructor();
    }
}
export namespace Stimulsoft.Report.Export {
    class StiSvgzExportSettings extends StiImageExportSettings {
        constructor();
    }
}
export namespace Stimulsoft.Report.Export {
    class StiTiffExportSettings extends StiImageExportSettings {
        constructor();
    }
}
export namespace Stimulsoft.Report.Export {
    class StiExcelExportSettings extends StiPageRangeExportSettings {
        excelType: StiExcelType;
        useOnePageHeaderAndFooter: boolean;
        get exportDataOnly(): boolean;
        set exportDataOnly(value: boolean);
        dataExportMode: StiDataExportMode;
        exportPageBreaks: boolean;
        exportObjectFormatting: boolean;
        exportEachPageToSheet: boolean;
        imageQuality: number;
        imageResolution: number;
        imageFormat: ImageFormat;
        companyString: string;
        lastModifiedString: string;
        restrictEditing: StiExcelRestrictEditing;
        protectionPassword: string;
        encryptionPassword: string;
        getExportFormat(): StiExportFormat;
        constructor(excelType?: StiExcelType);
        toParameters(): any;
    }
    class StiExcel2007ExportSettings extends StiExcelExportSettings {
    }
}
export namespace Stimulsoft.Report.Export {
    class StiPowerPointExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        imageQuality: number;
        imageResolution: number;
        encryptionPassword: string;
        imageFormat: ImageFormat;
    }
    class StiPpt2007ExportSettings extends StiPowerPointExportSettings {
    }
}
export namespace Stimulsoft.Report.Export {
    class StiWordExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        usePageHeadersAndFooters: boolean;
        imageQuality: number;
        imageResolution: number;
        imageFormat: ImageFormat;
        removeEmptySpaceAtBottom: boolean;
        companyString: string;
        lastModifiedString: string;
        restrictEditing: StiWordRestrictEditing;
        protectionPassword: string;
        encryptionPassword: string;
        toParameters(): any;
    }
    class StiWord2007ExportSettings extends StiWordExportSettings {
    }
}
export namespace Stimulsoft.Report.Export {
    import List = Stimulsoft.System.Collections.List;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import PointD = Stimulsoft.System.Drawing.Point;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Pen = Stimulsoft.System.Drawing.Pen;
    import Image = Stimulsoft.System.Drawing.Image;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    class StiBarCodeExportPainter implements Stimulsoft.Report.Painters.IStiBarCodePainter {
        private geomWriter;
        get onlyAssembleData(): boolean;
        baseTransform(context: any, x: number, y: number, angle: number, dx: number, dy: number): void;
        baseRollbackTransform(context: any): void;
        baseFillRectangle(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        baseFillRectangle2D(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        baseFillPolygon(context: any, brush: StiBrush, points: PointD[]): void;
        baseFillPolygons(context: any, brush: StiBrush, points: List<List<PointD>>): void;
        baseFillEllipse(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        baseDrawRectangle(context: any, penColor: Color, penSize: number, x: number, y: number, width: number, height: number): void;
        baseDrawImage(context: any, image: Image, report: StiReport, x: number, y: number, width: number, height: number): void;
        baseDrawString(context: any, st: string, font: Font, brush: StiBrush, rect: RectangleD, sf: StringFormat): void;
        baseMeasureString(context: any, st: string, font: Font): SizeD;
        static createNew(geomWriter1: IStiExportGeomWriter): StiBarCodeExportPainter;
        constructor(geomWriter1: StiSvgGeomWriter);
    }
    interface IStiExportGeomWriter {
        beginPath(): any;
        closeFigure(): any;
        endPath(): any;
        fillPath(brush: any): any;
        strokePath(pen: any): any;
        moveTo(point: PointD): any;
        drawLine(pointFrom: PointD, pointTo: PointD, pen: any): any;
        drawLineTo(pointTo: PointD, pen: any): any;
        drawRectangle(rect: RectangleD, pen: any, corners: StiCornerRadius): any;
        fillRectangle(rect: RectangleD, brush: Color | any, corners: StiCornerRadius): any;
        drawPolyline(points: PointD[], pen: Pen): any;
        drawPolylineTo(points: PointD[], pen: any): any;
        drawPolygon(points: PointD[], pen: any): any;
        fillPolygon(points: PointD[], brush: any): any;
        fillPolygons(points: List<List<PointD>>, brush: any): any;
        fillEllipse(rect: RectangleD, brush: any): any;
        drawBezier(p1: PointD, p2: PointD, p3: PointD, p4: PointD, pen: any): any;
        drawBezierTo(p2: PointD, p3: PointD, p4: PointD, pen: any): any;
        drawArc2(rect: RectangleD, p1: PointD, p2: PointD, pen: Pen): any;
        setPixel(point: PointD, color: Color): any;
        drawImage(img: Image, rect: RectangleD): any;
        drawText(basePoint: PointD, text: string, charsOffset: number[], font: Font, textColor: Color, angle: number, textAlign: EmfTextAlignmentMode): any;
        drawString(st: string, font: Font, brush: any, rect: RectangleD, sf: StringFormat): any;
        saveState(): any;
        restoreState(): any;
        translateTransform(x: number, y: number): any;
        rotateTransform(angle: number): any;
        measureString(st: string, font: Font): SizeD;
    }
}
export namespace Stimulsoft.Report.Export {
    import StringBuilder = Stimulsoft.System.Text.StringBuilder;
    class StiBidirectionalConvert {
        private arabicTableSize;
        private ligaturesTableSize;
        private static ligaturesTable;
        private static arabicTable;
        private static arabicTableArray;
        private stSeparator;
        private modePdf;
        convert(inputString: StringBuilder, useRightToLeft: boolean): StringBuilder;
        private convertArabic;
        private symbolIsDigitOrDelimiter;
        private static symbolIsArabicOrHebrew;
        static stringContainArabicOrHebrew(st: string): boolean;
        private symbolIsBidiMark;
        private symbolIsLTRMark;
        private symbolIsRTLMark;
        clear(): void;
        constructor(modePdf?: boolean);
    }
}
export namespace Stimulsoft.Report.Export {
    enum BidiClass {
        L = 0,
        LRE = 1,
        LRO = 2,
        R = 3,
        AL = 4,
        RLE = 5,
        RLO = 6,
        PDF = 7,
        EN = 8,
        ES = 9,
        ET = 10,
        AN = 11,
        CS = 12,
        NSM = 13,
        BN = 14,
        B = 15,
        S = 16,
        WS = 17,
        ON = 18,
        LRI = 19,
        RLI = 20,
        FSI = 21,
        PDI = 22
    }
    class IsolatingRunSequence {
        level: number;
        sos: BidiClass;
        eos: BidiClass;
        length: number;
        indexes: number[];
        types: number[];
        resolvedLevels: number[];
        resolveWeaks(): void;
        resolveNeutrals(input: string): void;
        resolveImplicit(): void;
        applyTypesAndLevels(refTypesList: {
            ref: number[];
        }, refLevelsList: {
            ref: number[];
        }): void;
        computeIsolatingRunSequence(pLevel: number, indexList: number[], typesList: number[], levels: number[]): void;
        getRunLimit(index: number, limit: number, typesSet: BidiClass[]): number;
        setRunTypes(start: number, limit: number, newType: BidiClass): void;
        constructor(paragraphEmbeddingLevel: number, runIndexList: number[], types: number[], levels: number[]);
    }
    export class StiBidirectionalConvert2 {
        static MAX_DEPTH: number;
        static MAX_NESTED_BRACKET_PAIRS: number;
        static leftBracketsList: string;
        static rightBracketsList: string;
        static charCode07: string;
        static convertString(input: string, rightToLeft: boolean, modePdf?: boolean, paddingWithSpaces?: boolean): string;
        static logicalToVisual(input: string, rightToLeft: boolean, lineBreaks?: number[], parts?: string[]): string;
        static convertArabicHebrew(inputSB: string, keepSize?: boolean): string;
        static classifyCharacters(text: string, refTypesList: {
            ref: number[];
        }): void;
        static getParagraphEmbeddingLevel(types: number[], matchingPDI: number[], si?: number, ei?: number): number;
        static getExplicitEmbeddingLevels(level: number, types: number[], refLevels: {
            ref: number[];
        }, matchingPDI: number[]): void;
        static getReorderedIndexes(level: number, typesList: number[], levelsList: number[], lineBreaks: number[], refLevels: {
            ref: number[];
        }): number[];
        static getMatchingPDI(types: number[], outMatchingPDI: {
            ref: number[];
        }, outMatchingIsolateInitiator: {
            ref: number[];
        }): void;
        static removeX9Characters(refBuffer: {
            ref: number[];
        }): void;
        static getLevelRuns(levels: number[]): number[][];
        static getRunForCharacter(levelRuns: number[][], length: number): number[];
        static getIsolatingRunSequences(pLevel: number, types: number[], levels: number[], levelRuns: number[][], matchingIsolateInitiator: number[], matchingPDI: number[], runCharsArray: number[]): IsolatingRunSequence[];
        static setLevels(refLevels: {
            ref: number[];
        }, newLevel: number): void;
        static leastGreaterOdd(l: number): number;
        static leastGreaterEven(l: number): number;
        static isOdd(n: number): boolean;
        static getTypeForLevel(level: number): BidiClass;
        static getTextLevels(paragraphEmbeddingLevel: number, typesList: number[], levelsList: number[], lineBreaks: number[]): number[];
        static getMultiLineReordered(levels: number[], lineBreaks: number[]): number[];
        static computeReorderingIndexes(levels: number[]): number[];
        static getOrderedString(input: string, newIndexes: number[], levels: number[]): string;
        static isBracketTypeOpen(ch: string): boolean;
        static isBracketTypeClose(ch: string): boolean;
    }
    export {};
}
export namespace Stimulsoft.Report.Export {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiExportImage = Stimulsoft.Report.Components.IStiExportImage;
    class StiCell {
        clone(): StiCell;
        forceExportAsImage(exportImage: any): boolean;
        private _exportFormat;
        get exportFormat(): StiExportFormat;
        set exportFormat(value: StiExportFormat);
        private _component;
        get component(): StiComponent;
        set component(value: StiComponent);
        private _exportImage;
        get exportImage(): IStiExportImage;
        set exportImage(value: IStiExportImage);
        private _cellStyle;
        get cellStyle(): StiCellStyle;
        set cellStyle(value: StiCellStyle);
        left: number;
        top: number;
        width: number;
        componentId: number;
        private _height;
        get height(): number;
        set height(value: number);
        text: string;
        constructor(exportFormat?: StiExportFormat);
    }
}
export namespace Stimulsoft.Report.Export {
    import IStiExportImage = Stimulsoft.Report.Components.IStiExportImage;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCell2 extends StiCell {
        clone(): StiCell;
        private isExportImageNull;
        private matrix;
        get exportFormat(): StiExportFormat;
        get component(): StiComponent;
        set component(value: StiComponent);
        get exportImage(): IStiExportImage;
        set exportImage(value: IStiExportImage);
        pageId: number;
        componentId: number;
        cellStyleId: number;
        get cellStyle(): StiCellStyle;
        set cellStyle(value: StiCellStyle);
        constructor(matrix: StiMatrix);
    }
}
export namespace Stimulsoft.Report.Export {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    class StiCellStyle {
        clone(): StiCellStyle;
        getHashCode(): number;
        equals(obj: any): boolean;
        static getStyleFromCache(color: Color, textColor: Color, font: Font, horAlignment: StiTextHorAlignment, vertAlignment: StiVertAlignment, border: StiBorderSide, borderL: StiBorderSide, borderR: StiBorderSide, borderB: StiBorderSide, textOptions: StiTextOptions, wordWrap: boolean, format: string, internalStyleName: string, lineSpacing: number, hashStyles: Hashtable, styles: StiCellStyle[], fontsCache: Hashtable, cellStyle: StiCellStyle, simplyAdd: boolean, overflow: boolean, borderRadius: number, allowHtmlTags: boolean): StiCellStyle;
        border: StiBorderSide;
        borderL: StiBorderSide;
        borderR: StiBorderSide;
        borderB: StiBorderSide;
        absolutePosition: boolean;
        color: Color;
        font: Font;
        horAlignment: StiTextHorAlignment;
        vertAlignment: StiVertAlignment;
        textOptions: StiTextOptions;
        textColor: Color;
        wordWrap: boolean;
        format: string;
        overflow: boolean;
        borderRadius: number;
        lineSpacing: number;
        allowHtmlTags: boolean;
        private _internalStyleName;
        get internalStyleName(): string;
        set internalStyleName(value: string);
        private _styleName;
        get styleName(): string;
        set styleName(value: string);
        constructor(color: Color, textColor: Color, font: Font, horAlignment: StiTextHorAlignment, vertAlignment: StiVertAlignment, border: StiBorderSide, borderL: StiBorderSide, borderR: StiBorderSide, borderB: StiBorderSide, textOptions: StiTextOptions, wordWrap: boolean, format: string, lineSpacing: number, styleName?: string, overflow?: boolean, borderRadius?: number, allowHtmlTags?: boolean);
    }
}
export namespace Stimulsoft.Report.Export {
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCellStyle2 {
        clone(): StiCellStyle2;
        equals(style: StiCellStyle2): boolean;
        absolutePosition: boolean;
        color: Color;
        font: Font;
        horAlignment: StiTextHorAlignment;
        vertAlignment: StiVertAlignment;
        textOptions: StiTextOptions;
        textColor: Color;
        wordWrap: boolean;
        format: string;
        private _internalStyleName;
        get internalStyleName(): string;
        set internalStyleName(value: string);
        private _styleName;
        get styleName(): string;
        set styleName(value: string);
        constructor(color: Color, textColor: Color, font: Font, horAlignment: StiTextHorAlignment, vertAlignment: StiVertAlignment, textOptions: StiTextOptions, wordWrap: boolean, format: string, styleName?: string);
    }
}
export namespace Stimulsoft.Report.Export {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import ImageFormat = Stimulsoft.System.Drawing.Imaging.ImageFormat;
    import Image = System.Drawing.Image;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiExportImageCache {
        imageCache: StiImageCache;
        imageIndex: Hashtable;
        imageIndex2: Hashtable;
        isOffice: boolean;
        imageFormat: Stimulsoft.Report.ImageFormat;
        scale: number;
        report: StiReport;
        addImage(image: Image, flate: boolean, rect: Rectangle, reconvert: boolean, hashTable: Hashtable, page: StiPage, compId: number, propId: string, comp: StiComponent): Promise<void>;
        getImageIndex(comp: StiComponent, propId?: string, compIndex?: any): number;
        copyImageInfo(oldPage: StiPage, newPage: StiPage, oldComp: StiComponent, newComp: StiComponent): void;
        constructor(imageFormat: Stimulsoft.Report.ImageFormat, isOffice: boolean, imageCache: StiImageCache, scale: number, report: StiReport);
    }
    class StiExportImageHelper {
        static convertAllImages(renderedReport: StiReport, imageFormat: ImageFormat, flate?: boolean, format?: StiExportFormat, exportCache?: StiExportImageCache): Promise<void>;
        static restoreImagesWithMask(renderedReport: StiReport): Promise<void>;
    }
}
export namespace Stimulsoft.Report.Export {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiHtmlImageHost {
        htmlExport: StiHtmlExportService;
        isMhtExport: boolean;
        forcePng: boolean;
        getImageString(bmp: Image): string;
        constructor(htmlExport: StiHtmlExportService);
    }
}
export namespace Stimulsoft.Report.Export {
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiHatchBrush = Stimulsoft.Base.Drawing.StiHatchBrush;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import TextWriter = Stimulsoft.System.IO.TextWriter;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    enum StiHtmlUnitType {
        Pixel = 0,
        Point = 1
    }
    class StiHtmlUnit {
        private static hiToPt;
        value: number;
        unitType: StiHtmlUnitType;
        toString(): string;
        static toPixelString(value: number): string;
        static newUnit2(value: number, unitType: StiHtmlUnitType): StiHtmlUnit;
        static newUnit(value: number, usePoints?: boolean): StiHtmlUnit;
        static isNullOrZero(unit: StiHtmlUnit): boolean;
    }
    class StiHtmlSvg {
        text: string;
    }
    class StiHtmlHyperlink {
        text: string;
        toolTip: string;
        navigateUrl: string;
        attributes: Hashtable;
        style: Hashtable;
        cssClass: string;
        openLinksTarget: string;
        id: string;
        image: StiHtmlImage;
        constructor();
    }
    class StiHtmlImage {
        toolTip: string;
        imageUrl: string;
        width: StiHtmlUnit;
        height: StiHtmlUnit;
        aspectRatio: boolean;
        multipleFactor: number;
        margins: {
            left: number;
            right: number;
            top: number;
            bottom: number;
            isEmpty: boolean;
        };
        horAlignment: number;
        vertAlignment: number;
        imageRotation: number;
        stretch: boolean;
        zoom: number;
        base64: string;
    }
    class StiHtmlTableCell {
        width: StiHtmlUnit;
        height: StiHtmlUnit;
        style: Hashtable;
        columnSpan: number;
        rowSpan: number;
        cssClass: string;
        text: string;
        toolTip: string;
        controls: any[];
        id: string;
        interaction: string;
        collapsed: string;
        parentIndex: string;
        sortDirection: string;
        dataBandSort: string;
        pageGuid: string;
        pageIndex: string;
        reportFile: string;
        componentIndex: string;
        editable: string;
        drillDownMode: string;
        interactionEvents: string;
        constructor();
    }
    class StiHtmlTableRow {
        style: Hashtable;
        cells: StiHtmlTableCell[];
        height: StiHtmlUnit;
        constructor();
    }
    class StiHtmlTable {
        backImageUrl: string;
        backgroundRepeat: string;
        backgroundPosition: string;
        width: StiHtmlUnit;
        maxWidth: StiHtmlUnit;
        border: StiBorder;
        borderWidth: number;
        cellPadding: number;
        cellSpacing: number;
        rows: StiHtmlTableRow[];
        align: StiHorAlignment;
        position: string;
        static marginsKey: string;
        static pageBreakBeforeKey: string;
        static vertAlignKey: string;
        static horAlignKey: string;
        static wordwrapKey: string;
        private static wrongUrlSymbols;
        htmlExportSettings: StiHtmlExportSettings;
        htmlExport: StiHtmlExportService;
        matrix: StiMatrix;
        get dpi96(): number;
        static stringToUrl(input: string): string;
        static stringToTitle(input: string): string;
        renderControl(writer: StiHtmlTextWriter, addPageBreaks: boolean, page: StiPage): void;
        private renderImage;
        private writeTableBegin;
        private writeTableEnd;
        constructor();
    }
    enum WriterMode {
        None = 0,
        BeginTag = 1,
        Attribute = 2,
        Data = 3
    }
    class StiHtmlTextWriter {
        private stream;
        private mode;
        indent: number;
        write(st: string): void;
        writeLine(st?: string): void;
        writeBeginTag(st: string): void;
        writeFullBeginTag(st: string): void;
        writeEndTag(st: string): void;
        writeFullEndTag(st: string): void;
        writeAttribute(attr: string, value: string): void;
        writeStyleAttribute(attr: string, value: string): void;
        flush(): void;
        getStream(): TextWriter;
        private closeTag;
        private checkIndent;
        constructor(baseStream: TextWriter);
    }
    class StiHtmlTableRender {
        private htmlExport;
        private htmlExportSettings;
        inherentStyles: Hashtable<any, any>;
        matrix: StiMatrix;
        renderStyle(style: StiCellStyle): void;
        renderStyleTable(cell: StiHtmlTableCell, style: StiCellStyle): void;
        renderStyles(useBookmarks: boolean, exportBookmarksOnly: boolean, cssStyles: Hashtable): void;
        renderStylesTable(useBookmarks: boolean, exportBookmarksOnly: boolean, cssStyles?: Hashtable): void;
        renderStylesTable2(useBookmarks: boolean, exportBookmarksOnly: boolean, addStyleTag: boolean, cssStyles?: Hashtable): void;
        private getWidth;
        private getHeight;
        renderTable(renderStyles: boolean, backGroundImageString: string, useBookmarks: boolean, exportBookmarksOnly: boolean, cssStyles: Hashtable, watermarkShowBehind?: boolean, border?: StiBorder, page?: StiPage): void;
        static getHatchBrushBackgroundStyle(htb: StiHatchBrush): string;
        constructor(htmlExport: StiHtmlExportService, htmlExportSettings: StiHtmlExportSettings, pages: StiPagesCollection);
    }
}
export namespace Stimulsoft.Report.Export {
    import List = Stimulsoft.System.Collections.List;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    import Image = Stimulsoft.System.Drawing.Image;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    enum StiTableLineInfo {
        Empty = 0,
        Unknown = 1,
        PageHeader = 2,
        PageFooter = 3,
        HeaderAP = 4,
        FooterAP = 5,
        HeaderD = 6,
        FooterD = 7,
        Data = 8,
        Trash = 9
    }
    class StiMatrix {
        cells2: StiCell[][];
        cells: StiMatrixCellsCollection;
        cellsMap: StiCell[][];
        totalHeight: number;
        totalWidth: number;
        styles: StiCellStyle[];
        coordX: List<number>;
        coordY: List<number>;
        linePlacement: StiTableLineInfo[];
        parentBandName: string[];
        bordersX2: StiBorderSide[][];
        bordersX: StiMatrixBorderSidesXCollection;
        bordersY2: StiBorderSide[][];
        bordersY: StiMatrixBorderSidesYCollection;
        horizontalPageBreaks: number[];
        cellStyles2: StiCellStyle[][];
        cellStyles: StiMatrixCellStylesCollection;
        bookmarks2: string[][];
        bookmarks: StiMatrixBookmarksCollection;
        bookmarksTable: Hashtable;
        interactions: number[][][];
        private maxRowHeight;
        private _defaultLinePrimitiveWidth;
        private static staticRectanglePrimitive;
        private coordXCheck;
        private coordYCheck;
        private coordXNew;
        private coordYNew;
        private coordXPrim;
        private coordYPrim;
        imagesBaseRect: Hashtable;
        private leftCached;
        private topCached;
        private xcHash;
        private ycHash;
        private tagSplitCache;
        private stylesCache;
        private fontsCache;
        private createdCells;
        borderSides: StiBorderSide[];
        exportFormat: StiExportFormat;
        private isHtmlService;
        private isHtmlOrExcelXmlService;
        private isHtmlPngMode;
        report: StiReport;
        private pages;
        private addComponentWithInteractions;
        private replaceCheckboxes;
        private hyperlinksToTag;
        pointerToBookmark: Hashtable;
        private pointerToTag;
        private maxCoordY;
        private defaultLinePrimitiveWidth;
        useCacheMode: boolean;
        private cacheManager;
        private setBookmarkValue;
        private static sortForMatrix;
        private round;
        private addCoord;
        static htmlScaleX: number;
        static htmlScaleY: number;
        private addCoord2;
        prepareTable(): void;
        getRange(rect: RectangleD): Rectangle;
        getStyleFromComponent(component: StiComponent, x: number, y: number, id: string, width?: number): StiCellStyle;
        private getStyle;
        private renderComponent;
        private getCellRectangle;
        private cutRectangleFromCellsMap;
        isComponentHasInteraction(component: StiComponent): boolean;
        isComponentHasEvent: (component: StiComponent) => boolean | Function;
        scanComponentsPlacement(optimize: boolean, exportObjectFormatting?: boolean): void;
        private getParentBandName;
        private processIntersectedCells;
        private getMaxRectFromCell;
        splitTagWithCache(inputString: string): string[];
        static splitTag(inputString: string): string[];
        static getStringsFromTag(tag: string, startPosition: number): string[];
        private copyFieldsListToFields;
        fields: DataField[];
        dataArrayLength: number;
        private fieldsList;
        private sizeX;
        private sizeY;
        private htName;
        prepareDocument(service: StiExportService, mode: StiDataExportMode): void;
        checkStylesNames(): void;
        getRealImageData(cell: StiCell, baseImage: Image, list?: any[]): Image;
        private checkComponentPlacement;
        static replaceComponentForExport(refComponent: {
            ref: StiComponent;
        }, replaceCheckboxes: boolean): void;
        private lastPage;
        private lastPageId;
        private lastComps;
        getCellComponent(cell2: StiCell): StiComponent;
        setCellComponent(cell2: StiCell, component: StiComponent, indexComponent: number): void;
        getBorderSideIndex(side: StiBorderSide): number;
        private clearCellsMapArea;
        static GCCollect(): void;
        allowModification(flag: boolean): void;
        clear(): void;
        constructor(pages: StiPagesCollection, checkForExcel: boolean, service: StiExportService, styles?: StiCellStyle[], dataMode?: StiDataExportMode, hasDividedPages?: boolean);
    }
    class DataField {
        name: string;
        info: number[];
        formatString: string;
        dataArray: string[];
        readyName: boolean;
        readyType: boolean;
        constructor(size: number);
    }
}
export namespace Stimulsoft.Report.Export {
    class StiMatrixCacheManager {
        private matrixWidth;
        private matrixHeight;
        private segmentHeight;
        private matrix;
        private amountOfProcessedPagesForStartGCCollect;
        private cachePath;
        flagForceSaveSegment: boolean;
        private _segments;
        get segments(): StiMatrixCacheSegment[];
        private _quickAccessSegments;
        get quickAccessSegments(): number[];
        amountOfQuickAccessSegments: number;
        getMatrixSegment(index: number): StiMatrixCacheSegment;
        getMatrixLineData(lineNumber: number): StiMatrixLineData;
        writeSegment(segment: StiMatrixCacheSegment): object;
        private writeMatrixLine;
        private writeMatrixCell;
        readSegment(string: string, segment: StiMatrixCacheSegment): void;
        private readMatrixCell;
        private readMatrixBorders;
        private readMatrixBookmark;
        private readMatrixCellStyles;
        saveSegment(segment: StiMatrixCacheSegment): void;
        loadSegment(segment: StiMatrixCacheSegment): void;
        clear(): void;
        constructor(matrix: StiMatrix, width: number, height: number, maxPageHeight: number);
    }
}
export namespace Stimulsoft.Report.Export {
    import Size = Stimulsoft.System.Drawing.Size;
    class StiMatrixBookmarksCollection {
        private manager;
        private matrix;
        gett(row: number, column: number): string;
        sett(row: number, column: number, value: string): void;
        bookmarksTable: {
            [key: string]: Size;
        };
        constructor(manager: StiMatrixCacheManager, matrix: StiMatrix);
    }
}
export namespace Stimulsoft.Report.Export {
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    class StiMatrixBorderSidesXCollection {
        private manager;
        private matrix;
        gett(row: number, column: number): StiBorderSide;
        sett(row: number, column: number, value: StiBorderSide): void;
        constructor(manager: StiMatrixCacheManager, matrix: StiMatrix);
    }
}
export namespace Stimulsoft.Report.Export {
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    class StiMatrixBorderSidesYCollection {
        private manager;
        private matrix;
        gett(row: number, column: number): StiBorderSide;
        sett(row: number, column: number, value: StiBorderSide): void;
        constructor(manager: StiMatrixCacheManager, matrix: StiMatrix);
    }
}
export namespace Stimulsoft.Report.Export {
    class StiMatrixCache {
        static createNewCache(): string;
        static deleteCache(path: string): void;
        static getCacheSegmentName(cache: string, cachePageGuid: string): string;
        static saveSegment(path: string, segment: string): void;
        static loadSegment(path: string): string;
        private static cachedStrings;
    }
}
export namespace Stimulsoft.Report.Export {
    class StiMatrixCacheSegment {
        private segmentHeight;
        private _cacheGuid;
        get cacheGuid(): string;
        set cacheGuid(value: string);
        private _lines;
        get lines(): StiMatrixLineData[];
        set lines(value: StiMatrixLineData[]);
        isSaved: boolean;
        newCacheGuid(): void;
        clear(): void;
        constructor(height: number);
    }
}
export namespace Stimulsoft.Report.Export {
    class StiMatrixCellStylesCollection {
        private manager;
        private matrix;
        gett(row: number, column: number): StiCellStyle;
        sett(row: number, column: number, value: StiCellStyle): void;
        constructor(manager: StiMatrixCacheManager, matrix: StiMatrix);
    }
}
export namespace Stimulsoft.Report.Export {
    class StiMatrixCellsCollection {
        private manager;
        private matrix;
        gett(row: number, column: number): StiCell;
        sett(row: number, column: number, value: StiCell): void;
        constructor(manager: StiMatrixCacheManager, matrix: StiMatrix);
    }
}
export namespace Stimulsoft.Report.Export {
    class StiMatrixLineData {
        cells: StiCell[];
        cellsMap: StiCell[];
        bordersX: number[];
        bordersY: number[];
        cellStyles: number[];
        bookmarks: string[];
        constructor(size: number);
    }
}
export namespace Stimulsoft.Report.Export {
    enum EmfTextAlignmentMode {
        TA_LEFT = 0,
        TA_RIGHT = 2,
        TA_CENTER = 6,
        TA_TOP = 0,
        TA_BOTTOM = 8,
        TA_BASELINE = 24,
        TA_NOUPDATECP = 0,
        TA_UPDATECP = 1,
        TA_RTLREADING = 256,
        TA_MASK = 287
    }
}
export namespace Stimulsoft.Report.Export {
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    class StiSegmentPagesDivider {
        static divide(pages: StiPagesCollection, service?: StiExportService, exportImageCache?: StiExportImageCache): StiPagesCollection;
    }
}
export namespace Stimulsoft.Report.Extensions {
    import DataColumn = Stimulsoft.System.Data.DataColumn;
    import Type = Stimulsoft.System.Type;
    class DataColumnExt {
        static tryConvertColumnType(column: DataColumn, newType: Type): boolean;
    }
}
export namespace Stimulsoft.Report.Func {
    class Ar {
        static MyAnd: string;
        static MyArry1: string[];
        static MyArry2: string[];
        static MyArry3: string[];
        static numToStr(numb: number, currency: string, subCurrency: string): string;
    }
}
export namespace Stimulsoft.Report.Func {
    class Bg {
        private static num0;
        private static num100;
        private static num2bgtext;
        private static ucfirst;
        static numToStr(num: number, upperCase?: boolean): string;
        static currToStr(num: number, isoCode?: string, showCents?: boolean, upperCase?: boolean): string;
    }
}
export namespace Stimulsoft.Report.Func {
    import DateTime = Stimulsoft.System.DateTime;
    class En {
        private static months;
        private static units;
        private static tens;
        private static addUnits;
        private static addTens;
        private static addRank;
        static decline(value: number, oneOrShowCents: string | boolean, twoOrDollars: string, cents?: string): string;
        static numToStr(value: number, uppercase?: boolean): string;
        static currToStr3(value: number, showCents: boolean): string;
        static currToStr(value: number, uppercase?: boolean, showCents?: boolean, dollars?: string, cents?: string): string;
        static dateToStr(date: DateTime, uppercase?: boolean): string;
    }
}
export namespace Stimulsoft.Report.Func {
    class EnGb {
        static zeroWord: string;
        static lessWord: string;
        static triplets: string[][];
        static lessTwenty: string[];
        static tens: string[];
        static convertToWord(numberr: number, currencyISO: string, decimals: number): string;
        private static convertToWord2;
        private static calculateOver;
    }
}
export namespace Stimulsoft.Report.Func {
    class EnIn {
        static numberToStr(value: number, blankIfZero?: boolean): string;
        static currencyToStr(currencyBasicUnit: string, currencyFractionalUnit: string, value: number, decimalPlaces: number, blankIfZero?: boolean): string;
        private static numberToWords;
        private static _wordsDictionary;
        private static get wordsDictionary();
    }
}
export namespace Stimulsoft.Report.Func {
    class Es {
        static zeroWord: string;
        static lessWord: string;
        static triplets: string[][];
        static lessTwenty: string[];
        static tens: string[];
        static currencies: string[][];
        static convertToWord(numberr: number, currencyISO: string, decimals: number, female?: boolean): string;
        private static determinateCurrenciesEurUsd;
        static numToStr(numberr: number, uppercase: boolean): string;
        static numToStr2(numberr: number, uppercase: boolean, female: boolean): string;
        private static convertToWord2;
    }
}
export namespace Stimulsoft.Report.Func {
    class Fa {
        static convertToWord(numberr: number): string;
        private static changingNum;
    }
}
export namespace Stimulsoft.Report.Func {
    class Fr {
        static zeroWord: string;
        static lessWord: string;
        static triplets: string[][];
        static lessTwentys: string[];
        static tens: string[];
        static convertToWord(numberr: number, currencyISO: string, decimals: number): string;
        private static convertToWord2;
        private static calculateOver;
    }
}
export namespace Stimulsoft.Report.Func {
    class Nl {
        static zeroWord: string;
        static lessWord: string;
        static triplets: string[][];
        static lessTwenty: string[];
        static tens: string[];
        static convertToWord(numberr: number, currencyISO: string, decimals: number): string;
        private static convertToWord2;
        private static calculateOver;
    }
}
export namespace Stimulsoft.Report.Func {
    import DateTime = Stimulsoft.System.DateTime;
    class Pl {
        private static units;
        private static tens;
        private static hundreds;
        private static thousends;
        private static million;
        private static billion;
        private static trillion;
        private static quadrillion;
        private static quintillion;
        private static zloty;
        private static grosz;
        private static dollar;
        private static cent;
        private static euro;
        private static months;
        static numToStr(value: number, uppercase: boolean): string;
        private static addUnits;
        private static addTens;
        private static addHundreds;
        private static addRank;
        private static decline2;
        private static decline;
        private static currToStr2;
        static currToStr(value: number, currencyISO: string, showCents: boolean, uppercase: boolean): string;
        static dateToStr(date: DateTime, uppercase: boolean): string;
    }
}
export namespace Stimulsoft.Report.Func {
    import DateTime = Stimulsoft.System.DateTime;
    class Pt {
        private static units;
        private static tens;
        private static months;
        static numToStr(value: number, uppercase: boolean): string;
        private static addRank;
        private static addUnits;
        private static addTens;
        private static decline;
        private static decline2;
        static currToStr2(value: number, uppercase: boolean, showCents: boolean, currencyISO: string, decimals: number): string;
        static currToStr(value: number, uppercase: boolean, showCents: boolean, dollars?: string, cents?: string, decimals?: number): string;
        static dateToStr(value: DateTime): string;
    }
}
export namespace Stimulsoft.Report.Func {
    class PtBr {
        private static unid;
        private static dezena;
        private static centena;
        static numToStr(value: number, uppercase?: boolean, dollars?: string, cents?: string): string;
    }
}
export namespace Stimulsoft.Report.Func {
    import DateTime = Stimulsoft.System.DateTime;
    class Ru {
        private static currencies;
        static registerCurrency(currency: Currency, currencyName: string): void;
        private static getCurrency;
        private static months;
        private static units;
        private static tens;
        private static hundreds;
        private static gendered;
        private static addUnits;
        private static addTens;
        private static addHundreds;
        private static addThousand;
        private static addRank;
        static numToStr(value: number, uppercase?: boolean, gender?: Gender): string;
        static currToStr(value: number, uppercase?: boolean, currency?: string, cents?: boolean): string;
        static decline2(value: number, one: string, two: string, five: string): string;
        static decline(value: number, currency: string, cents?: boolean): string;
        static dateToStr(date: DateTime, uppercase?: boolean): string;
    }
}
export namespace Stimulsoft.Report.Func {
    class Thai {
        private static tC_0;
        private static tC_1;
        private static tC_2;
        private static tC_3;
        private static tC_4;
        private static tC_5;
        private static tC_6;
        private static tC_7;
        private static tC_8;
        private static tC_9;
        private static tC_01;
        private static tC_10;
        private static tC_20;
        private static tC_100;
        private static tC_1000;
        private static tC_10000;
        private static tC_100000;
        private static tC_1000000;
        private static tC_Baht;
        private static tC_Satang;
        private static tC_Complete;
        static currToStr(value: number): string;
        private static SP_XCGtNumToMny;
        private static reverseString;
    }
}
export namespace Stimulsoft.Report.Func {
    class Tr {
        static Birler: string[];
        static Onlar: string[];
        static Binler: string[];
        static numToStr(value: number): string;
        static currToStr(value: number, currencyName?: string, showZeroCents?: boolean): string;
    }
}
export namespace Stimulsoft.Report.Func {
    import DateTime = Stimulsoft.System.DateTime;
    class Ua {
        private static currencies;
        static registerCurrency(currency: Currency, currencyName: string): void;
        private static getCurrency;
        private static months;
        private static units;
        private static tens;
        private static hundreds;
        private static gendered;
        private static addUnits;
        private static addTens;
        private static addHundreds;
        private static addThousand;
        private static addRank;
        static numToStr(value: number, uppercase?: boolean, gender?: Gender): string;
        static currToStr(value: number, uppercase?: boolean, currency?: string, cents?: boolean): string;
        static decline2(value: number, one: string, two: string, five: string): string;
        static decline(value: number, currency: string, cents?: boolean): string;
        static dateToStr(date: DateTime, uppercase?: boolean): string;
    }
}
export namespace Stimulsoft.Report.Func {
    class Zh {
        private static numChineseCharacter;
        static toWordsZh(num: number): string;
        static toCurrencyWordsZh(num: number): string;
        private static floatString;
        private static numberString;
        private static convert4;
        private static convertString;
        private static convert2;
        private static convert3;
    }
}
export namespace Stimulsoft.Report {
    let IStiGlobalizationManagerList: System.Interface<IStiGlobalizationManagerList>;
    interface IStiGlobalizationManagerList {
        getTextGlobalizedNames(): string[];
        getImageGlobalizedNames(): string[];
    }
}
export namespace Stimulsoft.Report {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiGlobalizationContainer implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        cultureName: string;
        private _items;
        get items(): StiGlobalizationItemCollection;
        set items(value: StiGlobalizationItemCollection);
        getAllStringsForReport(report: StiReport): Hashtable;
        localizeReport(report: StiReport): void;
        fillItemsFromReport(report: StiReport): void;
        removeUnlocalizedItemsFromReport(report: StiReport): void;
        constructor(cultureName?: string);
    }
}
export namespace Stimulsoft.Report {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiGlobalizationContainerCollection extends CollectionBase<StiGlobalizationContainer> implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        getByName(name: string): StiGlobalizationContainer;
        setByName(name: string, value: StiGlobalizationContainer): void;
        private report;
        skipException: boolean;
        private getShortName;
        localizeReport(cultureName: string): void;
        localizeReport2(info: CultureInfo): void;
        fillItemsFromReport(): void;
        removeUnlocalizedItemsFromReport(): void;
        removeComponent(comp: StiComponent): void;
        renameComponent(comp: StiComponent, oldName: string, newName: string): void;
        constructor(report: StiReport);
    }
}
export namespace Stimulsoft.Report {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiGlobalizationItem implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        propertyName: string;
        text: string;
        toString(): string;
        constructor(propertyName?: string, text?: string);
    }
}
export namespace Stimulsoft.Report {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    class StiGlobalizationItemCollection extends CollectionBase<StiGlobalizationItem> implements IComparer<StiGlobalizationItem> {
        compare(item1: StiGlobalizationItem, item2: StiGlobalizationItem): number;
        sort(): void;
    }
}
export namespace Stimulsoft.Report.Helpers {
    import Exception = Stimulsoft.System.Exception;
    import LogStatus = Stimulsoft.System.LogStatus;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class ExceptionExt {
        static log(exception: Exception | string, obj: any, message?: string): LogStatus;
        static logEvent(exception: Exception | string, component: StiComponent, eventName: string): LogStatus;
        static logExpression(exception: Exception | string, component: StiComponent, propertyName: string): LogStatus;
        static logSeriesExpression(exception: Exception | string, component: StiComponent, series: string, propertyName: string): LogStatus;
        private static getReportFromObject;
        static init(): void;
    }
}
export namespace Stimulsoft.Report.Helpers {
    import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
    class FontVHelper {
        static isFont(type: StiResourceType): boolean;
    }
}
export namespace Stimulsoft.Report {
    class StiAbbreviationNumberFormatHelper {
        static format(value: number, reportCulture?: string): string;
        static format2(value: number, outPostfix: any, reportCulture?: string): number;
        static format3(value: number, outPostfix: any, decimalDigits: any, totalNumberCapacity: number, reportCulture?: string): number;
        static simpleAbbreviateNumber(number: number): string;
        static getPostfixes(reportCulture?: string): string[];
    }
}
export namespace Stimulsoft.Report.Helpers {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    enum StiEventType {
        BeginRender = 0,
        BeforePrint = 1
    }
    class StiAppExpressionParser {
        private static readonly BeginRenderExpressionList;
        static processExpressions(component: StiComponent, allowDataLoading?: boolean, eventType?: StiEventType): void;
        static parseBoolExpression(component: StiComponent, propName: string, allowDataLoading?: boolean): boolean;
        static parseBoolExpressionAsync(component: StiComponent, propName: string, allowDataLoading?: boolean): Promise<boolean>;
        static parseStringExpression(component: StiComponent, propName: string, allowDataLoading?: boolean): string;
        static parseColorExpression(component: StiComponent, propName: string, allowDataLoading?: boolean): Color;
        static parseBrushExpression(component: StiComponent, propName: string, allowDataLoading?: boolean): StiBrush;
        static parseFontExpression(component: StiComponent, propName: string, allowDataLoading?: boolean): Stimulsoft.System.Drawing.Font;
        static parseNumberExpression(component: StiComponent, propName: string, allowDataLoading?: boolean): number;
        private static parseExpression;
        private static parseExpressionAsync;
    }
}
export namespace Stimulsoft.Report.Helpers {
    import List = Stimulsoft.System.Collections.List;
    class StiFileDialogHelper {
        static dataExts: List<string>;
        static imageExts: List<string>;
        static reportExts: List<string>;
        static textExts: List<string>;
        static documentExts: List<string>;
        static fontExts: List<string>;
    }
}
export namespace Stimulsoft.Base.Context {
    import Font = Stimulsoft.System.Drawing.Font;
    import GraphicsUnit = Stimulsoft.System.Drawing.GraphicsUnit;
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    class StiFontGeom extends StiGeom {
        static changeFontSize(font: Font, newFontSize: number): StiFontGeom;
        fontName: string;
        fontSize: number;
        fontStyle: FontStyle;
        unit: GraphicsUnit;
        type: StiGeomType;
        static create(font: Font): StiFontGeom;
        constructor(fontName: string, fontSize: number, style: FontStyle, unit: GraphicsUnit);
    }
}
export namespace Stimulsoft.Report {
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiFontIconGroup = Stimulsoft.Report.Helpers.StiFontIconGroup;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiFontIconSet = Stimulsoft.Report.Helpers.StiFontIconSet;
    import List = Stimulsoft.System.Collections.List;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import Size = Stimulsoft.System.Drawing.Size;
    class StiFontIconsHelper {
        static convertFontIconToImage(icon: StiFontIcons, color: Color, width: number, height: number, dy?: string): Image;
        static writeFontIconImage(writer: XmlTextWriter, color: Color, icon: StiFontIcons, width: number, height: number, dy?: string, x?: number, y?: number, horAlignment?: StiHorAlignment, vertAlignment?: StiVertAlignment): void;
        static convertFontIconToImageAsync(icon: StiFontIcons, color: Color, width: number, height: number, dy?: string, horAlign?: StiHorAlignment): Promise<Image>;
        static getIconPadding(fontIcons: StiFontIcons): number[];
        static getContent(fontIcons: StiFontIcons): string;
        private static getNetContent;
        static getIsonSetContent(iconSet: StiFontIconSet): string;
        static getFontIcons(iconSet: StiFontIconSet): List<StiFontIcons>;
        static getFontIcons1(iconGroup: StiFontIconGroup): List<StiFontIcons>;
        static getIconFontSize(context: StiContext, size: Size, text: string): number;
        static drawFillIcons(context: StiContext, brush: object, rect: Rectangle, singleSize: Size, icon: StiFontIcons, toolTip: string): void;
        static drawDirectionIcons(context: StiContext, brush: object, rect: Rectangle, singleSize: Size, icon: StiFontIcons, toolTip: string, interaction: StiInteractionDataGeom, verticalDirection: boolean, roundValues?: boolean): void;
        private static getStringFormatGeom;
    }
}
export namespace Stimulsoft.Report.Helpers {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImageTransparenceHelper {
        static getTransparentedImage(source: Image, transparency: number): Image;
    }
}
export namespace Stimulsoft.Report.Helpers {
    class StiIsoCountry {
        names: string[];
        ruNames: string[];
        frNames: string[];
        alpha2: string;
        alpha3: string;
        ru(...names: string[]): StiIsoCountry;
        fr(...names: string[]): StiIsoCountry;
        iso(alpha2: string, alpha3?: string): StiIsoCountry;
        constructor(...names: string[]);
    }
}
export namespace Stimulsoft.Report.Helpers {
    class StiIsoElementHelper {
        private static _countries;
        static get countries(): StiIsoCountry[];
        private static _usStates;
        static get usStates(): StiIsoCountry[];
        private static _canadaProvinces;
        static get canadaProvinces(): StiIsoCountry[];
        private static _brazilProvinces;
        static get brazilProvinces(): StiIsoCountry[];
        static getIsoAlpha2FromName(name: string, mapId?: string): string;
        static getIsoAlpha3FromName(name: string, mapId?: string): string;
        static getCountryFromName(name: string, mapId?: string): StiIsoCountry;
        private static getCountries;
        private static isEqual;
        static getCountryFromAlpha3(alpha3: string, mapId?: string): StiIsoCountry;
        static getCountryFromAlpha2(alpha2: string, mapId?: string): StiIsoCountry;
        private static initializeCountries;
        private static initializeUsStates;
        private static initializeCanadaProvinces;
        private static initializeBrazilProvinces;
    }
}
export namespace Stimulsoft.Report.Maps.Helpers {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    class StiGssMapHelper {
        private static hash;
        static allowGss(ident: string): boolean;
        static get(id: string): Dictionary<string, string>;
        static init(id: string): void;
        static isGssValue(value: string): boolean;
        private static add;
        private static initUKCountries;
    }
}
export namespace Stimulsoft.Report.Helpers {
    import IStiReport = Stimulsoft.Base.IStiReport;
    import IStiMapKeyHelper = Stimulsoft.Base.Map.IStiMapKeyHelper;
    class StiMapKeyHelper implements IStiMapKeyHelper {
        getMapIdents(key: string): string[];
        private static getMapIdents2;
        getNameFromIsoAlpha2(alpha2: string, mapId: string, lang: string, report?: StiReport): string;
        getNameFromIsoAlpha3(alpha3: string, mapId: string, lang: string, report?: StiReport): string;
        normalizeName(name: string, mapId: string, lang: string, report?: IStiReport): string;
        getIsoAlpha2FromName(name: string, mapId: string, lang: string, report?: StiReport): string;
        getIsoAlpha3FromName(name: string, mapId: string, lang: string, report?: StiReport): string;
        convertMapKeysToIsoAlpha2(mapKeys: string[], mapId: string, lang: string, report?: StiReport): string[];
        getMapKeysFromNames(values: any[], mapId: string, lang: string, report?: StiReport): string[];
        getMapKeyFromName(name: string, mapId: string, lang: string, report?: StiReport): string;
        static simplify(key: string): string;
    }
}
export namespace Stimulsoft.Base.Maps.Geoms {
    class StiMapGeomsContainer {
        name: string;
        width: number;
        height: number;
        geoms: StiMapGeomsObject[];
    }
}
export namespace Stimulsoft.Base.Maps.Geoms {
    class StiMapGeomsObject {
        name: string;
        geoms: StiMapGeom[];
        geoms3D: StiMapGeom[];
    }
}
export namespace Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiMapGeom {
        get geomType(): StiMapGeomType;
        getLastPoint(): Point;
    }
}
export namespace Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiMoveToMapGeom extends StiMapGeom {
        get geomType(): StiMapGeomType;
        x: number;
        y: number;
        getLastPoint(): Point;
    }
}
export namespace Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiLineMapGeom extends StiMapGeom {
        get geomType(): StiMapGeomType;
        x: number;
        y: number;
        getLastPoint(): Point;
    }
}
export namespace Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiBezierMapGeom extends StiMapGeom {
        get geomType(): StiMapGeomType;
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        x3: number;
        y3: number;
        getLastPoint(): Point;
    }
}
export namespace Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiBeziersMapGeom extends StiMapGeom {
        get geomType(): StiMapGeomType;
        array: number[];
        getLastPoint(): Point;
    }
}
export namespace Stimulsoft.Base.Maps.Geoms {
    class StiCloseMapGeom extends StiMapGeom {
        get geomType(): StiMapGeomType;
    }
}
export namespace Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    import List = Stimulsoft.System.Collections.List;
    class StiMapGeomCollection extends List<StiMapGeom> {
        getLastPoint(): Point;
    }
}
export namespace Stimulsoft.Report.Maps {
    import StiMapGeom = Stimulsoft.Base.Maps.Geoms.StiMapGeom;
    import StiMapGeomsContainer = Stimulsoft.Base.Maps.Geoms.StiMapGeomsContainer;
    class StiMapLoader {
        private static hashMaps;
        static deleteAllCustomMaps(): void;
        private static finalResourceName;
        static loadResource(report: StiReport, resourceName: string, lang: string): StiMapSvgContainer;
        private static parseResourceName;
        static getGeomsObject(report: StiReport, resourceName: string, lang: string): StiMapGeomsContainer;
        private static createGeom;
        static parsePath(text: string): StiMapGeom[];
    }
}
export namespace Stimulsoft.Report.Helpers {
    import StiMapSvg = Stimulsoft.Report.Maps.StiMapSvg;
    class StiMapResourceHelper {
        static getSvgBlockFromIsoAlpha2(alpha2: string, mapId: string, lang: string, report?: StiReport): StiMapSvg;
        static getSvgBlockFromName(name: string, mapId: string, lang: string, report?: StiReport): StiMapSvg;
        static getIsoAlpha2FromName(name: string, mapId: string, lang: string, report?: StiReport): string;
        static getIsoAlpha3FromName(name: string, mapId: string, lang: string, report?: StiReport): string;
        private static getResource;
        private static decodeAlpha;
    }
}
export namespace Stimulsoft.Report.Helpers {
    import RegionInfo = Stimulsoft.System.Globalization.RegionInfo;
    class StiRegionInfoHelper {
        static getIsoAlpha2FromName(name: string): string;
        static getIsoAlpha3FromName(name: string): string;
        static getNameFromIsoAlpha2(alpha2: string): string;
        static getNameFromIsoAlpha3(alpha3: string): string;
        static getLocalizedNameFromIsoAlpha2(alpha2: string): string;
        static getLocalizedNameFromIsoAlpha3(alpha3: string): string;
        static getRegionInfoFromName(name: string): RegionInfo;
        private static getAllRegions;
    }
}
export namespace Stimulsoft.Report.Helpers {
    import StiRelationDirection = Stimulsoft.Base.StiRelationDirection;
    import DataSet = Stimulsoft.System.Data.DataSet;
    import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
    class StiResourceArrayToDataSet {
        static get(resourceType: StiResourceType, array: number[], report?: StiReport, pathData?: string, tryParseDateTime?: boolean, relationDirection?: StiRelationDirection): DataSet;
    }
}
export namespace Stimulsoft.Report.Helpers {
    import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
    class StiResourceTypeHelper {
        static getTypeFromExtension(extension: string): StiResourceType;
        static isImageType(ext: string): boolean;
        static isTextType(ext: string): boolean;
        private static isExtensionType;
    }
}
export namespace Stimulsoft.Report.Helpers {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import List = Stimulsoft.System.Collections.List;
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiStringsTableHelper {
        private static rowsCache;
        static loadDataTableFromPackedString(content: string, columns: string[]): DataTable;
        static loadDataTableFromString(content: string, columns: string[]): DataTable;
        static loadDataTableFromStringRows(rows: string[][], columns: string[]): DataTable;
        static loadStringRowsFromPackedString(content: string, columns: string[]): string[][];
        static loadColumnsAndStringRowsFromPackedString(content: string, refColumns: {
            ref: string[];
        }): string[][];
        static loadStringRowsFromString(content: string, columns: string[]): string[][];
        static loadColumnsAndStringRowsFromString(content: string, refColumns: {
            ref: string[];
        }): string[][];
        static saveDataTableToPackedString(table: DataTable): string;
        static saveDataTableToString(table: DataTable): string;
        static saveDataTableToStringRows(table: DataTable, saveHeaders?: boolean): List<string[]>;
        static loadStringRowsFromCache(element: IStiElement): string[][];
        static loadColumnsAndStringRowsFromCache(element: IStiElement, refColumns: {
            ref: string[];
        }): string[][];
        static saveDataTableToCache(element: IStiElement, table: DataTable, saveHeaders?: boolean): void;
        static saveColumnsAndStringRowsToCache(element: IStiElement, columns: string[], rows: List<string[]>): void;
        static saveStringRowsToCache(element: IStiElement, rows: List<string[]>): void;
        static removeFromCache(element: IStiElement): void;
    }
}
export namespace Stimulsoft.Report.Gauge {
    enum StiGaugeRangeMode {
        Percentage = 1,
        Value = 2
    }
    enum StiScaleMode {
        V1 = 1,
        V2 = 2
    }
    enum StiGaugeRangeType {
        None = 0,
        Color = 1
    }
    enum StiGaugeCalculationMode {
        Auto = 1,
        Custom = 2
    }
    enum StiGaugeType {
        FullCircular = 0,
        HalfCircular = 1,
        Linear = 2,
        HorizontalLinear = 3,
        Bullet = 4
    }
    enum StiPlacement {
        Outside = 0,
        Overlay = 1,
        Inside = 2
    }
    enum StiGaugeElemenType {
        LinearElement = 0,
        RadialElement = 1,
        All = 2
    }
    enum StiBarRangeListType {
        LinearBar = 0,
        RadialBar = 1
    }
    enum StiLinearRangeColorMode {
        Default = 0,
        MixedColor = 1
    }
    enum StiRadialScaleSkin {
        Default = 0,
        Empty = 1,
        RadialScaleQuarterCircleNW = 2,
        RadialScaleQuarterCircleNE = 3,
        RadialScaleQuarterCircleSW = 4,
        RadialScaleQuarterCircleSE = 5,
        RadialScaleHalfCircleN = 6,
        RadialScaleHalfCircleS = 7
    }
    enum StiMarkerSkin {
        Diamond = 0,
        Rectangle = 1,
        TriangleTop = 2,
        TriangleBottom = 3,
        PentagonTop = 4,
        PentagonBottom = 5,
        Ellipse = 6,
        RectangularCalloutTop = 7,
        RectangularCalloutBottom = 8,
        TriangleLeft = 9,
        TriangleRight = 10,
        PentagonLeft = 11,
        PentagonRight = 12,
        RectangularCalloutLeft = 13
    }
    enum StiStateSkin {
        Ellipse = 0,
        Rectangle = 1,
        Diamond = 2
    }
    enum StiLinearBarSkin {
        Default = 0,
        HorizontalThermometer = 1,
        VerticalThermometer = 2
    }
    enum StiNeedleSkin {
        DefaultNeedle = 0,
        SpeedometerNeedle = 1,
        SpeedometerNeedle2 = 2,
        SimpleNeedle = 3
    }
    enum StiTickMarkSkin {
        Rectangle = 0,
        Ellipse = 1,
        Diamond = 2,
        TriangleTop = 3,
        TriangleRight = 4,
        TriangleLeft = 5,
        TriangleBottom = 6
    }
    enum StiRadiusMode {
        Auto = 0,
        Width = 1,
        Height = 2
    }
    enum StiRadialPosition {
        TopLeft = 0,
        TopRight = 1,
        BottonLeft = 2,
        BottomRight = 3,
        TopCenter = 4,
        LeftCenter = 5,
        BottomCenter = 6,
        RightCenter = 7
    }
    enum StiLabelRotationMode {
        None = 0,
        Automatic = 1,
        SurroundIn = 2,
        SurroundOut = 3
    }
    enum StiGaugeStyleId {
        StiStyle25 = 0,
        StiStyle26 = 1,
        StiStyle27 = 2,
        StiStyle28 = 3,
        StiStyle29 = 4,
        StiStyle30 = 5
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    import List = Stimulsoft.System.Collections.List;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiGaugeCalculationMode = Stimulsoft.Report.Gauge.StiGaugeCalculationMode;
    import StiScaleMode = Stimulsoft.Report.Gauge.StiScaleMode;
    import StiGaugeType = Stimulsoft.Report.Gauge.StiGaugeType;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    let IStiGauge: System.Interface<IStiGauge>;
    interface IStiGauge extends IStiComponent {
        scales: CollectionBase<IStiScaleBase>;
        customStyleName: string;
        drawGauge(context: StiGaugeContextPainter): any;
        loadFromXml(xmlNode: XmlNode): any;
        prepareInit(): any;
        minimum: number;
        maximum: number;
        mode: StiScaleMode;
        type: StiGaugeType;
        calculationMode: StiGaugeCalculationMode;
        isAnimation: boolean;
        previousAnimations: List<StiAnimation>;
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiGaugeStyle: System.Interface<IStiGaugeStyle>;
    interface IStiGaugeStyle extends ICloneable, IStiJsonReportObject {
        core: IStiGaugeStyleCoreXF;
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
    }
}
export namespace Stimulsoft.Report.Gauge {
    import IStiGauge = Stimulsoft.Report.Components.Gauge.IStiGauge;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiGaugeStyleCoreXF: System.Interface<IStiGaugeStyleCoreXF>;
    interface IStiGaugeStyleCoreXF {
        localizedName: string;
        brush: StiBrush;
        borderColor: Color;
        borderWidth: number;
        targetColor: Color;
        foreColor: Color;
        tickMarkMajorBrush: StiBrush;
        tickMarkMajorBorder: StiBrush;
        tickMarkMajorBorderWidth: number;
        tickMarkMinorBrush: StiBrush;
        tickMarkMinorBorder: StiBrush;
        tickMarkMinorBorderWidth: number;
        tickLabelMajorTextBrush: StiBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiBrush;
        tickLabelMinorFont: Font;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        linearBarBorderBrush: StiBrush;
        linearBarEmptyBrush: StiBrush;
        linearBarEmptyBorderBrush: StiBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiBrush;
        radialBarBorderBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
        radialBarEmptyBorderBrush: StiBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
        markerSkin: StiMarkerSkin;
        markerBrush: StiBrush;
        markerBorderBrush: StiBrush;
        markerBorderWidth: number;
        styleId: StiGaugeStyleId;
        gauge: IStiGauge;
    }
}
export namespace Stimulsoft.Report.Maps.Gis {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiGisCore {
        levelsKeepInMemmory: number;
        allowLocalCache: boolean;
        position: StiGisPointLatLng;
        positionPixel: StiGisPoint;
        renderOffset: StiGisPoint;
        centerTileXYLocation: StiGisPoint;
        centerTileXYLocationLast: StiGisPoint;
        compensationOffset: StiGisPoint;
        sizeOfMapArea: StiGisSize;
        minOfTiles: StiGisSize;
        maxOfTiles: StiGisSize;
        tileRect: StiGisRect;
        matrix: StiGisTileMatrix;
        tileDrawingList: StiGisDrawTile[];
        width: number;
        height: number;
        isDragging: boolean;
        zoomToArea: boolean;
        mouseWheelZooming: boolean;
        okZoom: number;
        skipOverZoom: number;
        isStarted: boolean;
        updatingBounds: boolean;
        geometryColor: Color;
        geometryLineSize: number;
        provider: StiOpenStreetMapProvider;
        languageStr: string;
        icon: StiFontIcons;
        iconColor: Color;
        private _zoom;
        get zoom(): number;
        set zoom(value: number);
        getPosition(): StiGisPointLatLng;
        setPosition(value: StiGisPointLatLng): void;
        getProvider(): StiOpenStreetMapProvider;
        setProvider(value: StiOpenStreetMapProvider): void;
        getViewArea(): StiGisRectLatLng;
        getIconColorGdi(): Color;
        initGeometryColor(color: Color, lineSize: number): void;
        setZoomToFitRect(rect: StiGisRectLatLng): void;
        goToCurrentPositionOnZoom(): void;
        private updateCenterTileXYLocation;
        onMapSizeChanged(width: number, height: number): void;
        fromLocalToLatLng(x: number, y: number): StiGisPointLatLng;
        fromLatLngToLocal(latlng: StiGisPointLatLng): StiGisPoint;
        getMaxZoomToFitRect(rect: StiGisRectLatLng): number;
        reloadMap(): void;
        cancelAsyncTasks(): void;
        getImageFrom(provider: StiOpenStreetMapProvider, pos: StiGisPoint, zoom: number): Promise<StiGisMapImage>;
        dispose(disposing: boolean): void;
        close(): void;
    }
}
export namespace Stimulsoft.Report.Maps.Gis {
    class StiGisDrawTile {
        posXY: StiGisPoint;
        posPixel: StiGisPoint;
        distanceSqr: number;
        toString(): string;
        equals(other: StiGisDrawTile): boolean;
        clone(): StiGisDrawTile;
    }
}
export namespace Stimulsoft.Report.Maps.Gis {
    class StiGisMapHelper {
        static customOpenStreetMapUrl: string;
    }
}
export namespace Stimulsoft.Report.Maps.Gis {
    class StiGisMapImage {
        data: Uint8Array;
        image: any;
        static fromBlob(blob: Blob): Promise<StiGisMapImage>;
        private static base64ArrayBuffer;
        close(): void;
        constructor(data: Uint8Array);
    }
}
export namespace Stimulsoft.Report.Maps.Gis {
    class StiGisMapViewData {
        private core;
        geoms: StiGisPointMapGeometry[];
        placemarks: StiGisPointMapGeometry[];
        clear(): void;
        forceUpdate(): void;
        draw(): string;
        getAllPoints(): StiGisPointLatLng[];
        close(): void;
        constructor(core: StiGisCore);
    }
}
export namespace Stimulsoft.Report.Maps.Gis {
    class StiGisPoint {
        private _x;
        get x(): number;
        set x(value: number);
        private _y;
        get y(): number;
        set y(value: number);
        clone(): StiGisPoint;
        isEmpty(): boolean;
        equals(obj: any): boolean;
        hashCode(): number;
        offset(dx: number, dy: number): void;
        offset2(p: StiGisPoint): void;
        offsetNegative(p: StiGisPoint): void;
        toString(): string;
        static get empty(): StiGisPoint;
        constructor(x?: number, y?: number);
    }
}
export namespace Stimulsoft.Report.Maps.Gis {
    class StiGisPointLatLng {
        lat: number;
        lng: number;
        equals(obj: any): boolean;
        toString(): string;
        clone(): StiGisPointLatLng;
        offset(lat: number, lng: number): void;
        static empty(): StiGisPointLatLng;
        constructor(lat?: number, lng?: number);
    }
}
export namespace Stimulsoft.Report.Maps.Gis {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiGisPointMapGeometry {
        private point;
        private localPoint;
        private iconArea;
        text: string;
        showPlacemark: boolean;
        setDescription(text: string): void;
        contains(pos: Point): boolean;
        draw(core: StiGisCore): string;
        updateLocalPosition(core: StiGisCore): void;
        getAllPoints(points: any): void;
        constructor(point: StiGisPointLatLng | {
            lat: number;
            lng: number;
        });
    }
}
export namespace Stimulsoft.Report.Maps.Gis {
    abstract class StiGisProjection {
        tileSize: number;
        static HALF_PI: number;
        static TWO_PI: number;
        static EPSLoN: number;
        static MAX_VAL: number;
        static MAXLONG: number;
        static DBLLONG: number;
        static R2D: number;
        static D2R: number;
        private fromLatLngToPixelCache;
        private fromPixelToLatLngCache;
        getTileValue(): number;
        fromLatLngToPixel(lat: number, lng: number, zoom: number): StiGisPoint;
        fromPixelToLatLng(x: number, y: number, zoom: number): StiGisPointLatLng;
        fromLatLngToPixel2(p: StiGisPointLatLng, zoom: number): StiGisPoint;
        fromPixelToLatLng2(p: StiGisPoint, zoom: number): StiGisPointLatLng;
        fromPixelToTileXY(p: StiGisPoint): StiGisPoint;
        getTileMatrixSizeXY(zoom: number): StiGisSize;
        getTileMatrixSizePixel(zoom: number): StiGisSize;
        getTileMatrixMinXY(zoom: number): StiGisSize;
        getTileMatrixMaxXY(zoom: number): StiGisSize;
        static clip(n: number, minValue: number, maxValue: number): number;
        constructor();
    }
}
export namespace Stimulsoft.Report.Maps.Gis {
    class StiGisRect {
        x: number;
        y: number;
        width: number;
        height: number;
        getLocation(): StiGisPoint;
        setLocation(value: StiGisPoint): void;
        getRightBottom(): StiGisPoint;
        getRightTop(): StiGisPoint;
        getLeftBottom(): StiGisPoint;
        getSize(): StiGisSize;
        setSize(value: StiGisSize): void;
        get left(): number;
        get top(): number;
        get right(): number;
        get bottom(): number;
        isEmpty(): boolean;
        equals(obj: any): boolean;
        toString(): string;
        static opEquals(left: StiGisRect, right: StiGisRect): boolean;
        static opNotEquals(left: StiGisRect, right: StiGisRect): boolean;
        contains(x: number, y: number): boolean;
        contains2(pt: StiGisPoint): boolean;
        contains3(rect: StiGisRect): boolean;
        inflate(width: number, height: number): void;
        offsetNegative(pos: StiGisPoint): void;
        offset(x: number, y: number): void;
        static get empty(): StiGisRect;
        constructor(x?: number, y?: number, width?: number, height?: number, location?: StiGisPoint, size?: StiGisSize);
    }
}
export namespace Stimulsoft.Report.Maps.Gis {
    class StiGisRectLatLng {
        lng: number;
        lat: number;
        widthLng: number;
        heightLat: number;
        get locationTopLeft(): StiGisPointLatLng;
        set locationTopLeft(value: StiGisPointLatLng);
        get locationRightBottom(): StiGisPointLatLng;
        get locationMiddle(): StiGisPointLatLng;
        get size(): StiGisSizeLatLng;
        set size(value: StiGisSizeLatLng);
        clone(): StiGisRectLatLng;
        static fromLTRB(leftLng: number, topLat: number, rightLng: number, bottomLat: number): StiGisRectLatLng;
        equals(obj: any): boolean;
        toString(): string;
        static opEquals(left: StiGisRectLatLng, right: StiGisRectLatLng): boolean;
        static opNotEquals(left: StiGisRectLatLng, right: StiGisRectLatLng): boolean;
        contains(lat: number, lng: number): boolean;
        contains2(pt: StiGisPointLatLng): boolean;
        static get empty(): StiGisRectLatLng;
        constructor(lat?: number, lng?: number, widthLng?: number, heightLat?: number, location?: StiGisPointLatLng, size?: StiGisSizeLatLng);
    }
}
export namespace Stimulsoft.Report.Maps.Gis {
    class StiGisSize {
        width: number;
        height: number;
        isEmpty(): boolean;
        equals(obj: StiGisSize): boolean;
        clone(): StiGisSize;
        toString(): string;
        static get empty(): StiGisSize;
        constructor(width?: number, height?: number);
    }
}
export namespace Stimulsoft.Report.Maps.Gis {
    class StiGisSizeLatLng {
        widthLng: number;
        heightLat: number;
        isEmpty(): boolean;
        static opEquals(sz1: StiGisSizeLatLng, sz2: StiGisSizeLatLng): boolean;
        static opNotEquals(sz1: StiGisSizeLatLng, sz2: StiGisSizeLatLng): boolean;
        static toStiGisPointLatLng(size: StiGisSizeLatLng): StiGisPointLatLng;
        equals(obj: any): boolean;
        toString(): string;
        static get empty(): StiGisSizeLatLng;
        constructor(heightLat?: number, widthLng?: number);
    }
}
export namespace Stimulsoft.Report.Maps.Gis {
    class StiGisTile {
        notEmpty: boolean;
        image: StiGisMapImage;
        zoom: number;
        pos: StiGisPoint;
        equals(obj: any): boolean;
        dispose(): void;
        static opEquals(m1: StiGisTile, m2: StiGisTile): boolean;
        static opNotEquals(m1: StiGisTile, m2: StiGisTile): boolean;
        clone(): StiGisTile;
        constructor(zoom?: number, pos?: StiGisPoint);
        static empty(): StiGisTile;
    }
}
export namespace Stimulsoft.Report.Maps.Gis {
    class StiGisTileMatrix {
        private layers;
        protected finalize(): void;
        clearAllLevels(): void;
        clearLevelsBelove(zoom: number): void;
        clearLevelsAbove(zoom: number): void;
        contains(zoom: number, p: StiGisPoint): boolean;
        get(zoom: number, p: StiGisPoint): StiGisTile;
        set(t: StiGisTile): void;
        dispose(disposing: boolean): void;
        close(): void;
        constructor();
    }
}
export namespace Stimulsoft.Report.Maps.Gis {
    class StiMercatorGisProjection extends StiGisProjection {
        static instance(): StiMercatorGisProjection;
        private static MinLatitude;
        private static MaxLatitude;
        private static MinLongitude;
        private static MaxLongitude;
        getBounds(): StiGisRectLatLng;
        getAxis(): number;
        getFlattening(): number;
        fromLatLngToPixel(lat: number, lng: number, zoom: number): StiGisPoint;
        fromPixelToLatLng(x: number, y: number, zoom: number): StiGisPointLatLng;
        getTileMatrixMinXY(zoom: number): StiGisSize;
        getTileMatrixMaxXY(zoom: number): StiGisSize;
        private clip;
    }
}
export namespace Stimulsoft.Report.Maps.Gis {
    class StiOpenStreetMapProvider {
        private static urlFormatEn;
        static ServerLetters: string;
        languageStr: string;
        area: StiGisRectLatLng | null;
        static timeoutMs: number;
        refererUrl: string;
        copyright: string;
        isInitialized: boolean;
        getMaxZoom(): number;
        getMinZoom(): number;
        getTileImageUsingHttp(urlStr: string): Promise<StiGisMapImage>;
        static getServerNum(pos: StiGisPoint, max: number): number;
        getProjection(): StiMercatorGisProjection;
        getTileImage(pos: StiGisPoint, zoom: number): Promise<StiGisMapImage>;
        private makeTileImageUrl;
        constructor();
    }
}
export namespace Stimulsoft.Report.Maps {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiMapSvgContainer {
        isNotCorrect: boolean;
        isCustom: boolean;
        name: string;
        width: number;
        height: number;
        textScale: number;
        paths: StiMapSvg[];
        hashPaths: Hashtable<string, StiMapSvg>;
        icon: string;
        prepare(): void;
    }
}
export namespace Stimulsoft.Report.Maps {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap21StyleFX extends StiMapStyleFX {
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get individualColor(): Color;
        set individualColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        constructor();
    }
}
export namespace Stimulsoft.Report.Painters {
    import List = Stimulsoft.System.Collections.List;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Image = Stimulsoft.System.Drawing.Image;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    let IStiBarCodePainter: System.Interface<IStiBarCodePainter>;
    interface IStiBarCodePainter {
        baseTransform(context: any, x: number, y: number, angle: number, dx: number, dy: number): any;
        baseRollbackTransform(context: any): any;
        baseFillRectangle(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): any;
        baseFillRectangle2D(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): any;
        baseFillPolygon(context: any, brush: StiBrush, points: PointD[]): any;
        baseFillPolygons(context: any, brush: StiBrush, points: List<List<PointD>>): any;
        baseFillEllipse(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): any;
        baseDrawRectangle(context: any, penColor: Color, penSize: number, x: number, y: number, width: number, height: number): any;
        baseDrawImage(context: any, image: Image, report: StiReport, x: number, y: number, width: number, height: number): any;
        baseDrawString(context: any, st: string, font: Font, brush: StiBrush, rect: RectangleD, sf: StringFormat): any;
        baseMeasureString(context: any, st: string, font: Font): SizeD;
    }
}
export namespace Stimulsoft.Report.Painters {
    let IStiPagePainter: System.Interface<IStiPagePainter>;
    interface IStiPagePainter {
    }
}
export namespace Stimulsoft.Report.Painters {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import SolidBrush = Stimulsoft.System.Drawing.SolidBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import Brush = Stimulsoft.System.Drawing.Brush;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiMapStyle = Stimulsoft.Report.Styles.StiMapStyle;
    import StiMapData = Stimulsoft.Report.Maps.StiMapData;
    import StiMap = Stimulsoft.Report.Maps.StiMap;
    class StiStyleColorsContainer {
        private stackColors;
        private index;
        private painter;
        getColor(index: number, count: number): Brush;
        getColor1(index: number, count: number): StiSolidBrush;
        getColors(seriesCount: number): Color[];
        init(map: StiMap, painter: StiGdiMapContextPainter): void;
    }
    class HeatmapInfo {
        private painter;
        private min;
        private max;
        private color;
        private zeroColor;
        private mode;
        getColor(data: StiMapData): Color;
        getBrush(data: StiMapData): Brush;
        getBrush1(data: StiMapData): StiBrush;
        constructor(painter: StiGdiMapContextPainter, map: StiMap, mapData: StiMapData[]);
    }
    class HeatmapWithGroupInfo {
        private painter;
        private hash;
        private hashColors;
        private zeroColor;
        private mode;
        getColor(data: StiMapData): Color;
        getBrush(data: StiMapData): Brush;
        getBrush1(data: StiMapData): Brush;
        constructor(painter: StiGdiMapContextPainter, map: StiMap, mapData: StiMapData[]);
    }
    class NoneInfo {
        constructor();
        private colors;
        private index;
        getBrush(): StiSolidBrush;
    }
    export class StiGdiMapContextPainter {
        individualStep: number;
        map: StiMap;
        defaultBrush: SolidBrush;
        defaultBrush1: StiSolidBrush;
        heatmapInfo: HeatmapInfo;
        heatmapWithGroupInfo: HeatmapWithGroupInfo;
        noneInfo: NoneInfo;
        hashGroup: any;
        colorsContainer: StiStyleColorsContainer;
        private cacheDataColumns;
        mapData: StiMapData[];
        mapStyle: StiMapStyle;
        dataTable: StiDataTable;
        dontConnectToData: boolean;
        getValues(meter: IStiMeter): any[];
        private getCacheName;
        prepareDataColumns(): void;
        private applyColumns;
        getGeomBrush(data: StiMapData, is3D?: boolean): Brush;
        updateHeatmapWithGroup(): void;
        updateGroupedData(): void;
        private fillGroupColors;
        parseHexColor(color: string): Color;
        constructor(map: StiMap);
    }
    export {};
}
export namespace Stimulsoft.Report.Painters {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiContainerPainter extends StiComponentPainter {
        paintComponents(container: StiContainer, g: Graphics): void;
        paint(component: StiComponent, g: Graphics): void;
    }
}
export namespace Stimulsoft.Report.Painters {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiViewPainter extends StiComponentPainter {
        getImage(component: Stimulsoft.Report.Components.StiComponent, REFzoom: any, format: StiExportFormat): Image;
    }
}
export namespace Stimulsoft.Report.Painters {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImagePainter extends StiViewPainter {
        getImage(component: Stimulsoft.Report.Components.StiComponent, REFzoom: any, format: StiExportFormat): Image;
    }
}
export namespace Stimulsoft.Report.Painters {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    class StiPagePainter extends StiContainerPainter implements IStiPagePainter {
        implements(): any[];
        paint(comp: StiComponent, g: Graphics): void;
    }
}
export namespace Stimulsoft.Report.Painters {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiText = Stimulsoft.Report.Components.StiText;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTextinCellsPainter {
        paintText(textComp: StiText, g: Graphics, rect: RectangleD): void;
        paintBackground(textComp: StiText, g: Graphics, rect: RectangleD): void;
        paintBorder(component: StiComponent, g: Graphics, rect: RectangleD, zoom: number, drawBorderFormatting: boolean, drawTopmostBorderSides: boolean): void;
    }
}
export namespace Stimulsoft.Report.Painters {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiText = Stimulsoft.Report.Components.StiText;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTextPainter extends StiComponentPainter {
        paintText(textComp: StiText, g: Graphics, rect: RectangleD): void;
        paintBackground(text: StiText, g: Graphics, rect: RectangleD): void;
        paintBorder(component: StiComponent, g: Graphics, rect: RectangleD, zoom: number, drawBorderFormatting: boolean, drawTopmostBorderSides: boolean): void;
        paint(component: StiComponent, g: Graphics): void;
    }
}
export namespace Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiPointAnimation extends StiAnimation {
        pointFrom: Point;
        type: StiAnimationType;
        constructor(pointFrom: Point, duration: TimeSpan, beginTime: TimeSpan);
    }
}
export namespace Stimulsoft.Base.Context {
    class StiContextOptions {
        get isPrinting(): boolean;
        private _isWpf;
        get isWpf(): boolean;
        private _isGdi;
        get isGdi(): boolean;
        private _zoom;
        get zoom(): number;
        constructor(isGdi: boolean, isWpf: boolean, isPrinting: boolean, zoom: number);
    }
}
export namespace Stimulsoft.Base.Context {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiPenGeom extends StiGeom {
        brush: Color | StiBrush;
        thickness: number;
        penStyle: Stimulsoft.Base.Drawing.StiPenStyle;
        alignment: StiPenAlignment;
        startCap: StiPenLineCap;
        endCap: StiPenLineCap;
        type: StiGeomType;
        constructor(brush: any, thickness?: number);
    }
}
export namespace Stimulsoft.Base.Context {
    class StiPopSmothingModeGeom extends StiGeom {
        type: StiGeomType;
    }
}
export namespace Stimulsoft.Base.Context {
    class StiPopTextRenderingHintGeom extends StiGeom {
        type: StiGeomType;
    }
}
export namespace Stimulsoft.Base.Context {
    class StiPushSmothingModeToAntiAliasGeom extends StiGeom {
        type: StiGeomType;
    }
}
export namespace Stimulsoft.Base.Context {
    class StiPushTextRenderingHintToAntiAliasGeom extends StiGeom {
        type: StiGeomType;
    }
}
export namespace Stimulsoft.Base.Context {
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import HotkeyPrefix = Stimulsoft.System.Drawing.Text.HotkeyPrefix;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
    import StringFormatFlags = Stimulsoft.System.Drawing.StringFormatFlags;
    class StiStringFormatGeom extends StiGeom {
        isGeneric: boolean;
        alignment: StringAlignment;
        formatFlags: StringFormatFlags;
        hotkeyPrefix: HotkeyPrefix;
        lineAlignment: StringAlignment;
        trimming: StringTrimming;
        type: StiGeomType;
        constructor(sf: StringFormat);
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    let IStiGaugeMarker: System.Interface<IStiGaugeMarker>;
    interface IStiGaugeMarker {
        showValue: boolean;
        textBrush: StiBrush;
        font: Font;
        format: string;
    }
}
export namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    class StiGraphicsPathCloseFigureGaugeGeom extends StiGaugeGeom {
        get type(): StiGaugeGeomType;
    }
}
export namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiGraphicsPathGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly startPoint: Point;
        get type(): StiGaugeGeomType;
        private _geoms;
        get geoms(): StiGaugeGeom[];
        addGraphicsPathArcGaugeGeom(x: number, y: number, width: number, height: number, startAngle: number, sweepAngle: number): void;
        addGraphicsPathCloseFigureGaugeGeom(): void;
        addGraphicsPathLinesGaugeGeom(points: Point[]): void;
        addGraphicsPathLineGaugeGeom(p1: Point, p2: Point): void;
        constructor(rect: Rectangle, startPoint: Point, background: StiBrush, borderBrush: StiBrush, borderWidth: number);
    }
}
export namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiGraphicsPathLineGaugeGeom extends StiGaugeGeom {
        readonly p1: Point;
        readonly p2: Point;
        get type(): StiGaugeGeomType;
        constructor(p1: Point, p2: Point);
    }
}
export namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiGraphicsPathLinesGaugeGeom extends StiGaugeGeom {
        readonly points: Point[];
        get type(): StiGaugeGeomType;
        constructor(points: Point[]);
    }
}
export namespace Stimulsoft.Base.Context {
    class StiInteractionDataGeom {
        componentName: string;
        pageGuid: string;
        componentIndex: string;
        pageIndex: string;
        elementIndex: string;
        interactionToolTip: string;
        interactionHyperlink: string;
        interactionData: StiInteractionData;
    }
}
export namespace Stimulsoft.Base.Maps.Geoms {
    enum StiMapGeomType {
        MoveTo = 0,
        Line = 1,
        Bezier = 2,
        Beziers = 3,
        Close = 4
    }
}
export namespace Stimulsoft.Report.Resources {
    class RobotoFont {
        static getContent(): number[];
        static getFont(): any;
    }
}
export namespace Stimulsoft.Report.Resources {
    class StimulsoftFont {
        static getContent(): number[];
        static getBase64Content(): string;
        static getFont(): any;
    }
}
export namespace Stimulsoft.Report.Styles {
    let IStiBaseStyle: System.Interface<IStiBaseStyle>;
    interface IStiBaseStyle {
        name: string;
    }
}
export namespace Stimulsoft.Report {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import IStiTitleStyle = Stimulsoft.Report.Styles.IStiTitleStyle;
    import IStiFontStyle = Stimulsoft.Report.Styles.IStiFontStyle;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGaugeStyle extends StiBaseStyle implements IStiTitleStyle, IStiFontStyle, IStiGetFonts, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        brush: StiBrush;
        borderColor: Color;
        targetColor: Color;
        borderWidth: number;
        foreColor: Color;
        tickMarkMajorBrush: StiBrush;
        tickMarkMajorBorder: StiBrush;
        tickMarkMajorBorderWidth: number;
        tickMarkMinorBrush: StiBrush;
        tickMarkMinorBorder: StiBrush;
        tickMarkMinorBorderWidth: number;
        tickLabelMajorTextBrush: StiBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiBrush;
        linearBarBrush: StiBrush;
        linearBarBorderBrush: StiBrush;
        linearBarEmptyBrush: StiBrush;
        linearBarEmptyBorderBrush: StiBrush;
        linearScaleBrush: StiBrush;
        radialBarBrush: StiBrush;
        radialBarBorderBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
        radialBarEmptyBorderBrush: StiBrush;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleBorderWidth: number;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        getFonts(): Font[];
        allowUseFont: boolean;
        font: Font;
        allowUseTitle: boolean;
        titleForeColor: Color;
        titleBackColor: Color;
        titleFont: Font;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
export namespace Stimulsoft.Report.Styles {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiHeatmapStyleData implements IStiJsonReportObject, ICloneable {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        color: Color;
        zeroColor: Color;
        mode: StiHeatmapFillMode;
        constructor(color?: Color, zeroColor?: Color, mode?: StiHeatmapFillMode);
    }
}
export namespace Stimulsoft.Report.Styles {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiHeatmapWithGroupStyleData implements IStiJsonReportObject, ICloneable {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        private defaultColors;
        colors: Color[];
        zeroColor: Color;
        mode: StiHeatmapFillMode;
        constructor(colors?: Color[], zeroColor?: Color, mode?: StiHeatmapFillMode);
    }
}
export namespace Stimulsoft.Report {
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import IStiFontStyle = Stimulsoft.Report.Styles.IStiFontStyle;
    import IStiTitleStyle = Stimulsoft.Report.Styles.IStiTitleStyle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiIndicatorStyle extends StiBaseStyle implements IStiTitleStyle, IStiFontStyle, IStiGetFonts, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        backColor: Color;
        glyphColor: Color;
        foreColor: Color;
        hotBackColor: Color;
        hotForeColor: Color;
        positiveColor: Color;
        negativeColor: Color;
        toolTipBrush: StiBrush;
        toolTipTextBrush: StiBrush;
        toolTipCornerRadius: StiCornerRadius;
        toolTipBorder: StiSimpleBorder;
        getFonts(): Font[];
        allowUseFont: boolean;
        font: Font;
        allowUseTitle: boolean;
        titleForeColor: Color;
        titleBackColor: Color;
        titleFont: Font;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
export namespace Stimulsoft.Report {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import IStiFontStyle = Stimulsoft.Report.Styles.IStiFontStyle;
    import IStiTitleStyle = Stimulsoft.Report.Styles.IStiTitleStyle;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    class StiProgressStyle extends StiBaseStyle implements IStiTitleStyle, IStiFontStyle, IStiGetFonts, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        foreColor: Color;
        backColor: Color;
        toolTipBrush: StiBrush;
        toolTipTextBrush: StiBrush;
        toolTipCornerRadius: StiCornerRadius;
        toolTipBorder: StiSimpleBorder;
        getFonts(): Font[];
        allowUseFont: boolean;
        font: Font;
        allowUseTitle: boolean;
        titleForeColor: Color;
        titleBackColor: Color;
        titleFont: Font;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
export namespace Stimulsoft.Report {
    import StiNestedFactor = Stimulsoft.Report.StiNestedFactor;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStylesCreator {
        private report;
        showReportTitles: boolean;
        showReportSummaries: boolean;
        showPageHeaders: boolean;
        showPageFooters: boolean;
        showGroupHeaders: boolean;
        showGroupFooters: boolean;
        showHeaders: boolean;
        showDatas: boolean;
        showFooters: boolean;
        showBorders: boolean;
        private get colorFactor();
        maxNestedLevel: number;
        nestedFactor: StiNestedFactor;
        createStyles(collectionName: string, baseColor: Color): StiBaseStyle[];
        private createStyles1;
        private createStyles2;
        private createStyle;
        private getStyleName;
        constructor(report: StiReport);
    }
}
export namespace Stimulsoft.Report.Styles {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBorderSides = Stimulsoft.Base.Drawing.StiBorderSides;
    class StiStylesHelper {
        static getBorderSidesFromLocation(component: StiComponent): StiBorderSides;
        static changeComponentStyleName(comp: StiComponent, oldName: string, newName: string): void;
        private static changeDataBandStyleName;
        private static changeElementStyleName;
        private static changeChartStyleName;
        private static changeGaugeStyleName;
    }
}
export namespace Stimulsoft.Report.Styles {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import ContentAlignment = Stimulsoft.System.Drawing.ContentAlignment;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiWatermarkStyle extends StiBaseStyle {
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        textEnabled: boolean;
        textRightToLeft: boolean;
        textShowBehind: boolean;
        text: string;
        textBrush: StiBrush;
        textFont: Font;
        private _textAngle;
        get textAngle(): number;
        set textAngle(value: number);
        imageEnabled: boolean;
        get image(): System.Drawing.Image;
        set image(value: System.Drawing.Image);
        private imageBytes_;
        get imageBytes(): number[];
        set imageBytes(value: number[]);
        imageMultipleFactor: number;
        private _imageTransparency;
        get imageTransparency(): number;
        set imageTransparency(value: number);
        imageAlignment: ContentAlignment;
        imageTiling: boolean;
        imageStretch: boolean;
        imageShowBehind: boolean;
        imageAspectRatio: boolean;
        weaveEnabled: boolean;
        weaveMajorIcon: StiFontIcons;
        private weaveMajorSize_;
        get weaveMajorSize(): number;
        set weaveMajorSize(value: number);
        weaveMajorColor: Color;
        weaveMinorIcon: StiFontIcons;
        private weaveMinorSize_;
        get weaveMinorSize(): number;
        set weaveMinorSize(value: number);
        weaveMinorColor: Color;
        private weaveAngle_;
        get weaveAngle(): number;
        set weaveAngle(value: number);
        private weaveDistance_;
        get weaveDistance(): number;
        set weaveDistance(value: number);
        private existImage;
        private takeImage;
        private takeGdiImage;
        putImage(image: System.Drawing.Image): void;
        putImage2(image: number[]): void;
        resetImage(): void;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
export namespace Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionElement {
    }
}
export namespace Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionComponentNameElement extends StiStyleConditionElement {
        private _operationComponentName;
        get operationComponentName(): StiStyleConditionOperation;
        set operationComponentName(value: StiStyleConditionOperation);
        private _componentName;
        get componentName(): string;
        set componentName(value: string);
        constructor(componentName: string, operationComponentName?: StiStyleConditionOperation);
    }
}
export namespace Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionComponentTypeElement extends StiStyleConditionElement {
        private _componentType;
        get componentType(): StiStyleComponentType;
        set componentType(value: StiStyleComponentType);
        private _operationComponentType;
        get operationComponentType(): StiStyleConditionOperation;
        set operationComponentType(value: StiStyleConditionOperation);
        constructor(componentType: StiStyleComponentType, operationComponentType?: StiStyleConditionOperation);
    }
}
export namespace Stimulsoft.Report.Styles.Conditions {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiStyleConditionElement = Stimulsoft.Report.Styles.Conditions.Elements.StiStyleConditionElement;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiStyleCondition implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiStyleCondition;
        private _type;
        get type(): StiStyleConditionType;
        set type(value: StiStyleConditionType);
        private _operationPlacement;
        get operationPlacement(): StiStyleConditionOperation;
        set operationPlacement(value: StiStyleConditionOperation);
        private _operationPlacementNestedLevel;
        get operationPlacementNestedLevel(): StiStyleConditionOperation;
        set operationPlacementNestedLevel(value: StiStyleConditionOperation);
        private _operationComponentType;
        get operationComponentType(): StiStyleConditionOperation;
        set operationComponentType(value: StiStyleConditionOperation);
        private _operationLocation;
        get operationLocation(): StiStyleConditionOperation;
        set operationLocation(value: StiStyleConditionOperation);
        private _operationComponentName;
        get operationComponentName(): StiStyleConditionOperation;
        set operationComponentName(value: StiStyleConditionOperation);
        private _placement;
        get placement(): StiStyleComponentPlacement;
        set placement(value: StiStyleComponentPlacement);
        private _placementNestedLevel;
        get placementNestedLevel(): number;
        set placementNestedLevel(value: number);
        private _componentType;
        get componentType(): StiStyleComponentType;
        set componentType(value: StiStyleComponentType);
        private _location;
        get location(): StiStyleLocation;
        set location(value: StiStyleLocation);
        private _componentName;
        get componentName(): string;
        set componentName(value: string);
        fromElements(elements: StiStyleConditionElement[]): void;
        constructor(type?: StiStyleConditionElement[] | StiStyleConditionType, operationPlacement?: StiStyleConditionOperation, operationPlacementNestedLevel?: StiStyleConditionOperation, operationComponentType?: StiStyleConditionOperation, operationLocation?: StiStyleConditionOperation, operationComponentName?: StiStyleConditionOperation, placement?: StiStyleComponentPlacement, placementNestedLevel?: number, componentType?: StiStyleComponentType, location?: StiStyleLocation, componentName?: string);
    }
}
export namespace Stimulsoft.Report {
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    class StiStyleConditionHelper {
        static isAllowStyle(component: Stimulsoft.Report.Components.StiComponent, style: StiBaseStyle): boolean;
    }
}
export namespace Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionLocationElement extends StiStyleConditionElement {
        private _operationLocation;
        get operationLocation(): StiStyleConditionOperation;
        set operationLocation(value: StiStyleConditionOperation);
        private _location;
        get location(): StiStyleLocation;
        set location(value: StiStyleLocation);
        constructor(location: StiStyleLocation, operationLocation?: StiStyleConditionOperation);
    }
}
export namespace Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionPlacementElement extends StiStyleConditionElement {
        private _placement;
        get placement(): StiStyleComponentPlacement;
        set placement(value: StiStyleComponentPlacement);
        private _operationPlacement;
        get operationPlacement(): StiStyleConditionOperation;
        set operationPlacement(value: StiStyleConditionOperation);
        constructor(placement: StiStyleComponentPlacement, operationPlacement?: StiStyleConditionOperation);
    }
}
export namespace Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionPlacementNestedLevelElement extends StiStyleConditionElement {
        private _placementNestedLevel;
        get placementNestedLevel(): number;
        set placementNestedLevel(value: number);
        private _operationPlacementNestedLevel;
        get operationPlacementNestedLevel(): StiStyleConditionOperation;
        set operationPlacementNestedLevel(value: StiStyleConditionOperation);
        constructor(placementNestedLevel: number, operationPlacementNestedLevel?: StiStyleConditionOperation);
    }
}
export namespace Stimulsoft.Report.Units {
    class StiInchesUnit extends StiUnit {
        get rulerStep(): number;
        get factor(): number;
        get shortName(): string;
        get name(): string;
        convertToHInches(value: number): number;
        convertFromHInches(value: number): number;
    }
}
export namespace Stimulsoft.Report.Viewer {
    enum StiPreviewSettings {
        All = 268435455,
        None = 0,
        PageViewMode = 1,
        VertScrollBar = 2,
        HorScrollBar = 4,
        StatusBar = 8,
        Print = 16,
        Open = 32,
        Save = 64,
        Parameters = 128,
        SendEMail = 256,
        PageNew = 512,
        PageDelete = 1024,
        PageDesign = 2048,
        PageSize = 4096,
        Resources = 8192,
        Editor = 65536,
        Find = 131072,
        Zoom = 262144,
        PageControl = 524288,
        Bookmarks = 1048576,
        Thumbs = 2097152,
        ContextMenu = 4194304,
        Close = 8388608,
        Toolbar = 16777216,
        Signature = 33554432,
        Help = 67108864,
        Default = 260039167
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiOdsExportService extends StiExportService implements IStiOdsExportService {
        implements(): any[];
        get defaultExtension(): string;
        get exportFormat(): StiExportFormat;
        get groupCategory(): string;
        get position(): number;
        get exportNameInMenu(): string;
        multipleFiles: boolean;
        getFilter(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private report;
        private matrix;
        private imageCache;
        private cellStyleList;
        private dataStyleList;
        private sheetNameList;
        private matrixList;
        private firstPageIndexList;
        private minRowList;
        private maxRowList;
        private cellStyleTableList;
        private imageQuality;
        private imageResolution;
        private currentCulture;
        private xmlIndentation;
        private doubleToString;
        private getColumnName;
        private getColorString;
        private getCellStyleNumber;
        private getStringFromBorder;
        private getDataStyleNumber;
        private writeMimetype;
        private writeMeta;
        private writeManifest;
        private writeImage;
        private writeSettings;
        private writeStyles;
        private writeContent;
        private writeDateTimeFormatString;
        private writeTableFromMatrix;
        exportOds(report: StiReport, stream: MemoryStream, settings: StiOdsExportSettings): void;
    }
}
export namespace Stimulsoft.Report.Export {
    import StiOdtExportSettings = Stimulsoft.Report.Export.StiOdtExportSettings;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiOdtExportService extends StiExportService implements IStiOdtExportService {
        implements(): any[];
        get defaultExtension(): string;
        get exportFormat(): StiExportFormat;
        get groupCategory(): string;
        get position(): number;
        get exportNameInMenu(): string;
        multipleFiles: boolean;
        getFilter(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private report;
        matrix: StiMatrix;
        removeEmptySpaceAtBottom: boolean;
        private imageCache;
        private cellStyleList;
        private paragraphStyleList;
        private xmlIndentation;
        private imageQuality;
        private imageResolution;
        private usePageHeadersAndFooters;
        private doubleToString;
        private getColumnName;
        private getColorString;
        private getCellStyleNumber;
        private getStringFromBorder;
        private getParagraphStyleNumber;
        private writeMimetype;
        private writeMeta;
        private writeManifest;
        private writeImage;
        private writeSettings;
        private writeStyles;
        private writeContent;
        exportOdt(report: StiReport, stream: MemoryStream, settings: StiOdtExportSettings): void;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiRtfExportService extends StiExportService implements IStiRtfExportService {
        implements(): any[];
        get defaultExtension(): string;
        get exportFormat(): StiExportFormat;
        get groupCategory(): string;
        get position(): number;
        get exportNameInMenu(): string;
        getFilter(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        multipleFiles: boolean;
        private getColorNumberInt;
        private getColorNumber;
        private getFontNumber;
        private getFontNumber2;
        private getCharsetIndex;
        private getFontNumber3;
        private getStyleNumber;
        private getLineStyle;
        private report;
        private sw;
        private colorList;
        private fontList;
        private styleList;
        private unicodeMapArray;
        private codePageToFont;
        private charsetCount;
        private fontToCodePages;
        private baseFontNumber;
        private sw2;
        private usePageHeadersAndFooters;
        private imageResolution;
        private imageQuality;
        private imageFormat;
        private imageCodec;
        private useStyles;
        private bookmarkList;
        private usedBookmarks;
        private removeEmptySpaceAtBottom;
        private hiToTwips;
        private frameCorrectValue;
        private pageHeight;
        private pageWidth;
        private matrix;
        private convertStringToBookmark;
        private compareExcellSheetNames;
        private convertTextWithHtmlTagsToRtfText;
        private static getLineHeightInTwips;
        private replacePardInRtf;
        private getImageString;
        private drawLine;
        private fillRect;
        private checkShape1;
        private renderShape1;
        private checkShape2;
        private renderShape2;
        private checkArabic;
        private unicodeToRtfString;
        private deleteToken;
        private getRtfString;
        private static parseHexTwoCharToInt;
        private static parseHexCharToInt;
        private makeHorAlignString;
        private getRtfStyleFromComponent;
        private renderStartDoc;
        private renderEndDoc;
        private renderPageHeader;
        private renderPageFooter;
        private renderTextAngle1;
        private renderTextAngle2;
        private renderHorAlign12;
        private renderVerAlign2;
        private renderBorder1;
        private renderBorder2;
        private renderBorder2Table;
        private renderBorder2TableGetValues;
        private renderBrush1;
        private renderBrush2;
        private renderTextBrush12;
        private renderTextFont12;
        private renderText12;
        private renderImage12;
        private renderRtf12;
        private renderImage3;
        private renderRtf3;
        private renderText3;
        private renderTextFont3;
        private renderTextBrush3;
        private renderBrush3;
        private renderBorder3;
        private renderStyle12;
        private writeFromMatrix;
        private exportRtf2;
        private exportRtf;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiTxtExportService extends StiExportService implements IStiTxtExportService {
        implements(): any[];
        get defaultExtension(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        get exportFormat(): StiExportFormat;
        get groupCategory(): string;
        get position(): number;
        get exportNameInMenu(): string;
        getFilter(): string;
        multipleFiles: boolean;
        private borderCodes;
        private firstEscapeCodeIndex;
        private ltrMark;
        private report;
        private needVerticalBorders;
        private needHorizontalBorders;
        private useFullTextBoxWidth;
        private useFullVerticalBorder;
        private useFullHorizontalBorder;
        private useEscapeCodes;
        private styleList;
        private escapeCodesList;
        private getBorderChar;
        private lineFill;
        private lineFillChar;
        private checkWordWrap;
        private checkGrow;
        private addCharsToLine;
        private getStyleNumber;
        private getEscapeNumber;
        private getEscapeNames;
        exportTxt(report: StiReport, stream: MemoryStream, settings: StiTxtExportSettings): void;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiXpsExportService extends StiExportService implements IStiXpsExportService {
        defaultExtension: string;
        get exportFormat(): StiExportFormat;
        groupCategory: string;
        position: number;
        exportNameInMenu: string;
        multipleFiles: boolean;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        getFilter(): string;
        private hiToDpi;
        private report;
        private fileName;
        private imageCache;
        private pageImages;
        private pageFonts;
        private pageBookmarks;
        private indexPage;
        private xmlIndentation;
        private pdfFont;
        private precision_digits;
        private reduceFontSize;
        private useImageComparer;
        private imageQuality;
        private imageResolution;
        private fontCorrectValue;
        private exportRtfTextAsImage;
        private isWordWrapSymbol;
        private isWordWrapSymbol2;
        private floatToString;
        private prepareData;
        private getTabsSize;
        private static convertToEscapeSequence;
        private getLineStyleDash;
        private checkGraphicsForTextRenderer;
        private writeContentTypes;
        private writeMainRels;
        private writeDocPropsCore;
        private writeFixedDocSeq;
        private writeFixedDoc;
        private writePage;
        private writeBorderFill;
        private writeBorderStroke;
        private writeBorderSide;
        private writeHyperlinksData;
        private writeText;
        private writeImage;
        private writeWatermark;
        private writePageRels;
        private writeResourceImage;
        private writeRecourceFont;
        exportXps(report: StiReport, stream: MemoryStream, settings: StiXpsExportSettings): void;
    }
}
export namespace Stimulsoft.Report.Export {
    import StiExportService = Stimulsoft.Report.Export.StiExportService;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiCsvExportService extends StiExportService implements IStiCsvExportService {
        implements(): any[];
        private writer;
        get defaultExtension(): string;
        get exportFormat(): StiExportFormat;
        get groupCategory(): string;
        get position(): number;
        get exportNameInMenu(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        multipleFiles: boolean;
        get getFilter(): string;
        private compareExcellSheetNames;
        exportCsv(report: StiReport, stream: MemoryStream, settings: StiDataExportSettings): void;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiDataExportService extends StiExportService implements IStiDataExportService {
        implements(): any[];
        get defaultExtension(): string;
        get exportFormat(): StiExportFormat;
        get groupCategory(): string;
        get position(): number;
        get exportNameInMenu(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private exportSettings;
        multipleFiles: boolean;
        getFilter(): string;
        exportData(report: StiReport, stream: MemoryStream, settings: StiDataExportSettings): void;
    }
}
export namespace Stimulsoft.Report.Export {
    import StiExportService = Stimulsoft.Report.Export.StiExportService;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiDbfExportService extends StiExportService implements IStiDbfExportService {
        implements(): any[];
        private writer2;
        private separator;
        get defaultExtension(): string;
        get exportFormat(): StiExportFormat;
        get groupCategory(): string;
        get position(): number;
        get exportNameInMenu(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        multipleFiles: boolean;
        get getFilter(): string;
        private static copePageNames;
        private static codePageCodes;
        private prepareData;
        private getBytes;
        exportDbf(report: StiReport, stream: MemoryStream, settings: StiDataExportSettings): void;
    }
}
export namespace Stimulsoft.Report.Export {
    import StiExportService = Stimulsoft.Report.Export.StiExportService;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiDifExportService extends StiExportService implements IStiDifExportService {
        implements(): any[];
        private writer;
        get defaultExtension(): string;
        get exportFormat(): StiExportFormat;
        get groupCategory(): string;
        get position(): number;
        get exportNameInMenu(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportDif(report: StiReport, stream: MemoryStream, settings: StiDataExportSettings): void;
    }
}
export namespace Stimulsoft.Report.Export {
    import StiExportService = Stimulsoft.Report.Export.StiExportService;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiJsonExportService extends StiExportService implements IStiJsonExportService {
        implements(): any[];
        get defaultExtension(): string;
        get exportFormat(): StiExportFormat;
        get groupCategory(): string;
        get position(): number;
        get exportNameInMenu(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportJson(report: StiReport, stream: MemoryStream, settings: StiDataExportSettings): void;
    }
}
export namespace Stimulsoft.Report.Export {
    import StiExportService = Stimulsoft.Report.Export.StiExportService;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiSylkExportService extends StiExportService implements IStiSylkExportService {
        implements(): any[];
        get defaultExtension(): string;
        get exportFormat(): StiExportFormat;
        get groupCategory(): string;
        get position(): number;
        get exportNameInMenu(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private writer;
        private formatList;
        private fontList;
        private colorHash;
        private hiToTwips;
        private twipsToColinfo;
        private twipsToSymbols;
        private getFontNumber;
        private getFormatNumber;
        private colorTableSize;
        private colorTable;
        private getColorIndex;
        exportSylk(report: StiReport, stream: MemoryStream, settings: StiDataExportSettings): void;
    }
}
export namespace Stimulsoft.Report.Export {
    import StiExportService = Stimulsoft.Report.Export.StiExportService;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiXmlExportService extends StiExportService implements IStiXmlExportService {
        implements(): any[];
        get defaultExtension(): string;
        get exportFormat(): StiExportFormat;
        get groupCategory(): string;
        get position(): number;
        get exportNameInMenu(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportXml(report: StiReport, stream: MemoryStream, settings: StiDataExportSettings): void;
        private writeDataSetToStream;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiBmpHelper {
        private static dwByte;
        private static dwByte2;
        private static dwWord;
        private static dwDWord;
        static saveToStream(imageForExport: Image, paletteType: StiPcxPaletteType, ditheringType: StiMonochromeDitheringType, stream: MemoryStream): void;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiGifHelper {
        static saveToStream(imageForExport: Image, paletteType: StiPcxPaletteType, ditheringType: StiMonochromeDitheringType, stream: MemoryStream): void;
    }
}
export namespace Stimulsoft.Report.Export.Office {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiOfficeEncryptedPackageHelper {
        static readonly BlockKey_HashInput: number[];
        static readonly BlockKey_HashValue: number[];
        static readonly BlockKey_KeyValue: number[];
        static readonly BlockKey_HmacKey: number[];
        static readonly BlockKey_HmacValue: number[];
        static EncryptPackage(packageData: number[], password: string, stream: MemoryStream): void;
        private static EncryptData;
        private static SetHMAC;
        private static MakeDataSpaces;
        private static CreateStrongEncryptionDataSpaceStream;
        private static CreateVersionStream;
        private static CreateDataSpaceMap;
        private static CreateTransformInfoPrimary;
        private static GetHashProvider;
        private static GetHmacProvider;
        private static IsPasswordValid;
        private static EncryptAgileFromKey;
        private static GetFinalHash;
        private static GetPasswordHashSpinPrepending;
        private static FixHashSize;
        private static CombinePassword;
        static getRandomBytes(count: number): number[];
    }
}
export namespace Stimulsoft.Report.Export.Office {
    enum StiOfficeCipherAlgorithm {
        AES = 0,
        RC2 = 1,
        RC4 = 2,
        DES = 3,
        DESX = 4,
        TRIPLE_DES = 5,
        TRIPLE_DES_112 = 6
    }
    enum StiOfficeChainingMode {
        ChainingModeCBC = 0,
        ChainingModeCFB = 1
    }
    enum StiOfficeHashAlgorithm {
        SHA1 = 0,
        SHA256 = 1,
        SHA384 = 2,
        SHA512 = 3,
        MD5 = 4,
        MD4 = 5,
        MD2 = 6,
        RIPEMD128 = 7,
        RIPEMD160 = 8,
        WHIRLPOOL = 9
    }
    class StiOfficeKeyDataInfo {
        saltSize: number;
        blockSize: number;
        keyBits: number;
        hashSize: number;
        cipherAlgorithm: StiOfficeCipherAlgorithm;
        cipherChaining: StiOfficeChainingMode;
        hashAlgorithm: StiOfficeHashAlgorithm;
        saltValue: number[];
    }
    class StiOfficeDataIntegrityInfo {
        encryptedHmacKey: number[];
        encryptedHmacValue: number[];
    }
    class StiOfficeKeyEncryptorInfo extends StiOfficeKeyDataInfo {
        spinCount: number;
        encryptedVerifierHashInput: number[];
        encryptedVerifierHashValue: number[];
        encryptedKeyValue: number[];
        verifierHashInput: number[];
        verifierHash: number[];
        keyValue: number[];
    }
    class StiOfficeEncryptionInfo {
        keyData: StiOfficeKeyDataInfo;
        dataIntegrity: StiOfficeDataIntegrityInfo;
        keyEncryptors: StiOfficeKeyEncryptorInfo[];
        saveToXml(): string;
        saveToBinary(): number[];
        private saveToBytes;
        private static getCipherAlgorithmString;
        private static getHashAlgorithmString;
        constructor(isDefault?: boolean);
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiPcxHelper {
        private static dwByte;
        private static dwByte2;
        private static dwByte3;
        private static dwWord;
        private static dwEncodedData;
        static saveToStream(imageForExport: Image, paletteType: StiPcxPaletteType, ditheringType: StiMonochromeDitheringType, stream: MemoryStream): void;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiTiffHelper {
        private static toTiffImage;
        static saveToStream(imageForExport: Image, paletteType: StiPcxPaletteType, ditheringType: StiMonochromeDitheringType, stream: MemoryStream): void;
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiHtml5ExportService extends StiExportService implements IStiHtml5ExportService {
        implements(): any[];
        renderAsDocument: boolean;
        get defaultExtension(): string;
        get exportFormat(): StiExportFormat;
        get groupCategory(): string;
        get position(): number;
        get exportNameInMenu(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        getFilter(): string;
        multipleFiles: boolean;
        report: StiReport;
        fileName: string;
        imageFormat: ImageFormat;
        htmlWriter: StiHtmlTextWriter;
        imageQuality: number;
        imageResolution: number;
        compressToArchive: boolean;
        private renderPage;
        private renderStartDoc;
        private renderEndDoc;
        exportHtml(report: StiReport, htmlWriter: StiHtmlTextWriter, settings: StiHtmlExportSettings): void;
        constructor();
    }
}
export namespace Stimulsoft.Report.Export {
    import Color = Stimulsoft.System.Drawing.Color;
    import Size = Stimulsoft.System.Drawing.Size;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiExcelExportService extends StiExportService implements IStiExcelExportService {
        implements(): any[];
        get exportFormat(): StiExportFormat;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private report;
        private fileName;
        private sendEMail;
        matrix: StiMatrix;
        private fontList;
        private fillList;
        private borderList;
        private xfList;
        private sstList;
        private sstHash;
        private sstHashIsTags;
        private imageList;
        private formatList;
        private sstCount;
        private sheetNameList;
        private imageListOffset;
        private printAreasList;
        private matrixList;
        private firstPageIndexList;
        private hyperlinkList;
        private minRowList;
        private maxRowList;
        private useOnePageHeaderAndFooter;
        private dataExportMode;
        private exportObjectFormatting;
        private exportEachPageToSheet;
        private exportHorizontalPageBreaks;
        private imageResolution;
        private imageQuality;
        private imageFormat;
        private imageResolutionMode;
        private imageCache;
        private restrictEditing;
        private protectionPassword;
        private exportCache;
        private reportCulture;
        private englishCulture;
        private docCompanyString;
        private docLastModifiedString;
        private xmlIndentation;
        private wrongUrlSymbols;
        private netTicksPerDay;
        private getLineStyle;
        private refChars;
        private getRefString;
        private getRefAbsoluteString;
        private floatToString;
        private stringToUrl;
        private getFontNumber;
        private getFillNumber;
        private getBorderNumber;
        private getXFNumber;
        private getSSTNumber;
        private getFormatNumber;
        HiToTwips: number;
        private TwipsToColinfo;
        private convert;
        private convertToEMU;
        private compareExcellSheetNames;
        private prepareData;
        private writeContentTypes;
        private writeMainRels;
        private writeDocPropsApp;
        private writeDocPropsCore;
        private writeWorkbookRels;
        private writeWorkbook;
        private writeSheetRels;
        private writeSheet;
        static regexCheckInteger1: RegExp;
        static regexCheckFloat1: RegExp;
        private checkForNumber;
        private calculateHash;
        private prepareMatrix;
        private getParentBandName;
        private convertAllowHtmlTagsToExcelString;
        private convertTextToExcelString;
        private writeDrawingRels;
        private writeDrawing;
        private writeStyles;
        private writeBorderData;
        private writeSST;
        private writeAdditionalData;
        private writeImage;
        exportExcel(report: StiReport, stream: MemoryStream, settings: StiExcelExportSettings): void;
    }
    class DataFont {
        Name: string;
        Bold: boolean;
        Italic: boolean;
        Underlined: boolean;
        Strikeout: boolean;
        Height: number;
        Color: Color;
        Charset: number;
        Family: number;
        constructor(Name: string, Bold: boolean, Italic: boolean, Underlined: boolean, Strikeout: boolean, Height: number, Color: Color, Charset: number, Family: number);
        equals(obj: DataFont): boolean;
    }
    class DataFill {
        Type: string;
        FgColor: Color;
        BgColor: Color;
        constructor(Type: string, FgColor: Color, BgColor: Color);
        equals(obj: DataFill): boolean;
    }
    class DataBorder {
        BorderLeft: StiBorderSide;
        BorderRight: StiBorderSide;
        BorderTop: StiBorderSide;
        BorderBottom: StiBorderSide;
        constructor(BorderLeft: StiBorderSide, BorderRight: StiBorderSide, BorderTop: StiBorderSide, BorderBottom: StiBorderSide);
        equals(obj: DataBorder): boolean;
        private eq;
    }
    class DataXF {
        FormatIndex: number;
        FontIndex: number;
        FillIndex: number;
        BorderIndex: number;
        XFId: number;
        HorAlign: StiTextHorAlignment;
        VertAlign: StiVertAlignment;
        TextRotationAngle: number;
        TextWrapped: boolean;
        RightToLeft: boolean;
        Editable: boolean;
        equalDataXF(xf: DataXF): boolean;
        constructor(FormatIndex: number, FontIndex: number, FillIndex: number, BorderIndex: number, XFId: number, HorAlign: StiTextHorAlignment, VertAlign: StiVertAlignment, TextRotationAngle: number, TextWrapped: boolean, RightToLeft: boolean, Editable: boolean);
    }
    class ExcelImageData {
        FirstRowIndex: number;
        FirstRowOffset: number;
        FirstColumnIndex: number;
        FirstColumnOffset: number;
        LastRowIndex: number;
        LastRowOffset: number;
        LastColumnIndex: number;
        LastColumnOffset: number;
        ImageIndex: number;
        Hyperlink: string;
        Component: StiComponent;
        OffsetAndSize: Rectangle;
        ImageSize: Size;
        constructor(FirstRowIndex: number, FirstRowOffset: number, FirstColumnIndex: number, FirstColumnOffset: number, LastRowIndex: number, LastRowOffset: number, LastColumnIndex: number, LastColumnOffset: number, ImageIndex: number, Hyperlink: string, Component: StiComponent, OffsetAndSize: Rectangle, ImageSize: Size);
    }
    class CellRangeAddress {
        FirstRow: number;
        LastRow: number;
        FirstColumn: number;
        LastColumn: number;
        constructor(FirstRow: number, LastRow: number, FirstColumn: number, LastColumn: number);
    }
    class HlinkData {
        Range: CellRangeAddress;
        Description: string;
        Bookmark: string;
        constructor(Range: CellRangeAddress, Description: string, Bookmark: string);
    }
    class StiExcel2007ExportService extends StiExcelExportService {
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiPowerPointExportService extends StiExportService implements IStiPowerPointExportService {
        implements(): any[];
        get exportFormat(): StiExportFormat;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private report;
        private imageSlide;
        private imageResolution;
        private imageQuality;
        private imageCache;
        private imageFormat;
        private idCounter;
        private hyperlinkList;
        private xmlIndentation;
        private currentCulture;
        private newCulture;
        private imageResolutionMode;
        private exportCache;
        private getLineStyle;
        private stringToUrl;
        private wrongUrlSymbols;
        private convertToEmu;
        private writeColor;
        private writeContentTypes;
        private writeMainRels;
        private writeDocPropsApp;
        private writeDocPropsCore;
        private writeTableStyles;
        private writePresProps;
        private writeViewProps;
        private writeTheme;
        private writeSlideMasterRels;
        private writeSlideMaster;
        private writeSlideLayoutRels;
        private writeSlideLayout;
        private writePresentationRels;
        private writePresentation;
        private writeSlideRels;
        private writeSlide;
        private writeStiTextbox;
        private writeStiImage;
        private writeStiImageAuto;
        private writeSpPr;
        private writeBorder;
        private writeLine;
        private writeRoundRectangle;
        private capStyleToPptStyle;
        private writeWatermark;
        private writeHyperlinkInfo;
        private writeImage;
        exportPowerPoint(report: StiReport, stream: MemoryStream, settings: StiPowerPointExportSettings): void;
    }
    class StiPpt2007ExportService extends StiPowerPointExportService {
    }
}
export namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    class StiWordExportService extends StiExportService implements IStiWordExportService {
        implements(): any[];
        get exportFormat(): StiExportFormat;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private report;
        private fileName;
        private sendEMail;
        multipleFiles: boolean;
        getFilter(): string;
        matrix: StiMatrix;
        removeEmptySpaceAtBottom: boolean;
        private fontList;
        private styleList;
        private imageCache;
        private bookmarkList;
        private hyperlinkList;
        private embedsList;
        private xmlIndentation;
        private imageQuality;
        private imageResolution;
        private imageFormat;
        private imageResolutionMode;
        private lineSpace;
        private lineSpace2;
        private usePageHeadersAndFooters;
        private restrictEditing;
        private protectionPassword;
        private headersData;
        private headersRels;
        private footersData;
        private footersRels;
        private shiftHeader;
        private shiftFooter;
        private hasHeader;
        private hasFooter;
        private additionalIndex;
        private spriteIndex;
        private needEmptyParagraph;
        private bkmRefText;
        private bkmRefId;
        private hypRefText;
        private hypRefId;
        private exportCache;
        private englishCulture;
        private docCompanyString;
        private docLastModifiedString;
        private static fontsToCorrectHeight;
        private static defaultFontHeightCorrection;
        private static checkFontsToCorrectHeight;
        private getLineStyle;
        private getColorString;
        private getStyleNumber;
        private getStyleFromComponent;
        private stringToUrl;
        private wrongUrlSymbols;
        private getHyperlinkRefId;
        private static get hiToTwips();
        private convert;
        private convertHiToTwips;
        private convertTwipsToEmu;
        private convertStringToBookmark;
        private initialCodeArray;
        private encryptionMatrix;
        private concatByteArrays;
        generateDocumentProtection(writer: XmlTextWriter, strPassword: string): void;
        private writeFromMatrix;
        private writeCellContent;
        private writeStiImage;
        private writeStiImageAuto;
        private writeTableInfo;
        private writeHtmlTags;
        private writeParagraphBegin;
        private writeRunProperties;
        private renderBorder2TableGetValues;
        private getLineStyle2TableGetValues;
        private writeDocument;
        private getPagesBackColor;
        private comparePages;
        private writePageInfo;
        private writeBorders;
        private writeBorderData;
        private writeFootNotes;
        private writeEndNotes;
        private writeHeader;
        private writeFooter;
        private writeWatermark;
        private writeContentTypes;
        private writeMainRels;
        private writeDocPropsApp;
        private writeDocPropsCore;
        private writeSettings;
        private writeWebSettings;
        private writeFontTable;
        private writeDocumentRels;
        private writeHeaderFooterRels;
        private writeStyles;
        private writeImage;
        exportWord(report: StiReport, stream: MemoryStream, settings: StiWordExportSettings): void;
    }
    class StiWord2007ExportService extends StiWordExportService {
    }
}
export namespace Stimulsoft.Report.Export {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiGaugeDrawingHelper {
        private static PiDiv180;
        private static FourDivThree;
        static convertArcToCubicBezier(centerPoint: Point, radius: number, startAngle: number, sweepAngle: number): Point[];
        static convertArcToCubicBezier2(centerPoint: Point, radius1: number, radius2: number, startAngle: number, sweepAngle: number): Point[];
    }
}
export namespace Stimulsoft.Report.Export {
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiHatchBrush = Stimulsoft.Base.Drawing.StiHatchBrush;
    import StiText = Stimulsoft.Report.Components.StiText;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiImage = Stimulsoft.Report.Components.StiImage;
    class StiPdfData {
        X: number;
        Y: number;
        Width: number;
        Height: number;
        Component: StiComponent;
        service: StiPdfExportService;
        get Right(): number;
        get Top(): number;
        clone(): StiPdfData;
        constructor(service: StiPdfExportService);
    }
    class StiImageData {
        Width: number;
        Height: number;
        Name: string;
        ImageFormat: StiImageFormat;
    }
    class StiShadingData {
        X: number;
        Y: number;
        Width: number;
        Height: number;
        Page: number;
        Angle: number;
        FunctionIndex: number;
    }
    class StiShadingFunctionData {
        Colors: Color[];
    }
    class StiEditableObject {
        X: number;
        Y: number;
        Width: number;
        Height: number;
        Page: number;
        Text: string;
        Content: number[];
        Content2: number[];
        Multiline: boolean;
        Alignment: Stimulsoft.Base.Drawing.StiTextHorAlignment;
        FontNumber: number;
        FontSize: number;
        FontColor: Color;
        Component: StiComponent;
        constructor();
    }
    class StiLinkObject {
        X: number;
        Y: number;
        Width: number;
        Height: number;
        Page: number;
        DestPage: number;
        DestY: number;
        Link: string;
    }
    class StiPdfExportService extends StiExportService implements IStiPdfExportService {
        implements(): any[];
        get exportFormat(): StiExportFormat;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: (error?: string) => void, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        report: StiReport;
        multipleFiles: boolean;
        private imageQuality;
        private imageResolutionMain;
        private imageResolutionMode;
        private sw;
        pageStream: MemoryStream;
        imageList: StiImageData[];
        private imageCache;
        private exportCache;
        private imageInterpolationTable;
        private imageCacheIndexToList;
        private imageInfoList;
        private imageInfoCounter;
        imagesCurrent: number;
        private fontsCounter;
        private bookmarksCounter;
        private linksCounter;
        annotsCounter: number;
        annotsCurrent: number;
        annots2Counter: number;
        private annots2Current;
        private unsignedSignaturesCounter;
        shadingCurrent: number;
        private tooltipsCounter;
        private colorTable;
        private alphaTable;
        pdfFont: PdfFonts;
        private standardPdfFonts;
        private embeddedFonts;
        useUnicodeMode: boolean;
        private reduceFontSize;
        private compressed;
        private compressedFonts;
        private encrypted;
        usePdfA: boolean;
        private pdfComplianceMode;
        private exportRtfTextAsImage;
        private autoPrint;
        private imageCompressionMethod;
        private imageFormat;
        private monochromeDitheringType;
        private allowEditable;
        private useTransparency;
        private embeddedFiles;
        private zugferdComplianceMode;
        private zugferdConformanceLevel;
        private fontGlyphsReduceNotNeed;
        private xref;
        private bookmarksTree;
        private bookmarksTreeTemp;
        linksArray: StiLinkObject[];
        private tagsArray;
        private tooltipsArray;
        annotsArray: StiEditableObject[];
        private annots2Array;
        private unsignedSignaturesArray;
        shadingArray: StiShadingData[];
        private hatchArray;
        private shadingFunctionArray;
        private haveBookmarks;
        private haveLinks;
        haveAnnots: boolean;
        private haveTooltips;
        CodePage1252part80AF: number[];
        private CodePage1252;
        hiToTwips: number;
        private precision_digits_font;
        pdfCKT: number;
        private IDValue;
        private IDValueString;
        private IDValueStringMeta;
        private currentDateTime;
        private currentDateTimeMeta;
        private producerName;
        private creatorName;
        private keywords;
        private currentObjectNumber;
        private currentGenerationNumber;
        private keyLength;
        private lastColorStrokeA;
        private lastColorNonStrokeA;
        private colorStack;
        info: StiPdfStructure;
        private haveDigitalSignature;
        private pdfSecurity;
        tempGeomWriter: StiPdfGeomWriter;
        lastProcessedComponent: StiComponent;
        static printScaling: boolean;
        private static regexEscape;
        stringReplace(st: string, oldValue: string, newValue: string): string;
        getHatchNumber(brush: StiHatchBrush): number;
        getShadingFunctionNumber(colors: Color[]): number;
        private isColorArraysEquals;
        private addXref;
        convertToString(value: number, precision?: number): string;
        static convertToEscapeSequence(value: string): string;
        static convertToEscapeSequencePlusTabs(value: string): string;
        setStrokeColor(tempColor: Color): void;
        setNonStrokeColor(tempColor: Color): void;
        private colorHash1;
        private colorHash2;
        private _gsTable;
        get gsTable(): string[][];
        pushColorToStack(): void;
        popColorFromStack(): void;
        fillRectBrush(brush: StiBrush, rect: Rectangle, cornerRadius?: StiCornerRadius): void;
        private storeStringLine;
        storeString(st: string): void;
        private convertToHexString;
        private storeMemoryStream2;
        private storeMemoryStream3;
        private storeMemoryStream4;
        storeWysiwygSymbols(text: StiText, pageNumber?: number): void;
        private renderStartDoc;
        private renderEndDoc;
        getCreatorString(): string;
        private renderPageHeader;
        private renderPageFooter;
        private renderFontTable;
        private renderImageTable;
        private renderBookmarksTable;
        private renderPatternTable;
        private writeHatchPattern;
        private writeShadingPattern;
        private writeShadingFunction;
        private renderLinkTable;
        private renderAnnotTable;
        private renderTooltipTable;
        private renderEncodeRecord;
        private renderExtGStateRecord;
        storeImageData(image: Image, imageResolution: number, needSmoothing: boolean, comp: StiComponent, propId?: string): number;
        storeImageDataForGeom(image: StiImage): void;
        private writeImageInfo;
        writeImageInfo2(pp: StiPdfData, imageResolutionX: number, imageResolutionY: number): void;
        renderImage(pp: StiPdfData, imageResolution: number, forceResolutionModeAuto?: boolean): void;
        renderIcon(pp: StiPdfData): void;
        private renderWatermark;
        storeShadingData1(brush: StiBrush, pageNumber: number): void;
        storeShadingData2(x: number, y: number, width: number, height: number, brush: StiBrush, compAngle?: number): number;
        storeHatchData(brush: StiBrush): void;
        private renderMetadata;
        private renderColorSpace;
        private renderAutoPrint;
        private renderEmbeddedFiles;
        private addBookmarkNode;
        private makeBookmarkFromTree;
        exportPdf(report: StiReport, stream: MemoryStream, settings: StiPdfExportSettings): void;
        private exportPdf1;
    }
}
export namespace Stimulsoft.Report.Export {
    import Font = Stimulsoft.System.Drawing.Font;
    class PdfFontInfo {
        Widths: number[];
        CharPdfNames: string[];
        CH: number;
        XH: number;
        ASC: number;
        DESC: number;
        tmASC: number;
        tmDESC: number;
        tmExternal: number;
        MacAscend: number;
        MacDescend: number;
        MacLineGap: number;
        LLX: number;
        LLY: number;
        URX: number;
        URY: number;
        StemV: number;
        ItalicAngle: number;
        LineGap: number;
        NtmFlags: number;
        UnderscoreSize: number;
        UnderscorePosition: number;
        StrikeoutSize: number;
        StrikeoutPosition: number;
        UnicodeMap: number[];
        UnicodeMapBack: number[];
        GlyphList: number[];
        GlyphBackList: number[];
        GlyphMap: number[];
        SymsToPDF: number[];
        MappedSymbolsCount: number;
        NeedSyntItalic: boolean;
        NeedSyntBold: boolean;
        GlyphWidths: number[];
        ChildFontsMap: number[];
        UseUnicode: boolean;
    }
    class pfontInfo {
        Name: string;
        PdfName: string;
        Bold: boolean;
        Italic: boolean;
        Number: number;
        Font: Font;
        ParentFontNumber: number;
        ChildFontsMap: number[];
        UseUnicode: boolean;
        FontKitObject: any;
    }
    class PdfFonts extends PdfFontInfo {
        getFontMetrics(font: Font, currentFontInfo: PdfFontInfo, glyphMap: number[], report: StiReport): void;
        static isFontStimulsoft(name: string): boolean;
        private standardFontQuantity;
        private standardFontNumWidths;
        private standardFontNumChars;
        firstMappedSymbol: number;
        factor: number;
        maxSymbols: number;
        forceUseUnicode: boolean;
        WIDTHS: number[];
        fonts: PdfFontInfo[];
        UnicodeMapsList: number[][];
        GlyphMapsList: number[][];
        standardPdfFonts: boolean;
        fontList: pfontInfo[];
        private fontsInfoStore;
        private family_Helvetica;
        private family_Courier;
        private family_Times_Roman;
        private family_Symbol;
        private family_ZapfDingbats;
        PdfFontName: string[];
        private _currentFont;
        get currentFont(): number;
        set currentFont(value: number);
        InitFontsData(report: StiReport): void;
        constructor();
        getFontNumber(incomingFont: Font): number;
        storeUnicodeSymbolsInMap(st: string): void;
        storeGlyphsInMap(sb: string): void;
        private TtfHeaderSize;
        getCharToGlyphTable(buff: Uint8Array, fontName: string): number[];
        reduceFontSize(buff: Uint8Array, fontName: string, remakeGlyphTable: boolean): Stimulsoft.System.IO.MemoryStream;
        private scanFontFile;
        private getCmapTable;
        private copyUint8Array;
        ARG_1_AND_2_ARE_WORDS: number;
        ARGS_ARE_XY_VALUES: number;
        ROUND_XY_TO_GRID: number;
        WE_HAVE_A_SCALE: number;
        MORE_COMPONENTS: number;
        WE_HAVE_AN_X_AND_Y_SCALE: number;
        WE_HAVE_A_TWO_BY_TWO: number;
        WE_HAVE_INSTRUCTIONS: number;
        USE_MY_METRICS: number;
        OVERLAP_COMPOUND: number;
        SCALED_COMPONENT_OFFSET: number;
        UNSCALED_COMPONENT_OFFSET: number;
        TablesNames: string[];
        private getTtfInfo;
        private GetUInt8;
        private GetUInt16;
        private GetUInt32;
        private GetInt16;
        private SetUInt16;
        private SetUInt32;
        clear(): void;
        getFontDataBuf(font: Font, report: StiReport): any;
        getFontDataFromGdi(font: Font, report: StiReport): any;
    }
    class FontsInfoStore {
        clear(): void;
    }
}
export namespace Stimulsoft.Report.Export {
    import List = Stimulsoft.System.Collections.List;
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StringBuilder = Stimulsoft.System.Text.StringBuilder;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Matrix = Stimulsoft.System.Drawing.Drawing2D.Matrix;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Pen = Stimulsoft.System.Drawing.Pen;
    import Image = Stimulsoft.System.Drawing.Image;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    class StiPdfGeomWriter implements IStiExportGeomWriter {
        private penWidthDefault;
        private precision_digits;
        private hiToTwips;
        private pdfCKT;
        private lastPoint;
        private makepath;
        private pathClosed;
        path: StringBuilder;
        private allowThinLines;
        private cornerScaling;
        pageStream: MemoryStream;
        private pdfService;
        assembleData: boolean;
        pageNumber: number;
        matrixCache: Matrix[];
        componentAngle: number;
        forceNewPoint: boolean;
        private xmin;
        private xmax;
        private ymin;
        private ymax;
        private calculateMinMax;
        private convertToString;
        setPen(objPen: any, saveState?: boolean, forceThin?: boolean): boolean;
        setBrush(brush: Color | StiBrush, rect: Rectangle, saveState?: boolean, REFisTransparent?: any): boolean;
        private outputLineString;
        private convertArcToBezierPoints;
        convertSplineToCubicBezier(points: Point[], tension: number): Point[];
        private calculateCurveBezier;
        private calculateCurveBezierEndPoints;
        getPointString(point: Point): string;
        getLineToString(pointTo: Point): string;
        getRectString4(x: number, y: number, width: number, height: number): string;
        getRectString(rect: Rectangle): string;
        getRectWithCornersString(rect: Rectangle, corners: StiCornerRadius): string;
        getBezierString(p1: Point, p2: Point, p3: Point): string;
        getBezierString2(p1x: number, p1y: number, p2x: number, p2y: number, p3x: number, p3y: number): string;
        getPolylineString(points: Point[], close: boolean, drawTo: boolean): string;
        getEllipseString4(x: number, y: number, width: number, height: number): string;
        getEllipseString(rect: Rectangle): string;
        private getPenStyleDashString;
        beginPath(): void;
        closeFigure(): void;
        endPath(): void;
        fillPath(brush: any): void;
        strokePath(pen: any): void;
        moveTo(point: Point): void;
        drawLine(pointFrom: Point, pointTo: Point, pen: any): void;
        drawLineTo(pointTo: Point, pen: any): void;
        drawRectangle(rect: Rectangle, pen: any, corners: StiCornerRadius): void;
        fillRectangle(rect: Rectangle, brush: any, corners: StiCornerRadius): void;
        drawPolygon(points: Point[], pen: any): void;
        drawPolyline(points: Point[], pen: any, close?: boolean, drawTo?: boolean): void;
        drawPolylineTo(points: Point[], pen: any): void;
        fillPolygon(points: Point[], brush: any): void;
        fillPolygons(points: List<List<PointD>>, brush: any): void;
        drawBezier(p1: Point, p2: Point, p3: Point, p4: Point, pen: any): void;
        drawBezierTo(p2: Point, p3: Point, p4: Point, pen: any): void;
        drawSpline(points: Point[], tension: number, pen: any): void;
        drawArc(rect: Rectangle, startAngle: number, sweepAngle: number): void;
        drawEllipse(rect: Rectangle, pen: any): void;
        fillEllipse(rect: Rectangle, brush: any): void;
        drawPie(rect: Rectangle, startAngle: number, sweepAngle: number): void;
        drawString(st: string, font: Font, brush: StiBrush, rect: Rectangle, sf: StringFormat): void;
        saveState(): void;
        restoreState(): void;
        translateTransform(x: number, y: number): void;
        rotateTransform(angle: number): void;
        rotateTransform2(angle: number, x: number, y: number): void;
        setClip(rect: Rectangle): void;
        drawArc2(rect: RectangleD, p1: PointD, p2: PointD, pen: Pen): void;
        drawText(basePoint: PointD, text: string, charsOffset: number[], font: Font, textColor: Color, angle: number, textAlign: EmfTextAlignmentMode): void;
        setPixel(point: PointD, color: Color): void;
        measureString(st: string, font: Font): SizeD;
        drawImage(img: Image, rect: RectangleD): void;
        constructor(stream: MemoryStream, service: StiPdfExportService, assembleData?: boolean, allowThinLines?: boolean, cornerScaling?: number);
    }
}
export namespace Stimulsoft.Report.Export {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiPdfRenderChart {
        static renderChart(pp: StiPdfData, assemble: boolean, pageNumber: number): void;
        static renderSparkline(pp: StiPdfData, assemble: boolean, pageNumber: number): void;
        static renderContext(pp: StiPdfData, assemble: boolean, pageNumber: number, context: StiContext, allowThinLines?: boolean): void;
        private static getStartPoint;
        private static rectToRectangle;
        private static brushToStiBrush;
        private static checkPenGeom;
    }
}
export namespace Stimulsoft.Report.Export {
    class StiPdfRenderGauge {
        static renderGauge(pp: StiPdfData, assemble: boolean, pageNumber: number): void;
        private static checkPenGeom;
        private static getPenGeom2;
        private static getPenGeom;
        private static round;
    }
}
export namespace Stimulsoft.Report.Export {
    class StiPdfRenderIndicators {
        static renderIndicators(pp: StiPdfData): StiPdfData;
    }
}
export namespace Stimulsoft.Report.Export {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiShape = Stimulsoft.Report.Components.StiShape;
    import StiCheckBox = Stimulsoft.Report.Components.StiCheckBox;
    class StiPdfRenderPrimitives {
        static renderBorder1(pp: StiPdfData): void;
        static renderBorder2(pp: StiPdfData): void;
        private static renderBorderWithCorners2;
        private static writeBorderWithCorners2;
        private static storeBorderSideData;
        static getPenStyleDashString(style: StiPenStyle, step: number, pp: StiPdfData): string;
        static checkShape(shape: StiShape): boolean;
        static renderShape(pp: StiPdfData, imageResolution: number): void;
        static renderRoundedRectanglePrimitive(pp: StiPdfData): void;
        static renderCheckbox(pp: StiPdfData, checkBoxValue: boolean, storeShading?: boolean): void;
        static getCheckBoxValue(checkbox: StiCheckBox): boolean;
    }
}
export namespace Stimulsoft.Report.Export {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiPdfRenderText {
        private static hiToTwips;
        private static precision_digits_font;
        private static fontCorrectValue;
        private static boldFontStrokeWidthValue;
        private static italicAngleTanValue;
        private static charCode07;
        static renderText(pp: StiPdfData, basePoint?: Point, clipMargins?: boolean): void;
        private static isWordWrapSymbol;
        private static getTabsSize;
        static renderTextFont(pp: StiPdfData): void;
        static renderText2(pp: StiPdfData, pageNumber?: number): void;
        static renderText3(pp: StiPdfData, pageNumber?: number): void;
        private static renderTextLine;
    }
}
export namespace Stimulsoft.Report.Export {
    class StiPdfResources {
        static sRGBprofile: number[];
        static hatchData: string[];
        private static standardFontWidths;
        private static standardFontInfo;
        private static _standardFontCharsNames;
        static get standardFontCharsNames(): string[];
    }
}
export namespace Stimulsoft.Report.Export {
    class StiPdfSecurity {
        static paddingString: number[];
        ownerValue: number[];
        userValue: number[];
        ownerExtendedValue: number[];
        userExtendedValue: number[];
        permsValue: number[];
        IDValue: number[];
        encryptionKey: number[];
        encryptionKeyLength: number;
        passwordOwner: string;
        passwordUser: string;
        securityFlags: number;
        keyLength: StiPdfEncryptionKeyLength;
        pdfService: StiPdfExportService;
        private padPassword;
        computingCryptoValues(userAccessPrivileges: StiUserAccessPrivileges, passwordInputOwner: string, passwordInputUser: string, keyLength: StiPdfEncryptionKeyLength, IDValue: number[]): boolean;
        private computingCryptoValues2;
        private computingCryptoValuesV4;
        private computingCryptoValuesV5;
        private encodeKeyDataV5;
        private decodeKeyDataV5;
        private getHashV5;
        private static calculate_hash_r5;
        private static calculate_hash_r6;
        encryptData(data: number[], currentObjectNumber: number, currentGenerationNumber: number): number[];
        private throwEncryptionError;
        renderEncodeRecord(sw: Stimulsoft.System.IO.MemoryStream, pdfService: StiPdfExportService): void;
        getBytesUInt32(uint: number): number[];
        getBytesUint16(uint: number): number[];
        private rc4;
        private computeHashMD5;
        constructor(service: StiPdfExportService);
    }
}
export namespace Stimulsoft.Report.Export {
    class StiPdfObjInfo {
        ref: number;
        info: StiPdfStructure;
        get isUsed(): boolean;
        addRef(): void;
        toString(): string;
    }
    class StiPdfContentObjInfo extends StiPdfObjInfo {
        content: StiPdfObjInfo;
    }
    class StiPdfXObjectObjInfo extends StiPdfObjInfo {
        mask: StiPdfObjInfo;
    }
    class StiPdfFontObjInfo extends StiPdfObjInfo {
        descendantFont: StiPdfObjInfo;
        toUnicode: StiPdfObjInfo;
        cIDSet: StiPdfObjInfo;
        encoding: StiPdfObjInfo;
        fontDescriptor: StiPdfObjInfo;
        fontFile2: StiPdfObjInfo;
    }
    class StiPdfOutlinesObjInfo extends StiPdfObjInfo {
        items: StiPdfObjInfo[];
    }
    class StiPdfPatternsObjInfo extends StiPdfObjInfo {
        resources: StiPdfObjInfo;
        first: StiPdfObjInfo;
        hatchItems: StiPdfObjInfo[];
        shadingItems: StiPdfObjInfo[];
        shadingFunctionItems: StiPdfObjInfo[];
    }
    class StiPdfAnnotObjInfo extends StiPdfObjInfo {
        aP: StiPdfObjInfo;
        aA: StiPdfObjInfo[];
    }
    class StiPdfCheckBoxObjInfo {
        items: StiPdfAnnotObjInfo[];
    }
    class StiPdfAcroFormObjInfo extends StiPdfObjInfo {
        annots: StiPdfAnnotObjInfo[];
        checkBoxes: StiPdfCheckBoxObjInfo[];
        unsignedSignatures: StiPdfAnnotObjInfo[];
        signatures: StiPdfAnnotObjInfo[];
        tooltips: StiPdfAnnotObjInfo[];
        annotFontItems: StiPdfFontObjInfo[];
        fontHelvetica: StiPdfObjInfo;
    }
    class StiPdfStructure {
        root: StiPdfObjInfo;
        info: StiPdfObjInfo;
        colorSpace: StiPdfObjInfo;
        pages: StiPdfObjInfo;
        structTreeRoot: StiPdfObjInfo;
        optionalContentGroup: StiPdfObjInfo;
        pageList: StiPdfContentObjInfo[];
        xObjectList: StiPdfXObjectObjInfo[];
        fontList: StiPdfFontObjInfo[];
        outlines: StiPdfOutlinesObjInfo;
        patterns: StiPdfPatternsObjInfo;
        linkList: StiPdfObjInfo[];
        encode: StiPdfObjInfo;
        extGState: StiPdfObjInfo;
        acroForm: StiPdfAcroFormObjInfo;
        metadata: StiPdfObjInfo;
        destOutputProfile: StiPdfObjInfo;
        outputIntents: StiPdfObjInfo;
        embeddedJS: StiPdfContentObjInfo;
        embeddedFilesList: StiPdfContentObjInfo[];
        private objectsCounter;
        private objects;
        addRef(info: StiPdfObjInfo): void;
        createObject(addRef?: boolean): StiPdfObjInfo;
        createContentObject(addRef?: boolean): StiPdfContentObjInfo;
        createXObject(addRef?: boolean, haveMask?: boolean): StiPdfXObjectObjInfo;
        createFontObject(addRef?: boolean, useUnicodeMode?: boolean, standardPdfFonts?: boolean, embeddedFonts?: boolean, annotFont?: boolean): StiPdfFontObjInfo;
        createOutlinesObject(addRef?: boolean): StiPdfOutlinesObjInfo;
        createPatternsObject(addRef?: boolean): StiPdfPatternsObjInfo;
        createAcroFormObject(addRef?: boolean): StiPdfAcroFormObjInfo;
        createAnnotObject(addRef?: boolean, createAP?: boolean, numberAA?: number): StiPdfAnnotObjInfo;
        constructor();
    }
}
export namespace Stimulsoft.Report.Export {
    class StiEncode {
        static unicodeToCodePageArray: number[];
        static unicodeToAnsiArray: number[];
        private static codePagesDataTable;
        private static codePagesCount;
        static codePagesTable: number[][];
        static codePagesTableSize: number;
        static encode(sb: string, codepage: number): string;
        static StiEncode(): void;
    }
}
export namespace Stimulsoft.Report.Events {
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiGetTitleEventArgs extends EventArgs {
        value: string;
        index: number;
        series: IStiSeries;
    }
}
export namespace Stimulsoft.Report.Events {
    import EventArgs = Stimulsoft.System.EventArgs;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    class StiNewAutoSeriesEventArgs extends EventArgs {
        seriesIndex: number;
        color: any;
        series: IStiSeries;
        constructor(seriesIndex: number, series: IStiSeries, color: any);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import Color = Stimulsoft.System.Drawing.Color;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import PointD = Stimulsoft.System.Drawing.Point;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    class StiChartHelper {
        static globalDurationElement: TimeSpan;
        static globalBeginTimeElement: TimeSpan;
        static fillSeriesData(series: StiSeries, items: StiDataItem[]): void;
        static getFilterData(report: StiReport, filter: StiChartFilter, filterMethodName: string): any;
        static getFilterResult(filter: StiChartFilter, itemArgument: any, itemValue: any, itemValueEnd: any, itemValueOpen: any, itemValueClose: any, itemValueLow: any, itemValueHigh: any, data: any): boolean;
        static convertStringToColor(colorStr: string): Color;
        static createChart(masterChart: StiChart, chartComp: StiChart): void;
        static getShorterListPoints(series: StiSeries): PointD[];
        private static checkParetoValues;
        private static checkValueNaN;
        private static checkArgumentsDateTimeStep;
        private static ceilDateTimeByStep;
        private static roundDateTimeByStep;
        static checkWaterfallTotals(chart: IStiChart): void;
        private static createTopN;
        private static createValuesTopN;
        private static createValuesWeightsTopN;
        private static getNextDate;
        private static getKey;
        private static sortArray;
        private static findIndex;
        private static getValueForDate;
        private static getTotalTimeSpans;
        private static isArgumentsDateTime;
        private static maximumDate;
        private static minimumDate;
        private static getAutoSeriesColorFromautoSeriesColorDataColumn;
        private static getAutoSeriesTitleFromAutoSeriesTitleDataColumn;
        private static getAutoSeriesKeysFromAutoSeriesKeyDataColumn;
        private static setTitle;
        private static setCutPieList;
        private static getArguments;
        private static getArgumentsFromArgumentExpression;
        private static getArgumentsFromArgumentDataColumn;
        private static getArgumentsFromListOfArguments;
        private static getValues;
        private static getValuesFromValueExpression;
        private static getValuesFromValueDataColumn;
        private static getValuesFromListOfValues;
        private static getValuesEnd;
        private static getValuesEndFromValueEndExpression;
        private static getValuesEndFromValueDataColumnEnd;
        private static getValuesEndFromListOfValuesEnd;
        private static getValuesOpen;
        private static getValuesOpenFromValuesOpenExpression;
        private static getValuesOpenFromValueDataColumnOpen;
        private static getValuesOpenFromListOfValuesOpen;
        private static getValuesClose;
        private static getValuesCloseFromValuesCloseExpression;
        private static getValuesCloseFromValueDataColumnClose;
        private static getValuesCloseFromListOfValuesClose;
        private static getValuesHigh;
        private static getValuesHighFromValuesHighExpression;
        private static getValuesHighFromValueDataColumnHigh;
        private static getValuesHighFromListOfValuesHigh;
        private static getValuesLow;
        private static getValuesLowFromValuesLowExpression;
        private static getValuesLowFromValueDataColumnLow;
        private static getValuesLowFromListOfValuesLow;
        private static getWeights;
        private static getWeightsWeightExpression;
        private static getWeightsFromWeightDataColumn;
        private static getWeightsFromListOfWeights;
        private static getXValues;
        private static getXValuesFromXvalueExpression;
        private static getXValuesFromXValueDataColumn;
        private static getXValuesFromListOfXValues;
        private static getYValues;
        private static getYValuesFromXvalueExpression;
        private static getYValuesFromYValueDataColumn;
        private static getYValuesFromListOfYValues;
        private static getHyperlinks;
        private static getHyperlinksFromHyperlinkExpression;
        private static getHyperlinksFromHyperlinkDataColumn;
        private static getHyperlinksFromListOfHyperlinks;
        private static getTags;
        private static getTagsFromTagExpression;
        private static getTagsFromTagDataColumn;
        private static getTagsFromListOfTags;
        private static getToolTips;
        private static getToolTipsFromToolTipExpression;
        private static getToolTipsFromToolTipDataColumn;
        private static getToolTipsFromListOfToolTips;
        static getAnimationCompatibilitySeries(series1: IStiSeries, series2: IStiSeries): boolean;
        private static getAnimationSeriesType;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiArea extends StiService implements IStiJsonReportObject, IStiArea, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        static loadFromJsonObjectInternal(jObject: StiJson): IStiArea;
        static loadAreaFromXml(xmlNode: XmlNode, chart: Stimulsoft.Report.Components.StiChart): StiArea;
        get propName(): string;
        clone(): StiArea;
        toString(): string;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        get serviceCategory(): string;
        get serviceType(): Stimulsoft.System.Type;
        get isDefaultSeriesTypeFullStackedColumnSeries(): boolean;
        get isDefaultSeriesTypeFullStackedBarSeries(): boolean;
        core: StiAreaCoreXF;
        chart: IStiChart;
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        colorEach: boolean;
        showShadow: boolean;
        borderColor: Color;
        borderThickness: number;
        brush: StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarArea extends StiArea implements IStiJsonReportObject, IStiRadarArea, IStiArea, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiRadarArea;
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        private _interlacingHor;
        get interlacingHor(): IStiInterlacingHor;
        set interlacingHor(value: IStiInterlacingHor);
        private _interlacingVert;
        get interlacingVert(): IStiInterlacingVert;
        set interlacingVert(value: IStiInterlacingVert);
        private _gridLinesHor;
        get gridLinesHor(): IStiRadarGridLinesHor;
        set gridLinesHor(value: IStiRadarGridLinesHor);
        private _gridLinesVert;
        get gridLinesVert(): IStiRadarGridLinesVert;
        set gridLinesVert(value: IStiRadarGridLinesVert);
        radarStyle: StiRadarStyle;
        private _xAxis;
        get xAxis(): IStiXRadarAxis;
        set xAxis(value: IStiXRadarAxis);
        private _yAxis;
        get yAxis(): IStiYRadarAxis;
        set yAxis(value: IStiYRadarAxis);
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiChartCoreXF implements ICloneable, IStiApplyStyle, IStiChartCoreXF {
        implements(): any[];
        clone(): any;
        applyStyle(style: IStiChartStyle): void;
        render(context: StiContext, rect: RectangleD, useMargins: boolean): StiCellGeom;
        private setLegendRect;
        chart: IStiChart;
        fullRectangle: RectangleD;
        constructor(chart: IStiChart);
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiChartTable implements IStiJsonReportObject, IStiChartTable, ICloneable {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(m: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        get propName(): string;
        clone(): StiChartTable;
        get font(): Font;
        set font(value: Font);
        visible: boolean;
        allowApplyStyle: boolean;
        markerVisible: boolean;
        gridLineColor: Color;
        get textColor(): Color;
        set textColor(value: Color);
        gridLinesHor: boolean;
        gridLinesVert: boolean;
        gridOutline: boolean;
        format: string;
        header: IStiChartTableHeader;
        core: StiChartTableCoreXF;
        dataCells: StiChartTableDataCells;
        chart: IStiChart;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiChartTitle implements IStiChartTitle, ICloneable, IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        get propName(): string;
        clone(): StiChartTitle;
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        core: StiChartTitleCoreXF;
        font: Font;
        text: string;
        brush: StiBrush;
        antialiasing: boolean;
        alignment: StringAlignment;
        dock: StiChartTitleDock;
        spacing: number;
        visible: boolean;
        chart: IStiChart;
        constructor(font?: Font, text?: string, brush?: StiBrush, antialiasing?: boolean, alignment?: StringAlignment, dock?: StiChartTitleDock, spacing?: number, visible?: boolean, allowApplyStyle?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiStripsCollection extends CollectionBase<IStiStrips> implements IStiJsonReportObject, IStiApplyStyle, IStiStripsCollection {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        applyStyle(style: IStiChartStyle): void;
        private getStripsTitle;
        add(value: IStiStrips): void;
        chart: StiChart;
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiConstantLinesCollection extends CollectionBase<IStiConstantLines> implements IStiJsonReportObject, IStiApplyStyle, IStiConstantLinesCollection {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        applyStyle(style: IStiChartStyle): void;
        private getConstantLineTitle;
        add(value: IStiConstantLines): void;
        chart: StiChart;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    class StiSeriesLabels extends StiService implements IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        saveToJsonObject(m: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        static loadFromJsonObjectInternal(jObject: StiJson, chart: IStiChart): IStiSeriesLabels;
        static loadLabelsFromXml(xmlNode: XmlNode, chart: IStiChart): StiSeriesLabels;
        get propName(): string;
        clone(): StiSeriesLabels;
        get serviceName(): string;
        get serviceCategory(): string;
        get serviceType(): Stimulsoft.System.Type;
        preventIntersection: boolean;
        core: StiSeriesLabelsCoreXF;
        get axisCore(): StiAxisSeriesLabelsCoreXF;
        get pieCore(): StiPieSeriesLabelsCoreXF;
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        get conditions(): StiChartConditionsCollection;
        set conditions(value: StiChartConditionsCollection);
        get showOnZeroValues(): boolean;
        set showOnZeroValues(value: boolean);
        showZeros: boolean;
        showNulls: boolean;
        markerVisible: boolean;
        markerSize: SizeD;
        markerAlignment: StiMarkerAlignment;
        step: number;
        valueType: StiSeriesLabelsValueType;
        valueTypeSeparator: string;
        legendValueType: StiSeriesLabelsValueType;
        textBefore: string;
        textAfter: string;
        angle: number;
        format: string;
        antialiasing: boolean;
        visible: boolean;
        drawBorder: boolean;
        useSeriesColor: boolean;
        labelColor: Color;
        borderColor: Color;
        brush: StiBrush;
        font: Font;
        chart: IStiChart;
        wordWrap: boolean;
        width: number;
        formatService: StiFormatService;
        toString(): string;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisSeriesLabels extends StiSeriesLabels implements IStiSeriesLabels, ICloneable, IStiAxisSeriesLabels {
        implements(): any[];
        meta(): StiMeta[];
        private _showInPercent;
        get showInPercent(): boolean;
        set showInPercent(value: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCenterAxisLabels extends StiAxisSeriesLabels implements IStiJsonReportObject, IStiSeriesLabels, IStiCenterAxisLabels, IStiAxisSeriesLabels, ICloneable {
        implements(): any[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiAxis implements IStiAxis, IStiJsonReportObject {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiAxis;
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        get step(): number;
        set step(value: number);
        private _title;
        get title(): IStiAxisTitle;
        set title(value: IStiAxisTitle);
        get titleDirection(): StiLegendDirection;
        set titleDirection(value: StiLegendDirection);
        logarithmicScale: boolean;
        core: StiAxisCoreXF;
        startFromZero: boolean;
        interaction: IStiAxisInteraction;
        labels: IStiAxisLabels;
        range: IStiAxisRange;
        ticks: IStiAxisTicks;
        arrowStyle: StiArrowStyle;
        lineStyle: StiPenStyle;
        lineColor: Color;
        lineWidth: number;
        visible: boolean;
        area: IStiAxisArea;
        info: StiAxisInfoXF;
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, allowApplyStyle?: boolean, logarithmicScale?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiYAxis extends StiAxis implements IStiJsonReportObject, IStiYAxis, ICloneable, IStiAxis {
        implements(): any[];
        meta(): StiMeta[];
        get propName(): string;
        showYAxis: StiShowYAxis;
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, showYAxis?: StiShowYAxis, allowApplyStyle?: boolean, logarithmicScale?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiYRightAxis extends StiYAxis implements IStiJsonReportObject, IStiYAxis, ICloneable, IStiAxis, IStiYRightAxis {
        implements(): any[];
        meta(): StiMeta[];
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, allowApplyStyle?: boolean, logarithmicScale?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiXAxis extends StiAxis implements IStiJsonReportObject, IStiAxis, IStiXAxis, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        get propName(): string;
        showEdgeValues: boolean;
        showXAxis: StiShowXAxis;
        dateTimeStep: IStiAxisDateTimeStep;
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, showXAxis?: StiShowXAxis, showEdgeValues?: boolean, allowApplyStyle?: boolean, dateTimeStep?: IStiAxisDateTimeStep, logarithmicScale?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiXTopAxis extends StiXAxis implements IStiXTopAxis, ICloneable, IStiAxis, IStiXAxis, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, showXAxis?: StiShowXAxis, showEdgeValues?: boolean, allowApplyStyle?: boolean, logarithmicScale?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiYLeftAxis extends StiYAxis implements IStiJsonReportObject, IStiYAxis, ICloneable, IStiAxis, IStiYLeftAxis {
        implements(): any[];
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, showYAxis?: StiShowYAxis, allowApplyStyle?: boolean, logarithmicScale?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiAxisLabels implements IStiJsonReportObject, IStiAxisLabels, ICloneable {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiAxisLabels;
        core: StiAxisLabelsCoreXF;
        allowApplyStyle: boolean;
        format: string;
        angle: number;
        width: number;
        textBefore: string;
        textAfter: string;
        font: Font;
        antialiasing: boolean;
        placement: StiLabelsPlacement;
        color: Color;
        textAlignment: StiHorAlignment;
        step: number;
        wordWrap: boolean;
        calculatedStep: number;
        formatService: StiFormatService;
        constructor(format?: string, textBefore?: string, textAfter?: string, angle?: number, font?: Font, antialiasing?: boolean, placement?: StiLabelsPlacement, color?: Color, width?: number, textAlignment?: StiHorAlignment, step?: number, allowApplyStyle?: boolean, wordWrap?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisRange implements IStiJsonReportObject, ICloneable, IStiAxisRange {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiAxisRange;
        minimum: number;
        maximum: number;
        auto: boolean;
        constructor(auto?: boolean, minimum?: number, maximum?: number);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisTicks implements IStiJsonReportObject, IStiAxisTicks, ICloneable {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiAxisTicks;
        private _lengthUnderLabels;
        get lengthUnderLabels(): number;
        set lengthUnderLabels(value: number);
        private _length;
        get length(): number;
        set length(value: number);
        private _minorLength;
        get minorLength(): number;
        set minorLength(value: number);
        private _minorCount;
        get minorCount(): number;
        set minorCount(value: number);
        private _step;
        get step(): number;
        set step(value: number);
        minorVisible: boolean;
        visible: boolean;
        constructor(visible?: boolean, length?: number, minorVisible?: boolean, minorLength?: number, minorCount?: number, step?: number, lengthUnderLabels?: number);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisInteraction implements IStiJsonReportObject, IStiAxisInteraction, ICloneable {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiAxisInteraction;
        showScrollBar: boolean;
        rangeScrollEnabled: boolean;
        constructor(showScrollBar?: boolean, rangeScrollEnabled?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiAxisDateTimeStep implements IStiAxisDateTimeStep, IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiAxisDateTimeStep;
        step: StiTimeDateStep;
        numberOfValues: number;
        interpolation: boolean;
        aggregation: StiDateTimeStepAggregation;
        constructor(step?: StiTimeDateStep, numberOfValues?: number, interpolation?: boolean, aggregation?: StiDateTimeStepAggregation);
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiXBottomAxis extends StiXAxis implements IStiJsonReportObject, IStiXAxis, ICloneable, IStiXBottomAxis, IStiAxis {
        implements(): any[];
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, showXAxis?: StiShowXAxis, showEdgeValues?: boolean, allowApplyStyle?: boolean, dateTimeStep?: IStiAxisDateTimeStep, logarithmicScale?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGridLines implements IStiJsonReportObject, IStiGridLines, ICloneable {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        needSetAreaJsonPropertyInternal: boolean;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        get propName(): string;
        clone(): StiGridLines;
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        core: StiGridLinesCoreXF;
        color: Color;
        minorColor: Color;
        style: StiPenStyle;
        minorStyle: StiPenStyle;
        visible: boolean;
        minorVisible: boolean;
        area: IStiArea;
        private _minorCount;
        get minorCount(): number;
        set minorCount(value: number);
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, minorColor?: Color, minorStyle?: StiPenStyle, minorVisible?: boolean, minorCount?: number, allowApplyStyle?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGridLinesVert extends StiGridLines implements IStiJsonReportObject, IStiGridLines, ICloneable, IStiGridLinesVert {
        implements(): any[];
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, minorColor?: Color, minorStyle?: StiPenStyle, minorVisible?: boolean, minorCount?: number, allowApplyStyle?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGridLinesHor extends StiGridLines implements IStiJsonReportObject, IStiGridLines, IStiGridLinesHor, ICloneable {
        implements(): any[];
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, minorColor?: Color, minorStyle?: StiPenStyle, minorVisible?: boolean, minorCount?: number, allowApplyStyle?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiInterlacing implements IStiInterlacing, ICloneable, IStiJsonReportObject {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        needSetAreaJsonPropertyInternal: boolean;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        get propName(): string;
        clone(): StiInterlacing;
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        core: StiInterlacingCoreXF;
        interlacedBrush: StiBrush;
        visible: boolean;
        area: IStiArea;
        constructor(interlacedBrush?: StiBrush, visible?: boolean, allowApplyStyle?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiInterlacingVert extends StiInterlacing implements IStiInterlacingVert {
        implements(): any[];
        constructor(interlacedBrush?: StiBrush, visible?: boolean, allowApplyStyle?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiInterlacingHor extends StiInterlacing implements IStiInterlacing, IStiInterlacingHor, IStiJsonReportObject, ICloneable {
        implements(): any[];
        constructor(interlacedBrush?: StiBrush, visible?: boolean, allowApplyStyle?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisArea extends StiArea implements IStiJsonReportObject, IStiAxisArea, IStiArea, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiAxisArea;
        get axisCore(): StiAxisAreaCoreXF;
        private _interlacingHor;
        get interlacingHor(): IStiInterlacingHor;
        set interlacingHor(value: IStiInterlacingHor);
        private _interlacingVert;
        get interlacingVert(): IStiInterlacingVert;
        set interlacingVert(value: IStiInterlacingVert);
        private _gridLinesHor;
        get gridLinesHor(): IStiGridLinesHor;
        set gridLinesHor(value: IStiGridLinesHor);
        private _gridLinesHorRight;
        get gridLinesHorRight(): IStiGridLinesHor;
        set gridLinesHorRight(value: IStiGridLinesHor);
        private _gridLinesVert;
        get gridLinesVert(): IStiGridLinesVert;
        set gridLinesVert(value: IStiGridLinesVert);
        private _yAxis;
        get yAxis(): IStiYAxis;
        set yAxis(value: IStiYAxis);
        private _yRightAxis;
        get yRightAxis(): IStiYAxis;
        set yRightAxis(value: IStiYAxis);
        private _xAxis;
        get xAxis(): IStiXAxis;
        set xAxis(value: IStiXAxis);
        private _xTopAxis;
        get xTopAxis(): IStiXAxis;
        set xTopAxis(value: IStiXAxis);
        reverseHor: boolean;
        reverseVert: boolean;
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiClusteredColumnArea extends StiAxisArea implements IStiJsonReportObject, IStiClusteredColumnArea, IStiAxisArea, IStiRoundValuesArea, ICloneable, IStiArea {
        implements(): any[];
        meta(): StiMeta[];
        roundValues: boolean;
        sideBySide: boolean;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiSeriesCollection extends CollectionBase<IStiSeries> implements IStiJsonReportObject, IStiApplyStyle, IStiSeriesCollection {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, chart: StiChart): void;
        applyStyle(style: IStiChartStyle): void;
        private getSeriesTitle;
        add(value: IStiSeries): void;
        insert(index: number, value: IStiSeries): void;
        remove(item: IStiSeries): void;
        removeAt(index: number): void;
        getByName(name: string): IStiSeries;
        setByName(name: string, value: IStiSeries): void;
        seriesAdded: Function;
        private invokeSeriesAdded;
        seriesRemoved: Function;
        private invokeSeriesRemoved;
        chart: StiChart;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiFilterItem = Stimulsoft.Report.Components.StiFilterItem;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    class StiChartFilter implements IStiJsonReportObject, IStiChartFilter, ICloneable {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiChartFilter;
        get index(): number;
        condition: StiFilterCondition;
        dataType: StiFilterDataType;
        item: StiFilterItem;
        private _valueObj;
        get value(): string;
        set value(value: string);
        toString(): string;
        filters: StiChartFiltersCollection;
        constructor(item?: StiFilterItem, dataType?: StiFilterDataType, condition?: StiFilterCondition, value?: string);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    import StiFilterItem = Stimulsoft.Report.Components.StiFilterItem;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiChartCondition extends StiChartFilter implements IStiChartCondition, IStiChartFilter, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiChartCondition;
        color: Color;
        markerType: StiMarkerType;
        markerAngle: number;
        conditions: StiChartConditionsCollection;
        constructor(color?: Color, item?: StiFilterItem, dataType?: StiFilterDataType, condition?: StiFilterCondition, value?: string, markerType?: StiMarkerType, markerAngle?: number);
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiChartConditionsCollection extends CollectionBase<StiChartCondition> implements IStiJsonReportObject, ICloneable, IStiChartConditionsCollection {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiChartConditionsCollection;
        add(condition: StiChartCondition): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiNewAutoSeriesEventArgs = Stimulsoft.Report.Events.StiNewAutoSeriesEventArgs;
    import StiGetTitleEventArgs = Stimulsoft.Report.Events.StiGetTitleEventArgs;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiSeries extends StiService implements IStiJsonReportObject, ICloneable, IStiSeries, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        get propName(): string;
        clone(): StiSeries;
        private static storedCulture;
        baseTransform(): void;
        get parent(): StiComponent;
        get serviceName(): string;
        get serviceCategory(): string;
        get serviceType(): Stimulsoft.System.Type;
        allowApplyStyle: boolean;
        core: StiSeriesCoreXF;
        format: string;
        sortBy: StiSeriesSortType;
        sortDirection: StiSeriesSortDirection;
        showInLegend: boolean;
        get showLabels(): boolean;
        set showLabels(value: boolean);
        private _showSeriesLabels;
        get showSeriesLabels(): StiShowSeriesLabels;
        set showSeriesLabels(value: StiShowSeriesLabels);
        showShadow: boolean;
        filterMode: StiFilterMode;
        filters: StiChartFiltersCollection;
        conditions: StiChartConditionsCollection;
        topN: IStiSeriesTopN;
        yAxis: StiSeriesYAxis;
        private _seriesLabels;
        get seriesLabels(): IStiSeriesLabels;
        set seriesLabels(value: IStiSeriesLabels);
        get trendLine(): IStiTrendLine;
        set trendLine(value: IStiTrendLine);
        private _chart;
        get chart(): IStiChart;
        set chart(value: IStiChart);
        trendLines: StiTrendLinesCollection;
        isTotalLabel: boolean;
        valuesStart: number[];
        private _values;
        get values(): number[];
        set values(value: number[]);
        valueDataColumn: string;
        get valuesString(): string;
        set valuesString(value: string);
        originalArguments: any[];
        originalTopNValues: any[];
        private _arguments;
        get arguments(): any[];
        set arguments(value: any[]);
        protected getArguments(): any[];
        protected setArguments(value: any[]): void;
        argumentDataColumn: string;
        get argumentsString(): string;
        set argumentsString(value: string);
        autoSeriesTitleDataColumn: string;
        autoSeriesKeyDataColumn: string;
        autoSeriesColorDataColumn: string;
        private _toolTips;
        get toolTips(): string[];
        set toolTips(value: string[]);
        toolTipDataColumn: string;
        get toolTipsString(): string;
        set toolTipsString(value: string);
        private _tags;
        get tags(): any[];
        set tags(value: any[]);
        tagDataColumn: string;
        get tagString(): string;
        set tagString(value: string);
        private _hyperlinks;
        get hyperlinks(): string[];
        set hyperlinks(value: string[]);
        hyperlinkDataColumn: string;
        get hyperlinkString(): string;
        set hyperlinkString(value: string);
        drillDownEnabled: boolean;
        drillDownReport: string;
        get drillDownPage(): StiPage;
        set drillDownPage(value: StiPage);
        drillDownPageGuid: string;
        allowSeries: boolean;
        allowSeriesElements: boolean;
        get coreTitle(): string;
        set coreTitle(value: string);
        isDashboard: boolean;
        legendColor: Color;
        private _interaction;
        get interaction(): IStiSeriesInteraction;
        set interaction(value: IStiSeriesInteraction);
        processSeriesColors(pointIndex: number, seriesColor: Color): Color;
        processSeriesMarkerType(pointIndex: number, markerType: StiMarkerType): StiMarkerType;
        processSeriesMarkerAngle(pointIndex: number, markerAngle: number): number;
        processSeriesMarkerVisible(pointIndex: number): boolean;
        processSeriesBrushes(pointIndex: number, seriesBrush: StiBrush): StiBrush;
        private getConditionResult;
        toString(): string;
        static tryParseValue(value: string, culture: string, refResult: {
            ref: number;
        }): boolean;
        static getNullableValuesFromString(series: StiSeries, list: string): number[];
        static getValuesFromString(list: string): number[];
        static getStringsFromString(list: string): string[];
        static getArgumentsFromString(list: string): any[];
        getDefaultAreaType(): Stimulsoft.System.Type;
        getDefaultLegendType(): Stimulsoft.System.Type;
        newAutoSeries: Function;
        invokeNewAutoSeries(e: StiNewAutoSeriesEventArgs): void;
        getValue: Function;
        protected onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValues: Function;
        protected onGetListOfValues(e: StiGetValueEventArgs): void;
        invokeGetListOfValues(sender: StiComponent, e: StiGetValueEventArgs, series: StiSeries): void;
        getArgument: Function;
        protected onGetArgument(e: StiValueEventArgs): void;
        invokeGetArgument(sender: StiComponent, e: StiValueEventArgs): void;
        getListOfArguments: Function;
        protected onGetListOfArguments(e: StiGetValueEventArgs): void;
        invokeGetListOfArguments(sender: StiComponent, e: StiGetValueEventArgs): void;
        getTitle: Function;
        protected onGetTitle(e: StiGetTitleEventArgs): void;
        invokeGetTitle(sender: StiComponent, e: StiGetTitleEventArgs): void;
        getToolTip: Function;
        protected onGetToolTip(e: StiValueEventArgs): void;
        invokeGetToolTip(sender: StiComponent, e: StiValueEventArgs): void;
        getListOfToolTips: Function;
        protected onGetListOfToolTips(e: StiGetValueEventArgs): void;
        invokeGetListOfToolTips(sender: StiComponent, e: StiGetValueEventArgs): void;
        getTag: Function;
        protected onGetTag(e: StiValueEventArgs): void;
        invokeGetTag(sender: any, e: StiValueEventArgs): void;
        getListOfTags: Function;
        protected onGetListOfTags(e: StiGetValueEventArgs): void;
        invokeGetListOfTags(sender: StiComponent, e: StiGetValueEventArgs): void;
        getHyperlink: Function;
        protected onGetHyperlink(e: StiValueEventArgs): void;
        invokeGetHyperlink(sender: any, e: StiValueEventArgs): void;
        getListOfHyperlinks: Function;
        protected onGetListOfHyperlinks(e: StiGetValueEventArgs): void;
        invokeGetListOfHyperlinks(sender: StiComponent, e: StiGetValueEventArgs): void;
        private valueObj;
        get value(): string;
        set value(value: string);
        listOfValues: string;
        argument: string;
        listOfArguments: string;
        titleValue: string;
        title: string;
        toolTip: string;
        listOfToolTips: string;
        tag: string;
        listOfTags: string;
        hyperlink: string;
        listOfHyperlinks: string;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    import StiText = Stimulsoft.Report.Components.StiText;
    class StiChartInfo extends StiComponentInfo implements IStiChartInfo {
        implements(): any[];
        storedForProcessAtEndChart: StiChart;
        interactiveComps: StiText[];
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiChartStyle extends StiBaseStyle implements IStiJsonReportObject, IStiChartStyle, ICloneable {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromXml(xmlNode: XmlNode): StiChartStyle;
        static loadFromJsonObjectInternal(jObject: StiJson): StiChartStyle;
        get serviceName(): string;
        get serviceCategory(): string;
        get serviceType(): Stimulsoft.System.Type;
        isOffice2015Style: boolean;
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        core: StiStyleCoreXF;
        toString(): string;
        compareChartStyle(style: StiChartStyle): boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle25 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle29 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiLegend implements IStiJsonReportObject, ICloneable, IStiLegend {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        static loadFromJsonObjectInternal(jObject: StiJson, chart: IStiChart): IStiLegend;
        static loadLabelsFromXml(xmlNode: XmlNode, chart: IStiChart): StiLegend;
        get propName(): string;
        clone(): StiLegend;
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        core: StiLegendCoreXF;
        chart: IStiChart;
        hideSeriesWithEmptyTitle: boolean;
        showShadow: boolean;
        borderColor: Color;
        brush: StiBrush;
        titleColor: Color;
        labelsColor: Color;
        direction: StiLegendDirection;
        horAlignment: StiLegendHorAlignment;
        vertAlignment: StiLegendVertAlignment;
        titleFont: Font;
        font: Font;
        visible: boolean;
        markerVisible: boolean;
        markerBorder: boolean;
        markerSize: SizeD;
        markerAlignment: StiMarkerAlignment;
        horSpacing: number;
        vertSpacing: number;
        size: SizeD;
        title: string;
        columnWidth: number;
        wordWrap: boolean;
        private _columns;
        get columns(): number;
        set columns(value: number);
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiTreemapSeries extends StiSeries implements IStiJsonReportObject, IStiTreemapSeries, IStiSeriesBorderThickness, IStiCornerRadius, IStiFontIconsSeries, ICloneable, IStiSeries {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiTreemapSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        borderColor: Color;
        borderThickness: number;
        cornerRadius: StiCornerRadius;
        brush: StiBrush;
        icon: StiFontIcons;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiPictorialSeries extends StiSeries implements IStiPictorialSeries, IStiFontIconsSeries, ICloneable, IStiSeries, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        brush: StiBrush;
        icon: StiFontIcons;
        clone(): StiPictorialSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Components {
    import Font = Stimulsoft.System.Drawing.Font;
    import StiChartEditorType = Stimulsoft.Report.Chart.StiChartEditorType;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import EventArgs = Stimulsoft.System.EventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiChartConditionsCollection = Stimulsoft.Report.Chart.StiChartConditionsCollection;
    import IStiArea = Stimulsoft.Report.Chart.IStiArea;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import IStiChartTable = Stimulsoft.Report.Chart.IStiChartTable;
    import IStiChartTitle = Stimulsoft.Report.Chart.IStiChartTitle;
    import IStiLegend = Stimulsoft.Report.Chart.IStiLegend;
    import IStiSeriesLabels = Stimulsoft.Report.Chart.IStiSeriesLabels;
    import StiChartCoreXF = Stimulsoft.Report.Chart.StiChartCoreXF;
    import StiChartInfo = Stimulsoft.Report.Chart.StiChartInfo;
    import StiConstantLinesCollection = Stimulsoft.Report.Chart.StiConstantLinesCollection;
    import IStiChartStyle = Stimulsoft.Report.Chart.IStiChartStyle;
    import StiStripsCollection = Stimulsoft.Report.Chart.StiStripsCollection;
    import StiSeriesCollection = Stimulsoft.Report.Chart.StiSeriesCollection;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiImageRotation = Stimulsoft.Report.Components.StiImageRotation;
    import StiComponentType = Stimulsoft.Report.Components.StiComponentType;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiFiltersCollection = Stimulsoft.Report.Components.StiFiltersCollection;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    import List = Stimulsoft.System.Collections.List;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiChart extends StiComponent implements IStiBorder, IStiBusinessObject, IStiBrush, IStiDataSource, IStiDataRelation, IStiMasterComponent, IStiSort, IStiFilter, IStiExportImage, IStiExportImageExtended, IStiIgnoryStyle, IStiGlobalizationProvider, IStiChart, IStiJsonReportObject, IStiGetFonts {
        implements(): any[];
        jsonMasterComponentTemp: string;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        convertToHInches(value: number): number;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        clone(): StiChart;
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        filterMethodHandler: Function;
        filterMode: StiFilterMode;
        filters: StiFiltersCollection;
        get filter(): string;
        set filter(value: string);
        filterOn: boolean;
        border: StiBorder;
        brush: StiBrush;
        private _sort;
        get sort(): string[];
        set sort(value: string[]);
        get dataSource(): StiDataSource;
        private _dataSourceName;
        get dataSourceName(): string;
        set dataSourceName(value: string);
        get isDataSourceEmpty(): boolean;
        get isBusinessObjectEmpty(): boolean;
        get businessObject(): StiBusinessObject;
        private _businessObjectGuid;
        get businessObjectGuid(): string;
        set businessObjectGuid(value: string);
        masterComponent: StiComponent;
        countData: number;
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        isEofValue: boolean;
        get isEof(): boolean;
        set isEof(value: boolean);
        isBofValue: boolean;
        get isBof(): boolean;
        set isBof(value: boolean);
        get isEmpty(): boolean;
        positionValue: number;
        get position(): number;
        set position(value: number);
        get count(): number;
        private isCacheValues;
        private cachedCount;
        private cachedIsBusinessObjectEmpty;
        private cachedIsDataSourceEmpty;
        private cachedDataSource;
        private cachedBusinessObject;
        cacheValues(cache: boolean): void;
        get dataRelation(): StiDataRelation;
        dataRelationName: string;
        processAtEnd: boolean;
        getFonts(): Font[];
        get priority(): number;
        get localizedCategory(): string;
        defaultClientRectangle: RectangleD;
        get componentType(): StiComponentType;
        get localizedName(): string;
        invokeEvents(): void;
        protected onProcessChart(e: EventArgs): void;
        invokeProcessChart(sender: any, e: EventArgs): void;
        processChartEvent: StiEvent;
        private series_SeriesAdded;
        private series_SeriesRemoved;
        seriesLabelsConditions: StiChartConditionsCollection;
        get chartType(): IStiArea;
        set chartType(value: IStiArea);
        isDashboard: boolean;
        applyStyle(): void;
        simplifyValues(): void;
        core: StiChartCoreXF;
        rotation: StiImageRotation;
        editorType: StiChartEditorType;
        private _series;
        get series(): StiSeriesCollection;
        set series(value: StiSeriesCollection);
        private _area;
        get area(): IStiArea;
        set area(value: IStiArea);
        private _table;
        get table(): IStiChartTable;
        set table(value: IStiChartTable);
        private _style;
        get style(): IStiChartStyle;
        set style(value: IStiChartStyle);
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        customStyleName: string;
        private _horSpacing;
        get horSpacing(): number;
        set horSpacing(value: number);
        private _vertSpacing;
        get vertSpacing(): number;
        set vertSpacing(value: number);
        private _seriesLabels;
        get seriesLabels(): IStiSeriesLabels;
        set seriesLabels(value: IStiSeriesLabels);
        get labels(): IStiSeriesLabels;
        set labels(value: IStiSeriesLabels);
        private _legend;
        get legend(): IStiLegend;
        set legend(value: IStiLegend);
        private _title;
        get title(): IStiChartTitle;
        set title(value: IStiChartTitle);
        private _strips;
        get strips(): StiStripsCollection;
        set strips(value: StiStripsCollection);
        private _constantLines;
        get constantLines(): StiConstantLinesCollection;
        set constantLines(value: StiConstantLinesCollection);
        isAnimation: boolean;
        isAnimationChangingValues: boolean;
        chartInfo: StiChartInfo;
        previousAnimations: List<StiAnimation>;
        sortAnimation: boolean;
        constructor(rect?: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiChartOptions {
        private static _oldChartPercentMode;
        static get oldChartPercentMode(): boolean;
        static set oldChartPercentMode(value: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import PointD = Stimulsoft.System.Drawing.Point;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
    class StiInteractionOptions {
        updateContext: boolean;
        recallEvent: boolean;
        recallTime: TimeSpan;
        isRecalled: boolean;
        mousePoint: PointD;
        dragEnabled: boolean;
        dragDelta: SizeD;
        interactionToolTip: string;
        interactionHyperlink: string;
        seriesInteractionData: StiSeriesInteractionData;
    }
}
export namespace Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiPointHelper {
        private static getPointClassify;
        static isPointInTriangle(p: PointD, a: PointD, b: PointD, c: PointD): boolean;
        static isPointInPolygon(p: PointD, points: PointD[]): boolean;
        static getLineOffsetRectangle(point1: PointD, point2: PointD, offset: number): PointD[];
        static isLineContainsPoint(startPoint: PointD, endPoint: PointD, offset: number, point: PointD): boolean;
        static optimizePoints(points: PointD[]): PointD[];
    }
}
export namespace Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSimplifyHelper {
        private static getSquareDistance;
        private static getSquareSegmentDistance;
        private static simplifyRadialDistance;
        private static simplifyDouglasPeucker;
        static simplify(points: PointD[], tolerance: number, highestQuality: boolean): PointD[];
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiBoxAndWhiskerHelper {
        static checkArgument(chart: IStiChart): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiHeatmapHelper {
        static getColorFromRange(colors: Color[], min: number, max: number, value: number): Color;
        static getColorAtOffset(colors: Color[], offsets: number[], targetOffset: number): Color;
        static interpolate(start: number, end: number, factor: number): number;
        static getLinearGradientPoints(count: number): number[];
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    class StiHistogramHelper {
        static checkValuesAndArguments(series: IStiSeries, formatService: StiFormatService): void;
        private static roundToSignificantDigits;
        private static getStandardDeviation;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiPie3dHelper {
        static readonly brightnessEnhancementFactor1 = 0.3;
        static createColorWithCorrectedLightness(color: Color, correctionFactor: number): Color;
        static getActualAngle(rect: Rectangle, transformedAngle: number): number;
        static transformAngle(rect: Rectangle, angle: number): number;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiEmptyCellsAs = Stimulsoft.Report.Dashboard.StiEmptyCellsAs;
    import StiShowEmptyCellsAs = Stimulsoft.Report.Chart.StiShowEmptyCellsAs;
    class StiShowEmptyCellsAsHelper {
        static convert(emptyCellsAs: StiEmptyCellsAs): StiShowEmptyCellsAs;
        static seriesIsEmtyCellsAs(series: StiSeries): boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiTextContentHelper {
        static getMeasureText(context: StiContext, text: string, font: Font, maxWidth: number): string;
        static getMeasureText2(context: StiContext, text: string, font: StiFontGeom, maxWidth: number): string;
    }
}
export namespace Stimulsoft.Report.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAreaCoreXF implements ICloneable, IStiApplyStyle, IStiAreaCoreXF, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        clone(): StiAreaCoreXF;
        applyStyle(style: IStiChartStyle): void;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        protected prepareInfo(rect: RectangleD): void;
        checkInLabelsTypes(typeForCheck: Stimulsoft.System.Type): boolean;
        getSeries(): IStiSeries[];
        isAcceptableSeries(seriesType: Stimulsoft.System.Type): boolean;
        isAcceptableSeriesLabels(seriesLabelsType: Stimulsoft.System.Type): boolean;
        area: IStiArea;
        get localizedName(): string;
        get seriesOrientation(): StiChartSeriesOrientation;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiShowEmptyCellsAs = Stimulsoft.Report.Chart.StiShowEmptyCellsAs;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiShowNullsSeriesAs = Stimulsoft.Report.Chart.IStiShowNullsSeriesAs;
    import IStiShowZerosSeriesAs = Stimulsoft.Report.Chart.IStiShowZerosSeriesAs;
    class StiBaseLineSeries extends StiSeries implements IStiJsonReportObject, IStiBaseLineSeries, ICloneable, IStiSeries, IStiAllowApplyColorNegative, IStiShowNullsSeries, IStiShowNullsSeriesAs, IStiShowZerosSeries, IStiShowZerosSeriesAs {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiBaseLineSeries;
        showNulls: boolean;
        showZeros: boolean;
        get showMarker(): boolean;
        set showMarker(value: boolean);
        get markerColor(): Color;
        set markerColor(value: Color);
        get markerSize(): number;
        set markerSize(value: number);
        get markerType(): StiMarkerType;
        set markerType(value: StiMarkerType);
        marker: IStiMarker;
        lineMarker: IStiLineMarker;
        private _lineColor;
        get lineColor(): Color;
        set lineColor(value: Color);
        getLineColor(): Color;
        setLineColor(value: Color): void;
        lineStyle: StiPenStyle;
        lighting: boolean;
        private _lineWidth;
        get lineWidth(): number;
        set lineWidth(value: number);
        labelsOffset: number;
        lineColorNegative: Color;
        allowApplyColorNegative: boolean;
        private _showNullsAs;
        get showNullsAs(): StiShowEmptyCellsAs;
        set showNullsAs(value: StiShowEmptyCellsAs);
        private _showZerosAs;
        get showZerosAs(): StiShowEmptyCellsAs;
        set showZerosAs(value: StiShowEmptyCellsAs);
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiScatterSeries extends StiBaseLineSeries implements IStiBaseLineSeries, IStiSeries, ICloneable, IStiScatterSeries, IStiAllowApplyColorNegative {
        implements(): any[];
        clone(): StiScatterSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        getLineColor(): Color;
        setLineColor(value: Color): void;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiScatterLineSeries extends StiScatterSeries implements IStiScatterLineSeries, IStiBaseLineSeries, IStiScatterSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        implements(): any[];
        clone(): StiScatterLineSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisAreaCoreXF extends StiAreaCoreXF implements IStiAxisAreaCoreXF {
        implements(): any[];
        applyStyle(style: IStiChartStyle): void;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        private calculateScrollValuesX;
        private calculateScrollValuesY;
        protected prepareInfo(rect: RectangleD): void;
        private renderSeries;
        isAutoRangeXAxis(axis: IStiAxis): boolean;
        isAutoRangeYAxis(axis: IStiAxis): boolean;
        calculateMinimumAndMaximumXAxis(axis: IStiAxis): void;
        calculateMinimumAndMaximumYAxisLog(axis: IStiAxis): void;
        calculateMinimumAndMaximumYAxis(axis: IStiAxis): void;
        static getNextLowerDigit(number: number): number;
        getArgumentLabel(line: StiStripLineXF, series: IStiSeries): string;
        switchOff(): void;
        private swap;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        protected createStripLinesXAxis(axis: IStiAxis): void;
        protected checkShowEdgeValues(axis: IStiAxis): void;
        protected createStripLinesYAxis(axis: IStiAxis, isDateTimeValues: boolean): void;
        protected checkStripLinesAndMaximumMinimumXAxis(axis: IStiAxis): void;
        protected checkStripLinesAndMaximumMinimumYAxis(axis: IStiAxis): void;
        protected calculateStepX(axis: IStiAxis, topPosition: number, bottomPosition: number): void;
        protected calculateStepY(axis: IStiAxis, topPosition: number, bottomPosition: number): void;
        private checkStartFromZeroYAxis;
        calculatePositions(axis: IStiAxis, REFcollection: any, step: number, calculationForTicks: boolean): void;
        private calculateDivider;
        private static rotateStripLines;
        getDividerX(): number;
        getDividerTopX(): number;
        getDividerY(): number;
        getDividerRightY(): number;
        private getRightActualMin;
        private getRightActualMax;
        valuesCount: number;
        get scrollDistanceX(): number;
        get scrollDistanceY(): number;
        private _scrollRangeX;
        get scrollRangeX(): number;
        private _scrollRangeY;
        get scrollRangeY(): number;
        private _scrollViewX;
        get scrollViewX(): number;
        private _scrollViewY;
        get scrollViewY(): number;
        blockScrollValueX: boolean;
        blockScrollValueY: boolean;
        scrollValueX: number;
        scrollValueY: number;
        rightActualMin: number;
        rightActualMax: number;
        private _scrollDpiX;
        get scrollDpiX(): number;
        private _scrollDpiY;
        get scrollDpiY(): number;
        scrollDragStartValue: number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiClusteredColumnAreaCoreXF extends StiAxisAreaCoreXF {
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiArea = Stimulsoft.Report.Chart.IStiArea;
    class StiBoxAndWhiskerAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiScatterAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        private isArgumentDateTime;
        private isXAxisAutoRange;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        protected checkStripLinesAndMaximumMinimumXAxis(axis: IStiAxis): void;
        protected createStripLinesXAxis(axis: IStiAxis): void;
        protected createStripLinesYAxis(axis: IStiAxis, isDateTimeValues: boolean): void;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiArea = Stimulsoft.Report.Chart.IStiArea;
    class StiBubbleAreaCoreXF extends StiScatterAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiCandlestickAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        protected createStripLinesXAxis(axis: IStiAxis): void;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiClusteredBarAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get seriesOrientation(): StiChartSeriesOrientation;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiAreaAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiHistogramAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiLineAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiParetoAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiSplineAreaAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiSplineAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiSteppedAreaAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiSteppedLineAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiWaterfallAreaCoreXF extends StiAxisAreaCoreXF {
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieAreaCoreXF extends StiAreaCoreXF {
        valuesCount: number;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesCollection: IStiSeries[]): void;
        protected prepareInfo(rect: RectangleD): void;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDoughnutAreaCoreXF extends StiPieAreaCoreXF {
        applyStyle(style: IStiChartStyle): void;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStackedBarAreaCoreXF extends StiClusteredBarAreaCoreXF {
        private prepareSeriesRange;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        get localizedName(): string;
        get seriesOrientation(): StiChartSeriesOrientation;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiFullStackedBarAreaCoreXF extends StiStackedBarAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStackedColumnAreaCoreXF extends StiAxisAreaCoreXF {
        private prepareSeriesRange;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiFullStackedColumnAreaCoreXF extends StiStackedColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiFullStackedAreaAreaCoreXF extends StiFullStackedColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiFullStackedLineAreaCoreXF extends StiFullStackedColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiFullStackedSplineAreaAreaCoreXF extends StiFullStackedColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiFullStackedSplineAreaCoreXF extends StiFullStackedColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiFunnelAreaCoreXF extends StiAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesCollection: IStiSeries[]): void;
        protected prepareInfo(rect: RectangleD): void;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiGanttAreaCoreXF extends StiClusteredBarAreaCoreXF {
        protected createStripLinesXAxis(axis: IStiAxis): void;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        get localizedName(): string;
        get seriesOrientation(): StiChartSeriesOrientation;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiHeatmapAreaCoreXF extends StiAxisAreaCoreXF {
        xValuesCount: number;
        yValuesCount: number;
        protected prepareInfo(rect: Rectangle): void;
        protected createStripLinesXAxis(axis: IStiAxis): void;
        protected createStripLinesYAxis(axis: IStiAxis, isDateTimeValues: boolean): void;
        calculatePositions(axis: IStiAxis, REFcollection: any, step: number, calculationForTicks: boolean): void;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPictorialAreaCoreXF extends StiAreaCoreXF {
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPictorialStackedAreaCoreXF extends StiAreaCoreXF {
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiPie3dAreaCoreXF extends StiPieAreaCoreXF {
        render(context: StiContext, rect: Rectangle): StiCellGeom;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiRadarAreaCoreXF extends StiAreaCoreXF {
        applyStyle(style: IStiChartStyle): void;
        valuesCount: number;
        points: PointD[];
        arguments: any[];
        centerPoint: PointD;
        render(context: StiContext, areaRect: RectangleD): StiCellGeom;
        private static centerArea;
        measureLabels(context: StiContext, rect: RectangleD): RectangleD;
        renderArguments(context: StiContext, geom: StiRadarAreaGeom, series: IStiSeries): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesCollection: IStiSeries[]): void;
        protected prepareInfo(rect: RectangleD): void;
        protected createStripLinesAxis(axis: IStiYRadarAxis, minimum: number, maximum: number): void;
        private calculateStep;
        calculatePositions(axis: IStiYRadarAxis, REFcollection: any, step: number, calculationForTicks: boolean): void;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiRadarAreaAreaCoreXF extends StiRadarAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiRadarLineAreaCoreXF extends StiRadarAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiRadarPointAreaCoreXF extends StiRadarAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiRangeAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiRangeBarAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        protected createStripLinesXAxis(axis: IStiAxis): void;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiSplineRangeAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiSteppedRangeAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStackedAreaAreaCoreXF extends StiStackedColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStackedLineAreaCoreXF extends StiStackedColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStackedSplineAreaAreaCoreXF extends StiStackedColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStackedSplineAreaCoreXF extends StiStackedColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStockAreaCoreXF extends StiCandlestickAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiSunburstAreaCoreXF extends StiAreaCoreXF {
        render(context: StiContext, rect: Rectangle): StiCellGeom;
        protected prepareInfo(rect: Rectangle): void;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTreemapAreaCoreXF extends StiAreaCoreXF {
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderSeries(context: StiContext, boxes: RectangleD[], boxRoot: RectangleD, geom: StiAreaGeom, seriesCollection: IStiSeries[]): void;
        private cutArea;
        squarify(data: number[], currentrow: number[], container: RectangleD, stack: RectangleD[]): RectangleD[];
        private improvesRatio;
        private calculateRatio;
        normalizeDataForArea(data: number[], area: number): number[];
        private getCoordinates;
        prepareInfo(rect: RectangleD): void;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisCoreXF implements ICloneable, IStiApplyStyle, IStiAxisCoreXF, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        clone(): StiAxisCoreXF;
        applyStyle(style: IStiChartStyle): void;
        getStartFromZero(): boolean;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderView(context: StiContext, rect: RectangleD): StiCellGeom;
        calculateStripPositions(topPosition: number, bottomPosition: number): void;
        getTicksMaxLength(context: StiContext): number;
        getArrowHeight(context: StiContext): number;
        getLabelsSpaceAxis(context: StiContext): number;
        getLabelsTwoLinesDestination(context: StiContext): number;
        getFontGeom(context: StiContext): StiFontGeom;
        getTextAlignment(): StiHorAlignment;
        getStringFormatGeom(context: StiContext, wordWrap: boolean): StiStringFormatGeom;
        protected getAxisTitleSize(context: StiContext): SizeD;
        protected getAngleTitle(): number;
        protected getCorrectionFontSize(axisRect: Rectangle, titleRect: Rectangle, currentFontSize: number): number;
        protected checkUseMaxWidth(axisRect: Rectangle, titleRect: Rectangle, RefMaxWidth: any): boolean;
        static defaultScrollBarSize: number;
        static defaultScrollBarSmallFactor: number;
        static defaultScrollBarFirstRecallTime: number;
        static defaultScrollBarOtherRecallTime: number;
        get ticksMaxLength(): number;
        get arrowWidth(): number;
        get arrowHeight(): number;
        axis: IStiAxis;
        get info(): StiAxisInfoXF;
        set info(value: StiAxisInfoXF);
        constructor(axis: IStiAxis);
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisInfoXF implements ICloneable, IStiAxisInfoXF {
        implements(): any[];
        clone(): StiAxisInfoXF;
        dpi: number;
        step: number;
        get range(): number;
        stripLines: StiStripLinesXF;
        stripPositions: number[];
        ticksCollection: StiStripPositionXF[];
        labelsCollection: StiStripPositionXF[];
        minimum: number;
        maximum: number;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiAxisLabelInfoXF {
        clientRectangle: RectangleD;
        textPoint: PointD;
        angle: number;
        width: number;
        wordWrap: boolean;
        rotationMode: StiRotationMode;
        text: string;
        stripLine: StiStripLineXF;
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisLabelsCoreXF implements IStiApplyStyle, ICloneable, IStiAxisLabelsCoreXF {
        implements(): any[];
        clone(): StiAxisLabelsCoreXF;
        applyStyle(style: IStiChartStyle): void;
        labels: IStiAxisLabels;
        constructor(labels: IStiAxisLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisTitleCoreXF implements IStiApplyStyle, ICloneable, IStiAxisTitleCoreXF {
        implements(): any[];
        clone(): StiAxisTitleCoreXF;
        applyStyle(style: IStiChartStyle): void;
        title: IStiAxisTitle;
        constructor(title: IStiAxisTitle);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiXAxisCoreXF extends StiAxisCoreXF {
        private storedCulture;
        getStartFromZero(): boolean;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderView(context: StiContext, rect: RectangleD): StiCellGeom;
        renderScrollBar(context: StiContext, axisRect: RectangleD, axisGeom: StiXAxisViewGeom): void;
        renderCenter(context: StiContext, rect: RectangleD): StiCellGeom;
        renderCenterView(context: StiContext, rect: RectangleD): StiCellGeom;
        getLabelText(line: StiStripLineXF, series: IStiSeries): string;
        getLabelText2(objectValue: any, value: number, series: IStiSeries): string;
        setTotalNumberCapacity(): void;
        private get isLabelsAngleByWidth();
        private checkAutoAngleLabels;
        private measureStripLines;
        getCenterAxisRect(context: StiContext, rect: RectangleD, includeAxisArrow: boolean, includeLabelsHeight: boolean, isDrawing: boolean): RectangleD;
        getAxisRect(context: StiContext, rect: RectangleD, includeAxisArrow: boolean, includeLabelsWidth: boolean, isDrawing: boolean, includeScrollBar: boolean): RectangleD;
        private renderLabels;
        private renderTitle;
        private isArgumentDateTime1;
        private isArgumentDateTime2;
        get dock(): StiXAxisDock;
        get isTopSide(): boolean;
        get isBottomSide(): boolean;
        constructor(axis: IStiAxis);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiXBottomAxisCoreXF extends StiXAxisCoreXF {
        get dock(): StiXAxisDock;
        constructor(axis: IStiAxis);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiXTopAxisCoreXF extends StiXAxisCoreXF {
        get dock(): StiXAxisDock;
        constructor(axis: IStiAxis);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiYAxisCoreXF extends StiAxisCoreXF {
        private storedCulture;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderView(context: StiContext, rect: RectangleD): StiCellGeom;
        renderScrollBar(context: StiContext, axisRect: RectangleD, axisGeom: StiYAxisViewGeom): void;
        renderCenter(context: StiContext, rect: RectangleD): StiCellGeom;
        renderCenterView(context: StiContext, rect: RectangleD): StiCellGeom;
        setTotalNumberCapacity(): void;
        getLabelText(line: StiStripLineXF, series: IStiSeries): string;
        private measureStripLines;
        getCenterAxisRect(context: StiContext, rect: RectangleD, includeAxisArrow: boolean, includeLabelsHeight: boolean, isDrawing: boolean): RectangleD;
        getAxisRect(context: StiContext, rect: RectangleD, includeAxisArrow: boolean, includeLabelsHeight: boolean, isDrawing: boolean, includeScrollBar: boolean): RectangleD;
        private renderLabels;
        private renderTitle;
        get dock(): StiYAxisDock;
        get isLeftSide(): boolean;
        get isRightSide(): boolean;
        constructor(axis: IStiAxis);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiYLeftAxisCoreXF extends StiYAxisCoreXF {
        get dock(): StiYAxisDock;
        constructor(axis: IStiAxis);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiYRightAxisCoreXF extends StiYAxisCoreXF {
        get dock(): StiYAxisDock;
        getStartFromZero(): boolean;
        constructor(axis: IStiAxis);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStripLineCalculatorXF {
        private static getInterval1;
        static getInterval(minValue: number, maxValue: number, num: number): number;
        static getStripLines(minValue: number, maxValue: number, step: number, asDateTimeValue: boolean): StiStripLinesXF;
        static getStripLines2(axis: IStiAxis, step: number, asDateTimeValue: boolean): StiStripLinesXF;
        static getScatterXDateStripLines(minValue: number, maxValue: number, step: number): StiStripLinesXF;
        private static getCountAfterComma;
        static getStripLinesLogScale(minValue: number, maxValue: number): StiStripLinesXF;
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStripLineXF implements ICloneable, IStiStripLineXF {
        implements(): any[];
        clone(): StiStripLineXF;
        valueObject: any;
        private valueObj;
        get value(): number;
        set value(value: number);
        constructor(valueObject: any, value: number);
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiStripLinesXF extends CollectionBase<StiStripLineXF> implements ICloneable, IStiStripLinesXF {
        implements(): any[];
        clone(): StiStripLinesXF;
        add2(valueObject: any, value: number): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStripPositionXF implements IStiStripPositionXF {
        implements(): any[];
        position: number;
        stripLine: StiStripLineXF;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import ICloneable = Stimulsoft.System.ICloneable;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiChartTitleCoreXF implements ICloneable, IStiApplyStyle, IStiChartTitleCoreXF {
        implements(): any[];
        clone(): StiChartTitleCoreXF;
        applyStyle(style: IStiChartStyle): void;
        render(context: StiContext, chartTitle: IStiChartTitle, rect: RectangleD): StiCellGeom;
        chartTitle: IStiChartTitle;
        constructor(chartTitle: IStiChartTitle);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiConstantLinesCoreXF implements IStiApplyStyle, ICloneable, IStiConstantLinesCoreXF {
        implements(): any[];
        clone(): any;
        applyStyle(style: IStiChartStyle): void;
        renderXConstantLines(geom: StiAxisAreaGeom, rect: RectangleD): void;
        renderYConstantLines(geom: StiAxisAreaGeom, rect: RectangleD): void;
        render(context: StiContext, geom: StiAxisAreaGeom, rect: RectangleD): void;
        constantLines: IStiConstantLines;
        constructor(constantLines: IStiConstantLines);
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiGridLinesCoreXF implements IStiApplyStyle, ICloneable, IStiGridLinesCoreXF {
        implements(): any[];
        clone(): StiGridLinesCoreXF;
        applyStyle(style: IStiChartStyle): void;
        gridLines: IStiGridLines;
        constructor(gridLines: IStiGridLines);
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarGridLinesCoreXF implements IStiApplyStyle, ICloneable, IStiRadarGridLinesCoreXF {
        implements(): any[];
        clone(): StiRadarGridLinesCoreXF;
        applyStyle(style: IStiChartStyle): void;
        gridLines: IStiRadarGridLines;
        constructor(gridLines: IStiRadarGridLines);
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiInterlacingCoreXF implements IStiApplyStyle, ICloneable, IStiInterlacingCoreXF {
        implements(): any[];
        clone(): StiInterlacingCoreXF;
        applyStyle(style: IStiChartStyle): void;
        interlacing: IStiInterlacing;
        constructor(interlacing: IStiInterlacing);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import RectangleF = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiLegendCoreXF implements ICloneable, IStiApplyStyle, IStiLegendCoreXF {
        implements(): any[];
        applyStyle(style: IStiChartStyle): void;
        isAcceptableSeries(seriesType: Stimulsoft.System.Type): boolean;
        clone(): StiLegendCoreXF;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        getMatrixIndexItem(countColumns: number, countRows: number, countItems: number): number[][];
        getArgumentText(series: IStiSeries, index: number): string;
        getLegendItemColumn(seriesItems: StiLegendItemCoreXF[], seriesItem: StiLegendItemCoreXF): number;
        getTitleSize(context: StiContext): SizeD;
        getItemSize1(context: StiContext, seriesItems: StiLegendItemCoreXF[], seriesIndex: number): SizeD;
        getItemSize2(context: StiContext, seriesItems: StiLegendItemCoreXF[], seriesItem: StiLegendItemCoreXF): SizeD;
        getItemRealSize(context: StiContext, seriesItem: StiLegendItemCoreXF): SizeD;
        getItemsSize(context: StiContext, seriesItems: StiLegendItemCoreXF[]): SizeD;
        getItemsAutoSize(context: StiContext, seriesItems: StiLegendItemCoreXF[], rect: RectangleF, countColumns: any, countRows: any): SizeD;
        getSeriesSize(context: StiContext, rect: RectangleF, countColumns: any, countRows: any): SizeD;
        getLegendSize(context: StiContext, rect: RectangleF, countColumns: any, countRows: any): SizeD;
        getLegendItems(REFcount: any): StiLegendItemCoreXF[];
        legend: IStiLegend;
        constructor(legend: IStiLegend);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiHeatmapLegendCoreXF extends StiLegendCoreXF {
        render(context: StiContext, rect: Rectangle): StiCellGeom;
        private getSpacingVertical;
        getLegendSize(context: StiContext, rect: Rectangle): SizeD;
        private getMarkerSize;
        private getBodyValueTextSize;
        private getItemCores;
        private roundValues;
        private naiveRound;
        isAcceptableSeries(seriesType: Stimulsoft.System.Type): boolean;
        constructor(legend: IStiLegend);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Size = Stimulsoft.System.Drawing.Size;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiHeatmapLegendItemCoreXF {
        text: string;
        series: IStiSeries;
        color: Color;
        getText(context: StiContext, font: StiFontGeom): string;
        measureString(context: StiContext, font: StiFontGeom): Size;
        constructor(text: string, series: IStiSeries, color: Color);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Size = Stimulsoft.System.Drawing.Size;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiLegendItemCoreXF {
        text: string;
        series: IStiSeries;
        index: number;
        colorIndex: number;
        getText(context: StiContext, font: StiFontGeom): string;
        measureString(context: StiContext, font: StiFontGeom): Size;
        constructor(text: string, series: IStiSeries, index: number, colorIndex: number);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiMarkerCoreXF implements ICloneable, IStiMarkerCoreXF {
        implements(): any[];
        clone(): StiMarkerCoreXF;
        drawMarkers(context: StiContext, points: PointD[], showShadow: boolean): void;
        static getMarkerRect(position: PointD, markerSize: number, zoom: number): RectangleD;
        draw(context: StiContext, marker: IStiMarker, position: PointD, zoom: number, showShadow: boolean, isMouseOver: boolean, isTooltipMode: boolean, isAnimation: boolean, toolTip: string, tag: any, interaction: StiInteractionDataGeom): void;
        drawLine(context: StiContext, x1: number, y1: number, x2: number, y2: number, scale: number, brushMarker: StiBrush, penMarker: StiPenGeom, markerType: StiMarkerType, markerStep: number, markerSize: number, angle: number): void;
        drawLines(context: StiContext, points: PointD[], scale: number, brushMarker: any, penMarker: StiPenGeom, markerType: StiMarkerType, markerStep: number, markerSize: number, angle: number): void;
        drawPoint(context: StiContext, x: number, y: number, scale: number, brush: any, pen: StiPenGeom, markerType: StiMarkerType, icon: StiFontIcons, markerSize: number, angle: number, isMouseOver: boolean, isAnimation: boolean, toolTip: string, tag: any, interaction: StiInteractionDataGeom): void;
        private drawPolygon;
        marker: IStiMarker;
        constructor(marker: IStiMarker);
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarAxisCoreXF implements ICloneable, IStiApplyStyle, IStiRadarAxisCoreXF {
        implements(): any[];
        clone(): StiRadarAxisCoreXF;
        applyStyle(style: IStiChartStyle): void;
        axis: IStiRadarAxis;
        constructor(axis: IStiRadarAxis);
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarAxisLabelsCoreXF implements IStiApplyStyle, ICloneable, IStiRadarAxisLabelsCoreXF {
        implements(): any[];
        clone(): StiRadarAxisLabelsCoreXF;
        applyStyle(style: IStiChartStyle): void;
        labels: IStiRadarAxisLabels;
        constructor(labels: IStiRadarAxisLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiXRadarAxisCoreXF extends StiRadarAxisCoreXF implements IStiXRadarAxisCoreXF {
        implements(): any[];
        applyStyle(style: IStiChartStyle): void;
        renderLabel(context: StiContext, series: IStiSeries, point: PointD, argument: any, angle: number, colorIndex: number, colorCount: number): StiXRadarAxisLabelGeom;
        getLabelText(value: any): string;
        getLabelRect(context: StiContext, point: PointD, text: string, angle: number): RectangleD;
        get xAxis(): IStiXRadarAxis;
        constructor(axis: IStiRadarAxis);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiYRadarAxisCoreXF extends StiRadarAxisCoreXF implements IStiYRadarAxisCoreXF {
        implements(): any[];
        applyStyle(style: IStiChartStyle): void;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        private measureStripLines;
        private renderLabels;
        calculateStripPositions(topPosition: number, bottomPosition: number): void;
        getAxisRect(context: StiContext, rect: RectangleD): RectangleD;
        getTicksMaxLength(context: StiContext): number;
        getLabelsSpaceAxis(context: StiContext): number;
        getLabelsTwoLinesDestination(context: StiContext): number;
        getTextAlignment(): StiHorAlignment;
        setTotalNumberCapacity(): void;
        getLabelText(line: StiStripLineXF): string;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        getFontGeom(context: StiContext): StiFontGeom;
        get yAxis(): IStiYRadarAxis;
        get info(): StiAxisInfoXF;
        set info(value: StiAxisInfoXF);
        get ticksMaxLength(): number;
        constructor(axis: IStiRadarAxis);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSeriesCoreXF implements ICloneable, IStiApplyStyleSeries, IStiSeriesCoreXF, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        clone(): StiSeriesCoreXF;
        applyStyle(style: IStiChartStyle, color: Color): void;
        checkLabelsRect(labels: IStiSeriesLabels, geom: StiAreaGeom, labelsRect: RectangleD): RectangleD;
        checkLabelsRect2(labels: IStiSeriesLabels, rect: RectangleD, labelsRect: RectangleD): RectangleD;
        private getDrawRectangle;
        private rotatePoint;
        checkIntersectionLabels(geom: StiAreaGeom): void;
        private getLabelRectangle;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        getSeriesLabels(): IStiAxisSeriesLabels;
        getTag(tagIndex: number): string;
        getInteraction(area: IStiArea, series: IStiSeries, pointIndex: number): StiSeriesInteractionData;
        private static falseObject;
        private static trueObject;
        get localizedName(): string;
        seriesColors: Color[];
        isDateTimeValues: boolean;
        isDateTimeArguments: boolean;
        series: IStiSeries;
        get interaction(): IStiSeriesInteraction;
        set interaction(value: IStiSeriesInteraction);
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBoxAndWhiskerSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: Rectangle, geom: StiAreaGeom, series: IStiSeries[]): void;
        private getFirstValues;
        private getSecondValues;
        private getThirdQuartile;
        private getFirstQuartile;
        private getMedian;
        private getMedianIndices;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import IStiBaseLineSeries = Stimulsoft.Report.Chart.IStiBaseLineSeries;
    import IStiAxisArea = Stimulsoft.Report.Chart.IStiAxisArea;
    import StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
    class StiBaseLineSeriesCoreXF extends StiSeriesCoreXF implements IStiApplyStyleSeries {
        implements(): any[];
        applyStyle(style: IStiChartStyle, color: Color): void;
        protected clipLinePoints(context: StiContext, geom: StiAreaGeom, points: PointD[], REFstartIndex: any, REFendIndex: any): PointD[];
        renderMarkers(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        getInteractions(context: StiContext, geom: StiAreaGeom, points: PointD[]): StiSeriesInteractionData[];
        renderLines(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        protected getPointsZeroConnect(series: IStiBaseLineSeries, values: number[], axisArea: IStiAxisArea): PointD[];
        protected getPointsNullConnect(series: IStiBaseLineSeries, values: number[], axisArea: IStiAxisArea): PointD[];
        private getPointConnect;
        private getPointValue2;
        private getPointValue;
        private getPointValue1;
        private isTopmostLine;
        correctPoint(point: PointD, rect: RectangleD, correctY: number): PointD;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiScatterSeriesCoreXF extends StiBaseLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderLines(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBubbleSeriesCoreXF extends StiScatterSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderLines(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        renderBubbles(context: StiContext, geom: StiAreaGeom, series: IStiBubbleSeries, points: PointD[], weights: number[]): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiClusteredColumnSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        protected getPointEnd(currentSeries: IStiClusteredColumnSeries, value: number, seriesLeftPos: number, seriesWidth: number): PointD;
        protected getColumnRect(context: StiContext, currentSeries: IStiClusteredColumnSeries, value: number, seriesLeftPos: number, seriesWidth: number): RectangleD;
        protected correctPoint(point: PointD, rect: RectangleD): PointD;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        private measureLeftPosition;
        private getSeriesCurrentValue;
        private getSeriesValueStart;
        private getSeriesBrush2;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiClusteredBarSeriesCoreXF extends StiClusteredColumnSeriesCoreXF implements IStiApplyStyleSeries {
        implements(): any[];
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private getBarRect;
        protected correctPoint(point: PointD, rect: RectangleD): PointD;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiLineSeriesCoreXF extends StiBaseLineSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiAreaSeriesCoreXF extends StiLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiHistogramSeriesCoreXF extends StiClusteredColumnSeriesCoreXF {
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiParetoSeriesCoreXF extends StiClusteredColumnSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private renderLinePareto;
        private renderLines;
        private getParetoValues;
        private getPointValue;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiSplineSeriesCoreXF extends StiBaseLineSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSplineAreaSeriesCoreXF extends StiSplineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiSteppedLineSeriesCoreXF extends StiBaseLineSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSteppedAreaSeriesCoreXF extends StiSteppedLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiWaterfallSeriesCoreXF extends StiClusteredColumnSeriesCoreXF {
        renderSeries(context: StiContext, rect: Rectangle, geom: StiAreaGeom, series: IStiSeries[]): void;
        private getSumSeriesWidth;
        private getDividerYSeries;
        private renderColumns;
        protected getPointEnd(currentSeries: IStiClusteredColumnSeries, value: number, seriesLeftPos: number, seriesWidth: number, posY?: number): PointD;
        protected getColumnRect(context: StiContext, currentSeries: IStiClusteredColumnSeries, value: number, seriesLeftPos: number, seriesWidth: number, REFposY?: any): Rectangle;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        private correctBrush;
        private renderPieElement;
        private renderPieElementShadow;
        private measurePieElement;
        private measurePieElementCore;
        protected checkNonZerovalue(seriesArray: IStiSeries[], REFnonZeroValuesCount: {
            ref: number;
        }, REFfirstNonZeroValueIndex: {
            ref: number;
        }, REFfirstNonZeroSeries: {
            ref: IStiSeries;
        }, isForValueFrom?: boolean): number;
        protected isNotNullValues(seriesArray: IStiSeries[]): boolean;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        getColorCount(seriesArray: IStiSeries[], isForValueFrom?: boolean): number;
        private isIntersectionLabels;
        private getPieLabelGeoms;
        getPieSeriesLabels(): IStiPieSeriesLabels;
        private getPieElementGeoms;
        private checkIntersectionOutLabels;
        private checkIntersectionTwoColumnsLabels;
        checkIntersectionLabels(geom: StiAreaGeom): void;
        private checkLabelPosition;
        protected getGradPerValue(series: IStiSeries[], isForValueFrom?: boolean): number;
        getPercentPerValue(series: IStiSeries[], isForValueFrom?: boolean): number;
        protected getPointCenter(rect: RectangleD): PointD;
        protected getRadius(context: StiContext, rect: RectangleD): number;
        protected getPoint(centerPie: PointD, radius: number, angle: number): PointD;
        protected getArgumentText(series: IStiSeries, index: number): string;
        private getPieDistance;
        private getPieDistance2;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDoughnutSeriesCoreXF extends StiPieSeriesCoreXF {
        private renderDoughnutElement;
        isNotNullValues(seriesArray: IStiSeries[]): boolean;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        protected checkNonZerovalue(seriesArray: IStiSeries[], REFnonZeroValuesCount: any, REFfirstNonZeroValueIndex: any, REFfirstNonZeroSeries: any, isForValueFrom?: boolean): number;
        protected getGradPerValue(series: IStiSeries[]): number;
        getPercentPerValue(series: IStiSeries[]): number;
        protected getArgumentText(series: IStiSeries, index: number): string;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCandlestickSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStockSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedBarSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private calculateTotalWidth;
        private correctRect;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiFullStackedBarSeriesCoreXF extends StiStackedBarSeriesCoreXF {
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiStackedBaseLineSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        clipLinePoints(context: StiContext, geom: StiAreaGeom, startPoints: PointD[], endPoints: PointD[], REFnewStartPoints: any, REFnewEndPoints: any, REFstartIndex: any, REFendIndex: any): void;
        renderMarkers(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        renderLines(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private calculateTotalHeight;
        private correctPoint;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        get isFullStacked(): boolean;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiStackedLineSeriesCoreXF extends StiStackedBaseLineSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedAreaSeriesCoreXF extends StiStackedLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiFullStackedAreaSeriesCoreXF extends StiStackedAreaSeriesCoreXF {
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedColumnSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private calculateTotalHeight;
        private correctRect;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiFullStackedColumnSeriesCoreXF extends StiStackedColumnSeriesCoreXF {
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiFullStackedLineSeriesCoreXF extends StiStackedLineSeriesCoreXF {
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiStackedSplineSeriesCoreXF extends StiStackedBaseLineSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedSplineAreaSeriesCoreXF extends StiStackedSplineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiFullStackedSplineAreaSeriesCoreXF extends StiStackedSplineAreaSeriesCoreXF {
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiFullStackedSplineSeriesCoreXF extends StiStackedSplineSeriesCoreXF {
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiFunnelSeriesCoreXF extends StiSeriesCoreXF {
        private labels;
        applyStyle(style: IStiChartStyle, color: Color): void;
        isNotNullValues(seriesArray: IStiSeries[]): boolean;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        private checkNonZerovalue;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getCurrentValue(funnelSeries: IStiFunnelSeries, index: number, values: number[]): number;
        getNextCurrentValue(funnelSeries: IStiFunnelSeries, index: number, values: number[]): number;
        getAllValues(funnelSeries: IStiFunnelSeries[]): number[];
        getAllTrueValues(funnelSeries: IStiFunnelSeries[]): number[];
        private getValues;
        private getArgumentText;
        private renderFunnelEmpty;
        private renderFunnelElement;
        private getSingleValueHeight;
        private getSingleValueWidth;
        private measureFunnelElementCore;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiFunnelWeightedSlicesSeriesCoreXF extends StiSeriesCoreXF {
        private labels;
        applyStyle(style: IStiChartStyle, color: Color): void;
        isNotNullValues(seriesArray: IStiSeries[]): boolean;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        private checkNonZerovalue;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getAllValues(funnelSeries: IStiFunnelSeries[]): number[];
        getAllTrueValues(funnelSeries: IStiFunnelSeries[]): number[];
        private getValues;
        private getArgumentText;
        private renderFunnelEmpty;
        private getPathFunnelEmpty;
        private renderFunnelElement;
        private getSumValues;
        private getSumLastValues;
        private measureFunnelElementCore;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiGanttSeriesCoreXF extends StiClusteredBarSeriesCoreXF {
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import List = Stimulsoft.System.Collections.List;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiHeatmapSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: Rectangle, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        private getArgumentText;
        getAllValues(): List<number>;
        getHeatmapColors(): Color[];
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class DataPictorial {
        value: number;
        series: StiPictorialSeries;
        index: number;
        constructor(value: number, series: StiPictorialSeries, index: number);
    }
    class StiPictorialSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        get localizedName(): string;
        private singleSizeConst;
        getSingleSize(context: StiContext): SizeD;
        private showEmptyGeom;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        roundPictirialValue(currentFactorValue: number, deltaValue: number): number;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiPictorialStackedSeriesCoreXF extends StiSeriesCoreXF {
        private correctionAlfa;
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: Rectangle, geom: StiAreaGeom, seriesCollection: IStiSeries[]): void;
        private isNotNullValues;
        private correctionMainPoint;
        private getArgumentText;
        private getRectangle;
        private getStringFormatGeom;
        private measureFontSize;
        private getSumValues;
        getAllTrueValues(funnelSeries: IStiSeries[]): number[];
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import PointF = Stimulsoft.System.Drawing.Point;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiPie3dSlice {
        private rectPieSlilce;
        private pieHeight;
        private seriesBrush;
        private borderColor;
        private series;
        private area;
        colorCount: number;
        startAngle: number;
        sweepAngle: number;
        get endAngle(): number;
        value: number;
        argumentText: string;
        tag: string;
        index: number;
        colorIndex: number;
        textPosition: PointF;
        interaction: StiSeriesInteractionData;
        startSideExists: boolean;
        endSideExists: boolean;
        drawLabels(areaGeom: StiAreaGeom, context: StiContext): void;
        drawTopPieSliceGeom(areaGeom: StiAreaGeom): void;
        drawBottomPieSliceGeom(areaGeom: StiAreaGeom): void;
        drawSides(areaGeom: StiAreaGeom): void;
        split(splitAngle: number): StiPie3dSlice[];
        initTextPosition(areaGeom: StiAreaGeom): void;
        private getNewModified;
        constructor(area: IStiArea, value: number, argumentText: string, tag: string, index: number, series: IStiPie3dSeries, rectPieSlilce: Rectangle, pieHeight: number, startAngle: number, sweepAngle: number, seriesBrush: StiBrush, borderColor: Color, colorIndex: number, colorCount: number);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Size = Stimulsoft.System.Drawing.Size;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiPie3dSeriesCoreXF extends StiPieSeriesCoreXF {
        private mPieSlices;
        private pieHeight;
        renderSeries(context: StiContext, rect: Rectangle, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        private drawLabels;
        private drawTops;
        private drawSliceSides;
        private drawBottoms;
        private measureBoundingRect;
        protected initializePieSlices(area: IStiArea, mainRect: Rectangle, seriesArray: IStiSeries[], zoom: number): void;
        protected initializeEmptyPieSlices(area: IStiArea, mainRect: Rectangle, seriesArray: IStiSeries[], zoom: number): void;
        private getTopEllipseSize;
        protected getSliceDisplacement(angle: number, xDisplacement: number, yDisplacement: number): Size;
        private getLargestDisplacement;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRadarSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        private getPointsList;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        renderAreas(context: StiContext, series: IStiRadarSeries, pointsInfo: StiSeriesPointsInfo, geom: StiAreaGeom): void;
        renderLines(context: StiContext, series: IStiRadarSeries, pointsInfo: StiSeriesPointsInfo, geom: StiAreaGeom): void;
        renderPoints(context: StiContext, series: IStiRadarSeries, points: PointD[], geom: StiAreaGeom): void;
        private getArgument;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarAreaSeriesCoreXF extends StiRadarSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        get localizedName(): string;
        renderLines(context: StiContext, series: IStiRadarSeries, pointsInfo: StiSeriesPointsInfo, geom: StiAreaGeom): void;
        renderAreas(context: StiContext, series: IStiRadarSeries, pointsInfo: StiSeriesPointsInfo, geom: StiAreaGeom): void;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarLineSeriesCoreXF extends StiRadarSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        get localizedName(): string;
        renderLines(context: StiContext, series: IStiRadarSeries, pointsInfo: StiSeriesPointsInfo, geom: StiAreaGeom): void;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarPointSeriesCoreXF extends StiRadarSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRangeBarSeriesCoreXF extends StiClusteredColumnSeriesCoreXF {
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRangeSeriesCoreXF extends StiLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private renderLines2;
        private renderMarkers2;
        private getYPoint;
        private renderAreas2;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSplineRangeSeriesCoreXF extends StiSplineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private getYPoint;
        private renderAreas2;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSteppedRangeSeriesCoreXF extends StiSteppedLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private renderAreas2;
        private renderLines2;
        private renderMarkers2;
        private getYPoint;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiScatterLineSeriesCoreXF extends StiScatterSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiScatterSplineSeriesCoreXF extends StiScatterSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRibbonSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private static getValueFromArray;
        private correctRect;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): any;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointF = Stimulsoft.System.Drawing.Point;
    class StiSunburstSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: Rectangle, geom: StiAreaGeom, seriesCollection: IStiSeries[]): void;
        private renderComputeSeries;
        private renderLevelSeries;
        private renderLevelSeriesLebels;
        private renderSunburstElement;
        protected getPoint(centerPie: PointF, radius: number, angle: number): PointF;
        private getDataTable;
        private getCountRow;
        private getGradPerValue;
        protected getRadius(context: StiContext, rect: Rectangle): number;
        protected getPointCenter(rect: Rectangle): PointF;
        private getSumColumn;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTreemapSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        getArgumentText(series: IStiSeries, index: number): string;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSeriesLabelsCoreXF implements ICloneable, IStiApplyStyle, IStiSeriesLabelsCoreXF, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        clone(): StiSeriesLabelsCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private storedCulture;
        get position(): number;
        get seriesLabelsType(): StiSeriesLabelsType;
        seriesLabels: IStiSeriesLabels;
        get localizedName(): string;
        processSeriesColors(pointIndex: number, brush: StiBrush, series: IStiSeries): StiBrush;
        getSeriesLabelColor(series: IStiSeries, colorIndex: number, colorCount: number): Color;
        getBorderColor(series: IStiSeries, colorIndex: number, colorCount: number): Color;
        getLabelColor(series: IStiSeries, colorIndex: number, colorCount: number): Color;
        recalcValue(value: number, signs: number): number;
        getLabelText(series: IStiSeries, value: number, argument: string, tag: string, seriesName: string, useLegendValueType?: boolean): string;
        getLabelText2(series: IStiSeries, value: number, argument: string, tag: string, seriesName: string, weight: number, useLegendValueType: boolean): string;
        private getArgument;
        private getFormatted;
        getFormattedValue(series: IStiSeries, value: number): string;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiNoneLabelsCoreXF extends StiSeriesLabelsCoreXF {
        get seriesLabelsType(): StiSeriesLabelsType;
        get position(): number;
        get localizedName(): string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiAxisSeriesLabelsCoreXF extends StiSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, endPoint: PointD, startPoint: PointD, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, animation?: StiAnimation): StiSeriesLabelsGeom;
        renderLabel2(series: IStiSeries, context: StiContext, endPoint: PointD, startPoint: PointD, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, weight: number, colorIndex: number, colorCount: number, rect: RectangleD, animation?: StiAnimation): StiSeriesLabelsGeom;
        recalcValue(value: number, signs: number): number;
        get seriesLabelsType(): StiSeriesLabelsType;
        currentIndex: number;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterAxisLabelsCoreXF extends StiAxisSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, endPoint: PointD, startPoint: PointD, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, animation?: StiAnimation): StiSeriesLabelsGeom;
        renderLabel2(series: IStiSeries, context: StiContext, endPoint: PointD, startPoint: PointD, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, weight: number, colorIndex: number, colorCount: number, rect: RectangleD, animation?: StiAnimation): StiSeriesLabelsGeom;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        get position(): number;
        get localizedName(): string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiInsideBaseAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        get localizedName(): string;
        get position(): number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiInsideEndAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        get position(): number;
        get localizedName(): string;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiLeftAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        get localizedName(): string;
        get position(): number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiOutsideAxisLabelsCoreXF extends StiAxisSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, endPoint: PointD, startPoint: PointD, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD): StiSeriesLabelsGeom;
        get position(): number;
        get localizedName(): string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiOutsideBaseAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        get localizedName(): string;
        get position(): number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiOutsideEndAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        get localizedName(): string;
        get position(): number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiRightAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        get localizedName(): string;
        get position(): number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiValueAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        get localizedName(): string;
        get position(): number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiFunnelSeriesLabelsCoreXF extends StiSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, valueNext: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, singleValueHeight: number, singleValueWidth: number, centerAxis: number, REFmeasureRect: any): StiSeriesLabelsGeom;
        get seriesLabelsType(): StiSeriesLabelsType;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCenterFunnelLabelsCoreXF extends StiFunnelSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, valueNext: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, singleValueHeight: number, singleValueWidth: number, centerAxis: number, REFmeasureRect: any): StiSeriesLabelsGeom;
        private getSumLastValues;
        get seriesLabelsType(): StiSeriesLabelsType;
        get position(): number;
        get localizedName(): string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsideLeftFunnelLabelsCoreXF extends StiFunnelSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, valueNext: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, singleValueHeight: number, singleValueWidth: number, centerAxis: number, REFmeasureRect: any): StiSeriesLabelsGeom;
        get seriesLabelsType(): StiSeriesLabelsType;
        get position(): number;
        get localizedName(): string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsideRightFunnelLabelsCoreXF extends StiFunnelSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, valueNext: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, singleValueHeight: number, singleValueWidth: number, centerAxis: number, REFmeasureRect: any): StiSeriesLabelsGeom;
        get seriesLabelsType(): StiSeriesLabelsType;
        get position(): number;
        get localizedName(): string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterHeatmapLabelsCoreXF extends StiSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, animation?: StiAnimation): StiSeriesLabelsGeom;
        getLabelRect(context: StiContext, rect: RectangleD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        get position(): number;
        get localizedName(): string;
        get seriesLabelsType(): StiSeriesLabelsType;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPictorialStackedLabelsCoreXF extends StiSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, lineLength: number, rect: RectangleD): StiSeriesLabelsGeom;
        get seriesLabelsType(): StiSeriesLabelsType;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiCenterPictorialStackedLabelsCoreXF extends StiPictorialStackedLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, lineLength: number, rect: Rectangle): StiSeriesLabelsGeom;
        get seriesLabelsType(): StiSeriesLabelsType;
        get position(): number;
        get localizedName(): string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsideLeftPictorialStackedLabelsCoreXF extends StiPictorialStackedLabelsCoreXF {
        applyStyle(style: IStiChartStyle): void;
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, lineLength: number, rect: Rectangle): StiSeriesLabelsGeom;
        get seriesLabelsType(): StiSeriesLabelsType;
        get position(): number;
        get localizedName(): string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsideRightPictorialStackedLabelsCoreXF extends StiPictorialStackedLabelsCoreXF {
        applyStyle(style: IStiChartStyle): void;
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, lineLength: number, rect: Rectangle): StiSeriesLabelsGeom;
        get seriesLabelsType(): StiSeriesLabelsType;
        get position(): number;
        get localizedName(): string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiCenterPie3dLabelsCoreXF extends StiSeriesLabelsCoreXF {
        percentPerValue: number;
        get seriesLabelsType(): StiSeriesLabelsType;
        get position(): number;
        get localizedName(): string;
        renderLabel2(series: IStiSeries, context: StiContext, pie3dSlice: StiPie3dSlice): StiSeriesLabelsGeom;
        getLabelRect(context: StiContext, labelPoint: Point, labelText: string, font: StiFontGeom, sf: StiStringFormatGeom): Rectangle;
        recalcValue(value: number, signs: number): number;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieSeriesLabelsCoreXF extends StiSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, centerPie: PointD, radius: number, radius2: number, pieAngle: number, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, measure: boolean, colorIndex: number, colorCount: number, percentPerValue: number, REFmeasureRect: {
            ref: RectangleD;
        }, drawValue: boolean, deltaY: number): StiSeriesLabelsGeom;
        recalcValue(value: number, signs: number): number;
        get seriesLabelsType(): StiSeriesLabelsType;
        percentPerValue: number;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiCenterPieLabelsCoreXF extends StiPieSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, centerPie: PointD, radius: number, radius2: number, pieAngle: number, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, measure: boolean, colorIndex: number, colorCount: number, percentPerValue: number, REFmeasureRect: {
            ref: RectangleD;
        }, drawValue: boolean, deltaY: number): StiSeriesLabelsGeom;
        getLabelPoint(centerPie: PointD, radius: number, angleRad: number): PointD;
        getLabelRect(context: StiContext, labelPoint: PointD, labelText: string, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        get seriesLabelsType(): StiSeriesLabelsType;
        get position(): number;
        get localizedName(): string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiInsideEndPie3dLabelsCoreXF extends StiCenterPie3dLabelsCoreXF {
        percentPerValue: number;
        get seriesLabelsType(): StiSeriesLabelsType;
        get position(): number;
        get localizedName(): string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiInsideEndPieLabelsCoreXF extends StiCenterPieLabelsCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiOutsidePieLabelsCoreXF extends StiCenterPieLabelsCoreXF {
        applyStyle(style: IStiChartStyle): void;
        get position(): number;
        get localizedName(): string;
        getLineColor(series: IStiSeries, colorIndex: number, colorCount: number): Color;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTwoColumnsPieLabelsCoreXF extends StiOutsidePieLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, centerPie: PointD, radius: number, radius2: number, pieAngle: number, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, measure: boolean, colorIndex: number, colorCount: number, percentPerValue: number, REFmeasureRect: any, drawValue: boolean, deltaY: number): StiSeriesLabelsGeom;
        get seriesLabelsType(): StiSeriesLabelsType;
        get position(): number;
        get localizedName(): string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterTreemapLabelsCoreXF extends StiSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, animation?: StiAnimation): StiSeriesLabelsGeom;
        getLabelRect(context: StiContext, rect: RectangleD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        get position(): number;
        get localizedName(): string;
        get seriesLabelsType(): StiSeriesLabelsType;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStripsCoreXF implements IStiApplyStyle, ICloneable, IStiStripsCoreXF {
        implements(): any[];
        clone(): any;
        applyStyle(style: IStiChartStyle): void;
        renderXStrips(context: StiContext, geom: StiAxisAreaGeom, rect: RectangleD): void;
        private calculateXValue;
        renderYStrips(context: StiContext, geom: StiAxisAreaGeom, rect: RectangleD): void;
        private calculateYValue;
        render(context: StiContext, geom: StiAxisAreaGeom, rect: RectangleD): void;
        strips: IStiStrips;
        constructor(strips: IStiStrips);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    class StiStyleCoreXF implements IStiStyleCoreXF {
        implements(): any[];
        get localizedName(): string;
        get styleId(): StiChartStyleId;
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get chartAreaBorderColor(): Color;
        get chartAreaBorderThickness(): number;
        chart: IStiChart;
        get chartAreaShowShadow(): boolean;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsLineColor(): Color;
        get seriesLabelsFont(): Font;
        get toolTipBrush(): StiBrush;
        get toolTipTextBrush(): StiBrush;
        get toolTipCornerRadius(): StiCornerRadius;
        get toolTipBorder(): StiSimpleBorder;
        get trendLineColor(): Color;
        get trendLineShowShadow(): boolean;
        get legendBrush(): StiBrush;
        get legendLabelsColor(): Color;
        get legendBorderColor(): Color;
        get legendTitleColor(): Color;
        get legendShowShadow(): boolean;
        get legendFont(): Font;
        get axisTitleColor(): Color;
        get axisLineColor(): Color;
        get axisLabelsColor(): Color;
        get interlacingHorBrush(): StiBrush;
        get interlacingVertBrush(): StiBrush;
        get gridLinesHorColor(): Color;
        get gridLinesVertColor(): Color;
        get seriesLighting(): boolean;
        get seriesShowShadow(): boolean;
        get seriesShowBorder(): boolean;
        get seriesBorderColor(): Color;
        get seriesBorderThickness(): number;
        get seriesCornerRadius(): StiCornerRadius;
        private _markerVisible;
        get markerVisible(): boolean;
        set markerVisible(value: boolean);
        get firstStyleColor(): Color;
        get lastStyleColor(): Color;
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        fillColumn(context: StiContext, rect: RectangleD, brush: StiBrush, interaction: StiInteractionDataGeom): void;
        fillCicledColumn(context: StiContext, rect: RectangleD, cornerRadius: StiCornerRadius, brush: StiBrush, interaction: StiInteractionDataGeom, tooltip: string): void;
        getAreaBrush(color: Color): StiBrush;
        getColumnBrush(color: Color): StiBrush;
        getColumnBorder(color: Color): Color;
        getColors(seriesCount: number, seriesColors: Color[]): Color[];
        getColorByIndex(index: number, count: number, seriesColors: Color[]): Color;
        getColorBySeries(series: IStiSeries, seriesColors: Color[]): Color;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF01 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCustomStyleCoreXF extends StiStyleCoreXF01 {
        private _base;
        get localizedName(): string;
        reportChartStyle: Stimulsoft.Report.Styles.StiChartStyle;
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get chartAreaBorderColor(): Color;
        get chartAreaBorderThickness(): number;
        get chartAreaShowShadow(): boolean;
        get toolTipBrush(): StiBrush;
        get toolTipTextBrush(): StiBrush;
        get toolTipCornerRadius(): StiCornerRadius;
        get toolTipBorder(): StiSimpleBorder;
        get seriesLighting(): boolean;
        get seriesShowShadow(): boolean;
        get seriesShowBorder(): boolean;
        get seriesBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsLineColor(): Color;
        get seriesBorderThickness(): number;
        get seriesCornerRadius(): StiCornerRadius;
        get trendLineColor(): Color;
        get trendLineShowShadow(): boolean;
        get legendBrush(): StiBrush;
        get legendLabelsColor(): Color;
        get legendBorderColor(): Color;
        get legendTitleColor(): Color;
        get markerVisible(): boolean;
        set markerVisible(value: boolean);
        get axisTitleColor(): Color;
        get axisLineColor(): Color;
        get axisLabelsColor(): Color;
        get interlacingHorBrush(): StiBrush;
        get interlacingVertBrush(): StiBrush;
        get gridLinesHorColor(): Color;
        get gridLinesVertColor(): Color;
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        reportStyleName: string;
        get reportStyle(): Stimulsoft.Report.Styles.StiChartStyle;
        private _customStyle;
        get customStyle(): StiCustomStyle;
        getColumnBrush(color: Color): StiBrush;
        constructor(customStyle: StiCustomStyle);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF02 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get basicStyleColor(): Color;
        get styleColors(): Color[];
        get styleId(): StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF03 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF04 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get basicStyleColor(): Color;
        get styleColors(): Color[];
        get styleId(): StiChartStyleId;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF05 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF06 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF07 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF08 extends StiStyleCoreXF03 {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF09 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF10 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF11 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF12 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF13 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF14 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF15 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF16 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF17 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    class StiStyleCoreXF18 extends StiStyleCoreXF {
        get localizedName(): string;
        fillColumn(context: StiContext, rect: RectangleD, brush: StiBrush, interaction: StiInteractionDataGeom): void;
        getColumnBrush(color: Color): StiBrush;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF19 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get interlacingHorBrush(): StiBrush;
        get interlacingVertBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get chartBrush(): StiBrush;
        get styleId(): StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF20 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get axisLineColor(): Color;
        get chartAreaBorderColor(): Color;
        get styleId(): StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF21 extends StiStyleCoreXF {
        get localizedName(): string;
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get chartAreaBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get legendBrush(): StiBrush;
        get legendLabelsColor(): Color;
        get axisTitleColor(): Color;
        get axisLineColor(): Color;
        get axisLabelsColor(): Color;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
        getColumnBorder(color: Color): Color;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF22 extends StiStyleCoreXF {
        get localizedName(): string;
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get chartAreaBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get legendBrush(): StiBrush;
        get legendLabelsColor(): Color;
        get axisTitleColor(): Color;
        get axisLineColor(): Color;
        get axisLabelsColor(): Color;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get toolTipBrush(): StiBrush;
        get toolTipTextBrush(): StiBrush;
        get toolTipBorder(): StiSimpleBorder;
        get styleId(): StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
        getColumnBorder(color: Color): Color;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF23 extends StiStyleCoreXF22 {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get styleId(): StiChartStyleId;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStyleCoreXF24 extends StiStyleCoreXF22 {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get styleId(): StiChartStyleId;
        get chartAreaBorderColor(): Color;
        get legendBorderColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStyleCoreXF25 extends StiStyleCoreXF22 {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get styleId(): StiChartStyleId;
        get chartAreaBorderColor(): Color;
        get legendShowShadow(): boolean;
        get legendBorderColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsFont(): Font;
        get seriesLighting(): boolean;
        get seriesShowShadow(): boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStyleCoreXF26 extends StiStyleCoreXF22 {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get chartAreaBorderColor(): Color;
        get chartAreaBrush(): StiBrush;
        get legendShowShadow(): boolean;
        get legendBorderColor(): Color;
        get seriesLabelsColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsFont(): Font;
        get seriesLighting(): boolean;
        get seriesShowShadow(): boolean;
        get markerVisible(): boolean;
        set markerVisible(value: boolean);
        get styleId(): StiChartStyleId;
        getColumnBorder(color: Color): Color;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStyleCoreXF27 extends StiStyleCoreXF22 {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get chartAreaBorderColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsFont(): Font;
        get legendBrush(): StiBrush;
        get legendLabelsColor(): Color;
        get legendBorderColor(): Color;
        get legendTitleColor(): Color;
        get legendShowShadow(): boolean;
        get legendFont(): Font;
        get seriesLighting(): boolean;
        getColumnBorder(color: Color): Color;
        get toolTipBrush(): StiBrush;
        get toolTipTextBrush(): StiBrush;
        get toolTipBorder(): StiSimpleBorder;
        get styleId(): StiChartStyleId;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStyleCoreXF28 extends StiStyleCoreXF26 {
        get localizedName(): string;
        protected _styleColor: Color[];
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get chartAreaBorderColor(): Color;
        get axisTitleColor(): Color;
        get axisLineColor(): Color;
        get axisLabelsColor(): Color;
        get legendBrush(): StiBrush;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get legendBorderColor(): Color;
        get legendTitleColor(): Color;
        get legendShowShadow(): boolean;
        get legendFont(): Font;
        get toolTipBrush(): StiBrush;
        get toolTipTextBrush(): StiBrush;
        get toolTipBorder(): StiSimpleBorder;
        get styleId(): StiChartStyleId;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStyleCoreXF29 extends StiStyleCoreXF26 {
        get localizedName(): string;
        _styleColor: Color[];
        get styleColors(): Color[];
        get styleId(): StiChartStyleId;
        get chartAreaBorderColor(): Color;
        get legendShowShadow(): boolean;
        get legendBorderColor(): Color;
        get seriesLabelsColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiStyleCoreXF30 extends StiStyleCoreXF22 {
        get localizedName(): string;
        _styleColor: Color[];
        get styleColors(): Color[];
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get chartAreaBorderColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsFont(): Font;
        get legendBrush(): StiBrush;
        get legendLabelsColor(): Color;
        get legendTitleColor(): Color;
        get legendShowShadow(): boolean;
        get legendBorderColor(): Color;
        get legendFont(): Font;
        get seriesLighting(): boolean;
        getColumnBorder(color: Color): Color;
        get styleId(): StiChartStyleId;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiStyleCoreXF31 extends StiStyleCoreXF22 {
        get localizedName(): string;
        _styleColor: Color[];
        get styleColors(): Color[];
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get chartAreaBorderColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsFont(): Font;
        get legendBrush(): StiBrush;
        get legendLabelsColor(): Color;
        get legendTitleColor(): Color;
        get legendShowShadow(): boolean;
        get legendBorderColor(): Color;
        get legendFont(): Font;
        get toolTipBrush(): StiBrush;
        get toolTipTextBrush(): StiBrush;
        get toolTipBorder(): StiSimpleBorder;
        get seriesLighting(): boolean;
        getColumnBorder(color: Color): Color;
        get styleId(): StiChartStyleId;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiStyleCoreXF32 extends StiStyleCoreXF22 {
        get localizedName(): string;
        _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get legendBrush(): StiBrush;
        get legendLabelsColor(): Color;
        get legendBorderColor(): Color;
        get legendTitleColor(): Color;
        get legendShowShadow(): boolean;
        get legendFont(): Font;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsLineColor(): Color;
        get seriesLabelsFont(): Font;
        get axisTitleColor(): Color;
        get axisLineColor(): Color;
        get axisLabelsColor(): Color;
        get gridLinesHorColor(): Color;
        get gridLinesVertColor(): Color;
        get toolTipBrush(): StiBrush;
        get seriesLighting(): boolean;
        get styleId(): StiChartStyleId;
        getColumnBorder(color: Color): Color;
        getColumnBrush(color: Color): StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiStyleCoreXF33 extends StiStyleCoreXF {
        get localizedName(): string;
        _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get legendBrush(): StiBrush;
        get legendLabelsColor(): Color;
        get legendBorderColor(): Color;
        get legendTitleColor(): Color;
        get legendShowShadow(): boolean;
        get legendFont(): Font;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsLineColor(): Color;
        get seriesLabelsFont(): Font;
        get axisTitleColor(): Color;
        get axisLineColor(): Color;
        get axisLabelsColor(): Color;
        get gridLinesHorColor(): Color;
        get gridLinesVertColor(): Color;
        get seriesLighting(): boolean;
        get styleId(): StiChartStyleId;
        getColumnBorder(color: Color): Color;
        getColumnBrush(color: Color): StiBrush;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiStyleCoreXF34 extends StiStyleCoreXF22 {
        get localizedName(): string;
        _styleColor: Color[];
        get styleColors(): Color[];
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get chartAreaBorderColor(): Color;
        get legendBrush(): StiBrush;
        get legendLabelsColor(): Color;
        get legendBorderColor(): Color;
        get legendTitleColor(): Color;
        get legendShowShadow(): boolean;
        get legendFont(): Font;
        get toolTipBrush(): StiBrush;
        get toolTipTextBrush(): StiBrush;
        get toolTipBorder(): StiSimpleBorder;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsFont(): Font;
        get seriesLighting(): boolean;
        get styleId(): StiChartStyleId;
        getColumnBorder(color: Color): Color;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiStyleCoreXF35 extends StiStyleCoreXF22 {
        get localizedName(): string;
        _styleColor: Color[];
        get styleColors(): Color[];
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get chartAreaBorderColor(): Color;
        get legendBrush(): StiBrush;
        get legendLabelsColor(): Color;
        get legendBorderColor(): Color;
        get legendTitleColor(): Color;
        get legendShowShadow(): boolean;
        get legendFont(): Font;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsFont(): Font;
        get toolTipBrush(): StiBrush;
        get toolTipTextBrush(): StiBrush;
        get toolTipBorder(): StiSimpleBorder;
        get seriesLighting(): boolean;
        get styleId(): StiChartStyleId;
        getColumnBorder(color: Color): Color;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiStyleCoreXF36 extends StiStyleCoreXF26 {
        get localizedName(): string;
        get styleColors(): Color[];
        get chartAreaBorderColor(): Color;
        get legendBorderColor(): Color;
        get legendShowShadow(): boolean;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsFont(): Font;
        get seriesLighting(): boolean;
        get seriesShowShadow(): boolean;
        get styleId(): StiChartStyleId;
        getColumnBorder(color: Color): Color;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiStyleCoreXF37 extends StiStyleCoreXF26 {
        get localizedName(): string;
        getAreaBrush(color: Color): StiBrush;
        get styleId(): StiChartStyleId;
        get styleColors(): Color[];
        get chartAreaBorderColor(): Color;
        get legendShowShadow(): boolean;
        get legendBorderColor(): Color;
        get axisTitleColor(): Color;
        get axisLineColor(): Color;
        get axisLabelsColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsFont(): Font;
        get seriesLighting(): boolean;
        get seriesShowShadow(): boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiChartTableCoreXF implements ICloneable, IStiApplyStyle, IStiChartTableCoreXF {
        implements(): any[];
        applyStyle(style: IStiChartStyle): void;
        clone(): StiChartTableCoreXF;
        private storedCulture;
        chartTable: IStiChartTable;
        showTable(): boolean;
        getHeightTable(context: StiContext, widthTable: number): number;
        getHeightHeaderTable(context: StiContext, widthTable: number): number;
        getWidthCellLegend(context: StiContext): number;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        private getMaxCountValues;
        private getArguments;
        getLabelText(objectValue: any, series: IStiSeries): string;
        private getTableValues;
        constructor(table: IStiChartTable);
    }
}
export namespace Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTrendLineCoreXF implements ICloneable, IStiTrendLineCoreXF {
        implements(): any[];
        clone(): StiTrendLineCoreXF;
        get localizedName(): string;
        trendLine: IStiTrendLine;
        renderTrendLine(geom: StiAreaGeom, points: PointD[], posY: number): void;
        sum(values: number[]): number;
        sumSqr(values: number[]): number;
        sumProductions(valuesX: number[], valuesY: number[]): number;
        sumProductionsXLogY(valuesX: number[], valuesY: number[]): number;
        sumLn(values: number[]): number;
        constructor(trendLine: IStiTrendLine);
    }
}
export namespace Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTrendLineExponentialCoreXF extends StiTrendLineCoreXF {
        get localizedName(): string;
        renderTrendLine(geom: StiAreaGeom, points: PointD[], posY: number): void;
        constructor(trendLine: IStiTrendLine);
    }
}
export namespace Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTrendLineLinearCoreXF extends StiTrendLineCoreXF {
        get localizedName(): string;
        renderTrendLine(geom: StiAreaGeom, points: PointD[], posY: number): void;
        constructor(trendLine: IStiTrendLine);
    }
}
export namespace Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTrendLineLogarithmicCoreXF extends StiTrendLineCoreXF {
        get localizedName(): string;
        renderTrendLine(geom: StiAreaGeom, points: PointD[], posY: number): void;
        constructor(trendLine: IStiTrendLine);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiTrendLineNoneCoreXF extends StiTrendLineCoreXF {
        get localizedName(): string;
        constructor(trendLine: IStiTrendLine);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiGeom = Stimulsoft.Base.Context.StiGeom;
    import StiGeomType = Stimulsoft.Base.Context.StiGeomType;
    class StiCellGeom extends StiGeom implements IStiCellGeom {
        implements(): any[];
        get invisible(): boolean;
        type: StiGeomType;
        childGeoms: StiCellGeom[];
        clientRectangle: RectangleD;
        dispose(): void;
        contains(x: number, y: number): boolean;
        getGeomAt(parent: StiCellGeom, x: number, y: number): StiCellGeom;
        getSeriesGeoms(): StiCellGeom[];
        getSeriesElementGeoms(): StiCellGeom[];
        getRect(geom: StiGeom): RectangleD;
        createChildGeoms(): void;
        draw(context: StiContext): void;
        drawGeom(context: StiContext): void;
        drawChildGeoms(context: StiContext): void;
        protected allowChildDrawing(cellGeom: StiCellGeom): boolean;
        constructor(clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiChartGeom extends StiCellGeom {
        draw(context: StiContext): void;
        constructor(clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiNullableDrawing {
        static drawLines(context: StiContext, penGeom: StiPenGeom, points: PointD[], animation?: StiAnimation): void;
        static drawLines2(context: StiContext, penGeom: StiPenGeom, pointsStart: PointD[], points: PointD[], animation?: StiAnimation): void;
        static drawCurve(context: StiContext, penGeom: StiPenGeom, points: PointD[], tension: number, animation?: StiAnimation): void;
        static getPointsList(points: PointD[]): PointD[][];
        static getNullablePointsList(points: PointD[]): PointD[][];
        static getPointsList2(points1: PointD[], points2: PointD[], REFlist1: any, REFlist2: any): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAreaGeom extends StiCellGeom {
        area: IStiArea;
        draw(context: StiContext): void;
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import List = Stimulsoft.System.Collections.List;
    class StiLineF {
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        constructor(x1: number, y1: number, x2: number, y2: number);
    }
    class StiAxisAreaGeom extends StiAreaGeom {
        view: StiAxisAreaViewGeom;
        private minWidth;
        private drawInterlacingHor;
        private drawInterlacingVer;
        private getGridLinesHorMajor;
        private getGridLinesHorMinor;
        private getGridLinesVerMajor;
        private getGridLinesVerMinor;
        protected allowChildDrawing(cellGeom: StiCellGeom): boolean;
        isChildVisibleInView(cellGeom: StiCellGeom): boolean;
        draw(context: StiContext): void;
        drawLines(context: StiContext, lines: List<StiLineF>, pen: StiPenGeom): void;
        constructor(view: StiAxisAreaViewGeom, area: IStiArea, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisAreaViewGeom extends StiAreaGeom {
        draw(context: StiContext): void;
        drawGeom(context: StiContext): void;
        drawChildGeoms(context: StiContext): void;
        private drawBorder;
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieAreaGeom extends StiAreaGeom {
        draw(context: StiContext): void;
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDoughnutAreaGeom extends StiPieAreaGeom {
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiDoughnutAreaIndicatorGeom extends StiCellGeom {
        indicator: StiDoughnutAreaIndicator;
        valueText: string;
        titleText: string;
        draw(context: StiContext): void;
        drawText(context: StiContext, text: string, color: Color, rect: Rectangle, font: Font): void;
        static getFontSize(context: StiContext, rect: Rectangle, text: string, font: Font): number;
        constructor(clientRectangle: Rectangle, valueText: string, titleText: string, indicator: StiDoughnutAreaIndicator);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPictorialAreaGeom extends StiAreaGeom {
        draw(context: StiContext): void;
        drawGeom(context: StiContext): void;
        private drawBorder;
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRadarAreaGeom extends StiAreaGeom {
        valuesCount: number;
        private drawHor;
        private drawVert;
        private drawBackground;
        draw(context: StiContext): void;
        constructor(area: IStiArea, clientRectangle: RectangleD, valuesCount: number);
    }
}
export namespace Stimulsoft.Report.Chart {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiSunburstAreaGeom extends StiPieAreaGeom {
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTreemapAreaGeom extends StiAreaGeom {
        draw(context: StiContext): void;
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisLabelGeom extends StiCellGeom {
        rotationMode: StiRotationMode;
        textPoint: PointD;
        angle: number;
        axis: IStiAxis;
        text: string;
        stripLine: StiStripLineXF;
        width: number;
        wordWrap: boolean;
        draw(context: StiContext): void;
        constructor(axis: IStiAxis, clientRectangle: RectangleD, textPoint: PointD, text: string, stripLine: StiStripLineXF, angle: number, width: number, rotationMode: StiRotationMode, wordWrap: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisTitleGeom extends StiCellGeom {
        axis: IStiAxis;
        angle: number;
        font: StiFontGeom;
        draw(context: StiContext): void;
        constructor(axis: IStiAxis, clientRectangle: RectangleD, angle: number, stringAlignment: StringAlignment, font: StiFontGeom);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiXAxisGeom extends StiCellGeom {
        axis: IStiXAxis;
        isCenterAxis: boolean;
        view: StiXAxisViewGeom;
        drawArrow(context: StiContext, rect: RectangleD): void;
        private drawAxisLine;
        private drawMinorTicks;
        private drawTicks;
        private isArgumentDateTime;
        private drawAxis;
        private getViewclipRect;
        allowChildDrawing(cellGeom: StiCellGeom): boolean;
        draw(context: StiContext): void;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD, isCenterAxis: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiXAxisViewGeom extends StiXAxisGeom {
        drawChildGeoms(context: StiContext): void;
        draw(context: StiContext): void;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD, isCenterAxis: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiYAxisGeom extends StiCellGeom {
        axis: IStiYAxis;
        isCenterAxis: boolean;
        view: StiYAxisViewGeom;
        drawArrow(context: StiContext, rect: RectangleD): void;
        private drawAxisLine;
        private drawMinorTicks;
        private drawTicks;
        private drawAxis;
        private getViewclipRect;
        allowChildDrawing(cellGeom: StiCellGeom): boolean;
        draw(context: StiContext): void;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD, isCenterAxis: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiYAxisViewGeom extends StiYAxisGeom {
        drawChildGeoms(context: StiContext): void;
        draw(context: StiContext): void;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD, isCenterAxis: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDownButtonGeom extends StiCellGeom {
        private axis;
        draw(context: StiContext): void;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHorzScrollBarGeom extends StiCellGeom {
        draw(context: StiContext): void;
        axis: IStiXAxis;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHorzTrackBarGeom extends StiCellGeom {
        draw(context: StiContext): void;
        axis: IStiXAxis;
        scrollBar: StiHorzScrollBarGeom;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD, scrollBar: StiHorzScrollBarGeom);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLeftButtonGeom extends StiCellGeom {
        axis: IStiXAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRightButtonGeom extends StiCellGeom {
        axis: IStiXAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiUpButtonGeom extends StiCellGeom {
        axis: IStiYAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiVertScrollBarGeom extends StiCellGeom {
        draw(context: StiContext): void;
        private axis;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiVertTrackBarGeom extends StiCellGeom {
        draw(context: StiContext): void;
        axis: IStiYAxis;
        scrollBar: StiVertScrollBarGeom;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD, scrollBar: StiVertScrollBarGeom);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiChartTitleGeom extends StiCellGeom {
        title: IStiChartTitle;
        draw(context: StiContext): void;
        constructor(title: IStiChartTitle, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiConstantLinesVerticalGeom extends StiCellGeom {
        line: IStiConstantLines;
        point: PointD;
        mode: StiRotationMode;
        draw(context: StiContext): void;
        constructor(line: IStiConstantLines, clientRectangle: RectangleD, point: PointD, mode: StiRotationMode);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiConstantLinesYGeom extends StiCellGeom {
        line: IStiConstantLines;
        point: PointD;
        mode: StiRotationMode;
        draw(context: StiContext): void;
        constructor(line: IStiConstantLines, clientRectangle: RectangleD, point: PointD, mode: StiRotationMode);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendGeom extends StiCellGeom {
        legend: IStiLegend;
        seriesItems: StiLegendItemCoreXF[];
        legendTitleGeom: StiLegendTitleGeom;
        dispose(): void;
        draw(context: StiContext): void;
        constructor(legend: IStiLegend, clientRectangle: RectangleD, seriesItems: StiLegendItemCoreXF[]);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendItemGeom extends StiCellGeom {
        legend: IStiLegend;
        item: StiLegendItemCoreXF;
        colorIndex: number;
        legendItemsCount: number;
        private legendItemIndex;
        draw(context: StiContext): void;
        constructor(legend: IStiLegend, item: StiLegendItemCoreXF, clientRectangle: RectangleD, colorIndex: number, legendItemsCount: number, legendItemIndex: number);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendTitleGeom extends StiCellGeom {
        legend: IStiLegend;
        draw(context: StiContext): void;
        constructor(legend: IStiLegend, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHeatmapLegendGeom extends StiCellGeom {
        legend: IStiLegend;
        legendTitleGeom: StiLegendTitleGeom;
        draw(context: StiContext): void;
        constructor(legend: IStiLegend, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHeatmapLegendItemGeom extends StiCellGeom {
        legend: IStiLegend;
        startItemCore: StiHeatmapLegendItemCoreXF;
        endItemCore: StiHeatmapLegendItemCoreXF;
        draw(context: StiContext): void;
        constructor(legend: IStiLegend, clientRectangle: RectangleD, startItemCore: StiHeatmapLegendItemCoreXF, endItemCore: StiHeatmapLegendItemCoreXF);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHeatmapLegendMarkerGeom extends StiCellGeom {
        legend: IStiLegend;
        colors: Color[];
        draw(context: StiContext): void;
        private drawMarker;
        constructor(legend: IStiLegend, colors: Color[], clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendAreaMarker implements IStiLegendMarker {
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendCandelstickMarker implements IStiLegendMarker {
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendColumnMarker implements IStiLegendMarker {
        implements(): any[];
        draw(context: StiContext, series: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendDoughnutMarker implements IStiLegendMarker {
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiLegendFontIconMarker implements IStiLegendMarker {
        draw(context: StiContext, series: IStiSeries, rect: Rectangle, colorIndex: number, colorCount: number, index: number): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendFunnelMarker implements IStiLegendMarker {
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendLineMarker implements IStiLegendMarker {
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiLegendMarkerHelper {
        static getSteppedMarkerPath(rect: RectangleD): StiSegmentGeom[];
        static getAreaMarkerPath(rect: RectangleD): StiSegmentGeom[];
        static getAreaMarkerLinePoints(rect: RectangleD): PointD[];
        static getSplineAreaMarkerPath(rect: RectangleD): StiSegmentGeom[];
        static getSplineAreaMarkerLinePoints(rect: RectangleD): PointD[];
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendPictorialMarker implements IStiLegendMarker {
        implements(): any[];
        draw(context: StiContext, series: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendPieMarker implements IStiLegendMarker {
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendRangeMarker implements IStiLegendMarker {
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendSplineAreaMarker implements IStiLegendMarker {
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendSplineRangeMarker implements IStiLegendMarker {
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendStackedAreaMarker implements IStiLegendMarker {
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendStackedSplineAreaMarker implements IStiLegendMarker {
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendSteppedAreaMarker implements IStiLegendMarker {
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendSteppedRangeMarker implements IStiLegendMarker {
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendStockMarker implements IStiLegendMarker {
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiMarkerLegendFactory {
        static createMarker(series: IStiSeries): IStiLegendMarker;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import IStiSeriesElement = Stimulsoft.Report.Chart.IStiSeriesElement;
    import StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
    class StiMarkerGeom extends StiCellGeom implements IStiSeriesElement {
        implements(): any[];
        private getValueIndex;
        getHyperlink(): string;
        private getHyperlink2;
        getToolTip(): string;
        private getToolTip2;
        interaction: StiSeriesInteractionData;
        index: number;
        point: PointD;
        marker: IStiMarker;
        value: number;
        showShadow: boolean;
        series: IStiSeries;
        elementIndex: string;
        isTooltipMode: boolean;
        contains(x: number, y: number): boolean;
        getMouseOverRect(): RectangleD;
        draw(context: StiContext): void;
        constructor(series: IStiSeries, index: number, value: number, point: PointD, marker: IStiMarker, showShadow: boolean, zoom: number, isTooltipMode: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRadarAxisGeom extends StiCellGeom {
        axis: IStiYRadarAxis;
        private drawAxisLine;
        private drawMinorTicks;
        private drawTicks;
        private drawAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiYRadarAxis, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiXRadarAxisLabelGeom extends StiCellGeom {
        borderColor: Color;
        labelBrush: StiBrush;
        text: string;
        angle: number;
        point: PointD;
        labelRect: RectangleD;
        axis: IStiXRadarAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiXRadarAxis, text: string, labelBrush: StiBrush, borderColor: Color, angle: number, clientRectangle: RectangleD, labelRect: RectangleD, point: PointD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiYRadarAxisLabelGeom extends StiCellGeom {
        rotationMode: StiRotationMode;
        textPoint: PointD;
        angle: number;
        axis: IStiYRadarAxis;
        text: string;
        stripLine: StiStripLineXF;
        draw(context: StiContext): void;
        constructor(axis: IStiYRadarAxis, clientRectangle: RectangleD, textPoint: PointD, text: string, stripLine: StiStripLineXF, angle: number, rotationMode: StiRotationMode);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMouseOverHelper {
        static getMouseOverColor(): Color;
        static getLineMouseOverColor(): Color;
        static mouseOverLineDistance: number;
        static mouseOverSplineDistance: number;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    import IStiSeriesElement = Stimulsoft.Report.Chart.IStiSeriesElement;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
    class StiSeriesElementGeom extends StiCellGeom implements IStiSeriesElement {
        implements(): any[];
        protected getValueIndex(): number;
        getHyperlink(): string;
        private getHyperlink2;
        getToolTip(): string;
        private getToolTip2;
        seriesBrush: StiBrush;
        value: number;
        index: number;
        series: IStiSeries;
        areaGeom: StiAreaGeom;
        elementIndex: string;
        _interaction: StiSeriesInteractionData;
        get interaction(): StiSeriesInteractionData;
        set interaction(value: StiSeriesInteractionData);
        draw(context: StiContext): void;
        getInteractionData(): StiInteractionDataGeom;
        getSeriesBorderThickness(zoom: number): number;
        protected getCornerRadius(): StiCornerRadius;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiSeries, clientRectangle: RectangleD, brush: StiBrush);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
    class StiSeriesGeom extends StiCellGeom {
        series: IStiSeries;
        interactions: StiSeriesInteractionData[];
        areaGeom: StiAreaGeom;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, series: IStiSeries, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBoxAndWhiskerSeriesElementGeom extends StiCellGeom {
        brush: StiBrush;
        borderColor: Color;
        beginTime: TimeSpan;
        areaGeom: StiAreaGeom;
        mean: number;
        maximum: number;
        minimum: number;
        median: number;
        firstQuartile: number;
        thirdQuartile: number;
        positionX: number;
        values: number[];
        series: IStiSeries;
        draw(context: StiContext): void;
        getSeriesBorderThickness(zoom: number): number;
        constructor(areaGeom: StiAreaGeom, series: IStiSeries, positionX: number, minimum: number, maximim: number, firstQuartile: number, thirdQuartile: number, median: number, values: number[], mean: number, clientRectangle: Rectangle, brush: StiBrush, borderColor: Color, beginTime: TimeSpan);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiBubbleSeriesElementGeom extends StiSeriesElementGeom {
        seriesBrush: StiBrush;
        seriesBorderColor: Color;
        beginTime: TimeSpan;
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, clientRectangle: RectangleD, beginTime: TimeSpan);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiClusteredBarSeriesElementGeom extends StiSeriesElementGeom {
        seriesBorderColor: Color;
        valueStart: number;
        columnRectStart: RectangleD;
        draw(context: StiContext): void;
        private getBorderPath;
        protected getAnimation(): StiAnimation;
        constructor(areaGeom: StiAreaGeom, valueStart: number, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, columnRectStart: RectangleD, columnRect: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiBaseLineSeriesGeom extends StiSeriesGeom {
        additionalSeriesId: string;
        points: PointD[];
        pointsFrom: PointD[];
        pointsIds: string[];
        get allowMouseOver(): boolean;
        static getClientRectangle(points: PointD[], lineWidth: number): RectangleD;
        draw(context: StiContext): void;
        protected getAnimation(points?: PointD[]): StiAnimation;
        protected getAnimationConnect(points?: PointD[]): StiAnimation;
        protected getAnimation2(pointsFrom: PointD[], points: PointD[], pointsIds: string[]): StiAnimation;
        constructor(areaGeom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo, series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiLineSeriesGeom extends StiBaseLineSeriesGeom {
        pointsZeroConnect: PointD[];
        pointsNullConnect: PointD[];
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        private getPointCross;
        constructor(areaGeom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo, series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiAreaSeriesGeom extends StiLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo, series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiClusteredColumnSeriesElementGeom extends StiSeriesElementGeom {
        seriesBorderColor: Color;
        columnRectStart: RectangleD;
        draw(context: StiContext): void;
        private getBorderPath;
        protected getAnimation(): StiAnimation;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, columnRect: RectangleD, columnRectStart: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSplineSeriesGeom extends StiBaseLineSeriesGeom {
        pointsZeroConnect: PointD[];
        pointsNullConnect: PointD[];
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo, series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiSplineAreaSeriesGeom extends StiSplineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo, series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSteppedLineSeriesGeom extends StiBaseLineSeriesGeom {
        getSteppedPoints(points: PointD[]): PointD[];
        protected getSteppedPointsIds(ids: string[]): string[];
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        private intersectionAxis;
        constructor(areaGeom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo, series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiSteppedAreaSeriesGeom extends StiSteppedLineSeriesGeom {
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo, series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import PointF = Stimulsoft.System.Drawing.Point;
    import StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiWaterfallLineGeom extends StiCellGeom {
        pen: StiPenGeom;
        pointStart: PointF;
        pointEnd: PointF;
        animation: boolean;
        draw(context: StiContext): void;
        constructor(pointStart: PointF, pointEnd: PointF, pen: StiPenGeom, clientRectangle: Rectangle, animation: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiDoughnutEmptySeriesElementGeom extends StiCellGeom {
        draw(context: StiContext): void;
        constructor(clientRectangle: Rectangle);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDoughnutSeriesElementGeom extends StiSeriesElementGeom {
        clientRectangleDt: RectangleD;
        path: StiSegmentGeom[];
        pathLight: StiSegmentGeom[];
        pathDark: StiSegmentGeom[];
        borderColor: Color;
        brush: StiBrush;
        brushLight: StiBrush;
        brushDark: StiBrush;
        startAngle: number;
        endAngle: number;
        radiusFrom: number;
        radiusTo: number;
        beginTime: TimeSpan;
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        private getAnimation;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiDoughnutSeries, clientRectangle: RectangleD, clientRectangleDt: RectangleD, path: StiSegmentGeom[], pathLight: StiSegmentGeom[], pathDark: StiSegmentGeom[], borderColor: Color, brush: StiBrush, brushLight: StiBrush, brushDark: StiBrush, startAngle: number, endAngle: number, radiusFrom: number, radiusTo: number, beginTime: TimeSpan);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
    class StiFinancialSeriesElementGeom extends StiCellGeom {
        series: IStiSeries;
        interaction: StiSeriesInteractionData;
        open: number;
        close: number;
        high: number;
        low: number;
        positionX: number;
        areaGeom: StiAreaGeom;
        index: number;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, series: IStiSeries, clientRectangle: RectangleD, open: number, close: number, high: number, low: number, positionX: number, index: number);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCandlestickSeriesElementGeom extends StiFinancialSeriesElementGeom {
        brush: StiBrush;
        borderColor: Color;
        beginTime: TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, series: IStiSeries, clientRectangle: RectangleD, bodyStart: number, bodyEnd: number, high: number, low: number, positionX: number, index: number, brush: StiBrush, borderColor: Color, beginTime: TimeSpan);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStockSeriesElementGeom extends StiFinancialSeriesElementGeom {
        color: Color;
        beginTime: TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, series: IStiSeries, clientRectangle: RectangleD, open: number, close: number, high: number, low: number, positionX: number, index: number, color: Color, beginTime: TimeSpan);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiFunnelEmptySeriesElementGeom extends StiCellGeom {
        path: StiSegmentGeom[];
        draw(context: StiContext): void;
        constructor(clientRectangle: Rectangle, path: StiSegmentGeom[]);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiFunnelSeriesElementGeom extends StiSeriesElementGeom {
        path: StiSegmentGeom[];
        borderColor: Color;
        brush: StiBrush;
        beginTime: TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiSeries, clientRectangle: RectangleD, brush: StiBrush, borderColor: Color, path: StiSegmentGeom[], beginTime: TimeSpan);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiGanttSeriesElementGeom extends StiSeriesElementGeom {
        rectFrom: RectangleD;
        draw(context: StiContext): void;
        protected getAnimation(): StiAnimation;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiSeries, clientRectangle: RectangleD, rectFrom: RectangleD, brush: StiBrush);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiHeatmapSeriesElementGeom extends StiSeriesElementGeom {
        seriesBorderColor: Color;
        animation: StiAnimation;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, columnRect: Rectangle, animation: StiAnimation);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import List = Stimulsoft.System.Collections.List;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiPictorialEmptySeriesElementGeom extends StiSeriesElementGeom {
        animation: StiAnimation;
        drawRectangles: List<Rectangle>;
        clipRectangles: List<Rectangle>;
        icon: StiFontIcons;
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        protected getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, series: IStiSeries, icon: StiFontIcons, drawRectangles: List<Rectangle>, clipRectangles: List<Rectangle>, clientRectangle: Rectangle, animation: StiAnimation);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiPictorialSeriesElementGeom extends StiSeriesElementGeom {
        icon: StiFontIcons;
        drawRectangles: RectangleD[];
        clipRectangles: RectangleD[];
        seriesBrush: StiBrush;
        animation: StiAnimation;
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, series: IStiSeries, icon: StiFontIcons, drawRectangles: RectangleD[], clipRectangles: RectangleD[], clientRectangle: RectangleD, animation: StiAnimation);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiPictorialStackedEmptySeriesElementGeom extends StiSeriesElementGeom {
        animation: StiAnimation;
        clipRectangle: Rectangle;
        icon: StiFontIcons;
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        getFontGeom(context: StiContext): StiFontGeom;
        measureFontSize(context: StiContext, rect: Rectangle, font: StiFontGeom): number;
        protected getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, series: IStiSeries, icon: StiFontIcons, clientRectangle: Rectangle, clipRectangle: Rectangle, animation: StiAnimation);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiPictorialStackedSeriesElementGeom extends StiSeriesElementGeom {
        icon: StiFontIcons;
        clipRectangle: RectangleD;
        animation: StiAnimation;
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        private getFontGeom;
        private measureFontSize;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, series: IStiSeries, icon: StiFontIcons, clientRectangle: RectangleD, clipRectangle: RectangleD, animation: StiAnimation);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPie3dMainSideSeriesElementGeom extends StiSeriesElementGeom {
        borderColor: Color;
        startAngle: number;
        sweepAngle: number;
        realStartAngle: number;
        realSweepAngle: number;
        count: number;
        get interaction(): StiSeriesInteractionData;
        pie3DSlice: StiPie3dSlice;
        draw(context: StiContext): void;
        private getAnimation;
        constructor(pie3DSlice: StiPie3dSlice, areaGeom: StiAreaGeom, value: number, index: number, count: number, series: IStiPieSeries, clientRectangle: RectangleD, borderColor: Color, brush: StiBrush, startAngle: number, sweepAngle: number);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiPie3dSidesSeriesElementGeom extends StiSeriesElementGeom {
        s_shadowAngle: number;
        pen: StiPenGeom;
        startnAngle: number;
        sweepAngle: number;
        m_boundingRectangle: Rectangle;
        m_sliceHeight: number;
        m_startAngle: number;
        m_sweepAngle: number;
        m_center: Point;
        m_centerBelow: Point;
        m_pointStart: Point;
        m_pointStartBelow: Point;
        m_pointEnd: Point;
        m_pointEndBelow: Point;
        m_brushStartSide: StiBrush;
        m_brushEndSide: StiBrush;
        m_brushPeripherySurface: StiBrush;
        m_brushSurface: StiBrush;
        m_startSide: StiPie3dQuadrilateral;
        m_endSide: StiPie3dQuadrilateral;
        count: number;
        startSideExists: boolean;
        endSideExists: boolean;
        get StartAngle(): number;
        get EndAngle(): number;
        get Interaction(): StiSeriesInteractionData;
        pie3DSlice: StiPie3dSlice;
        draw(context: StiContext): void;
        private drawStartSide;
        private drawEndSide;
        private drawVisiblePeriphery;
        private drawHiddenPeriphery;
        private getHiddenPeripherySurfaceBounds;
        private getVisiblePeripherySurfaceBounds;
        protected drawCylinderSurfaceSection(context: StiContext, pen: StiPenGeom, brush: StiBrush, peripherySurfaceBounds: StiPie3dPeripherySurfaceBounds): void;
        getTextPosition(): Point;
        protected getActualAngle(transformedAngle: number): number;
        private createPathForCylinderSurfaceSection;
        private initializePieSlice;
        private initializeSides;
        protected createSurfaceBrushes(shadowStyle: StiPie3dLightingStyle): void;
        protected createBrushForSide(color: Color, angle: number): StiBrush;
        protected createBrushForPeriphery(color: Color): StiBrush;
        static createColorWithCorrectedLightness(color: Color, correctionFactor: number): Color;
        protected peripheralPoint(xCenter: number, yCenter: number, semiMajor: number, semiMinor: number, angleDegrees: number): Point;
        protected transformAngle(angle: number): number;
        private getAnimation;
        constructor(pie3DSlice: StiPie3dSlice, areaGeom: StiAreaGeom, value: number, index: number, count: number, series: IStiPie3dSeries, clientRectangle: Rectangle, borderColor: Color, brush: StiBrush, startAngle: number, sweepAngle: number, pieHeight: number, startSideExists: boolean, endSideExists: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiPieEmptySeriesElementGeom extends StiCellGeom {
        draw(context: StiContext): void;
        constructor(clientRectangle: Rectangle);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieSeriesElementGeom extends StiSeriesElementGeom {
        path: StiSegmentGeom[];
        pathLight: StiSegmentGeom[];
        borderColor: Color;
        brush: StiBrush;
        startAngle: number;
        endAngle: number;
        radius: number;
        beginTime: TimeSpan;
        count: number;
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        private getAnimation;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiPieSeries, clientRectangle: RectangleD, path: StiSegmentGeom[], pathLight: StiSegmentGeom[], borderColor: Color, brush: StiBrush, startAngle: number, endAngle: number, radius: number);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieSeriesFullElementGeom extends StiSeriesElementGeom {
        brush: StiBrush;
        borderColor: Color;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiPieSeries, clientRectangle: RectangleD, brush: StiBrush, borderColor: Color);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieSeriesShadowElementGeom extends StiCellGeom {
        get invisible(): boolean;
        series: IStiPieSeries;
        shadowContext: StiContext;
        radius: number;
        duration: TimeSpan;
        beginTime: TimeSpan;
        isAnimation: boolean;
        draw(context: StiContext): void;
        constructor(series: IStiPieSeries, clientRectangle: RectangleD, radius: number, shadowContext: StiContext, duration: TimeSpan, beginTime: TimeSpan);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiRadarAreaSeriesGeom extends StiCellGeom {
        series: IStiSeries;
        pointsFrom: PointD[];
        points: PointD[];
        pointsIds: string[];
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(series: IStiSeries, pointsInfo: StiSeriesPointsInfo);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRadarPointSeriesElementGeom extends StiSeriesElementGeom {
        protected getValueIndex(): number;
        point: PointD;
        contains(x: number, y: number): boolean;
        getMouseOverRect(): RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, brush: StiBrush, series: IStiRadarSeries, point: PointD, zoom: number);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiRangeBarElementGeom extends StiSeriesElementGeom {
        rectFrom: RectangleD;
        draw(context: StiContext): void;
        protected getAnimation(): StiAnimation;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiSeries, brush: StiBrush, clientRectangle: RectangleD, rectFrom: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiRangeSeriesGeom extends StiLineSeriesGeom {
        pointsEnd: PointD[];
        draw(context: StiContext): void;
        private isPointsEqual;
        private getBrush;
        private fillPath;
        private intersection;
        private getPointCross2;
        constructor(areaGeom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo, series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSplineRangeSeriesGeom extends StiSplineSeriesGeom {
        pointsEnd: PointD[];
        draw(context: StiContext): void;
        private fillPath;
        constructor(areaGeom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo, series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSteppedRangeSeriesGeom extends StiSteppedLineSeriesGeom {
        pointsEnd: PointD[];
        draw(context: StiContext): void;
        private getBrush;
        private fillPath;
        private intersection;
        constructor(areaGeom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo, series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiScatterSplineSeriesGeom extends StiBaseLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo, series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiStackedBarSeriesElementGeom extends StiSeriesElementGeom {
        seriesBorderColor: Color;
        columnRectStart: RectangleD;
        draw(context: StiContext): void;
        private getBorderPath;
        protected getAnimation(): StiAnimation;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, clientRectangle: RectangleD, columnRectStart: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedBarSeriesShadowElementGeom extends StiCellGeom {
        get invisible(): boolean;
        series: IStiSeries;
        isLeftShadow: boolean;
        isRightShadow: boolean;
        draw(context: StiContext): void;
        constructor(series: IStiSeries, clientRectangle: RectangleD, isLeftShadow: boolean, isRightShadow: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import List = Stimulsoft.System.Collections.List;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    class StiRibbonSeriesGeom extends StiSeriesGeom {
        metadata: StiRibbonSeriesMetadata;
        beginTime: TimeSpan;
        static getClientRectangle(rectangles: List<Rectangle>): Rectangle;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, metadata: StiRibbonSeriesMetadata, series: IStiSeries, beginTime: TimeSpan);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedAreaSeriesGeom extends StiSeriesGeom {
        startPoints: PointD[];
        endPoints: PointD[];
        pointsIds: string[];
        contains(x: number, y: number): boolean;
        static getClientRectangle(startPoints: PointD[], endPoints: PointD[]): RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo, series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedBaseLineSeriesGeom extends StiSeriesGeom {
        points: PointD[];
        static getClientRectangle(points: PointD[]): RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiStackedColumnSeriesElementGeom extends StiSeriesElementGeom {
        seriesBorderColor: Color;
        columnRectStart: RectangleD;
        draw(context: StiContext): void;
        private getBorderPath;
        protected getAnimation(): StiAnimation;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, clientRectangle: RectangleD, columnRectStart: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedColumnSeriesShadowElementGeom extends StiCellGeom {
        get invisible(): boolean;
        private series;
        private isTopShadow;
        private isBottomShadow;
        draw(context: StiContext): void;
        constructor(series: IStiSeries, clientRectangle: RectangleD, isTopShadow: boolean, isBottomShadow: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiStackedLineSeriesGeom extends StiBaseLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        private getPointCross;
        constructor(areaGeom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo, series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedSplineAreaSeriesGeom extends StiSeriesGeom {
        startPoints: PointD[];
        endPoints: PointD[];
        pointsIds: string[];
        contains(x: number, y: number): boolean;
        static getClientRectangle(startPoints: PointD[], endPoints: PointD[]): RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo, series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiStackedSplineSeriesGeom extends StiBaseLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo, series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiSunburstEmptySeriesElementGeom extends StiCellGeom {
        draw(context: StiContext): void;
        private drawSunburst;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import List = Stimulsoft.System.Collections.List;
    class StiSunburstSeriesElementGeom extends StiSeriesElementGeom {
        private index2;
        private index3;
        clientRectangleDt: RectangleD;
        startAngle: number;
        endAngle: number;
        radiusFrom: number;
        path: List<StiSegmentGeom>;
        borderColor: Color;
        brush: StiBrush;
        radiusTo: number;
        beginTime: TimeSpan;
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        private getAnimation;
        constructor(areaGeom: StiAreaGeom, value: number, index1: number, index2: number, index3: number, series: IStiSeries, clientRectangle: RectangleD, clientRectangleDt: RectangleD, path: List<StiSegmentGeom>, borderColor: Color, brush: StiBrush, startAngle: number, endAngle: number, radiusFrom: number, radiusTo: number, beginTime: TimeSpan);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiTreemapEmptySeriesElementGeom extends StiCellGeom {
        draw(context: StiContext): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiTreemapSeriesElementGeom extends StiSeriesElementGeom {
        seriesBrush: StiBrush;
        seriesBorderColor: Color;
        animation: StiAnimation;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, clientRectangle: RectangleD, animation: StiAnimation);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiSeriesLabelsGeom extends StiCellGeom {
        private getValueIndex;
        private getHyperlink;
        private getToolTip;
        value: number;
        index: number;
        series: IStiSeries;
        seriesLabels: IStiSeriesLabels;
        beginTime: TimeSpan;
        duration: TimeSpan;
        drawMarker(context: StiContext, itemRect: Rectangle, markerColor: any, markerBrush: StiBrush): void;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterAxisLabelsGeom extends StiSeriesLabelsGeom {
        labelColor: Color;
        labelBorderColor: Color;
        seriesBrush: StiBrush;
        seriesLabelsBrush: StiBrush;
        seriesBorderColor: Color;
        font: StiFontGeom;
        text: string;
        animation: StiAnimation;
        draw(context: StiContext): void;
        private drawLabelArea;
        private drawLabelText;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, labelColor: Color, labelBorderColor: Color, seriesBrush: StiBrush, seriesLabelsBrush: StiBrush, seriesBorderColor: Color, font: StiFontGeom, animation: StiAnimation);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsideAxisLabelsGeom extends StiSeriesLabelsGeom {
        labelColor: Color;
        labelBorderColor: Color;
        seriesBrush: StiBrush;
        seriesBorderColor: Color;
        font: StiFontGeom;
        text: string;
        startPoint: PointD;
        endPoint: PointD;
        animation: StiAnimation;
        draw(context: StiContext): void;
        private drawLabelArea;
        private drawLines;
        private drawLabelText;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, labelColor: Color, labelBorderColor: Color, seriesBrush: StiBrush, seriesBorderColor: Color, font: StiFontGeom, startPoint: PointD, endPoint: PointD, animation: StiAnimation);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterFunnelLabelsGeom extends StiSeriesLabelsGeom {
        seriesBrush: StiBrush;
        borderColor: Color;
        seriesBorderColor: Color;
        labelBrush: StiBrush;
        text: string;
        labelRect: RectangleD;
        animation: StiAnimation;
        draw(context: StiContext): void;
        private drawLabelArea;
        private drawLabelText;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, seriesBrush: StiBrush, labelBrush: StiBrush, borderColor: Color, seriesBorderColor: Color, labelRect: RectangleD, animation: StiAnimation);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsideFunnelLabelsGeom extends StiCenterFunnelLabelsGeom {
        startPointLine: PointD;
        endPointLine: PointD;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, seriesBrush: StiBrush, labelBrush: StiBrush, borderColor: Color, seriesBorderColor: Color, labelRect: RectangleD, startPointLine: PointD, endPointLine: PointD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiOutsidePictorialStackedLabelGeom extends StiSeriesLabelsGeom {
        seriesBrush: StiBrush;
        borderColor: Color;
        seriesBorderColor: Color;
        labelLineColor: Color;
        labelBrush: StiBrush;
        text: string;
        labelRect: RectangleD;
        lineRect: RectangleD;
        animation: StiAnimation;
        draw(context: StiContext): void;
        private drawLineLabel;
        private drawLabelArea;
        private drawLabelText;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, seriesBrush: StiBrush, labelBrush: StiBrush, labelLineColor: Color, borderColor: Color, seriesBorderColor: Color, labelRect: RectangleD, lineRect: RectangleD, animation: StiAnimation);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterPieLabelsGeom extends StiSeriesLabelsGeom {
        seriesBrush: StiBrush;
        borderColor: Color;
        seriesBorderColor: Color;
        seriesLabelsBrush: StiBrush;
        labelBrush: StiBrush;
        text: string;
        rotationMode: StiRotationMode;
        labelRect: RectangleD;
        angleToUse: number;
        animation: StiAnimation;
        draw(context: StiContext): void;
        private drawLabelArea;
        private drawLabelText;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, seriesBrush: StiBrush, labelBrush: StiBrush, seriesLabelsBrush: StiBrush, borderColor: Color, seriesBorderColor: Color, rotationMode: StiRotationMode, labelRect: RectangleD, angleToUse: number, animation: StiAnimation);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsidePieLabelsGeom extends StiCenterPieLabelsGeom {
        lineColor: Color;
        labelPoint: PointD;
        startPoint: PointD;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, seriesBrush: StiBrush, labelBrush: StiBrush, seriesLabelsBrush: StiBrush, borderColor: Color, seriesBorderColor: Color, rotationMode: StiRotationMode, labelRect: RectangleD, angleToUse: number, lineColor: Color, labelPoint: PointD, startPoint: PointD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTwoColumnsPieLabelsGeom extends StiSeriesLabelsGeom {
        seriesBrush: StiBrush;
        borderColor: Color;
        seriesBorderColor: Color;
        labelBrush: StiBrush;
        seriesLabelsBrush: StiBrush;
        text: string;
        labelRect: RectangleD;
        lineColor: Color;
        startPoint: PointD;
        endPoint: PointD;
        arcPoint: PointD;
        centerPie: PointD;
        animation: StiAnimation;
        draw(context: StiContext): void;
        private drawLines;
        drawMarker(context: StiContext, itemRect: Rectangle, markerColor: any, markerBrush: StiBrush): void;
        private drawLabelArea;
        private drawLabelText;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, seriesBrush: StiBrush, labelBrush: StiBrush, seriesLabelsBrush: StiBrush, borderColor: Color, seriesBorderColor: Color, labelRect: RectangleD, lineColor: Color, startPoint: PointD, endPoint: PointD, arcPoint: PointD, centerPie: PointD, animation: StiAnimation);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterTreemapLabelsGeom extends StiSeriesLabelsGeom {
        labelColor: Color;
        labelBorderColor: Color;
        seriesBrush: StiBrush;
        seriesLabelsBrush: StiBrush;
        seriesBorderColor: Color;
        font: StiFontGeom;
        text: string;
        animation: StiAnimation;
        draw(context: StiContext): void;
        private drawLabelArea;
        private drawLabelText;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, labelColor: Color, labelBorderColor: Color, seriesBrush: StiBrush, seriesLabelsBrush: StiBrush, seriesBorderColor: Color, font: StiFontGeom, animation: StiAnimation);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStripsXGeom extends StiCellGeom {
        strip: IStiStrips;
        draw(context: StiContext): void;
        constructor(strip: IStiStrips, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStripsYGeom extends StiCellGeom {
        strip: IStiStrips;
        draw(context: StiContext): void;
        constructor(strip: IStiStrips, clientRectangle: RectangleD);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiChartTableGeom extends StiCellGeom {
        constructor(clientRectangle: RectangleD, table: string[][], widthCellLegendTableChart: number, heightCellHeader: number, chartTable: IStiChartTable);
        private table;
        private widthCellLegendTableChart;
        private heightCellHeader;
        private chartTable;
        private pen;
        private font;
        private fontHeader;
        private labelBrush;
        private sf;
        private sfHeader;
        private labelHeaderBrush;
        draw(context: StiContext): void;
        private drawHeaderArgument;
        private drawTitleLegend;
        private drawRootTable;
        private checkFontSize;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTrendCurveGeom extends StiCellGeom {
        points: PointD[];
        trendLine: IStiTrendLine;
        draw(context: StiContext): void;
        constructor(points: PointD[], trendLine: IStiTrendLine);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTrendLineGeom extends StiCellGeom {
        private trendLine;
        private pointStart;
        private pointEnd;
        draw(context: StiContext): void;
        private static getArray;
        constructor(pointStart: PointD, pointEnd: PointD, trendLine: IStiTrendLine);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class Sti3dOptions implements ISti3dOptions {
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        get propName(): string;
        private opacity_;
        get opacity(): number;
        set opacity(value: number);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiPie3dOptions extends Sti3dOptions implements IStiPie3dOptions {
        meta(): StiMeta[];
        lighting: StiPie3dLightingStyle;
        private height_;
        get height(): number;
        set height(value: number);
        private distance_;
        get distance(): number;
        set distance(value: number);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiBoxAndWhiskerArea extends StiAxisArea implements IStiBoxAndWhiskerArea {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiScatterArea extends StiClusteredColumnArea implements IStiScatterArea, IStiArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiBubbleArea extends StiScatterArea implements IStiScatterArea, IStiClusteredColumnArea, IStiArea, IStiAxisArea, IStiJsonReportObject, ICloneable, IStiBubbleArea {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCandlestickArea extends StiClusteredColumnArea implements IStiCandlestickArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, IStiArea, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiClusteredBarArea extends StiClusteredColumnArea implements IStiArea, IStiClusteredBarArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAreaArea extends StiClusteredColumnArea implements IStiArea, IStiClusteredColumnArea, IStiAxisArea, IStiAreaArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiHistogramArea extends StiAxisArea {
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiLineArea extends StiClusteredColumnArea implements IStiArea, IStiLineArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiParetoArea extends StiClusteredColumnArea implements IStiArea, IStiParetoArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSplineArea extends StiClusteredColumnArea implements IStiArea, IStiSplineArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSplineAreaArea extends StiClusteredColumnArea implements IStiArea, IStiSplineAreaArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSteppedAreaArea extends StiClusteredColumnArea implements IStiArea, IStiSteppedAreaArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSteppedLineArea extends StiClusteredColumnArea implements IStiArea, IStiClusteredColumnArea, IStiAxisArea, IStiSteppedLineArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiWaterfallArea extends StiAxisArea implements IStiWaterfallArea, IStiRoundValuesArea {
        implements(): any[];
        meta(): StiMeta[];
        roundValues: boolean;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiPieArea extends StiArea implements IStiJsonReportObject, IStiPieArea, IStiArea, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiDoughnutArea extends StiPieArea implements IStiJsonReportObject, IStiPieArea, IStiArea, ICloneable, IStiDoughnutArea {
        implements(): any[];
        meta(): StiMeta[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        clone(): StiDoughnutArea;
        indicator: StiDoughnutAreaIndicator;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiDoughnutAreaIndicator implements IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(m: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiDoughnutAreaIndicator;
        visible: boolean;
        value: StiDoughnutAreaIndicatorValue;
        title: StiDoughnutAreaIndicatorTitle;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDoughnutAreaIndicatorTitle implements IStiJsonReportObject, ICloneable {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(m: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiDoughnutAreaIndicatorTitle;
        getColor(): Color;
        styleColor: Color;
        text: string;
        color: Color;
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDoughnutAreaIndicatorValue implements IStiJsonReportObject, ICloneable {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(m: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiDoughnutAreaIndicatorValue;
        getColor(): Color;
        styleColor: Color;
        value: string;
        color: Color;
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedBarArea extends StiClusteredBarArea implements IStiClusteredBarArea, IStiClusteredColumnArea, IStiArea, IStiAxisArea, IStiJsonReportObject, IStiStackedBarArea, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedBarArea extends StiStackedBarArea implements IStiClusteredBarArea, IStiClusteredColumnArea, IStiArea, IStiAxisArea, IStiFullStackedBarArea, IStiStackedBarArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedColumnArea extends StiAxisArea implements IStiJsonReportObject, IStiStackedColumnArea, IStiAxisArea, ICloneable, IStiArea {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedColumnArea extends StiStackedColumnArea implements IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiFullStackedColumnArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedAreaArea extends StiFullStackedColumnArea implements IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiFullStackedColumnArea, IStiJsonReportObject, ICloneable, IStiFullStackedAreaArea {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedLineArea extends StiFullStackedColumnArea implements IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiFullStackedColumnArea, IStiJsonReportObject, ICloneable, IStiFullStackedLineArea {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedSplineArea extends StiFullStackedColumnArea implements IStiFullStackedSplineArea, IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiFullStackedColumnArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedSplineAreaArea extends StiFullStackedColumnArea implements IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiFullStackedColumnArea, IStiFullStackedSplineAreaArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFunnelArea extends StiArea implements IStiJsonReportObject, IStiArea, ICloneable, IStiFunnelArea {
        implements(): any[];
        meta(): StiMeta[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiFunnelWeightedSlicesArea extends StiFunnelArea {
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiGanttArea extends StiClusteredBarArea implements IStiClusteredBarArea, IStiClusteredColumnArea, IStiArea, IStiAxisArea, IStiJsonReportObject, IStiGanttArea, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiHeatmapArea extends StiAxisArea implements IStiHeatmapArea {
        implements(): any[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiPictorialArea extends StiArea implements IStiJsonReportObject, IStiPictorialArea, IStiRoundValuesArea, IStiArea, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        roundValues: boolean;
        actual: boolean;
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiPictorialStackedArea extends StiArea implements IStiJsonReportObject, IStiArea, ICloneable {
        implements(): any[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiPie3dArea extends StiPieArea {
        meta(): StiMeta[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarAreaArea extends StiRadarArea implements IStiJsonReportObject, IStiRadarArea, IStiArea, IStiRadarAreaArea, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarLineArea extends StiRadarArea implements IStiJsonReportObject, IStiRadarArea, IStiArea, ICloneable, IStiRadarLineArea {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarPointArea extends StiRadarArea implements IStiJsonReportObject, IStiRadarPointArea, IStiRadarArea, IStiArea, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRangeArea extends StiClusteredColumnArea implements IStiArea, IStiRangeArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRangeBarArea extends StiClusteredColumnArea implements IStiArea, IStiRangeBarArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSplineRangeArea extends StiClusteredColumnArea implements IStiArea, IStiAxisArea, IStiClusteredColumnArea, IStiSplineRangeArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSteppedRangeArea extends StiClusteredColumnArea implements IStiArea, IStiClusteredColumnArea, IStiSteppedRangeArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRibbonArea extends StiAxisArea implements IStiJsonReportObject, IStiRibbonArea, IStiAxisArea, ICloneable, IStiArea {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedAreaArea extends StiStackedColumnArea implements IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiStackedAreaArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedLineArea extends StiStackedColumnArea implements IStiStackedLineArea, IStiArea, IStiAxisArea, IStiStackedColumnArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedSplineArea extends StiStackedColumnArea implements IStiStackedSplineArea, IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedSplineAreaArea extends StiStackedColumnArea implements IStiAxisArea, IStiStackedColumnArea, IStiArea, IStiStackedSplineAreaArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStockArea extends StiClusteredColumnArea implements IStiArea, IStiStockArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSunburstArea extends StiArea implements IStiJsonReportObject, IStiSunburstArea, ICloneable {
        implements(): any[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTreemapArea extends StiArea implements IStiJsonReportObject, IStiTreemapArea, ICloneable {
        implements(): any[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiAxisTitle implements IStiAxisTitle, ICloneable, IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiAxisTitle;
        core: StiAxisTitleCoreXF;
        allowApplyStyle: boolean;
        font: Font;
        text: string;
        color: Color;
        antialiasing: boolean;
        alignment: StringAlignment;
        position: StiTitlePosition;
        direction: StiDirection;
        constructor(font?: Font, text?: string, color?: Color, antialiasing?: boolean, alignment?: StringAlignment, direction?: StiDirection, allowApplyStyle?: boolean, position?: StiTitlePosition);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiConstantLines extends StiService implements IStiConstantLines, ICloneable, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        get propName(): string;
        clone(): StiConstantLines;
        get serviceCategory(): string;
        get ServiceType(): Stimulsoft.System.Type;
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        core: StiConstantLinesCoreXF;
        antialiasing: boolean;
        position: StiConstantLines_StiTextPosition;
        font: Font;
        text: string;
        titleVisible: boolean;
        orientation: StiConstantLines_StiOrientation;
        lineWidth: number;
        lineStyle: StiPenStyle;
        lineColor: Color;
        showInLegend: boolean;
        showBehind: boolean;
        axisValue: string;
        visible: boolean;
        chart: IStiChart;
        toString(): string;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiChartFiltersCollection extends CollectionBase<IStiChartFilter> implements IStiJsonReportObject, ICloneable {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiChartFiltersCollection;
        add(filter: StiChartFilter): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    class StiDataItem {
        index: number;
        argument: any;
        value: any;
        valueEnd: any;
        xValue: any;
        yValue: any;
        weight: any;
        valueOpen: any;
        valueClose: any;
        valueLow: any;
        valueHigh: any;
        title: any;
        key: any;
        color: any;
        toolTip: any;
        tag: any;
        constructor(index: number, argument: any, value: any, valueEnd: any, xValue: any, yValue: any, weight: any, valueOpen: any, valueClose: any, valueLow: any, valueHight: any, title: any, key: any, color: any, toolTip: any, tag: any);
    }
    class StiDataItemComparer implements IComparer<StiDataItem> {
        compare(x: StiDataItem, y: StiDataItem): number;
        private directionFactor;
        private sortType;
        constructor(sortType: StiSeriesSortType, sortDirection: StiSeriesSortDirection);
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiRadarGridLines implements IStiJsonReportObject, IStiRadarGridLines, ICloneable {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        needSetAreaJsonPropertyInternal: boolean;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        get propName(): string;
        clone(): StiRadarGridLines;
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        core: StiRadarGridLinesCoreXF;
        color: Color;
        style: StiPenStyle;
        visible: boolean;
        area: IStiArea;
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, allowApplyStyle?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarGridLinesHor extends StiRadarGridLines implements IStiJsonReportObject, IStiRadarGridLines, IStiRadarGridLinesHor, ICloneable {
        implements(): any[];
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, allowApplyStyle?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarGridLinesVert extends StiRadarGridLines implements IStiJsonReportObject, IStiRadarGridLines, IStiRadarGridLinesVert, ICloneable {
        implements(): any[];
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, allowApplyStyle?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Size = Stimulsoft.System.Drawing.Size;
    class StiHeatmapLegend extends StiLegend {
        hideSeriesWithEmptyTitle: boolean;
        direction: StiLegendDirection;
        horAlignment: StiLegendHorAlignment;
        vertAlignment: StiLegendVertAlignment;
        markerVisible: boolean;
        markerSize: Size;
        markerAlignment: StiMarkerAlignment;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiMarker implements IStiJsonReportObject, IStiMarker, ICloneable {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        get propName(): string;
        clone(): StiMarker;
        core: StiMarkerCoreXF;
        showInLegend: boolean;
        visible: boolean;
        extendedVisible: StiExtendedStyleBool;
        brush: StiBrush;
        borderColor: Color;
        size: number;
        angle: number;
        type: StiMarkerType;
        icon: StiFontIcons;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiLineMarker extends StiMarker implements IStiJsonReportObject, IStiLineMarker, IStiMarker, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        step: number;
        icon: StiFontIcons;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiRadarAxis implements IStiJsonReportObject, IStiRadarAxis, ICloneable {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        jsonLoadFromJsonObjectArea: boolean;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiRadarAxis;
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        core: StiRadarAxisCoreXF;
        visible: boolean;
        area: IStiRadarArea;
        range: IStiAxisRange;
        constructor(range?: IStiAxisRange, visible?: boolean, allowApplyStyle?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiRadarAxisLabels implements IStiJsonReportObject, IStiRadarAxisLabels, ICloneable {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiRadarAxisLabels;
        allowApplyStyle: boolean;
        core: StiRadarAxisLabelsCoreXF;
        rotationLabels: boolean;
        textBefore: string;
        textAfter: string;
        drawBorder: boolean;
        format: string;
        font: Font;
        antialiasing: boolean;
        color: Color;
        borderColor: Color;
        brush: StiBrush;
        width: number;
        wordWrap: boolean;
        constructor(format?: string, font?: Font, antialiasing?: boolean, drawBorder?: boolean, color?: Color, borderColor?: Color, brush?: StiBrush, allowApplyStyle?: boolean, rotationLabels?: boolean, width?: number, wordWrap?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiXRadarAxis extends StiRadarAxis implements IStiXRadarAxis, IStiRadarAxis, ICloneable, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        get propName(): string;
        clone(): StiXRadarAxis;
        get xCore(): StiXRadarAxisCoreXF;
        labels: IStiRadarAxisLabels;
        constructor(labels?: IStiRadarAxisLabels, range?: IStiAxisRange, visible?: boolean, allowApplyStyle?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiYRadarAxis extends StiRadarAxis implements IStiYRadarAxis, IStiRadarAxis, ICloneable, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        get propName(): string;
        clone(): StiYRadarAxis;
        get yCore(): StiYRadarAxisCoreXF;
        labels: IStiAxisLabels;
        ticks: IStiAxisTicks;
        lineStyle: StiPenStyle;
        lineColor: Color;
        lineWidth: number;
        info: StiAxisInfoXF;
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, ticks?: IStiAxisTicks, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, allowApplyStyle?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiSeriesInteraction implements IStiSeriesInteraction, IStiJsonReportObject, ICloneable {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        get propName(): string;
        getReport(): any;
        clone(): StiSeriesInteraction;
        get hyperlink(): string;
        set hyperlink(value: string);
        get tag(): string;
        set tag(value: string);
        get toolTip(): string;
        set toolTip(value: string);
        get hyperlinkDataColumn(): string;
        set hyperlinkDataColumn(value: string);
        get tagDataColumn(): string;
        set tagDataColumn(value: string);
        get toolTipDataColumn(): string;
        set toolTipDataColumn(value: string);
        get listOfHyperlinks(): string;
        set listOfHyperlinks(value: string);
        get listOfTags(): string;
        set listOfTags(value: string);
        get listOfToolTips(): string;
        set listOfToolTips(value: string);
        get allowSeries(): boolean;
        set allowSeries(value: boolean);
        get allowSeriesElements(): boolean;
        set allowSeriesElements(value: boolean);
        get drillDownEnabled(): boolean;
        set drillDownEnabled(value: boolean);
        get drillDownReport(): string;
        set drillDownReport(value: string);
        get drillDownPage(): StiPage;
        set drillDownPage(value: StiPage);
        get drillDownPageGuid(): string;
        set drillDownPageGuid(value: string);
        get parentComponent(): StiComponent;
        parentSeries: StiSeries;
    }
}
export namespace Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSeriesPointsInfo {
        points: PointD[];
        pointsFrom: PointD[];
        pointsStart: PointD[];
        pointsEnd: PointD[];
        pointsZeroConnect: PointD[];
        pointsNullConnect: PointD[];
        pointsIds: string[];
        additionalSeriesId: string;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiBoxAndWhiskerSeries extends StiSeries implements IStiBoxAndWhiskerSeries, IStiSeriesBorderThickness {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiBoxAndWhiskerSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        brush: StiBrush;
        allowApplyBrush: boolean;
        showInnerPoints: boolean;
        showMeanMarkers: boolean;
        borderThickness: number;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiBubbleSeries extends StiScatterSeries implements IStiBaseLineSeries, IStiBubbleSeries, IStiFontIconsSeries, IStiScatterSeries, IStiSeriesBorderThickness, IStiJsonReportObject, IStiSeries, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiBubbleSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        borderColor: Color;
        brush: StiBrush;
        private _weights;
        get weights(): number[];
        set weights(value: number[]);
        get weightsString(): string;
        set weightsString(value: string);
        weightDataColumn: string;
        getWeight: Function;
        onGetWeight(e: StiGetValueEventArgs): void;
        invokeGetWeight(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfWeights: Function;
        onGetListOfWeights(e: StiGetValueEventArgs): void;
        invokeGetListOfWeights(sender: StiComponent, e: StiGetValueEventArgs, series: StiBubbleSeries): void;
        weight: string;
        listOfWeights: string;
        icon: StiFontIcons;
        borderThickness: number;
        private _bubbleScale;
        get bubbleScale(): number;
        set bubbleScale(value: number);
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiClusteredColumnSeries extends StiSeries implements IStiJsonReportObject, IStiClusteredColumnSeries, IStiFontIconsSeries, IStiSeriesBorderThickness, IStiCornerRadius, ICloneable, IStiSeries, IStiAllowApplyBrushNegative, IStiShowZerosSeries {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiClusteredColumnSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        showZeros: boolean;
        cornerRadius: StiCornerRadius;
        private _width;
        get width(): number;
        set width(value: number);
        borderColor: Color;
        brush: StiBrush;
        brushNegative: StiBrush;
        allowApplyBrushNegative: boolean;
        icon: StiFontIcons;
        borderThickness: number;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiClusteredBarSeries extends StiClusteredColumnSeries implements IStiJsonReportObject, IStiClusteredColumnSeries, IStiSeries, ICloneable, IStiClusteredBarSeries, IStiAllowApplyBrushNegative {
        implements(): any[];
        get xAxis(): StiSeriesXAxis;
        set xAxis(value: StiSeriesXAxis);
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiLineSeries extends StiBaseLineSeries implements IStiJsonReportObject, IStiBaseLineSeries, IStiLineSeries, ICloneable, IStiSeries, IStiAllowApplyColorNegative {
        implements(): any[];
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiAreaSeries extends StiLineSeries implements IStiLineSeries, IStiBaseLineSeries, IStiAreaSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyBrushNegative {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiAreaSeries;
        topmostLine: boolean;
        brush: StiBrush;
        brushNegative: StiBrush;
        allowApplyBrushNegative: boolean;
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiHistogramSeries extends StiClusteredColumnSeries implements IStiHistogramSeries {
        implements(): any[];
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _width1;
        get width(): number;
        set width(value: number);
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiParetoSeries extends StiSeries implements IStiJsonReportObject, IStiParetoSeries, IStiSeriesBorderThickness, IStiCornerRadius, IStiBaseLineSeries, IStiClusteredColumnSeries, ICloneable, IStiSeries, IStiAllowApplyBrushNegative, IStiShowNullsSeries, IStiShowZerosSeries {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiParetoSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        showZeros: boolean;
        private _width;
        get width(): number;
        set width(value: number);
        borderColor: Color;
        borderThickness: number;
        brush: StiBrush;
        brushNegative: StiBrush;
        allowApplyBrushNegative: boolean;
        showNulls: boolean;
        cornerRadius: StiCornerRadius;
        get showMarker(): boolean;
        set showMarker(value: boolean);
        get markerColor(): Color;
        set markerColor(value: Color);
        get markerSize(): number;
        set markerSize(value: number);
        get markerType(): StiMarkerType;
        set markerType(value: StiMarkerType);
        marker: IStiMarker;
        lineMarker: IStiLineMarker;
        private _lineColor;
        get lineColor(): Color;
        set lineColor(value: Color);
        getLineColor(): Color;
        setLineColor(value: Color): void;
        lineStyle: StiPenStyle;
        lighting: boolean;
        private _lineWidth;
        get lineWidth(): number;
        set lineWidth(value: number);
        labelsOffset: number;
        lineColorNegative: Color;
        allowApplyColorNegative: boolean;
        allowApplyLineColor: boolean;
        showNullsAs: StiShowEmptyCellsAs;
        showZerosAs: StiShowEmptyCellsAs;
        icon: StiFontIcons;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiSplineSeries extends StiBaseLineSeries implements IStiJsonReportObject, IStiBaseLineSeries, ICloneable, IStiSeries, IStiSplineSeries, IStiAllowApplyColorNegative {
        implements(): any[];
        meta(): StiMeta[];
        getDefaultAreaType(): Stimulsoft.System.Type;
        tension: number;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSplineAreaSeries extends StiSplineSeries implements IStiSplineSeries, IStiBaseLineSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiSplineAreaSeries, IStiAllowApplyColorNegative {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiSplineAreaSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        topmostLine: boolean;
        brush: StiBrush;
        brushNegative: StiBrush;
        allowApplyBrushNegative: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiSteppedLineSeries extends StiBaseLineSeries implements IStiJsonReportObject, IStiBaseLineSeries, IStiSeries, ICloneable, IStiSteppedLineSeries, IStiAllowApplyColorNegative {
        implements(): any[];
        meta(): StiMeta[];
        getDefaultAreaType(): Stimulsoft.System.Type;
        pointAtCenter: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiSteppedAreaSeries extends StiSteppedLineSeries implements IStiSteppedLineSeries, IStiBaseLineSeries, IStiJsonReportObject, IStiSteppedAreaSeries, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiSteppedAreaSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        topmostLine: boolean;
        brush: StiBrush;
        brushNegative: StiBrush;
        allowApplyBrushNegative: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiWaterfallSeries extends StiClusteredColumnSeries implements IStiWaterfallSeries {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiWaterfallSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        connectorLine: IStiWaterfallConnectorLine;
        total: IStiWaterfallTotal;
        constructor();
    }
}
export namespace Stimulsoft.Report.Components.Design {
    class StiSeriesInteractionConverter {
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiPieSeries extends StiSeries implements IStiPieSeries, IStiFontIconsSeries, ICloneable, IStiSeries, IStiJsonReportObject, IStiAllowApplyBorderColor, IStiSeriesBorderThickness, IStiAllowApplyBrush, IStiShowZerosSeries {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiPieSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        showZeros: boolean;
        allowApplyBrush: boolean;
        allowApplyBorderColor: boolean;
        getArguments(): any[];
        setArguments(value: any[]): void;
        startAngle: number;
        borderColor: Color;
        borderThickness: number;
        brush: StiBrush;
        lighting: boolean;
        private _diameter;
        get diameter(): number;
        set diameter(value: number);
        private _distance;
        get distance(): number;
        set distance(value: number);
        private _cutPieListValues;
        get cutPieListValues(): number[];
        set cutPieListValues(value: number[]);
        get cuttedPieList(): string;
        set cuttedPieList(value: string);
        cutPieList: string;
        icon: StiFontIcons;
        getCutPieList: Function;
        onGetCutPieList(e: StiGetValueEventArgs): void;
        invokeGetCutPieList(sender: StiComponent, e: StiGetValueEventArgs): void;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiDoughnutSeries extends StiPieSeries implements IStiPieSeries, IStiSeries, ICloneable, IStiDoughnutSeries, IStiJsonReportObject, IStiAllowApplyBorderColor, IStiAllowApplyBrush, IStiShowZerosSeries {
        implements(): any[];
        meta(): StiMeta[];
        getDefaultAreaType(): Stimulsoft.System.Type;
        width: number;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiCandlestickSeries extends StiSeries implements IStiJsonReportObject, IStiSeries, IStiFinancialSeries, ICloneable, IStiCandlestickSeries {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiCandlestickSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _valuesOpen;
        get valuesOpen(): number[];
        set valuesOpen(value: number[]);
        private _valuesClose;
        get valuesClose(): number[];
        set valuesClose(value: number[]);
        get valuesStringOpen(): string;
        set valuesStringOpen(value: string);
        get valuesStringClose(): string;
        set valuesStringClose(value: string);
        get valuesStringHigh(): string;
        set valuesStringHigh(value: string);
        get valuesStringLow(): string;
        set valuesStringLow(value: string);
        private _valuesHigh;
        get valuesHigh(): number[];
        set valuesHigh(value: number[]);
        private _valuesLow;
        get valuesLow(): number[];
        set valuesLow(value: number[]);
        valueDataColumnOpen: string;
        valueDataColumnClose: string;
        valueDataColumnHigh: string;
        valueDataColumnLow: string;
        borderColor: Color;
        borderColorNegative: Color;
        private _borderWidth;
        get borderWidth(): number;
        set borderWidth(value: number);
        brush: StiBrush;
        brushNegative: StiBrush;
        getValueOpen: Function;
        protected onGetValueOpen(e: StiGetValueEventArgs): void;
        invokeGetValueOpen(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesOpen: Function;
        protected onGetListOfValuesOpen(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesOpen(sender: StiComponent, e: StiGetValueEventArgs): void;
        getValueClose: Function;
        protected onGetValueClose(e: StiGetValueEventArgs): void;
        invokeGetValueClose(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesClose: Function;
        protected onGetListOfValuesClose(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesClose(sender: StiComponent, e: StiGetValueEventArgs): void;
        getValueHigh: Function;
        protected onGetValueHigh(e: StiGetValueEventArgs): void;
        invokeGetValueHigh(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesHigh: Function;
        protected onGetListOfValuesHigh(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesHigh(sender: StiComponent, e: StiGetValueEventArgs): void;
        getValueLow: Function;
        protected onGetValueLow(e: StiGetValueEventArgs): void;
        invokeGetValueLow(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesLow: Function;
        protected onGetListOfValuesLow(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesLow(sender: StiComponent, e: StiGetValueEventArgs): void;
        private valueObjOpen;
        get valueOpen(): string;
        set valueOpen(value: string);
        listOfValuesOpen: string;
        private valueObjClose;
        get valueClose(): string;
        set valueClose(value: string);
        listOfValuesClose: string;
        private valueObjHigh;
        get valueHigh(): string;
        set valueHigh(value: string);
        listOfValuesHigh: string;
        private valueObjLow;
        get valueLow(): string;
        set valueLow(value: string);
        listOfValuesLow: string;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiStockSeries extends StiCandlestickSeries implements IStiJsonReportObject, IStiStockSeries, IStiFinancialSeries, ICloneable, IStiSeries, IStiAllowApplyColorNegative {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiStockSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        lineColor: Color;
        lineStyle: StiPenStyle;
        private _lineWidth;
        get lineWidth(): number;
        set lineWidth(value: number);
        lineColorNegative: Color;
        allowApplyColorNegative: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiFontIconsSeries = Stimulsoft.Report.Chart.IStiFontIconsSeries;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiStackedBarSeries extends StiSeries implements IStiJsonReportObject, IStiStackedBarSeries, IStiSeriesBorderThickness, IStiFontIconsSeries, IStiCornerRadius, ICloneable, IStiSeries, IStiAllowApplyBrushNegative, IStiShowZerosSeries {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiStackedBarSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        showZeros: boolean;
        private _width;
        get width(): number;
        set width(value: number);
        borderColor: Color;
        borderThickness: number;
        brush: StiBrush;
        brushNegative: StiBrush;
        allowApplyBrushNegative: boolean;
        cornerRadius: StiCornerRadius;
        get xAxis(): StiSeriesXAxis;
        set xAxis(value: StiSeriesXAxis);
        icon: StiFontIcons;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedBarSeries extends StiStackedBarSeries implements IStiJsonReportObject, IStiStackedBarSeries, IStiFontIconsSeries, ICloneable, IStiSeries, IStiFullStackedBarSeries {
        implements(): any[];
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiStackedBaseLineSeries extends StiSeries implements IStiJsonReportObject, IStiStackedBaseLineSeries, ICloneable, IStiSeries {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiStackedBaseLineSeries;
        showNulls: boolean;
        get showMarker(): boolean;
        set showMarker(value: boolean);
        get markerColor(): Color;
        set markerColor(value: Color);
        get markerSize(): number;
        set markerSize(value: number);
        get markerType(): StiMarkerType;
        set markerType(value: StiMarkerType);
        marker: IStiMarker;
        lineMarker: IStiLineMarker;
        lighting: boolean;
        lineColor: Color;
        private _lineWidth;
        get lineWidth(): number;
        set lineWidth(value: number);
        lineStyle: StiPenStyle;
        lineColorNegative: Color;
        allowApplyColorNegative: boolean;
        getDefaultAreaType(): Stimulsoft.System.Type;
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedLineSeries extends StiStackedBaseLineSeries implements IStiJsonReportObject, IStiStackedBaseLineSeries, IStiStackedLineSeries, IStiSeries, ICloneable, IStiShowNullsSeries {
        implements(): any[];
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiStackedAreaSeries extends StiStackedLineSeries implements ICloneable, IStiStackedBaseLineSeries, IStiStackedLineSeries, IStiJsonReportObject, IStiSeries, IStiStackedAreaSeries, IStiAllowApplyBrushNegative {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiStackedAreaSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        get coreBrush(): StiBrush;
        set coreBrush(value: StiBrush);
        brush: StiBrush;
        brushNegative: StiBrush;
        allowApplyBrushNegative: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedAreaSeries extends StiStackedAreaSeries implements IStiFullStackedAreaSeries, IStiStackedAreaSeries, IStiStackedBaseLineSeries, IStiShowNullsSeries, IStiSeries, IStiJsonReportObject, IStiStackedLineSeries, ICloneable, IStiAllowApplyBrushNegative {
        implements(): any[];
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiStackedColumnSeries extends StiSeries implements IStiJsonReportObject, IStiStackedColumnSeries, IStiFontIconsSeries, ICloneable, IStiSeries, IStiAllowApplyBrushNegative, IStiCornerRadius, IStiSeriesBorderThickness, IStiShowZerosSeries {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiStackedColumnSeries;
        showZeros: boolean;
        private _width;
        get width(): number;
        set width(value: number);
        borderColor: Color;
        borderThickness: number;
        brush: StiBrush;
        brushNegative: StiBrush;
        allowApplyBrushNegative: boolean;
        icon: StiFontIcons;
        cornerRadius: StiCornerRadius;
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedColumnSeries extends StiStackedColumnSeries implements IStiFullStackedColumnSeries, IStiStackedColumnSeries, ICloneable, IStiSeries, IStiJsonReportObject, IStiAllowApplyBrushNegative {
        implements(): any[];
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedLineSeries extends StiStackedLineSeries implements IStiJsonReportObject, IStiStackedBaseLineSeries, IStiStackedLineSeries, IStiSeries, ICloneable {
        implements(): any[];
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiStackedSplineSeries extends StiStackedBaseLineSeries implements IStiJsonReportObject, IStiStackedBaseLineSeries, ICloneable, IStiSeries, IStiStackedSplineSeries, IStiAllowApplyColorNegative {
        implements(): any[];
        meta(): StiMeta[];
        tension: number;
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiStackedSplineAreaSeries extends StiStackedSplineSeries implements IStiStackedSplineSeries, IStiStackedBaseLineSeries, IStiStackedSplineAreaSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyBrushNegative {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiStackedSplineAreaSeries;
        brush: StiBrush;
        brushNegative: StiBrush;
        allowApplyBrushNegative: boolean;
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedSplineAreaSeries extends StiStackedSplineAreaSeries implements IStiFullStackedSplineAreaSeries, IStiShowNullsSeries, IStiStackedSplineSeries, IStiStackedBaseLineSeries, IStiStackedSplineAreaSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyBrushNegative {
        implements(): any[];
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedSplineSeries extends StiStackedSplineSeries implements IStiStackedSplineSeries, IStiStackedBaseLineSeries, IStiFullStackedSplineSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        implements(): any[];
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiFunnelSeries extends StiSeries implements IStiJsonReportObject, IStiFunnelSeries, IStiFontIconsSeries, IStiSeriesBorderThickness, IStiSeries, ICloneable, IStiShowZerosSeries {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiFunnelSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        showZeros: boolean;
        allowApplyBrush: boolean;
        allowApplyBorderColor: boolean;
        brush: StiBrush;
        borderColor: Color;
        borderThickness: number;
        icon: StiFontIcons;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFunnelWeightedSlicesSeries extends StiFunnelSeries implements IStiJsonReportObject, IStiFunnelSeries, IStiFunnelWeightedSlicesSeries, IStiSeries, ICloneable {
        implements(): any[];
        clone(): StiFunnelWeightedSlicesSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiGanttSeries extends StiClusteredBarSeries implements IStiClusteredColumnSeries, IStiClusteredBarSeries, IStiRangeSeries, IStiJsonReportObject, IStiSeries, IStiGanttSeries, ICloneable, IStiAllowApplyBrushNegative {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiGanttSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _valuesEnd;
        get valuesEnd(): number[];
        set valuesEnd(value: number[]);
        get valuesStringEnd(): string;
        set valuesStringEnd(value: string);
        valueDataColumnEnd: string;
        getValueEnd: Function;
        protected onGetValueEnd(e: StiGetValueEventArgs): void;
        invokeGetValueEnd(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesEnd: Function;
        protected onGetListOfValuesEnd(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesEnd(sender: StiComponent, e: StiGetValueEventArgs, series: StiGanttSeries): void;
        private valueObjEnd;
        get valueEnd(): string;
        set valueEnd(value: string);
        listOfValuesEnd: string;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiHeatmapSeries extends StiSeries implements IStiJsonReportObject, IStiHeatmapSeries, IStiSeriesBorderThickness, IStiSeries {
        implements(): any[];
        meta(): StiMeta[];
        getDefaultAreaType(): Stimulsoft.System.Type;
        getDefaultLegendType(): Stimulsoft.System.Type;
        private _xValues;
        get xValues(): any[];
        set xValues(value: any[]);
        protected getXValues(): any[];
        protected setXValues(value: any[]): void;
        private _yValues;
        get yValues(): any[];
        set yValues(value: any[]);
        protected getYValues(): any[];
        protected setYValues(value: any[]): void;
        yValuesDataColumn: string;
        xValuesDataColumn: string;
        get xValuesString(): string;
        set xValuesString(value: string);
        get yValuesString(): string;
        set yValuesString(value: string);
        getListOfYValues: Function;
        protected onGetListOfYValues(e: StiGetValueEventArgs): void;
        invokeGetListOfYValues(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfXValues: Function;
        protected onGetListOfXValues(e: StiGetValueEventArgs): void;
        invokeGetListOfXValues(sender: StiComponent, e: StiGetValueEventArgs): void;
        xValue: string;
        yValue: string;
        listOfXValues: string;
        listOfYValues: string;
        borderColor: Color;
        borderThickness: number;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiPictorialStackedSeries = Stimulsoft.Report.Chart.IStiPictorialStackedSeries;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiPictorialStackedSeries extends StiSeries implements IStiFontIconsSeries, ICloneable, IStiSeries, IStiPictorialStackedSeries, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        brush: StiBrush;
        icon: StiFontIcons;
        clone(): StiPictorialStackedSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiPie3dPeripherySurfaceBounds {
        startAngle: number;
        endAngle: number;
        startPoint: Point;
        endPoint: Point;
        realStartAngle: number;
        realEndAngle: number;
        constructor(startAngle: number, endAngle: number, startPoint: Point, endPoint: Point, realStartAngle: number, realEndAngle: number);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiPie3dQuadrilateral {
        animation: StiAnimation;
        rectangle: Rectangle;
        point1: Point;
        point2: Point;
        point3: Point;
        point4: Point;
        toClose: boolean;
        draw(context: StiContext, pen: StiPenGeom, brush: StiBrush): void;
        static empty(): StiPie3dQuadrilateral;
        constructor(rectangle: Rectangle, point1: Point, point2: Point, point3: Point, point4: Point, toClose: boolean, animation: StiAnimation);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiPie3dSeries extends StiPieSeries implements IStiPie3dSeries, IStiShowZerosSeries {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiPieSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        options3D: StiPie3dOptions;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiRadarSeries extends StiSeries implements IStiJsonReportObject, ICloneable, IStiSeries, IStiRadarSeries, IStiShowNullsSeries {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiRadarSeries;
        showNulls: boolean;
        marker: IStiMarker;
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiRadarAreaSeries extends StiRadarSeries implements IStiRadarSeries, IStiRadarLineSeries, IStiJsonReportObject, IStiSeries, IStiRadarAreaSeries, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        lineColor: Color;
        lineStyle: StiPenStyle;
        lighting: boolean;
        private _lineWidth;
        get lineWidth(): number;
        set lineWidth(value: number);
        brush: StiBrush;
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiRadarLineSeries extends StiRadarSeries implements IStiJsonReportObject, IStiRadarLineSeries, ICloneable, IStiSeries, IStiRadarSeries {
        implements(): any[];
        meta(): StiMeta[];
        lineColor: Color;
        lineStyle: StiPenStyle;
        lighting: boolean;
        private _lineWidth;
        get lineWidth(): number;
        set lineWidth(value: number);
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarPointSeries extends StiRadarSeries implements IStiJsonReportObject, IStiRadarPointSeries, ICloneable, IStiSeries, IStiRadarSeries {
        implements(): any[];
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiRangeBarSeries extends StiClusteredColumnSeries implements IStiRangeBarSeries, IStiClusteredColumnSeries, IStiRangeSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyBrushNegative {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiRangeBarSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _valuesEnd;
        get valuesEnd(): number[];
        set valuesEnd(value: number[]);
        get valuesStringEnd(): string;
        set valuesStringEnd(value: string);
        valueDataColumnEnd: string;
        getValueEnd: Function;
        protected onGetValueEnd(e: StiGetValueEventArgs): void;
        invokeGetValueEnd(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesEnd: Function;
        protected onGetListOfValuesEnd(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesEnd(sender: StiComponent, e: StiGetValueEventArgs, series: StiRangeBarSeries): void;
        private valueObjEnd;
        get valueEnd(): string;
        set valueEnd(value: string);
        listOfValuesEnd: string;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiRangeSeries extends StiLineSeries implements IStiLineSeries, IStiLineRangeSeries, IStiBaseLineSeries, IStiRangeSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiRangeSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        brush: StiBrush;
        private _valuesEnd;
        get valuesEnd(): number[];
        set valuesEnd(value: number[]);
        get valuesStringEnd(): string;
        set valuesStringEnd(value: string);
        valueDataColumnEnd: string;
        brushNegative: StiBrush;
        allowApplyBrushNegative: boolean;
        getValueEnd: Function;
        onGetValueEnd(e: StiGetValueEventArgs): void;
        invokeGetValueEnd(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesEnd: Function;
        onGetListOfValuesEnd(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesEnd(sender: StiComponent, e: StiGetValueEventArgs, series: StiRangeSeries): void;
        private valueObjEnd;
        get valueEnd(): string;
        set valueEnd(value: string);
        listOfValuesEnd: string;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiSplineRangeSeries extends StiSplineSeries implements IStiSplineSeries, IStiSplineRangeSeries, IStiBaseLineSeries, IStiRangeSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiSplineRangeSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        brush: StiBrush;
        private _valuesEnd;
        get valuesEnd(): number[];
        set valuesEnd(value: number[]);
        get valuesStringEnd(): string;
        set valuesStringEnd(value: string);
        valueDataColumnEnd: string;
        getValueEnd: Function;
        onGetValueEnd(e: StiGetValueEventArgs): void;
        invokeGetValueEnd(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesEnd: Function;
        onGetListOfValuesEnd(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesEnd(sender: StiComponent, e: StiGetValueEventArgs, series: StiSplineRangeSeries): void;
        private valueObjEnd;
        get valueEnd(): string;
        set valueEnd(value: string);
        listOfValuesEnd: string;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiSteppedRangeSeries extends StiSteppedLineSeries implements IStiSteppedLineSeries, IStiBaseLineSeries, IStiRangeSeries, IStiSteppedRangeSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiSteppedRangeSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        brush: StiBrush;
        private _valuesEnd;
        get valuesEnd(): number[];
        set valuesEnd(value: number[]);
        get valuesStringEnd(): string;
        set valuesStringEnd(value: string);
        valueDataColumnEnd: string;
        brushNegative: StiBrush;
        allowApplyBrushNegative: boolean;
        getValueEnd: Function;
        onGetValueEnd(e: StiGetValueEventArgs): void;
        invokeGetValueEnd(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesEnd: Function;
        onGetListOfValuesEnd(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesEnd(sender: StiComponent, e: StiGetValueEventArgs, series: StiSteppedRangeSeries): void;
        private valueObjEnd;
        get valueEnd(): string;
        set valueEnd(value: string);
        listOfValuesEnd: string;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiScatterSplineSeries extends StiScatterSeries implements ICloneable, IStiScatterLineSeries, IStiBaseLineSeries, IStiScatterSplineSeries, IStiJsonReportObject, IStiSeries, IStiScatterSeries, IStiAllowApplyColorNegative {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiScatterSplineSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        tension: number;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    class StiRibbonSeries extends StiSeries implements IStiJsonReportObject, IStiRibbonSeries, IStiCornerRadius, IStiSeriesBorderThickness {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiRibbonSeries;
        private _width;
        get width(): number;
        set width(value: number);
        borderColor: Color;
        borderThickness: number;
        brush: StiBrush;
        cornerRadius: StiCornerRadius;
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import List = Stimulsoft.System.Collections.List;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRibbonSeriesMetadata {
        borderColor: Color;
        brush: StiBrush;
        rectangles: List<Rectangle>;
        constructor(brush: StiBrush, borderColor: Color);
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiSunburstSeries extends StiSeries implements IStiJsonReportObject, IStiSunburstSeries, IStiSeriesBorderThickness, ICloneable, IStiSeries {
        implements(): any[];
        meta(): StiMeta[];
        clone(): StiSunburstSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        borderColor: Color;
        borderThickness: number;
        brush: StiBrush;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiNoneLabels extends StiSeriesLabels implements IStiNoneLabels, IStiSeriesLabels, ICloneable, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiInsideBaseAxisLabels extends StiCenterAxisLabels implements IStiInsideBaseAxisLabels, IStiSeriesLabels, ICloneable, IStiAxisSeriesLabels, IStiJsonReportObject {
        implements(): any[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiInsideEndAxisLabels extends StiCenterAxisLabels implements IStiCenterAxisLabels, IStiAxisSeriesLabels, IStiSeriesLabels, IStiJsonReportObject, IStiInsideEndAxisLabels, ICloneable {
        implements(): any[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiLeftAxisLabels extends StiCenterAxisLabels implements IStiCenterAxisLabels, IStiLeftAxisLabels, IStiAxisSeriesLabels, IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        implements(): any[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiOutsideAxisLabels extends StiAxisSeriesLabels implements IStiOutsideAxisLabels, IStiSeriesLabels, ICloneable, IStiAxisSeriesLabels, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        lineLength: number;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiOutsideBaseAxisLabels extends StiCenterAxisLabels implements IStiCenterAxisLabels, IStiAxisSeriesLabels, IStiJsonReportObject, IStiOutsideBaseAxisLabels, IStiSeriesLabels, ICloneable {
        implements(): any[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiOutsideEndAxisLabels extends StiCenterAxisLabels implements IStiOutsideEndAxisLabels, IStiCenterAxisLabels, IStiAxisSeriesLabels, IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        implements(): any[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRightAxisLabels extends StiCenterAxisLabels implements IStiCenterAxisLabels, IStiAxisSeriesLabels, IStiRightAxisLabels, IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        implements(): any[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiValueAxisLabels extends StiCenterAxisLabels implements IStiValueAxisLabels, IStiCenterAxisLabels, IStiAxisSeriesLabels, IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        implements(): any[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFunnelSeriesLabels extends StiSeriesLabels implements IStiJsonReportObject, IStiFunnelSeriesLabels, ICloneable, IStiSeriesLabels {
        implements(): any[];
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCenterFunnelLabels extends StiFunnelSeriesLabels implements IStiJsonReportObject, IStiSeriesLabels, IStiFunnelSeriesLabels, ICloneable, IStiCenterFunnelLabels {
        implements(): any[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiOutsideLeftFunnelLabels extends StiFunnelSeriesLabels implements IStiCenterFunnelLabels, IStiOutsideLeftFunnelLabels, IStiJsonReportObject, IStiSeriesLabels, IStiFunnelSeriesLabels, ICloneable {
        implements(): any[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiOutsideRightFunnelLabels extends StiFunnelSeriesLabels implements IStiOutsideRightFunnelLabels, IStiCenterFunnelLabels, IStiJsonReportObject, IStiSeriesLabels, IStiFunnelSeriesLabels, ICloneable {
        implements(): any[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiCenterHeatmapLabels extends StiAxisSeriesLabels implements IStiCenterAxisLabels {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCenterPictorialStackedLabels extends StiFunnelSeriesLabels implements IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        implements(): any[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiOutsideLeftPictorialStackedLabels extends StiCenterPictorialStackedLabels implements IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        lineColor: Color;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiOutsideRightPictorialStackedLabels extends StiCenterPictorialStackedLabels implements IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        lineColor: Color;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiPictorialStackedLabels extends StiSeriesLabels implements IStiJsonReportObject, ICloneable, IStiSeriesLabels {
        implements(): any[];
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiPieSeriesLabels extends StiSeriesLabels implements IStiJsonReportObject, IStiPieSeriesLabels, IStiSeriesLabels, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        private _showInPercent;
        get showInPercent(): boolean;
        set showInPercent(value: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiCenterPie3dLabels extends StiPieSeriesLabels {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCenterPieLabels extends StiPieSeriesLabels implements IStiJsonReportObject, IStiPieSeriesLabels, IStiSeriesLabels, IStiCenterPieLabels, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        autoRotate: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiInsideEndPie3dLabels extends StiCenterPie3dLabels {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiInsideEndPieLabels extends StiCenterPieLabels implements IStiCenterPieLabels, IStiSeriesLabels, IStiPieSeriesLabels, IStiInsideEndPieLabels, IStiJsonReportObject, ICloneable {
        implements(): any[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiOutsidePieLabels extends StiCenterPieLabels implements IStiOutsidePieLabels, IStiCenterPieLabels, IStiPieSeriesLabels, IStiSeriesLabels, IStiJsonReportObject, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        showValue: boolean;
        lineLength: number;
        lineColor: Color;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTwoColumnsPieLabels extends StiOutsidePieLabels implements IStiTwoColumnsPieLabels, IStiOutsidePieLabels, IStiCenterPieLabels, IStiPieSeriesLabels, IStiSeriesLabels, IStiJsonReportObject, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiCenterTreemapLabels extends StiAxisSeriesLabels implements IStiCenterAxisLabels {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiStrips extends StiService implements IStiJsonReportObject, IStiStrips, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        saveToJsonObject(m: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        get propName(): string;
        clone(): StiStrips;
        get serviceCategory(): string;
        get serviceType(): Stimulsoft.System.Type;
        core: StiStripsCoreXF;
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        showBehind: boolean;
        stripBrush: StiBrush;
        antialiasing: boolean;
        font: Font;
        text: string;
        titleVisible: boolean;
        titleColor: Color;
        orientation: StiStrips_StiOrientation;
        showInLegend: boolean;
        maxValue: string;
        minValue: string;
        visible: boolean;
        chart: IStiChart;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle01 extends StiChartStyle {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiCustomStyle extends StiStyle01 implements IStiCustomStyle {
        implements(): any[];
        get serviceName(): string;
        get customCore(): StiCustomStyleCoreXF;
        constructor(reportStyleName?: string);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle02 extends StiChartStyle {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle03 extends StiChartStyle {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle04 extends StiChartStyle {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle05 extends StiChartStyle {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle06 extends StiChartStyle {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle07 extends StiChartStyle {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle08 extends StiStyle03 {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle09 extends StiChartStyle {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle10 extends StiChartStyle {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle11 extends StiChartStyle {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle12 extends StiChartStyle {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle13 extends StiChartStyle {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle14 extends StiChartStyle {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle15 extends StiChartStyle {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle16 extends StiChartStyle {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle17 extends StiChartStyle {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle18 extends StiChartStyle {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle19 extends StiChartStyle {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle20 extends StiChartStyle {
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle21 extends StiChartStyle {
        isOffice2015Style: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle22 extends StiChartStyle {
        isOffice2015Style: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStyle23 extends StiChartStyle {
        isOffice2015Style: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle24 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle26 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle27 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle28 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle30 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle31 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle32 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle33 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle34 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle35 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle36 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle37 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiChartTableDataCells implements IStiChartTableDataCells, IStiJsonReportObject {
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(m: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiChartTableDataCells;
        font: Font;
        textColor: Color;
        shrinkFontToFit: boolean;
        shrinkFontToFitMinimumSize: number;
        constructor(shrinkFontToFit?: boolean, shrinkFontToFitMinimumSize?: number, font?: Font, textColor?: Color);
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiChartTableHeader implements IStiJsonReportObject, IStiChartTableHeader, ICloneable {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(m: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiChartTableHeader;
        brush: StiBrush;
        font: Font;
        textColor: Color;
        wordWrap: boolean;
        textAfter: string;
        format: string;
        constructor(textAfter?: string, brush?: StiBrush, font?: Font, textColor?: Color, wordWrap?: boolean, format?: string);
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiSeriesTopN implements IStiJsonReportObject, IStiSeriesTopN, ICloneable {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(m: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        get propName(): string;
        clone(): StiSeriesTopN;
        mode: StiTopNMode;
        count: number;
        showOthers: boolean;
        othersText: string;
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiTrendLine extends StiService implements IStiTrendLine, ICloneable, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        static loadFromJsonObjectInternal(jObject: StiJson): IStiTrendLine;
        loadFromXml(xn: XmlNode): void;
        static loadTrendLineFromXml(xmlNode: XmlNode): StiTrendLine;
        get propName(): string;
        clone(): StiTrendLine;
        get serviceName(): string;
        get serviceCategory(): string;
        get serviceType(): Stimulsoft.System.Type;
        core: StiTrendLineCoreXF;
        lineColor: Color;
        lineWidth: number;
        lineStyle: StiPenStyle;
        showShadow: boolean;
        allowApplyStyle: boolean;
        position: StiTrendLine_StiTextPosition;
        font: Font;
        text: string;
        titleVisible: boolean;
        toString(): string;
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTrendLineExponential extends StiTrendLine implements IStiTrendLine, ICloneable, IStiJsonReportObject, IStiTrendLineExponential {
        implements(): any[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTrendLineLinear extends StiTrendLine implements IStiTrendLine, IStiTrendLineLinear, ICloneable, IStiJsonReportObject {
        implements(): any[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTrendLineLogarithmic extends StiTrendLine implements IStiTrendLine, IStiTrendLineLogarithmic, ICloneable, IStiJsonReportObject {
        implements(): any[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTrendLineNone extends StiTrendLine implements IStiTrendLine, IStiTrendLineNone, IStiJsonReportObject, ICloneable {
        implements(): any[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiTrendLinesCollection extends CollectionBase<StiTrendLine> implements IStiTrendLinesCollection, ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): object;
        add(line: StiTrendLine): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiWaterfallConnectorLine implements IStiWaterfallConnectorLine, ICloneable, IStiJsonReportObject {
        implements(): any[];
        clone(): StiWaterfallConnectorLine;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(m: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        lineColor: Color;
        lineStyle: StiPenStyle;
        lineWidth: number;
        visible: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiWaterfallTotal implements IStiWaterfallTotal, ICloneable, IStiJsonReportObject {
        implements(): any[];
        clone(): StiWaterfallTotal;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(m: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        text: string;
        visible: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiCamera3D {
        forward: StiVector4;
        up: StiVector4;
        right: StiVector4;
        h_fov: number;
        v_fov: number;
        nearPlane: number;
        farPlane: number;
        position: StiVector4;
        render: StiRender3D;
        translateMatrix(): StiMatrix;
        rotateMatrix(): StiMatrix;
        cameraMatrix(): StiMatrix;
        constructor(render: StiRender3D, point: StiVector3);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiProjection {
        near: number;
        far: number;
        right: number;
        left: number;
        top: number;
        bottom: number;
        projectionMatrix: StiMatrix;
        toScreenMatrix: StiMatrix;
        constructor(render: StiRender3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    import PointF = Stimulsoft.System.Drawing.Point;
    class StiRender3D implements IStiRender3D {
        camera: StiCamera3D;
        projection: StiProjection;
        width: number;
        height: number;
        halfWidth: number;
        halfHeight: number;
        globalRotationX: number;
        globalRotationY: number;
        globalScale: number;
        contextScale: number;
        contextTranslate: PointF;
        constructor(width: number, height: number);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiAxisAreaCoreXF3D extends StiAreaCoreXF implements IStiAxisAreaCoreXF3D {
        applyStyle(style: IStiChartStyle): void;
        valuesCount: number;
        contextScale: number;
        contextTranslate: Point;
        render(context: StiContext, rect: Rectangle): StiCellGeom;
        private renderStrips;
        private renderYStrips;
        private renderXStrips;
        private calculateXValue;
        private calculateYValue;
        private renderConstantLines;
        private renderYConstantLines;
        private renderXConstantLines;
        private renderInterlacingVer;
        switchOff(): void;
        private renderInterlacingHor;
        protected prepareInfo(rect: Rectangle): void;
        calculateMinimumAndMaximumYAxis(axis: IStiAxis3D): void;
        private checkStartFromZeroYAxis;
        private calculateStepX;
        private calculateStepY;
        private calculateStepZ;
        calculatePositions(axis: IStiAxis3D, REFcollection: any, step: number, calculationForTicks?: boolean): void;
        private getPrePositionZ;
        private getPositionZ;
        private renderSeries;
        private renderGridLinesHorZY;
        private renderGridLinesHorXY;
        private renderGridLinesVertZX;
        private renderGridLinesVertXY;
        protected checkShowEdgeValues(axis: IStiXAxis3D): void;
        private calculateMinimumAndMaximumXAxis;
        private createStripLinesYAxis;
        createStripLinesXAxis(axis: IStiAxis3D): void;
        protected createStripLinesZAxis(axis: IStiAxis3D): void;
        protected checkStripLinesAndMaximumMinimumXAxis(axis: IStiAxis3D): void;
        protected checkStripLinesAndMaximumMinimumYAxis(axis: IStiAxis3D): void;
        protected checkStripLinesAndMaximumMinimumZAxis(axis: IStiAxis3D): void;
        getArgumentLabel(line: StiStripLineXF, series: IStiSeries): string;
        protected prepareRange(xAxis: IStiAxis3D, yAxis: IStiAxis3D, zAxis: IStiAxis3D): void;
        getDividerY(): number;
        private calculateDivider;
        protected getRedner3D(): StiRender3D;
        protected getFactorWidthHeight(rect: Rectangle): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiClusteredColumnAreaCoreXF3D extends StiAxisAreaCoreXF3D {
        get localizedName(): string;
        get position(): number;
        protected prepareRange(specXAxis: IStiAxis3D, specYAxis: IStiAxis3D, specZAxis: IStiAxis3D): void;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiLineAreaCoreXF3D extends StiClusteredColumnAreaCoreXF3D {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiStackedColumnAreaCoreXF3D extends StiAxisAreaCoreXF3D {
        private prepareSeriesRange;
        protected prepareRange(specXAxis: IStiAxis3D, yAxis: IStiAxis3D, zAxis: IStiAxis3D): void;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiFullStackedColumnAreaCoreXF3D extends StiStackedColumnAreaCoreXF3D {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import ICloneable = Stimulsoft.System.ICloneable;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    class StiAxisCoreXF3D implements ICloneable, IStiApplyStyle, IStiAxisCoreXF3D {
        implements(): any[];
        clone(): any;
        applyStyle(style: IStiChartStyle): void;
        getFontGeom(context: StiContext): StiFontGeom;
        axis: IStiAxis3D;
        calculateStripPositions(topPosition: number, bottomPosition: number): void;
        render3D(context: StiContext, rect3D: StiRectangle3D, render: StiRender3D): StiCellGeom;
        getAxisTitleSize(context: StiContext): SizeD;
        getStringFormatGeom(context: StiContext, wordWrap: boolean): StiStringFormatGeom;
        constructor(axis: IStiAxis3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisInfoXF3D implements ICloneable, IStiAxisInfoXF3D {
        implements(): any[];
        clone(): any;
        dpi: number;
        step: number;
        get range(): number;
        stripPositions: number[];
        stripLines: StiStripLinesXF;
        labelsCollection: StiStripPositionXF[];
        minimum: number;
        maximum: number;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import Size = Stimulsoft.System.Drawing.Size;
    class StiAxisLabelInfoXF3D {
        textPoint: StiPoint3D;
        clientSize: Size;
        rotationMode: StiRotationMode;
        text: string;
        stripLine: StiStripLineXF;
        angle: number;
        width: number;
        wordWrap: boolean;
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisLabelsCoreXF3D implements IStiApplyStyle, ICloneable, IStiAxisLabelsCoreXF3D {
        implements(): any[];
        clone(): any;
        applyStyle(style: IStiChartStyle): void;
        labels: IStiAxisLabels3D;
        constructor(labels: IStiAxisLabels3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisTitleCoreXF3D implements IStiApplyStyle, ICloneable, IStiAxisTitleCoreXF3D {
        implements(): any[];
        clone(): any;
        applyStyle(style: IStiChartStyle): void;
        title: IStiAxisTitle3D;
        render(context: StiContext, titleRect: Rectangle, axis: IStiAxis3D): StiAxisTitleGeom3D;
        getAngleTitle(axis: IStiAxis3D): number;
        constructor(title: IStiAxisTitle3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import SizeF = Stimulsoft.System.Drawing.Size;
    class StiXAxisCoreXF3D extends StiAxisCoreXF3D {
        private storedCulture;
        getAxisRect(context: StiContext, rect: Rectangle, includeAxisArrow: boolean, includeLabelsHeight: boolean, isDrawing: boolean, includeScrollBar: boolean): SizeF;
        private measureStripLines;
        getLabelText(line: StiStripLineXF, series: IStiSeries): string;
        getLabelText2(objectValue: any, value: number, series: IStiSeries): string;
        render3D(context: StiContext, rect3D: StiRectangle3D, render: StiRender3D): StiCellGeom;
        private renderLabels;
        constructor(axis: IStiAxis3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import SizeF = Stimulsoft.System.Drawing.Size;
    class StiYAxisCoreXF3D extends StiAxisCoreXF3D {
        private storedCulture;
        getAxisRect(context: StiContext, rect: Rectangle, includeAxisArrow: boolean, includeLabelsHeight: boolean, isDrawing: boolean, includeScrollBar: boolean): SizeF;
        private measureStripLines;
        setTotalNumberCapacity(): void;
        getLabelText(line: IStiStripLineXF): string;
        render3D(context: StiContext, rect3D: StiRectangle3D, render: StiRender3D): StiCellGeom;
        private renderLabels;
        constructor(axis: IStiAxis3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiZAxisCoreXF3D extends StiAxisCoreXF3D {
        render3D(context: StiContext, rect3D: StiRectangle3D, render: StiRender3D): StiCellGeom;
        constructor(axis: IStiAxis3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiMatrix {
        grid: number[][];
        get rows(): number;
        get columns(): number;
        static deepCopy(matrix: number[][]): number[][];
        getByIndex(i: number, j: number): number;
        setByIndex(i: number, j: number, value: number): void;
        static multiply(firstMatrix: StiMatrix, secondMatrix: StiMatrix): StiMatrix;
        constructor(a: StiMatrix | number[][]);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiVector3 {
        x: number;
        y: number;
        z: number;
        constructor(x: number, y: number, z: number);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiVector4 extends StiVector3 {
        w: number;
        constructor(x: number, y: number, z: number, w: number);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSeriesCoreXF3D extends StiSeriesCoreXF {
        renderSeries3D(render3D: StiRender3D, context: StiContext, rect: StiRectangle3D, geom: StiAreaGeom, seriesIndex: number, seriesArray: IStiSeries[]): any;
        getSeriesColor(colorIndex: number, colorCount: number, color: Color): Color;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiClusteredColumnSeriesCoreXF3D extends StiSeriesCoreXF3D {
        applyStyle(style: IStiChartStyle, color: Color): void;
        get localizedName(): string;
        renderSeries3D(render3D: StiRender3D, context: StiContext, rect: StiRectangle3D, geom: StiAreaGeom, seriesIndex: number, series: IStiSeries[]): void;
        private render;
        renderSideBySide(render3D: StiRender3D, context: StiContext, rect: StiRectangle3D, geom: StiAreaGeom, series: IStiSeries[]): void;
        private measureLeftPosition;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        getSeriesColor(colorIndex: number, colorCount: number, color: Color): Color;
        static measureXPosition(axisArea: IStiAxisArea3D, pointIndex: number, length: number): number;
        private measureZPosition;
        static getColumnRect3D(currentSeries: StiSeries3D, value: number, seriesXPos: number, seriesWidth: number, seriesZPos: number, seriesLength: number): StiRectangle3D;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiLineSeriesCoreXF3D extends StiSeriesCoreXF3D {
        applyStyle(style: IStiChartStyle, color: Color): void;
        get localizedName(): string;
        renderSeries3D(render3D: StiRender3D, context: StiContext, rect: StiRectangle3D, geom: StiAreaGeom, seriesIndex: number, series: IStiSeries[]): void;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        getSeriesColor(colorIndex: number, colorCount: number, color: Color): Color;
        private measureXPosition;
        private measureZPosition;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStackedColumnSeriesCoreXF3D extends StiSeriesCoreXF3D {
        applyStyle(style: IStiChartStyle, color: Color): void;
        get localizedName(): string;
        renderSeries3D(render3D: StiRender3D, context: StiContext, rect: StiRectangle3D, geom: StiAreaGeom, index: number, series: IStiSeries[]): void;
        getSeriesBorderColor(colorIndex: number, colorCount: number): any;
        getSeriesColor(colorIndex: number, colorCount: number, color: Color): Color;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiFullStackedColumnSeriesCoreXF3D extends StiStackedColumnSeriesCoreXF3D {
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiAxisSeriesLabelsCoreXF3D extends StiSeriesLabelsCoreXF {
        get seriesLabelsType(): StiSeriesLabelsType;
        renderLabel3D(render3D: StiRender3D, series: IStiSeries, context: StiContext, rect3D: StiRectangle3D, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, weight: number, colorIndex: number, colorCount: number): any;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiCenterAxisLabelsCoreXF3D extends StiAxisSeriesLabelsCoreXF3D {
        get position(): number;
        get localizedName(): string;
        renderLabel3D(render3D: StiRender3D, series: IStiSeries, context: StiContext, rect3D: StiRectangle3D, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, weight: number, colorIndex: number, colorCount: number): StiCellGeom;
        private getPointLabel;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiOutsideAxisLabelsCoreXF3D extends StiCenterAxisLabelsCoreXF3D {
        get position(): number;
        get localizedName(): string;
        renderLabel3D(render3D: StiRender3D, series: IStiSeries, context: StiContext, rect3D: StiRectangle3D, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, weight: number, colorIndex: number, colorCount: number): StiCellGeom;
        private getPointLabel2;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
export namespace Stimulsoft.Report.Chart {
    import List = Stimulsoft.System.Collections.List;
    import StiGeomType = Stimulsoft.Base.Context.StiGeomType;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointF = Stimulsoft.System.Drawing.Point;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiGeom3D extends StiCellGeom {
        render: StiRender3D;
        vertexes: StiMatrix;
        faces: List<number[]>;
        type: StiGeomType;
        drawVertexes: boolean;
        drawEdges: boolean;
        colorsFaces: Color[];
        renderPoints: List<PointF>;
        private isGlobalTransform;
        static multiplyVertexes(vertexes: StiMatrix, matrix: StiMatrix): StiMatrix;
        private normilizeVertixes;
        protected globalTransform(): void;
        getPoints(): List<PointF>;
        draw(context: StiContext): void;
        measureCientRect(): Rectangle;
        private getClientRectangle;
        screenProjection(): StiMatrix;
        drawElements(context: StiContext, vertices: StiMatrix): void;
        getToolTip(): any;
        drawBorder(context: StiContext, vertices: StiMatrix): void;
        protected drawFaceBorder(context: StiContext, vertices: StiMatrix, face: number[], color: Color): void;
        protected getFacePolygonPoints(face: number[], vertices: StiMatrix): List<PointF>;
        getBorderColor(): Color;
        protected getPoint(vertices: StiMatrix, vertIndex: number): PointF;
        protected getPointN(x: number, y: number): PointF;
        translate(vector: StiVector3): void;
        scale(scaleTo: number): void;
        rotateX(angle: number): void;
        rotateY(angle: number): void;
        rotateZ(angle: number): void;
        constructor(render: StiRender3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    class StiLineGeom3D extends StiGeom3D {
        color: Color;
        penStyle: StiPenStyle;
        lineWidth: number;
        drawElements(context: StiContext, vertices: StiMatrix): void;
        constructor(startPoint: StiPoint3D, endPoint: StiPoint3D, color: Color, lineWidth: number, style: StiPenStyle, render3D: StiRender3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiColor = Stimulsoft.Report.Components.IStiColor;
    class StiPlaneGeom3D extends StiGeom3D implements IStiColor {
        implements(): any[];
        color: Color;
        constructor(sPoint1: StiPoint3D, sPoint2: StiPoint3D, ePoint1: StiPoint3D, ePoint2: StiPoint3D, color: Color, render: StiRender3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import SizeF = Stimulsoft.System.Drawing.Size;
    class StiTextGeom3D extends StiGeom3D {
        text: string;
        font: StiFontGeom;
        color: Color;
        mode: StiRotationMode;
        angle: number;
        drawElements(context: StiContext, vertices: StiMatrix): void;
        private drawText;
        private getStringFormat;
        protected getLabelRect(context: StiContext): SizeF;
        constructor(text: string, font: StiFontGeom, color: Color, mode: StiRotationMode, angle: number, point3D: StiPoint3D, render3D: StiRender3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiColor = Stimulsoft.Report.Components.IStiColor;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiAreaGeom3D extends StiGeom3D implements IStiColor {
        implements(): any[];
        color: Color;
        constructor(render: StiRender3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiAxisAreaGeom3D extends StiAreaGeom3D {
        constructor(render: StiRender3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiAxisAreaViewGeom3D extends StiAreaGeom {
        render: StiRender3D;
        draw(context: StiContext): void;
        drawGeom(context: StiContext): void;
        drawChildGeoms(context: StiContext): void;
        constructor(area: IStiArea, clientRectangle: Rectangle, render: StiRender3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiXYAreaGeom3D extends StiAreaGeom3D {
        constructor(width: number, height: number, render: StiRender3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiXZAreaGeom3D extends StiAreaGeom3D {
        constructor(width: number, height: number, render: StiRender3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiZYAreaGeom3D extends StiAreaGeom3D {
        constructor(width: number, height: number, render: StiRender3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    import SizeF = Stimulsoft.System.Drawing.Size;
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisLabelGeom3D extends StiGeom3D {
        axis: IStiAxis3D;
        clientSize: SizeF;
        text: string;
        stripLine: StiStripLineXF;
        rotationMode: StiRotationMode;
        angle: number;
        width: number;
        wordWrap: boolean;
        drawElements(context: StiContext, vertices: StiMatrix): void;
        measureCientRect(): Rectangle;
        constructor(axis: IStiAxis3D, clientSize: SizeF, textPoint: StiPoint3D, text: string, stripLine: StiStripLineXF, rotationMode: StiRotationMode, angle: number, width: number, wordWrap: boolean, render: StiRender3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisTitleGeom3D extends StiCellGeom {
        axis: IStiAxis3D;
        angle: number;
        private font;
        draw(context: StiContext): void;
        constructor(axis: IStiAxis3D, clientRectangle: Rectangle, angle: number, font: StiFontGeom);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiXAxisGeom3D extends StiGeom3D {
        constructor(rect: StiRectangle3D, render: StiRender3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiYAxisGeom3D extends StiGeom3D {
        constructor(rect: StiRectangle3D, render: StiRender3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendColumnMarker3D implements IStiLegendMarker {
        implements(): any[];
        draw(context: StiContext, series: IStiSeries, rect: Rectangle, colorIndex: number, colorCount: number, index: number): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendLineMarker3D implements IStiLegendMarker {
        implements(): any[];
        draw(context: StiContext, series: IStiSeries, rect: Rectangle, colorIndex: number, colorCount: number, index: number): void;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
    class StiSeriesElementGeom3D extends StiGeom3D implements IStiSeriesElement {
        implements(): any[];
        seriesColor: Color;
        value: number;
        index: number;
        series: IStiSeries;
        interaction: StiSeriesInteractionData;
        elementIndex: string;
        getInteractionData(): StiInteractionDataGeom;
        protected getValueIndex(): number;
        getToolTip(): string;
        private getToolTip2;
        constructor(render: StiRender3D, value: number, index: number, series: IStiSeries, color: Color);
    }
}
export namespace Stimulsoft.Report.Chart {
    import PointF = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiBorderColor = Stimulsoft.Report.Components.IStiBorderColor;
    import IStiColor = Stimulsoft.Report.Components.IStiColor;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import List = Stimulsoft.System.Collections.List;
    class StiBoxSeriesElementGeom3D extends StiSeriesElementGeom3D implements IStiBorderColor, IStiColor, IStiDrawSidesGeom3D {
        implements(): any[];
        color: Color;
        borderColor: Color;
        get backFace(): number[];
        get leftFace(): number[];
        get bottomFace(): number[];
        get topFace(): number[];
        get rightFace(): number[];
        get frontFace(): number[];
        private _columnRect3D;
        get columnRect3D(): StiRectangle3D;
        set columnRect3D(value: StiRectangle3D);
        private _drawLeft;
        get drawLeft(): boolean;
        set drawLeft(value: boolean);
        private _drawBack;
        get drawBack(): boolean;
        set drawBack(value: boolean);
        private _drawTop;
        get drawTop(): boolean;
        set drawTop(value: boolean);
        private _drawBottom;
        get drawBottom(): boolean;
        set drawBottom(value: boolean);
        private setVertexes;
        drawBorder(context: StiContext, vertices: StiMatrix): void;
        buildFaces(): void;
        buildColorFaces(): void;
        protected getFacePolygonPoints(face: number[], vertices: StiMatrix): List<PointF>;
        private isTopFace;
        private isBottomFace;
        private isDrawTopFace;
        private isDrawBottomFace;
        constructor(columnRect3D: StiRectangle3D, value: number, index: number, series: IStiSeries, color: Color, borderColor: Color, render: StiRender3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiBorderColor = Stimulsoft.Report.Components.IStiBorderColor;
    import IStiColor = Stimulsoft.Report.Components.IStiColor;
    class StiLineSeriesGeom3D extends StiGeom3D implements IStiBorderColor, IStiColor {
        implements(): any[];
        color: Color;
        borderColor: Color;
        constructor(sPoint1: StiPoint3D, sPoint2: StiPoint3D, ePoint1: StiPoint3D, ePoint2: StiPoint3D, color: Color, borderColor: Color, render: StiRender3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiBorderColor = Stimulsoft.Report.Components.IStiBorderColor;
    import IStiColor = Stimulsoft.Report.Components.IStiColor;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiPartialPyramidSeriesElementGeom3D extends StiSeriesElementGeom3D implements IStiBorderColor, IStiColor, IStiDrawSidesGeom3D {
        implements(): any[];
        color: Color;
        borderColor: Color;
        rect3D: StiRectangle3D;
        partialRect3D: StiRectangle3D;
        get backFace(): number[];
        get leftFace(): number[];
        get bottomFace(): number[];
        get topFace(): number[];
        get rightFace(): number[];
        get frontFace(): number[];
        private _drawLeft;
        get drawLeft(): boolean;
        set drawLeft(value: boolean);
        private _drawBack;
        get drawBack(): boolean;
        set drawBack(value: boolean);
        private _drawTop;
        get drawTop(): boolean;
        set drawTop(value: boolean);
        private _drawBottom;
        get drawBottom(): boolean;
        set drawBottom(value: boolean);
        private setVertexes;
        drawBorder(context: StiContext, vertices: StiMatrix): void;
        buildFaces(): void;
        buildColorFaces(): void;
        constructor(rect3D: StiRectangle3D, partialRect3D: StiRectangle3D, value: number, index: number, series: IStiSeries, color: Color, borderColor: Color, render: StiRender3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiBorderColor = Stimulsoft.Report.Components.IStiBorderColor;
    import IStiColor = Stimulsoft.Report.Components.IStiColor;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiPyramidSeriesElementGeom3D extends StiSeriesElementGeom3D implements IStiBorderColor, IStiColor {
        implements(): any[];
        color: Color;
        borderColor: Color;
        private _columnRect3D;
        get columnRect3D(): StiRectangle3D;
        set columnRect3D(value: StiRectangle3D);
        get backFace(): number[];
        get leftFace(): number[];
        get bottomFace(): number[];
        get rightFace(): number[];
        get frontFace(): number[];
        private setVertexes;
        drawBorder(context: StiContext, vertices: StiMatrix): void;
        constructor(columnRect3D: StiRectangle3D, value: number, index: number, series: IStiSeries, color: Color, borderColor: Color, render: StiRender3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiSeriesLabelsGeom3D extends StiGeom3D {
        value: number;
        index: number;
        series: IStiSeries;
        seriesLabels: IStiSeriesLabels;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, render3D: StiRender3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    import SizeF = Stimulsoft.System.Drawing.Size;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    class StiCenterAxisLabelsGeom3D extends StiSeriesLabelsGeom3D {
        text: string;
        labelColor: Color;
        labelBorderColor: Color;
        seriesBrush: StiBrush;
        seriesLabelsBrush: StiBrush;
        seriesBorderColor: Color;
        font: StiFontGeom;
        drawElements(context: StiContext, vertices: StiMatrix): void;
        protected drawLabelArea(context: StiContext, rect: Rectangle): void;
        protected drawLabelText(context: StiContext, rect: Rectangle): void;
        private getFormatGeom;
        protected getLabelRect(context: StiContext): SizeF;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, labelText: string, labelColor: Color, labelBorderColor: Color, seriesBrush: StiBrush, seriesLabelsBrush: StiBrush, seriesBorderColor: Color, font: StiFontGeom, point3D: StiPoint3D, render3D: StiRender3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiOutsideAxisLabelsGeom3D extends StiCenterAxisLabelsGeom3D {
        drawElements(context: StiContext, vertices: StiMatrix): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, labelText: string, labelColor: Color, labelBorderColor: Color, seriesBrush: StiBrush, seriesLabelsBrush: StiBrush, seriesBorderColor: Color, font: StiFontGeom, point3D: StiPoint3D, render3D: StiRender3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiMatrixHelper {
        static translate(tx: number, ty: number, tz: number): StiMatrix;
        static scale(n: number): StiMatrix;
        static rotateX(a: number): StiMatrix;
        static rotateY(a: number): StiMatrix;
        static rotateZ(a: number): StiMatrix;
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiPoint3D {
        x: number;
        y: number;
        z: number;
        constructor(x: number, y: number, z: number);
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiRectangle3D implements IStiRectangle3D {
        x: number;
        y: number;
        z: number;
        length: number;
        height: number;
        width: number;
        get right(): number;
        get front(): number;
        get top(): number;
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiArea3D extends StiService implements IStiJsonReportObject, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        static loadFromJsonObjectInternal(jObject: StiJson): IStiArea;
        static loadAreaFromXml(xmlNode: XmlNode, chart: Stimulsoft.Report.Components.StiChart): StiArea;
        get propName(): string;
        clone(): StiArea;
        toString(): string;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        get serviceCategory(): string;
        get serviceType(): Stimulsoft.System.Type;
        core: StiAreaCoreXF;
        chart: IStiChart;
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiAxisArea3D extends StiArea implements IStiJsonReportObject, IStiAxisArea3D, IStiArea, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        clone(): any;
        private _xAxis;
        get xAxis(): IStiXAxis3D;
        set xAxis(value: IStiXAxis3D);
        private _yAxis;
        get yAxis(): IStiYAxis3D;
        set yAxis(value: IStiYAxis3D);
        private _zAxis;
        get zAxis(): IStiAxis3D;
        set zAxis(value: IStiAxis3D);
        private _rotationX;
        get rotationX(): number;
        set rotationX(value: number);
        private _rotationY;
        get rotationY(): number;
        set rotationY(value: number);
        scale: number;
        cameraX: number;
        cameraY: number;
        cameraZ: number;
        nearPlane: number;
        get axisCore(): StiAxisAreaCoreXF3D;
        private _interlacingHor;
        get interlacingHor(): IStiInterlacingHor;
        set interlacingHor(value: IStiInterlacingHor);
        private _interlacingVert;
        get interlacingVert(): IStiInterlacingVert;
        set interlacingVert(value: IStiInterlacingVert);
        private _gridLinesHor;
        get gridLinesHor(): IStiGridLinesHor;
        set gridLinesHor(value: IStiGridLinesHor);
        private _gridLinesVert;
        get gridLinesVert(): IStiGridLinesVert;
        set gridLinesVert(value: IStiGridLinesVert);
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiClusteredColumnArea3D extends StiAxisArea3D implements IStiJsonReportObject, IStiClusteredColumnArea3D, ICloneable, IStiArea3D {
        implements(): any[];
        meta(): StiMeta[];
        private _sideBySide;
        get sideBySide(): boolean;
        set sideBySide(value: boolean);
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiLineArea3D extends StiClusteredColumnArea3D implements IStiJsonReportObject, IStiLineArea3D, IStiClusteredColumnArea3D, ICloneable, IStiArea3D {
        implements(): any[];
        meta(): StiMeta[];
        get sideBySide(): boolean;
        set sideBySide(value: boolean);
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedColumnArea3D extends StiAxisArea3D implements IStiJsonReportObject, IStiStackedColumnArea3D, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedColumnArea3D extends StiStackedColumnArea3D implements IStiArea3D, IStiAxisArea3D, IStiFullStackedColumnArea3D, IStiJsonReportObject, ICloneable {
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiAxis3D implements IStiAxis3D, IStiJsonReportObject {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): any;
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        info: StiAxisInfoXF3D;
        core: StiAxisCoreXF3D;
        labels: IStiAxisLabels3D;
        lineColor: Color;
        visible: boolean;
        area: IStiAxisArea3D;
        private _title;
        get title(): IStiAxisTitle3D;
        set title(value: IStiAxisTitle3D);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiAxisLabels3D implements IStiJsonReportObject, IStiAxisLabels3D, IStiFont, ICloneable {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): any;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        core: StiAxisLabelsCoreXF3D;
        allowApplyStyle: boolean;
        format: string;
        font: Font;
        color: Color;
        textBefore: string;
        textAfter: string;
        angle: number;
        width: number;
        wordWrap: boolean;
        calculatedStep: number;
        formatService: StiFormatService;
        constructor(format?: string, textBefore?: string, textAfter?: string, font?: Font, color?: Color, allowApplyStyle?: boolean, angle?: number, width?: number, wordWrap?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiDirection = Stimulsoft.Report.Chart.StiDirection;
    class StiAxisTitle3D implements IStiJsonReportObject, IStiAxisTitle3D, IStiFont, ICloneable {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): any;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        core: StiAxisTitleCoreXF3D;
        allowApplyStyle: boolean;
        font: Font;
        text: string;
        color: Color;
        direction: StiDirection;
        constructor(font?: Font, text?: string, color?: Color, direction?: StiDirection, allowApplyStyle?: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiXAxis3D extends StiAxis3D implements IStiJsonReportObject, IStiXAxis3D, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        get propName(): string;
        showEdgeValues: boolean;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiYAxis3D extends StiAxis3D implements IStiJsonReportObject, IStiYAxis3D, ICloneable {
        implements(): any[];
        get propName(): string;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiZAxis3D extends StiAxis3D implements IStiJsonReportObject, IStiZAxis3D, ICloneable {
        implements(): any[];
        get propName(): string;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiSeries3D extends StiSeries {
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBaseLineSeries3D extends StiSeries3D implements IStiJsonReportObject, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        lineColor: Color;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiClusteredColumnSeries3D extends StiSeries3D implements IStiClusteredColumnSeries3D, IStiColumnShape3D, IStiJsonReportObject, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        private _length;
        get length(): number;
        set length(value: number);
        private _width;
        get width(): number;
        set width(value: number);
        borderColor: Color;
        color: Color;
        columnShape: StiColumnShape3D;
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiLineSeries3D extends StiBaseLineSeries3D implements IStiLineSeries3D, IStiJsonReportObject, ICloneable {
        implements(): any[];
        width: number;
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStackedColumnSeries3D extends StiSeries3D implements IStiStackedColumnSeries3D, IStiClusteredColumnSeries3D, IStiColumnShape3D, IStiJsonReportObject, ICloneable, IStiSeries {
        implements(): any[];
        meta(): StiMeta[];
        private _length;
        get length(): number;
        set length(value: number);
        private _width;
        get width(): number;
        set width(value: number);
        borderColor: Color;
        color: Color;
        columnShape: StiColumnShape3D;
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    class StiFullStackedColumnSeries3D extends StiStackedColumnSeries3D implements IStiFullStackedColumnSeries3D, IStiStackedColumnSeries3D, IStiClusteredColumnSeries3D, IStiColumnShape3D {
        implements(): any[];
        getDefaultAreaType(): Stimulsoft.System.Type;
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisSeriesLabels3D extends StiSeriesLabels implements IStiAxisSeriesLabels, IStiSeriesLabels, ICloneable {
        implements(): any[];
        meta(): StiMeta[];
        private _showInPercent;
        get showInPercent(): boolean;
        set showInPercent(value: boolean);
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiCenterAxisLabels3D extends StiAxisSeriesLabels3D implements IStiJsonReportObject, ICloneable {
        implements(): any[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiOutsideAxisLabels3D extends StiAxisSeriesLabels3D implements IStiJsonReportObject, ICloneable {
        implements(): any[];
        constructor();
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Type = Stimulsoft.System.Type;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    class StiGaugeStyleXF extends StiBaseStyle implements IStiGaugeStyle, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        static createFromJsonObject(jObject: StiJson): StiGaugeStyleXF;
        static createFromXml(xmlNode: XmlNode): StiGaugeStyleXF;
        get serviceName(): string;
        get serviceCategory(): string;
        get serviceType(): Type;
        core: StiGaugeStyleCoreXF;
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        toString(): string;
        compareGaugeStyle(style: StiGaugeStyleXF): boolean;
        drawStyle(g: Graphics, rect: Rectangle, paintValue: boolean, paintImage: boolean): void;
        drawBox(g: Graphics, rect: Rectangle, paintValue: boolean, paintImage: boolean): void;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF26 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        constructor();
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF27 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        constructor();
    }
}
export namespace Stimulsoft.Report.Gauge {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    class StiGaugeStyleCoreXF implements IStiGaugeStyleCoreXF {
        get localizedName(): string;
        brush: StiBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        targetColor: Color;
        tickMarkMajorBrush: StiBrush;
        tickMarkMajorBorder: StiBrush;
        tickMarkMajorBorderWidth: number;
        tickMarkMinorBrush: StiBrush;
        tickMarkMinorBorder: StiBrush;
        tickMarkMinorBorderWidth: number;
        tickLabelMajorTextBrush: StiBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiBrush;
        tickLabelMinorFont: Font;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        linearBarBorderBrush: StiBrush;
        linearBarEmptyBrush: StiBrush;
        linearBarEmptyBorderBrush: StiBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiBrush;
        radialBarBorderBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
        radialBarEmptyBorderBrush: StiBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
        markerSkin: StiMarkerSkin;
        markerBrush: StiBrush;
        markerBorderBrush: StiBrush;
        markerBorderWidth: number;
        styleId: StiGaugeStyleId;
        gauge: StiGauge;
    }
}
export namespace Stimulsoft.Report.Gauge {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiGaugeStyleCoreXF25 extends StiGaugeStyleCoreXF {
        get localizedName(): string;
        brush: StiBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        targetColor: Color;
        tickMarkMajorBrush: StiBrush;
        tickMarkMajorBorder: StiBrush;
        tickMarkMinorBrush: StiBrush;
        tickMarkMinorBorder: StiBrush;
        tickLabelMajorTextBrush: StiBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiBrush;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        linearBarBorderBrush: StiBrush;
        linearBarEmptyBrush: any;
        linearBarEmptyBorderBrush: any;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiBrush;
        radialBarBorderBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
        radialBarEmptyBorderBrush: StiBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiGaugeStyle = Stimulsoft.Report.StiGaugeStyle;
    class StiCustomGaugeStyleCoreXF extends StiGaugeStyleCoreXF25 {
        get localizedName(): string;
        get reportStyleName(): string;
        reportGaugeStyle: StiGaugeStyle;
        constructor(style: StiGaugeStyle);
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiCustomGaugeStyleCoreXF = Stimulsoft.Report.Gauge.StiCustomGaugeStyleCoreXF;
    class StiCustomGaugeStyle extends StiGaugeStyleXF27 {
        get serviceName(): string;
        get customCore(): StiCustomGaugeStyleCoreXF;
        constructor(style?: StiGaugeStyle);
    }
}
export namespace Stimulsoft.Report.Gauge.Helpers {
    class StiMathHelper {
        static length1(value1: number, value2: number): number;
        static maxMinusMin(value1: number, value2: number): number;
        static getMax(...list: number[]): number;
    }
}
export namespace Stimulsoft.Report.Gauge.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiRectangleHelper {
        static centerX(rect: Rectangle): number;
        static centerY(rect: Rectangle): number;
    }
}
export namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import StiGraphicsPathLinesGaugeGeom = Stimulsoft.Report.Gauge.GaugeGeoms.StiGraphicsPathLinesGaugeGeom;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import IStiScaleBarGeometry = Stimulsoft.Report.Gauge.Primitives.IStiScaleBarGeometry;
    import Size = Stimulsoft.System.Drawing.Size;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiLinearBarGeometry implements IStiScaleBarGeometry {
        private scale;
        size: Size;
        rectGeometry: Rectangle;
        radius: number;
        diameter: number;
        center: Point;
        checkRectGeometry(rect: Rectangle): void;
        private getRectGeometry;
        getRestToLenght(): number;
        private checkMinMaxWidth;
        drawScaleGeometry(context: StiGaugeContextPainter): void;
        drawGeometry(context: StiGaugeContextPainter, startValue1: number, endValue1: number, startWidth: number, endWidth: number, offset: number, placement: StiPlacement, REFrect: any, returnOnlyRect: boolean): StiGraphicsPathLinesGaugeGeom;
        drawPrimitiveGeometry(context: StiGaugeContextPainter, rect: Rectangle, minAscent: number, maxAscent: number, startWidth: number, endWidth: number, placement: StiPlacement, restOffset: number, isStartGreaterEnd: boolean): StiGraphicsPathLinesGaugeGeom;
        constructor(scale: StiLinearScale);
    }
}
export namespace Stimulsoft.Report.Gauge {
    let IStiApplyStyleGauge: System.Interface<IStiApplyStyleGauge>;
    interface IStiApplyStyleGauge {
        applyStyle(style: IStiGaugeStyle): void;
    }
}
export namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IAsIs = Stimulsoft.System.IAsIs;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiApplyStyleGauge = Stimulsoft.Report.Gauge.IStiApplyStyleGauge;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiElementBase implements ICloneable, IStiApplyStyleGauge, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        applyStyle(style: IStiGaugeStyle): void;
        clone(): any;
        allowApplyStyle: boolean;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
export namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import EventArgs = Stimulsoft.System.EventArgs;
    import IStiScaleBarGeometry = Stimulsoft.Report.Gauge.Primitives.IStiScaleBarGeometry;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiScaleBase = Stimulsoft.Report.Components.Gauge.IStiScaleBase;
    import StiElementBase = Stimulsoft.Report.Components.Gauge.Primitives.StiElementBase;
    class StiScaleHelper {
        actualMinimum: number;
        actualMaximum: number;
        minWidth: number;
        maxWidth: number;
        private _totalLength;
        get totalLength(): number;
        set totalLength(value: number);
    }
    class StiScaleBase extends StiElementBase implements IStiJsonReportObject, IStiScaleBase {
        meta(): StiMeta[];
        get propName(): string;
        clone(): StiScaleBase;
        barGeometry: IStiScaleBarGeometry;
        scaleHelper: StiScaleHelper;
        get isUp(): boolean;
        gauge: StiGauge;
        seriesKey: {};
        private _left;
        get left(): number;
        set left(value: number);
        private _top;
        get top(): number;
        set top(value: number);
        private _startWidth;
        get startWidth(): number;
        set startWidth(value: number);
        private _endWidth;
        get endWidth(): number;
        set endWidth(value: number);
        private _majorInterval;
        get majorInterval(): number;
        set majorInterval(value: number);
        private _minorInterval;
        get minorInterval(): number;
        set minorInterval(value: number);
        private _minimum;
        get minimum(): number;
        set minimum(value: number);
        private _maximum;
        get maximum(): number;
        set maximum(value: number);
        private _isReversed;
        get isReversed(): boolean;
        set isReversed(value: boolean);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _borderBrush;
        get borderBrush(): StiBrush;
        set borderBrush(value: StiBrush);
        _items: Stimulsoft.Report.Gauge.Collections.StiGaugeElementCollection;
        get items(): Stimulsoft.Report.Gauge.Collections.StiGaugeElementCollection;
        set(value: Stimulsoft.Report.Gauge.Collections.StiGaugeElementCollection): void;
        get scaleType(): StiGaugeElemenType;
        dateTimeMode: boolean;
        prepare(gauge: StiGauge): void;
        calculateMinMaxScaleHelper(): void;
        calculateWidthScaleHelper(): void;
        getPosition(value: number): number;
        interactiveClick(e: EventArgs): void;
        drawElement(context: StiGaugeContextPainter): void;
        constructor();
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import EventArgs = Stimulsoft.System.EventArgs;
    import Orientation = Stimulsoft.System.Drawing.Orientation;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiLinearScale extends StiScaleBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        applyStyle(style: IStiGaugeStyle): void;
        private _orientation;
        get orientation(): Orientation;
        set orientation(value: Orientation);
        private _relativeHeight;
        get relativeHeight(): number;
        set relativeHeight(value: number);
        get scaleType(): Stimulsoft.Report.Gauge.StiGaugeElemenType;
        interactiveClick(e: EventArgs): void;
        constructor();
    }
}
export namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import StiGraphicsPathLinesGaugeGeom = Stimulsoft.Report.Gauge.GaugeGeoms.StiGraphicsPathLinesGaugeGeom;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import Size = Stimulsoft.System.Drawing.Size;
    import IStiScaleBarGeometry = Stimulsoft.Report.Gauge.Primitives.IStiScaleBarGeometry;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiRadialBarGeometry implements IStiScaleBarGeometry {
        scale: StiRadialScale;
        size: Size;
        rectGeometry: Rectangle;
        radius: number;
        diameter: number;
        center: Point;
        checkRectGeometry(rect: Rectangle): void;
        drawScaleGeometry(context: StiGaugeContextPainter): void;
        getRestToLenght(): number;
        drawGeometry(context: StiGaugeContextPainter, startValue: number, endValue: number, startWidth: number, endWidth: number, offset: number, placement: StiPlacement, REFrect: any, returnOnlyRect: boolean): StiGraphicsPathLinesGaugeGeom;
        constructor(scale: StiRadialScale);
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import EventArgs = Stimulsoft.System.EventArgs;
    import Point = Stimulsoft.System.Drawing.Point;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    class StiRadialScale extends StiScaleBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        protected loadPointFromXml(text: string): Point;
        clone(): StiRadialScale;
        applyStyle(style: IStiGaugeStyle): void;
        private _radius;
        get radius(): number;
        set radius(value: number);
        private _radiusMode;
        get radiusMode(): Stimulsoft.Report.Gauge.StiRadiusMode;
        set radiusMode(value: Stimulsoft.Report.Gauge.StiRadiusMode);
        private _center;
        get center(): Point;
        set center(value: Point);
        private _startAngle;
        get startAngle(): number;
        set startAngle(value: number);
        private _sweepAngle;
        get sweepAngle(): number;
        set sweepAngle(value: number);
        private _skin;
        get skin(): Stimulsoft.Report.Gauge.StiRadialScaleSkin;
        set skin(value: Stimulsoft.Report.Gauge.StiRadialScaleSkin);
        get scaleType(): Stimulsoft.Report.Gauge.StiGaugeElemenType;
        getRadius(): number;
        getStartWidth(): number;
        getEndWidth(): number;
        getSweepAngle(): number;
        getCurrentAngle(angle: number): number;
        interactiveClick(e: EventArgs): void;
        constructor();
    }
}
export namespace Stimulsoft.Report.Gauge.Collections {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    class StiScaleCollection extends CollectionBase<StiScaleBase> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private parent;
        clone(): StiScaleCollection;
        get isReadOnly(): boolean;
        private setParent;
        private clearParent;
        add(element: StiScaleBase): void;
        insert(index: number, element: StiScaleBase): void;
        remove(element: StiScaleBase): boolean;
        copyTo(elements: StiScaleBase[], arrayIndex: number): void;
        moveUp(element: StiScaleBase): boolean;
        moveDown(element: StiScaleBase): boolean;
        constructor(parent: StiGauge);
    }
}
export namespace Stimulsoft.Report.Components {
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    import List = Stimulsoft.System.Collections.List;
    import StiScaleMode = Stimulsoft.Report.Gauge.StiScaleMode;
    import StiGaugeCalculationMode = Stimulsoft.Report.Gauge.StiGaugeCalculationMode;
    import StiGaugeType = Stimulsoft.Report.Gauge.StiGaugeType;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiScaleCollection = Stimulsoft.Report.Gauge.Collections.StiScaleCollection;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiExportImageExtended = Stimulsoft.Report.Components.IStiExportImageExtended;
    import IStiBorder = Stimulsoft.Report.Components.IStiBorder;
    import IStiBrush = Stimulsoft.Report.Components.IStiBrush;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiGauge = Stimulsoft.Report.Components.Gauge.IStiGauge;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    class StiGauge extends StiComponent implements IStiExportImageExtended, IStiBorder, IStiBrush, IStiGauge, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(cloneProperties?: boolean, cloneComponents?: boolean): StiGauge;
        prepareInit(): void;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        private _border;
        get border(): StiBorder;
        set border(value: StiBorder);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private valueFormat_;
        get valueFormat(): StiFormatService;
        set valueFormat(value: StiFormatService);
        private static getValueFormatDefault;
        get localizedCategory(): string;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        mode: StiScaleMode;
        shortValue: boolean;
        minimum: number;
        maximum: number;
        type: StiGaugeType;
        calculationMode: StiGaugeCalculationMode;
        painter: StiGaugeContextPainter;
        private _style;
        get style(): IStiGaugeStyle;
        set style(value: IStiGaugeStyle);
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        customStyleName: string;
        scales: StiScaleCollection;
        isAnimation: boolean;
        previousAnimations: List<StiAnimation>;
        private changeSkin;
        private getGaugeStyle;
        drawGauge(context: StiGaugeContextPainter): void;
        applyStyle(style: IStiGaugeStyle): void;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Report.Gauge.Collections {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiIndicatorRangeInfo = Stimulsoft.Report.Components.Gauge.StiIndicatorRangeInfo;
    class StiBarRangeListCollection extends CollectionBase<StiIndicatorRangeInfo> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private barType;
        clone(): StiBarRangeListCollection;
        get isReadOnly(): boolean;
        add(element: StiIndicatorRangeInfo): void;
        insert(index: number, element: StiIndicatorRangeInfo): void;
        copyTo(elements: StiIndicatorRangeInfo[], arrayIndex: number): void;
        moveUp(element: StiIndicatorRangeInfo): boolean;
        moveDown(element: StiIndicatorRangeInfo): boolean;
        constructor(barType: StiBarRangeListType);
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    import IStiCustomValueBase = Stimulsoft.Report.Components.Gauge.IStiCustomValueBase;
    class StiCustomValueBase implements ICloneable, IStiCustomValueBase, IStiJsonReportObject {
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        get propName(): string;
        clone(): any;
        private _value;
        get value(): number;
        set value(value: number);
        private _placement;
        get placement(): StiPlacement;
        set placement(value: StiPlacement);
        private _offset;
        get offset(): number;
        set offset(value: number);
        get localizedName(): string;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiCustomValueBase = Stimulsoft.Report.Components.Gauge.StiCustomValueBase;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    class StiRadialTickMarkCustomValue extends StiCustomValueBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        clone(): StiRadialTickMarkCustomValue;
        useBrush: boolean;
        useBorderBrush: boolean;
        useBorderWidth: boolean;
        private _relativeWidth;
        get relativeWidth(): number;
        set relativeWidth(value: number);
        private _relativeHeight;
        get relativeHeight(): number;
        set relativeHeight(value: number);
        private _offsetAngle;
        get offsetAngle(): number;
        set offsetAngle(value: number);
        private _skin;
        get skin(): StiGaugeElementSkin;
        set skin(value: StiGaugeElementSkin);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _borderBrush;
        get borderBrush(): StiBrush;
        set borderBrush(value: StiBrush);
        private _borderWidth;
        get borderWidth(): number;
        set borderWidth(value: number);
        get localizedName(): string;
        toString(): string;
        constructor(value?: number, offset?: number, relativeWidth?: number, relativeHeight?: number, offsetAngle?: number, placement?: StiPlacement, brush?: StiBrush, borderBrush?: StiBrush, borderWidth?: number, skin?: StiGaugeElementSkin);
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiLabelRotationMode = Stimulsoft.Report.Gauge.StiLabelRotationMode;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    class StiRadialTickLabelCustomValue extends StiCustomValueBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        text: string;
        offsetAngle: number;
        labelRotationMode: StiLabelRotationMode;
        get localizedName(): string;
        toString(): string;
        constructor(value?: number, text?: string, offset?: number, offsetAngle?: number, labelRotationMode?: StiLabelRotationMode, placement?: StiPlacement);
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    class StiLinearTickMarkCustomValue extends StiCustomValueBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        private _relativeWidth;
        get relativeWidth(): number;
        set relativeWidth(value: number);
        private _relativeHeight;
        get(): number;
        set relativeHeight(value: number);
        private _skin;
        get skin(): StiGaugeElementSkin;
        set skin(value: StiGaugeElementSkin);
        get localizedName(): string;
        toString(): string;
        constructor(value?: number, offset?: number, relativeWidth?: number, relativeHeight?: number, placement?: StiPlacement, skin?: StiGaugeElementSkin);
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    class StiLinearTickLabelCustomValue extends StiCustomValueBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        private _text;
        get text(): string;
        set text(value: string);
        get localizedName(): string;
        toString(): string;
        constructor(value?: number, text?: string, offset?: number, placement?: StiPlacement);
    }
}
export namespace Stimulsoft.Report.Gauge.Collections {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiCustomValueBase = Stimulsoft.Report.Components.Gauge.StiCustomValueBase;
    class StiCustomValuesCollection extends CollectionBase<StiCustomValueBase> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiCustomValuesCollection;
        get isReadOnly(): boolean;
        copyTo(elements: StiCustomValueBase[], arrayIndex: number): void;
        moveUp(element: StiCustomValueBase): boolean;
        moveDown(element: StiCustomValueBase): boolean;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStateIndicatorFilter implements ICloneable, IStiJsonReportObject {
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        get propName(): string;
        clone(): any;
        private _startValue;
        get startValue(): number;
        set startValue(value: number);
        private _endValue;
        get endValue(): number;
        set endValue(value: number);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _borderBrush;
        get borderBrush(): StiBrush;
        set borderBrush(value: StiBrush);
        toString(): string;
    }
}
export namespace Stimulsoft.Report.Gauge.Collections {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiStateIndicatorFilter = Stimulsoft.Report.Components.Gauge.StiStateIndicatorFilter;
    class StiFilterCollection extends CollectionBase<StiStateIndicatorFilter> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiFilterCollection;
        get isReadOnly(): boolean;
        moveUp(element: StiStateIndicatorFilter): boolean;
        moveDown(element: StiStateIndicatorFilter): boolean;
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle?: number, centerPoint?: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiIndicatorBase = Stimulsoft.Report.Components.Gauge.Primitives.StiIndicatorBase;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiMarkerBaseSkin extends StiGaugeElementSkin {
        addLines(context: StiGaugeContextPainter, indicator: StiIndicatorBase, points: Point[], rect: Rectangle, angle: number, centerPoint: Point, sf: StringFormat, animation: StiAnimation): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker10Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker11Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker12Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker13Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker14Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker15Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker1Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker2Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker3Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker4Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker5Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker6Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker7Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker8Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker9Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiNeedleIndicator1Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    class StiNeedleIndicator2Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiNeedleIndicator3Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    class StiNeedleIndicator4Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiState1Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    class StiState2Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiState3Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark1Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark2Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark3Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark4Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark5Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark6Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark7Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Helpers {
    class StiGaugeSkinHelper {
        static getMarkerSkin(skin: StiMarkerSkin): StiGaugeElementSkin;
        static getTickMarkSkin(skin: StiTickMarkSkin): StiGaugeElementSkin;
        static getStateIndicatorSkin(skin: StiStateSkin): StiGaugeElementSkin;
        static getNeedleIndicatorSkin(skin: StiNeedleSkin): StiGaugeElementSkin;
    }
}
export namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import IStiGaugeElement = Stimulsoft.Report.Components.Gauge.IStiGaugeElement;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiGaugeElement extends StiElementBase implements IStiJsonReportObject, IStiGaugeElement {
        meta(): StiMeta[];
        get PropName(): string;
        animation: StiAnimation;
        get elementType(): StiGaugeElemenType;
        get localizeName(): string;
        scale: StiScaleBase;
        prepareGaugeElement(): void;
    }
}
export namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiIndicatorBase extends StiGaugeElement implements IStiJsonReportObject {
        meta(): StiMeta[];
        clone(): StiIndicatorBase;
        private _valueObj;
        get valueObj(): number;
        set valueObj(value: number);
        private _placement;
        get placement(): Stimulsoft.Report.Gauge.StiPlacement;
        set placement(value: Stimulsoft.Report.Gauge.StiPlacement);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _borderBrush;
        get borderBrush(): StiBrush;
        set borderBrush(value: StiBrush);
        private _borderWidth;
        get borderWidth(): number;
        set borderWidth(value: number);
        getValueEvent: StiEvent;
        onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _value;
        get value(): string;
        set value(value: string);
        prepareGaugeElement(): void;
        interactiveClick(rect: Rectangle, p: Point): void;
        onValueChanged(): void;
        getActualValue(): number;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import Point = Stimulsoft.System.Drawing.Point;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiIndicatorBase = Stimulsoft.Report.Components.Gauge.Primitives.StiIndicatorBase;
    class StiNeedle extends StiIndicatorBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        protected loadPointFromXml(text: string): Point;
        applyStyle(style: IStiGaugeStyle): void;
        private _format;
        get format(): string;
        set format(value: string);
        private _showValue;
        get showValue(): boolean;
        set showValue(value: boolean);
        private _textBrush;
        get textBrush(): StiBrush;
        set textBrush(value: StiBrush);
        private _font;
        get font(): Font;
        set font(value: Font);
        private _capBrush;
        get capBrush(): StiBrush;
        set capBrush(value: StiBrush);
        private _capBorderBrush;
        get capBorderBrush(): StiBrush;
        set capBorderBrush(value: StiBrush);
        private _capBorderWidth;
        get capBorderWidth(): number;
        set capBorderWidth(value: number);
        offsetNeedle: number;
        startWidth: number;
        endWidth: number;
        private _autoCalculateCenterPoint;
        get autoCalculateCenterPoint(): boolean;
        set autoCalculateCenterPoint(value: boolean);
        private _centerPoint;
        get centerPoint(): Point;
        set centerPoint(value: Point);
        private _relativeHeight;
        get relativeHeight(): number;
        set relativeHeight(value: number);
        private _relativeWidth;
        get relativeWidth(): number;
        set relativeWidth(value: number);
        private _skin;
        get skin(): Stimulsoft.Report.Gauge.StiNeedleSkin;
        set skin(value: Stimulsoft.Report.Gauge.StiNeedleSkin);
        customSkin: StiGaugeElementSkin;
        get elementType(): StiGaugeElemenType;
        get localizeName(): string;
        drawElement(context: StiGaugeContextPainter): any;
        interactiveClick(rect: Rectangle, p: Point): void;
        private getActualCenterPoint;
        private getActualSkin;
        constructor();
    }
}
export namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import IStiGaugeMarker = Stimulsoft.Report.Gauge.IStiGaugeMarker;
    class StiMarkerBase extends StiIndicatorBase implements IStiGaugeMarker, IStiJsonReportObject {
        meta(): StiMeta[];
        clone(): StiMarkerBase;
        private _offset;
        get offset(): number;
        set offset(value: number);
        private _relativeWidth;
        get relativeWidth(): number;
        set relativeWidth(value: number);
        private _relativeHeight;
        get relativeHeight(): number;
        set relativeHeight(value: number);
        private _skin;
        get skin(): Stimulsoft.Report.Gauge.StiMarkerSkin;
        set skin(value: Stimulsoft.Report.Gauge.StiMarkerSkin);
        customSkin: StiGaugeElementSkin;
        private _format;
        get format(): string;
        set format(value: string);
        private _showValue;
        get showValue(): boolean;
        set showValue(value: boolean);
        private _textBrush;
        get textBrush(): StiBrush;
        set textBrush(value: StiBrush);
        private _font;
        get font(): Font;
        set font(value: Font);
        getActualSkin(): StiGaugeElementSkin;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiMarkerBase = Stimulsoft.Report.Components.Gauge.Primitives.StiMarkerBase;
    class StiLinearMarker extends StiMarkerBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        applyStyle(style: IStiGaugeStyle): void;
        get localizeName(): string;
        drawElement(context: StiGaugeContextPainter): void;
        private getRectangle;
        interactiveClick(rect: Rectangle, p: Point): void;
        private getBarPosition;
    }
}
export namespace Stimulsoft.Report.Gauge.Helpers {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMixedColorHelper {
        static colorMixed(colors: Color[]): Color;
        private static colorMixer;
    }
}
export namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiBarRangeListCollection = Stimulsoft.Report.Gauge.Collections.StiBarRangeListCollection;
    import StiBarRangeListType = Stimulsoft.Report.Gauge.StiBarRangeListType;
    class StiBarBase extends StiIndicatorBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        clone(): StiBarBase;
        private _emptyBrush;
        get emptyBrush(): StiBrush;
        set emptyBrush(value: StiBrush);
        private _emptyBorderBrush;
        get emptyBorderBrush(): StiBrush;
        set emptyBorderBrush(value: StiBrush);
        private _emptyBorderWidth;
        get emptyBorderWidth(): number;
        set emptyBorderWidth(value: number);
        private _offset;
        get offset(): number;
        set offset(value: number);
        private _startWidth;
        get startWidth(): number;
        set startWidth(value: number);
        private _endWidth;
        get endWidth(): number;
        set endWidth(value: number);
        private _useRangeColor;
        get useRangeColor(): boolean;
        set useRangeColor(value: boolean);
        rangeList: StiBarRangeListCollection;
        get barType(): StiBarRangeListType;
        onRangeColorChanged(): void;
        checkActualBrushForTopGeometry(): void;
        onValueChanged(): void;
        constructor();
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBarBase = Stimulsoft.Report.Components.Gauge.Primitives.StiBarBase;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiLinearBar extends StiBarBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        applyStyle(style: IStiGaugeStyle): void;
        private colorModeHelper;
        private actualBackground;
        private _skin;
        get skin(): Stimulsoft.Report.Gauge.StiLinearBarSkin;
        set skin(value: Stimulsoft.Report.Gauge.StiLinearBarSkin);
        private _rangeColorMode;
        get rangeColorMode(): Stimulsoft.Report.Gauge.StiLinearRangeColorMode;
        set rangeColorMode(value: Stimulsoft.Report.Gauge.StiLinearRangeColorMode);
        onRangeColorChanged(): void;
        get barType(): Stimulsoft.Report.Gauge.StiBarRangeListType;
        get localizeName(): string;
        checkActualBrushForTopGeometry(): void;
        private getRangeBrush;
        interactiveClick(rect: Rectangle, p: Point): void;
        drawElement(context: StiGaugeContextPainter): void;
        private drawHorizontalThermometer;
        private drawVerticalThermometer;
        private getGeometryHelperForTopIndicator;
        private getTopGeometry;
    }
}
export namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiTickBase extends StiGaugeElement implements IStiJsonReportObject {
        meta(): StiMeta[];
        clone(): StiTickBase;
        getSkipValuesEvent: StiEvent;
        onGetSkipValues(e: StiGetValueEventArgs): void;
        invokeGetSkipValues(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        getSkipIndicesEvent: StiEvent;
        onGetSkipIndices(e: StiGetValueEventArgs): void;
        invokeGetSkipIndices(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _skipValues;
        get skipValues(): string;
        set skipValues(value: string);
        private _skipIndices;
        get skipIndices(): string;
        set skipIndices(value: string);
        private _placement;
        get placement(): Stimulsoft.Report.Gauge.StiPlacement;
        set placement(value: Stimulsoft.Report.Gauge.StiPlacement);
        private _skipValuesObj;
        get skipValuesObj(): number[];
        set skipValuesObj(value: number[]);
        private _skipIndicesObj;
        get skipIndicesObj(): number[];
        set skipIndicesObj(value: number[]);
        private _offset;
        get offset(): number;
        set offset(value: number);
        private _minimumValue;
        get minimumValue(): number;
        set minimumValue(value: number);
        private _maximumValue;
        get maximumValue(): number;
        set maximumValue(value: number);
        get isSkipMajorValues(): boolean;
        getPointCollection(): Hashtable;
        getMinorCollections(): Hashtable;
        getMajorCollections(): Hashtable;
        checkTickValue(skipValues: number[], skipIndices: number[], key: number, value: number): boolean;
        prepareGaugeElement(): void;
        getOffset(value: number): number;
        getPlacement(value: Stimulsoft.Report.Gauge.StiPlacement): Stimulsoft.Report.Gauge.StiPlacement;
    }
}
export namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    class StiTickLabelBase extends StiTickBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        clone(): StiTickLabelBase;
        private _textFormat;
        get textFormat(): string;
        set textFormat(value: string);
        private _formatService;
        get formatService(): StiFormatService;
        set formatService(value: StiFormatService);
        private _textBrush;
        get textBrush(): StiBrush;
        set textBrush(value: StiBrush);
        private _font;
        get font(): Font;
        set font(value: Font);
        getTextForRender(value: number, format: string): string;
        getTextForRender2(value: string, format?: string): string;
    }
}
export namespace Stimulsoft.Report.Gauge.Helpers {
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class CacheInfo {
        valueKey: number;
        valueStr: string;
        count: number;
        toString(): string;
        constructor(valueKey: number, valueStr: string, count: number);
    }
    class StiTickLabelHelper {
        static getLabels(collection: Hashtable, scale: StiScaleBase): Dictionary<number, string>;
        private static prepare;
    }
}
export namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiTickLabelBase;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Point = Stimulsoft.System.Drawing.Point;
    import Size = Stimulsoft.System.Drawing.Size;
    class StiRadialTickLabelBase extends StiTickLabelBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        private _labelRotationMode;
        get labelRotationMode(): Stimulsoft.Report.Gauge.StiLabelRotationMode;
        set labelRotationMode(value: Stimulsoft.Report.Gauge.StiLabelRotationMode);
        private _offsetAngle;
        get offsetAngle(): number;
        set offsetAngle(value: number);
        get elementType(): StiGaugeElemenType;
        drawElement(context: StiGaugeContextPainter): void;
        getMatrixRotation(context: StiGaugeContextPainter, centerPoint: Point, textSize: Size, rotateMode: Stimulsoft.Report.Gauge.StiLabelRotationMode, radius: number, angle: number, REFposition: any): number;
        private getRadialPosition;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiRadialTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickLabelBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiRadialTickLabelMinor extends StiRadialTickLabelBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        applyStyle(style: IStiGaugeStyle): void;
        private _skipMajorValues;
        get skipMajorValues(): boolean;
        set skipMajorValues(value: boolean);
        get isSkipMajorValues(): boolean;
        get elementType(): StiGaugeElemenType;
        get localizeName(): string;
        getPointCollection(): Hashtable;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiRadialTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickLabelBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiRadialTickLabelMajor extends StiRadialTickLabelBase {
        meta(): StiMeta[];
        applyStyle(style: IStiGaugeStyle): void;
        get elementType(): StiGaugeElemenType;
        get localizeName(): string;
        getPointCollection(): Hashtable;
    }
}
export namespace Stimulsoft.Report.Gauge.Events {
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiGetTextEventArgs extends EventArgs {
        value: string;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetTextEventArgs = Stimulsoft.Report.Gauge.Events.StiGetTextEventArgs;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiCustomValuesCollection = Stimulsoft.Report.Gauge.Collections.StiCustomValuesCollection;
    import StiRadialTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickLabelBase;
    import IStiTickCustom = Stimulsoft.Report.Gauge.Primitives.IStiTickCustom;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiRadialTickLabelCustom extends StiRadialTickLabelBase implements IStiTickCustom, IStiJsonReportObject {
        meta(): StiMeta[];
        clone(): StiRadialTickLabelCustom;
        valueObj: number;
        textObj: string;
        values: StiCustomValuesCollection;
        get elementType(): StiGaugeElemenType;
        get localizeName(): string;
        onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        getValueEvent: StiEvent;
        onGetText(e: StiGetTextEventArgs): void;
        invokeGetText(sender: StiGaugeElement, e: StiGetTextEventArgs): void;
        getTextEvent: StiEvent;
        value: string;
        text: string;
        prepareGaugeElement(): void;
        drawElement(context: StiGaugeContextPainter): void;
        private getOffsetAngle;
        private getLabelRotationMode;
    }
}
export namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiTickBase = Stimulsoft.Report.Components.Gauge.Primitives.StiTickBase;
    class StiTickMarkBase extends StiTickBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        clone(): StiTickMarkBase;
        private _relativeHeight;
        get relativeHeight(): number;
        set relativeHeight(value: number);
        private _relativeWidth;
        get relativeWidth(): number;
        set relativeWidth(value: number);
        private _skin;
        get skin(): Stimulsoft.Report.Gauge.StiTickMarkSkin;
        set skin(value: Stimulsoft.Report.Gauge.StiTickMarkSkin);
        customSkin: StiGaugeElementSkin;
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _borderBrush;
        get borderBrush(): StiBrush;
        set borderBrush(value: StiBrush);
        private _borderWidth;
        get borderWidth(): number;
        set borderWidth(value: number);
        getActualSkin(): StiGaugeElementSkin;
        getRelativeWidth(value: number): number;
        getRelativeHeight(value: number): number;
    }
}
export namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiLinearTickMarkBase extends StiTickMarkBase {
        drawElement(context: StiGaugeContextPainter): void;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiLinearTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickMarkBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiLinearTickMarkMinor extends StiLinearTickMarkBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        applyStyle(style: IStiGaugeStyle): void;
        private _skipMajorValues;
        get skipMajorValues(): boolean;
        set skipMajorValues(value: boolean);
        get isSkipMajorValues(): boolean;
        get localizeName(): string;
        getPointCollection(): Hashtable;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiLinearTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickMarkBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiLinearTickMarkMajor extends StiLinearTickMarkBase {
        meta(): StiMeta[];
        applyStyle(style: IStiGaugeStyle): void;
        get localizeName(): string;
        getPointCollection(): Hashtable;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiLinearTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickMarkBase;
    import IStiTickCustom = Stimulsoft.Report.Gauge.Primitives.IStiTickCustom;
    import StiCustomValuesCollection = Stimulsoft.Report.Gauge.Collections.StiCustomValuesCollection;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiLinearTickMarkCustom extends StiLinearTickMarkBase implements IStiTickCustom, IStiJsonReportObject {
        meta(): StiMeta[];
        clone(): StiLinearTickMarkCustom;
        private _valueObj;
        get valueObj(): number;
        set valueObj(value: number);
        values: StiCustomValuesCollection;
        get localizeName(): string;
        getValueEvent: StiEvent;
        onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _value;
        get value(): string;
        set value(value: string);
        prepareGaugeElement(): void;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
export namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import StiTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiTickLabelBase;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiLinearTickLabelBase extends StiTickLabelBase {
        drawElement(context: StiGaugeContextPainter): void;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiLinearTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickLabelBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiLinearTickLabelMinor extends StiLinearTickLabelBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        applyStyle(style: IStiGaugeStyle): void;
        private _skipMajorValues;
        get skipMajorValues(): boolean;
        set skipMajorValues(value: boolean);
        get isSkipMajorValues(): boolean;
        get localizeName(): string;
        getPointCollection(): Hashtable;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiLinearTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickLabelBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiLinearTickLabelMajor extends StiLinearTickLabelBase {
        meta(): StiMeta[];
        applyStyle(style: IStiGaugeStyle): void;
        get localizeName(): string;
        getPointCollection(): Hashtable;
    }
}
export namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiTickMarkBase;
    class StiRadialTickMarkBase extends StiTickMarkBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        private _offsetAngle;
        get offsetAngle(): number;
        set offsetAngle(value: number);
        get elementType(): StiGaugeElemenType;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiRadialTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickMarkBase;
    import IStiTickCustom = Stimulsoft.Report.Gauge.Primitives.IStiTickCustom;
    import StiCustomValuesCollection = Stimulsoft.Report.Gauge.Collections.StiCustomValuesCollection;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiRadialTickMarkCustom extends StiRadialTickMarkBase implements IStiTickCustom, IStiJsonReportObject {
        meta(): StiMeta[];
        clone(): StiRadialTickMarkCustom;
        valueObj: number;
        values: StiCustomValuesCollection;
        getValueEvent: StiEvent;
        onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _value;
        get value(): string;
        set value(value: string);
        get elementType(): StiGaugeElemenType;
        get localizeName(): string;
        prepareGaugeElement(): void;
        drawElement(context: StiGaugeContextPainter): void;
        private getOffsetAngle;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiRadialTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickMarkBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiRadialTickMarkMajor extends StiRadialTickMarkBase {
        meta(): StiMeta[];
        applyStyle(style: IStiGaugeStyle): void;
        get elementType(): StiGaugeElemenType;
        get localizeName(): string;
        getPointCollection(): Hashtable;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiRadialTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickMarkBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiRadialTickMarkMinor extends StiRadialTickMarkBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        applyStyle(style: IStiGaugeStyle): void;
        private _skipMajorValues;
        get skipMajorValues(): boolean;
        set skipMajorValues(value: boolean);
        get isSkipMajorValues(): boolean;
        get elementType(): StiGaugeElemenType;
        get localizeName(): string;
        getPointCollection(): Hashtable;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBarRangeListType = Stimulsoft.Report.Gauge.StiBarRangeListType;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiIndicatorRangeInfo = Stimulsoft.Report.Components.Gauge.IStiIndicatorRangeInfo;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiIndicatorRangeInfo implements ICloneable, IStiIndicatorRangeInfo, IStiJsonReportObject {
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xmlNode: XmlNode, report: StiReport): void;
        get propName(): string;
        clone(): any;
        private _value;
        get value(): number;
        set value(value: number);
        get rangeListType(): StiBarRangeListType;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBarRangeListType = Stimulsoft.Report.Gauge.StiBarRangeListType;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiLinearIndicatorRangeInfo extends StiIndicatorRangeInfo implements IStiJsonReportObject {
        meta(): StiMeta[];
        private _color;
        get color(): Color;
        set color(value: Color);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        get rangeListType(): StiBarRangeListType;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiBarBase = Stimulsoft.Report.Components.Gauge.Primitives.StiBarBase;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiRadialBar extends StiBarBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        applyStyle(style: IStiGaugeStyle): void;
        private actualBush;
        private colorModeHelper;
        get elementType(): StiGaugeElemenType;
        get barType(): Stimulsoft.Report.Gauge.StiBarRangeListType;
        get localizeName(): string;
        checkActualBrushForTopGeometry(): void;
        drawElement(context: StiGaugeContextPainter): void;
        onRangeColorChanged(): void;
        interactiveClick(rect: Rectangle, p: Point): void;
        private getRangeGeometry;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBarRangeListType = Stimulsoft.Report.Gauge.StiBarRangeListType;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRadialIndicatorRangeInfo extends StiIndicatorRangeInfo implements IStiJsonReportObject {
        meta(): StiMeta[];
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        get rangeListType(): StiBarRangeListType;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiMarkerBase = Stimulsoft.Report.Components.Gauge.Primitives.StiMarkerBase;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiRadialMarker extends StiMarkerBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        applyStyle(style: IStiGaugeStyle): void;
        get elementType(): StiGaugeElemenType;
        get localizeName(): string;
        drawElement(context: StiGaugeContextPainter): void;
        interactiveClick(rect: Rectangle, p: Point): void;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiFilterCollection = Stimulsoft.Report.Gauge.Collections.StiFilterCollection;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiIndicatorBase = Stimulsoft.Report.Components.Gauge.Primitives.StiIndicatorBase;
    import IStiGaugeMarker = Stimulsoft.Report.Gauge.IStiGaugeMarker;
    class StiStateIndicator extends StiIndicatorBase implements IStiGaugeMarker, IStiJsonReportObject {
        meta(): StiMeta[];
        private lastFilter;
        private _format;
        get format(): string;
        set format(value: string);
        private _showValue;
        get showValue(): boolean;
        set showValue(value: boolean);
        private _textBrush;
        get textBrush(): StiBrush;
        set textBrush(value: StiBrush);
        private _font;
        get font(): Font;
        set font(value: Font);
        get elementType(): Stimulsoft.Report.Gauge.StiGaugeElemenType;
        get localizeName(): string;
        filters: StiFilterCollection;
        private _left;
        get left(): number;
        set left(value: number);
        private _top;
        get top(): number;
        set top(value: number);
        private _relativeWidth;
        get relativeWidth(): number;
        set relativeWidth(value: number);
        private _relativeHeight;
        get relativeHeight(): number;
        set relativeHeight(value: number);
        private _skin;
        get skin(): Stimulsoft.Report.Gauge.StiStateSkin;
        set skin(value: Stimulsoft.Report.Gauge.StiStateSkin);
        private _customSkin;
        get customSkin(): Stimulsoft.Report.Gauge.StiGaugeElementSkin;
        set customSkin(value: Stimulsoft.Report.Gauge.StiGaugeElementSkin);
        onValueChanged(): void;
        interactiveClick(rect: Rectangle, p: Point): void;
        drawElement(context: StiGaugeContextPainter): void;
        getActualSkin(): Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    }
}
export namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import IStiRangeBase = Stimulsoft.Report.Components.Gauge.IStiRangeBase;
    class StiRangeBase implements ICloneable, IStiRangeBase, IStiJsonReportObject {
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        get propName(): string;
        clone(): StiRangeBase;
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _borderBrush;
        get borderBrush(): StiBrush;
        set borderBrush(value: StiBrush);
        private _borderWidth;
        get borderWidth(): number;
        set borderWidth(value: number);
        private _startValue;
        get startValue(): number;
        set startValue(value: number);
        private _endValue;
        get endValue(): number;
        set endValue(value: number);
        private _startWidth;
        get startWidth(): number;
        set startWidth(value: number);
        private _endWidth;
        get endWidth(): number;
        set endWidth(value: number);
        private _placement;
        get placement(): StiPlacement;
        set placement(value: StiPlacement);
        private _offset;
        get offset(): number;
        set offset(value: number);
        rangeList: StiScaleRangeList;
        get localizeName(): string;
        drawRange(context: StiGaugeContextPainter, scale: StiScaleBase): void;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiRangeBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRangeBase;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    class StiLinearRange extends StiRangeBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        drawRange(context: StiGaugeContextPainter, scale: StiScaleBase): void;
        get localizeName(): string;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    import StiRangeBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRangeBase;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiRadialRange extends StiRangeBase implements IStiJsonReportObject {
        meta(): StiMeta[];
        useValuesFromTheSpecifiedRange: boolean;
        get localizeName(): string;
        drawRange(context: StiGaugeContextPainter, scale: StiScaleBase): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Collections {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiRangeBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRangeBase;
    import StiScaleRangeList = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleRangeList;
    class StiRangeCollection extends CollectionBase<StiRangeBase> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): any;
        private parent;
        clone(): StiRangeCollection;
        get isReadOnly(): boolean;
        setByIndex(index: number, value: StiRangeBase): void;
        setParent(element: StiRangeBase): void;
        clearParent(element: StiRangeBase): void;
        add(element: StiRangeBase): void;
        insert(index: number, element: StiRangeBase): void;
        remove(element: StiRangeBase): boolean;
        copyTo(elements: StiRangeBase[], arrayIndex: number): void;
        moveUp(element: StiRangeBase): boolean;
        moveDown(element: StiRangeBase): boolean;
        constructor(parent: StiScaleRangeList);
    }
}
export namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiRangeCollection = Stimulsoft.Report.Gauge.Collections.StiRangeCollection;
    class StiScaleRangeList extends StiGaugeElement implements IStiJsonReportObject {
        meta(): StiMeta[];
        clone(): StiScaleRangeList;
        ranges: StiRangeCollection;
        constructor();
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiScaleRangeList = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleRangeList;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiLinearRangeList extends StiScaleRangeList implements IStiJsonReportObject {
        meta(): StiMeta[];
        drawElement(context: StiGaugeContextPainter): void;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiScaleRangeList = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleRangeList;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiRadialRangeList extends StiScaleRangeList implements IStiJsonReportObject {
        meta(): StiMeta[];
        get elementType(): StiGaugeElemenType;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Helpers {
    import IStiScaleBase = Stimulsoft.Report.Components.Gauge.IStiScaleBase;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    class StiGaugeHelper {
        static globalDurationElement: TimeSpan;
        static globalBeginTimeElement: TimeSpan;
        private static currentCulture;
        static getFloatValueFromObject(valueObj: any, scale: IStiScaleBase): number;
        static getFloatValueFromObject2(valueObj: any, defaultValue: number): number;
        static getFloatArrayValueFromString(value: any): number[];
        private static initializeGauge;
        private static initializeName;
        static checkGaugeName(gauge: StiGauge): void;
        static simpleRadialGauge(gauge: StiGauge, report: StiReport): void;
        static radialTwoScalesGauge(gauge: StiGauge, report: StiReport): void;
        static radialBarGauge(gauge: StiGauge, report: StiReport): void;
        static simpleTwoBarGauge(gauge: StiGauge, report: StiReport): void;
        static defaultRadialGauge(gauge: StiGauge, report: StiReport): void;
        static defaultLinearGauge(gauge: StiGauge, report: StiReport): void;
        static linearGaugeRangeList(gauge: StiGauge, report: StiReport): void;
        static bulletGraphsGreen(gauge: StiGauge, report: StiReport): void;
        static halfDonutsGauge(gauge: StiGauge, report: StiReport): void;
        static halfDonutsGauge2(gauge: StiGauge, report: StiReport): void;
        static radialGaugeHalfCircleN(gauge: StiGauge, report: StiReport): void;
        static radialGaugeHalfCircleS(gauge: StiGauge, report: StiReport): void;
        static radialGaugeQuarterCircleNW(gauge: StiGauge, report: StiReport): void;
        static radialGaugeQuarterCircleNE(gauge: StiGauge, report: StiReport): void;
        static radialGaugeQuarterCircleSW(gauge: StiGauge, report: StiReport): void;
        static radialGaugeQuarterCircleSE(gauge: StiGauge, report: StiReport): void;
        private static radialGaugeQuarterCircle;
        static horizontalThermometer(gauge: StiGauge, report: StiReport): void;
        static verticalThermometer(gauge: StiGauge, report: StiReport): void;
        static lightSpeedometer(gauge: StiGauge, report: StiReport): void;
        static darkSpeedometer(gauge: StiGauge, report: StiReport): void;
    }
}
export namespace Stimulsoft.Report.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetTextEventArgs = Stimulsoft.Report.Gauge.Events.StiGetTextEventArgs;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiCustomValuesCollection = Stimulsoft.Report.Gauge.Collections.StiCustomValuesCollection;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiLinearTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickLabelBase;
    import IStiTickCustom = Stimulsoft.Report.Gauge.Primitives.IStiTickCustom;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiLinearTickLabelCustom extends StiLinearTickLabelBase implements IStiTickCustom, IStiJsonReportObject {
        meta(): StiMeta[];
        clone(): StiLinearTickLabelCustom;
        private _valueObj;
        get valueObj(): number;
        set valueObj(value: number);
        private _textObj;
        get textObj(): string;
        set textObj(value: string);
        values: StiCustomValuesCollection;
        get localizeName(): string;
        getValueEvent: StiEvent;
        onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        getTextEvent: StiEvent;
        onGetText(e: StiGetTextEventArgs): void;
        invokeGetText(sender: StiGaugeElement, e: StiGetTextEventArgs): void;
        private _value;
        get value(): string;
        set value(value: string);
        private _text;
        get text(): string;
        set text(value: string);
        prepareGaugeElement(): void;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
export namespace Stimulsoft.Report.Gauge.Collections {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    class StiGaugeElementCollection extends CollectionBase<StiGaugeElement> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, report: StiReport): void;
        private scale;
        private scaleType;
        clone(): StiGaugeElementCollection;
        get isReadOnly(): boolean;
        setByIndex(index: number, value: StiGaugeElement): void;
        toArray(): StiGaugeElement[];
        private addCore;
        add(element: StiGaugeElement): void;
        addRange(elements: StiGaugeElement[]): void;
        insert(index: number, element: StiGaugeElement): void;
        remove(element: StiGaugeElement): boolean;
        copyTo(elements: StiGaugeElement[], arrayIndex: number): void;
        private setItemInternal;
        moveUp(element: StiGaugeElement): boolean;
        moveDown(element: StiGaugeElement): boolean;
        constructor(scale: StiScaleBase);
    }
}
export namespace Stimulsoft.Report.Gauge.Events {
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiGetValueEventArgs extends EventArgs {
        value: any;
    }
}
export namespace Stimulsoft.Report.Gauge.Helpers {
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiDrawingHelper {
        static getRoundedPath(rect: Rectangle, offset: number, leftTop: number, rightTop: number, rightBottom: number, leftBottom: number): void;
        private static PiDiv180;
        private static FourDivThree;
        static getArcGeometry(rect: Rectangle, startAngle: number, sweepAngle: number, startWidth: number, endWidth: number): void;
        static getRadialRangeGeometry(centerPoint: Point, startAngle: number, sweepAngle: number, radius1: number, radius2: number, radius3: number, radius4: number): void;
        private static round;
        private static convertArcToCubicBezier;
        private static convertArcToCubicBezier2;
    }
}
export namespace Stimulsoft.Report.Gauge.Helpers {
    import IStiGauge = Stimulsoft.Report.Components.Gauge.IStiGauge;
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    class StiGaugeInitHelper {
        static isGaugeV2(gauge: IStiGauge): boolean;
        static init(gauge: StiGauge, type: StiGaugeType, skipText?: boolean): any;
        static prepare(gauge: IStiGauge): void;
        private static isFullCircularScale;
        private static createFullCircularScale;
        private static isHalfCircularScale;
        private static createHalfCircularScale;
        private static isLinearScale;
        private static createLinearScale;
        private static isBulletScale;
        private static createBullet;
        private static addLinearRanges;
    }
}
export namespace Stimulsoft.Report.Gauge.Primitives {
    import StiGraphicsPathLinesGaugeGeom = Stimulsoft.Report.Gauge.GaugeGeoms.StiGraphicsPathLinesGaugeGeom;
    import Size = Stimulsoft.System.Drawing.Size;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    let IStiScaleBarGeometry: System.Interface<IStiScaleBarGeometry>;
    interface IStiScaleBarGeometry {
        size: Size;
        rectGeometry: Rectangle;
        center: Point;
        radius: number;
        diameter: number;
        checkRectGeometry(rect: Rectangle): void;
        drawScaleGeometry(context: StiGaugeContextPainter): void;
        getRestToLenght(): number;
        drawGeometry(context: StiGaugeContextPainter, startValue: number, endValue: number, startWidth: number, endWidth: number, offset: number, placement: StiPlacement, REFrect: any, returnOnlyRect: boolean): StiGraphicsPathLinesGaugeGeom;
    }
}
export namespace Stimulsoft.Report.Gauge.Primitives {
    import StiCustomValuesCollection = Stimulsoft.Report.Gauge.Collections.StiCustomValuesCollection;
    let IStiTickCustom: System.Interface<IStiTickCustom>;
    interface IStiTickCustom {
        valueObj: number;
        values: StiCustomValuesCollection;
    }
}
export namespace Stimulsoft.Report.Gauge {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiEmptyBrush = Stimulsoft.Base.Drawing.StiEmptyBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiGaugeStyleCoreXF24 extends StiGaugeStyleCoreXF {
        get localizedName(): string;
        brush: StiSolidBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        targetColor: Color;
        tickMarkMajorBrush: StiSolidBrush;
        tickMarkMajorBorder: StiEmptyBrush;
        tickMarkMinorBrush: StiSolidBrush;
        tickMarkMinorBorder: StiEmptyBrush;
        tickLabelMajorTextBrush: StiSolidBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiSolidBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiSolidBrush;
        linearScaleBrush: StiSolidBrush;
        linearBarBrush: StiSolidBrush;
        linearBarBorderBrush: StiEmptyBrush;
        linearBarEmptyBrush: StiEmptyBrush;
        linearBarEmptyBorderBrush: StiEmptyBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiSolidBrush;
        radialBarBorderBrush: StiEmptyBrush;
        radialBarEmptyBrush: StiSolidBrush;
        radialBarEmptyBorderBrush: StiEmptyBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiSolidBrush;
        needleBorderBrush: StiEmptyBrush;
        needleCapBrush: StiSolidBrush;
        needleCapBorderBrush: StiSolidBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
export namespace Stimulsoft.Report.Gauge {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiEmptyBrush = Stimulsoft.Base.Drawing.StiEmptyBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiGaugeStyleCoreXF26 extends StiGaugeStyleCoreXF {
        get localizedName(): string;
        brush: StiSolidBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        targetColor: Color;
        tickMarkMajorBrush: StiSolidBrush;
        tickMarkMajorBorder: StiEmptyBrush;
        tickMarkMinorBrush: StiSolidBrush;
        tickMarkMinorBorder: StiEmptyBrush;
        tickLabelMajorTextBrush: StiSolidBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiSolidBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiSolidBrush;
        linearScaleBrush: StiSolidBrush;
        linearBarBrush: StiSolidBrush;
        linearBarBorderBrush: StiEmptyBrush;
        linearBarEmptyBrush: StiEmptyBrush;
        linearBarEmptyBorderBrush: StiEmptyBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiSolidBrush;
        radialBarBorderBrush: StiEmptyBrush;
        radialBarEmptyBrush: StiSolidBrush;
        radialBarEmptyBorderBrush: StiEmptyBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiSolidBrush;
        needleBorderBrush: StiEmptyBrush;
        needleCapBrush: StiSolidBrush;
        needleCapBorderBrush: StiSolidBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
export namespace Stimulsoft.Report.Gauge {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiEmptyBrush = Stimulsoft.Base.Drawing.StiEmptyBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiGaugeStyleCoreXF27 extends StiGaugeStyleCoreXF {
        get localizedName(): string;
        brush: StiSolidBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        targetColor: Color;
        tickMarkMajorBrush: StiEmptyBrush;
        tickMarkMajorBorder: StiEmptyBrush;
        tickMarkMinorBrush: StiEmptyBrush;
        tickMarkMinorBorder: StiEmptyBrush;
        tickLabelMajorTextBrush: StiSolidBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiSolidBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiSolidBrush;
        linearScaleBrush: StiSolidBrush;
        linearBarBrush: StiSolidBrush;
        linearBarBorderBrush: StiEmptyBrush;
        linearBarEmptyBrush: StiEmptyBrush;
        linearBarEmptyBorderBrush: StiEmptyBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiSolidBrush;
        radialBarBorderBrush: StiEmptyBrush;
        radialBarEmptyBrush: StiSolidBrush;
        radialBarEmptyBorderBrush: StiEmptyBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiSolidBrush;
        needleBorderBrush: StiEmptyBrush;
        needleCapBrush: StiSolidBrush;
        needleCapBorderBrush: StiSolidBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
export namespace Stimulsoft.Report.Gauge {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiEmptyBrush = Stimulsoft.Base.Drawing.StiEmptyBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiGaugeStyleCoreXF28 extends StiGaugeStyleCoreXF {
        get localizedName(): string;
        brush: StiSolidBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        targetColor: Color;
        tickMarkMajorBrush: StiEmptyBrush;
        tickMarkMajorBorder: StiEmptyBrush;
        tickMarkMinorBrush: StiEmptyBrush;
        tickMarkMinorBorder: StiEmptyBrush;
        tickLabelMajorTextBrush: StiSolidBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiSolidBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiSolidBrush;
        linearScaleBrush: StiSolidBrush;
        linearBarBrush: StiSolidBrush;
        linearBarBorderBrush: StiEmptyBrush;
        linearBarEmptyBrush: StiEmptyBrush;
        linearBarEmptyBorderBrush: StiEmptyBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiSolidBrush;
        radialBarBorderBrush: StiEmptyBrush;
        radialBarEmptyBrush: StiSolidBrush;
        radialBarEmptyBorderBrush: StiEmptyBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiSolidBrush;
        needleBorderBrush: StiEmptyBrush;
        needleCapBrush: StiSolidBrush;
        needleCapBorderBrush: StiSolidBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
export namespace Stimulsoft.Report.Gauge {
    import Font = Stimulsoft.System.Drawing.Font;
    import StiEmptyBrush = Stimulsoft.Base.Drawing.StiEmptyBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiGaugeStyleCoreXF29 extends StiGaugeStyleCoreXF {
        get localizedName(): string;
        brush: StiSolidBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        targetColor: Color;
        tickMarkMajorBrush: StiSolidBrush;
        tickMarkMajorBorder: StiEmptyBrush;
        tickMarkMinorBrush: StiSolidBrush;
        tickMarkMinorBorder: StiEmptyBrush;
        tickLabelMajorTextBrush: StiSolidBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiSolidBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiSolidBrush;
        linearMarkerBorder: StiSolidBrush;
        linearScaleBrush: StiSolidBrush;
        linearBarBrush: StiSolidBrush;
        linearBarBorderBrush: StiEmptyBrush;
        linearBarEmptyBrush: StiEmptyBrush;
        linearBarEmptyBorderBrush: StiEmptyBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiSolidBrush;
        radialBarBorderBrush: StiEmptyBrush;
        radialBarEmptyBrush: StiSolidBrush;
        radialBarEmptyBorderBrush: StiEmptyBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiSolidBrush;
        needleBorderBrush: StiEmptyBrush;
        needleCapBrush: StiSolidBrush;
        needleCapBorderBrush: StiSolidBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
export namespace Stimulsoft.Report.Gauge {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiGaugeStyleCoreXF = Stimulsoft.Report.Gauge.StiGaugeStyleCoreXF;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiGaugeStyleCoreXF30 extends StiGaugeStyleCoreXF {
        get localizedName(): string;
        brush: StiBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        targetColor: Color;
        tickMarkMajorBrush: StiBrush;
        tickMarkMajorBorder: StiBrush;
        tickMarkMinorBrush: StiBrush;
        tickMarkMinorBorder: StiBrush;
        tickLabelMajorTextBrush: StiBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiBrush;
        linearMarkerBorder: StiBrush;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        linearBarBorderBrush: StiBrush;
        linearBarEmptyBrush: StiBrush;
        linearBarEmptyBorderBrush: StiBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiBrush;
        radialBarBorderBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
        radialBarEmptyBorderBrush: StiBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiGaugeStyleCoreXF30 = Stimulsoft.Report.Gauge.StiGaugeStyleCoreXF30;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiGaugeStyleCoreXF31 extends StiGaugeStyleCoreXF30 {
        get localizedName(): string;
        brush: StiBrush;
        targetColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        markerBrush: StiBrush;
        linearMarkerBorder: StiBrush;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        radialBarBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiGaugeStyleCoreXF30 = Stimulsoft.Report.Gauge.StiGaugeStyleCoreXF30;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiGaugeStyleCoreXF32 extends StiGaugeStyleCoreXF30 {
        get localizedName(): string;
        brush: StiBrush;
        targetColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        markerBrush: StiBrush;
        linearMarkerBorder: StiBrush;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        needleCapBorderWidth: number;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        radialBarBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiGaugeStyleCoreXF30 = Stimulsoft.Report.Gauge.StiGaugeStyleCoreXF30;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGaugeStyleCoreXF33 extends StiGaugeStyleCoreXF30 {
        get localizedName(): string;
        brush: StiBrush;
        targetColor: Color;
        foreColor: Color;
        tickMarkMajorBrush: StiBrush;
        tickMarkMajorBorder: StiBrush;
        tickMarkMinorBrush: StiBrush;
        tickMarkMinorBorder: StiBrush;
        tickLabelMajorTextBrush: StiBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiBrush;
        linearMarkerBorder: StiBrush;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        needleCapBorderWidth: number;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        radialBarBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGaugeStyleCoreXF34 extends StiGaugeStyleCoreXF {
        get localizedName(): string;
        brush: StiBrush;
        borderColor: Color;
        borderWidth: number;
        targetColor: Color;
        foreColor: Color;
        tickMarkMajorBrush: StiBrush;
        tickMarkMajorBorder: StiBrush;
        tickMarkMinorBrush: StiBrush;
        tickMarkMinorBorder: StiBrush;
        tickLabelMajorTextBrush: StiBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiBrush;
        linearMarkerBorder: StiBrush;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        linearBarBorderBrush: StiBrush;
        linearBarEmptyBrush: StiBrush;
        linearBarEmptyBorderBrush: StiBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiBrush;
        radialBarBorderBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
        radialBarEmptyBorderBrush: StiBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiEmptyBrush = Stimulsoft.Base.Drawing.StiEmptyBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGaugeStyleCoreXF35 extends StiGaugeStyleCoreXF {
        get localizedName(): string;
        brush: StiSolidBrush;
        borderColor: Color;
        foreColor: Color;
        borderWidth: number;
        targetColor: Color;
        tickMarkMajorBrush: StiSolidBrush;
        tickMarkMajorBorder: StiEmptyBrush;
        tickMarkMinorBrush: StiEmptyBrush;
        tickMarkMinorBorder: StiEmptyBrush;
        tickLabelMajorTextBrush: StiSolidBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiSolidBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiSolidBrush;
        linearMarkerBorder: StiSolidBrush;
        linearScaleBrush: StiSolidBrush;
        linearBarBrush: StiSolidBrush;
        linearBarBorderBrush: StiEmptyBrush;
        linearBarEmptyBrush: StiEmptyBrush;
        linearBarEmptyBorderBrush: StiEmptyBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiSolidBrush;
        radialBarBorderBrush: StiEmptyBrush;
        radialBarEmptyBrush: StiSolidBrush;
        radialBarEmptyBorderBrush: StiEmptyBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiSolidBrush;
        needleBorderBrush: StiEmptyBrush;
        needleCapBrush: StiSolidBrush;
        needleCapBorderBrush: StiSolidBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiEmptyBrush = Stimulsoft.Base.Drawing.StiEmptyBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGaugeStyleCoreXF36 extends StiGaugeStyleCoreXF {
        get localizedName(): string;
        brush: StiBrush;
        borderColor: Color;
        foreColor: Color;
        borderWidth: number;
        targetColor: Color;
        tickMarkMajorBrush: StiSolidBrush;
        tickMarkMajorBorder: StiEmptyBrush;
        tickMarkMinorBrush: StiSolidBrush;
        tickMarkMinorBorder: StiEmptyBrush;
        tickLabelMajorTextBrush: StiSolidBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiSolidBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiSolidBrush;
        linearMarkerBorder: StiSolidBrush;
        linearScaleBrush: StiSolidBrush;
        linearBarBrush: StiSolidBrush;
        linearBarBorderBrush: StiEmptyBrush;
        linearBarEmptyBrush: StiEmptyBrush;
        linearBarEmptyBorderBrush: StiEmptyBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiSolidBrush;
        radialBarBorderBrush: StiEmptyBrush;
        radialBarEmptyBrush: StiSolidBrush;
        radialBarEmptyBorderBrush: StiEmptyBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiSolidBrush;
        needleBorderBrush: StiEmptyBrush;
        needleCapBrush: StiSolidBrush;
        needleCapBorderBrush: StiSolidBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiGaugeStyleCoreXF37 extends StiGaugeStyleCoreXF36 {
        private static constForeColor;
        private static constTrackColor;
        get localizedName(): string;
        brush: StiBrush;
        foreColor: System.Drawing.Color;
        targetColor: System.Drawing.Color;
        markerBrush: StiSolidBrush;
        linearMarkerBorder: StiSolidBrush;
        linearScaleBrush: StiSolidBrush;
        linearBarBrush: StiSolidBrush;
        radialBarBrush: StiSolidBrush;
        radialBarEmptyBrush: StiSolidBrush;
        needleBrush: StiSolidBrush;
        needleCapBrush: StiSolidBrush;
        needleCapBorderBrush: StiSolidBrush;
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF24 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        constructor();
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF25 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        constructor();
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF28 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        constructor();
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF29 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        constructor();
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF30 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        constructor();
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF31 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        constructor();
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF32 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        constructor();
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF33 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        constructor();
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF34 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        constructor();
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF35 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        constructor();
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF36 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        constructor();
    }
}
export namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF37 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        constructor();
    }
}
export namespace Stimulsoft.Blockly.Model {
    enum EscapeMode {
        None = 0,
        Break = 1,
        Continue = 2
    }
}
export namespace Stimulsoft.Blockly.Model {
    import List = Stimulsoft.System.Collections.List;
    class ListExt extends List<any> {
        static evaluate<T = any>(values: List<Value>, name: string, context: Context): T;
        static evaluateAsync<T = any>(values: List<Value>, name: string, context: Context): Promise<T>;
        static get(fields: List<Field>, name: string): string;
        static get2(statements: List<Statement>, name: string): Statement;
        static getValue(mutations: List<Mutation>, name: string, domain?: string): string;
        static average(list: List<number>): number;
    }
}
export namespace Stimulsoft.Blockly.Model {
    import IAsIs = Stimulsoft.System.IAsIs;
    import Field = Stimulsoft.Blockly.Model.Field;
    import Statement = Stimulsoft.Blockly.Model.Statement;
    import Mutation = Stimulsoft.Blockly.Model.Mutation;
    import Context = Stimulsoft.Blockly.Model.Context;
    import List = Stimulsoft.System.Collections.List;
    class IronBlock implements IFragment, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        id: string;
        fields: List<Field>;
        values: List<Value>;
        statements: List<Statement>;
        type: string;
        inline: boolean;
        next: IronBlock;
        mutations: List<Mutation>;
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
        constructor();
    }
}
export namespace Stimulsoft.Blockly.Blocks.Maths {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class MathRandomInt extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Model {
    class Field {
        name: string;
        value: string;
    }
}
export namespace Stimulsoft.Blockly.Model {
    class Mutation {
        domain: string;
        name: string;
        value: string;
        constructor(domain: string, name: string, value: string);
    }
}
export namespace Stimulsoft.Blockly.Model {
    import Context = Stimulsoft.Blockly.Model.Context;
    class Value implements IFragment {
        implements(): any[];
        name: string;
        block: IronBlock;
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Text {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class TextPrint extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Text {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class TextBlock extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Text {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class TextAppend extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Text {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class TextIndexOf extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Text {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class TextCaseChange extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Text {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class TextTrim extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Text {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class TextLength extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Text {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class TextJoin extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Text {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class TextIsEmpty extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Text {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class ColourRgb extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
        private evaluateInner;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Text {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class ColourRandom extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Text {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class ColourBlend extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
        private evaluateInner;
        rgbToHex(r: number, g: number, b: number): string;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Text {
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    import Context = Stimulsoft.Blockly.Model.Context;
    class ColourPicker extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Controls {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class ControlsFor extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Controls {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class ControlsIf extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Controls {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class ControlsForEach extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Controls {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class ControlsWhileUntil extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Controls {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class ControlsFlowStatement extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Controls {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class ControlsRepeatExt extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Model {
    import Context = Stimulsoft.Blockly.Model.Context;
    class Statement implements IFragment {
        implements(): any[];
        name: string;
        block: IronBlock;
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Procedures {
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    import Context = Stimulsoft.Blockly.Model.Context;
    class ProceduresDef extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
        findEndOfChain(block: IronBlock): IronBlock;
    }
}
export namespace Stimulsoft.Blockly.Model {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    import StiReport = Stimulsoft.Report.StiReport;
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class Context {
        variables: Dictionary<string, any>;
        functions: Dictionary<string, any>;
        escapeMode: EscapeMode;
        parent: Context;
        report: StiReport;
        sender: any;
        event: StiEvent;
        eventArgs: EventArgs;
        constructor();
    }
}
export namespace Stimulsoft.Blockly.Blocks.Procedures {
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    import Context = Stimulsoft.Blockly.Model.Context;
    class ProceduresCallNoReturn extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Procedures {
    import ProceduresCallNoReturn = Stimulsoft.Blockly.Blocks.Procedures.ProceduresCallNoReturn;
    import Context = Stimulsoft.Blockly.Model.Context;
    class ProceduresCallReturn extends ProceduresCallNoReturn {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Procedures {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class ProceduresIfReturn extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Logic {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class LogicCompare extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
        private compare;
        compareString(op: string, a: string, b: string): boolean;
        compareNumber(op: string, a: number, b: number): boolean;
        compareBool(op: string, a: boolean, b: boolean): boolean;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Logic {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class LogicBoolean extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Logic {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class LogicNull extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Logic {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class LogicTernary extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Logic {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class LogicNegate extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Logic {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class LogicOperation extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
        private evaluateInner;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Lists {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class ListsSplit extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
        private evaluateInner;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Lists {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class ListsIndexOf extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Lists {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class ListsGetIndex extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Lists {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class ListsCreateWith extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Lists {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class ListsLength extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Lists {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class ListsRepeat extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Lists {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class ListsIsEmpty extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Maths {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class MathArithmetic extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
        private evaluateInner;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Maths {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class MathNumber extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Maths {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class MathSingle extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
        private evaluateInner;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Maths {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class MathRound extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
        private evaluateInner;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Maths {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class MathRandomFloat extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Maths {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class MathModulo extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Maths {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class MathConstrain extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Maths {
    import List = Stimulsoft.System.Collections.List;
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class MathOnList extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
        private evaluateInner;
        median(values: List<any>): any;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Maths {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class MathConstant extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
        getValue(constant: string): number;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Maths {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class MathNumberProperty extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
        private evaluateInner;
        isPrime(number: number): boolean;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Variables {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class VariablesGet extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Variables {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class VariablesSet extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Visuals {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiColorHex extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Visuals {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiColorARGB extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Visuals {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiNewFont extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Visuals {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiNewSolidBrush extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Visuals {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiNewGradientBrush extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Visuals {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiNewBorder extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Visuals {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiNewBrush extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Visuals {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiNewPenStyle extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Visuals {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiNewMargin extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Visuals {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiNewPadding extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Visuals {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiNewCornerRadius extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Data {
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    import Context = Stimulsoft.Blockly.Model.Context;
    class StiGetDataSource extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Data {
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    import Context = Stimulsoft.Blockly.Model.Context;
    class StiDataSourceGetData extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Data {
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    import Context = Stimulsoft.Blockly.Model.Context;
    class StiGetDataSourceByName extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Data {
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    import Context = Stimulsoft.Blockly.Model.Context;
    class StiDataSourceProperty extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Data {
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    import Context = Stimulsoft.Blockly.Model.Context;
    class StiDataSourceMethod extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Data {
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    import Context = Stimulsoft.Blockly.Model.Context;
    class StiSetDataSourceSqlCommand extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Data {
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    import Context = Stimulsoft.Blockly.Model.Context;
    class StiDataSourceGetDataByColumnName extends IronBlock {
        evaluate(context: Context): any;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Variables {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiGetVariable extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Variables {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiGetVariableByName extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Variables {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiSetVariable extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Variables {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiSystemVariable extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Objects {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiGetCurrentValue extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Report {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiThisComponent extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Report {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiThisReport extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Report {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiAllComponents extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Report {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiAllComponentsFrom extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
        private getComponent;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Objects {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiSetCurrentValue extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Objects {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiGetComponent extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Objects {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiGetComponentByName extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Objects {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiSetPropertyOfObjectTo extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
        private setValue;
        checkPropertyName(obj: any, propertyName: string): string;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Objects {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiGetPropertyOfObject extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
        private getValue;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Objects {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiGetStyleByName extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.System {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiIsFirstPass extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.System {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiIsSecondPass extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Functions {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiFunctionRun extends IronBlock {
        evaluateAsync(context: Context): Promise<any>;
        evaluate(context: Context): any;
        private evaluateFunction;
        private evaluateUserFunction;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Functions {
    import StiFunction = Stimulsoft.Report.Dictionary.StiFunction;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiUserFunction = Stimulsoft.Report.Dictionary.StiUserFunction;
    import StiUserFunctionsCollection = Stimulsoft.Report.Dictionary.StiUserFunctionsCollection;
    class StiBlocklyFunctionBlockKeyCache {
        static cache: Hashtable;
        static createKey(funct: StiFunction): string;
        static createKey2(userFunction: StiUserFunction): string;
        static getFunction(key: string): StiFunction;
        private static fillCache;
        static getBlockKeyTable(userFunctions: StiUserFunctionsCollection): Hashtable;
        static getFunction2(key: string, userFunctions: StiUserFunctionsCollection): any;
        private static fillCache2;
        static getBlockKeyTable2(userFunctions: StiUserFunctionsCollection): Hashtable;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Process {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiOpenLink extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Process {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiRefreshViewer extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.Process {
    import Context = Stimulsoft.Blockly.Model.Context;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class StiResetAllFilters extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Model {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiReport = Stimulsoft.Report.StiReport;
    import List = Stimulsoft.System.Collections.List;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class Workspace implements IFragment {
        implements(): any[];
        constructor();
        blocks: List<IronBlock>;
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
        evaluate2(report: StiReport, sender: any, valueArg: EventArgs, args?: Dictionary<string, any>): any;
        evaluateAsync2(report: StiReport, sender: any, valueArg: EventArgs, args?: Dictionary<string, any>): Promise<any>;
        evaluate3(report: StiReport, sender: any, stiEvent: StiEvent, valueArg: EventArgs, args?: Dictionary<string, any>): any;
    }
}
export namespace Stimulsoft.Blockly {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Workspace = Stimulsoft.Blockly.Model.Workspace;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    import StiUserFunction = Stimulsoft.Report.Dictionary.StiUserFunction;
    import StiReport = Stimulsoft.Report.StiReport;
    class Parser {
        private blocks;
        addBlock<T extends IronBlock>(c: {
            new (): T;
        }, type: string): Parser;
        parse(xml: string, preserveWhitespace?: boolean): Workspace;
        parseBlock(node: XmlNode): IronBlock;
        parseField(fieldNode: XmlNode, block: IronBlock): void;
        parseValue(valueNode: XmlNode, block: IronBlock): void;
        parseStatement(statementNode: XmlNode, block: IronBlock): void;
        parseMutation(mutationNode: XmlNode, block: IronBlock): void;
        static addStandardBlocks(parser: Parser, report: StiReport): Parser;
        addUserFunctionBlocks(userFunction: StiUserFunction): Parser;
    }
}
export namespace Stimulsoft.Blockly {
    import EventArgs = Stimulsoft.System.EventArgs;
    import IStiBlocksParser = Stimulsoft.Base.Blocks.IStiBlocksParser;
    import IStiReport = Stimulsoft.Base.IStiReport;
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    class StiBlocksParser implements IStiBlocksParser {
        evaluate(report: IStiReport, sender: any, xml: string, args: EventArgs): void;
        evaluateAsync(report: IStiReport, sender: any, xml: string, args: EventArgs): Promise<void>;
        evaluateUserFunction(report: IStiReport, functionObj: object, argumentss: Dictionary<string, any>): any;
    }
}
export namespace Stimulsoft.Blockly {
    class StiObjConverter {
        static toDouble(obj: any): number;
        static getValue(obj: any): any;
    }
}
export namespace Stimulsoft.Blockly.Blocks.Procedures {
    import Context = Stimulsoft.Blockly.Model.Context;
    import Value = Stimulsoft.Blockly.Model.Value;
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    class ValueBlock extends IronBlock {
        value: Value;
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
        constructor(value: Value);
    }
}
export namespace Stimulsoft.Blockly.Model {
    import Context = Stimulsoft.Blockly.Model;
    let IFragment: System.Interface<Context.IFragment>;
    interface IFragment {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.Model {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    class ProcedureContext extends Context {
        parameters: Dictionary<string, any>;
        constructor();
    }
}
export namespace Stimulsoft.Blockly.Resources {
    class StiBlocklyResourcesHelper {
        static loadResourceFile(fileName: string): string;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.UserFunctions {
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    import Context = Stimulsoft.Blockly.Model.Context;
    class StiUserFunctionArgument extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Blockly.StiBlocks.UserFunctions {
    import IronBlock = Stimulsoft.Blockly.Model.IronBlock;
    import Context = Stimulsoft.Blockly.Model.Context;
    class StiUserFunctionReturn extends IronBlock {
        evaluate(context: Context): any;
        evaluateAsync(context: Context): Promise<any>;
    }
}
export namespace Stimulsoft.Reflection {
    class StiTypesHelper {
        static run(type?: Stimulsoft.System.Type, namespace?: string): void;
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesAfghanistan {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesAfrica {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesAlbania {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesAlgeria {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesAndorra {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesAngola {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesArgentina {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesArgentinaFD {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesArmenia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesAsia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesAustralia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesAustria {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesAzerbaijan {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesBelarus {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesBelgium {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesBenelux {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesBenin {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesBolivia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesBosniaAndHerzegovina {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesBotswana {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesBrazil {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesBulgaria {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesBurkinaFaso {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesBurundi {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesCameroon {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesCanada {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesCapeVerde {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesCentralAfricanRepublic {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesChad {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesChile {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesChina {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesColombia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesComoros {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesCroatia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesCyprus {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesCzechRepublic {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesDenmark {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesDjibouti {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesEU {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesEUWithUnitedKingdom {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesEcuador {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesEgypt {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesEquatorialGuinea {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesEritrea {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesEstonia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesEthiopia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesEurope {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesEuropeWithRussia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesFalklandIslands {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesFinland {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesFrance {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesFrance18Regions {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesFranceDepartments {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesGabon {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesGambia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesGeorgia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesGermany {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesGhana {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesGreece {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesGuinea {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesGuineaBissau {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesGuyana {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesHungary {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesIceland {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesIndia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesIndonesia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesIreland {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesIsrael {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesItaly {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesIvoryCoast {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesJapan {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesJapan_JA {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesKazakhstan {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesKenya {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesLatvia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesLesotho {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesLiberia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesLibya {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesLiechtenstein {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesLithuania {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesLuxembourg {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMacedonia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMadagascar {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMalawi {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMalaysia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMali {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMalta {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMauritania {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMauritius {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMexico {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMiddleEast {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMoldova {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMonaco {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMontenegro {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMorocco {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMozambique {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesNamibia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesNetherlands {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesNewZealand {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesNiger {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesNigeria {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesNorthAmerica {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesNorway {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesOceania {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesOman {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesParaguay {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesPeru {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesPhilippines {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesPoland {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesPortugal {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesPuertoRico {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesQatar {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesRepublicOfTheCongo {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesRomania {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesRussia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesRwanda {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSanMarino {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSaoTomeAndPrincipe {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSaudiArabia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesScandinavia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSenegal {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSerbia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSeychelles {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSierraLeone {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSlovakia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSlovenia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSomalia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSouthAfrica {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSouthAmerica {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSouthKorea {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSouthSudan {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSoutheastAsia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSpain {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSudan {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSuriname {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSwaziland {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSweden {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSwitzerland {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesTaiwan {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesTanzania {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesThailand {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesTogo {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesTunisia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesTurkey {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesUK {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesUKCountries {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesUSA {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesUSAAndCanada {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesUSAAndPuertoRico {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesUganda {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesUkraine {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesUruguay {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesVatican {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesVenezuela {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesVietnam {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesWorld {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesZambia {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapResourcesZimbabwe {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsArgentinaFD_ES {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsArgentina_ES {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsAsia_HE {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsAsia_JA {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsAsia_KO {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsAsia_RU {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsAsia_ZH {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsBrazil_ES {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsCanada_FR {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsChile_ES {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsChina_ZH {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsCzechRepublic_CS {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsFinland_FI {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsFinland_SE {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsFrance18Regions_FR {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsFranceDepartments_FR {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsFrance_FR {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsGermany_DE {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsIsrael_HE {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsItaly_IT {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsJapan_JA {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsMexico_ES {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsNetherlands_FY {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsNetherlands_NL {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsNorway_NO {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsPoland_PL {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsRussia_RU {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsSouthKorea_KO {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsSwitzerland_DE {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsSwitzerland_FR {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsSwitzerland_IT {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsSwitzerland_RO {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsUkraine_UK {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsWorld_CS {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsWorld_ES {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsWorld_FI {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsWorld_FR {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsWorld_FY {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsWorld_HE {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsWorld_IT {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsWorld_JA {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsWorld_KO {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsWorld_NL {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsWorld_NO {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsWorld_PL {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsWorld_RO {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsWorld_RU {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsWorld_SE {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsWorld_UK {
        static get(): {};
    }
}
export namespace Stimulsoft.Report.Maps {
    class StiMapLangsWorld_ZH {
        static get(): {};
    }
}
export namespace Stimulsoft.Dashboard {
    enum StiTextFormatState {
        None = 0,
        DecimalDigits = 1,
        DecimalSeparator = 2,
        GroupSeparator = 4,
        GroupSize = 8,
        PositivePattern = 16,
        NegativePattern = 32,
        CurrencySymbol = 64,
        PercentageSymbol = 128,
        Abbreviation = 256,
        NegativeInRed = 512
    }
    enum StiFilterCondition {
        EqualTo = 0,
        NotEqualTo = 1,
        GreaterThan = 2,
        GreaterThanOrEqualTo = 3,
        LessThan = 4,
        LessThanOrEqualTo = 5,
        Between = 6,
        NotBetween = 7,
        Containing = 8,
        NotContaining = 9,
        BeginningWith = 10,
        EndingWith = 11,
        IsNull = 12,
        IsNotNull = 13
    }
    enum StiFilterItem {
        Argument = 0,
        Value = 1,
        ValueEnd = 2,
        Expression = 3,
        ValueOpen = 4,
        ValueClose = 5,
        ValueLow = 6,
        ValueHigh = 7
    }
    enum StiFilterDataType {
        String = 0,
        Numeric = 1,
        DateTime = 2,
        Boolean = 3,
        Expression = 4
    }
}
export namespace Stimulsoft.Dashboard.Components {
    enum StiMeterIdent {
        ArgumentChartMeter = 1,
        SeriesChartMeter = 2,
        SortByChartMeter = 3,
        ValueChartMeter = 4,
        StartValueChartMeter = 5,
        EndValueChartMeter = 6,
        OpenValueChartMeter = 7,
        CloseValueChartMeter = 8,
        LowValueChartMeter = 9,
        HighValueChartMeter = 10,
        WeightChartMeter = 11,
        XChartMeter = 12,
        YChartMeter = 13,
        IndicatorValueChartMeter = 14,
        MaxGaugeMeter = 15,
        MinGaugeMeter = 16,
        SeriesGaugeMeter = 17,
        ValueGaugeMeter = 18,
        TargetGaugeMeter = 19,
        SeriesIndicatorMeter = 20,
        TargetIndicatorMeter = 21,
        ValueIndicatorMeter = 22,
        SeriesProgressMeter = 23,
        TargetProgressMeter = 24,
        ValueProgressMeter = 25,
        LatitudeMapMeter = 26,
        LongitudeMapMeter = 27,
        LocationMapMeter = 28,
        LocationValueMapMeter = 29,
        LocationColorMapMeter = 30,
        LocationArgumentMapMeter = 31,
        KeyMapMeter = 32,
        NameMapMeter = 33,
        ValueMapMeter = 34,
        GroupMapMeter = 35,
        ColorMapMeter = 36,
        ColorScaleColumn = 37,
        DataBarsColumn = 38,
        DimensionColumn = 39,
        IndicatorColumn = 40,
        MeasureColumn = 41,
        SparklinesColumn = 42,
        BubbleColumn = 43,
        ColorScaleCardsColumn = 44,
        DataBarsCardsColumn = 45,
        DimensionCardsColumn = 46,
        IndicatorCardsColumn = 47,
        MeasureCardsColumn = 48,
        SparklinesCardsColumn = 49,
        BubbleCardsColumn = 50,
        PivotColumn = 51,
        PivotRow = 52,
        PivotSummary = 53,
        NameListBoxMeter = 54,
        KeyListBoxMeter = 55,
        KeyTreeViewMeter = 56,
        KeyTreeViewBoxMeter = 57,
        NameComboBoxMeter = 58,
        KeyComboBoxMeter = 59,
        ValueDatePickerMeter = 60,
        ValueNumberBoxMeter = 61,
        TextMeter = 62,
        TextMeasureMeter = 63,
        ImageMeter = 64,
        WebContentMeter = 65
    }
}
export namespace Stimulsoft.Dashboard.Components {
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiApp = Stimulsoft.Base.IStiApp;
    import IStiDashboardWatermark = Stimulsoft.Report.Dashboard.IStiDashboardWatermark;
    import StiAdvancedWatermark = Stimulsoft.Base.Drawing.StiAdvancedWatermark;
    import StiSurfaceViewMode = Stimulsoft.Report.Components.StiSurfaceViewMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiMargins = Stimulsoft.Report.Components.StiMargins;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import IStiDashboard = Stimulsoft.Report.Dashboard.IStiDashboard;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiDashboardViewMode = Stimulsoft.Report.Components.StiDashboardViewMode;
    import StiDashboardContentAlignment = Stimulsoft.Report.Dashboard.StiDashboardContentAlignment;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiDashboard extends StiPage implements IStiDashboard, IStiDashboardWatermark, IStiJsonReportObject, IStiGlobalizationProvider {
        implements(): any[];
        clone(): any;
        meta(): StiMeta[];
        getMeters(nested?: boolean, group?: string): List<IStiMeter>;
        getElements(nested?: boolean, group?: string): List<IStiElement>;
        getUserFilters(element: IStiElement): List<StiDataFilterRule>;
        private getUserFilters3;
        getUnplacedElements(): List<IStiElement>;
        switchSurfaceViewMode(value: StiSurfaceViewMode): void;
        removeMobileSurface(): void;
        get isMobileSurfaceSelected(): boolean;
        get isDesktopSurfaceSelected(): boolean;
        fetchAllMeters(): List<IStiMeter>;
        getNestedPages(): List<StiPage>;
        get isEnabled(): boolean;
        isEnabledAsync(): Promise<boolean>;
        get isDefined(): boolean;
        get isQuerable(): boolean;
        backColor: Color;
        retrieveUsedDataNames(group: string): List<string>;
        getDictionary(): IStiAppDictionary;
        getDataSources(dataNames: List<string>): List<IStiAppDataSource>;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        get serviceCategory(): string;
        get localizedName(): string;
        margins: StiMargins;
        get gridSize(): number;
        get unit(): StiUnit;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        get skip(): boolean;
        set skip(value: boolean);
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        getKey(): string;
        get key(): string;
        set key(value: string);
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        dashboardWatermark: StiAdvancedWatermark;
        getApp(): IStiApp;
        protected onRefreshing(e: EventArgs): void;
        refreshingEvent: StiEvent;
        invokeRefreshing(): void;
        private _width2;
        get width(): number;
        set width(value: number);
        private _height2;
        private surfaceViewMode;
        get height(): number;
        set height(value: number);
        private _altSize;
        get altSize(): SizeD;
        set altSize(value: SizeD);
        private _dashboardViewMode;
        get dashboardViewMode(): StiDashboardViewMode;
        set dashboardViewMode(value: StiDashboardViewMode);
        private _contentAlignment;
        get contentAlignment(): StiDashboardContentAlignment;
        set contentAlignment(value: StiDashboardContentAlignment);
        private _altContentAlignment;
        get altContentAlignment(): StiDashboardContentAlignment;
        set altContentAlignment(value: StiDashboardContentAlignment);
        private _deviceWidth;
        get deviceWidth(): number;
        set deviceWidth(value: number);
        get isMobileSurfacePresent(): boolean;
        constructor(report?: StiReport);
    }
}
export namespace Stimulsoft.Dashboard.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiLocalizedMeter = Stimulsoft.Base.Meters.IStiLocalizedMeter;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiMeter implements IStiMeter, IStiLocalizedMeter, IStiJsonReportObject {
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        implements(): any[];
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        saveToString(): string;
        loadFromString(str: string): void;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        getUniqueCode(): number;
        expression: string;
        label: string;
        get localizedName(): string;
        ident: StiMeterIdent;
        key: string;
        isDefault(): boolean;
        toString(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components {
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    class StiDimensionMeter extends StiMeter implements IStiDimensionMeter {
        implements(): any[];
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Export {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    import Attribute = Stimulsoft.System.Attribute;
    class StiExportToolAttribute extends Attribute {
        exportToolTypeName: string;
        constructor(exportToolTypeName: string);
        static attributes: Dictionary<string, StiExportToolAttribute>;
        static add(typeName: string, exportToolTypeName: string): void;
    }
}
export namespace Stimulsoft.Dashboard.Components.Panel {
    import IStiPanelElement = Stimulsoft.Report.Dashboard.IStiPanelElement;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiApp = Stimulsoft.Base.IStiApp;
    import StiAdvancedWatermark = Stimulsoft.Base.Drawing.StiAdvancedWatermark;
    import IStiDashboardWatermark = Stimulsoft.Report.Dashboard.IStiDashboardWatermark;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    import IStiSimpleShadow = Stimulsoft.Report.Components.IStiSimpleShadow;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiDashboard = Stimulsoft.Report.Dashboard.IStiDashboard;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiToolboxCategory = Stimulsoft.Report.Components.StiToolboxCategory;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiPadding = Stimulsoft.Report.Dashboard.StiPadding;
    import StiMargin = Stimulsoft.Report.Dashboard.StiMargin;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import IStiMargin = Stimulsoft.Report.Dashboard.IStiMargin;
    import IStiPadding = Stimulsoft.Report.Dashboard.IStiPadding;
    import IStiPanel = Stimulsoft.Report.Dashboard.IStiPanel;
    import IStiSimpleBorder = Stimulsoft.Report.Components.IStiSimpleBorder;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiAltProperties = Stimulsoft.Report.Dashboard.IStiAltProperties;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPanelElement extends StiPanel implements IStiSimpleBorder, IStiCornerRadius, IStiSimpleShadow, IStiPanel, IStiPanelElement, IStiPadding, IStiMargin, IStiAltProperties, IStiJsonReportObject, IStiDashboardWatermark {
        implements(): any[];
        clone(cloneProperties: boolean): StiPanelElement;
        meta(): StiMeta[];
        getMeters(nested?: boolean, group?: string): List<IStiMeter>;
        getElements(nested?: boolean, group?: string): List<IStiElement>;
        fetchAllMeters(): List<IStiMeter>;
        getMeters2(): List<IStiMeter>;
        getFilterRules(): List<StiDataFilterRule>;
        getNestedPages(): List<StiPage>;
        get dashboard(): IStiDashboard;
        get isDefined(): boolean;
        get isQuerable(): boolean;
        isEnabledAsync(): Promise<boolean>;
        get zoom(): number;
        retrieveUsedDataNames(group: string): List<string>;
        getDictionary(): IStiAppDictionary;
        getDataSources(dataNames: List<string>): List<IStiAppDataSource>;
        margin: StiMargin;
        padding: StiPadding;
        border2: StiSimpleBorder;
        backColor: Color;
        dashboardWatermark: StiAdvancedWatermark;
        private _watermarkStyle;
        get watermarkStyle(): string;
        set watermarkStyle(value: string);
        getApp(): IStiApp;
        shadow: StiSimpleShadow;
        cornerRadius: StiCornerRadius;
        altTitleVisible: boolean;
        altClientRectangle: RectangleD;
        altParentKey: string;
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        get style(): string;
        set style(value: string);
        get serviceCategory(): string;
        get localizedCategory(): string;
        get toolboxCategory(): StiToolboxCategory;
        canContainIn(component: StiComponent): boolean;
        get key(): string;
        set key(value: string);
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Components {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiToolboxCategory = Stimulsoft.Report.Components.StiToolboxCategory;
    import StiMargin = Stimulsoft.Report.Dashboard.StiMargin;
    import StiPadding = Stimulsoft.Report.Dashboard.StiPadding;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiDashboard = Stimulsoft.Report.Dashboard.IStiDashboard;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiMargin = Stimulsoft.Report.Dashboard.IStiMargin;
    import IStiPadding = Stimulsoft.Report.Dashboard.IStiPadding;
    import IStiBackColor = Stimulsoft.Report.Components.IStiBackColor;
    import IStiSimpleBorder = Stimulsoft.Report.Components.IStiSimpleBorder;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiAltProperties = Stimulsoft.Report.Dashboard.IStiAltProperties;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiElement extends StiComponent implements IStiElement, IStiSimpleBorder, IStiBackColor, IStiPadding, IStiMargin, IStiAltProperties, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        get dashboard(): IStiDashboard;
        get isDefined(): boolean;
        get isQuerable(): boolean;
        isEnabledAsync(): Promise<boolean>;
        get zoom(): number;
        retrieveUsedDataNames2(group: string): List<string>;
        retrieveUsedDataNames(): List<string>;
        getDictionary(): IStiAppDictionary;
        getDataSources(dataNames: List<string>): List<IStiAppDataSource>;
        clone(cloneProperties: boolean): any;
        border2: StiSimpleBorder;
        private _backColor;
        get backColor(): Color;
        set backColor(value: Color);
        margin: StiMargin;
        padding: StiPadding;
        altTitleVisible: boolean;
        altClientRectangle: RectangleD;
        altParentKey: string;
        get serviceCategory(): string;
        canContainIn(component: StiComponent): boolean;
        toolboxCategory: StiToolboxCategory;
        get localizedCategory(): string;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        get key(): string;
        set key(value: string);
        getNestedPages(): List<StiPage>;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Components {
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiManuallyEnteredDataParser {
        static columnValue: string;
        static columnEndValue: string;
        static columnTarget: string;
        static columnCloseValue: string;
        static columnLowValue: string;
        static columnHighValue: string;
        static columnArgument: string;
        static columnX: string;
        static columnY: string;
        static columnWeight: string;
        static columnSeries: string;
        static getIndicatorDataTable(content: string, element: IStiElement): StiDataTable;
        static getProgressDataTable(content: string, element: IStiElement): StiDataTable;
        static getGaugeDataTable(content: string, dateTimeMode: boolean, element: IStiElement): StiDataTable;
        static getChartDataTable(content: string, element: IStiElement): StiDataTable;
        static sumNullable(values: List<number>): number;
        private static parseDateTime;
        private static parseDecimal;
        private static parseNullableDecimal;
        static parseString(value: any, element: IStiElement): string;
    }
}
export namespace Stimulsoft.Dashboard.Components {
    import IStiMeasureMeter = Stimulsoft.Base.Meters.IStiMeasureMeter;
    class StiMeasureMeter extends StiMeter implements IStiMeasureMeter {
        implements(): any[];
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components {
    import StiTitlePadding = Stimulsoft.Report.Dashboard.StiTitlePadding;
    import IStiTitlePadding = Stimulsoft.Report.Dashboard.IStiTitlePadding;
    import StiTextSizeMode = Stimulsoft.Report.Dashboard.StiTextSizeMode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiTitle = Stimulsoft.Report.Dashboard.IStiTitle;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiTitle implements ICloneable, IStiJsonReportObject, IStiTitle, IStiTitlePadding {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        static createFromJsonObject(jObject: StiJson): StiTitle;
        static createFromXml(xmlNode: XmlNode): StiTitle;
        clone(): any;
        padding: StiTitlePadding;
        horAlignment: StiHorAlignment;
        font: Font;
        backColor: Color;
        foreColor: Color;
        text: string;
        visible: boolean;
        sizeMode: StiTextSizeMode;
        constructor(text?: string, foreColor?: Color, backColor?: Color, font?: Font, alignment?: StiHorAlignment, visible?: boolean, sizeMode?: StiTextSizeMode, padding?: StiTitlePadding);
    }
}
export namespace Stimulsoft.Dashboard.Components.Button {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiButtonElementIconSet = Stimulsoft.Report.Dashboard.IStiButtonElementIconSet;
    class StiButtonElementIconSet implements IStiButtonElementIconSet, ICloneable {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        static createFromJsonObject(j: StiJson): StiButtonElementIconSet;
        static createFromXml(xmlNode: XmlNode): StiButtonElementIconSet;
        clone(): any;
        icon: StiFontIcons;
        checkedIcon: StiFontIcons;
        uncheckedIcon: StiFontIcons;
        parent: StiButtonElement;
        isDefault(): boolean;
        constructor(checkedIcon?: StiFontIcons, uncheckedIcon?: StiFontIcons);
    }
}
export namespace Stimulsoft.Dashboard.Components.Button {
    import StiFilterInclusionMode = Stimulsoft.Report.Dashboard.StiFilterInclusionMode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiButtonElementIconSet = Stimulsoft.Dashboard.Components.Button.StiButtonElementIconSet;
    import StiIconAlignment = Stimulsoft.Report.Dashboard.StiIconAlignment;
    import Size = Stimulsoft.System.Drawing.Size;
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import List = Stimulsoft.System.Collections.List;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import IStiButtonVisualStates = Stimulsoft.Report.Dashboard.IStiButtonVisualStates;
    import IStiButtonElementIconSet = Stimulsoft.Report.Dashboard.IStiButtonElementIconSet;
    import StiButtonType = Stimulsoft.Report.Dashboard.StiButtonType;
    import StiButtonShapeType = Stimulsoft.Base.Drawing.StiButtonShapeType;
    import StiButtonStretch = Stimulsoft.Report.Dashboard.StiButtonStretch;
    import IStiCopyStyleExt = Stimulsoft.Report.Design.IStiCopyStyleExt;
    import IStiWordWrap = Stimulsoft.Report.Components.IStiWordWrap;
    import IStiTextBrush = Stimulsoft.Report.Components.IStiTextBrush;
    import IStiButtonElement = Stimulsoft.Report.Dashboard.IStiButtonElement;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import IStiBrush = Stimulsoft.Report.Components.IStiBrush;
    import IStiFixedHeightElement = Stimulsoft.Report.Dashboard.IStiFixedHeightElement;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import IStiVertAlignment = Stimulsoft.Report.Components.IStiVertAlignment;
    import IStiTextHorAlignment = Stimulsoft.Report.Components.IStiTextHorAlignment;
    class StiButtonElement extends StiElement implements IStiButtonElement, IStiCopyStyleExt, IStiTextHorAlignment, IStiVertAlignment, IStiWordWrap, IStiFont, IStiFixedHeightElement, IStiBrush, IStiTextBrush {
        implements(): any[];
        clone(cloneProperties: boolean): any;
        meta(): StiMeta[];
        get isFixedHeight(): boolean;
        private checkedValue;
        get checked(): boolean;
        set checked(value: boolean);
        shapeType: StiButtonShapeType;
        private _stretch;
        get stretch(): StiButtonStretch;
        set stretch(value: StiButtonStretch);
        type: StiButtonType;
        getIconSet(): IStiButtonElementIconSet;
        getVisualStates(): IStiButtonVisualStates;
        shadow: StiSimpleShadow;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        private _customStyleName;
        get customStyleName(): string;
        set customStyleName(value: string);
        convertFrom(element: IStiElement): void;
        userFilters: List<StiDataFilterRule>;
        textFormat: StiFormatService;
        font: Font;
        getParentKey(): string;
        setParentKey(key: string): void;
        applyDefaultFilters(): Promise<void>;
        getIdentityFilters(): List<StiDataFilterRule>;
        inclusionMode: StiFilterInclusionMode;
        cornerRadius: StiCornerRadius;
        getFonts(): Font[];
        horAlignment: StiTextHorAlignment;
        vertAlignment: StiVertAlignment;
        wordWrap: boolean;
        brush: StiBrush;
        textBrush: StiBrush;
        get backColor(): Color;
        set backColor(value: Color);
        get foreColor(): Color;
        set foreColor(value: Color);
        invokeSetCopyStyle(): void;
        invokeGetCopyStyle(): void;
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        private getFixedHeight;
        private _visualStates;
        get visualStates(): StiButtonVisualStates;
        set visualStates(value: StiButtonVisualStates);
        get isChecked(): boolean;
        getMinSize(): Size;
        setMinSize(value: Size): void;
        getMaxSize(): Size;
        setMaxSize(value: Size): void;
        text: string;
        group: string;
        iconAlignment: StiIconAlignment;
        iconSet: StiButtonElementIconSet;
        iconBrush: StiBrush;
        selectedValue: any;
        selectedKey: string;
        selectedLabel: string;
        selectedIndex: number;
        checkedChangedEvent: StiEvent;
        invokeCheckedChanged(sender: any, e: any): void;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Components.Button {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiButtonElementIconSet = Stimulsoft.Report.Dashboard.IStiButtonElementIconSet;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiButtonVisualState = Stimulsoft.Report.Dashboard.IStiButtonVisualState;
    class StiButtonVisualState implements IStiButtonVisualState, ICloneable {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        static createFromJsonObject(j: StiJson): StiButtonVisualState;
        static createFromXml(xmlNode: XmlNode): StiButtonVisualState;
        clone(): any;
        font: Font;
        brush: StiBrush;
        textBrush: StiBrush;
        border: StiSimpleBorder;
        iconSet: StiButtonElementIconSet;
        getIconSet(): IStiButtonElementIconSet;
        iconBrush: StiBrush;
        parent: StiButtonElement;
    }
}
export namespace Stimulsoft.Dashboard.Components.Button {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiButtonVisualState = Stimulsoft.Report.Dashboard.IStiButtonVisualState;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiCopyStyleExt = Stimulsoft.Report.Design.IStiCopyStyleExt;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiButtonVisualStates = Stimulsoft.Report.Dashboard.IStiButtonVisualStates;
    class StiButtonVisualStates implements IStiButtonVisualStates, ICloneable, IStiGetFonts, IStiCopyStyleExt {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        static createFromJsonObject(j: StiJson): StiButtonVisualStates;
        static createFromXml(xmlNode: XmlNode): StiButtonVisualStates;
        clone(): any;
        getFonts(): Font[];
        invokeSetCopyStyle(): void;
        invokeGetCopyStyle(): void;
        getHoverState(): IStiButtonVisualState;
        getPressedState(): IStiButtonVisualState;
        getCheckedState(): IStiButtonVisualState;
        private _hover;
        get hover(): StiButtonVisualState;
        set hover(value: StiButtonVisualState);
        private _pressed;
        get pressed(): StiButtonVisualState;
        set pressed(value: StiButtonVisualState);
        private _checked;
        get checked(): StiButtonVisualState;
        set checked(value: StiButtonVisualState);
        parent: StiButtonElement;
        constructor();
    }
}
export namespace Stimulsoft.Dashboard.Interactions.Design {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDashboardInteractionLoader {
        static loadInteractionFromJsonObject(jObject: StiJson): StiDashboardInteraction;
        static loadInteractionFromXml(xmlNode: XmlNode): StiDashboardInteraction;
    }
}
export namespace Stimulsoft.Dashboard.Interactions {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiDashboardDrillDownParameter = Stimulsoft.Report.Dashboard.IStiDashboardDrillDownParameter;
    import List = Stimulsoft.System.Collections.List;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    import StiAvailableInteractionOnHover = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnHover;
    import StiAvailableInteractionOnDataManipulation = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnDataManipulation;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDashboardInteraction implements IStiDashboardInteraction, IStiJsonReportObject {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        isDefault(): boolean;
        getDrillDownParameters(): List<IStiDashboardDrillDownParameter>;
        setDrillDownParameters(drillDownParameters: any[]): void;
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        availableOnHover: StiAvailableInteractionOnHover;
        availableOnDataManipulation: StiAvailableInteractionOnDataManipulation;
        onHover: StiInteractionOnHover;
        onClick: StiInteractionOnClick;
        hyperlinkDestination: StiInteractionOpenHyperlinkDestination;
        toolTip: string;
        hyperlink: string;
        drillDownPageKey: string;
        drillDownParameters: List<StiDashboardDrillDownParameter>;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>);
    }
}
export namespace Stimulsoft.Dashboard.Interactions {
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import List = Stimulsoft.System.Collections.List;
    class StiCardsColumnDashboardInteraction extends StiDashboardInteraction {
        ident: StiInteractionIdent;
        availableOnClick: number;
        onHover: StiInteractionOnHover;
        onClick: StiInteractionOnClick;
        isDefault(): boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>);
    }
}
export namespace Stimulsoft.Dashboard.Components.Cards {
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import StiCardsColumnDashboardInteraction = Stimulsoft.Dashboard.Interactions.StiCardsColumnDashboardInteraction;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import IStiVertAlignment = Stimulsoft.Report.Components.IStiVertAlignment;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiCardsColumn = Stimulsoft.Base.Meters.IStiCardsColumn;
    import StiCardsColumnVisibility = Stimulsoft.Base.Drawing.StiCardsColumnVisibility;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    import IStiWordWrap = Stimulsoft.Report.Components.IStiWordWrap;
    import IStiDataTopN = Stimulsoft.Data.Engine.IStiDataTopN;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    class StiCardsColumn extends StiMeter implements IStiCardsColumn, IStiHorAlignment, IStiVertAlignment, IStiForeColor, IStiTextFormat, IStiFont, IStiWordWrap, IStiElementInteraction, IStiDataTopN {
        implements(): any[];
        meta(): StiMeta[];
        clone(): any;
        horAlignment: StiHorAlignment;
        vertAlignment: StiVertAlignment;
        textFormat: StiFormatService;
        topN: StiDataTopN;
        font: Font;
        foreColor: Color;
        dashboardInteraction: IStiDashboardInteraction;
        getUniqueCode(): number;
        wrapLine: boolean;
        height: number;
        wordWrap: boolean;
        visibility: StiCardsColumnVisibility;
        visibilityExpression: string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, vertAlignment?: StiVertAlignment, height?: number, textFormat?: StiFormatService, visibility?: StiCardsColumnVisibility, visibilityExpression?: string, foreColor?: Color, wrapLine?: boolean, wordWrap?: boolean, interaction?: StiCardsColumnDashboardInteraction, topN?: StiDataTopN);
    }
}
export namespace Stimulsoft.Dashboard.Components.Cards {
    import IStiMeasureCardsColumn = Stimulsoft.Base.Meters.IStiMeasureCardsColumn;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiCardsColumnVisibility = Stimulsoft.Base.Drawing.StiCardsColumnVisibility;
    import StiCardsColumn = Stimulsoft.Dashboard.Components.Cards.StiCardsColumn;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiMeasureMeter = Stimulsoft.Base.Meters.IStiMeasureMeter;
    import IStiMeasureColumn = Stimulsoft.Base.Meters.IStiMeasureColumn;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    class StiMeasureCardsColumn extends StiCardsColumn implements IStiMeasureMeter, IStiMeasureColumn, IStiMeasureCardsColumn {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, vertAlignment?: StiVertAlignment, height?: number, textFormat?: StiFormatService, visibility?: StiCardsColumnVisibility, visibilityExpression?: string, foreColor?: Color, wrapLine?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Cards {
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiCardsColumnVisibility = Stimulsoft.Base.Drawing.StiCardsColumnVisibility;
    import StiMeasureCardsColumn = Stimulsoft.Dashboard.Components.Cards.StiMeasureCardsColumn;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiBubbleColumn = Stimulsoft.Base.Meters.IStiBubbleColumn;
    class StiBubbleCardsColumn extends StiMeasureCardsColumn implements IStiBubbleColumn, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        getUniqueCode(): number;
        ident: StiMeterIdent;
        allowCustomColors: boolean;
        positiveColor: Color;
        negativeColor: Color;
        horAlignment: StiHorAlignment;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, vertAlignment?: StiVertAlignment, height?: number, textFormat?: StiFormatService, visibility?: StiCardsColumnVisibility, visibilityExpression?: string, foreColor?: Color, allowCustomColors?: boolean, positiveColor?: Color, negativeColor?: Color, wrapLine?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Cards {
    import IStiDimensionCardsColumn = Stimulsoft.Base.Meters.IStiDimensionCardsColumn;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiCardsColumnVisibility = Stimulsoft.Base.Drawing.StiCardsColumnVisibility;
    import StiCardsColumn = Stimulsoft.Dashboard.Components.Cards.StiCardsColumn;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    class StiDimensionCardsColumn extends StiCardsColumn implements IStiDimensionMeter, IStiDimensionCardsColumn {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, vertAlignment?: StiVertAlignment, height?: number, textFormat?: StiFormatService, visibility?: StiCardsColumnVisibility, visibilityExpression?: string, foreColor?: Color, wrapLine?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Helpers {
    import List = Stimulsoft.System.Collections.List;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiMeterLoader {
        static loadFromJson2(jsons: List<StiJson>): List<StiMeter>;
        static loadFromJson(json: StiJson): StiMeter;
        static loadFromXml(xmlNode: XmlNode): StiMeter;
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    class StiIndicatorValueChartMeter extends StiMeasureMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiArgumentMeter = Stimulsoft.Base.Meters.IStiArgumentMeter;
    class StiArgumentChartMeter extends StiDimensionMeter implements IStiArgumentMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.TreeViewBox {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiKeyTreeViewBoxMeter extends StiDimensionMeter implements IStiValueMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.TreeView {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiKeyTreeViewMeter extends StiDimensionMeter implements IStiValueMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Interactions {
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import List = Stimulsoft.System.Collections.List;
    class StiTableColumnDashboardInteraction extends StiDashboardInteraction {
        ident: StiInteractionIdent;
        availableOnClick: number;
        onHover: StiInteractionOnHover;
        onClick: StiInteractionOnClick;
        isDefault(): boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>);
    }
}
export namespace Stimulsoft.Dashboard.Components.Table {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    import IStiDataFormat = Stimulsoft.Data.Engine.IStiDataFormat;
    import StiDataFormatKind = Stimulsoft.Data.Engine.StiDataFormatKind;
    import StiSummaryColumnType = Stimulsoft.Base.StiSummaryColumnType;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import StiTableColumnDashboardInteraction = Stimulsoft.Dashboard.Interactions.StiTableColumnDashboardInteraction;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiTableColumn = Stimulsoft.Base.Meters.IStiTableColumn;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    import IStiDataTopN = Stimulsoft.Data.Engine.IStiDataTopN;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    import IStiTableColumnSize = Stimulsoft.Report.Dashboard.IStiTableColumnSize;
    import StiTableColumnSize = Stimulsoft.Report.Dashboard.StiTableColumnSize;
    class StiTableColumn extends StiMeter implements IStiHorAlignment, IStiTextFormat, IStiDataFormat, IStiTableColumn, IStiForeColor, IStiJsonReportObject, IStiElementInteraction, IStiTableColumnSize, IStiDataTopN {
        implements(): any[];
        meta(): StiMeta[];
        clone(): any;
        horAlignment: StiHorAlignment;
        textFormat: StiFormatService;
        topN: StiDataTopN;
        getDataFormat(): StiDataFormatKind;
        foreColor: Color;
        dashboardInteraction: IStiDashboardInteraction;
        getUniqueCode(): number;
        checkRules(): void;
        get visible(): boolean;
        set visible(value: boolean);
        visibility: StiTableColumnVisibility;
        visibilityExpression: string;
        showTotalSummary: boolean;
        summaryType: StiSummaryColumnType;
        summaryAlignment: StiHorAlignment;
        headerAlignment: StiHorAlignment;
        private _size;
        get size(): StiTableColumnSize;
        set size(value: StiTableColumnSize);
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, visibility?: StiTableColumnVisibility, visibilityExpression?: string, foreColor?: Color, showTotalSummary?: boolean, summaryType?: StiSummaryColumnType, summaryAlignment?: StiHorAlignment, headerAlignment?: StiHorAlignment, interaction?: StiTableColumnDashboardInteraction, topN?: StiDataTopN);
    }
}
export namespace Stimulsoft.Dashboard.Components.Table {
    import StiTableColumnDashboardInteraction = Stimulsoft.Dashboard.Interactions.StiTableColumnDashboardInteraction;
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiMeasureMeter = Stimulsoft.Base.Meters.IStiMeasureMeter;
    import IStiMeasureColumn = Stimulsoft.Base.Meters.IStiMeasureColumn;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiSummaryColumnType = Stimulsoft.Base.StiSummaryColumnType;
    class StiMeasureColumn extends StiTableColumn implements IStiMeasureMeter, IStiMeasureColumn {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, visibility?: StiTableColumnVisibility, visibilityExpression?: string, foreColor?: Color, showTotalSummary?: boolean, summaryType?: StiSummaryColumnType, summaryAlignment?: StiHorAlignment, headerAlignment?: StiHorAlignment, interaction?: StiTableColumnDashboardInteraction);
    }
}
export namespace Stimulsoft.Dashboard.Components.Table {
    import StiSummaryColumnType = Stimulsoft.Base.StiSummaryColumnType;
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiIndicatorColumn = Stimulsoft.Base.Meters.IStiIndicatorColumn;
    import StiTableColumnSize = Stimulsoft.Report.Dashboard.StiTableColumnSize;
    class StiIndicatorColumn extends StiMeasureColumn implements IStiIndicatorColumn {
        implements(): any[];
        ident: StiMeterIdent;
        get size(): StiTableColumnSize;
        set size(value: StiTableColumnSize);
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, visibility?: StiTableColumnVisibility, visibilityExpression?: string, foreColor?: Color, showTotalSummary?: boolean, summaryType?: StiSummaryColumnType, summaryAlignment?: StiHorAlignment);
    }
}
export namespace Stimulsoft.Dashboard.Components.Table {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiSummaryColumnType = Stimulsoft.Base.StiSummaryColumnType;
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiColorScaleColumn = Stimulsoft.Base.Meters.IStiColorScaleColumn;
    import StiTableColumnSize = Stimulsoft.Report.Dashboard.StiTableColumnSize;
    class StiColorScaleColumn extends StiMeasureColumn implements IStiColorScaleColumn, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        getUniqueCode(): number;
        ident: StiMeterIdent;
        minimumColor: Color;
        maximumColor: Color;
        get size(): StiTableColumnSize;
        set size(value: StiTableColumnSize);
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, visibility?: StiTableColumnVisibility, visibilityExpression?: string, foreColor?: Color, showTotalSummary?: boolean, summaryType?: StiSummaryColumnType, summaryAlignment?: StiHorAlignment, minimumColor?: Color, maximumColor?: Color);
    }
}
export namespace Stimulsoft.Dashboard.Components.Table {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiSummaryColumnType = Stimulsoft.Base.StiSummaryColumnType;
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiDataBarsColumn = Stimulsoft.Base.Meters.IStiDataBarsColumn;
    import StiTableColumnSize = Stimulsoft.Report.Dashboard.StiTableColumnSize;
    class StiDataBarsColumn extends StiMeasureColumn implements IStiDataBarsColumn, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        getUniqueCode(): number;
        ident: StiMeterIdent;
        width: number;
        positiveColor: Color;
        negativeColor: Color;
        overlappedColor: Color;
        fillColor: Color;
        minimum: string;
        maximum: string;
        get size(): StiTableColumnSize;
        set size(value: StiTableColumnSize);
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, visibility?: StiTableColumnVisibility, visibilityExpression?: string, foreColor?: Color, positiveColor?: Color, negativeColor?: Color, overlappedColor?: Color, fillColor?: Color, showTotalSummary?: boolean, summaryType?: StiSummaryColumnType, summaryAlignment?: StiHorAlignment, headerAlignment?: StiHorAlignment, width?: number, minimum?: string, maximum?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Table {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiSparklinesColumn = Stimulsoft.Base.Meters.IStiSparklinesColumn;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiSummaryColumnType = Stimulsoft.Base.StiSummaryColumnType;
    import StiTableColumnSize = Stimulsoft.Report.Dashboard.StiTableColumnSize;
    class StiSparklinesColumn extends StiMeasureColumn implements IStiSparklinesColumn, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        type: StiSparklinesType;
        showHighLowPoints: boolean;
        showFirstLastPoints: boolean;
        allowCustomColors: boolean;
        positiveColor: Color;
        negativeColor: Color;
        get size(): StiTableColumnSize;
        set size(value: StiTableColumnSize);
        getUniqueCode(): number;
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, type?: StiSparklinesType, showHighLowPoints?: boolean, showFirstLastPoints?: boolean, visibility?: StiTableColumnVisibility, visibilityExpression?: string, foreColor?: Color, showTotalSummary?: boolean, summaryType?: StiSummaryColumnType, summaryAlignment?: StiHorAlignment, allowCustomColors?: boolean, positiveColor?: Color, negativeColor?: Color);
    }
}
export namespace Stimulsoft.Dashboard.Components.Table {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    import StiSummaryColumnType = Stimulsoft.Base.StiSummaryColumnType;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiBubbleColumn = Stimulsoft.Base.Meters.IStiBubbleColumn;
    import StiTableColumnSize = Stimulsoft.Report.Dashboard.StiTableColumnSize;
    class StiBubbleColumn extends StiMeasureColumn implements IStiBubbleColumn, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        getUniqueCode(): number;
        ident: StiMeterIdent;
        allowCustomColors: boolean;
        positiveColor: Color;
        negativeColor: Color;
        horAlignment: StiHorAlignment;
        get size(): StiTableColumnSize;
        set size(value: StiTableColumnSize);
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, visibility?: StiTableColumnVisibility, visibilityExpression?: string, foreColor?: Color, showTotalSummary?: boolean, summaryType?: StiSummaryColumnType, summaryAlignment?: StiHorAlignment, allowCustomColors?: boolean, positiveColor?: Color, negativeColor?: Color);
    }
}
export namespace Stimulsoft.Dashboard.Helpers {
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiCultureHelper {
        static set(report: StiReport): CultureInfo;
        static restore(culture: CultureInfo): void;
    }
}
export namespace Stimulsoft.Dashboard.Helpers {
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiBooleanFormatService = Stimulsoft.Report.Components.TextFormats.StiBooleanFormatService;
    import StiDateFormatService = Stimulsoft.Report.Components.TextFormats.StiDateFormatService;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiNumberFormatService = Stimulsoft.Report.Components.TextFormats.StiNumberFormatService;
    import StiPercentageFormatService = Stimulsoft.Report.Components.TextFormats.StiPercentageFormatService;
    import StiCurrencyFormatService = Stimulsoft.Report.Components.TextFormats.StiCurrencyFormatService;
    import StiGeneralFormatService = Stimulsoft.Report.Components.TextFormats.StiGeneralFormatService;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    class StiTextFormatHelper {
        private static storedCulture;
        private static _defaultGeneralFormat;
        static get defaultGeneralFormat(): StiGeneralFormatService;
        private static _defaultCurrencyFormat;
        static get defaultCurrencyFormat(): StiCurrencyFormatService;
        private static _defaultPercentageFormat;
        static get defaultPercentageFormat(): StiPercentageFormatService;
        private static _defaultNumberFormat;
        static get defaultNumberFormat(): StiNumberFormatService;
        private static _defaultIntegerFormat;
        static get defaultIntegerFormat(): StiNumberFormatService;
        private static _defaultDateFormat;
        static get defaultDateFormat(): StiDateFormatService;
        private static _defaultBooleanFormat;
        static get defaultBooleanFormat(): StiBooleanFormatService;
        static formatBasedOnColumnType(component: StiComponent, column: StiTableColumn, value: any): string;
        static formatBasedOnColumnType2(component: StiComponent, formatService: StiFormatService, column: IStiMeter, value: any): string;
        static format(report: StiReport, format: StiFormatService, value: any): string;
        static formatAsPercentage(report: StiReport, value: any): string;
        static formatAsPercentage2(report: StiReport, format: StiFormatService, value: any): string;
        static getDefaultFormatForColumn(cell: IStiAppDataCell): StiFormatService;
    }
}
export namespace Stimulsoft.Dashboard.Components.Table {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiSummaryColumnType = Stimulsoft.Base.StiSummaryColumnType;
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import IStiDimensionColumn = Stimulsoft.Base.Meters.IStiDimensionColumn;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    class StiDimensionColumn extends StiTableColumn implements IStiDimensionMeter, IStiDimensionColumn {
        implements(): any[];
        meta(): StiMeta[];
        clone(): any;
        ident: StiMeterIdent;
        get localizedName(): string;
        showHyperlink: boolean;
        hyperlinkPattern: string;
        getUniqueCode(): number;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, visibility?: StiTableColumnVisibility, visibilityExpression?: string, visible?: boolean, foreColor?: Color, showHyperlink?: boolean, hyperlinkPattern?: string, showTotalSummary?: boolean, summaryType?: StiSummaryColumnType, summaryAlignment?: StiHorAlignment);
    }
}
export namespace Stimulsoft.Dashboard.Components.RegionMap {
    import IStiColorMapMeter = Stimulsoft.Base.Meters.IStiColorMapMeter;
    class StiColorMapMeter extends StiDimensionMeter implements IStiColorMapMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.RegionMap {
    import IStiValueMapMeter = Stimulsoft.Base.Meters.IStiValueMapMeter;
    class StiValueMapMeter extends StiMeasureMeter implements IStiValueMapMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.RegionMap {
    import IStiGroupMapMeter = Stimulsoft.Base.Meters.IStiGroupMapMeter;
    class StiGroupMapMeter extends StiDimensionMeter implements IStiGroupMapMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.RegionMap {
    import IStiNameMapMeter = Stimulsoft.Base.Meters.IStiNameMapMeter;
    class StiNameMapMeter extends StiDimensionMeter implements IStiNameMapMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.RegionMap {
    import IStiKeyMapMeter = Stimulsoft.Base.Meters.IStiKeyMapMeter;
    class StiKeyMapMeter extends StiDimensionMeter implements IStiKeyMapMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Progress {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiValueProgressMeter extends StiMeasureMeter implements IStiValueMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Progress {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiTargetProgressMeter extends StiMeasureMeter implements IStiValueMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Progress {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiSeriesProgressMeter extends StiDimensionMeter implements IStiValueMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Interactions {
    import StiAvailableInteractionOnHover = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnHover;
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    import List = Stimulsoft.System.Collections.List;
    class StiPivotTableItemDashboardInteraction extends StiDashboardInteraction {
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        availableOnHover: StiAvailableInteractionOnHover;
        onHover: StiInteractionOnHover;
        onClick: StiInteractionOnClick;
        isDefault(): boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>);
    }
}
export namespace Stimulsoft.Dashboard.Components.PivotTable {
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import StiPivotTableItemDashboardInteraction = Stimulsoft.Dashboard.Interactions.StiPivotTableItemDashboardInteraction;
    import IStiPivotItem = Stimulsoft.Report.Dashboard.IStiPivotItem;
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    import StiSortDirection = Stimulsoft.Report.CrossTab.Core.StiSortDirection;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiMeterRules = Stimulsoft.Report.Dashboard.IStiMeterRules;
    import IStiTableColumnSize = Stimulsoft.Report.Dashboard.IStiTableColumnSize;
    import StiTableColumnSize = Stimulsoft.Report.Dashboard.StiTableColumnSize;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiPivotColumn = Stimulsoft.Base.Meters.IStiPivotColumn;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    import IStiDataTopN = Stimulsoft.Data.Engine.IStiDataTopN;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    class StiPivotColumn extends StiMeter implements IStiDimensionMeter, IStiHorAlignment, IStiTextFormat, IStiPivotColumn, IStiMeterRules, IStiDataTopN, IStiTableColumnSize, IStiPivotItem, IStiJsonReportObject, IStiElementInteraction {
        implements(): any[];
        clone(): any;
        meta(): StiMeta[];
        checkRules(): void;
        horAlignment: StiHorAlignment;
        showTotal: boolean;
        totalLabel: string;
        textFormat: StiFormatService;
        size: StiTableColumnSize;
        visibility: StiTableColumnVisibility;
        visibilityExpression: string;
        expandExpression: string;
        dashboardInteraction: IStiDashboardInteraction;
        topN: StiDataTopN;
        get strSortDirection(): string;
        set strSortDirection(value: string);
        sortDirection: StiSortDirection;
        getUniqueCode(): number;
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, topN?: StiDataTopN, showTotal?: boolean, totalLabel?: string, size?: StiTableColumnSize, sortDirection?: StiSortDirection, expandExpression?: string, visibility?: StiTableColumnVisibility, visibilityExpression?: string, interaction?: StiPivotTableItemDashboardInteraction);
    }
}
export namespace Stimulsoft.Dashboard.Components.PivotTable {
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import StiPivotTableItemDashboardInteraction = Stimulsoft.Dashboard.Interactions.StiPivotTableItemDashboardInteraction;
    import IStiPivotItem = Stimulsoft.Report.Dashboard.IStiPivotItem;
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    import StiSortDirection = Stimulsoft.Report.CrossTab.Core.StiSortDirection;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiMeterRules = Stimulsoft.Report.Dashboard.IStiMeterRules;
    import StiTableColumnSize = Stimulsoft.Report.Dashboard.StiTableColumnSize;
    import IStiTableColumnSize = Stimulsoft.Report.Dashboard.IStiTableColumnSize;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiPivotRow = Stimulsoft.Base.Meters.IStiPivotRow;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    import IStiDataTopN = Stimulsoft.Data.Engine.IStiDataTopN;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    class StiPivotRow extends StiMeter implements IStiDimensionMeter, IStiHorAlignment, IStiTextFormat, IStiTableColumnSize, IStiPivotRow, IStiMeterRules, IStiDataTopN, IStiPivotItem, IStiJsonReportObject, IStiElementInteraction {
        implements(): any[];
        clone(): any;
        meta(): StiMeta[];
        checkRules(): void;
        horAlignment: StiHorAlignment;
        showTotal: boolean;
        totalLabel: string;
        textFormat: StiFormatService;
        size: StiTableColumnSize;
        visibility: StiTableColumnVisibility;
        visibilityExpression: string;
        expandExpression: string;
        dashboardInteraction: IStiDashboardInteraction;
        topN: StiDataTopN;
        get strSortDirection(): string;
        set strSortDirection(value: string);
        sortDirection: StiSortDirection;
        getUniqueCode(): number;
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, topN?: StiDataTopN, showTotal?: boolean, totalLabel?: string, size?: StiTableColumnSize, sortDirection?: StiSortDirection, expandExpression?: string, visibility?: StiTableColumnVisibility, visibilityExpression?: string, interaction?: StiPivotTableItemDashboardInteraction);
    }
}
export namespace Stimulsoft.Dashboard.Components.PivotTable {
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import StiPivotTableItemDashboardInteraction = Stimulsoft.Dashboard.Interactions.StiPivotTableItemDashboardInteraction;
    import IStiPivotItem = Stimulsoft.Report.Dashboard.IStiPivotItem;
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiMeterRules = Stimulsoft.Report.Dashboard.IStiMeterRules;
    import StiTableColumnSize = Stimulsoft.Report.Dashboard.StiTableColumnSize;
    import IStiTableColumnSize = Stimulsoft.Report.Dashboard.IStiTableColumnSize;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiPivotSummary = Stimulsoft.Base.Meters.IStiPivotSummary;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    class StiPivotSummary extends StiMeasureMeter implements IStiHorAlignment, IStiTextFormat, IStiTableColumnSize, IStiMeterRules, IStiPivotSummary, IStiPivotItem, IStiJsonReportObject, IStiElementInteraction {
        implements(): any[];
        clone(): any;
        meta(): StiMeta[];
        checkRules(): void;
        horAlignment: StiHorAlignment;
        textFormat: StiFormatService;
        size: StiTableColumnSize;
        visibility: StiTableColumnVisibility;
        visibilityExpression: string;
        hideZeros: boolean;
        dashboardInteraction: IStiDashboardInteraction;
        getUniqueCode(): number;
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, size?: StiTableColumnSize, hideZeros?: boolean, visibility?: StiTableColumnVisibility, visibilityExpression?: string, interaction?: StiPivotTableItemDashboardInteraction);
    }
}
export namespace Stimulsoft.Dashboard.Components.OnlineMap {
    class StiLatitudeMapMeter extends StiDimensionMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.OnlineMap {
    class StiLongitudeMapMeter extends StiDimensionMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.ListBox {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiKeyListBoxMeter extends StiDimensionMeter implements IStiValueMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.ListBox {
    import IStiArgumentMeter = Stimulsoft.Base.Meters.IStiArgumentMeter;
    class StiNameListBoxMeter extends StiDimensionMeter implements IStiArgumentMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.DatePicker {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiValueDatePickerMeter extends StiDimensionMeter implements IStiValueMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.NumberBox {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiValueNumberBoxMeter extends StiDimensionMeter implements IStiValueMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    class StiEndValueChartMeter extends StiMeasureMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.ComboBox {
    import IStiArgumentMeter = Stimulsoft.Base.Meters.IStiArgumentMeter;
    class StiNameComboBoxMeter extends StiDimensionMeter implements IStiArgumentMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.ComboBox {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiKeyComboBoxMeter extends StiDimensionMeter implements IStiValueMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Gauge {
    import IStiSeriesMeter = Stimulsoft.Base.Meters.IStiSeriesMeter;
    class StiSeriesGaugeMeter extends StiDimensionMeter implements IStiSeriesMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Gauge {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiValueGaugeMeter extends StiMeasureMeter implements IStiValueMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Gauge {
    import IStiTargetMeter = Stimulsoft.Base.Meters.IStiTargetMeter;
    class StiTargetGaugeMeter extends StiMeasureMeter implements IStiTargetMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Indicator {
    import IStiSeriesMeter = Stimulsoft.Base.Meters.IStiSeriesMeter;
    class StiSeriesIndicatorMeter extends StiDimensionMeter implements IStiSeriesMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Indicator {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiValueIndicatorMeter extends StiMeasureMeter implements IStiValueMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Indicator {
    import IStiTargetMeter = Stimulsoft.Base.Meters.IStiTargetMeter;
    class StiTargetIndicatorMeter extends StiMeasureMeter implements IStiTargetMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    class StiWeightChartMeter extends StiMeasureMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiChartSeriesType = Stimulsoft.Report.Dashboard.StiChartSeriesType;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiEmptyCellsAs = Stimulsoft.Report.Dashboard.StiEmptyCellsAs;
    import StiSeriesYAxis = Stimulsoft.Report.Chart.StiSeriesYAxis;
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiValueChartMeter extends StiMeasureMeter implements IStiJsonReportObject, IStiValueMeter {
        implements(): any[];
        meta(): StiMeta[];
        seriesType: StiChartSeriesType;
        yAxis: StiSeriesYAxis;
        lineStyle: StiPenStyle;
        lineWidth: number;
        showZeros: StiEmptyCellsAs;
        showNulls: StiEmptyCellsAs;
        ident: StiMeterIdent;
        getUniqueCode(): number;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, seriesType?: StiChartSeriesType, yAxis?: StiSeriesYAxis, lineStyle?: StiPenStyle, lineWidth?: number, showZeros?: StiEmptyCellsAs, showNulls?: StiEmptyCellsAs);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiChartSeriesType = Stimulsoft.Report.Dashboard.StiChartSeriesType;
    class StiOpenValueChartMeter extends StiValueChartMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        seriesType: StiChartSeriesType;
        constructor(key?: string, expression?: string, label?: string, seriesType?: StiChartSeriesType);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    class StiCloseValueChartMeter extends StiMeasureMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    class StiLowValueChartMeter extends StiMeasureMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    class StiHighValueChartMeter extends StiMeasureMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiSeriesMeter = Stimulsoft.Base.Meters.IStiSeriesMeter;
    class StiSeriesChartMeter extends StiDimensionMeter implements IStiSeriesMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiSeriesMeter = Stimulsoft.Base.Meters.IStiSeriesMeter;
    class StiSortByChartMeter extends StiDimensionMeter implements IStiSeriesMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    class StiXChartMeter extends StiDimensionMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    class StiYChartMeter extends StiDimensionMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.OnlineMap {
    class StiLocationMapMeter extends StiDimensionMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.OnlineMap {
    class StiLocationColorMapMeter extends StiDimensionMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.OnlineMap {
    class StiLocationValueMapMeter extends StiDimensionMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.OnlineMap {
    class StiLocationArgumentMapMeter extends StiDimensionMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Cards {
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiCardsColumnVisibility = Stimulsoft.Base.Drawing.StiCardsColumnVisibility;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiIndicatorColumn = Stimulsoft.Base.Meters.IStiIndicatorColumn;
    class StiIndicatorCardsColumn extends StiMeasureCardsColumn implements IStiIndicatorColumn {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, vertAlignment?: StiVertAlignment, height?: number, textFormat?: StiFormatService, visibility?: StiCardsColumnVisibility, visibilityExpression?: string, foreColor?: Color, wrapLine?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Cards {
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiCardsColumnVisibility = Stimulsoft.Base.Drawing.StiCardsColumnVisibility;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiColorScaleColumn = Stimulsoft.Base.Meters.IStiColorScaleColumn;
    class StiColorScaleCardsColumn extends StiMeasureCardsColumn implements IStiColorScaleColumn, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        getUniqueCode(): number;
        ident: StiMeterIdent;
        minimumColor: Color;
        maximumColor: Color;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, vertAlignment?: StiVertAlignment, height?: number, textFormat?: StiFormatService, visibility?: StiCardsColumnVisibility, visibilityExpression?: string, foreColor?: Color, minimumColor?: Color, maximumColor?: Color, wrapLine?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Cards {
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiCardsColumnVisibility = Stimulsoft.Base.Drawing.StiCardsColumnVisibility;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiDataBarsColumn = Stimulsoft.Base.Meters.IStiDataBarsColumn;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiDataBarsCardsColumn extends StiMeasureCardsColumn implements IStiDataBarsColumn, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        ident: StiMeterIdent;
        width: number;
        positiveColor: Color;
        negativeColor: Color;
        overlappedColor: Color;
        fillColor: Color;
        minimum: string;
        maximum: string;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, vertAlignment?: StiVertAlignment, height?: number, textFormat?: StiFormatService, visibility?: StiCardsColumnVisibility, visibilityExpression?: string, foreColor?: Color, wrapLine?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Cards {
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiCardsColumnVisibility = Stimulsoft.Base.Drawing.StiCardsColumnVisibility;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiSparklinesColumn = Stimulsoft.Base.Meters.IStiSparklinesColumn;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    class StiSparklinesCardsColumn extends StiMeasureCardsColumn implements IStiSparklinesColumn, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        type: Table.StiSparklinesType;
        showHighLowPoints: boolean;
        showFirstLastPoints: boolean;
        allowCustomColors: boolean;
        positiveColor: Color;
        negativeColor: Color;
        height: number;
        getUniqueCode(): number;
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, vertAlignment?: StiVertAlignment, height?: number, textFormat?: StiFormatService, type?: Stimulsoft.Dashboard.Components.Table.StiSparklinesType, showHighLowPoints?: boolean, showFirstLastPoints?: boolean, visibility?: StiCardsColumnVisibility, visibilityExpression?: string, foreColor?: Color, allowCustomColors?: boolean, positiveColor?: Color, negativeColor?: Color, wrapLine?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Text {
    import IStiTextMeasureMeter = Stimulsoft.Base.Meters.IStiTextMeasureMeter;
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    import List = Stimulsoft.System.Collections.List;
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiTextMeasureMeter extends StiMeasureMeter implements IStiValueMeter, IStiTextMeasureMeter {
        implements(): any[];
        ident: StiMeterIdent;
        getUniqueName(): string;
        static getUniqueNames(measures: List<StiTextMeasureMeter>): Dictionary<string, StiTextMeasureMeter>;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Helpers {
    import StiTextMeasureMeter = Stimulsoft.Dashboard.Components.Text.StiTextMeasureMeter;
    import StiYChartMeter = Stimulsoft.Dashboard.Components.Chart.StiYChartMeter;
    import StiXChartMeter = Stimulsoft.Dashboard.Components.Chart.StiXChartMeter;
    import StiValueNumberBoxMeter = Stimulsoft.Dashboard.Components.NumberBox.StiValueNumberBoxMeter;
    import StiIndicatorValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiIndicatorValueChartMeter;
    import StiSortByChartMeter = Stimulsoft.Dashboard.Components.Chart.StiSortByChartMeter;
    import StiIndicatorCardsColumn = Stimulsoft.Dashboard.Components.Cards.StiIndicatorCardsColumn;
    import StiBubbleCardsColumn = Stimulsoft.Dashboard.Components.Cards.StiBubbleCardsColumn;
    import StiColorScaleCardsColumn = Stimulsoft.Dashboard.Components.Cards.StiColorScaleCardsColumn;
    import StiDataBarsCardsColumn = Stimulsoft.Dashboard.Components.Cards.StiDataBarsCardsColumn;
    import StiSparklinesCardsColumn = Stimulsoft.Dashboard.Components.Cards.StiSparklinesCardsColumn;
    import StiMeasureCardsColumn = Stimulsoft.Dashboard.Components.Cards.StiMeasureCardsColumn;
    import StiDimensionCardsColumn = Stimulsoft.Dashboard.Components.Cards.StiDimensionCardsColumn;
    import StiCardsColumn = Stimulsoft.Dashboard.Components.Cards.StiCardsColumn;
    import StiBubbleColumn = Stimulsoft.Dashboard.Components.Table.StiBubbleColumn;
    import StiLocationArgumentMapMeter = Stimulsoft.Dashboard.Components.OnlineMap.StiLocationArgumentMapMeter;
    import StiLocationMapMeter = Stimulsoft.Dashboard.Components.OnlineMap.StiLocationMapMeter;
    import StiLocationColorMapMeter = Stimulsoft.Dashboard.Components.OnlineMap.StiLocationColorMapMeter;
    import StiLocationValueMapMeter = Stimulsoft.Dashboard.Components.OnlineMap.StiLocationValueMapMeter;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    import Type = Stimulsoft.System.Type;
    import StiKeyTreeViewBoxMeter = Stimulsoft.Dashboard.Components.TreeViewBox.StiKeyTreeViewBoxMeter;
    import StiKeyTreeViewMeter = Stimulsoft.Dashboard.Components.TreeView.StiKeyTreeViewMeter;
    import StiIndicatorColumn = Stimulsoft.Dashboard.Components.Table.StiIndicatorColumn;
    import StiColorScaleColumn = Stimulsoft.Dashboard.Components.Table.StiColorScaleColumn;
    import StiDataBarsColumn = Stimulsoft.Dashboard.Components.Table.StiDataBarsColumn;
    import StiSparklinesColumn = Stimulsoft.Dashboard.Components.Table.StiSparklinesColumn;
    import StiDimensionColumn = Stimulsoft.Dashboard.Components.Table.StiDimensionColumn;
    import StiMeasureColumn = Stimulsoft.Dashboard.Components.Table.StiMeasureColumn;
    import StiColorMapMeter = Stimulsoft.Dashboard.Components.RegionMap.StiColorMapMeter;
    import StiValueMapMeter = Stimulsoft.Dashboard.Components.RegionMap.StiValueMapMeter;
    import StiGroupMapMeter = Stimulsoft.Dashboard.Components.RegionMap.StiGroupMapMeter;
    import StiNameMapMeter = Stimulsoft.Dashboard.Components.RegionMap.StiNameMapMeter;
    import StiKeyMapMeter = Stimulsoft.Dashboard.Components.RegionMap.StiKeyMapMeter;
    import StiValueProgressMeter = Stimulsoft.Dashboard.Components.Progress.StiValueProgressMeter;
    import StiTargetProgressMeter = Stimulsoft.Dashboard.Components.Progress.StiTargetProgressMeter;
    import StiSeriesProgressMeter = Stimulsoft.Dashboard.Components.Progress.StiSeriesProgressMeter;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import IStiDashboard = Stimulsoft.Report.Dashboard.IStiDashboard;
    import StiPivotColumn = Stimulsoft.Dashboard.Components.PivotTable.StiPivotColumn;
    import StiPivotRow = Stimulsoft.Dashboard.Components.PivotTable.StiPivotRow;
    import StiPivotSummary = Stimulsoft.Dashboard.Components.PivotTable.StiPivotSummary;
    import StiLatitudeMapMeter = Stimulsoft.Dashboard.Components.OnlineMap.StiLatitudeMapMeter;
    import StiLongitudeMapMeter = Stimulsoft.Dashboard.Components.OnlineMap.StiLongitudeMapMeter;
    import StiKeyListBoxMeter = Stimulsoft.Dashboard.Components.ListBox.StiKeyListBoxMeter;
    import StiNameListBoxMeter = Stimulsoft.Dashboard.Components.ListBox.StiNameListBoxMeter;
    import StiValueDatePickerMeter = Stimulsoft.Dashboard.Components.DatePicker.StiValueDatePickerMeter;
    import StiElement = Stimulsoft.Dashboard.Components.StiElement;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiNameComboBoxMeter = Stimulsoft.Dashboard.Components.ComboBox.StiNameComboBoxMeter;
    import StiKeyComboBoxMeter = Stimulsoft.Dashboard.Components.ComboBox.StiKeyComboBoxMeter;
    import StiSeriesGaugeMeter = Stimulsoft.Dashboard.Components.Gauge.StiSeriesGaugeMeter;
    import StiValueGaugeMeter = Stimulsoft.Dashboard.Components.Gauge.StiValueGaugeMeter;
    import StiTargetGaugeMeter = Stimulsoft.Dashboard.Components.Gauge.StiTargetGaugeMeter;
    import StiSeriesIndicatorMeter = Stimulsoft.Dashboard.Components.Indicator.StiSeriesIndicatorMeter;
    import StiValueIndicatorMeter = Stimulsoft.Dashboard.Components.Indicator.StiValueIndicatorMeter;
    import StiTargetIndicatorMeter = Stimulsoft.Dashboard.Components.Indicator.StiTargetIndicatorMeter;
    import StiWeightChartMeter = Stimulsoft.Dashboard.Components.Chart.StiWeightChartMeter;
    import StiChartElement = Stimulsoft.Dashboard.Components.Chart.StiChartElement;
    import StiOpenValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiOpenValueChartMeter;
    import StiCloseValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiCloseValueChartMeter;
    import StiLowValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiLowValueChartMeter;
    import StiHighValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiHighValueChartMeter;
    import StiArgumentChartMeter = Stimulsoft.Dashboard.Components.Chart.StiArgumentChartMeter;
    import StiValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiValueChartMeter;
    import StiSeriesChartMeter = Stimulsoft.Dashboard.Components.Chart.StiSeriesChartMeter;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiEndValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiEndValueChartMeter;
    import StiMeter = Stimulsoft.Dashboard.Components.StiMeter;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    class Chart {
        static getValue(meter: StiMeter): StiValueChartMeter;
        static getGanttStartValue(cell: IStiAppDataCell): StiValueChartMeter;
        static getGanttEndValue(cell: IStiAppDataCell): StiEndValueChartMeter;
        static getEndValue(meter: StiMeter): StiEndValueChartMeter;
        static getOpenValue(meter: StiMeter): StiOpenValueChartMeter;
        static getCloseValue(meter: StiMeter): StiCloseValueChartMeter;
        static getLowValue(meter: StiMeter): StiLowValueChartMeter;
        static getHighValue(meter: StiMeter): StiHighValueChartMeter;
        static getValue2(cell: IStiAppDataCell, element: StiChartElement): StiValueChartMeter;
        static getEndValue2(cell: IStiAppDataCell): StiEndValueChartMeter;
        static getCloseValue2(cell: IStiAppDataCell): StiCloseValueChartMeter;
        static getLowValue2(cell: IStiAppDataCell): StiLowValueChartMeter;
        static getHighValue2(cell: IStiAppDataCell): StiHighValueChartMeter;
        static getWeight(meter: StiMeter): StiWeightChartMeter;
        static getWeight2(cell: IStiAppDataCell): StiWeightChartMeter;
        static getArgument(meter: StiMeter): StiArgumentChartMeter;
        static getArgument2(cell: IStiAppDataCell): StiArgumentChartMeter;
        static getX2(cell: IStiAppDataCell): StiArgumentChartMeter;
        static getXValue2(cell: IStiAppDataCell): StiXChartMeter;
        static getX(meter: StiMeter): StiArgumentChartMeter;
        static getXValue(meter: StiMeter): StiXChartMeter;
        static getY2(cell: IStiAppDataCell): StiValueChartMeter;
        static getYValue2(cell: IStiAppDataCell): StiYChartMeter;
        static getY(meter: StiMeter): StiValueChartMeter;
        static getYValue(meter: StiMeter): StiYChartMeter;
        static getSeries(meter: StiMeter): StiSeriesChartMeter;
        static getSortBy(meter: StiMeter): StiSortByChartMeter;
        static getSeries2(cell: IStiAppDataCell): StiSeriesChartMeter;
        static getSortBy2(cell: IStiAppDataCell): StiSortByChartMeter;
        static getIndicatorValue(meter: StiMeter): StiIndicatorValueChartMeter;
        static getIndicatorValue2(cell: IStiAppDataCell): StiIndicatorValueChartMeter;
    }
    class ComboBox {
        static getName(meter: StiMeter): StiNameComboBoxMeter;
        static getName2(cell: IStiAppDataCell): StiNameComboBoxMeter;
        static getKey(meter: StiMeter): StiKeyComboBoxMeter;
        static getKey2(cell: IStiAppDataCell): StiKeyComboBoxMeter;
    }
    class DataFilter {
        static getFilter2(dataColumn: StiDataColumn): StiDataFilterRule;
        static getFilter(column: StiTableColumn, element: StiElement): StiDataFilterRule;
    }
    class DatePicker {
        static getValue(meter: StiMeter): StiValueDatePickerMeter;
        static getValue2(cell: IStiAppDataCell): StiValueDatePickerMeter;
    }
    class NumberBox {
        static getValue(meter: StiMeter): StiValueNumberBoxMeter;
        static getValue2(cell: IStiAppDataCell): StiValueNumberBoxMeter;
    }
    class Gauge {
        static getSeries(meter: StiMeter): StiSeriesGaugeMeter;
        static getSeries2(cell: IStiAppDataCell): StiSeriesGaugeMeter;
        static getValue(meter: StiMeter): StiValueGaugeMeter;
        static getValue2(cell: IStiAppDataCell): StiValueGaugeMeter;
        static getTarget(meter: StiMeter): StiTargetGaugeMeter;
        static getTarget2(cell: IStiAppDataCell): StiTargetGaugeMeter;
    }
    class Indicator {
        static getSeries(meter: StiMeter): StiSeriesIndicatorMeter;
        static getSeries2(cell: IStiAppDataCell): StiSeriesIndicatorMeter;
        static getValue(meter: StiMeter): StiValueIndicatorMeter;
        static getValue2(cell: IStiAppDataCell): StiValueIndicatorMeter;
        static getTarget(meter: StiMeter): StiTargetIndicatorMeter;
        static getTarget2(cell: IStiAppDataCell): StiTargetIndicatorMeter;
    }
    class ListBox {
        static getName(meter: StiMeter): StiNameListBoxMeter;
        static getName2(cell: IStiAppDataCell): StiNameListBoxMeter;
        static getKey(meter: StiMeter): StiKeyListBoxMeter;
        static getKey2(cell: IStiAppDataCell): StiKeyListBoxMeter;
    }
    class OnlineMap {
        static getLatitude(meter: StiMeter): StiLatitudeMapMeter;
        static getLongitude(meter: StiMeter): StiLongitudeMapMeter;
        static getLocation(meter: StiMeter): StiLocationMapMeter;
        static getLocationColor(meter: StiMeter): StiLocationColorMapMeter;
        static getLocationValue(meter: StiMeter): StiLocationValueMapMeter;
        static getLocationArgument(meter: StiMeter): StiLocationArgumentMapMeter;
        static getLatitude2(cell: IStiAppDataCell): StiLatitudeMapMeter;
        static getLongitude2(cell: IStiAppDataCell): StiLongitudeMapMeter;
        static getLocation2(cell: IStiAppDataCell): StiLocationMapMeter;
        static getLocationColor2(cell: IStiAppDataCell): StiLocationColorMapMeter;
        static getLocationValue2(cell: IStiAppDataCell): StiLocationValueMapMeter;
        static getLocationArgument2(cell: IStiAppDataCell): StiLocationArgumentMapMeter;
    }
    class Pivot {
        static getColumn(meter: StiMeter): StiPivotColumn;
        static getRow(meter: StiMeter): StiPivotRow;
        static getShowTotal(meter: StiMeter): boolean;
        static getTotalLabel(meter: StiMeter): string;
        static getSortDirection(meter: StiMeter): string;
        static getExpandExpression(meter: StiMeter): string;
        static getSummary(meter: StiMeter): StiPivotSummary;
        static getSummary3(meter: StiMeter, dashboard?: IStiDashboard): StiPivotSummary;
        static getColumn2(cell: IStiAppDataCell): StiPivotColumn;
        static getRow2(cell: IStiAppDataCell): StiPivotRow;
        static getSummary2(cell: IStiAppDataCell): StiPivotSummary;
        static getFormat(meter: StiMeter): StiFormatService;
        static getTopN(meter: StiMeter): StiDataTopN;
    }
    class Progress {
        static getSeries(meter: StiMeter): StiSeriesProgressMeter;
        static getSeries2(cell: IStiAppDataCell): StiSeriesProgressMeter;
        static getValue(meter: StiMeter): StiValueProgressMeter;
        static getValue2(cell: IStiAppDataCell): StiValueProgressMeter;
        static getTarget(meter: StiMeter): StiTargetProgressMeter;
        static getTarget2(cell: IStiAppDataCell): StiTargetProgressMeter;
    }
    class RegionMap {
        static getKey(meter: StiMeter): StiKeyMapMeter;
        static getName(meter: StiMeter): StiNameMapMeter;
        static getGroup(meter: StiMeter): StiGroupMapMeter;
        static getValue(meter: StiMeter, dashboard: IStiDashboard): StiValueMapMeter;
        static getColor(meter: StiMeter): StiColorMapMeter;
        static getKey2(cell: IStiAppDataCell): StiKeyMapMeter;
        static getName2(cell: IStiAppDataCell): StiNameMapMeter;
        static getValue2(cell: IStiAppDataCell): StiValueMapMeter;
        static getGroup2(cell: IStiAppDataCell): StiGroupMapMeter;
        static getColor2(cell: IStiAppDataCell): StiColorMapMeter;
    }
    class Table {
        static getColumn(meter: StiMeter): StiTableColumn;
        static getDimension(tableColumn: StiTableColumn): StiDimensionColumn;
        static getDimension2(cell: IStiAppDataCell): StiDimensionColumn;
        static getMeasure(tableColumn: StiTableColumn, dashboard: IStiDashboard): StiMeasureColumn;
        static getMeasure2(cell: IStiAppDataCell): StiMeasureColumn;
        static getDataBars(tableColumn: StiTableColumn, dashboard: IStiDashboard): StiDataBarsColumn;
        static getColorScale(tableColumn: StiTableColumn, dashboard: IStiDashboard): StiColorScaleColumn;
        static getSparklines(tableColumn: StiTableColumn): StiSparklinesColumn;
        static getBubble(tableColumn: StiTableColumn, dashboard: IStiDashboard): StiBubbleColumn;
        static getIndicator(tableColumn: StiTableColumn, dashboard: IStiDashboard): StiIndicatorColumn;
    }
    class Text {
        static getMeter(meter: StiMeter): StiTextMeasureMeter;
        static getMeter2(cell: IStiAppDataCell): StiTextMeasureMeter;
    }
    class Cards {
        static getColumn(meter: StiMeter): StiCardsColumn;
        static getDimension(cardsColumn: StiCardsColumn): StiDimensionCardsColumn;
        static getDimension2(cell: IStiAppDataCell): StiDimensionCardsColumn;
        static getMeasure(cardsColumn: StiCardsColumn, dashboard: IStiDashboard): StiMeasureCardsColumn;
        static getMeasure2(cell: IStiAppDataCell): StiMeasureCardsColumn;
        static getDataBars(cardsColumn: StiCardsColumn, dashboard: IStiDashboard): StiDataBarsCardsColumn;
        static getColorScale(cardsColumn: StiCardsColumn, dashboard: IStiDashboard): StiColorScaleCardsColumn;
        static getSparklines(cardsColumn: StiCardsColumn): StiSparklinesCardsColumn;
        static getBubble(cardsColumn: StiCardsColumn, dashboard: IStiDashboard): StiBubbleCardsColumn;
        static getIndicator(cardsColumn: StiCardsColumn, dashboard: IStiDashboard): StiIndicatorCardsColumn;
    }
    class TreeView {
        static getKey(meter: StiMeter): StiKeyTreeViewMeter;
        static getKey2(cell: IStiAppDataCell): StiKeyTreeViewMeter;
    }
    class TreeViewBox {
        static getKey(meter: StiMeter): StiKeyTreeViewBoxMeter;
        static getKey2(cell: IStiAppDataCell): StiKeyTreeViewBoxMeter;
    }
    class StiMeterHelper {
        static Chart: typeof Chart;
        static ComboBox: typeof ComboBox;
        static DataFilter: typeof DataFilter;
        static DatePicker: typeof DatePicker;
        static NumberBox: typeof NumberBox;
        static Gauge: typeof Gauge;
        static Indicator: typeof Indicator;
        static ListBox: typeof ListBox;
        static OnlineMap: typeof OnlineMap;
        static Pivot: typeof Pivot;
        static Progress: typeof Progress;
        static RegionMap: typeof RegionMap;
        static Table: typeof Table;
        static Cards: typeof Cards;
        static TreeView: typeof TreeView;
        static TreeViewBox: typeof TreeViewBox;
        static Text: typeof Text;
        static toTotalExpression2(cell: IStiAppDataCell): string;
        static toTotalExpression(meter: StiMeter): string;
        static toTotalExpression3(meter: StiMeter, dashboard: IStiDashboard): string;
        static toSumExpression2(dataColumn: StiDataColumn): string;
        static toSumExpression(expression: string): string;
        static toCountExpression2(dataColumn: StiDataColumn): string;
        static toCountExpression(expression: string): string;
        static toExpression(cell: IStiAppDataCell): string;
        static toAlias(cell: IStiAppDataCell): string;
        static toDataType(cell: IStiAppDataCell): Type;
    }
}
export namespace Stimulsoft.Dashboard.Components.Cards {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiPadding = Stimulsoft.Report.Dashboard.StiPadding;
    import StiMargin = Stimulsoft.Report.Dashboard.StiMargin;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCardsItem implements ICloneable {
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): any;
        cornerRadius: StiCornerRadius;
        margin: StiMargin;
        padding: StiPadding;
        colorEach: boolean;
        private isDefaultMargin;
        private isDefaultPadding;
    }
}
export namespace Stimulsoft.Dashboard.Interactions {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiInteractionLayout = Stimulsoft.Report.Dashboard.IStiInteractionLayout;
    import StiAvailableInteractionOnHover = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnHover;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    class StiCardsDashboardInteraction extends StiDashboardInteraction implements IStiJsonReportObject, IStiInteractionLayout {
        implements(): any[];
        meta(): StiMeta[];
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        availableOnHover: StiAvailableInteractionOnHover;
        showFullScreenButton: boolean;
        showSaveButton: boolean;
        showViewDataButton: boolean;
        fileName: string;
        headerText: string;
        footerText: string;
        get isDefaultLayout(): boolean;
        isDefault(): boolean;
        constructor(showFullScreenButton?: boolean, showSaveButton?: boolean, showViewDataButton?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Cards {
    import IStiShowBlanks = Stimulsoft.Report.Components.IStiShowBlanks;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import IStiCardsItem = Stimulsoft.Report.Dashboard.IStiCardsItem;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiSeriesColors = Stimulsoft.Report.Dashboard.IStiSeriesColors;
    import StiCardsItem = Stimulsoft.Dashboard.Components.Cards.StiCardsItem;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiItemOrientation = Stimulsoft.Report.Dashboard.StiItemOrientation;
    import StiCardsColumn = Stimulsoft.Dashboard.Components.Cards.StiCardsColumn;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiCardsElement = Stimulsoft.Report.Dashboard.IStiCardsElement;
    import IStiSimpleShadow = Stimulsoft.Report.Components.IStiSimpleShadow;
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiCardsElement extends StiElement implements IStiCardsElement, IStiSimpleShadow, IStiTitleElement, IStiElementLayout, IStiElementInteraction, IStiCornerRadius, IStiJsonReportObject, IStiSeriesColors, IStiGlobalizationProvider, IStiShowBlanks {
        implements(): any[];
        clone(cloneProperties: boolean): any;
        meta(): StiMeta[];
        get toolboxPosition(): number;
        get localizedName(): string;
        helpUrl: string;
        dataFilters: List<StiDataFilterRule>;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        group: string;
        title: StiTitle;
        crossFiltering: boolean;
        shadow: StiSimpleShadow;
        convertFrom(element: IStiElement): void;
        layout: StiElementLayout;
        cornerRadius: StiCornerRadius;
        showBlanks: boolean;
        createMeters(source: IStiCardsElement): void;
        createMeters2(dataSource: StiDataSource): void;
        createMeter(cell: IStiAppDataCell): void;
        removeMeter(index: number): void;
        removeAllMeters(): void;
        insertMeter(index: number, meter: IStiMeter): void;
        insertNewDimension(index: number): void;
        insertNewMeasure(index: number): void;
        getMeasure(cell: IStiAppDataCell): IStiMeter;
        getDimension(cell: IStiAppDataCell): IStiMeter;
        getCards(): IStiCardsItem;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        dashboardInteraction: IStiDashboardInteraction;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        seriesColors: Color[];
        orientation: StiItemOrientation;
        columns: List<StiCardsColumn>;
        cards: StiCardsItem;
        columnCount: number;
        getNestedPages(): List<StiPage>;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    enum StiChartLabelsStyle {
        Value = 0,
        PercentOfTotal = 1,
        Category = 2,
        CategoryValue = 3,
        CategoryPercentOfTotal = 4
    }
    enum StiLegendVisibility {
        False = 0,
        Auto = 1,
        Always = 2
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiChartAreaIndicator implements IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(m: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiChartAreaIndicator;
        value: StiChartAreaIndicatorValue;
        title: StiChartAreaIndicatorTitle;
        constructor();
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiChartAreaIndicator = Stimulsoft.Dashboard.Components.Chart.StiChartAreaIndicator;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiChartArea = Stimulsoft.Report.Dashboard.IStiChartArea;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiChartArea implements IStiJsonReportObject, IStiChartArea {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiChartArea;
        sideBySide: boolean;
        colorEach: boolean;
        reverseHor: boolean;
        reverseVert: boolean;
        interlacingHor: StiHorChartInterlacing;
        interlacingVert: StiVertChartInterlacing;
        gridLinesHor: StiHorChartGridLines;
        gridLinesVert: StiVertChartGridLines;
        xAxis: StiXChartAxis;
        xTopAxis: StiXTopChartAxis;
        yAxis: StiYChartAxis;
        yRightAxis: StiYRightChartAxis;
        indicator: StiChartAreaIndicator;
        private _horSpacing;
        get horSpacing(): number;
        set horSpacing(value: number);
        private _vertSpacing;
        get vertSpacing(): number;
        set vertSpacing(value: number);
        constructor(colorEach?: boolean, reverseHor?: boolean, reverseVert?: boolean, gridLinesHor?: StiHorChartGridLines, gridLinesVert?: StiVertChartGridLines, interlacingHor?: StiHorChartInterlacing, interlacingVert?: StiVertChartInterlacing, xAxis?: StiXChartAxis, yAxis?: StiYChartAxis, xTopAxis?: StiXTopChartAxis, yRightAxis?: StiYRightChartAxis, indicator?: StiChartAreaIndicator);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiChartAreaIndicatorTitle implements IStiJsonReportObject, ICloneable {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(m: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiChartAreaIndicatorTitle;
        text: string;
        color: Color;
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiChartAreaIndicatorValue implements IStiJsonReportObject, ICloneable {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(m: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiChartAreaIndicatorValue;
        color: Color;
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiLabelsPlacement = Stimulsoft.Report.Chart.StiLabelsPlacement;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiChartAxisLabels implements ICloneable, IStiFont, IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): any;
        angle: number;
        color: Color;
        font: Font;
        placement: StiLabelsPlacement;
        textAlignment: StiHorAlignment;
        textAfter: string;
        textBefore: string;
        step: number;
        wordWrap: boolean;
        width: number;
        constructor(textBefore?: string, textAfter?: string, angle?: number, font?: Font, placement?: StiLabelsPlacement, color?: Color, textAlignment?: StiHorAlignment, width?: number, wordWrap?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiChartAxisLabels = Stimulsoft.Dashboard.Components.Chart.StiChartAxisLabels;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiChartAxis implements IStiJsonReportObject, ICloneable, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        clone(): any;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        labels: StiChartAxisLabels;
        range: StiChartAxisRange;
        visible: boolean;
        constructor(labels?: StiChartAxisLabels, range?: StiChartAxisRange, visible?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiChartAxisRange implements IStiJsonReportObject, ICloneable {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): any;
        _minimum: number;
        get minimum(): number;
        set minimum(value: number);
        maximum: number;
        auto: boolean;
        constructor(auto?: boolean, minimum?: number, maximum?: number);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IAsIs = Stimulsoft.System.IAsIs;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiTitlePosition = Stimulsoft.Report.Chart.StiTitlePosition;
    import Color = Stimulsoft.System.Drawing.Color;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    enum Order {
        Alignment = 1,
        Color = 2,
        Direction = 3,
        Font = 4,
        Placement = 5,
        Position = 6,
        Text = 7,
        Visible = 8
    }
    class StiChartAxisTitle implements IStiJsonReportObject, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): any;
        visible: boolean;
        alignment: StringAlignment;
        color: Color;
        font: Font;
        position: StiTitlePosition;
        text: string;
        constructor(font?: Font, text?: string, color?: Color, alignment?: StringAlignment, position?: StiTitlePosition, visible?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiConstantLines_StiTextPosition = Stimulsoft.Report.Chart.StiConstantLines_StiTextPosition;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiChartConstantLines = Stimulsoft.Report.Dashboard.IStiChartConstantLines;
    class StiChartConstantLines implements ICloneable, IStiChartConstantLines, IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiChartConstantLines;
        text: string;
        lineStyle: StiPenStyle;
        lineColor: Color;
        axisValue: string;
        lineWidth: number;
        position: StiConstantLines_StiTextPosition;
        static createFromJson(json: StiJson): StiChartConstantLines;
        static createFromXml(xmlNode: XmlNode): StiChartConstantLines;
        constructor(text?: string, axisValue?: string, lineColor?: Color, lineStyle?: StiPenStyle, lineWidth?: number, position?: StiConstantLines_StiTextPosition);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiMarkerType = Stimulsoft.Report.Chart.StiMarkerType;
    import StiExtendedStyleBool = Stimulsoft.Report.Chart.StiExtendedStyleBool;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiChartMarker implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiChartMarker;
        size: number;
        angle: number;
        type: StiMarkerType;
        visible: StiExtendedStyleBool;
        static createFromJson(json: StiJson): StiChartConstantLines;
        static createFromXml(xmlNode: XmlNode): StiChartConstantLines;
        constructor(size?: number);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiChartLegendTitle implements IStiJsonReportObject {
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): any;
        color: Color;
        font: Font;
        text: string;
        constructor(font?: Font, text?: string, color?: Color);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiSeriesLabelsValueType = Stimulsoft.Report.Chart.StiSeriesLabelsValueType;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiChartLegendLabels implements ICloneable, IStiFont, IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): any;
        color: Color;
        font: Font;
        valueType: StiSeriesLabelsValueType;
        constructor(font?: Font, color?: Color, valueType?: StiSeriesLabelsValueType);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiLegendDirection = Stimulsoft.Report.Chart.StiLegendDirection;
    import StiChartLegendTitle = Stimulsoft.Dashboard.Components.Chart.StiChartLegendTitle;
    import StiChartLegendLabels = Stimulsoft.Dashboard.Components.Chart.StiChartLegendLabels;
    import StiLegendVertAlignment = Stimulsoft.Report.Chart.StiLegendVertAlignment;
    import StiLegendHorAlignment = Stimulsoft.Report.Chart.StiLegendHorAlignment;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    enum Order {
        HorAlignment = 1,
        Labels = 2,
        Title = 3,
        VertAlignment = 4
    }
    class StiChartLegend implements IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): any;
        horAlignment: StiLegendHorAlignment;
        vertAlignment: StiLegendVertAlignment;
        get visible(): boolean;
        set visible(value: boolean);
        visibility: StiLegendVisibility;
        direction: StiLegendDirection;
        columns: number;
        labels: StiChartLegendLabels;
        title: StiChartLegendTitle;
        constructor(title?: StiChartLegendTitle, labels?: StiChartLegendLabels, horAlignment?: StiLegendHorAlignment, vertAlignment?: StiLegendVertAlignment, visibility?: StiLegendVisibility, direction?: StiLegendDirection, columns?: number);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import StiTitlePosition = Stimulsoft.Report.Chart.StiTitlePosition;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiDirection = Stimulsoft.Report.Chart.StiDirection;
    class StiYChartAxisTitle extends StiChartAxisTitle implements IStiJsonReportObject {
        meta(): StiMeta[];
        direction: StiDirection;
        constructor(font?: Font, text?: string, color?: Color, alignment?: StringAlignment, direction?: StiDirection, position?: StiTitlePosition, visible?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiYChartAxisTitle = Stimulsoft.Dashboard.Components.Chart.StiYChartAxisTitle;
    class StiYChartAxis extends StiChartAxis implements IStiJsonReportObject {
        clone(): any;
        meta(): StiMeta[];
        title: StiYChartAxisTitle;
        startFromZero: boolean;
        constructor(labels?: StiChartAxisLabels, title?: StiYChartAxisTitle, visible?: boolean, startFromZero?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiAutoBool = Stimulsoft.Base.StiAutoBool;
    class StiXChartAxis extends StiChartAxis implements IStiJsonReportObject {
        clone(): any;
        meta(): StiMeta[];
        title: StiXChartAxisTitle;
        showEdgeValues: StiAutoBool;
        startFromZero: StiAutoBool;
        constructor(labels?: StiChartAxisLabels, title?: StiXChartAxisTitle, visible?: boolean, startFromZero?: StiAutoBool, showEdgeValues?: StiAutoBool);
    }
}
export namespace Stimulsoft.Dashboard.Interactions {
    import StiInteractionViewsState = Stimulsoft.Report.Dashboard.StiInteractionViewsState;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiAllowUserSortingDashboardInteraction = Stimulsoft.Report.Dashboard.IStiAllowUserSortingDashboardInteraction;
    import IStiInteractionLayout = Stimulsoft.Report.Dashboard.IStiInteractionLayout;
    import StiDashboardDrillDownParameter = Stimulsoft.Dashboard.Interactions.StiDashboardDrillDownParameter;
    import List = Stimulsoft.System.Collections.List;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import IStiAllowUserDrillDownDashboardInteraction = Stimulsoft.Report.Dashboard.IStiAllowUserDrillDownDashboardInteraction;
    class StiChartDashboardInteraction extends StiDashboardInteraction implements IStiAllowUserDrillDownDashboardInteraction, IStiAllowUserSortingDashboardInteraction, IStiJsonReportObject, IStiInteractionLayout {
        implements(): any[];
        meta(): StiMeta[];
        ident: StiInteractionIdent;
        allowUserDrillDown: boolean;
        allowUserSorting: boolean;
        availableOnClick: number;
        availableOnDataManipulation: number;
        viewsState: StiInteractionViewsState;
        showFullScreenButton: boolean;
        showSaveButton: boolean;
        showViewDataButton: boolean;
        fileName: string;
        headerText: string;
        footerText: string;
        get isDefaultLayout(): boolean;
        isDefault(): boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>, allowUserDrillDown?: boolean, fileName?: string, headerText?: string, footerText?: string, showFullScreenButton?: boolean, showSaveButton?: boolean, showViewDataButton?: boolean, viewsState?: StiInteractionViewsState);
    }
}
export namespace Stimulsoft.Dashboard.Interactions {
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import List = Stimulsoft.System.Collections.List;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiDrillDownHelper {
        static isDrillAvailable(element: IStiElement): boolean;
        static isDrillUpAvailable(element: IStiElement): boolean;
        static isDrillDownAvailable(element: IStiElement): boolean;
        static drillUp(element: IStiElement): void;
        static drillDown(element: IStiElement, drillDownFilters?: List<StiDataFilterRule>): void;
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiChartTrendLineType = Stimulsoft.Report.Dashboard.StiChartTrendLineType;
    import IStiChartTrendLine = Stimulsoft.Report.Dashboard.IStiChartTrendLine;
    class StiChartTrendLine implements ICloneable, IStiChartTrendLine, IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiChartTrendLine;
        type: StiChartTrendLineType;
        lineStyle: StiPenStyle;
        lineColor: Color;
        lineWidth: number;
        keyValueMeter: string;
        static createFromJson(json: StiJson): StiChartTrendLine;
        static createFromXml(xmlNode: XmlNode): StiChartTrendLine;
        constructor(keyValueMeter?: string, type?: StiChartTrendLineType, lineColor?: Color, lineStyle?: StiPenStyle, lineWidth?: number);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiShowBlanks = Stimulsoft.Report.Components.IStiShowBlanks;
    import StiColumnShape3D = Stimulsoft.Report.Chart.StiColumnShape3D;
    import Sti3dOptions = Stimulsoft.Report.Chart.Sti3dOptions;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    import IStiSimpleShadow = Stimulsoft.Report.Components.IStiSimpleShadow;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiDataMode = Stimulsoft.Report.StiDataMode;
    import StiUserViewState = Stimulsoft.Report.Dashboard.StiUserViewState;
    import IStiUserViewStates = Stimulsoft.Report.Dashboard.IStiUserViewStates;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiMarkerType = Stimulsoft.Report.Chart.StiMarkerType;
    import StiChartMarker = Stimulsoft.Dashboard.Components.Chart.StiChartMarker;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    import IStiNegativeSeriesColors = Stimulsoft.Report.Dashboard.IStiNegativeSeriesColors;
    import IStiParetoSeriesColors = Stimulsoft.Report.Dashboard.IStiParetoSeriesColors;
    import IStiSeriesColors = Stimulsoft.Report.Dashboard.IStiSeriesColors;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiChartLegend = Stimulsoft.Dashboard.Components.Chart.StiChartLegend;
    import StiYChartAxis = Stimulsoft.Dashboard.Components.Chart.StiYChartAxis;
    import StiXChartAxis = Stimulsoft.Dashboard.Components.Chart.StiXChartAxis;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiTitle = Stimulsoft.Dashboard.Components.StiTitle;
    import StiYChartMeter = Stimulsoft.Dashboard.Components.Chart.StiYChartMeter;
    import StiSeriesChartMeter = Stimulsoft.Dashboard.Components.Chart.StiSeriesChartMeter;
    import StiWeightChartMeter = Stimulsoft.Dashboard.Components.Chart.StiWeightChartMeter;
    import StiArgumentChartMeter = Stimulsoft.Dashboard.Components.Chart.StiArgumentChartMeter;
    import StiHighValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiHighValueChartMeter;
    import StiLowValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiLowValueChartMeter;
    import StiCloseValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiCloseValueChartMeter;
    import StiEndValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiEndValueChartMeter;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiSkipOwnFilter = Stimulsoft.Report.Dashboard.IStiSkipOwnFilter;
    import IStiChartElement = Stimulsoft.Report.Dashboard.IStiChartElement;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import IStiDrillDownElement = Stimulsoft.Data.Engine.IStiDrillDownElement;
    import IStiChartConstantLines = Stimulsoft.Report.Dashboard.IStiChartConstantLines;
    import IStiChartStrips = Stimulsoft.Report.Dashboard.IStiChartStrips;
    import IStiChartElementCondition = Stimulsoft.Report.Dashboard.IStiChartElementCondition;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiChartConditionalField = Stimulsoft.Report.Chart.StiChartConditionalField;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiChartTrendLine = Stimulsoft.Report.Dashboard.IStiChartTrendLine;
    import StiChartTrendLineType = Stimulsoft.Report.Dashboard.StiChartTrendLineType;
    import StiChartTrendLine = Stimulsoft.Dashboard.Components.Chart.StiChartTrendLine;
    class StiChartElement extends StiElement implements IStiChartElement, IStiSimpleShadow, IStiCornerRadius, IStiUserViewStates, IStiSkipOwnFilter, IStiTitleElement, IStiElementLayout, IStiJsonReportObject, IStiGlobalizationProvider, IStiSeriesColors, IStiNegativeSeriesColors, IStiParetoSeriesColors, IStiElementInteraction, IStiDrillDownElement, IStiShowBlanks {
        implements(): any[];
        clone(cloneProperties: boolean): any;
        meta(): StiMeta[];
        convertToBubble(): void;
        convertFromBubble(): void;
        convertToGantt(): void;
        getChartSeriesTypes(seriesTypeStr: string): List<string>;
        getManuallyEnteredChartMeter(): IStiMeter;
        previousAnimations: List<StiAnimation>;
        sortAnimation: boolean;
        addValue(cell: IStiAppDataCell): void;
        getValue2(cell: IStiAppDataCell): IStiMeter;
        getValue(meter: IStiMeter): IStiMeter;
        getGanttStartValue(cell: IStiAppDataCell): IStiMeter;
        getGanttEndValue(cell: IStiAppDataCell): IStiMeter;
        getY(cell: IStiAppDataCell): IStiMeter;
        getX(cell: IStiAppDataCell): IStiMeter;
        fetchAllValues(): List<IStiMeter>;
        fetchAllXValues(): List<IStiMeter>;
        fetchAllYValues(): List<IStiMeter>;
        getValueByIndex(index: number): IStiMeter;
        insertValue(index: number, meter: IStiMeter): void;
        removeValue(index: number): void;
        removeAllValues(): void;
        createNewValue(): IStiMeter;
        addEndValue(cell: IStiAppDataCell): void;
        getEndValue2(cell: IStiAppDataCell): IStiMeter;
        getEndValue(meter: IStiMeter): IStiMeter;
        getEndValueByIndex(index: number): IStiMeter;
        insertEndValue(index: number, meter: IStiMeter): void;
        removeEndValue(index: number): void;
        removeAllEndValues(): void;
        createNewEndValue(): IStiMeter;
        addCloseValue(cell: IStiAppDataCell): void;
        getCloseValue2(cell: IStiAppDataCell): IStiMeter;
        getCloseValue(meter: IStiMeter): IStiMeter;
        getCloseValueByIndex(index: number): IStiMeter;
        insertCloseValue(index: number, meter: IStiMeter): void;
        removeCloseValue(index: number): void;
        removeAllCloseValues(): void;
        createNewCloseValue(): IStiMeter;
        addLowValue(cell: IStiAppDataCell): void;
        getLowValue2(cell: IStiAppDataCell): IStiMeter;
        getLowValue(meter: IStiMeter): IStiMeter;
        getLowValueByIndex(index: number): IStiMeter;
        insertLowValue(index: number, meter: IStiMeter): void;
        removeLowValue(index: number): void;
        removeAllLowValues(): void;
        createNewLowValue(): IStiMeter;
        addHighalue(cell: IStiAppDataCell): void;
        getHighValue2(cell: IStiAppDataCell): IStiMeter;
        getHighValue(meter: IStiMeter): IStiMeter;
        getHighValueByIndex(index: number): IStiMeter;
        insertHighValue(index: number, meter: IStiMeter): void;
        removeHighValue(index: number): void;
        removeAllHighValues(): void;
        createNewHighValue(): IStiMeter;
        addXValue(cell: IStiAppDataCell): void;
        getXValue2(cell: IStiAppDataCell): IStiMeter;
        getXValue(meter: IStiMeter): IStiMeter;
        getXValueByIndex(index: number): IStiMeter;
        insertXValue(index: number, meter: IStiMeter): void;
        removeXValue(index: number): void;
        removeAllXValues(): void;
        createNewXValue(): IStiMeter;
        addYValue(cell: IStiAppDataCell): void;
        getYValue2(cell: IStiAppDataCell): IStiMeter;
        getYValue(meter: IStiMeter): IStiMeter;
        getYValueByIndex(index: number): IStiMeter;
        insertYValue(index: number, meter: IStiMeter): void;
        removeYValue(index: number): void;
        removeAllYValues(): void;
        createNewYValue(): IStiMeter;
        addArgument(cell: IStiAppDataCell): void;
        getArgument2(cell: IStiAppDataCell): IStiMeter;
        getArgument(meter: IStiMeter): IStiMeter;
        fetchAllArguments(): List<IStiMeter>;
        getArgumentByIndex(index: number): IStiMeter;
        insertArgument(index: number, meter: IStiMeter): void;
        removeArgument(index: number): void;
        removeAllArguments(): void;
        createNewArgument(): void;
        addWeight(cell: IStiAppDataCell): void;
        getWeight2(cell: IStiAppDataCell): IStiMeter;
        getWeight(meter: IStiMeter): IStiMeter;
        getWeightByIndex(index: number): IStiMeter;
        insertWeight(index: number, meter: IStiMeter): void;
        removeWeight(index: number): void;
        removeAllWeights(): void;
        createNewWeight(): void;
        addSeries(cell: IStiAppDataCell): void;
        getSeries2(cell: IStiAppDataCell): IStiMeter;
        getSeries(meter: IStiMeter): IStiMeter;
        getSeries3(): IStiMeter;
        insertSeries(meter: IStiMeter): void;
        removeSeries(): void;
        createNewSeries(): void;
        addSortBy(cell: IStiAppDataCell): void;
        getSortBy2(cell: IStiAppDataCell): IStiMeter;
        getSortBy(meter: IStiMeter): IStiMeter;
        getSortBy3(): IStiMeter;
        insertSortBy(meter: IStiMeter): void;
        removeSortBy(): void;
        createNewSortBy(): void;
        addIndicatorValue(cell: IStiAppDataCell): void;
        getIndicatorValue2(cell: IStiAppDataCell): IStiMeter;
        getIndicatorValue(meter: IStiMeter): IStiMeter;
        getIndicatorValue3(): IStiMeter;
        insertIndicatorValue(meter: IStiMeter): void;
        removeIndicatorValue(): void;
        createNewIndicatorValue(): void;
        fetchConstantLines(): List<IStiChartConstantLines>;
        addConstantLine(): void;
        removeConstantLine(index: number): void;
        moveConstantLine(fromIndex: number, toIndex: number): void;
        fetchStrips(): List<IStiChartStrips>;
        addStrip(): void;
        removeStrip(index: number): void;
        moveStrip(fromIndex: number, toIndex: number): void;
        addTrendLines(keyValueMeter: string, type: StiChartTrendLineType, lineColor: Color, lineStyle: StiPenStyle, lineWidth: number): void;
        fetchTrendLines(): List<IStiChartTrendLine>;
        clearTrendLines(): void;
        addChartCondition(keyValueMeter: string, dataType: StiFilterDataType, condition: StiFilterCondition, value: string, color: Color, markerType: StiMarkerType, markerAngle: number, field: StiChartConditionalField, isExpression: boolean): void;
        fetchChartConditions(): List<IStiChartElementCondition>;
        clearChartConditions(): void;
        convertFrom(element: IStiElement): void;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        title: StiTitle;
        layout: StiElementLayout;
        group: string;
        get allowSkipOwnFilter(): boolean;
        crossFiltering: boolean;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        private _customStyleName;
        get customStyleName(): string;
        set customStyleName(value: string);
        userFilters: List<StiDataFilterRule>;
        userSorts: List<StiDataSortRule>;
        userViewStates: List<StiUserViewState>;
        selectedViewStateKey: string;
        switchSelectedViewState(newKey: string): void;
        saveToJsonForViewState(): StiJson;
        loadFromJsonForViewState(jObject: StiJson): void;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        topN: StiDataTopN;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        seriesColors: Color[];
        negativeSeriesColors: Color[];
        paretoSeriesColors: Color[];
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        dashboardInteraction: IStiDashboardInteraction;
        cornerRadius: StiCornerRadius;
        showBlanks: boolean;
        shadow: StiSimpleShadow;
        getFonts(): Font[];
        get toolboxPosition(): number;
        get localizedName(): string;
        helpUrl: string;
        cachedSmallFont: Font;
        manuallyEnteredChartMeter: StiValueChartMeter;
        get colorEach(): boolean;
        set colorEach(value: boolean);
        showViewTitle: boolean;
        values: List<StiValueChartMeter>;
        endValues: List<StiEndValueChartMeter>;
        closeValues: List<StiCloseValueChartMeter>;
        lowValues: List<StiLowValueChartMeter>;
        highValues: List<StiHighValueChartMeter>;
        arguments: List<StiArgumentChartMeter>;
        weights: List<StiWeightChartMeter>;
        xValues: List<StiXChartMeter>;
        yValues: List<StiYChartMeter>;
        series: StiSeriesChartMeter;
        sortBy: StiSortByChartMeter;
        indicatorValue: StiIndicatorValueChartMeter;
        get xAxis(): StiXChartAxis;
        set xAxis(value: StiXChartAxis);
        get xTopAxis(): StiXTopChartAxis;
        set xTopAxis(value: StiXTopChartAxis);
        get yAxis(): StiYChartAxis;
        set yAxis(value: StiYChartAxis);
        get yRightAxis(): StiYRightChartAxis;
        set yRightAxis(value: StiYRightChartAxis);
        legend: StiChartLegend;
        area: StiChartArea;
        private _labels;
        get labels(): StiChartLabels;
        set labels(value: StiChartLabels);
        argumentFormat: StiFormatService;
        valueFormat: StiFormatService;
        private static getValueFormatDefault;
        trendLines: List<StiChartTrendLine>;
        constantLines: List<StiChartConstantLines>;
        strips: List<StiChartStrips>;
        options3D: Sti3dOptions;
        chartConditions: List<StiChartElementCondition>;
        marker: StiChartMarker;
        icon: StiFontIcons;
        roundValues: boolean;
        columnShape: StiColumnShape3D;
        dataMode: StiDataMode;
        manuallyEnteredData: string;
        getManuallyEnteredDataTable(): StiDataTable;
        get isAxisAreaChart(): boolean;
        get isStackedChart(): boolean;
        get isScatterChart(): boolean;
        get isLinesChart(): boolean;
        get isBubbleChart(): boolean;
        get isBarChart(): boolean;
        get isRange(): boolean;
        get isFinancial(): boolean;
        get isPieChart(): boolean;
        get isPie3dChart(): boolean;
        get isDoughnutChart(): boolean;
        get isFunnelChart(): boolean;
        get isPictorialStackedChart(): boolean;
        get isPictorialChart(): boolean;
        get isHeatmapChart(): boolean;
        get isTreemapChart(): boolean;
        get isParetoChart(): boolean;
        get isRibbonChart(): boolean;
        get isSunburstChart(): boolean;
        get isFullStackedChart(): boolean;
        get isWaterfallChart(): boolean;
        get isRadarChart(): boolean;
        get isAxisAreaChart3D(): boolean;
        get isClusteredColumnChart3D(): boolean;
        get isClusteredColumnChart(): boolean;
        get isClusteredBarChart(): boolean;
        get isLineChart3D(): boolean;
        getNestedPages(): List<StiPage>;
        drillDownFiltersList: List<List<StiDataFilterRule>>;
        drillDownFilters: List<StiDataFilterRule>;
        drillDownCurrentLevel: number;
        get drillDownLevelCount(): number;
        checkBrowsableProperties(): void;
        private setBrowsableProperty;
        getChartSeries(): IStiSeries;
        chartValuesList(): List<StiValueChartMeter>;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiChartElementCondition = Stimulsoft.Report.Dashboard.IStiChartElementCondition;
    import StiMarkerType = Stimulsoft.Report.Chart.StiMarkerType;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiChartConditionalField = Stimulsoft.Report.Chart.StiChartConditionalField;
    class StiChartElementCondition implements ICloneable, IStiChartElementCondition, IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiChartElementCondition;
        color: Color;
        markerAngle: number;
        markerType: StiMarkerType;
        condition: StiFilterCondition;
        dataType: StiFilterDataType;
        value: string;
        keyValueMeter: string;
        field: StiChartConditionalField;
        isExpression: boolean;
        static createFromJson(json: StiJson): StiChartElementCondition;
        static createFromXml(xmlNode: XmlNode): StiChartElementCondition;
        constructor(keyValueMeter?: string, color?: Color, dataType?: StiFilterDataType, condition?: StiFilterCondition, value?: string, markerType?: StiMarkerType, markerAngle?: number, field?: StiChartConditionalField, isExpression?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiChartGridLines implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiChartGridLines;
        color: Color;
        visible: boolean;
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiChartInterlacing implements ICloneable, IStiJsonReportObject {
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiChartInterlacing;
        color: Color;
        visible: boolean;
        constructor(color?: Color, visible?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiChartLabels = Stimulsoft.Report.Dashboard.IStiChartLabels;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiChartLabelsPosition = Stimulsoft.Report.Dashboard.StiChartLabelsPosition;
    class StiChartLabels implements IStiJsonReportObject, IStiChartLabels {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiChartLabels;
        get position(): StiChartLabelsPosition;
        set position(value: StiChartLabelsPosition);
        axisPosition: StiChartLabelsPosition;
        piePosition: StiChartLabelsPosition;
        pie3dPosition: StiChartLabelsPosition;
        clusteredColumn3dPosition: StiChartLabelsPosition;
        line3dPosition: StiChartLabelsPosition;
        doughnutPosition: StiChartLabelsPosition;
        funnelPosition: StiChartLabelsPosition;
        pictorialStackedPosition: StiChartLabelsPosition;
        heatmapPosition: StiChartLabelsPosition;
        treemapPosition: StiChartLabelsPosition;
        radarPosition: StiChartLabelsPosition;
        foreColor: Color;
        font: Font;
        autoRotate: boolean;
        style: StiChartLabelsStyle;
        textAfter: string;
        textBefore: string;
        wordWrap: boolean;
        width: number;
        element: StiChartElement;
        constructor(axisPosition?: StiChartLabelsPosition, piePosition?: StiChartLabelsPosition, doughnutPosition?: StiChartLabelsPosition, funnelPosition?: StiChartLabelsPosition, treemapPosition?: StiChartLabelsPosition, heatmapPosition?: StiChartLabelsPosition, radarPosition?: StiChartLabelsPosition, clusteredColumn3dPosition?: StiChartLabelsPosition, style?: StiChartLabelsStyle, font?: Font, foreColor?: Color, textBefore?: string, textAfter?: string, autoRotate?: boolean, width?: number, wordWrap?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiChartStrips = Stimulsoft.Report.Dashboard.IStiChartStrips;
    import StiStrips_StiOrientation = Stimulsoft.Report.Chart.StiStrips_StiOrientation;
    class StiChartStrips implements ICloneable, IStiChartStrips, IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiChartStrips;
        text: string;
        titleColor: Color;
        stripBrush: StiBrush;
        orientation: StiStrips_StiOrientation;
        minValue: string;
        maxValue: string;
        static createFromJson(json: StiJson): StiChartStrips;
        static createFromXml(xmlNode: XmlNode): StiChartStrips;
        constructor(text?: string, minValue?: string, maxValue?: string, titleColor?: Color, stripBrush?: StiBrush, orientation?: StiStrips_StiOrientation);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    class StiChartUserViewStatesHelper {
        static saveToJsonObject(chart: StiChartElement): StiJson;
        static loadFromJsonObject(chart: StiChartElement, jObject: StiJson): void;
        static clearVisualState(chart: StiChartElement): void;
        static switchSelectedViewState(chart: StiChartElement, newKey: string): void;
        static saveVisualState(chart: StiChartElement, key: string): void;
        static loadVisualState(chart: StiChartElement, key: string): void;
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiLabelsPlacement = Stimulsoft.Report.Chart.StiLabelsPlacement;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    class StiChartYRightAxisLabels extends StiChartAxisLabels {
        meta(): StiMeta[];
        textAlignment: StiHorAlignment;
        constructor(textBefore?: string, textAfter?: string, angle?: number, font?: Font, placement?: StiLabelsPlacement, color?: Color, textAlignment?: StiHorAlignment);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiHorChartGridLines extends StiChartGridLines {
        meta(): StiMeta[];
        visible: boolean;
        constructor(color?: Color, visible?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiHorChartInterlacing extends StiChartInterlacing {
        constructor(color?: Color, visible?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiChartSeriesType = Stimulsoft.Report.Dashboard.StiChartSeriesType;
    class StiStartValueChartMeter extends StiValueChartMeter {
        seriesType: StiChartSeriesType;
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, seriesType?: StiChartSeriesType);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiVertChartGridLines extends StiChartGridLines {
        meta(): StiMeta[];
        visible: boolean;
        constructor(color?: Color, visible?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiVertChartInterlacing extends StiChartInterlacing {
        constructor(color?: Color, visible?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import StiTitlePosition = Stimulsoft.Report.Chart.StiTitlePosition;
    import StiDirection = Stimulsoft.Report.Chart.StiDirection;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiXChartAxisTitle extends StiChartAxisTitle implements IStiJsonReportObject {
        meta(): StiMeta[];
        direction: StiDirection;
        constructor(font?: Font, text?: string, color?: Color, alignment?: StringAlignment, direction?: StiDirection, position?: StiTitlePosition, visible?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiXTopChartAxis extends StiXChartAxis {
        meta(): StiMeta[];
        visible: boolean;
        constructor(labels?: StiChartAxisLabels, title?: StiXChartAxisTitle, visible?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiYRightChartAxis extends StiYChartAxis {
        meta(): StiMeta[];
        visible: boolean;
        labels: StiChartYRightAxisLabels;
        constructor(labels?: StiChartAxisLabels, title?: StiYChartAxisTitle, visible?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Design {
    class StiMeterConverter {
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    class StiValueChartMeterConverter extends StiMeterConverter {
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart.Design {
    class StiXChartAxisConverter {
    }
}
export namespace Stimulsoft.Dashboard.Components.Chart.Design {
    class StiYChartAxisConverter {
    }
}
export namespace Stimulsoft.Dashboard.Interactions {
    import List = Stimulsoft.System.Collections.List;
    import StiDashboardDrillDownParameter = Stimulsoft.Dashboard.Interactions.StiDashboardDrillDownParameter;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiAvailableInteractionOnDataManipulation = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnDataManipulation;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    import StiAvailableInteractionOnHover = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnHover;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    class StiFilterDashboardInteraction extends StiDashboardInteraction {
        ident: StiInteractionIdent;
        availableOnHover: StiAvailableInteractionOnHover;
        availableOnClick: StiAvailableInteractionOnClick;
        availableOnDataManipulation: StiAvailableInteractionOnDataManipulation;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, toolTip?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>);
    }
}
export namespace Stimulsoft.Dashboard.Components.ComboBox {
    import StiFilterInclusionMode = Stimulsoft.Report.Dashboard.StiFilterInclusionMode;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    import IStiSimpleShadow = Stimulsoft.Report.Components.IStiSimpleShadow;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import Size = Stimulsoft.System.Drawing.Size;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import Color = Stimulsoft.System.Drawing.Color;
    import List = Stimulsoft.System.Collections.List;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiItemSelectionMode = Stimulsoft.Report.Dashboard.StiItemSelectionMode;
    import IStiFixedHeightElement = Stimulsoft.Report.Dashboard.IStiFixedHeightElement;
    import IStiComboBoxElement = Stimulsoft.Report.Dashboard.IStiComboBoxElement;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    class StiComboBoxElement extends StiElement implements IStiSimpleShadow, IStiCornerRadius, IStiComboBoxElement, IStiFixedHeightElement, IStiJsonReportObject, IStiElementInteraction {
        implements(): any[];
        meta(): StiMeta[];
        clone(cloneProperties: boolean): any;
        group: string;
        get isFixedHeight(): boolean;
        getParentKey(): string;
        setParentKey(key: string): void;
        applyDefaultFilters(): Promise<void>;
        getIdentityFilters(): List<StiDataFilterRule>;
        inclusionMode: StiFilterInclusionMode;
        userFilters: List<StiDataFilterRule>;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        dashboardInteraction: IStiDashboardInteraction;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        font: Font;
        shadow: StiSimpleShadow;
        cornerRadius: StiCornerRadius;
        foreColor: Color;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        showAllValue: boolean;
        showBlanks: boolean;
        selectionMode: StiItemSelectionMode;
        selectedValue: any;
        selectedKey: string;
        selectedLabel: string;
        selectedIndex: number;
        addKeyMeter2(cell: IStiAppDataCell): void;
        addKeyMeter(meter: IStiMeter): void;
        getKeyMeter(): IStiMeter;
        removeKeyMeter(): void;
        createNewKeyMeter(): void;
        addNameMeter2(cell: IStiAppDataCell): void;
        addNameMeter(meter: IStiMeter): void;
        getNameMeter(): IStiMeter;
        removeNameMeter(): void;
        createNewNameMeter(): void;
        createNextMeter(cell: IStiAppDataCell): void;
        convertFrom(element: IStiElement): void;
        textFormat: StiFormatService;
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        getMinSize(): Size;
        setMinSize(value: Size): void;
        getMaxSize(): Size;
        setMaxSize(value: Size): void;
        helpUrl: string;
        private _fixedHeight;
        get fixedHeight(): boolean;
        set fixedHeight(value: boolean);
        parentKey: string;
        initialValue: string;
        nameMeter: StiNameComboBoxMeter;
        keyMeter: StiKeyComboBoxMeter;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Components.ComboBox {
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import List = Stimulsoft.System.Collections.List;
    class StiComboBoxHelper {
        static fetchItems(comboBoxElement: StiComboBoxElement, dataTable: StiDataTable, showBlanks: boolean): List<StiComboBoxItem>;
        static isBlank(data: any): boolean;
        static fetchDefaultUserFilters(comboBoxElement: StiComboBoxElement): Promise<List<StiDataFilterRule>>;
        private static fetchInitialValues;
        static getInitialValues(element: StiComboBoxElement): List<string>;
        private static getNameMeterIndex;
        private static getKeyMeterIndex;
        static getKeyMeterExpression(comboBoxElement: StiComboBoxElement): string;
        private static format;
    }
}
export namespace Stimulsoft.Dashboard.Components.ComboBox {
    class StiComboBoxItem {
        label: string;
        value: any;
        toString(): string;
        constructor(label: string, value?: any);
    }
}
export namespace Stimulsoft.Dashboard.Components.DatePicker {
    import StiFilterInclusionMode = Stimulsoft.Report.Dashboard.StiFilterInclusionMode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    import IStiSimpleShadow = Stimulsoft.Report.Components.IStiSimpleShadow;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInitialDateRangeSelection = Stimulsoft.Report.Dashboard.StiInitialDateRangeSelection;
    import StiInitialDateRangeSelectionSource = Stimulsoft.Report.Dashboard.StiInitialDateRangeSelectionSource;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDateSelectionMode = Stimulsoft.Report.Dashboard.StiDateSelectionMode;
    import StiDateCondition = Stimulsoft.Report.Dashboard.StiDateCondition;
    import Size = Stimulsoft.System.Drawing.Size;
    import StiValueDatePickerMeter = Stimulsoft.Dashboard.Components.DatePicker.StiValueDatePickerMeter;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import List = Stimulsoft.System.Collections.List;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiGroupElement = Stimulsoft.Report.Dashboard.IStiGroupElement;
    import IStiFixedHeightElement = Stimulsoft.Report.Dashboard.IStiFixedHeightElement;
    import IStiDatePickerElement = Stimulsoft.Report.Dashboard.IStiDatePickerElement;
    class StiDatePickerElement extends StiElement implements IStiDatePickerElement, IStiCornerRadius, IStiSimpleShadow, IStiFixedHeightElement, IStiGroupElement, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        clone(cloneProperties: boolean): any;
        group: string;
        get isFixedHeight(): boolean;
        getParentKey(): string;
        setParentKey(key: string): void;
        applyDefaultFilters(): Promise<void>;
        getIdentityFilters(): List<StiDataFilterRule>;
        inclusionMode: StiFilterInclusionMode;
        userFilters: List<StiDataFilterRule>;
        dataFilters: List<StiDataFilterRule>;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        selectedValue: any;
        selectedKey: string;
        selectedLabel: string;
        selectedIndex: number;
        font: Font;
        foreColor: Color;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        addValueMeter2(cell: IStiAppDataCell): void;
        addValueMeter(meter: IStiMeter): void;
        getValueMeter(): IStiMeter;
        removeValueMeter(): void;
        createNewValueMeter(): void;
        convertFrom(element: IStiElement): void;
        shadow: StiSimpleShadow;
        cornerRadius: StiCornerRadius;
        textFormat: StiFormatService;
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        getMinSize(): Size;
        setMinSize(value: Size): void;
        getMaxSize(): Size;
        setMaxSize(value: Size): void;
        helpUrl: string;
        private _fixedHeight;
        get fixedHeight(): boolean;
        set fixedHeight(value: boolean);
        condition: StiDateCondition;
        selectionMode: StiDateSelectionMode;
        valueMeter: StiValueDatePickerMeter;
        initialRangeSelection: StiInitialDateRangeSelection;
        initialRangeSelectionSource: StiInitialDateRangeSelectionSource;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Components.DatePicker {
    import IStiAppVariable = Stimulsoft.Base.IStiAppVariable;
    import IStiDatePickerElement = Stimulsoft.Report.Dashboard.IStiDatePickerElement;
    import StiDataFilterCondition = Stimulsoft.Data.Engine.StiDataFilterCondition;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiInitialDateRangeSelection = Stimulsoft.Report.Dashboard.StiInitialDateRangeSelection;
    import DateTime = Stimulsoft.System.DateTime;
    import List = Stimulsoft.System.Collections.List;
    class StiDatePickerHelper {
        static calculateRangeFromInitial(selection: StiInitialDateRangeSelection, start: {
            ref: DateTime;
        }, end: {
            ref: DateTime;
        }): void;
        static fetchDefaultUserFilters(datePickerElement: StiDatePickerElement): Promise<List<StiDataFilterRule>>;
        private static getSingleDefaultUserFilters;
        private static getRangeDefaultUserFilters;
        private static getAutoRangeDefaultUserFilters;
        static getValueMeterExpression(datePickerElement: StiDatePickerElement): string;
        static getCondition(datePickerElement: StiDatePickerElement): StiDataFilterCondition;
        static getFormatedDate(dateTime: DateTime): string;
        static getVariableSpecifiedAsValue(element: IStiDatePickerElement): IStiAppVariable;
        static isVariableSpecifiedAsValue(element: IStiDatePickerElement): boolean;
        static getDefaultValue(element: IStiDatePickerElement): any;
    }
}
export namespace Stimulsoft.Dashboard.Components.Design {
    class StiElementEditorConsts {
        elementEditor: string;
        textFormatEditor: string;
    }
}
export namespace Stimulsoft.Dashboard.Components.Design {
    class StiElementLayoutConverter {
    }
}
export namespace Stimulsoft.Dashboard.Components.Design {
    class StiElementStyleConverter {
    }
}
export namespace Stimulsoft.Dashboard.Components.Design {
    class StiMeterListConverter {
    }
}
export namespace Stimulsoft.Dashboard.Components.Design {
    class StiTitleConverter {
    }
}
export namespace Stimulsoft.Dashboard.Render {
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    import StiElement = Stimulsoft.Dashboard.Components.StiElement;
    import StiReport = Stimulsoft.Report.StiReport;
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiElementBuilder {
        protected storedCulture: CultureInfo;
        protected getSeriesKeysLimitCount(element: StiElement): number;
        protected getSeries(table: StiDataTable, seriesIndex: number, seriesKey: any, report: StiReport, shortValue?: boolean): string;
        protected getValue(table: StiDataTable, valueIndex: number, seriesIndex: number, seriesCount: number, seriesKey: string, dateTimeMode?: boolean): number;
        protected getTarget(table: StiDataTable, targetIndex: number, seriesIndex: number, seriesCount: number, seriesKey: string, dateTimeMode?: boolean): number;
        protected getNullableTarget(table: StiDataTable, targetIndex: number, seriesIndex: number, seriesCount: number, seriesKey: string, dateTimeMode?: boolean): number;
        protected getNullableValue(table: StiDataTable, valueIndex: number, seriesIndex: number, seriesCount: number, seriesKey: string): number;
        protected getSeriesKeyValues(table: StiDataTable, seriesIndex: number, count?: number): List<any>;
        protected getSeriesKeys(table: StiDataTable, seriesIndex: number, count?: number): List<string>;
        private replaceDbNull;
        protected toString(value: any): string;
        protected toReadableString(value: any, report: StiReport): string;
    }
}
export namespace Stimulsoft.Dashboard.Components.Gauge {
    import IStiMinGaugeMeter = Stimulsoft.Base.Meters.IStiMinGaugeMeter;
    class StiMinGaugeMeter extends StiMeasureMeter implements IStiMinGaugeMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Gauge {
    import IStiMaxGaugeMeter = Stimulsoft.Base.Meters.IStiMaxGaugeMeter;
    class StiMaxGaugeMeter extends StiMeasureMeter implements IStiMaxGaugeMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Visuals.Gauge {
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    class StiGaugeIteration {
        gauge: StiGauge;
        series: string;
        value: number;
        target: number;
    }
}
export namespace Stimulsoft.Dashboard.Render {
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import Size = Stimulsoft.System.Drawing.Size;
    import StiGaugeElement = Stimulsoft.Dashboard.Components.Gauge.StiGaugeElement;
    import StiGaugeIteration = Stimulsoft.Dashboard.Visuals.Gauge.StiGaugeIteration;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiGaugeElementBuilder extends StiElementBuilder {
        private findMinMaxValues;
        render(element: StiGaugeElement, size: Size, dataTable: StiDataTable): Promise<List<StiGaugeIteration>>;
        render2(element: StiGaugeElement, size: Size, dataTable: StiDataTable): () => Promise<List<StiGaugeIteration>>;
        private fundActualValues;
        private getSummary;
        private static setStyle;
        private static getTargetBrush;
        private static getTickMarkBrush;
        private static getTickLabelBrush;
        private createScale;
        private static calculateMinorInterval;
        private createFullCircularScale;
        createHalfCircularScale(element: StiGaugeElement, dateTimeMode: boolean, skipRotateLabels: boolean, size: SizeD, minValue: number, maxValue: number, target?: number): Promise<StiScaleBase>;
        createLinearScale(element: StiGaugeElement, dateTimeMode: boolean, minValue: number, maxValue: number, isHorizontal: boolean, target: number): Promise<StiScaleBase>;
        private static addRadialRanges;
        createBullet(element: StiGaugeElement, dateTimeMode: boolean, minValue: number, maxValue: number, target?: number): Promise<StiScaleBase>;
        private static addLinearRanges;
        private getMinValue;
        private getMaxValue;
        private getValueMeterIndex;
        private getMinMeterIndex;
        private getMaxMeterIndex;
        private getSeriesMeterIndex;
        private getTargetMeterIndex;
        private static getSmallElementFont;
    }
}
export namespace Stimulsoft.Dashboard.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiGaugeRange = Stimulsoft.Report.Dashboard.IStiGaugeRange;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiGaugeRange implements IStiJsonReportObject, IStiGaugeRange, ICloneable {
        implements(): any[];
        clone(): any;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        private currentCulture;
        color: Color;
        get start(): number;
        set start(value: number);
        get end(): number;
        set end(value: number);
        startExpression: string;
        endExpression: string;
        static loadFromJson(json: StiJson): StiGaugeRange;
        static loadFromXml(xmlNode: XmlNode): StiGaugeRange;
        saveToString(): string;
        getStringRepresentation(): string;
        constructor(color?: Color, startExpression?: string, endExpression?: string);
    }
}
export namespace Stimulsoft.Dashboard.Interactions {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiInteractionLayout = Stimulsoft.Report.Dashboard.IStiInteractionLayout;
    import StiAvailableInteractionOnDataManipulation = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnDataManipulation;
    import StiAvailableInteractionOnHover = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnHover;
    import IStiAllowUserSortingDashboardInteraction = Stimulsoft.Report.Dashboard.IStiAllowUserSortingDashboardInteraction;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    class StiGaugeDashboardInteraction extends StiDashboardInteraction implements IStiAllowUserSortingDashboardInteraction, IStiJsonReportObject, IStiInteractionLayout {
        implements(): any[];
        meta(): StiMeta[];
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        availableOnHover: StiAvailableInteractionOnHover;
        availableOnDataManipulation: StiAvailableInteractionOnDataManipulation;
        allowUserSorting: boolean;
        allowUserDrillDown: boolean;
        onClick: StiInteractionOnClick;
        showFullScreenButton: boolean;
        showSaveButton: boolean;
        showViewDataButton: boolean;
        fileName: string;
        headerText: string;
        footerText: string;
        get isDefaultLayout(): boolean;
        isDefault(): boolean;
        constructor(fileName?: string, headerText?: string, footerText?: string, showFullScreenButton?: boolean, showSaveButton?: boolean, allowUserSorting?: boolean, showViewDataButton?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiLabelRotationMode = Stimulsoft.Report.Gauge.StiLabelRotationMode;
    import StiLabelPlacement = Stimulsoft.Report.Dashboard.StiLabelPlacement;
    import IStiGaugeLabels = Stimulsoft.Report.Dashboard.IStiGaugeLabels;
    class StiGaugeLabels implements IStiJsonReportObject, IStiGaugeLabels {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiGaugeLabels;
        visible: boolean;
        placement: StiLabelPlacement;
        rotationMode: StiLabelRotationMode;
        constructor(visible?: boolean, placement?: StiLabelPlacement, rotationMode?: StiLabelRotationMode);
    }
}
export namespace Stimulsoft.Dashboard.Components.Gauge {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    import IStiGaugeTarget = Stimulsoft.Report.Dashboard.IStiGaugeTarget;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiGaugeTarget implements IStiJsonReportObject, IStiGaugeTarget {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): StiGaugeTarget;
        showLabel: boolean;
        placement: StiPlacement;
        constructor(showLabel?: boolean, placement?: StiPlacement);
    }
}
export namespace Stimulsoft.Dashboard.Components.Gauge {
    import DateTime = Stimulsoft.System.DateTime;
    import IStiShowBlanks = Stimulsoft.Report.Components.IStiShowBlanks;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    import IStiSimpleShadow = Stimulsoft.Report.Components.IStiSimpleShadow;
    import StiGaugeTarget = Stimulsoft.Dashboard.Components.Gauge.StiGaugeTarget;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiDataMode = Stimulsoft.Report.StiDataMode;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import IStiGauge = Stimulsoft.Report.Components.Gauge.IStiGauge;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeRange = Stimulsoft.Dashboard.Components.Gauge.StiGaugeRange;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import List = Stimulsoft.System.Collections.List;
    import StiTitle = Stimulsoft.Dashboard.Components.StiTitle;
    import Size = Stimulsoft.System.Drawing.Size;
    import IStiGaugeRange = Stimulsoft.Report.Dashboard.IStiGaugeRange;
    import StiSeriesGaugeMeter = Stimulsoft.Dashboard.Components.Gauge.StiSeriesGaugeMeter;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiGaugeElement = Stimulsoft.Report.Dashboard.IStiGaugeElement;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiGaugeLabels = Stimulsoft.Dashboard.Components.Gauge.StiGaugeLabels;
    import IStiNumberFormat = Stimulsoft.Report.Components.IStiNumberFormat;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiGaugeElement extends StiElement implements IStiGaugeElement, IStiSimpleShadow, IStiCornerRadius, IStiTitleElement, IStiFont, IStiForeColor, IStiNumberFormat, IStiElementLayout, IStiElementInteraction, IStiJsonReportObject, IStiGlobalizationProvider, IStiShowBlanks {
        implements(): any[];
        clone(cloneProperties: boolean): any;
        meta(): StiMeta[];
        addValue2(cell: IStiAppDataCell): void;
        addValue(meter: IStiMeter): void;
        removeValue(): void;
        getValue(): IStiMeter;
        getValue2(meter: IStiMeter): IStiMeter;
        createNewValue(): void;
        addSeries2(cell: IStiAppDataCell): void;
        addSeries(meter: IStiMeter): void;
        removeSeries(): void;
        getSeries(): IStiMeter;
        getSeries2(meter: IStiMeter): IStiMeter;
        createNewSeries(): void;
        addTarget2(cell: IStiAppDataCell): void;
        addTarget(meter: IStiMeter): void;
        removeTarget(): void;
        getTarget(): IStiMeter;
        getTarget2(meter: IStiMeter): IStiMeter;
        createNewTarget(): void;
        getRanges(): List<IStiGaugeRange>;
        private getPreferedColor;
        addRange(): IStiGaugeRange;
        removeRange(index: number): void;
        createdDefaultRanges(): void;
        dataMode: StiDataMode;
        manuallyEnteredData: string;
        getManuallyEnteredDataTable(): StiDataTable;
        getGaugeComponent(size?: Size): Promise<IStiGauge>;
        previousAnimations: List<StiAnimation>;
        convertFrom(element: IStiElement): void;
        group: string;
        title: StiTitle;
        layout: StiElementLayout;
        crossFiltering: boolean;
        shadow: StiSimpleShadow;
        cornerRadius: StiCornerRadius;
        showBlanks: boolean;
        dateTimeMode: boolean;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        cachedSmallFont: Font;
        font: Font;
        foreColor: Color;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        userSorts: List<StiDataSortRule>;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        get toolboxPosition(): number;
        get localizedName(): string;
        helpUrl: string;
        dashboardInteraction: IStiDashboardInteraction;
        valueFormat: StiFormatService;
        private static getValueFormatDefault;
        shortValue: boolean;
        labels: StiGaugeLabels;
        targetSettings: StiGaugeTarget;
        value: StiValueGaugeMeter;
        series: StiSeriesGaugeMeter;
        target: StiTargetGaugeMeter;
        get minimum(): number;
        set minimum(value: number);
        get maximum(): number;
        set maximum(value: number);
        minimumValue: string;
        maximumValue: string;
        minimumDateTime: DateTime;
        maximumDateTime: DateTime;
        calculationMode: Report.Gauge.StiGaugeCalculationMode;
        rangeMode: Report.Gauge.StiGaugeRangeMode;
        rangeType: Report.Gauge.StiGaugeRangeType;
        type: Report.Gauge.StiGaugeType;
        ranges: List<StiGaugeRange>;
        isSampleForStyles: boolean;
        getMinimumValue(): number;
        getMaximumValue(): number;
        getNestedPages(): List<StiPage>;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Components.Gauge.Design {
    class StiGaugeRangeConverter {
    }
}
export namespace Stimulsoft.Dashboard.Components.Text {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiTextMeter extends StiDimensionMeter implements IStiValueMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Image {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiImageMeter extends StiDimensionMeter implements IStiValueMeter {
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.WebContent {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiWebContentMeter extends StiDimensionMeter implements IStiValueMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.Helpers {
    class StiMeterCreator {
        static neww(identName: string): StiMeter;
        static neww2(ident: StiMeterIdent): StiMeter;
    }
}
export namespace Stimulsoft.Dashboard.Components.Helpers {
    class StiMeterJsonConverter {
    }
}
export namespace Stimulsoft.Dashboard.Interactions {
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import List = Stimulsoft.System.Collections.List;
    class StiImageDashboardInteraction extends StiDashboardInteraction {
        ident: StiInteractionIdent;
        availableOnClick: number;
        onClick: StiInteractionOnClick;
        isDefault(): boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>);
    }
}
export namespace Stimulsoft.Dashboard.Components.Image {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    import IStiSimpleShadow = Stimulsoft.Report.Components.IStiSimpleShadow;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import List = Stimulsoft.System.Collections.List;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import Image = Stimulsoft.System.Drawing.Image;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiImageElement = Stimulsoft.Report.Dashboard.IStiImageElement;
    import IStiVertAlignment = Stimulsoft.Report.Components.IStiVertAlignment;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiImageElement extends StiElement implements IStiHorAlignment, IStiVertAlignment, IStiImageElement, IStiCornerRadius, IStiSimpleShadow, IStiTitleElement, IStiJsonReportObject, IStiGlobalizationProvider, IStiElementInteraction {
        implements(): any[];
        clone(cloneProperties: boolean): any;
        meta(): StiMeta[];
        get isDefined(): boolean;
        get isQuerable(): boolean;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        group: string;
        title: StiTitle;
        get imageToDraw(): Promise<Image>;
        image: Image;
        imageHyperlink: string;
        aspectRatio: boolean;
        icon: StiFontIcons;
        iconColor: Color;
        crossFiltering: boolean;
        copyAllImageProperties(image: IStiImageElement): void;
        horAlignment: StiHorAlignment;
        vertAlignment: StiVertAlignment;
        get style(): string;
        set style(value: string);
        setString(propertyName: string, value: string): void;
        dashboardInteraction: IStiDashboardInteraction;
        shadow: StiSimpleShadow;
        cornerRadius: StiCornerRadius;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        getNestedPages(): List<StiPage>;
        resetAllImageProperties(): void;
        get isHyperlinkExpressionOrHyperlinkDataColumnDefined(): boolean;
        get isImageDefined(): boolean;
        get isImageIconDefined(): boolean;
        get isImageHyperlinkDefined(): boolean;
        get isImageHyperlinkExpressionDefined(): boolean;
        get isImageHyperlinkDataColumnDefined(): boolean;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Components.Image.Design {
    class StiImageBytesConverter {
    }
}
export namespace Stimulsoft.Dashboard.Interactions {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiInteractionLayout = Stimulsoft.Report.Dashboard.IStiInteractionLayout;
    import StiAvailableInteractionOnDataManipulation = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnDataManipulation;
    import IStiAllowUserSortingDashboardInteraction = Stimulsoft.Report.Dashboard.IStiAllowUserSortingDashboardInteraction;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import List = Stimulsoft.System.Collections.List;
    class StiIndicatorDashboardInteraction extends StiDashboardInteraction implements IStiAllowUserSortingDashboardInteraction, IStiJsonReportObject, IStiInteractionLayout {
        implements(): any[];
        meta(): StiMeta[];
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        availableOnDataManipulation: StiAvailableInteractionOnDataManipulation;
        allowUserDrillDown: boolean;
        allowUserSorting: boolean;
        onClick: StiInteractionOnClick;
        showFullScreenButton: boolean;
        showSaveButton: boolean;
        showViewDataButton: boolean;
        fileName: string;
        headerText: string;
        footerText: string;
        get isDefaultLayout(): boolean;
        isDefault(): boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>, allowUserDrillDown?: boolean, allowUserSorting?: boolean, fileName?: string, headerText?: string, footerText?: string, showFullScreenButton?: boolean, showSaveButton?: boolean, showViewDataButton?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Indicator {
    import IStiShowBlanks = Stimulsoft.Report.Components.IStiShowBlanks;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    import IStiSimpleShadow = Stimulsoft.Report.Components.IStiSimpleShadow;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiDataMode = Stimulsoft.Report.StiDataMode;
    import StiIndicatorIconRangeMode = Stimulsoft.Report.Dashboard.StiIndicatorIconRangeMode;
    import StiIndicatorIconMode = Stimulsoft.Report.Dashboard.StiIndicatorIconMode;
    import IStiAllowSortByVariation = Stimulsoft.Data.Engine.IStiAllowSortByVariation;
    import StiTargetMode = Stimulsoft.Report.Dashboard.StiTargetMode;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import StiIndicatorConditionPermissions = Stimulsoft.Report.Dashboard.StiIndicatorConditionPermissions;
    import StiIndicatorFieldCondition = Stimulsoft.Report.Dashboard.StiIndicatorFieldCondition;
    import IStiIndicatorElementCondition = Stimulsoft.Report.Dashboard.IStiIndicatorElementCondition;
    import StiIconAlignment = Stimulsoft.Report.Dashboard.StiIconAlignment;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiFontIconSet = Stimulsoft.Report.Helpers.StiFontIconSet;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import List = Stimulsoft.System.Collections.List;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiValueIndicatorMeter = Stimulsoft.Dashboard.Components.Indicator.StiValueIndicatorMeter;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiIndicatorElement = Stimulsoft.Report.Dashboard.IStiIndicatorElement;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import StiFontSizeMode = Stimulsoft.Report.Dashboard.StiFontSizeMode;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import IStiIndicatorIconRange = Stimulsoft.Report.Dashboard.IStiIndicatorIconRange;
    import StiIndicatorValueType = Stimulsoft.Report.Dashboard.StiIndicatorValueType;
    class StiIndicatorElement extends StiElement implements IStiTextFormat, IStiIndicatorElement, IStiCornerRadius, IStiSimpleShadow, IStiTitleElement, IStiFont, IStiForeColor, IStiElementLayout, IStiElementInteraction, IStiJsonReportObject, IStiGlobalizationProvider, IStiAllowSortByVariation, IStiShowBlanks {
        implements(): any[];
        clone(cloneProperties: boolean): any;
        meta(): StiMeta[];
        group: string;
        shadow: StiSimpleShadow;
        cornerRadius: StiCornerRadius;
        addValue2(cell: IStiAppDataCell): void;
        addValue(meter: IStiMeter): void;
        removeValue(): void;
        getValue(): IStiMeter;
        getValue2(meter: IStiMeter): IStiMeter;
        createNewValue(): void;
        addTarget2(cell: IStiAppDataCell): void;
        addTarget(meter: IStiMeter): void;
        removeTarget(): void;
        getTarget(): IStiMeter;
        getTarget2(meter: IStiMeter): IStiMeter;
        createNewTarget(): void;
        addSeries2(cell: IStiAppDataCell): void;
        addSeries(meter: IStiMeter): void;
        removeSeries(): void;
        getSeries(): IStiMeter;
        getSeries2(meter: IStiMeter): IStiMeter;
        createNewSeries(): void;
        getIconRanges(): List<IStiIndicatorIconRange>;
        addRange(): IStiIndicatorIconRange;
        removeRange(index: number): void;
        createdDefaultRanges(): void;
        dataMode: StiDataMode;
        manuallyEnteredData: string;
        getManuallyEnteredDataTable(): StiDataTable;
        addIndicatorCondition(field: StiIndicatorFieldCondition, condition: StiFilterCondition, value: string, icon: StiFontIcons, iconColor: Color, targetIcon: StiFontIcons, targetIconColor: Color, customIcon: [], iconAlignment: StiIconAlignment, targetIconAlignment: StiIconAlignment, permissions: StiIndicatorConditionPermissions, font: Font, textColor: Color, backColor: Color): void;
        fetchIndicatorConditions(): List<IStiIndicatorElementCondition>;
        clearIndicatorConditions(): void;
        convertFrom(element: IStiElement): void;
        textFormat: StiFormatService;
        font: Font;
        foreColor: Color;
        showBlanks: boolean;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        title: StiTitle;
        layout: StiElementLayout;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        topN: StiDataTopN;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        userSorts: List<StiDataSortRule>;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        dashboardInteraction: IStiDashboardInteraction;
        glyphColor: Color;
        targetFormat: StiFormatService;
        value: StiValueIndicatorMeter;
        target: StiTargetIndicatorMeter;
        series: StiSeriesIndicatorMeter;
        customIcon: number[];
        icon: StiFontIcons;
        iconSet: StiFontIconSet;
        iconAlignment: StiIconAlignment;
        targetMode: StiTargetMode;
        fontSizeMode: StiFontSizeMode;
        iconMode: StiIndicatorIconMode;
        iconRangeMode: StiIndicatorIconRangeMode;
        iconRanges: List<StiIndicatorIconRange>;
        indicatorConditions: List<StiIndicatorElementCondition>;
        crossFiltering: boolean;
        valueType: StiIndicatorValueType;
        isSampleForStyles: boolean;
        getNestedPages(): List<StiPage>;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Components.Indicator {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Font = Stimulsoft.System.Drawing.Font;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiIndicatorElementCondition = Stimulsoft.Report.Dashboard.IStiIndicatorElementCondition;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiIndicatorFieldCondition = Stimulsoft.Report.Dashboard.StiIndicatorFieldCondition;
    import StiIconAlignment = Stimulsoft.Report.Dashboard.StiIconAlignment;
    import StiIndicatorConditionPermissions = Stimulsoft.Report.Dashboard.StiIndicatorConditionPermissions;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiIndicatorElementCondition implements ICloneable, IStiIndicatorElementCondition, IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): any;
        iconColor: Color;
        icon: StiFontIcons;
        targetIconColor: Color;
        targetIcon: StiFontIcons;
        condition: StiFilterCondition;
        field: StiIndicatorFieldCondition;
        value: string;
        customIcon: number[];
        permissions: StiIndicatorConditionPermissions;
        textColor: Color;
        backColor: Color;
        font: Font;
        iconAlignment: StiIconAlignment;
        targetIconAlignment: StiIconAlignment;
        static createFromJson(json: StiJson): StiIndicatorElementCondition;
        static createFromXml(xmlNode: XmlNode): StiIndicatorElementCondition;
        constructor(field?: StiIndicatorFieldCondition, condition?: StiFilterCondition, value?: string, icon?: StiFontIcons, iconColor?: Color, targetIcon?: StiFontIcons, targetIconColor?: Color, customIcon?: number[], iconAlignment?: StiIconAlignment, targetIconAlignment?: StiIconAlignment, permissions?: StiIndicatorConditionPermissions, font?: Font, textColor?: Color, backColor?: Color);
    }
}
export namespace Stimulsoft.Dashboard.Components.Indicator {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import IStiIndicatorIconRange = Stimulsoft.Report.Dashboard.IStiIndicatorIconRange;
    class StiIndicatorIconRange implements IStiJsonReportObject, IStiIndicatorIconRange, ICloneable {
        implements(): any[];
        clone(): any;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        icon: StiFontIcons;
        startExpression: string;
        endExpression: string;
        static loadFromJson(json: StiJson): StiIndicatorIconRange;
        static loadFromXml(xmlNode: XmlNode): StiIndicatorIconRange;
        saveToString(): string;
        getStringRepresentation(): string;
        constructor(icon?: StiFontIcons, start?: string, end?: string);
    }
}
export namespace Stimulsoft.Dashboard.Components.ListBox {
    import StiFilterInclusionMode = Stimulsoft.Report.Dashboard.StiFilterInclusionMode;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import StiListBoxSelectionType = Stimulsoft.Report.Dashboard.StiListBoxSelectionType;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    import IStiSimpleShadow = Stimulsoft.Report.Components.IStiSimpleShadow;
    import StiItemOrientation = Stimulsoft.Report.Dashboard.StiItemOrientation;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiItemSelectionMode = Stimulsoft.Report.Dashboard.StiItemSelectionMode;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiNameListBoxMeter = Stimulsoft.Dashboard.Components.ListBox.StiNameListBoxMeter;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiListBoxElement = Stimulsoft.Report.Dashboard.IStiListBoxElement;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    class StiListBoxElement extends StiElement implements IStiListBoxElement, IStiSimpleShadow, IStiCornerRadius, IStiTitleElement, IStiJsonReportObject, IStiGlobalizationProvider, IStiElementInteraction {
        implements(): any[];
        clone(cloneProperties: boolean): any;
        meta(): StiMeta[];
        group: string;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        showAllValue: boolean;
        showBlanks: boolean;
        selectionMode: StiItemSelectionMode;
        orientation: StiItemOrientation;
        selectionType: StiListBoxSelectionType;
        title: StiTitle;
        getParentKey(): string;
        setParentKey(key: string): void;
        applyDefaultFilters(): Promise<void>;
        getIdentityFilters(): List<StiDataFilterRule>;
        inclusionMode: StiFilterInclusionMode;
        addKeyMeter2(cell: IStiAppDataCell): void;
        addKeyMeter(meter: IStiMeter): void;
        getKeyMeter(): IStiMeter;
        removeKeyMeter(): void;
        createNewKeyMeter(): void;
        addNameMeter2(cell: IStiAppDataCell): void;
        addNameMeter(meter: IStiMeter): void;
        getNameMeter(): IStiMeter;
        removeNameMeter(): void;
        createNewNameMeter(): void;
        shadow: StiSimpleShadow;
        cornerRadius: StiCornerRadius;
        createNextMeter(cell: IStiAppDataCell): void;
        convertFrom(element: IStiElement): void;
        selectedValue: any;
        selectedKey: string;
        selectedLabel: string;
        selectedIndex: number;
        userFilters: List<StiDataFilterRule>;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        dashboardInteraction: IStiDashboardInteraction;
        font: Font;
        foreColor: Color;
        textFormat: StiFormatService;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        parentKey: string;
        initialValue: string;
        nameMeter: StiNameListBoxMeter;
        keyMeter: StiKeyListBoxMeter;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Components.ListBox {
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiListBoxHelper {
        static fetchItems(listBoxElement: StiListBoxElement, dataTable: StiDataTable, showBlanks: boolean): List<StiListBoxItem>;
        static isBlank(data: any): boolean;
        static fetchDefaultUserFilters(listBoxElement: StiListBoxElement): Promise<List<StiDataFilterRule>>;
        private static fetchInitialValues;
        static getInitialValues(element: StiListBoxElement): List<string>;
        static getNameMeterIndex(table: StiDataTable): number;
        static getKeyMeterIndex(table: StiDataTable): number;
        static getKeyMeterExpression(listBoxElement: StiListBoxElement): string;
        static format(listBoxElement: StiListBoxElement, value: any): string;
    }
}
export namespace Stimulsoft.Dashboard.Components.ListBox {
    class StiListBoxItem {
        label: string;
        value: any;
        toString(): string;
        constructor(label: string, value?: any);
    }
}
export namespace Stimulsoft.Dashboard.Components.NumberBox {
    import IStiAppVariable = Stimulsoft.Base.IStiAppVariable;
    import StiDataFilterCondition = Stimulsoft.Data.Engine.StiDataFilterCondition;
    import List = Stimulsoft.System.Collections.List;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiNumberBoxElement = Stimulsoft.Dashboard.Components.NumberBox.StiNumberBoxElement;
    import DecimalRange = Stimulsoft.Report.DecimalRange;
    class StiNumberBoxHelper {
        static getInitialValue(element: StiNumberBoxElement): any;
        static getRangeInitialValue(element: StiNumberBoxElement): Promise<DecimalRange>;
        static getSingleInitialValue(element: StiNumberBoxElement): Promise<number>;
        static fetchDefaultUserFilters(numberBoxElement: StiNumberBoxElement): Promise<List<StiDataFilterRule>>;
        private static getSingleDefaultUserFilters;
        private static getRangeDefaultUserFilters;
        private static getAutoRange;
        static getValueMeterExpression(numberBoxElement: StiNumberBoxElement): string;
        static getCondition(numberBoxElement: StiNumberBoxElement): StiDataFilterCondition;
        static getVariableSpecifiedAsValue(element: StiNumberBoxElement): IStiAppVariable;
        static isRange(element: StiNumberBoxElement): boolean;
        static isVariableSpecifiedAsValue(element: StiNumberBoxElement): boolean;
        static getMinMaxRange(element: StiNumberBoxElement): Promise<DecimalRange>;
    }
}
export namespace Stimulsoft.Dashboard.Components.NumberBox {
    import StiFilterInclusionMode = Stimulsoft.Report.Dashboard.StiFilterInclusionMode;
    import StiNumberMinMaxMode = Stimulsoft.Report.Dashboard.StiNumberMinMaxMode;
    import Size = Stimulsoft.System.Drawing.Size;
    import Font = Stimulsoft.System.Drawing.Font;
    import List = Stimulsoft.System.Collections.List;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiNumberSelectionMode = Stimulsoft.Report.Dashboard.StiNumberSelectionMode;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiNumberCondition = Stimulsoft.Report.Dashboard.StiNumberCondition;
    import IStiNumberBoxElement = Stimulsoft.Report.Dashboard.IStiNumberBoxElement;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    import IStiFixedHeightElement = Stimulsoft.Report.Dashboard.IStiFixedHeightElement;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import IStiSimpleShadow = Stimulsoft.Report.Components.IStiSimpleShadow;
    import IStiGroupElement = Stimulsoft.Report.Dashboard.IStiGroupElement;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiValueNumberBoxMeter = Stimulsoft.Dashboard.Components.NumberBox.StiValueNumberBoxMeter;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiNumberBoxElement extends StiElement implements IStiNumberBoxElement, IStiSimpleShadow, IStiCornerRadius, IStiFixedHeightElement, IStiGroupElement, IStiHorAlignment, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        clone(cloneProperties: boolean): any;
        group: string;
        isFixedHeight: boolean;
        getParentKey(): string;
        setParentKey(key: string): void;
        applyDefaultFilters(): Promise<void>;
        getIdentityFilters(): List<StiDataFilterRule>;
        inclusionMode: StiFilterInclusionMode;
        userFilters: List<StiDataFilterRule>;
        dataFilters: List<StiDataFilterRule>;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        font: Font;
        foreColor: Color;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        addValueMeter2(cell: IStiAppDataCell): void;
        addValueMeter(meter: IStiMeter): void;
        getValueMeter(): IStiMeter;
        removeValueMeter(): void;
        createNewValueMeter(): void;
        convertFrom(element: IStiElement): void;
        get textFormat(): StiFormatService;
        getFonts(): Font[];
        shadow: StiSimpleShadow;
        cornerRadius: StiCornerRadius;
        horAlignment: StiHorAlignment;
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        getMinSize(): Size;
        setMinSize(value: Size): void;
        getMaxSize(): Size;
        setMaxSize(value: Size): void;
        helpUrl: string;
        selectedValue: any;
        selectedKey: string;
        selectedLabel: string;
        selectedIndex: number;
        decimalDigits: number;
        condition: StiNumberCondition;
        selectionMode: StiNumberSelectionMode;
        minMaxMode: StiNumberMinMaxMode;
        initialValue: string;
        initialToValue: string;
        min: string;
        max: string;
        valueMeter: StiValueNumberBoxMeter;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Interactions {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiInteractionLayout = Stimulsoft.Report.Dashboard.IStiInteractionLayout;
    import StiAvailableInteractionOnDataManipulation = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnDataManipulation;
    import StiAvailableInteractionOnHover = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnHover;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    class StiOnlineMapDashboardInteraction extends StiDashboardInteraction implements IStiJsonReportObject, IStiInteractionLayout {
        implements(): any[];
        meta(): StiMeta[];
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        availableOnHover: StiAvailableInteractionOnHover;
        availableOnDataManipulation: StiAvailableInteractionOnDataManipulation;
        showFullScreenButton: boolean;
        showSaveButton: boolean;
        showViewDataButton: boolean;
        fileName: string;
        headerText: string;
        footerText: string;
        get isDefaultLayout(): boolean;
        isDefault(): boolean;
        constructor(fileName?: string, headerText?: string, footerText?: string, showFullScreenButton?: boolean, showSaveButton?: boolean, showViewDataButton?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.OnlineMap {
    import StiGeoMapProviderType = Stimulsoft.Report.Dashboard.StiGeoMapProviderType;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    import IStiSimpleShadow = Stimulsoft.Report.Components.IStiSimpleShadow;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiOnlineMapElement = Stimulsoft.Report.Dashboard.IStiOnlineMapElement;
    import StiOnlineMapLocationType = Stimulsoft.Report.Dashboard.StiOnlineMapLocationType;
    import StiOnlineMapCulture = Stimulsoft.Report.Dashboard.StiOnlineMapCulture;
    import StiOnlineMapLocationColorType = Stimulsoft.Report.Dashboard.StiOnlineMapLocationColorType;
    import StiOnlineMapValueViewMode = Stimulsoft.Report.Dashboard.StiOnlineMapValueViewMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiOnlineMapElement extends StiElement implements IStiOnlineMapElement, IStiSimpleShadow, IStiCornerRadius, IStiTitleElement, IStiElementLayout, IStiElementInteraction, IStiJsonReportObject, IStiGlobalizationProvider {
        implements(): any[];
        clone(cloneProperties: boolean): any;
        meta(): StiMeta[];
        group: string;
        title: StiTitle;
        layout: StiElementLayout;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        createNextMeter(cell: IStiAppDataCell): void;
        addLatitudeMeter2(cell: IStiAppDataCell): void;
        addLatitudeMeter(meter: IStiMeter): void;
        getLatitudeMeter(): IStiMeter;
        removeLatitudeMeter(): void;
        createNewLatitudeMeter(): void;
        addLongitudeMeter2(cell: IStiAppDataCell): void;
        addLongitudeMeter(meter: IStiMeter): void;
        getLongitudeMeter(): IStiMeter;
        removeLongitudeMeter(): void;
        createNewLongitudeMeter(): void;
        addLocationMeter2(cell: IStiAppDataCell): void;
        addLocationMeter(meter: IStiMeter): void;
        getLocationMeter(): IStiMeter;
        removeLocationMeter(): void;
        createNewLocationMeter(): void;
        addLocationColorMeter2(cell: IStiAppDataCell): void;
        addLocationColorMeter(meter: IStiMeter): void;
        getLocationColorMeter(): IStiMeter;
        removeLocationColorMeter(): void;
        createNewLocationColorMeter(): void;
        addLocationValueMeter2(cell: IStiAppDataCell): void;
        addLocationValueMeter(meter: IStiMeter): void;
        getLocationValueMeter(): IStiMeter;
        removeLocationValueMeter(): void;
        createNewLocationValueMeter(): void;
        addLocationArgumentMeter(cell: IStiAppDataCell): void;
        addLocationArgumentMeter2(meter: IStiMeter): void;
        getLocationArgumentMeter(): IStiMeter;
        removeLocationArgumentMeter(): void;
        createNewLocationArgumentMeter(): void;
        shadow: StiSimpleShadow;
        cornerRadius: StiCornerRadius;
        convertFrom(element: IStiElement): void;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        get toolboxPosition(): number;
        get localizedName(): string;
        helpUrl: string;
        dashboardInteraction: IStiDashboardInteraction;
        private _onePointZoom;
        get onePointZoom(): number;
        set onePointZoom(value: number);
        userBingKey: string;
        latitude: StiLatitudeMapMeter;
        longitude: StiLongitudeMapMeter;
        location: StiLocationMapMeter;
        locationColorMeter: StiLocationMapMeter;
        locationValue: StiLocationMapMeter;
        locationArgument: StiLocationMapMeter;
        locationType: StiOnlineMapLocationType;
        culture: StiOnlineMapCulture;
        locationColorType: StiOnlineMapLocationColorType;
        valueViewMode: StiOnlineMapValueViewMode;
        locationColor: Color;
        icon: StiFontIcons;
        iconColor: Color;
        customIcon: number[];
        crossFiltering: boolean;
        provider: StiGeoMapProviderType;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Components.Table {
    import IStiTableSection = Stimulsoft.Report.Dashboard.IStiTableSection;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiTableCells = Stimulsoft.Report.Dashboard.IStiTableCells;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiTableCells implements IStiTableCells, ICloneable, IStiJsonReportObject, IStiGetFonts {
        implements(): any[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        static createFromJsonObject(jObject: StiJson): StiTableCells;
        static createFromXml(xmlNode: XmlNode): StiTableCells;
        clone(): any;
        isDefault(): boolean;
        getFonts(): Font[];
        getColumns(): IStiTableSection;
        getData(): IStiTableSection;
        getTotals(): IStiTableSection;
        private _columns;
        get columns(): StiTableSection;
        set columns(value: StiTableSection);
        private shouldSerializeColumns;
        private _data;
        get data(): StiTableSection;
        set data(value: StiTableSection);
        private shouldSerializeData;
        private _totals;
        get totals(): StiTableSection;
        set totals(value: StiTableSection);
        private shouldSerializeTotals;
        private _element;
        get element(): StiElement;
        set element(value: StiElement);
        getElement(): StiElement;
        setElement(value: StiElement): void;
        constructor();
    }
}
export namespace Stimulsoft.Dashboard.Components.Table {
    import IStiTableSection = Stimulsoft.Report.Dashboard.IStiTableSection;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiPivotTableCells = Stimulsoft.Report.Dashboard.IStiPivotTableCells;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiPivotTableCells extends StiTableCells implements IStiPivotTableCells, ICloneable, IStiJsonReportObject, IStiGetFonts {
        implements(): any[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        static createFromJsonObject(jObject: StiJson): StiPivotTableCells;
        static createFromXml(xmlNode: XmlNode): StiPivotTableCells;
        clone(): any;
        isDefault(): boolean;
        getFonts(): Font[];
        getRows(): IStiTableSection;
        private _rows;
        get rows(): StiTableSection;
        set rows(value: StiTableSection);
        private shouldSerializeRows;
        setElement(value: StiElement): void;
        constructor();
    }
}
export namespace Stimulsoft.Dashboard.Components.PivotTable {
    import IStiPivotItem = Stimulsoft.Report.Dashboard.IStiPivotItem;
    import IStiReport = Stimulsoft.Base.IStiReport;
    class StiPivotTableColumnVisibilityHelper {
        static getVisible(item: IStiPivotItem, report: IStiReport): boolean;
    }
}
export namespace Stimulsoft.Dashboard.Helpers {
    import StiMeter = Stimulsoft.Dashboard.Components.StiMeter;
    import List = Stimulsoft.System.Collections.List;
    import StiPivotTableElement = Stimulsoft.Dashboard.Components.PivotTable.StiPivotTableElement;
    class StiPivotTableElementSelection {
        private static hash;
        static getSelected(element: StiPivotTableElement): List<StiMeter>;
        static getSelectedObjects(element: StiPivotTableElement): List<any>;
        static isSelected(element: StiPivotTableElement, column: StiMeter): boolean;
        static select(element: StiPivotTableElement, column: StiMeter): void;
        static resetSelection(element: StiPivotTableElement): void;
    }
}
export namespace Stimulsoft.Dashboard.Interactions {
    import IStiInteractionPivotLayout = Stimulsoft.Report.Dashboard.IStiInteractionPivotLayout;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiInteractionLayout = Stimulsoft.Report.Dashboard.IStiInteractionLayout;
    import StiAvailableInteractionOnDataManipulation = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnDataManipulation;
    import StiAvailableInteractionOnHover = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnHover;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    class StiPivotTableDashboardInteraction extends StiDashboardInteraction implements IStiJsonReportObject, IStiInteractionLayout, IStiInteractionPivotLayout {
        implements(): any[];
        meta(): StiMeta[];
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        availableOnHover: StiAvailableInteractionOnHover;
        availableOnDataManipulation: StiAvailableInteractionOnDataManipulation;
        showFullScreenButton: boolean;
        showSaveButton: boolean;
        showViewDataButton: boolean;
        showExpandAllButton: boolean;
        showCollapseAllButton: boolean;
        fileName: string;
        headerText: string;
        footerText: string;
        get isDefaultLayout(): boolean;
        isDefault(): boolean;
        constructor(fileName?: string, headerText?: string, footerText?: string, showFullScreenButton?: boolean, showSaveButton?: boolean, showViewDataButton?: boolean, showExpandAllButton?: boolean, showCollapseAllButton?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.PivotTable {
    import IStiPivotTableCells = Stimulsoft.Report.Dashboard.IStiPivotTableCells;
    import StiPivotTableCells = Stimulsoft.Dashboard.Components.Table.StiPivotTableCells;
    import StiPivotTableConditionType = Stimulsoft.Report.Dashboard.StiPivotTableConditionType;
    import StiDataTopNMode = Stimulsoft.Data.Engine.StiDataTopNMode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    import IStiSimpleShadow = Stimulsoft.Report.Components.IStiSimpleShadow;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiSummaryDirection = Stimulsoft.Report.CrossTab.Core.StiSummaryDirection;
    import StiIconAlignment = Stimulsoft.Report.Dashboard.StiIconAlignment;
    import StiConditionPermissions = Stimulsoft.Report.Components.StiConditionPermissions;
    import IStiPivotTableElementCondition = Stimulsoft.Report.Dashboard.IStiPivotTableElementCondition;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiPivotSummary = Stimulsoft.Dashboard.Components.PivotTable.StiPivotSummary;
    import StiPivotColumn = Stimulsoft.Dashboard.Components.PivotTable.StiPivotColumn;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiPivotTableElement = Stimulsoft.Report.Dashboard.IStiPivotTableElement;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiPivotTableElement extends StiElement implements IStiPivotTableElement, IStiSimpleShadow, IStiCornerRadius, IStiTitleElement, IStiElementLayout, IStiElementInteraction, IStiJsonReportObject, IStiGlobalizationProvider {
        implements(): any[];
        maxIconSize: number;
        clone(cloneProperties: boolean): any;
        meta(): StiMeta[];
        retrieveUsedDataNames(): List<string>;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        getUsedMeters(): List<IStiMeter>;
        get isDefined(): boolean;
        shadow: StiSimpleShadow;
        cornerRadius: StiCornerRadius;
        group: string;
        title: StiTitle;
        layout: StiElementLayout;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        crossFiltering: boolean;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        summaryDirection: StiSummaryDirection;
        createNextMeter(cell: IStiAppDataCell): void;
        createNewColumn(): void;
        getColumn2(cell: IStiAppDataCell): IStiMeter;
        getColumn(meter: IStiMeter): IStiMeter;
        getColumnByIndex(index: number): IStiMeter;
        insertColumn(index: number, meter: IStiMeter): void;
        removeColumn(index: number): void;
        removeAllColumns(): void;
        createNewRow(): void;
        getRow2(cell: IStiAppDataCell): IStiMeter;
        getRow(meter: IStiMeter): IStiMeter;
        getRowByIndex(index: number): IStiMeter;
        insertRow(index: number, meter: IStiMeter): void;
        removeRow(index: number): void;
        removeAllRows(): void;
        createNewSummary(): void;
        getSummary2(cell: IStiAppDataCell): IStiMeter;
        getSummary(meter: IStiMeter): IStiMeter;
        getSummaryByIndex(index: number): IStiMeter;
        insertSummary(index: number, meter: IStiMeter): void;
        removeSummary(index: number): void;
        removeAllSummaries(): void;
        addPivotTableCondition(keyValueMeter: string, destinationValueMeter: string, dataType: StiFilterDataType, condition: StiFilterCondition, value: string, font: Font, textColor: Color, backColor: Color, permissions: StiConditionPermissions, icon: StiFontIcons, iconAlignment: StiIconAlignment, customIcon: number[], iconColor: Color, conditionType: StiPivotTableConditionType, topNMode: StiDataTopNMode, topNCount: number, measureField: string, topNConditionCell: boolean, topNConditionHeader: boolean, topNConditionTotal: boolean): void;
        getAllMeters(): List<IStiMeter>;
        fetchPivotTableConditions(): List<IStiPivotTableElementCondition>;
        clearPivotTableConditions(): void;
        getFonts(): Font[];
        convertFrom(element: IStiElement): void;
        setString(propertyName: string, value: string): void;
        cloneMeter(meter: StiMeter, keys: any): StiMeter;
        findKey(key: string, keys: any): string;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        getCells(): IStiPivotTableCells;
        get toolboxPosition(): number;
        get localizedName(): string;
        helpUrl: string;
        dashboardInteraction: IStiDashboardInteraction;
        columns: List<StiPivotColumn>;
        rows: List<StiPivotRow>;
        summaries: List<StiPivotSummary>;
        totalLabel: string;
        get foreColor(): Color;
        set foreColor(value: Color);
        private _cells;
        get cells(): StiPivotTableCells;
        set cells(value: StiPivotTableCells);
        private shouldSerializeCells;
        getColumnFont(): Font;
        getRowFont(): Font;
        getDataFont(): Font;
        getTotalFont(): Font;
        pivotTableConditions: List<IStiPivotTableElementCondition>;
        getFormatObjects(): List<any>;
        getNestedPages(): List<StiPage>;
        getPushCommands(expression: string): List<string>;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Components.PivotTable {
    import StiPivotTableConditionType = Stimulsoft.Report.Dashboard.StiPivotTableConditionType;
    import StiDataTopNMode = Stimulsoft.Data.Engine.StiDataTopNMode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiFilterDataType = Stimulsoft.Dashboard.StiFilterDataType;
    import StiFilterCondition = Stimulsoft.Dashboard.StiFilterCondition;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import Size = Stimulsoft.System.Drawing.Size;
    import StiIconAlignment = Stimulsoft.Report.Dashboard.StiIconAlignment;
    import StiConditionPermissions = Stimulsoft.Report.Components.StiConditionPermissions;
    import IStiPivotTableElementCondition = Stimulsoft.Report.Dashboard.IStiPivotTableElementCondition;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiPivotTableElementCondition implements IStiPivotTableElementCondition, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        clone(): any;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        static loadFromJson(jObject: StiJson): StiPivotTableElementCondition;
        static loadFromXml(xmlNode: XmlNode): any;
        get iconFontSize(): number;
        textColor: Color;
        backColor: Color;
        font: Font;
        permissions: StiConditionPermissions;
        private _customIcon;
        get customIcon(): number[];
        set customIcon(value: number[]);
        icon: StiFontIcons;
        iconAlignment: StiIconAlignment;
        condition: StiFilterCondition;
        dataType: StiFilterDataType;
        value: string;
        keyValueMeter: string;
        private _destinationValueMeter;
        get destinationValueMeter(): string;
        set destinationValueMeter(value: string);
        iconColor: Color;
        private _iconSize;
        conditionType: StiPivotTableConditionType;
        topNMode: StiDataTopNMode;
        topNCount: number;
        measureField: string;
        topNConditionCell: boolean;
        topNConditionHeader: boolean;
        topNConditionTotal: boolean;
        get iconSize(): Size;
        getIcon(): Promise<number[]>;
        getUniqueCode(): number;
        constructor(keyValueMeter?: string, destinationValueMeter?: string, dataType?: StiFilterDataType, condition?: StiFilterCondition, value?: string, font?: Font, textColor?: Color, backColor?: Color, permissions?: StiConditionPermissions, icon?: StiFontIcons, iconAlignment?: StiIconAlignment, customIcon?: number[], iconColor?: Color, conditionType?: StiPivotTableConditionType, topNMode?: StiDataTopNMode, topNCount?: number, measureField?: string, topNConditionCell?: boolean, topNConditionHeader?: boolean, topNConditionTotal?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.PivotTable.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    class StiPivotColumnConverter extends StiMeterConverter {
    }
}
export namespace Stimulsoft.Dashboard.Components.PivotTable.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    class StiPivotRowConverter extends StiMeterConverter {
    }
}
export namespace Stimulsoft.Dashboard.Components.PivotTable.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    class StiPivotSummaryConverter extends StiMeterConverter {
    }
}
export namespace Stimulsoft.Dashboard.Interactions {
    import List = Stimulsoft.System.Collections.List;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import IStiAllowUserDrillDownDashboardInteraction = Stimulsoft.Report.Dashboard.IStiAllowUserDrillDownDashboardInteraction;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiInteractionLayout = Stimulsoft.Report.Dashboard.IStiInteractionLayout;
    import IStiAllowUserSortingDashboardInteraction = Stimulsoft.Report.Dashboard.IStiAllowUserSortingDashboardInteraction;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    class StiProgressDashboardInteraction extends StiDashboardInteraction implements IStiAllowUserDrillDownDashboardInteraction, IStiAllowUserSortingDashboardInteraction, IStiJsonReportObject, IStiInteractionLayout {
        implements(): any[];
        meta(): StiMeta[];
        ident: StiInteractionIdent;
        availableOnClick: number;
        availableOnDataManipulation: number;
        allowUserDrillDown: boolean;
        allowUserSorting: boolean;
        onClick: StiInteractionOnClick;
        showFullScreenButton: boolean;
        showSaveButton: boolean;
        showViewDataButton: boolean;
        fileName: string;
        headerText: string;
        footerText: string;
        get isDefaultLayout(): boolean;
        isDefault(): boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>, allowUserDrillDown?: boolean, allowUserSorting?: boolean, fileName?: string, headerText?: string, footerText?: string, showFullScreenButton?: boolean, showSaveButton?: boolean, showViewDataButton?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Progress {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import IStiShowBlanks = Stimulsoft.Report.Components.IStiShowBlanks;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    import IStiSimpleShadow = Stimulsoft.Report.Components.IStiSimpleShadow;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiDataMode = Stimulsoft.Report.StiDataMode;
    import StiProgressConditionPermissions = Stimulsoft.Report.Dashboard.StiProgressConditionPermissions;
    import StiProgressFieldCondition = Stimulsoft.Report.Dashboard.StiProgressFieldCondition;
    import IStiAllowSortByVariation = Stimulsoft.Data.Engine.IStiAllowSortByVariation;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiSeriesColors = Stimulsoft.Report.Dashboard.IStiSeriesColors;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiProgressElementMode = Stimulsoft.Report.Dashboard.StiProgressElementMode;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import List = Stimulsoft.System.Collections.List;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTargetProgressMeter = Stimulsoft.Dashboard.Components.Progress.StiTargetProgressMeter;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiProgressElement = Stimulsoft.Report.Dashboard.IStiProgressElement;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import IStiProgressElementCondition = Stimulsoft.Report.Dashboard.IStiProgressElementCondition;
    import StiProgressValueType = Stimulsoft.Report.Dashboard.StiProgressValueType;
    class StiProgressElement extends StiElement implements IStiTextFormat, IStiSimpleShadow, IStiCornerRadius, IStiProgressElement, IStiTitleElement, IStiFont, IStiForeColor, IStiElementLayout, IStiElementInteraction, IStiJsonReportObject, IStiGlobalizationProvider, IStiSeriesColors, IStiAllowSortByVariation, IStiShowBlanks {
        implements(): any[];
        clone(cloneProperties: boolean): any;
        meta(): StiMeta[];
        group: string;
        addValue2(cell: IStiAppDataCell): void;
        addValue(meter: IStiMeter): void;
        removeValue(): void;
        getValue(): IStiMeter;
        getValue2(meter: IStiMeter): IStiMeter;
        createNewValue(): void;
        addTarget2(cell: IStiAppDataCell): void;
        addTarget(meter: IStiMeter): void;
        removeTarget(): void;
        getTarget(): IStiMeter;
        getTarget2(meter: IStiMeter): IStiMeter;
        createNewTarget(): void;
        addSeries2(cell: IStiAppDataCell): void;
        addSeries(meter: IStiMeter): void;
        removeSeries(): void;
        getSeries(): IStiMeter;
        getSeries2(meter: IStiMeter): IStiMeter;
        createNewSeries(): void;
        dataMode: StiDataMode;
        manuallyEnteredData: string;
        getManuallyEnteredDataTable(): StiDataTable;
        convertFrom(element: IStiElement): void;
        textFormat: StiFormatService;
        font: Font;
        foreColor: Color;
        title: StiTitle;
        layout: StiElementLayout;
        shadow: StiSimpleShadow;
        cornerRadius: StiCornerRadius;
        showBlanks: boolean;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        topN: StiDataTopN;
        dataTransformation: {};
        crossFiltering: boolean;
        dataFilters: List<StiDataFilterRule>;
        userSorts: List<StiDataSortRule>;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        seriesColors: Color[];
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        addProgressCondition(field: StiProgressFieldCondition, condition: StiFilterCondition, value: string, permissions: StiProgressConditionPermissions, font: Font, textColor: Color, color: Color, trackColor: Color): void;
        fetchProgressConditions(): List<IStiProgressElementCondition>;
        clearProgressConditions(): void;
        dashboardInteraction: IStiDashboardInteraction;
        colorEach: boolean;
        value: StiValueProgressMeter;
        target: StiTargetProgressMeter;
        series: StiSeriesProgressMeter;
        mode: StiProgressElementMode;
        progressConditions: List<StiProgressElementCondition>;
        valueType: StiProgressValueType;
        isSampleForStyles: boolean;
        getNestedPages(): List<StiPage>;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Components.Progress {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Font = Stimulsoft.System.Drawing.Font;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiProgressElementCondition = Stimulsoft.Report.Dashboard.IStiProgressElementCondition;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiProgressFieldCondition = Stimulsoft.Report.Dashboard.StiProgressFieldCondition;
    import StiProgressConditionPermissions = Stimulsoft.Report.Dashboard.StiProgressConditionPermissions;
    class StiProgressElementCondition implements IStiJsonReportObject, ICloneable, IStiProgressElementCondition {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        clone(): any;
        condition: StiFilterCondition;
        field: StiProgressFieldCondition;
        value: string;
        permissions: StiProgressConditionPermissions;
        textColor: Color;
        color: Color;
        trackColor: Color;
        font: Font;
        static createFromJson(json: StiJson): StiProgressElementCondition;
        static createFromXml(xmlNode: XmlNode): StiProgressElementCondition;
        constructor(field?: StiProgressFieldCondition, condition?: StiFilterCondition, value?: string, permissions?: StiProgressConditionPermissions, font?: Font, textColor?: Color, color?: Color, trackColor?: Color);
    }
}
export namespace Stimulsoft.Dashboard.Interactions {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiInteractionLayout = Stimulsoft.Report.Dashboard.IStiInteractionLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import List = Stimulsoft.System.Collections.List;
    class StiRegionMapDashboardInteraction extends StiDashboardInteraction implements IStiJsonReportObject, IStiInteractionLayout {
        implements(): any[];
        meta(): StiMeta[];
        ident: StiInteractionIdent;
        availableOnClick: number;
        showFullScreenButton: boolean;
        showSaveButton: boolean;
        showViewDataButton: boolean;
        fileName: string;
        headerText: string;
        footerText: string;
        get isDefaultLayout(): boolean;
        isDefault(): boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>, fileName?: string, headerText?: string, footerText?: string, showFullScreenButton?: boolean, showSaveButton?: boolean, showViewDataButton?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.RegionMap {
    import Font = Stimulsoft.System.Drawing.Font;
    import StiMapLabels = Stimulsoft.Report.Maps.StiMapLabels;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiDataMode = Stimulsoft.Report.StiDataMode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    import IStiSimpleShadow = Stimulsoft.Report.Components.IStiSimpleShadow;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiKeyMapMeter = Stimulsoft.Dashboard.Components.RegionMap.StiKeyMapMeter;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiMapData = Stimulsoft.Report.Maps.StiMapData;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiDisplayNameType = Stimulsoft.Report.Maps.StiDisplayNameType;
    import StiMapType = Stimulsoft.Report.Maps.StiMapType;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiMapSource = Stimulsoft.Report.Maps.StiMapSource;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiSkipOwnFilter = Stimulsoft.Report.Dashboard.IStiSkipOwnFilter;
    import IStiRegionMapElement = Stimulsoft.Report.Dashboard.IStiRegionMapElement;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import IStiNumberFormat = Stimulsoft.Report.Components.IStiNumberFormat;
    class StiRegionMapElement extends StiElement implements IStiRegionMapElement, IStiSimpleShadow, IStiCornerRadius, IStiSkipOwnFilter, IStiTitleElement, IStiElementLayout, IStiJsonReportObject, IStiGlobalizationProvider, IStiElementInteraction, IStiFont, IStiNumberFormat {
        implements(): any[];
        clone(cloneProperties: boolean): any;
        meta(): StiMeta[];
        group: string;
        get allowSkipOwnFilter(): boolean;
        shadow: StiSimpleShadow;
        cornerRadius: StiCornerRadius;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        get isQuerable(): boolean;
        title: StiTitle;
        get font(): Font;
        set font(value: Font);
        valueFormat: StiFormatService;
        private static getValueFormatDefault;
        layout: StiElementLayout;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        userFilters: List<StiDataFilterRule>;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        createNextMeter(cell: IStiAppDataCell): void;
        addKeyMeter2(cell: IStiAppDataCell): void;
        addKeyMeter(meter: IStiMeter): void;
        getKeyMeter(): IStiMeter;
        removeKeyMeter(): void;
        createNewKeyMeter(): void;
        addNameMeter2(cell: IStiAppDataCell): void;
        addNameMeter(meter: IStiMeter): void;
        getNameMeter(): IStiMeter;
        removeNameMeter(): void;
        createNewNameMeter(): void;
        addValueMeter2(cell: IStiAppDataCell): void;
        addValueMeter(meter: IStiMeter): void;
        getValueMeter(): IStiMeter;
        removeValueMeter(): void;
        createNewValueMeter(): void;
        addGroupMeter2(cell: IStiAppDataCell): void;
        addGroupMeter(meter: IStiMeter): void;
        getGroupMeter(): IStiMeter;
        removeGroupMeter(): void;
        createNewGroupMeter(): void;
        addColorMeter2(cell: IStiAppDataCell): void;
        addColorMeter(meter: IStiMeter): void;
        getColorMeter(): IStiMeter;
        removeColorMeter(): void;
        createNewColorMeter(): void;
        convertFrom(element: IStiElement): void;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        get toolboxPosition(): number;
        get localizedName(): string;
        helpUrl: string;
        private _dashboardInteraction;
        get dashboardInteraction(): IStiDashboardInteraction;
        set dashboardInteraction(value: IStiDashboardInteraction);
        dataMode: StiDataMode;
        manuallyEnteredData: string;
        getManuallyEnteredDataTable(): StiDataTable;
        labels: StiMapLabels;
        private _language;
        get language(): string;
        set language(value: string);
        mapIdent: string;
        dataFrom: StiMapSource;
        mapData: string;
        mapType: StiMapType;
        showValue: boolean;
        showZeros: boolean;
        shortValue: boolean;
        colorEach: boolean;
        showBubble: boolean;
        show3D: boolean;
        showName: StiDisplayNameType;
        crossFiltering: boolean;
        keyMeter: StiKeyMapMeter;
        nameMeter: StiNameMapMeter;
        valueMeter: StiValueMapMeter;
        groupMeter: StiGroupMapMeter;
        colorMeter: StiColorMapMeter;
        getNestedPages(): List<StiPage>;
        getMapData(): List<StiMapData>;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Interactions {
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import List = Stimulsoft.System.Collections.List;
    class StiShapeDashboardInteraction extends StiDashboardInteraction {
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        onClick: StiInteractionOnClick;
        isDefault(): boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>);
    }
}
export namespace Stimulsoft.Dashboard.Components.Shape {
    import List = Stimulsoft.System.Collections.List;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiTitle = Stimulsoft.Dashboard.Components.StiTitle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiRectangleShapeType = Stimulsoft.Report.Components.StiRectangleShapeType;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiShapeElement = Stimulsoft.Report.Dashboard.IStiShapeElement;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    class StiShapeElement extends StiElement implements IStiShapeElement, IStiTitleElement, IStiElementInteraction, IStiJsonReportObject, IStiGlobalizationProvider {
        implements(): any[];
        clone(cloneProperties: boolean): any;
        meta(): StiMeta[];
        get toolboxPosition(): number;
        get localizedName(): string;
        helpUrl: string;
        get isDefined(): boolean;
        get isQuerable(): boolean;
        title: StiTitle;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        dashboardInteraction: IStiDashboardInteraction;
        shapeType: StiRectangleShapeType;
        private _size;
        get size(): number;
        set size(value: number);
        fill: StiBrush;
        stroke: Color;
        getNestedPages(): List<StiPage>;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Components.Table {
    enum StiDataBarsDirection {
        LeftToRight = 0,
        RighToLeft = 1
    }
    enum StiDataBarsBrushType {
        Solid = 0,
        Gradient = 1
    }
    enum StiSparklinesType {
        Line = 0,
        Area = 1,
        Column = 2,
        WinLoss = 3
    }
}
export namespace Stimulsoft.Dashboard.Helpers {
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import List = Stimulsoft.System.Collections.List;
    import StiTableElement = Stimulsoft.Dashboard.Components.Table.StiTableElement;
    class StiTableElementSelection {
        private static hash;
        static getSelected(element: StiTableElement): List<StiTableColumn>;
        static getSelectedObjects(element: StiTableElement): List<any>;
        static isSelected(element: StiTableElement, column: StiTableColumn): boolean;
        static select(element: StiTableElement, column: StiTableColumn): void;
        static resetSelection(element: StiTableElement): void;
    }
}
export namespace Stimulsoft.Dashboard.Interactions {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiAllowUserColumnSelectionDashboardInteraction = Stimulsoft.Report.Dashboard.IStiAllowUserColumnSelectionDashboardInteraction;
    import IStiInteractionLayout = Stimulsoft.Report.Dashboard.IStiInteractionLayout;
    import List = Stimulsoft.System.Collections.List;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    import IStiTableDashboardInteraction = Stimulsoft.Report.Dashboard.IStiTableDashboardInteraction;
    import IStiAllowUserSortingDashboardInteraction = Stimulsoft.Report.Dashboard.IStiAllowUserSortingDashboardInteraction;
    import IStiAllowUserFilteringDashboardInteraction = Stimulsoft.Report.Dashboard.IStiAllowUserFilteringDashboardInteraction;
    import StiAvailableInteractionOnHover = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnHover;
    class StiTableDashboardInteraction extends StiDashboardInteraction implements IStiTableDashboardInteraction, IStiAllowUserColumnSelectionDashboardInteraction, IStiAllowUserSortingDashboardInteraction, IStiAllowUserFilteringDashboardInteraction, IStiJsonReportObject, IStiInteractionLayout {
        implements(): any[];
        meta(): StiMeta[];
        allowUserColumnSelection: boolean;
        allowUserSorting: boolean;
        allowUserFiltering: boolean;
        drillDownFiltered: boolean;
        fullRowSelect: boolean;
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        availableOnHover: StiAvailableInteractionOnHover;
        availableOnDataManipulation: number;
        showFullScreenButton: boolean;
        showSaveButton: boolean;
        showViewDataButton: boolean;
        fileName: string;
        headerText: string;
        footerText: string;
        get isDefaultLayout(): boolean;
        isDefault(): boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>, allowFiltering?: boolean, allowSorting?: boolean, allowUserColumnSelection?: boolean, drillDownFiltered?: boolean, fullRowSelect?: boolean, fileName?: string, headerText?: string, footerText?: string, showFullScreenButton?: boolean, showSaveButton?: boolean, showViewDataButton?: boolean);
    }
}
export namespace Stimulsoft.Dashboard.Components.Table {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import Font = Stimulsoft.System.Drawing.Font;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiTableElementCondition = Stimulsoft.Report.Dashboard.IStiTableElementCondition;
    import StiTableConditionPermissions = Stimulsoft.Report.Dashboard.StiTableConditionPermissions;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiIconAlignment = Stimulsoft.Report.Dashboard.StiIconAlignment;
    class StiTableElementCondition implements ICloneable, IStiTableElementCondition, IStiJsonReportObject {
        implements(): any[];
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        private parseStringArray;
        clone(): any;
        get keyValueMeters(): string[];
        set keyValueMeters(value: string[]);
        keyDataFieldMeters: string[];
        keyDestinationMeters: string[];
        dataType: Report.Components.StiFilterDataType;
        condition: StiFilterCondition;
        value: string;
        permissions: StiTableConditionPermissions;
        font: Font;
        foreColor: Color;
        backColor: Color;
        isExpression: boolean;
        customIcon: number[];
        icon: StiFontIcons;
        iconAlignment: StiIconAlignment;
        iconColor: Color;
        static createFromJson(json: StiJson): StiTableElementCondition;
        static createFromXml(xmlNode: XmlNode): StiTableElementCondition;
        constructor(keyDataFieldMeters?: string[], keyDestinationMeters?: string[], dataType?: StiFilterDataType, condition?: StiFilterCondition, value?: string, permissions?: StiTableConditionPermissions, font?: Font, foreColor?: Color, backColor?: Color, isExpression?: boolean, icon?: StiFontIcons, iconAlignment?: StiIconAlignment, customIcon?: number[], iconColor?: Color);
    }
}
export namespace Stimulsoft.Dashboard.Components.Table {
    import StiIconAlignment = Stimulsoft.Report.Dashboard.StiIconAlignment;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import IStiTableCells = Stimulsoft.Report.Dashboard.IStiTableCells;
    import StiTableCells = Stimulsoft.Dashboard.Components.Table.StiTableCells;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    import IStiSimpleShadow = Stimulsoft.Report.Components.IStiSimpleShadow;
    import StiTableConditionPermissions = Stimulsoft.Report.Dashboard.StiTableConditionPermissions;
    import IStiSkipOwnFilter = Stimulsoft.Report.Dashboard.IStiSkipOwnFilter;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiTableSizeMode = Stimulsoft.Report.Dashboard.StiTableSizeMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Font = Stimulsoft.System.Drawing.Font;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiTableElement = Stimulsoft.Report.Dashboard.IStiTableElement;
    import IStiTableElementCondition = Stimulsoft.Report.Dashboard.IStiTableElementCondition;
    class StiTableElement extends StiElement implements IStiTableElement, IStiSimpleShadow, IStiCornerRadius, IStiTitleElement, IStiElementLayout, IStiJsonReportObject, IStiGlobalizationProvider, IStiElementInteraction, IStiSkipOwnFilter {
        implements(): any[];
        clone(cloneProperties: boolean): any;
        meta(): StiMeta[];
        createMeters(source: IStiTableElement): void;
        createMeters2(dataSource: StiDataSource): void;
        createMeter3(cell: IStiAppDataCell): void;
        removeMeter(index: number): void;
        removeAllMeters(): void;
        insertMeter(index: number, meter: IStiMeter): void;
        insertNewDimension(index: number): void;
        insertNewMeasure(index: number): void;
        getMeasure(cell: IStiAppDataCell): IStiMeter;
        getDimension(cell: IStiAppDataCell): IStiMeter;
        shadow: StiSimpleShadow;
        getFonts(): Font[];
        getCells(): IStiTableCells;
        cornerRadius: StiCornerRadius;
        convertFrom(element: IStiElement): void;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        title: StiTitle;
        layout: StiElementLayout;
        group: string;
        get allowSkipOwnFilter(): boolean;
        get foreColor(): Color;
        set foreColor(value: Color);
        get font(): Font;
        set font(value: Font);
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        userFilters: List<StiDataFilterRule>;
        userSorts: List<StiDataSortRule>;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        tableConditions: List<IStiTableElementCondition>;
        crossFiltering: boolean;
        private _cells;
        get cells(): StiTableCells;
        set cells(value: StiTableCells);
        private shouldSerializeCells;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        dashboardInteraction: IStiDashboardInteraction;
        addTableCondition(keyDataFieldMeters: string[], keyDestinationMeters: string[], dataType: Stimulsoft.Report.Components.StiFilterDataType, condition: Stimulsoft.Report.Components.StiFilterCondition, value: string, permissions: StiTableConditionPermissions, font: Font, foreColor: Color, backColor: Color, isExpression: boolean, icon?: StiFontIcons, iconAlignment?: StiIconAlignment, customIcon?: number[], iconColor?: Color): void;
        get toolboxPosition(): number;
        get localizedName(): string;
        helpUrl: string;
        columns: List<StiTableColumn>;
        sizeMode: StiTableSizeMode;
        rowsPerPage: number;
        pageTurnTime: number;
        currentPageIndex: number;
        get headerForeColor(): Color;
        set headerForeColor(value: Color);
        get headerFont(): Font;
        set headerFont(value: Font);
        get footerForeColor(): Color;
        set footerForeColor(value: Color);
        get footerFont(): Font;
        set footerFont(value: Font);
        getColumnFont(): Font;
        getDataFont(): Font;
        getTotalFont(): Font;
        getNestedPages(): List<StiPage>;
        getFormatObjects(): List<any>;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Components.Table {
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiTableElementCondition = Stimulsoft.Report.Dashboard.IStiTableElementCondition;
    class StiTableElementConditionHelper {
        private static getConditionResult;
        private static getConditionValue;
        static processBackColor(defaultColor: Color, keyColumn: string, tableElement: StiTableElement, rowValues: any[], columnKeys: string[]): Promise<Color>;
        static processForeColor(defaultColor: Color, keyColumn: string, tableElement: StiTableElement, rowValues: any[], columnKeys: string[]): Promise<Color>;
        static processForeAndBackColor(defaultForeColor: Color, defaultBackColor: Color, keyColumn: string, tableElement: StiTableElement, rowValues: any[], columnKeys: string[]): Promise<{
            foreColor: Color;
            backColor: Color;
        }>;
        static processFontStyle(fontText: Font, keyColumn: string, tableElement: StiTableElement, rowValues: any[], columnKeys: string[]): Promise<FontStyle>;
        private static processFontStrikeout;
        private static processFontUnderline;
        private static processFontItalic;
        private static processFontBold;
        static getIconCondition(keyColumn: string, tableElement: StiTableElement, rowValues: any[], columnKeys: string[]): Promise<IStiTableElementCondition>;
    }
}
export namespace Stimulsoft.Dashboard.Components.Table {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiTableSection = Stimulsoft.Report.Dashboard.IStiTableSection;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    class StiTableSection implements IStiTableSection, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        static createFromJsonObject(jObject: StiJson): StiTableSection;
        static createFromXml(xmlNode: XmlNode): StiTableSection;
        clone(): any;
        isDefault(): boolean;
        private _backColor;
        get backColor(): Color;
        set backColor(value: Color);
        private shouldSerializeBackColor;
        private _foreColor;
        get foreColor(): Color;
        set foreColor(value: Color);
        private shouldSerializeForeColor;
        private _font;
        get font(): Font;
        set font(value: Font);
        private shouldSerializeFont;
        element: StiElement;
        private clearElementCache;
        constructor(font?: Font, foreColor?: Color, backColor?: Color);
    }
}
export namespace Stimulsoft.Dashboard.Components.Table.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    class StiDataBarsColumnConverter extends StiMeterConverter {
    }
}
export namespace Stimulsoft.Dashboard.Components.Table.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    class StiDimensionColumnConverter extends StiMeterConverter {
    }
}
export namespace Stimulsoft.Dashboard.Components.Table.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    class StiSparklinesColumnConverter extends StiMeterConverter {
    }
}
export namespace Stimulsoft.Dashboard.Components.Table.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    class StiTableColumnConverter extends StiMeterConverter {
    }
}
export namespace Stimulsoft.Dashboard.Interactions {
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import List = Stimulsoft.System.Collections.List;
    class StiTextDashboardInteraction extends StiDashboardInteraction {
        ident: StiInteractionIdent;
        availableOnClick: number;
        onClick: StiInteractionOnClick;
        isDefault(): boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>);
    }
}
export namespace Stimulsoft.Dashboard.Components.Text {
    import StiTextMeasureMeter = Stimulsoft.Dashboard.Components.Text.StiTextMeasureMeter;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiTextMeasureMeter = Stimulsoft.Base.Meters.IStiTextMeasureMeter;
    import StiTextSizeMode = Stimulsoft.Report.Dashboard.StiTextSizeMode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    import IStiSimpleShadow = Stimulsoft.Report.Components.IStiSimpleShadow;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import List = Stimulsoft.System.Collections.List;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiHtmlTextHelper = Stimulsoft.Report.Dashboard.IStiHtmlTextHelper;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiTextElement = Stimulsoft.Report.Dashboard.IStiTextElement;
    import IStiVertAlignment = Stimulsoft.Report.Components.IStiVertAlignment;
    import IStiTextHorAlignment = Stimulsoft.Report.Components.IStiTextHorAlignment;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiTextFont = Stimulsoft.Report.Components.IStiTextFont;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    class StiTextElement extends StiElement implements IStiTextFont, IStiSimpleShadow, IStiCornerRadius, IStiForeColor, IStiTextHorAlignment, IStiVertAlignment, IStiTextElement, IStiTitleElement, IStiJsonReportObject, IStiGlobalizationProvider, IStiElementInteraction {
        implements(): any[];
        clone(cloneProperties: boolean): any;
        meta(): StiMeta[];
        get isDefined(): boolean;
        get isQuerable(): boolean;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        title: StiTitle;
        shadow: StiSimpleShadow;
        cornerRadius: StiCornerRadius;
        text: string;
        getSimpleText(): string;
        rightToLeft: boolean;
        getMeasures(): List<IStiTextMeasureMeter>;
        addMeasure(): void;
        getMeasure(cell: IStiAppDataCell): IStiTextMeasureMeter;
        removeMeasure(index: number): void;
        removeAllMeasures(): void;
        insertMeasure(index: number, meter: IStiTextMeasureMeter): void;
        group: string;
        foreColor: Color;
        crossFiltering: boolean;
        getFont(): Font;
        setFontName(fontName: string): void;
        setFontSize(fontSize: number): void;
        growFontSize(): void;
        shrinkFontSize(): void;
        setFontBoldStyle(isBold: boolean): void;
        setFontItalicStyle(isItalic: boolean): void;
        setFontUnderlineStyle(isUnderline: boolean): void;
        get horAlignment(): StiTextHorAlignment;
        set horAlignment(value: StiTextHorAlignment);
        get style(): string;
        set style(value: string);
        vertAlignment: StiVertAlignment;
        setString(propertyName: string, value: string): void;
        dashboardInteraction: IStiDashboardInteraction;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        sizeMode: StiTextSizeMode;
        measures: List<StiTextMeasureMeter>;
        get isReportParserExpression(): boolean;
        getNestedPages(): List<StiPage>;
        getHtmlTextHelper(): IStiHtmlTextHelper;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Components.Text.Design {
    class StiTextConverter {
    }
}
export namespace Stimulsoft.Dashboard.Components.TreeView {
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiTreeItem {
        key: any;
        meter: IStiMeter;
        items: List<StiTreeItem>;
        toString(): string;
        constructor(key?: any, meter?: IStiMeter);
    }
}
export namespace Stimulsoft.Dashboard.Components.TreeView {
    import StiFilterInclusionMode = Stimulsoft.Report.Dashboard.StiFilterInclusionMode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    import IStiSimpleShadow = Stimulsoft.Report.Components.IStiSimpleShadow;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import StiItemSelectionMode = Stimulsoft.Report.Dashboard.StiItemSelectionMode;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiTreeViewElement = Stimulsoft.Report.Dashboard.IStiTreeViewElement;
    import StiItemFilterMode = Stimulsoft.Report.Dashboard.StiItemFilterMode;
    class StiTreeViewElement extends StiElement implements IStiTreeViewElement, IStiSimpleShadow, IStiCornerRadius, IStiTitleElement, IStiGlobalizationProvider, IStiJsonReportObject {
        implements(): any[];
        clone(cloneProperties: boolean): any;
        meta(): StiMeta[];
        group: string;
        shadow: StiSimpleShadow;
        cornerRadius: StiCornerRadius;
        getParentKey(): string;
        setParentKey(key: string): void;
        applyDefaultFilters(): Promise<void>;
        getIdentityFilters(): List<StiDataFilterRule>;
        inclusionMode: StiFilterInclusionMode;
        title: StiTitle;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        userFilters: List<StiDataFilterRule>;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        font: Font;
        foreColor: Color;
        showAllValue: boolean;
        showBlanks: boolean;
        selectionMode: StiItemSelectionMode;
        filterMode: StiItemFilterMode;
        selectedValue: any;
        selectedKey: string;
        selectedLabel: string;
        selectedIndex: number;
        getKeyMeter(cell: IStiAppDataCell): IStiMeter;
        getKeyMeterByIndex(index: number): IStiMeter;
        insertKeyMeter(index: number, meter: IStiMeter): void;
        removeKeyMeter(index: number): void;
        removeAllKeyMeters(): void;
        addNewKeyMeter(): IStiMeter;
        addKey(cell: IStiAppDataCell): void;
        convertFrom(element: IStiElement): void;
        textFormat: StiFormatService;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        parentKey: string;
        keyMeters: List<StiKeyTreeViewMeter>;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Components.TreeView {
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import List = Stimulsoft.System.Collections.List;
    import StiTreeItem = Stimulsoft.Dashboard.Components.TreeView.StiTreeItem;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiTreeViewHelper {
        static fetchItems(dataTable: StiDataTable, showBlanks: boolean): List<StiTreeItem>;
        static fetchDefaultUserFilters(treeViewElement: StiTreeViewElement): Promise<List<StiDataFilterRule>>;
        static format(treeViewElement: StiTreeViewElement, value: any): string;
        static getValueMeterExpressions(element: StiTreeViewElement): List<string>;
    }
}
export namespace Stimulsoft.Dashboard.Components.TreeViewBox {
    import StiFilterInclusionMode = Stimulsoft.Report.Dashboard.StiFilterInclusionMode;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    import IStiSimpleShadow = Stimulsoft.Report.Components.IStiSimpleShadow;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import Size = Stimulsoft.System.Drawing.Size;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import StiItemSelectionMode = Stimulsoft.Report.Dashboard.StiItemSelectionMode;
    import StiItemFilterMode = Stimulsoft.Report.Dashboard.StiItemFilterMode;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiFixedHeightElement = Stimulsoft.Report.Dashboard.IStiFixedHeightElement;
    import IStiTreeViewBoxElement = Stimulsoft.Report.Dashboard.IStiTreeViewBoxElement;
    class StiTreeViewBoxElement extends StiElement implements IStiTreeViewBoxElement, IStiSimpleShadow, IStiCornerRadius, IStiFixedHeightElement, IStiJsonReportObject {
        implements(): any[];
        meta(): StiMeta[];
        clone(cloneProperties: boolean): any;
        group: string;
        get isFixedHeight(): boolean;
        getParentKey(): string;
        setParentKey(key: string): void;
        applyDefaultFilters(): Promise<void>;
        getIdentityFilters(): List<StiDataFilterRule>;
        inclusionMode: StiFilterInclusionMode;
        shadow: StiSimpleShadow;
        cornerRadius: StiCornerRadius;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        userFilters: List<StiDataFilterRule>;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        font: Font;
        foreColor: Color;
        showAllValue: boolean;
        showBlanks: boolean;
        selectionMode: StiItemSelectionMode;
        filterMode: StiItemFilterMode;
        selectedValue: any;
        selectedKey: string;
        selectedLabel: string;
        selectedIndex: number;
        getKeyMeter(cell: IStiAppDataCell): IStiMeter;
        getKeyMeterByIndex(index: number): IStiMeter;
        insertKeyMeter(index: number, meter: IStiMeter): void;
        removeKeyMeter(index: number): void;
        removeAllKeyMeters(): void;
        addNewKeyMeter(): IStiMeter;
        addKey(cell: IStiAppDataCell): void;
        convertFrom(element: IStiElement): void;
        textFormat: StiFormatService;
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        getMinSize(): Size;
        setMinSize(value: Size): void;
        getMaxSize(): Size;
        setMaxSize(value: Size): void;
        helpUrl: string;
        private _fixedHeight;
        get fixedHeight(): boolean;
        set fixedHeight(value: boolean);
        parentKey: string;
        keyMeters: List<StiKeyTreeViewBoxMeter>;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Components.TreeViewBox {
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import List = Stimulsoft.System.Collections.List;
    class StiTreeViewBoxHelper {
        static fetchDefaultUserFilters(treeViewBoxElement: StiTreeViewBoxElement): Promise<List<StiDataFilterRule>>;
        static format(treeViewBoxElement: StiTreeViewBoxElement, value: any): string;
        static getValueMeterExpressions(element: StiTreeViewBoxElement): List<string>;
    }
}
export namespace Stimulsoft.Dashboard.Components.WebContent {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import StiSimpleShadow = Stimulsoft.Base.Drawing.StiSimpleShadow;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiSimpleShadow = Stimulsoft.Report.Components.IStiSimpleShadow;
    import IStiCornerRadius = Stimulsoft.Report.Components.IStiCornerRadius;
    import IStiWebContentElement = Stimulsoft.Report.Dashboard.IStiWebContentElement;
    class StiWebContentElement extends StiElement implements IStiWebContentElement, IStiCornerRadius, IStiSimpleShadow, IStiTitleElement, IStiJsonReportObject {
        implements(): any[];
        clone(cloneProperties: boolean): any;
        meta(): StiMeta[];
        get isDefined(): boolean;
        get isQuerable(): boolean;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        title: StiTitle;
        url: string;
        embedCode: string;
        shadow: StiSimpleShadow;
        cornerRadius: StiCornerRadius;
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        get isURLExpressionOrHyperlinkDataColumnDefined(): boolean;
        get isURLExpressionDefined(): boolean;
        get isHyperlinkDataColumnDefined(): boolean;
        constructor(rect?: Rectangle);
    }
}
export namespace Stimulsoft.Dashboard.Design {
    class StiInplaceDesigner {
        static isEditorActivated: boolean;
    }
}
export namespace Stimulsoft.Dashboard.Design.Helpers {
    enum StiRichTextAlignment {
        Left = 1,
        Right = 2,
        Center = 3,
        Justify = 4
    }
}
export namespace Stimulsoft.Dashboard.Design.Helpers {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiRichBoxControl {
        selectionFont: Font;
        selectionColor: Color;
        selectionAlignment: StiRichTextAlignment;
        font: Font;
        text: string;
        selectedText: string;
        selectAll(): void;
        select(start: number, end: number): void;
        beginUpdate(): void;
        endUpdate(): void;
        setSelectionFont(face: string): boolean;
        setSelectionSize(size: number): boolean;
        setSelectionBold(bold: boolean): boolean;
        setSelectionItalic(italic: boolean): boolean;
        setSelectionUnderlined(underlined: boolean): boolean;
        constructor();
    }
}
export namespace Stimulsoft.Dashboard.Design.Helpers {
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import IStiHtmlTextHelper = Stimulsoft.Report.Dashboard.IStiHtmlTextHelper;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiRichBoxControl = Stimulsoft.Dashboard.Design.Helpers.StiRichBoxControl;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiHtmlTextHelper implements IStiHtmlTextHelper {
        setFontName(textObj: any, text: string, fontName: string, defaultColor: Color): string;
        setFontSize(textObj: any, text: string, fontSize: number, defaultColor: Color): string;
        growFontSize(textObj: any, text: string, defaultColor: Color): string;
        shrinkFontSize(textObj: any, text: string, defaultColor: Color): string;
        setFontBoldStyle(textObj: any, text: string, isBold: boolean, defaultColor: Color): string;
        setFontItalicStyle(textObj: any, text: string, isItalic: boolean, defaultColor: Color): string;
        setFontUnderlineStyle(textObj: any, text: string, isUnderline: boolean, defaultColor: Color): string;
        setColor(textObj: any, text: string, color: Color, defaultColor: Color): string;
        setHorAlignment(textObj: any, text: string, alignment: StiTextHorAlignment, defaultColor: Color): string;
        getFont(textObj: any, text: string, defaultColor: Color): Font;
        getColor(textObj: any, text: string, defaultColor: Color): Color;
        getHorAlign(textObj: any, text: string, defaultColor: Color): StiTextHorAlignment;
        setHtmlText(htmlText: string, textObj: any, richTextBox: StiRichBoxControl, defaultColor: Color): void;
        getHtmlText(richTextBox: StiRichBoxControl, defaultColor: Color): string;
        private getAlignment;
        private getAlignment2;
        getSimpleText(htmlText: string, defaultColor: Color): string;
    }
}
export namespace Stimulsoft.Dashboard.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    import Size = Stimulsoft.System.Drawing.Size;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    class StiAutoSizeHtmlTextHelper {
        static measure(g: Graphics, rect: Rectangle, text: string, textObj: any, scale?: number): Size;
        static getDefaultTextOptions(): StiTextOptions;
        private static getTextScale;
    }
}
export namespace Stimulsoft.Dashboard.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Size = Stimulsoft.System.Drawing.Size;
    import Font = Stimulsoft.System.Drawing.Font;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    class StiAutoSizeTextHelper {
        static toAlignment(alignment: StiHorAlignment): StiTextHorAlignment;
        static measure(g: Graphics, text: string, font: Font): Size;
        static measure2(g: Graphics, text: string, font: Font, width: number): Size;
        static measureFontSize(g: Graphics, text: string, rect: Rectangle, font: Font): number;
    }
}
export namespace Stimulsoft.Dashboard.Helpers {
    class StiBingMapHelper {
        private static getContent;
        static getScript(mapData: {
            [key: string]: string;
        }): string;
    }
}
export namespace Stimulsoft.Dashboard.Helpers {
    import List = Stimulsoft.System.Collections.List;
    import StiCardsColumn = Stimulsoft.Dashboard.Components.Cards.StiCardsColumn;
    class StiCardsElementHelper {
        static minDataColumnValue(column: StiCardsColumn, rows: List<any[]>, columnIndex: number): number;
        static maxDataColumnValue(column: StiCardsColumn, rows: List<any[]>, columnIndex: number): number;
    }
}
export namespace Stimulsoft.Dashboard.Visuals {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiVisual {
        draw(context: StiContext, rect: Rectangle): Promise<void>;
        drawArrowMore(context: StiContext, rect: Rectangle, factor: number): void;
    }
}
export namespace Stimulsoft.Dashboard.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiStringFormatHelper {
        static getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        static measureAlignmentParameters(alignment: StiHorAlignment, elementRectText: Rectangle, rotationMode: {
            ref: StiRotationMode;
        }, point: {
            ref: Point;
        }): void;
        static getFontSize(context: StiContext, rect: Rectangle, text: string, font: Font): number;
    }
}
export namespace Stimulsoft.Dashboard.Visuals.Cards {
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiCardsColumn = Stimulsoft.Dashboard.Components.Cards.StiCardsColumn;
    import Size = Stimulsoft.System.Drawing.Size;
    import StiColorScaleCardsColumn = Stimulsoft.Dashboard.Components.Cards.StiColorScaleCardsColumn;
    import StiCardsElementStyle = Stimulsoft.Report.Dashboard.Styles.StiCardsElementStyle;
    import StiBubbleCardsColumn = Stimulsoft.Dashboard.Components.Cards.StiBubbleCardsColumn;
    import StiIndicatorCardsColumn = Stimulsoft.Dashboard.Components.Cards.StiIndicatorCardsColumn;
    import IStiCellIndicatorStyle = Stimulsoft.Report.Dashboard.Styles.IStiCellIndicatorStyle;
    import StiSparklinesCardsColumn = Stimulsoft.Dashboard.Components.Cards.StiSparklinesCardsColumn;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiDataBarsCardsColumn = Stimulsoft.Dashboard.Components.Cards.StiDataBarsCardsColumn;
    import StiCardsElement = Stimulsoft.Dashboard.Components.Cards.StiCardsElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    class StiCardsCellDrawer {
        static dataBarsDraw(context: StiContext, rect: Rectangle, cards: StiCardsElement, style: StiCardsElementStyle, foreColor: Color, column: StiDataBarsCardsColumn, zoom: number, val: number, min: number, max: number): void;
        static colorScaleDraw(context: StiContext, rect: Rectangle, cards: StiCardsElement, style: StiCardsElementStyle, foreColor: Color, column: StiColorScaleCardsColumn, zoom: number, value: number, min: number, max: number): void;
        private static getScaleColor;
        static sparklinesDraw(context: StiContext, rect: Rectangle, column: StiSparklinesCardsColumn, value: any, style: StiCardsElementStyle): void;
        static castToArray(value: any): any[];
        static bubbleDraw(context: StiContext, rect: Rectangle, cards: StiCardsElement, style: StiCardsElementStyle, foreColor: Color, bubbleColumn: StiBubbleCardsColumn, zoom: number, value: number, min: number, max: number, drawText?: boolean): void;
        private static calculateBubbleRect;
        static indicatorDraw(context: StiContext, rect: Rectangle, cards: StiCardsElement, style: StiCardsElementStyle, column: StiIndicatorCardsColumn, zoom: number, value: number): void;
        static calculateTextRect(rect: Rectangle, column: any, zoom: number, textWidth: number, isExporting: boolean): Rectangle;
        static getColor(foreColor: Color, value: number, style: IStiCellIndicatorStyle): Color;
        static calculateIndicatorRect(rect: Rectangle, column: any, zoom: number, textWidth: number, isExporting: boolean): Rectangle;
        private static getHorAlignment;
        static getCellText(cards: StiCardsElement, column: StiCardsColumn, value: number): string;
        private static drawIndicator;
        static imageDraw(context: StiContext, rectItem: Rectangle, value: any): void;
        static drawWordWrapText(context: StiContext, text: string, font: Font, color: Color, horAlignment: StiHorAlignment, vertAlignment: StiVertAlignment, rect: Rectangle, rectSize: Size, zoom: number): void;
        static drawText(context: StiContext, text: string, font: Font, color: Color, horAlignment: StiHorAlignment, vertAlignment: StiVertAlignment, rect: Rectangle, rectSize: Size, zoom: number): void;
        static getMeasureText(context: StiContext, text: string, font: StiFontGeom, maxWidth: number): string;
    }
}
export namespace Stimulsoft.Dashboard.Visuals.Cards {
    import StiCardsElementStyle = Stimulsoft.Report.Dashboard.Styles.StiCardsElementStyle;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import Font = Stimulsoft.System.Drawing.Font;
    import Size = Stimulsoft.System.Drawing.Size;
    import StiSparklinesCardsColumn = Stimulsoft.Dashboard.Components.Cards.StiSparklinesCardsColumn;
    import StiCardsColumn = Stimulsoft.Dashboard.Components.Cards.StiCardsColumn;
    import List = Stimulsoft.System.Collections.List;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiCardsElement = Stimulsoft.Dashboard.Components.Cards.StiCardsElement;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCardsVisual extends StiVisual {
        style: StiCardsElementStyle;
        element: StiCardsElement;
        dataTable: StiDataTable;
        draw(context: StiContext, rect: Rectangle): Promise<void>;
        private paintCards;
        private static processTopNElements;
        processColumnsWithTopN(columns: List<StiCardsColumn>): List<any[]>;
        private unionRectangles;
        private zoomAndMoveUp;
        private getCardRectanglesList;
        private getRectanglesHorizontalOrientation;
        private getRectanglesVerticalOrientation;
        getContentRectangle(rect: Rectangle): Rectangle;
        private paintCardItem;
        private processRowValue;
        private static measureItem;
        private static measureCards;
        private static measureCards2;
        static measureDataBarsCell(context: StiContext, cards: StiCardsElement, column: StiCardsColumn, rowValue: any, zoom: number): Size;
        static measureSparklinesCell(sparklinesCardsColumn: StiSparklinesCardsColumn, zoom: number): Size;
        static measureIndicatorCell(context: StiContext, cards: StiCardsElement, column: StiCardsColumn, rowValue: any, zoom: number): Size;
        static measureBubbleCell(context: StiContext, cards: StiCardsElement, column: StiCardsColumn, rowValue: any, zoom: number): Size;
        private static getForeColor;
        static getFontGeom(font: Font, zoom: number): StiFontGeom;
        getColor(index: number): Color;
        getStyleColor(index: number): Color;
        private getInteractionDataGeom;
        private getToolTip;
        private getHyperlink;
        private getInteraction;
        private getConstants;
        constructor(element: StiCardsElement, dataTable: StiDataTable);
    }
}
export namespace Stimulsoft.Dashboard.Helpers {
    import IStiCardsVisualSvgHelper = Stimulsoft.Report.Dashboard.Visuals.IStiCardsVisualSvgHelper;
    class StiCardsVisualSvgHelper implements IStiCardsVisualSvgHelper {
        implements(): any[];
        writeCards(writer: Stimulsoft.System.Xml.XmlTextWriter, svgData: Stimulsoft.Report.Export.StiSvgData, refNeedToScroll?: any, refContentHeight?: any, refContentWidth?: any): Promise<void>;
        private static getDataTable;
    }
}
export namespace Stimulsoft.Dashboard.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import List = Stimulsoft.System.Collections.List;
    class StiElementLocationHelper {
        private static hashLocations;
        static IsWpfMode: boolean;
        static getSumRectangle(listLocationRectangles: List<Rectangle>): Rectangle;
        static getLocationRectangles(rect: Rectangle, countRect: number, element: IStiElement): List<Rectangle>;
        private static getMinRectangle;
        private static prepareColumnRow;
        private static getUsingRect;
        private static checkMinRect;
        private static getSimpleRect;
    }
}
export namespace Stimulsoft.Dashboard.Helpers {
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    import List = Stimulsoft.System.Collections.List;
    import StiGaugeIteration = Stimulsoft.Dashboard.Visuals.Gauge.StiGaugeIteration;
    import Font = Stimulsoft.System.Drawing.Font;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiGaugeElement = Stimulsoft.Dashboard.Components.Gauge.StiGaugeElement;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    import IStiGaugeVisualSvgHelper = Stimulsoft.Report.Dashboard.Visuals.IStiGaugeVisualSvgHelper;
    class StiGaugeVisualSvgHelper implements IStiGaugeVisualSvgHelper {
        implements(): any[];
        writeGauge(writer: XmlTextWriter, svgData: StiSvgData, needAnimation: boolean, refNeedToScroll?: any, refContentHeight?: any): Promise<void>;
        private paintTitle;
        static getTitleMinFontSize(g: Graphics, iterations: () => Promise<List<StiGaugeIteration>>, font: Font, width: number, height: number): Promise<number>;
        static getTitleHeight(g: Graphics, iterations: () => Promise<List<StiGaugeIteration>>, rect: Rectangle, element: StiGaugeElement, minSize: number): Promise<number>;
        private getInteractionDataGeom;
        private getToolTip;
        private getHyperlink;
        private parseConstants;
        private isEmptyData;
        private static getDataTable;
        getEmptyDataGauge(gaugeElement: StiGaugeElement): StiGauge;
        private getBulletEmptyDataGauge;
        private getHorizontalLinearEmptyDataGauge;
        private getLinearEmptyDataGauge;
        private getHalfCircularEmptyDataGauge;
        private getFullCircularEmptyDataGauge;
    }
}
export namespace Stimulsoft.Dashboard.Visuals.Indicator {
    class StiIndicatorIteration {
        series: string;
        value: number;
        target: number;
        constructor(series?: string, value?: number, target?: number);
    }
}
export namespace Stimulsoft.Dashboard.Render {
    import StiIndicatorIteration = Stimulsoft.Dashboard.Visuals.Indicator.StiIndicatorIteration;
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiIndicatorElement = Stimulsoft.Dashboard.Components.Indicator.StiIndicatorElement;
    class StiIndicatorElementBuilder extends StiElementBuilder {
        render(element: StiIndicatorElement, dataTable: StiDataTable): Promise<List<StiIndicatorIteration>>;
        private static processVariationSort;
        static processTopNElements(element: StiIndicatorElement, iterations: List<StiIndicatorIteration>): Promise<List<StiIndicatorIteration>>;
        private getValueMeterIndex;
        private getTargetMeterIndex;
        private getSeriesMeterIndex;
    }
}
export namespace Stimulsoft.Dashboard.Visuals.Indicator {
    import Size = Stimulsoft.System.Drawing.Size;
    import List = Stimulsoft.System.Collections.List;
    import StiIndicatorElement = Stimulsoft.Dashboard.Components.Indicator.StiIndicatorElement;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiIndicatorVisual extends StiVisual {
        private indent;
        private minSide;
        iterations: List<StiIndicatorIteration>;
        element: StiIndicatorElement;
        draw(context: StiContext, rect: Rectangle): Promise<void>;
        getContentRectangle(rect: Rectangle): Rectangle;
        private drawSingleMode;
        private getVariation;
        private getFactorByFontSize;
        private getRectanglesSingleMode;
        private processFontStyle;
        private processFontStrikeout;
        private processFontUnderline;
        private processFontItalic;
        private processFontBold;
        private processFontName;
        private processIcon;
        private processTargetIcon;
        private processCustomIcon;
        private processIconAlignment;
        private processTargetIconAlignment;
        private processBackColor;
        private processForeColor;
        private processGlyphColor;
        private processTargetIconColor;
        private getConditionResult;
        private getConditionValue;
        private drawMultiMode;
        private drawMultiModePresent;
        private calculateDeltaIconList;
        private drawMultiModeWithTarget;
        private getInteractionDataGeom;
        private getToolTip;
        private getHyperlink;
        private parseConstants;
        private getMaxValue;
        getTargetValues(): number[];
        private drawTextIcon;
        private getFontGeom;
        measureFontSize(context: StiContext, rect: Rectangle, text: string, font: {
            ref: number;
        }): void;
        protected getElementSide(isVerticalOrientation: boolean, size: Size): number;
        private getDisplayText;
        constructor(element: StiIndicatorElement, iterations: List<StiIndicatorIteration>);
    }
}
export namespace Stimulsoft.Dashboard.Helpers {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import IStiIndicatorVisualSvgHelper = Stimulsoft.Report.Dashboard.Visuals.IStiIndicatorVisualSvgHelper;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    class StiIndicatorVisualSvgHelper implements IStiIndicatorVisualSvgHelper {
        implements(): any[];
        writeIndicator(writer: XmlTextWriter, svgData: StiSvgData, refNeedToScroll?: any, refContentHeight?: any): Promise<void>;
        private p;
        private isEmptyData;
        private getStyleSampleIterations;
        private getEmptyDataIterations;
        private getEmptyDataIndicatorElement;
        private static getDataTable;
    }
}
export namespace Stimulsoft.Dashboard.Helpers {
    import Size = Stimulsoft.System.Drawing.Size;
    class StiOSMMapHelper {
        private static getContent;
        static getScript(mapData: {
            [key: string]: string;
        }): string;
        static getImage(size: Size, map: {
            mapImage: string;
        }, userBingKey: string, pushPins?: string[]): Promise<string>;
    }
}
export namespace Stimulsoft.Dashboard.Helpers {
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiOnlineMapElement = Stimulsoft.Dashboard.Components.OnlineMap.StiOnlineMapElement;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiOnlineMapHelper {
        private static _ICON;
        private static get ICON();
        private static _EMPTY_ICON;
        private static get EMPTY_ICON();
        private static MAX_LOCATIONS;
        private static MAX_CHART_SECTORS;
        private static MIN_RADIUS;
        private static MAX_RADIUS;
        private static CHART_RADIUS;
        private static DELTA_RADIUS;
        private static htmlNameToColor;
        private static lockHtmlNameToColor;
        static getBingMapScript(element: IStiElement, showTitle: boolean): Promise<string>;
        static calculateMapData(dataTable: StiDataTable, onlineMapElement: StiOnlineMapElement): {};
        static getChartData(dataTable: StiDataTable, locIndex: number, locValueIndex: number, locAgrumentIndex: number, locValue: {}): Hashtable;
        static toUnits(number: number): string;
        static getCustomIcon(bytes: number[], mapData: {}): void;
        static imageBytesToBase64String(image: number[]): string;
        static getColors(count: number): Color[];
        static getLongitudeMeterIndex(dataTable: StiDataTable): number;
        static getLatitudeMeterIndex(dataTable: StiDataTable): number;
        static getLocationMeterIndex(dataTable: StiDataTable): number;
        static getLocationColorMeterIndex(dataTable: StiDataTable): number;
        static getLocationArgumentMeterIndex(dataTable: StiDataTable): number;
        static getLocationValueMeterIndex(dataTable: StiDataTable): number;
        static parseColor(colorAttribute: string): Color;
    }
}
export namespace Stimulsoft.Dashboard.Helpers {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiPivotTableCells = Stimulsoft.Dashboard.Components.Table.StiPivotTableCells;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiPivotElementStyle = Stimulsoft.Report.Dashboard.Styles.StiPivotElementStyle;
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiPivotTableElement = Stimulsoft.Dashboard.Components.PivotTable.StiPivotTableElement;
    import StiCell = Stimulsoft.Report.CrossTab.Core.StiCell;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiPivotTableElement = Stimulsoft.Report.Dashboard.IStiPivotTableElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiPivotTableHelper {
        static summaryTypes: Hashtable<string, string>;
        static FieldMargin: number;
        static getHeadersBounds(cells: StiCell[][]): Rectangle;
        static getViewerData(pivotElement: IStiPivotTableElement): Promise<any>;
        private static cellItem;
        static applyStyle(pivot: StiPivotTableElement, crossTab: StiCrossTab, exportDataOnly: boolean): void;
        static getBackColor(element: IStiElement, cells: StiPivotTableCells, style: StiPivotElementStyle, isInterlaced: boolean, isTotal: boolean): Color;
        static getForeColor(element: IStiElement, cells: StiPivotTableCells, style: StiPivotElementStyle, isInterlaced: boolean, isTotal: boolean): Color;
        private static getColor;
        static buildCross(masterCrossTab: StiCrossTab, dataTable: StiDataTable, pivot: StiPivotTableElement, zoom?: number): void;
        static convertToCrossTab(pivot: StiPivotTableElement, dataTable: StiDataTable, zoom?: number): Promise<StiCrossTab>;
        static updateCrossTab(crossTab: StiCrossTab, pivot: StiPivotTableElement, dataTable: StiDataTable, zoom: number, build?: boolean): Promise<void>;
        private static fillInteraction;
        private static changeFontSize;
        private static getCondition;
        private static setupTitle;
        private static addToConversionStore;
        private static setupField;
        private static createRowTotal;
        private static createColTotal;
        private static getLabel;
        private static getSummaryTypes;
        private static setTopN;
        private static setSummaryType;
    }
}
export namespace Stimulsoft.Dashboard.Visuals.Progress {
    class StiProgressIteration {
        series: string;
        value: number;
        target: number;
        constructor(series?: string, value?: number, target?: number);
    }
}
export namespace Stimulsoft.Dashboard.Render {
    import StiProgressElement = Stimulsoft.Dashboard.Components.Progress.StiProgressElement;
    import StiProgressIteration = Stimulsoft.Dashboard.Visuals.Progress.StiProgressIteration;
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiProgressElementBuilder extends StiElementBuilder {
        render(element: StiProgressElement, dataTable: StiDataTable): Promise<List<StiProgressIteration>>;
        private static processVariationSort;
        static processTopNElements(element: StiProgressElement, iterations: List<StiProgressIteration>): Promise<List<StiProgressIteration>>;
        private getValueMeterIndex;
        private getTargetMeterIndex;
        private getSeriesMeterIndex;
    }
}
export namespace Stimulsoft.Dashboard.Visuals.Progress.Helpers {
    import List = Stimulsoft.System.Collections.List;
    import StiProgressElement = Stimulsoft.Dashboard.Components.Progress.StiProgressElement;
    class StiProgressVisualCreator {
        static createProgressVisual(element: StiProgressElement, iterations: List<StiProgressIteration>): StiProgressVisual;
    }
}
export namespace Stimulsoft.Dashboard.Helpers {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    import IStiProgressVisualSvgHelper = Stimulsoft.Report.Dashboard.Visuals.IStiProgressVisualSvgHelper;
    class StiProgressVisualSvgHelper implements IStiProgressVisualSvgHelper {
        implements(): any[];
        writeProgress(writer: XmlTextWriter, svgData: StiSvgData, refNeedToScroll?: any, refContentHeight?: any): Promise<void>;
        private p;
        private isEmptyData;
        private getStyleSampleIterations;
        private getEmptyDataIterations;
        private static getDataTable;
    }
}
export namespace Stimulsoft.Dashboard.Helpers {
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    class StiTableAlignmentHelper {
        static getHorAlign(cell: IStiAppDataCell): StiHorAlignment;
    }
}
export namespace Stimulsoft.Dashboard.Helpers {
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    class StiTableElementHelper {
        static minDataColumnValue(column: StiTableColumn, dataTable: StiDataTable, columnIndex: number): number;
        static maxDataColumnValue(column: StiTableColumn, dataTable: StiDataTable, columnIndex: number): number;
        static calculateTotal(column: StiTableColumn, columnIndex: number, dataTable: StiDataTable): number;
    }
}
export namespace Stimulsoft.Dashboard.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiTitle = Stimulsoft.Report.Dashboard.IStiTitle;
    import Font = Stimulsoft.System.Drawing.Font;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Size = Stimulsoft.System.Drawing.Size;
    class StiTitleMeasureHelper {
        static measureTitle(title: IStiTitle): Size;
        static measureTitle2(title: IStiTitle, titleText: string): Size;
        static measureTitle3(g: Graphics, rect: Rectangle, title: IStiTitle, titleText: string): Size;
        static measureTitle4(g: Graphics, rect: Rectangle, font: Font, titleText: string): Size;
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiWizardDashboardsHelper {
        static loadReport(report: StiReport, wizardName: string): void;
        private static financial;
        private static orders;
        private static salesOverview;
        private static ticketsStatistics;
        private static trafficAnalytics;
        private static vehicleProduction;
        private static websiteAnalytics;
    }
}
export namespace Stimulsoft.Dashboard.Images {
    class StiDashboardImages {
    }
}
export namespace Stimulsoft.Dashboard.Interactions {
    import StiMeta = Stimulsoft.Base.Meta.StiMeta;
    import IStiDashboardDrillDownParameter = Stimulsoft.Report.Dashboard.IStiDashboardDrillDownParameter;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiDashboardDrillDownParameter implements ICloneable, IStiJsonReportObject, IStiDashboardDrillDownParameter {
        clone(): any;
        protected _hash: StiMeta[];
        meta(): StiMeta[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(j: StiJson): void;
        loadFromXml(xn: XmlNode): void;
        static loadFromJson(json: StiJson): StiDashboardDrillDownParameter;
        static loadFromXml(xmlNode: XmlNode): StiDashboardDrillDownParameter;
        saveToString(): string;
        getStringRepresentation(): string;
        name: string;
        expression: string;
        constructor();
    }
}
export namespace Stimulsoft.Dashboard.Interactions.Design {
    class StiDashboardDrillDownParameterConverter {
    }
}
export namespace Stimulsoft.Dashboard.Interactions.Design {
    class StiDashboardInteractionConverter {
    }
}
export namespace Stimulsoft.Dashboard.Interactions.Design {
    class StiDashboardInteractionCreator {
        static new2(identName: string): StiDashboardInteraction;
    }
}
export namespace Stimulsoft.Dashboard.Interactions.Design {
    class StiDashboardInteractionJsonConverter {
    }
}
export namespace Stimulsoft.Dashboard.Interactions.Design {
    class StiTableDashboardInteractionConverter extends StiDashboardInteractionConverter {
    }
}
export namespace Stimulsoft.Dashboard.Options {
    import Type = Stimulsoft.System.Type;
    class StiDashboardOptions {
    }
    class Services {
        private static _elements;
        static get elements(): Type[];
    }
}
export namespace Stimulsoft.Dashboard.Options {
    import Type = Stimulsoft.System.Type;
    class StiDashboardElementsLoader {
        static fetchAll(): Type[];
        static load(): void;
    }
}
export namespace Stimulsoft.Dashboard.Render {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import IStiChartStyle = Stimulsoft.Report.Chart.IStiChartStyle;
    import StiReport = Stimulsoft.Report.StiReport;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiValueChartMeter;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiMeter = Stimulsoft.Dashboard.Components.StiMeter;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import List = Stimulsoft.System.Collections.List;
    import StiChartElement = Stimulsoft.Dashboard.Components.Chart.StiChartElement;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiChartElementBuilder extends StiElementBuilder {
        private indicatorValueValue;
        render(element: StiChartElement, dataTable: StiDataTable): Promise<IStiChart>;
        protected renderElements(element: StiChartElement, chart: IStiChart, dataTable: StiDataTable): Promise<void>;
        private proccessSelectArguments;
        static processTopNElements(element: StiChartElement, series: IStiSeries): Promise<void>;
        private static setStyle;
        protected static getDetailRows(rows: List<any[]>, argument: any, argumentIndexes: List<number>): List<any[]>;
        protected renderSeries(element: StiChartElement, value: StiMeter, seriesKey: string, chart: IStiChart): IStiSeries;
        private static renderSeriesPie3d;
        private static renderSeriesYAxis;
        static renderSeriesLine(valueMeter: StiValueChartMeter, series: IStiSeries): void;
        protected static renderSeriesShowZeros(valueMeter: StiValueChartMeter, series: IStiSeries): void;
        protected static renderSeriesShowNulls(valueMeter: StiValueChartMeter, series: IStiSeries): void;
        private static renderSeriesLighting;
        private static renderSeriesIcon;
        renderMarker(element: StiChartElement, series: IStiSeries): void;
        private renderSeriesNegativeColor;
        private renderSeriesParetoColor;
        protected renderArea(element: StiChartElement, chart: IStiChart): Promise<void>;
        private static getColorEach;
        private renderAxisAxes3d;
        private renderAxisAxes;
        private static renderInterlacingHor;
        private static renderInterlacingVert;
        private static renderGridLinesHor;
        private static renderGridLinesVert;
        private renderXAxis3D;
        private renderYAxis3D;
        private static renderXAxisTitleText3D;
        private static renderYAxisTitleText3D;
        private renderXAxis;
        private renderYAxis;
        private static renderXRadarAxis;
        private static renderXRadarAxisLabels;
        private static renderYRadarAxis;
        private static renderYRadarAxisLabels;
        private static renderRadarXAxisLabelsColor;
        private static renderRadarYAxisLabelsColor;
        private static checkValueFormat;
        private static renderYRightAxis;
        private static renderXAxisTitleText;
        private static renderYAxisTitleText;
        private static renderAxisLineColor;
        private static renderRadarAxis;
        private renderAreaIndicator;
        private static renderAxis3D;
        private static renderAxisTitle3D;
        private static renderAxis;
        private static renderAxisTitle;
        private static renderAxisLabels3D;
        private static renderAxisLabels;
        private static renderAxisStartFromZero;
        private static renderAxisShowEdgeValues;
        private static renderAxisRange;
        private static renderAxisLabelsTitleColor;
        private static renderAxisLabelsTitleColor3D;
        private static renderAxisLabelsColor3D;
        private static renderAxisLabelsColor;
        private static getTitleAxisChart;
        private renderLegend;
        private static getChartLegendHotAlignment;
        private static getChartLegendVertAlignment;
        private static getChartLegendVisible;
        private static renderLegendTitleColor;
        private static renderSeriesLabelsLegendValueType;
        private static renderLegendLabelsColor;
        protected static renderConditions(seriesKey: string, series: IStiSeries, element: StiChartElement, valueMeter: StiMeter): Promise<void>;
        private static renderValueConditions;
        private static renderEndValueConditions;
        private static renderArgumentConditions;
        private static renderSeriesConditions;
        private static getConditionResult;
        private static renderConstantLines;
        private static renderStrips;
        protected static renderTrendLines(series: IStiSeries, element: StiChartElement, valueMeter: StiMeter): void;
        private static getTrendLine;
        private renderSeriesLabels;
        private static renderLabelsShowZeros;
        private static renderLabelsShowNulls;
        private static applyPropertiesToSeriesLabels;
        private static renderPieLabelsAutoRotate;
        private static renderLabelsColor;
        private static renderLabelsTextFormat;
        private static renderFunnelLabelsPosition;
        private static renderPictorialStackedLabelsPosition;
        private static renderTreemapLabelsPosition;
        private static renderHeatmapLabelsPosition;
        private static renderPieLabelsPosition;
        private static renderPie3dLabelsPosition;
        private static renderStackedLabelsPosition;
        private static renderRadarLabelsPosition;
        private static renderWaterfallLabelsPosition;
        private static renderAxisLabelsPosition;
        private static renderClusteredColumn3DLabelsPosition;
        private renderLine3DLabelsPosition;
        private static renderDoughnutLabelsPosition;
        private static renderPieLabelsStyle;
        private static renderLabelsStyle;
        protected renderSeriesInteraction(series: IStiSeries, element: StiChartElement, count: number, seriesKey: string): Promise<void>;
        private getToolTip;
        getToolTipStyle(style: IStiChartStyle): Promise<string>;
        private getHyperlink;
        private getIdentFromArgument;
        getTitle(meter: StiMeter): string;
        protected getSeriesTitle(element: StiChartElement, seriesKey: string, meter: StiMeter): string;
        protected getArgumentIndex(dataTable: StiDataTable, index: number): number;
        private simplifyValues;
        getShorterListPoints(series: IStiSeries): Point[];
        protected getString(format: StiFormatService, value: any, report: StiReport): string;
        private getFormatValue;
        private calculateIndicatorValue;
        static create(chart: StiChartElement): StiChartElementBuilder;
        static scaleFont(chart: IStiChart, scale: number, threshold?: number): void;
        private static getStyleFont;
        private static getSmallStyleFont;
        protected getValueMeterIndexes(table: StiDataTable): number[];
        protected getArgumentMeterIndexes(table: StiDataTable): List<number>;
        protected getSeriesMeterIndex(table: StiDataTable): number;
        protected getArgumentKeys(element: IStiElement, table: StiDataTable): List<any>;
        protected getValueMeters(table: StiDataTable): List<StiMeter>;
        protected getArgumentMeters(table: StiDataTable): List<StiMeter>;
    }
}
export namespace Stimulsoft.Dashboard.Render {
    import List = Stimulsoft.System.Collections.List;
    import StiWeightChartMeter = Stimulsoft.Dashboard.Components.Chart.StiWeightChartMeter;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import StiMeter = Stimulsoft.Dashboard.Components.StiMeter;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiChartElement = Stimulsoft.Dashboard.Components.Chart.StiChartElement;
    class StiBubbleChartElementBuilder extends StiChartElementBuilder {
        protected renderElements(element: StiChartElement, chart: IStiChart, dataTable: StiDataTable): Promise<void>;
        protected renderSeries(element: StiChartElement, value: StiMeter, groupKey: string, chart: IStiChart): IStiSeries;
        protected renderSeriesInteraction(series: IStiSeries, element: StiChartElement, count: number, seriesKey: string): Promise<void>;
        private getHyperlink2;
        protected getWeightIndex(table: StiDataTable, index: number): number;
        protected getWeightMeterIndexes(table: StiDataTable): List<number>;
        protected getWeightMeters(table: StiDataTable): List<StiWeightChartMeter>;
        protected getValueMeters(table: StiDataTable): List<StiMeter>;
        protected getArgumentMeters(table: StiDataTable): List<StiMeter>;
    }
}
export namespace Stimulsoft.Dashboard.Render {
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import StiChartElement = Stimulsoft.Dashboard.Components.Chart.StiChartElement;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiMeter = Stimulsoft.Dashboard.Components.StiMeter;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import StiCloseValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiCloseValueChartMeter;
    import StiLowValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiLowValueChartMeter;
    import StiHighValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiHighValueChartMeter;
    import List = Stimulsoft.System.Collections.List;
    class StiFinancialChartElementBuilder extends StiChartElementBuilder {
        protected renderElements(element: StiChartElement, chart: IStiChart, dataTable: StiDataTable): Promise<void>;
        protected renderSeries(element: StiChartElement, value: StiMeter, groupKey: string, chart: IStiChart): IStiSeries;
        protected renderSeriesInteraction(series: IStiSeries, element: StiChartElement, count: number, seriesKey: string): Promise<void>;
        protected renderArea(element: StiChartElement, chart: IStiChart): Promise<void>;
        protected getValueMeters(table: StiDataTable): List<StiMeter>;
        protected getCloseValueIndex(table: StiDataTable, index: number): number;
        protected getCloseMeterIndexes(table: StiDataTable): List<number>;
        protected getCloseMeters(table: StiDataTable): List<StiCloseValueChartMeter>;
        protected getLowValueIndex(table: StiDataTable, index: number): number;
        protected getLowMeterIndexes(table: StiDataTable): List<number>;
        protected getLowMeters(table: StiDataTable): List<StiLowValueChartMeter>;
        protected getHighValueIndex(table: StiDataTable, index: number): number;
        protected getHighMeterIndexes(table: StiDataTable): List<number>;
        protected getHighMeters(table: StiDataTable): List<StiHighValueChartMeter>;
    }
}
export namespace Stimulsoft.Dashboard.Render {
    import List = Stimulsoft.System.Collections.List;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import StiMeter = Stimulsoft.Dashboard.Components.StiMeter;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiChartElement = Stimulsoft.Dashboard.Components.Chart.StiChartElement;
    class StiHeatmapChartElementBuilder extends StiChartElementBuilder {
        protected renderElements(element: StiChartElement, chart: IStiChart, dataTable: StiDataTable): Promise<void>;
        protected renderSeries(element: StiChartElement, value: StiMeter, groupKey: string, chart: IStiChart): IStiSeries;
        protected renderSeriesInteraction(series: IStiSeries, element: StiChartElement, count: number, seriesKey: string): Promise<void>;
        private getHyperlink3;
        protected getYValueIndex(table: StiDataTable, index: number): number;
        protected getYMeterIndexes(table: StiDataTable): List<number>;
        protected getYMeters(table: StiDataTable): List<StiMeter>;
        protected getXValueIndex(table: StiDataTable, index: number): number;
        protected getXMeterIndexes(table: StiDataTable): List<number>;
        protected getXMeters(table: StiDataTable): List<StiMeter>;
    }
}
export namespace Stimulsoft.Dashboard.Render {
    import StiMeter = Stimulsoft.Dashboard.Components.StiMeter;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import StiEndValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiEndValueChartMeter;
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import StiChartElement = Stimulsoft.Dashboard.Components.Chart.StiChartElement;
    class StiRangeChartElementBuilder extends StiChartElementBuilder {
        protected renderElements(element: StiChartElement, chart: IStiChart, dataTable: StiDataTable): Promise<void>;
        protected renderSeries(element: StiChartElement, value: StiMeter, groupKey: string, chart: IStiChart): IStiSeries;
        protected renderSeriesInteraction(series: IStiSeries, element: StiChartElement, count: number, seriesKey: string): Promise<void>;
        private getToolTip2;
        private getHyperlink2;
        protected getValueMeters(table: StiDataTable): List<StiMeter>;
        protected getEndValueIndex(table: StiDataTable, index: number): number;
        protected getEndValueMeterIndexes(table: StiDataTable): List<number>;
        protected getEndValueMeters(table: StiDataTable): List<StiEndValueChartMeter>;
    }
}
export namespace Stimulsoft.Dashboard.Render {
    import StiShape = Stimulsoft.Report.Components.StiShape;
    import StiShapeElement = Stimulsoft.Dashboard.Components.Shape.StiShapeElement;
    class StiShapeElementBuilder {
        render(element: StiShapeElement): StiShape;
    }
}
export namespace Stimulsoft.Dashboard.Render {
    import StiChartElement = Stimulsoft.Dashboard.Components.Chart.StiChartElement;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiStackedChartElementBuilder extends StiChartElementBuilder {
        protected renderElements(element: StiChartElement, chart: IStiChart, dataTable: StiDataTable): Promise<void>;
        private static getDataTable;
        private static getCountRow;
        private static getArguments;
        private static getValues;
        private static processTopNStackedChart;
        private static getListByColumnName;
    }
}
export namespace Stimulsoft.Dashboard.Render {
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import StiMeter = Stimulsoft.Dashboard.Components.StiMeter;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiChartElement = Stimulsoft.Dashboard.Components.Chart.StiChartElement;
    class StiSunburstChartElementBuilder extends StiChartElementBuilder {
        protected renderElements(element: StiChartElement, chart: IStiChart, dataTable: StiDataTable): Promise<void>;
        protected renderSeries(element: StiChartElement, value: StiMeter, seriesKey: string, chart: IStiChart): IStiSeries;
    }
}
export namespace Stimulsoft.Dashboard.Visualizers {
    import Type = Stimulsoft.System.Type;
    class StiVisualizer {
        private static typeToGdiVisualizer;
        private static typeToWpfVisualizer;
        private static lockObject;
        static getVisualizer(type: Type): StiVisualizer;
    }
}
export namespace Stimulsoft.Dashboard.Visualizers {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiGdiVisualizer extends StiVisualizer {
        render(element: IStiElement): void;
    }
}
export namespace Stimulsoft.Dashboard.Visualizers {
    class StiGdiVisualizerAttribute {
        visualizerTypeName: string;
    }
}
export namespace Stimulsoft.Dashboard.Visuals.Indicator {
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiIndicatorIconRangeValue {
        start: number;
        end: number;
        icon: StiFontIcons;
        isBetween(value: number): boolean;
        constructor(start: number, end: number, icon: StiFontIcons);
    }
}
export namespace Stimulsoft.Dashboard.Visuals.Progress {
    import StiIndicatorIteration = Stimulsoft.Dashboard.Visuals.Indicator.StiIndicatorIteration;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    import Font = Stimulsoft.System.Drawing.Font;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    import StiProgressElement = Stimulsoft.Dashboard.Components.Progress.StiProgressElement;
    import Color = Stimulsoft.System.Drawing.Color;
    import List = Stimulsoft.System.Collections.List;
    import StiProgressElementStyle = Stimulsoft.Report.Dashboard.Styles.StiProgressElementStyle;
    class StiProgressVisual extends StiVisual {
        protected style: StiProgressElementStyle;
        protected minElementSide: number;
        protected minFontSize: number;
        iterations: List<StiProgressIteration>;
        element: StiProgressElement;
        protected getDisplayText(iteration: StiProgressIteration, valuePercent: number): string;
        private getMaxValue;
        getTargetValues(): List<number>;
        getTextValues(): List<string>;
        getColor(index: number): Color;
        getColors(seriesCount: number): Color[];
        getContentRectangle(rect: Rectangle): Rectangle;
        private getConditionResult;
        protected processColor(color: Color, iteration: StiProgressIteration): Color;
        private getVariation;
        private getConditionValue;
        protected processForeColor(iteration: StiProgressIteration, defaultColor?: Color): Color;
        protected processTrackColor(color: Color, iteration: StiProgressIteration): Color;
        processFontStyle(fontText: Font, iteration: StiProgressIteration): FontStyle;
        private processFontStrikeout;
        private processFontUnderline;
        private processFontItalic;
        private processFontBold;
        protected processFontName(fontName: string, iteration: StiProgressIteration): string;
        getInteractionDataGeom(iteration: StiIndicatorIteration): StiInteractionDataGeom;
        private getToolTip;
        private getHyperlink;
        private parseConstants;
        constructor(element: StiProgressElement, iterations: List<StiProgressIteration>);
    }
}
export namespace Stimulsoft.Dashboard.Visuals.Progress {
    import List = Stimulsoft.System.Collections.List;
    import StiProgressElement = Stimulsoft.Dashboard.Components.Progress.StiProgressElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiPieProgressVisual extends StiProgressVisual {
        draw(context: StiContext, rectMain: Rectangle): Promise<void>;
        private drawPieProgress;
        getTitleHeight(elementSide: number, size: number): number;
        constructor(element: StiProgressElement, iterations: List<StiProgressIteration>);
    }
}
export namespace Stimulsoft.Dashboard.Visuals.Progress {
    import List = Stimulsoft.System.Collections.List;
    import StiProgressElement = Stimulsoft.Dashboard.Components.Progress.StiProgressElement;
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiCircleProgressVisual extends StiPieProgressVisual {
        draw(context: StiContext, rectMain: Rectangle): Promise<void>;
        protected getPoint(centerPie: Point, radius: number, angle: number): Point;
        constructor(element: StiProgressElement, iterations: List<StiProgressIteration>);
    }
}
export namespace Stimulsoft.Dashboard.Visuals.Progress {
    import List = Stimulsoft.System.Collections.List;
    import StiProgressElement = Stimulsoft.Dashboard.Components.Progress.StiProgressElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiDataBarsProgressVisual extends StiProgressVisual {
        draw(context: StiContext, rect: Rectangle): Promise<void>;
        private isColorLight;
        constructor(element: StiProgressElement, iterations: List<StiProgressIteration>);
    }
}
export namespace Stimulsoft.Dashboard.Export {
    enum StiDashboardExportFormat {
        Pdf = 0,
        Excel = 1,
        Data = 2,
        Image = 3,
        Html = 4,
        Document = 5
    }
}
export namespace Stimulsoft.Dashboard.Export.Settings {
    import StiPageOrientation = Stimulsoft.Report.Components.StiPageOrientation;
    import PaperKind = Stimulsoft.System.Drawing.Printing.PaperKind;
    import IStiDashboardExportSettings = Stimulsoft.Report.Dashboard.Export.IStiDashboardExportSettings;
    import StiExportSettings = Stimulsoft.Report.Export.StiExportSettings;
    import StiExportFormat = Stimulsoft.Report.StiExportFormat;
    class StiDashboardExportSettings extends StiExportSettings implements IStiDashboardExportSettings {
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        implements(): any[];
        get isDesignMode(): boolean;
        format: StiDashboardExportFormat;
        renderBorders: boolean;
        renderSingleElement: boolean;
        renderSinglePage: boolean;
        orientation: StiPageOrientation;
        paperSize: PaperKind;
        openAfterExport: boolean;
        viewportWidth: number;
        viewportHeight: number;
        getExportFormat(): StiExportFormat;
        toParameters(): any;
    }
}
export namespace Stimulsoft.Dashboard.Export.Settings {
    import StiDashboardScaleMode = Stimulsoft.Report.Dashboard.StiDashboardScaleMode;
    let IStiDashboardScaleMode: System.Interface<IStiDashboardScaleMode>;
    interface IStiDashboardScaleMode {
        scaleMode: StiDashboardScaleMode;
    }
}
export namespace Stimulsoft.Dashboard.Export.Settings {
    let IStiSizeExportSettings: System.Interface<IStiSizeExportSettings>;
    interface IStiSizeExportSettings {
        width: number;
        height: number;
    }
}
export namespace Stimulsoft.Dashboard.Export.Settings {
    import IStiSizeExportSettings = Stimulsoft.Dashboard.Export.Settings.IStiSizeExportSettings;
    import StiDashboardScaleMode = Stimulsoft.Report.Dashboard.StiDashboardScaleMode;
    import IStiDashboardScaleMode = Stimulsoft.Dashboard.Export.Settings.IStiDashboardScaleMode;
    import StiImageType = Stimulsoft.Report.Export.StiImageType;
    import IStiImageDashboardExportSettings = Stimulsoft.Report.Dashboard.Export.IStiImageDashboardExportSettings;
    class StiImageDashboardExportSettings extends StiDashboardExportSettings implements IStiSizeExportSettings, IStiImageDashboardExportSettings, IStiDashboardScaleMode {
        implements(): any[];
        format: StiDashboardExportFormat;
        imageType: StiImageType;
        private _width;
        get width(): number;
        set width(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        scale: number;
        scaleMode: StiDashboardScaleMode;
        toParameters(): any;
        constructor(imageType?: StiImageType);
    }
}
export namespace Stimulsoft.Dashboard.Export.Settings {
    import StiImageType = Stimulsoft.Report.Export.StiImageType;
    class StiSvgDashboardExportSettings extends StiImageDashboardExportSettings {
        imageType: StiImageType;
        renderEmptyContent: boolean;
        designMode: boolean;
    }
}
export namespace Stimulsoft.Dashboard.Export.Settings {
    import StiDashboardScaleMode = Stimulsoft.Report.Dashboard.StiDashboardScaleMode;
    import IStiHtmlDashboardExportSettings = Stimulsoft.Report.Dashboard.Export.IStiHtmlDashboardExportSettings;
    class StiHtmlDashboardExportSettings extends StiDashboardExportSettings implements IStiHtmlDashboardExportSettings, IStiDashboardScaleMode {
        implements(): any[];
        format: StiDashboardExportFormat;
        imageQuality: number;
        scale: number;
        enableAnimation: boolean;
        scaleMode: StiDashboardScaleMode;
        toParameters(): any;
    }
}
export namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Type = Stimulsoft.System.Type;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiExportTool {
        private static typeToTool;
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        static getTool(type: Type): StiExportTool;
        static isAllowOpacity(settings: StiDashboardExportSettings): boolean;
        static getScaleFactor(destination: StiPanel, settings: StiDashboardExportSettings): number;
    }
}
export namespace Stimulsoft.Dashboard.Export.Helpers {
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiTitleExportHelper {
        static render(element: IStiElement, component: StiPanel, settings: StiDashboardExportSettings): Promise<Rectangle>;
        private static getTitleBackColor;
        private static getTitleForeColor;
        private static getTitleFont;
        private static getTitleText;
        static convert(alignment: StiHorAlignment): StiTextHorAlignment;
    }
}
export namespace Stimulsoft.Dashboard.Export.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiLayoutExportHelper {
        static excludeMargin(element: IStiElement, rect: Rectangle): Rectangle;
        static excludePadding(element: IStiElement, rect: Rectangle, scaleFactor: number): Rectangle;
        static excludeCornerRadius(element: IStiElement, rect: Rectangle, scaleFactor: number): Rectangle;
    }
}
export namespace Stimulsoft.Dashboard.Export.Helpers {
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiBorderExportHelper {
        static render(element: IStiElement, component: StiComponent, settings: StiDashboardExportSettings): void;
    }
}
export namespace Stimulsoft.Dashboard.Export.Helpers {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiBackColorExportHelper {
        static render(element: IStiElement, component: StiComponent): void;
    }
}
export namespace Stimulsoft.Dashboard.Export.Helpers {
    import StiExportFormat = Stimulsoft.Report.StiExportFormat;
    class StiExportFormatHelper {
        static convert(format: StiDashboardExportFormat): StiExportFormat;
    }
}
export namespace Stimulsoft.Dashboard.Export.Settings {
    import IStiSizeExportSettings = Stimulsoft.Dashboard.Export.Settings.IStiSizeExportSettings;
    import StiDashboardScaleMode = Stimulsoft.Report.Dashboard.StiDashboardScaleMode;
    import IStiExcelDashboardExportSettings = Stimulsoft.Report.Dashboard.Export.IStiExcelDashboardExportSettings;
    class StiExcelDashboardExportSettings extends StiDashboardExportSettings implements IStiSizeExportSettings, IStiExcelDashboardExportSettings, IStiDashboardScaleMode {
        implements(): any[];
        format: StiDashboardExportFormat;
        private _width;
        get width(): number;
        set width(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        imageQuality: number;
        exportDataOnly: boolean;
        scaleMode: StiDashboardScaleMode;
        toParameters(): any;
    }
}
export namespace Stimulsoft.Dashboard.Export.Settings {
    import StiDashboardScaleMode = Stimulsoft.Report.Dashboard.StiDashboardScaleMode;
    import IStiDashboardScaleMode = Stimulsoft.Dashboard.Export.Settings.IStiDashboardScaleMode;
    import IStiPdfDashboardExportSettings = Stimulsoft.Report.Dashboard.Export.IStiPdfDashboardExportSettings;
    class StiPdfDashboardExportSettings extends StiDashboardExportSettings implements IStiPdfDashboardExportSettings, IStiDashboardScaleMode {
        implements(): any[];
        format: StiDashboardExportFormat;
        autoPrint: boolean;
        imageQuality: number;
        scaleMode: StiDashboardScaleMode;
        toParameters(): any;
    }
}
export namespace Stimulsoft.Dashboard.Export.Settings {
    import StiDataType = Stimulsoft.Report.Export.StiDataType;
    import IStiDataDashboardExportSettings = Stimulsoft.Report.Dashboard.Export.IStiDataDashboardExportSettings;
    class StiDataDashboardExportSettings extends StiDashboardExportSettings implements IStiDataDashboardExportSettings {
        implements(): any[];
        format: StiDashboardExportFormat;
        dataType: StiDataType;
        toParameters(): any;
        constructor(dataType?: StiDataType);
    }
}
export namespace Stimulsoft.Dashboard.Export.Helpers {
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiExportFormat = Stimulsoft.Report.StiExportFormat;
    import StiExportSettings = Stimulsoft.Report.Export.StiExportSettings;
    class StiExportSettingsHelper {
        static getExportSettings(settings: StiDashboardExportSettings): StiExportSettings;
        static getDashboardExportSettings(settings: StiExportSettings): StiDashboardExportSettings;
        static getDashboardExportSettings2(format: StiExportFormat): StiDashboardExportSettings;
        static isDataExport(settings: StiDashboardExportSettings): boolean;
    }
}
export namespace Stimulsoft.Dashboard.Export.Tools {
    import IStiControlElement = Stimulsoft.Report.Dashboard.IStiControlElement;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import Image = Stimulsoft.System.Drawing.Image;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    class StiElementExportTool extends StiExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        protected renderContent(element: IStiElement, destination: StiPanel, rect: Rectangle): Promise<void>;
        private drawElement;
        protected draw(element: IStiElement, rect: Rectangle): Promise<Image>;
        protected paintContent(g: Graphics, rect: Rectangle, element: IStiElement): Promise<void>;
        paintAtom(g: Graphics, rect: Rectangle, element: IStiElement): Promise<void>;
        static getDataTable(element: IStiElement): Promise<StiDataTable>;
        protected renderEmptyDataMessage(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): boolean;
        format(element: IStiControlElement, value: any): string;
        private getEmptyDataImage;
    }
}
export namespace Stimulsoft.Dashboard.Export.Tools {
    import List = Stimulsoft.System.Collections.List;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    class StiChartElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings, chartStartValues?: List<number[]>): Promise<void>;
    }
}
export namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiGaugeElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        private renderSingleGaugeFromIteration;
        private renderSingleGaugeTitleFromIteration;
    }
}
export namespace Stimulsoft.Dashboard.Export.Tools {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    class StiImageElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        protected renderContent(element: IStiElement, destination: StiPanel, rect: Rectangle): Promise<void>;
        private calculateHorAlignmentPosition;
        private calculateVertAlignmentPosition;
    }
}
export namespace Stimulsoft.Dashboard.Export {
    import StiExportSettings = Stimulsoft.Report.Export.StiExportSettings;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiExportFormat = Stimulsoft.Report.StiExportFormat;
    import IStiAppCell = Stimulsoft.Base.IStiAppCell;
    import List = Stimulsoft.System.Collections.List;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiDashboardExportTools {
        static exportAsync(onExport: Function, cell: IStiAppCell, settings: (StiExportSettings | StiDashboardExportSettings) | StiExportFormat): void;
        static export(cell: IStiAppCell, settings: (StiExportSettings | StiDashboardExportSettings) | StiExportFormat): Promise<number[]>;
        private static exportToStream;
        private static renderCellReportAsync;
        private static renderCellDashboardAsync;
        private static renderCellElement;
        private static renderDashboardAsync;
        private static renderSingleElementAsync;
        private static setUpPage;
        static renderElementsAsync(parent: StiContainer, elements: List<IStiElement>, scaleX: number, scaleY: number, settings: StiDashboardExportSettings): Promise<void>;
        static renderElementAsync(parent: StiContainer, element: IStiElement, scaleX: number, scaleY: number, settings: StiDashboardExportSettings, chartStartValues?: List<number[]>, refTitleRect?: {
            ref: Rectangle;
        }, chartAnimations?: List<StiAnimation>): Promise<StiComponent>;
    }
}
export namespace Stimulsoft.Dashboard.Drawing.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    class StiElementControlPainter {
        static getBorderContentRect(rect: Rectangle, border: StiBorder): Rectangle;
    }
}
export namespace Stimulsoft.Dashboard.Drawing.Helpers {
    class StiLocHelper {
        static get locAll(): string;
    }
}
export namespace Stimulsoft.Dashboard.Export.Painters.Table {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiIndicatorColumn = Stimulsoft.Dashboard.Components.Table.StiIndicatorColumn;
    import StiTableElement = Stimulsoft.Dashboard.Components.Table.StiTableElement;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiTableElementStyle = Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import StiSvgGeomWriter = Stimulsoft.Report.Export.StiSvgGeomWriter;
    class StiIndicatorCellPainter {
        static draw(writer: StiSvgGeomWriter, rect: RectangleD, table: StiTableElement, rowValues: any[], columnKeys: string[], column: StiIndicatorColumn, zoom: number, value: number, style: StiTableElementStyle, drawText?: boolean): Promise<void>;
        static draw2(writer: StiSvgGeomWriter, rect: RectangleD, table: StiTableElement, rowValues: any[], columnKeys: string[], column: StiIndicatorColumn, zoom: number, value: number, style: StiTableElementStyle, str: string, drawText?: boolean): Promise<void>;
        private static drawIndicator;
        private static drawText;
        static measureText(zoom: number, text: string, baseFont: Font): number;
        private static calculateIndicatorRect;
        static getCellText(table: StiTableElement, column: StiIndicatorColumn, value: number): string;
        static calculateTextRect(rect: Rectangle, textObj: any): Rectangle;
        static getColor(column: StiTableColumn, value: number, style: StiTableElementStyle): Color;
        private static toAlignment2;
        static toAlignment(value: StiHorAlignment): StringAlignment;
        private static getHorAlignment;
    }
}
export namespace Stimulsoft.Dashboard.Drawing.Painters {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiTableCells = Stimulsoft.Dashboard.Components.Table.StiTableCells;
    import List = Stimulsoft.System.Collections.List;
    import Size = Stimulsoft.System.Drawing.Size;
    import Font = Stimulsoft.System.Drawing.Font;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiTableElement = Stimulsoft.Dashboard.Components.Table.StiTableElement;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTableElementStyle = Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle;
    class StiTableElementGdiPainter {
        static getBackgroundColor(element: IStiElement, cells: StiTableCells, style: StiTableElementStyle, isInterlaced: boolean): Color;
        private static measureColumn;
        private static getArrowSize;
        private static getRightImageRect;
        static measureSparklinesCell(table: StiTableElement, columnWidth: number, zoom: number): Size;
        static measureIndicatorCell(g: Graphics, table: StiTableElement, column: StiTableColumn, rowValue: any, zoom: number): Size;
        static measureDataBarsCell(g: Graphics, table: StiTableElement, column: StiTableColumn, rowValue: any, zoom: number): Size;
        static measureBubbleCell(g: Graphics, table: StiTableElement, column: StiTableColumn, rowValue: any, zoom: number): Size;
        static measureCommonCell(g: Graphics, table: StiTableElement, column: StiTableColumn, rowValue: any, columnWidth: number, zoom: number): Size;
        static measureHeader(table: StiTableElement, column: StiTableColumn): Size;
        private static measureHeader2;
        static measureCell(caption: string, baseFont: Font, column: StiTableColumn): Size;
        private static measureCell2;
        static measureHeaders(columns: List<StiTableColumn>, baseFont: Font): number;
        private static captionSizeCache;
    }
}
export namespace Stimulsoft.Dashboard.Export.Painters.Table {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiTableElement = Stimulsoft.Dashboard.Components.Table.StiTableElement;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiTableElementStyle = Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle;
    import StiSvgGeomWriter = Stimulsoft.Report.Export.StiSvgGeomWriter;
    class StiBubbleCellPainter {
        static draw(writer: StiSvgGeomWriter, rect: RectangleD, table: StiTableElement, rowValues: any[], columnKeys: string[], column: StiTableColumn, zoom: number, value: number, min: number, max: number, isInterlaced: boolean, isSelected: boolean, drawText?: boolean): Promise<void>;
        static getForeColor(table: StiTableElement, column: StiTableColumn, style: StiTableElementStyle, isInterlaced: boolean, isSelected: boolean): Color;
        static calculateBubbleRect(table: StiTableElement, rect: RectangleD, textObj: object, value: number, min: number, max: number): RectangleD;
        static calculateTextRect(table: StiTableElement, rect: RectangleD, textObj: object): RectangleD;
        static getCellText(table: StiTableElement, column: StiTableColumn, value: number): string;
    }
}
export namespace Stimulsoft.Dashboard.Export.Painters.Table {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTableElementStyle = Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle;
    class StiColorScaleCellPainter {
        static getScaleColor(value: number, min: number, max: number, style: StiTableElementStyle, minimumColor: Color, maximumColor: Color): Color;
    }
}
export namespace Stimulsoft.Dashboard.Export.Painters.Table {
    import StiSvgGeomWriter = Stimulsoft.Report.Export.StiSvgGeomWriter;
    import IStiTableElementCondition = Stimulsoft.Report.Dashboard.IStiTableElementCondition;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiImage = Stimulsoft.Report.Components.StiImage;
    class StiConditionIconPainter {
        static drawIcon(g: StiSvgGeomWriter, condition: IStiTableElementCondition, rect: RectangleD, zoom: number): Promise<void>;
        static adjustCellContentRectWithIcon(rect: RectangleD, condition: IStiTableElementCondition): RectangleD;
        static getImageWithConditionIcon(condition: IStiTableElementCondition, parentRect: RectangleD, tableName: string): Promise<StiImage>;
    }
}
export namespace Stimulsoft.Dashboard.Export.Painters.Table {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiTableElement = Stimulsoft.Dashboard.Components.Table.StiTableElement;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiDataBarsDirection = Stimulsoft.Dashboard.Components.Table.StiDataBarsDirection;
    import StiDataBarsBrushType = Stimulsoft.Dashboard.Components.Table.StiDataBarsBrushType;
    import StiTableElementStyle = Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle;
    import StiSvgGeomWriter = Stimulsoft.Report.Export.StiSvgGeomWriter;
    class StiDataBarsCellPainter {
        static draw(writer: StiSvgGeomWriter, rect: RectangleD, table: StiTableElement, rowValues: any[], columnKeys: any[], column: StiTableColumn, zoom: number, value: number, min: number, max: number, isInterlaced: boolean, isSelected: boolean, drawText?: boolean, direction?: StiDataBarsDirection, brushType?: StiDataBarsBrushType): Promise<void>;
        static draw2(writer: StiSvgGeomWriter, rect: RectangleD, value: number, min: number, max: number, zoom: number, text: string, table: StiTableElement, rowValues: any[], columnKeys: any[], column: StiTableColumn, isInterlaced: boolean, isSelected: boolean, drawText?: boolean, direction?: StiDataBarsDirection, brushType?: StiDataBarsBrushType): Promise<void>;
        private static getOverlappedColor;
        private static getColorPositive;
        private static getNegativeColor;
        private static getFillColor;
        static getForeColor(table: StiTableElement, column: StiTableColumn, style: StiTableElementStyle, isInterlaced: boolean, isSelected: boolean): Color;
        static calculateDataBarsRect(rect: RectangleD, textObj: object): RectangleD;
        static calculateTextRect(rect: RectangleD, textObj: object): RectangleD;
    }
}
export namespace Stimulsoft.Dashboard.Export.Painters.Table {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiTableElementStyle = Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle;
    import StiSvgGeomWriter = Stimulsoft.Report.Export.StiSvgGeomWriter;
    import StiSparklinesColumn = Stimulsoft.Dashboard.Components.Table.StiSparklinesColumn;
    class StiSparklinesCellPainter {
        static draw(writer: StiSvgGeomWriter, rect: RectangleD, column: StiSparklinesColumn, value: any, style: StiTableElementStyle): void;
        static castToArray(value: any): any[];
    }
}
export namespace Stimulsoft.Dashboard.Export.Painters.Table {
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiTableColumnSizeHelper {
        width: number;
        minWidth: number;
        maxWidth: number;
        maxHeight: number;
        wordWrap: boolean;
        fontUniqueCode: number;
        column: StiTableColumn;
        isMeasurable: boolean;
        getUniqueCode(): number;
        getColumnWidth(width: number, skipDefaultWidth?: boolean): number;
        getColumnHeight(height: number): number;
        static isWordWrap(column: StiTableColumn): boolean;
        constructor(font: Font, column: StiTableColumn);
    }
}
export namespace Stimulsoft.Dashboard.Export.Tools {
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiComboBoxElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        getValuesCount(element: IStiElement, dataTable: StiDataTable): number;
        private renderElement;
        private renderItem;
        private static getNameMeterIndex;
        private static getKeyMeterIndex;
        private static getRow;
    }
}
export namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiDatePickerElementExportTool extends StiElementExportTool {
        private storedCulture;
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        private getDateTimeString;
        private getRangeVariableString;
        private getAutoRangeColumnString;
        private getRangeColumnString;
    }
}
export namespace Stimulsoft.Dashboard.Export.Tools {
    import StiBorderSides = Stimulsoft.Base.Drawing.StiBorderSides;
    import List = Stimulsoft.System.Collections.List;
    import StiCheckStyle = Stimulsoft.Report.Components.StiCheckStyle;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiListBoxElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        private static getCheckStyle;
        protected renderItems(destination: StiPanel, rect: Rectangle, element: IStiElement, allowOpacity: boolean, scaleFactor: number): Promise<void>;
        protected renderItems2(destination: StiPanel, rect: Rectangle, element: IStiElement, values: List<string>, checks: List<StiCheckStyle>, expanders: List<boolean>, allowOpacity: boolean, scaleFactor: number): void;
        private getHorizontalItemAutoWidth;
        private measureItemWidth;
        protected renderItem(destination: StiPanel, rect: Rectangle, element: IStiElement, value: string, checkStyle: StiCheckStyle, lineSide: StiBorderSides, drawCheckBox: boolean, drawRadioButton: boolean, expandItem: boolean, allowOpacity: boolean, scaleFactor: number): void;
        private static renderCheckControl;
    }
}
export namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiNumberBoxElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        private paintItem;
        private paintSeparator;
        private paintNavButtons;
        private static formatValue;
        private static getSeparatorColor;
    }
}
export namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiOnlineMapElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
    }
}
export namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiPanelElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
    }
}
export namespace Stimulsoft.Dashboard.Export.Tools {
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiPivotTableElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        private static renderForWebDesigner;
        private static renderCells;
        private static convertSizes;
        private static convert;
    }
}
export namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiRegionMapElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
    }
}
export namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    class StiShapeElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
    }
}
export namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import IStiTableElement = Stimulsoft.Report.Dashboard.IStiTableElement;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiTableElement = Stimulsoft.Dashboard.Components.Table.StiTableElement;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    class StiTableElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        static renderCellsForViewer(element: IStiTableElement, tableElementGridPageNumbers: any, onlyCurrentPageData: boolean): Promise<any[]>;
        private static renderCells;
        static processDataTableWithTopN(dataTable: StiDataTable): StiDataTable;
        private static processTopNElements;
        private static measureSparklinesCell;
        private static measureHeader;
        private static measureFooter;
        private static measureIndicatorCell;
        private static measureDataBarsCell;
        private static measureBubbleCell;
        private static measureCommonCell;
        private static renderHeader;
        private static getHeaderAlignment;
        private static renderFooter;
        private static renderCurrentPageNumber;
        static renderCell(destination: StiPanel, rect: Rectangle, table: StiTableElement, rowValues: any[], columnKeys: string[], column: StiTableColumn, zoom: number, value: any, min: number, max: number, isInterlaced: boolean, format: StiDashboardExportFormat, exportDataOnly: boolean): Promise<void>;
        private static processRowValue;
        private static renderGraphicCell;
        private static drawColorScaleColumn;
        private static renderBoolCell2;
        private static renderTextCell;
        private static renderImageCell;
        private static renderBoolCell;
        private static getColumnVisibilityState;
        private static getForeColor;
        private static getHeaderBackColor;
        private static getHeaderForeColor;
        private static getFooterForeColor;
        private static getFooterBackColor;
        private static getBorderSides;
    }
}
export namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiTextElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        private changeFontSize;
        private static isExpressionWithVariables;
    }
}
export namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiTreeViewBoxElementExportTool extends StiComboBoxElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        getValuesCount(element: IStiElement, dataTable: StiDataTable): number;
    }
}
export namespace Stimulsoft.Dashboard.Export.Tools {
    import StiBorderSides = Stimulsoft.Base.Drawing.StiBorderSides;
    import StiCheckStyle = Stimulsoft.Report.Components.StiCheckStyle;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiTreeViewElementExportTool extends StiListBoxElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        private getCheckStyle;
        protected renderItems(destination: StiPanel, rect: Rectangle, element: IStiElement, allowOpacity: boolean, scaleFactor: number): Promise<void>;
        protected renderItem(destination: StiPanel, rect: Rectangle, element: IStiElement, value: string, checkStyle: StiCheckStyle, lineSide: StiBorderSides, drawCheckBox: boolean, drawRadioButton: boolean, expandItem: boolean, allowOpacity: boolean, scaleFactor: number): void;
        private static renderExpander;
    }
}
export namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiWebContentElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        private paintHeader;
        private paintSeparator;
        private paintWebContent;
    }
}
export namespace Stimulsoft.Viewer {
    enum StiContentAlignment {
        Left = 0,
        Center = 1,
        Right = 2,
        Default = 3
    }
    enum StiInterfaceType {
        Auto = 0,
        Mouse = 1,
        Touch = 2,
        Mobile = 3
    }
    enum StiChartRenderType {
        Vector = 2,
        AnimatedVector = 3
    }
    enum StiPrintDestination {
        Default = 0,
        Pdf = 1,
        Direct = 2,
        WithPreview = 3
    }
    enum StiReportType {
        Auto = 0,
        Report = 1,
        Dashboard = 2
    }
    enum StiViewerTheme {
        Auto = 0,
        SimpleGray = 1,
        WindowsXP = 2,
        Windows7 = 3,
        Office2003 = 4,
        Office2007Blue = 5,
        Office2007Black = 6,
        Office2007Silver = 7,
        Office2010Blue = 8,
        Office2010Black = 9,
        Office2010Silver = 10,
        Office2013WhiteBlue = 11,
        Office2013WhiteCarmine = 12,
        Office2013WhiteGreen = 13,
        Office2013WhiteOrange = 14,
        Office2013WhitePurple = 15,
        Office2013WhiteTeal = 16,
        Office2013WhiteViolet = 17,
        Office2013LightGrayBlue = 18,
        Office2013LightGrayCarmine = 19,
        Office2013LightGrayGreen = 20,
        Office2013LightGrayOrange = 21,
        Office2013LightGrayPurple = 22,
        Office2013LightGrayTeal = 23,
        Office2013LightGrayViolet = 24,
        Office2013DarkGrayBlue = 25,
        Office2013DarkGrayCarmine = 26,
        Office2013DarkGrayGreen = 27,
        Office2013DarkGrayOrange = 28,
        Office2013DarkGrayPurple = 29,
        Office2013DarkGrayTeal = 30,
        Office2013DarkGrayViolet = 31,
        Office2013VeryDarkGrayBlue = 32,
        Office2013VeryDarkGrayCarmine = 33,
        Office2013VeryDarkGrayGreen = 34,
        Office2013VeryDarkGrayOrange = 35,
        Office2013VeryDarkGrayPurple = 36,
        Office2013VeryDarkGrayTeal = 37,
        Office2013VeryDarkGrayViolet = 38,
        Office2022WhiteBlue = 39,
        Office2022WhiteCarmine = 40,
        Office2022WhiteGreen = 41,
        Office2022WhiteOrange = 42,
        Office2022WhitePurple = 43,
        Office2022WhiteTeal = 44,
        Office2022WhiteViolet = 45,
        Office2022LightGrayBlue = 46,
        Office2022LightGrayCarmine = 47,
        Office2022LightGrayGreen = 48,
        Office2022LightGrayOrange = 49,
        Office2022LightGrayPurple = 50,
        Office2022LightGrayTeal = 51,
        Office2022LightGrayViolet = 52,
        Office2022DarkGrayBlue = 53,
        Office2022DarkGrayCarmine = 54,
        Office2022DarkGrayGreen = 55,
        Office2022DarkGrayOrange = 56,
        Office2022DarkGrayPurple = 57,
        Office2022DarkGrayTeal = 58,
        Office2022DarkGrayViolet = 59,
        Office2022BlackBlue = 60,
        Office2022BlackCarmine = 61,
        Office2022BlackGreen = 62,
        Office2022BlackOrange = 63,
        Office2022BlackPurple = 64,
        Office2022BlackTeal = 65,
        Office2022BlackViolet = 66
    }
    enum StiWebViewMode {
        SinglePage = 0,
        Continuous = 1,
        MultiplePages = 2,
        OnePage = 3,
        WholeReport = 4,
        MultiPage = 5
    }
    enum StiShowMenuMode {
        Click = 0,
        Hover = 1
    }
    enum StiZoomMode {
        PageWidth = -1,
        PageHeight = -2
    }
    enum StiExportAction {
        ExportReport = 1,
        SendEmail = 2
    }
    enum StiFirstDayOfWeek {
        Auto = 0,
        Monday = 1,
        Sunday = 2
    }
    enum StiParametersPanelPosition {
        Top = 0,
        Left = 1,
        FromReport = 2
    }
    enum StiToolbarDisplayMode {
        Simple = 0,
        Separated = 1
    }
    enum StiWebUIIconSet {
        Auto = 0,
        Monoline = 1,
        Regular = 2
    }
}
export namespace Stimulsoft.Viewer {
    class StiEmailSettings {
        email: string;
        subject: string;
        message: string;
    }
}
export namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiExportFormat = Stimulsoft.Report.StiExportFormat;
    class StiDashboardsSvgHelper {
        private static getSvgImageValue;
        private static saveElementToVectorStringAsync;
        static saveElementToStringAsync(element: IStiElement, scaleX?: number, scaleY?: number, designMode?: boolean, exportFormat?: StiExportFormat, requestParams?: any, refNeedToScroll?: any): Promise<string>;
        static saveElementToBase64Async(element: IStiElement, scaleX?: number, scaleY?: number, designMode?: boolean, exportFormat?: StiExportFormat, requestParams?: any): Promise<string>;
        private static applyTransparencyToComponents;
        private static setCulture;
        private static restoreCulture;
    }
}
export namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import StiReport = Stimulsoft.Report.StiReport;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    import IStiControlElement = Stimulsoft.Report.Dashboard.IStiControlElement;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    class StiDashboardElementViewHelper {
        static getElementContentAttributesAsync(element: IStiElement, scaleX: number, scaleY: number, requestParams: any): Promise<KeyObjectType>;
        static getForeColor(element: IStiElement): string;
        static getBackColor(element: IStiElement): string;
        static getBorder(element: IStiElement): any;
        static getBorderJson(border: StiSimpleBorder): KeyObjectType;
        static getFont(element: IStiElement): any;
        static getFontJson(font: Font): KeyObjectType;
        private static getTitleBackColor;
        private static getTitleForeColor;
        private static getTitleFont;
        static getTitle(element: IStiElement): Promise<KeyObjectType>;
        private static getBrushStr;
        private static getStyleName;
        static applyComponentStyleToElement(element: IStiElement): void;
        private static getButtonIconSetProperty;
        private static getButtonVisualStatesProperty;
        private static getButtonStyleColors;
        static getControlElementSettings(element: IStiElement): KeyObjectType;
        static getLayout(element: IStiElement): KeyObjectType;
        private static fixColor;
        static getActionColors(element: IStiElement): KeyObjectType;
        static getBingMapScript(element: IStiElement, showTitle: boolean): Promise<string>;
        static getDashboardInteractionAsync(element: any): Promise<KeyObjectType>;
        private static getToolTipStyles;
        static getShadow(element: IStiElement): any;
        static getCornerRadius(cornerRadius: StiCornerRadius): any;
        static getDashboardWatermark(element: IStiElement): any;
        private static getWeaveWatermarkImages;
        private static getHyperlinkTextAsync;
        static format(element: IStiControlElement, value: any): string;
        static getConstants(value: string, cells: any): Hashtable;
        static parseDashboardDrillDownParameters(drillDownParameters: any[], report: StiReport): Promise<void>;
        private static imageToBase64;
        private static getTopN;
        private static getWebContentElementURL;
    }
}
export namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiRangeBand {
        top: number;
        bottom: number;
        get height(): number;
        originalTop: number;
        originalBottom: number;
        get originalHeight(): number;
        isFixed: boolean;
        toString(): string;
        intersect(rect: Rectangle): boolean;
        constructor(top: number, bottom: number);
    }
}
export namespace Stimulsoft.Viewer {
    import StiHtmlExportMode = Stimulsoft.Report.Export.StiHtmlExportMode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    import StiPromise = Stimulsoft.System.StiPromise;
    import StiRangeBand = Stimulsoft.Viewer.Helpers.Dashboards.StiRangeBand;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import List = Stimulsoft.System.Collections.List;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiReportHelper {
        static getHtmlColor(color: Color): string;
        private static round;
        private static round2;
        static getNestedPages(report: StiReport): StiPage[];
        static getDashboards(report: StiReport, combineReportPages: boolean): KeyObjectType[];
        private static getElementsPositions;
        private static correctElementLocations;
        static getDashboardPageAsync(report: StiReport, pageIndex: number, requestParams: any): StiPromise<KeyObjectType>;
        static getElementAttributesAsync(page: StiPage, element: IStiElement, renderSingleElement: boolean, requestParams: any, elementOldHeights: any, bands?: List<StiRangeBand>, totalFixedHeight?: number): Promise<KeyObjectType>;
        static getSingleElementContent(report: StiReport, requestParams: any): Promise<KeyObjectType>;
        static calculatePositionForEachBand(requestParams: any, elements: List<IStiElement>, page: StiPage, bands: {
            ref: List<StiRangeBand>;
        }, totalFixedHeight: {
            ref: number;
        }, component?: StiComponent): void;
        static applySorting(report: StiReport, parameters: any): void;
        static applyCollapsing(report: StiReport, parameters: any): void;
        static applyDrillDown(report: StiReport, renderedReport: StiReport, parameters: any, appliedValues: any, params: any, viewer: StiViewer): Promise<StiReport>;
        static applyDashboardDrillDown(report: StiReport, drillDownParameters: any, appliedValues: any, action: string): Promise<StiReport>;
        private static addBookmarkNode;
        static getBookmarksContent(report: StiReport, viewerId: string, pageNumber: number): string;
        private static getBookmarksPageIndexes;
        static getTableOfContentsPointers(report: StiReport, requestParams: StiRequestParams): any[];
        private static getBookmarkPointers;
        static getReportPreviewSettings(report: StiReport): KeyObjectType;
        static getReportDisplayModeFromReport(report: StiReport): StiHtmlExportMode;
        static getReportCultureParams(report: StiReport): any;
        static getPagesCount(report: StiReport, originalPageNumber: number, combineReportPages: boolean): number;
        static brushToStr(brush: StiBrush): string;
        static isMixedReport(report: StiReport): boolean;
        static checkEvalEvents(report: StiReport, viewer: StiViewer, callback: (result: boolean) => void): void;
    }
    class StiBookmarkTreeNode {
        parent: number;
        title: string;
        url: string;
        used: boolean;
        componentGuid: string;
    }
}
export namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDataSortsHelper {
        static applySorting(report: StiReport, parameters: any): void;
        static applySortsToElement(element: IStiElement, sorts: any[]): void;
        static getElementSorts(element: IStiElement): any[];
        static sortRuleItem(sortRule: StiDataSortRule): {
            [key: string]: string;
        };
        static getSortMenuItems(element: IStiElement): any[];
        private static getSortDirection;
        private static fetchAllArguments;
        private static fetchAllValues;
        private static fetchAllXValues;
        private static fetchAllYValues;
        private static getSeries;
        private static getSortBy;
        private static getManualDataTable;
        private static isValuePresentedInManualData;
        private static isArgumentPresentedInManualData;
        private static isSeriesPresentedInManualData;
    }
}
export namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    import IStiDrillDownElement = Stimulsoft.Data.Engine.IStiDrillDownElement;
    import StiReport = Stimulsoft.Report.StiReport;
    import List = Stimulsoft.System.Collections.List;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import Type = Stimulsoft.System.Type;
    import IStiQueryObject = Stimulsoft.Data.Engine.IStiQueryObject;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiDataFiltersHelper {
        static applyFiltering(report: StiReport, parameters: any): void;
        static applyFiltersToElement(element: IStiElement, filters: any[]): void;
        static getElementFilters(element: IStiElement): KeyObjectType[];
        static getFilterItems(report: StiReport, requestParams: any): any;
        private static getDataTable;
        static getViewData(report: StiReport, requestParams: any): Promise<any>;
        private static processRowValue;
        private static removeSystemMeters;
        static getDataTableFilterQueryStringRepresentation(element: IStiElement): string;
        static getDrillDownFilters(drillDownElement: IStiDrillDownElement): any[];
        static getDrillDownFiltersList(drillDownElement: IStiDrillDownElement): KeyObjectType[][];
        static isStringColumnType(element: IStiElement): boolean;
        static isBlankData(data: any): boolean;
        static resetAllFilters(report: StiReport, pageNumber: number): Promise<void>;
        private static applyFilterParameters;
        static filterRuleItem(filterRule: StiDataFilterRule): KeyObjectType;
        private static sortFilterMenuItem;
        static getFilterItemsHelper(query: IStiQueryObject, meters: List<IStiMeter>, columnIndex: number, sorts: List<StiDataSortRule>, filters: List<StiDataFilterRule>, element?: IStiElement): any;
        static typeToString(type: Type): string;
        static toFilterString(value: any, type?: Type): string;
        static toDisplayString(value: any, type?: Type): string;
        private static distinct;
        private static isValueCanBeFiltered;
        private static getLevel;
        private static setDefaultSelectionProps;
        static applyDefaultFiltersForFilterElements(report: StiReport): Promise<void>;
        static applyDefaultFiltersForFilterElements2(dashboard: StiPage): Promise<void>;
        private static applyDatePickerFiltersToVariable;
        static checkInvoikeResetAllFilters(report: StiReport, evnt: StiEvent, pageNumber: number): Promise<void>;
    }
}
export namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDashboardElementDrillDownHelper {
        static applyDashboardElementDrillDown(report: StiReport, parameters: any): void;
        static applyDrillDownToElement(element: IStiElement, filters: any[]): void;
        static applyDashboardElementDrillUp(report: StiReport, parameters: any): void;
        static applyDrillUpToElement(element: IStiElement): void;
    }
}
export namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import List = Stimulsoft.System.Collections.List;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import IStiChartElement = Stimulsoft.Report.Dashboard.IStiChartElement;
    class StiChartElementViewHelper {
        private static isAllowInteractive;
        static getArgumentColumnPath(chartElement: IStiChartElement): string;
        static getArguments(chartElement: IStiChartElement): string[];
        static getSeriesColumnPath(chartElement: IStiChartElement): string;
        static getBubleXColumnPath(chartElement: IStiChartElement): string;
        static getBubleYColumnPath(chartElement: IStiChartElement): string;
        static getHeatmapXColumnPath(chartElement: IStiChartElement): string;
        static getHeatmapYColumnPath(chartElement: IStiChartElement): string;
        static getSeriesValues(chart: IStiChart): List<number[]>;
        static getChartValuesFromCache(cacheGuid: string, requestParams: any): any;
        static saveChartValuesToCache(cacheGuid: string, page: StiPage, requestParams: any): void;
        static getChartAnimationsFromCache(element: IStiChartElement): any;
        static saveChartAnimationsToCache(element: IStiChartElement, page: StiPage): void;
        static isBubble(chartElement: IStiChartElement): boolean;
        static isHeatmap(chartElement: IStiChartElement): boolean;
        static getUserViewStates(chartElement: IStiChartElement): any[];
        static changeChartElementViewState(report: StiReport, requestParams: any): Promise<KeyObjectType>;
    }
}
export namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import StiReport = Stimulsoft.Report.StiReport;
    import IStiDatePickerElement = Stimulsoft.Report.Dashboard.IStiDatePickerElement;
    class StiDatePickerElementViewHelper {
        private static storedCulture;
        private static dateTimeFormat;
        static getAutoRangeValues(datePickerElement: IStiDatePickerElement): Promise<any>;
        static getVariableRangeValues(datePickerElement: IStiDatePickerElement): Promise<{
            [key: string]: string;
        }>;
        static getVariableValue(datePickerElement: IStiDatePickerElement): Promise<string>;
        static isVariablePresent(datePickerElement: IStiDatePickerElement): boolean;
        static isRangeVariablePresent(datePickerElement: IStiDatePickerElement): boolean;
        static getFormattedValues(report: StiReport, requestParams: any): any;
        static getColumnPath(datePickerElement: IStiDatePickerElement): string;
        static getSettings(datePickerElement: IStiDatePickerElement): any;
    }
}
export namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import StiTableElementStyle = Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle;
    import StiReport = Stimulsoft.Report.StiReport;
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    import IStiTableElement = Stimulsoft.Report.Dashboard.IStiTableElement;
    import IStiTableColumn = Stimulsoft.Base.Meters.IStiTableColumn;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTableElementViewHelper {
        static getTableData(tableElement: IStiTableElement, requestParams: any): Promise<KeyObjectType[][]>;
        static getTableHiddenData(tableElement: IStiTableElement): Promise<KeyObjectType[][]>;
        static getTableSettings(tableElement: IStiTableElement, tableStyle?: StiTableElementStyle): KeyObjectType;
        private static getHighlightedColor;
        private static getCellBackColor;
        static getCellForeColor(tableElement: IStiTableElement, column: IStiTableColumn, isInterlacedForeColor?: boolean, tableStyle?: StiTableElementStyle): Color;
        private static getCellBackColorInterlaced;
        private static getCellSelectedBackColor;
        private static getCellSelectedForeColor;
        private static getHeaderBackColor;
        private static getHeaderSelectedBackColor;
        private static getHeaderForeColor;
        private static getFooterBackColor;
        private static getFooterForeColor;
        private static getColumnVisibilityState;
        private static getCellAlignment;
        private static getSortLabel;
        private static getFilterLabel;
        static changeTableElementSelectColumns(report: StiReport, requestParams: any): Promise<KeyObjectType>;
        static getDataForTableElementPage(report: StiReport, requestParams: any): Promise<KeyObjectType>;
    }
}
export namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiButtonElementHelper {
        static applyButtonEvent(report: StiReport, parameters: any): void;
    }
}
export namespace Stimulsoft.Viewer {
    import ProcessXmlDataArgs = Stimulsoft.Report.ProcessXmlDataArgs;
    import ProcessXsdDataArgs = Stimulsoft.Report.ProcessXsdDataArgs;
    import ProcessDBaseDataArgs = Stimulsoft.Report.ProcessDBaseDataArgs;
    import ProcessCsvDataArgs = Stimulsoft.Report.ProcessCsvDataArgs;
    import ProcessJsonDataArgs = Stimulsoft.Report.ProcessJsonDataArgs;
    import ProcessGisDataArgs = Stimulsoft.Report.ProcessGisDataArgs;
    import ProcessExcelDataCommand = Stimulsoft.Report.ProcessExcelDataCommand;
    import ProcessSqlDataCommand = Stimulsoft.Report.ProcessSqlDataCommand;
    import ProcessODataDataCommand = Stimulsoft.Report.ProcessODataDataCommand;
    import PrepareVariablesObject = Stimulsoft.Report.PrepareVariablesObject;
    import EndProcessDataArgs = Stimulsoft.Report.EndProcessDataArgs;
    import BeginProcessDataArgs = Stimulsoft.Report.BeginProcessDataArgs;
    import PrepareVariablesArgs = Stimulsoft.Report.PrepareVariablesArgs;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiHtmlExportService = Stimulsoft.Report.Export.StiHtmlExportService;
    import StiPagesRange = Stimulsoft.Report.StiPagesRange;
    import StiExportFormat = Stimulsoft.Report.StiExportFormat;
    import StiExportSettings = Stimulsoft.Report.Export.StiExportSettings;
    import IStiDashboardExportSettings = Stimulsoft.Report.Dashboard.Export.IStiDashboardExportSettings;
    import EventDataArgs = Stimulsoft.Report.EventDataArgs;
    import ReportDataArgs = Stimulsoft.Report.ReportDataArgs;
    import AsyncDataArgs = Stimulsoft.Report.AsyncDataArgs;
    type PrintReportEventArgs = EventDataArgs & ReportDataArgs & AsyncDataArgs & {
        printAction: string;
        pageRange: StiPagesRange;
        callback: () => void;
    };
    type BeginExportReportArgs = EventDataArgs & ReportDataArgs & AsyncDataArgs & {
        action: StiExportAction;
        settings: IStiDashboardExportSettings | StiExportSettings;
        format: StiExportFormat;
        formatName: string;
        fileName: string;
        openAfterExport: boolean;
        callback: () => void;
    };
    type EndExportReportArgs = EventDataArgs & ReportDataArgs & AsyncDataArgs & {
        format: StiExportFormat;
        formatName: string;
        fileName: string;
        openAfterExport: boolean;
        data: string | number[] | Uint8Array;
        callback: () => void;
    };
    type InteractionArgs = EventDataArgs & ReportDataArgs & AsyncDataArgs & {
        action: string;
        variables: any;
        sortingParameters: any;
        collapsingParameters: any;
        drillDownParameters: any;
        filteringParameters: any;
        callback: () => void;
    };
    type EmailReportArgs = EventDataArgs & ReportDataArgs & {
        async: boolean;
        settings: StiEmailSettings;
        format: StiExportFormat;
        formatName: string;
        fileName: string;
        data: string | number[] | Uint8Array;
        callback: () => void;
    };
    type DesignReportArgs = EventDataArgs & ReportDataArgs & {};
    type ShowReportArgs = EventDataArgs & ReportDataArgs & AsyncDataArgs & {
        viewer: StiViewer;
        callback: () => void;
    };
    type OpenReportArgs = EventDataArgs & ReportDataArgs & AsyncDataArgs & {
        callback: () => void;
    };
    type OpenedReportArgs = EventDataArgs & ReportDataArgs & AsyncDataArgs & {
        callback: () => void;
    };
    class StiJsViewer {
        options: any;
        defaultParameters: any;
        controls: any;
        reportParams: any;
        tableElementGridPageNumbers: any;
        service: any;
        assignReport(report: StiReport): any;
        initAutoUpdateCache(jsText: any, jsObject: any): any;
        postAjax(url: string, data: any, callback?: any): any;
        postAction(action: string, bookmarkPage?: any, bookmarkAnchor?: any, componentGuid?: any): any;
        postEmail(format: string, settingsObject: any): any;
        postExport(format: string, settingsObject: any, action: StiExportAction): any;
        postReportResource(resourceName: string, viewType: string): any;
        postPrint(action: string): any;
        postOpen(fileName: string, content: string): any;
        postInteraction(params: any): any;
        postDesign(): any;
        getReportParameters(action: string): any;
        viewer: StiViewer;
        InitializeErrorMessageForm(): any;
        MessageFormForEventsAccess(): any;
        updateVisibleState(): any;
        showParametersPanel(data: any, jsObject: any): any;
        openNewWindow(url: any, name?: any, specs?: any): any;
        removeAllEvents(): any;
        stopAllTimers(): any;
        sortPropsInDrillDownParameters(obj: any): any;
        InitializeBookmarksPanel(): any;
        createPostParameters(data: any, asObject: boolean): any;
        dashboardProcessTimeout: number;
        showReportPage(data: any, jsObject: StiJsViewer): any;
        InitializePasswordForm(): any;
        isDarkModeOS(): any;
        static GetCookie(name: string): any;
        static SetCookie(name: string, value: any): any;
        collections: {
            loc: {};
        };
        static setImageSource(htmlImage: any, options: any, collections: any, name: string, transform: boolean): any;
        static checkImageSource(options: any, collections: any, name: string): boolean;
        static getImageSource(options: any, collections: any, name: string): string;
        static GetCookie(name: string): any;
        constructor(parameters: any, collections: any);
    }
    class StiBase64 {
    }
    class StiViewer {
        drillDownReportCache: any;
        private _renderAfterCreate;
        onPrepareVariables: (args: PrepareVariablesArgs, callback: (result: PrepareVariablesObject[] | PrepareVariablesArgs) => void) => void;
        onBeginProcessData: (args: BeginProcessDataArgs & ProcessODataDataCommand & ProcessSqlDataCommand & ProcessExcelDataCommand & ProcessGisDataArgs & ProcessJsonDataArgs & ProcessCsvDataArgs & ProcessDBaseDataArgs & ProcessXsdDataArgs & ProcessXmlDataArgs, callback: (result: any) => void) => void;
        onEndProcessData: (args: EndProcessDataArgs & ProcessODataDataCommand & ProcessSqlDataCommand & ProcessExcelDataCommand & ProcessGisDataArgs & ProcessJsonDataArgs & ProcessCsvDataArgs & ProcessDBaseDataArgs & ProcessXsdDataArgs & ProcessXmlDataArgs) => void;
        onPrintReport: (args: PrintReportEventArgs, callback: () => void) => void;
        onBeginExportReport: (args: BeginExportReportArgs, callback: () => void) => void;
        onEndExportReport: (args: EndExportReportArgs, callback: () => void) => void;
        onInteraction: (args: InteractionArgs, callback: () => void) => void;
        onEmailReport: (args: EmailReportArgs, callback: () => void) => void;
        onDesignReport: (args: DesignReportArgs) => void;
        onShowReport: (args: ShowReportArgs, callback: () => void) => void;
        onOpenReport: (args: OpenReportArgs, callback: () => void) => void;
        onOpenedReport: (args: OpenedReportArgs, callback: () => void) => void;
        private reportCache;
        viewerId: string;
        options: StiViewerOptions;
        jsObject: StiJsViewer;
        currentReportGuid: string;
        get reportTemplate(): StiReport;
        get report(): StiReport;
        set report(value: StiReport);
        private _visible;
        get visible(): boolean;
        set visible(value: boolean);
        private _element;
        renderHtml(element?: string | HTMLElement): void;
        invokeComponentsEvents(params: any): void;
        private invokePrepareVariables;
        private invokeBeginProcessData;
        private invokeEndProcessData;
        private invokePrintReport;
        private invokeBeginExportReport;
        private invokeEndExportReport;
        private invokeInteraction;
        private invokeEmailReport;
        private invokeDesignReport;
        private invokeShowReport;
        private invokeOpenReport;
        private invokeOpenedReport;
        getReportPageAsync(report: StiReport, service: StiHtmlExportService, pageIndex: number, zoom: number, openLinksWindow: string): any;
        private getPagesArray;
        private getReportFileName;
        showProcessIndicator(): void;
        hideProcessIndicator(): void;
        refreshViewer(): void;
        dispatch(removeEvent?: boolean): void;
        dispose(removeEvent?: boolean): void;
        private getAutoTheme;
        applyTheme(theme: StiViewerTheme): void;
        setTheme(theme: StiViewerTheme): void;
        constructor(options?: StiViewerOptions, viewerId?: string, renderAfterCreate?: boolean);
    }
}
export namespace Stimulsoft.Viewer {
    class StiViewerOptions {
        private requestResourcesUrl;
        private requestStylesUrl;
        private requestAbsoluteUrl;
        private productVersion;
        private actions;
        private server;
        private buildDate;
        private shortProductVersion;
        private cultureName;
        private localization;
        private cloudMode;
        private serverMode;
        private formValues;
        private requestUrl;
        appearance: StiAppearanceOptions;
        toolbar: StiToolbarOptions;
        exports: StiExportsOptions;
        email: StiEmailOptions;
        width: string;
        height: string;
        viewerId: string;
        reportDesignerMode: boolean;
        toParameters(): any;
        private getDefaultExportSettings;
        private serializeObject;
        private getCultureName;
    }
}
export namespace Stimulsoft.Viewer {
    class StiRequestParams {
        interaction: StiInteractionParams;
    }
    class StiInteractionParams {
        variables: {};
        sorting: {};
        collapsing: {};
        drillDown: any[];
        editable: {};
        dashboardFiltering: {};
        dashboardSorting: {};
    }
}
export namespace Stimulsoft.Viewer {
    class StiThemesHelper {
        static getThemeName(themeType: {}, themeValue: number): string;
        static getAccentTheme(themeType: {}, themeValue: number): string;
        private static replaceStyleConstants;
        static applyTheme(themeName: string, accentName: string, appName: string): void;
        static checkThemeInCss(appName: string): {
            version: string;
            date: string;
            themeName: string;
        };
        static getImage(obj: any, path: string[]): any;
        static getImageSource(sourceObject: any, options: any, name: string): {
            data: string;
            scale: number;
        };
        private static getImageSourceInternal;
        static setImageSource(sourceObject: any, htmlImage: any, options: any, name: string, transform: boolean): void;
    }
}
export namespace Stimulsoft.Viewer {
    class StiCollectionsHelper {
        static getLocalizationItems(): any;
        static getPaperSizesItems(): any[];
    }
}
export namespace Stimulsoft.Viewer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiEditableFieldsHelper {
        static checkEditableReport(report: StiReport): boolean;
        static applyEditableFieldsToReport(report: StiReport, parameters: any): void;
    }
}
export namespace Stimulsoft.Viewer {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiElectronicSignatureHelper {
        static applySignatures(report: StiReport, signatures: any[]): void;
        static clearSignature(report: StiReport, requestParams: StiRequestParams): void;
        static getSignatureData(report: StiReport, requestParams: StiRequestParams): any;
        private static getSignatureComponents;
        static getStylesForSignature(): any[];
        static checkSignedReport(report: StiReport): boolean;
        private static colorToString;
        static stringToColor(colorStr: string): Color;
        static jsonToFont(fontJson: any): Font;
        private static imageToBase64;
        static base64ToByteArray(base64String: string): number[];
    }
}
export namespace Stimulsoft.Viewer {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiExportFormat = Stimulsoft.Report.StiExportFormat;
    import IStiDashboardExportSettings = Stimulsoft.Report.Dashboard.Export.IStiDashboardExportSettings;
    import StiExportSettings = Stimulsoft.Report.Export.StiExportSettings;
    class StiExportsHelper {
        static getReportFileContentType(exportFormat: StiExportFormat, exportSettings: any): string;
        static getReportFileName(exportFormat: StiExportFormat, exportSettings: any, report: StiReport, isDashboard: boolean): string;
        private static getExportDocumentExt;
        static getExportSettings(exportFormat: StiExportFormat, exportSettings: any): StiExportSettings;
        private static getPdfExportSettings;
        private static getXpsExportSettings;
        private static getPowerPointExportSettings;
        private static getHtmlExportSettings;
        private static getTextExportSettings;
        private static getRtfExportSettings;
        private static getWordExportSettings;
        private static getOdtExportSettings;
        private static getExcelExportSettings;
        private static getOdsExportSettings;
        private static getDataExportSettings;
        private static getImageExportSettings;
        static getDashboardExportSettings(exportFormat: StiExportFormat, exportSettings: any): IStiDashboardExportSettings;
        private static getPdfDashboardExportSettings;
        private static getExcelDashboardExportSettings;
        private static getDataDashboardExportSettings;
        private static getImageDashboardExportSettings;
        private static getHtmlDashboardExportSettings;
        private static getEncoding;
        static exportDashboardAsync(requestParams: any, report: StiReport, exportSettings: IStiDashboardExportSettings): Promise<number[] | string>;
        static exportReportAsync(exportFormat: StiExportFormat, exportSettings: any, report: StiReport, settings: StiExportSettings): Promise<number[] | string | Uint8Array>;
    }
}
export namespace Stimulsoft.Viewer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiFindPanelHelper {
        static getPageNumberOfFoundResult(report: StiReport, requestParams: StiRequestParams, viewer: StiViewer): {
            [key: string]: number;
        };
    }
}
export namespace Stimulsoft.Viewer {
    class StiFontsHelper {
        static getFontNames(): any[];
    }
}
export namespace Stimulsoft.Viewer {
    class StiLicHelper {
        static isValidOnHost(): boolean;
        private static isValids;
        private static isValid;
    }
}
export namespace Stimulsoft.Viewer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiReportContainer {
        report: StiReport;
        resourcesIncluded: boolean;
        command: string;
        constructor(report: StiReport, resourcesIncluded: boolean, command?: string);
    }
}
export namespace Stimulsoft.Viewer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiReportCopier {
        static cloneReport(report: StiReport, withResources: boolean): StiReport;
        private static cloneResources;
        static copyReportDictionary(reportFrom: StiReport, reportTo: StiReport): void;
        static copyElementsDrillDown(reportFrom: StiReport, reportTo: StiReport): void;
        static copyFilterElementsUserFilters(reportFrom: StiReport, reportTo: StiReport): void;
        static copyEventsFunction(reportFrom: StiReport, reportTo: StiReport): void;
    }
}
export namespace Stimulsoft.Viewer {
    import StiResourcesCollection = Stimulsoft.Report.Dictionary.StiResourcesCollection;
    import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiReportResourceHelper {
        static getResourcesItems(report: StiReport): any[];
        static isFontResourceType(resourceType: StiResourceType): boolean;
        static getFontResourcesArray(report: StiReport): any[];
        static getBase64DataFromFontResourceContent(resourceType: StiResourceType, content: number[]): string;
        static loadResourcesToReport(report: StiReport, resources: StiResourcesCollection): void;
    }
}
export namespace Stimulsoft.Viewer {
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiVariablesHelper {
        private en_us_culture;
        static fillDialogInfoItems(report: StiReport): Promise<void>;
        private static getVariableAlias;
        private static getItems;
        private static itemValueToString;
        private static isBindingVariable;
        private static containsBindingVariableValue;
        private static isUsedDateTimeType;
        private static isDateTime;
        private static getDateTimeObject;
        private static getTimeSpanStringValue;
        private static getBasicType;
        private static getStiType;
        private static getDateTimeType;
        static applyReportParameters(report: StiReport, values: any): void;
        static transferParametersValuesToReport(report: StiReport, values: any): void;
        static applyReportBindingVariables(report: StiReport, values: any): void;
        private static getLabelValue;
        private static setVariableLabel;
        private static setVariableValue;
        static getVariables(report: StiReport, values: any, sortDataItems: boolean): Promise<any>;
        static getVariablesValues(report: StiReport): KeyObjectType;
    }
}
export namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import IStiCardsElement = Stimulsoft.Report.Dashboard.IStiCardsElement;
    class StiCardsElementViewHelper {
        static getCellsInteractions(cardsElement: IStiCardsElement): Promise<any[]>;
    }
}
export namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import IStiComboBoxElement = Stimulsoft.Report.Dashboard.IStiComboBoxElement;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiComboBoxElementViewHelper {
        static getElementItems(comboBoxElement: IStiComboBoxElement): Promise<{
            [key: string]: {};
        }[]>;
        static comboBoxItem(label: string, value: any): {
            [key: string]: {};
        };
        static getSettings(comboBoxElement: IStiComboBoxElement): any;
        protected static getNameMeterIndex(table: StiDataTable): number;
        protected static getKeyMeterIndex(table: StiDataTable): number;
        static getColumnPath(comboBoxElement: IStiComboBoxElement): string;
    }
}
export namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import IStiImageElement = Stimulsoft.Report.Dashboard.IStiImageElement;
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    class StiImageElementViewHelper {
        static getImageSvgContent(imageElement: IStiImageElement, scaleX?: number, scaleY?: number, requestParams?: any): Promise<KeyObjectType>;
    }
}
export namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import IStiListBoxElement = Stimulsoft.Report.Dashboard.IStiListBoxElement;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiListBoxElementViewHelper {
        static getElementItems(listBoxElement: IStiListBoxElement): Promise<{
            [key: string]: {};
        }[]>;
        static listBoxItem(label: string, value: any): {
            [key: string]: {};
        };
        static getSettings(listBoxElement: IStiListBoxElement): any;
        protected static getNameMeterIndex(table: StiDataTable): number;
        protected static getKeyMeterIndex(table: StiDataTable): number;
        static getColumnPath(listBoxElement: IStiListBoxElement): string;
    }
}
export namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import IStiAppVariable = Stimulsoft.Base.IStiAppVariable;
    import IStiNumberBoxElement = Stimulsoft.Report.Dashboard.IStiNumberBoxElement;
    import DecimalRange = Stimulsoft.Report.DecimalRange;
    class StiNumberBoxElementViewHelper {
        static getJSMinMaxRange(element: IStiNumberBoxElement): Promise<any>;
        static getMinMaxRange(element: IStiNumberBoxElement): Promise<DecimalRange>;
        static getSettings(numberBoxElement: IStiNumberBoxElement): System.KeyObjectType;
        private static getAutoRange;
        static getJSInitialValue(element: IStiNumberBoxElement): Promise<any>;
        static getInitialValue(element: IStiNumberBoxElement): any;
        static getRangeInitialValue(element: IStiNumberBoxElement): Promise<DecimalRange>;
        static getSingleInitialValue(element: IStiNumberBoxElement): Promise<number>;
        static applyNumberBoxFiltersToVariable(numberBoxElement: IStiNumberBoxElement, filters: any[]): void;
        static getColumnPath(element: IStiNumberBoxElement): string;
        static isRange(element: IStiNumberBoxElement): boolean;
        static isVariablePresent(element: IStiNumberBoxElement): boolean;
        static getVariableSpecifiedAsValue(element: IStiNumberBoxElement): IStiAppVariable;
    }
}
export namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    import IStiPivotTableElement = Stimulsoft.Report.Dashboard.IStiPivotTableElement;
    class StiPivotTableElementViewHelper {
        static getPivotTableData(pivotElement: IStiPivotTableElement): Promise<any>;
        static getPivotTableSettings(pivotElement: IStiPivotTableElement): KeyObjectType;
        private static getCellBackColor;
        private static getSelectedCellBackColor;
        private static getAlternatingCellBackColor;
        private static getCellForeColor;
        private static getSelectedCellForeColor;
        private static getAlternatingCellForeColor;
        private static getColumnHeaderBackColor;
        private static getColumnHeaderForeColor;
        private static getHotColumnHeaderBackColor;
        private static getRowHeaderBackColor;
        private static getHotRowHeaderBackColor;
        private static getRowHeaderForeColor;
        private static getTotalBackColor;
        private static getAlternatingTotalBackColor;
        private static getTotalForeColor;
        private static getAlternatingTotalForeColor;
    }
}
export namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import IStiRegionMapElement = Stimulsoft.Report.Dashboard.IStiRegionMapElement;
    class StiRegionMapElementViewHelper {
        static getColumnPath(regionMapElement: IStiRegionMapElement): string;
    }
}
export namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    import IStiTreeViewBoxElement = Stimulsoft.Report.Dashboard.IStiTreeViewBoxElement;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiTreeViewBoxElementViewHelper {
        static getElementItems(treeViewBoxElement: IStiTreeViewBoxElement): Promise<List<KeyObjectType>>;
        static treeViewBoxItem(treeViewBoxElement: IStiTreeViewBoxElement, key?: any, meter?: IStiMeter): KeyObjectType;
        static getSettings(treeViewBoxElement: IStiTreeViewBoxElement): any;
        static getColumnPath(treeViewBoxElement: IStiTreeViewBoxElement): string;
        static getMeterKey(treeViewBoxElement: IStiTreeViewBoxElement): string;
    }
}
export namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    import IStiTreeViewElement = Stimulsoft.Report.Dashboard.IStiTreeViewElement;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiTreeViewElementViewHelper {
        static getElementItems(treeViewElement: IStiTreeViewElement): Promise<List<KeyObjectType>>;
        static treeViewItem(treeViewElement: IStiTreeViewElement, key?: any, meter?: IStiMeter): KeyObjectType;
        static getSettings(treeViewElement: IStiTreeViewElement): any;
        static getColumnPath(treeViewElement: IStiTreeViewElement): string;
        static getMeterKey(treeViewElement: IStiTreeViewElement): string;
    }
}
export namespace Stimulsoft.Viewer {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiHtmlExportMode = Stimulsoft.Report.Export.StiHtmlExportMode;
    class StiAppearanceOptions {
        private storeExportSettings;
        private showReportIsNotSpecifiedMessage;
        private customStylesUrl;
        private saveMenuImageSize;
        private designWindow;
        private printToPdfMode;
        private imagesQuality;
        backgroundColor: Color;
        pageBorderColor: Color;
        allowSelectionCurrentPage: boolean;
        allowLoadingFilterItemsOnScroll: boolean;
        rightToLeft: boolean;
        fullScreenMode: boolean;
        scrollbarsMode: boolean;
        openLinksWindow: string;
        openExportedReportWindow: string;
        showTooltips: boolean;
        showTooltipsHelp: boolean;
        showDialogsHelp: boolean;
        pageAlignment: StiContentAlignment;
        showPageShadow: boolean;
        bookmarksPrint: boolean;
        bookmarksTreeWidth: number;
        parametersPanelPosition: StiParametersPanelPosition;
        parametersPanelMaxHeight: number;
        parametersPanelColumnsCount: number;
        minParametersCountForMultiColumns: number;
        parametersPanelDateFormat: string;
        parametersPanelSortDataItems: boolean;
        interfaceType: StiInterfaceType;
        chartRenderType: StiChartRenderType;
        reportDisplayMode: StiHtmlExportMode;
        datePickerFirstDayOfWeek: StiFirstDayOfWeek;
        datePickerIncludeCurrentDayForRanges: boolean;
        allowTouchZoom: boolean;
        allowScrollZoom: boolean;
        allowMobileMode: boolean;
        combineReportPages: boolean;
        htmlRenderMode: StiHtmlExportMode;
        theme: StiViewerTheme;
        iconSet: StiWebUIIconSet;
        allowPropagationEvents: boolean;
    }
}
export namespace Stimulsoft.Viewer {
    class StiEmailOptions {
        showEmailDialog: boolean;
        showExportDialog: boolean;
        defaultEmailAddress: string;
        defaultEmailSubject: string;
        defaultEmailMessage: string;
    }
}
export namespace Stimulsoft.Viewer {
    class StiExportsOptions {
        private showExportToMht;
        private showExportToExcelBiff;
        private showExportToExcelXml;
        private showExportToImageMetafile;
        private openAfterExport;
        private showOpenAfterExport;
        storeExportSettings: boolean;
        showExportDialog: boolean;
        showExportToDocument: boolean;
        showExportToPdf: boolean;
        showExportToHtml: boolean;
        showExportToHtml5: boolean;
        showExportToWord: boolean;
        showExportToExcel: boolean;
        showExportToCsv: boolean;
        showExportToJson: boolean;
        showExportToDbf: boolean;
        showExportToXml: boolean;
        showExportToDif: boolean;
        showExportToSylk: boolean;
        showExportToText: boolean;
        showExportToOpenDocumentWriter: boolean;
        showExportToOpenDocumentCalc: boolean;
        showExportToPowerPoint: boolean;
        showExportToImageSvg: boolean;
        showExportToImagePng: boolean;
        showExportToImageJpeg: boolean;
        showExportToImageSvgz: boolean;
        showExportToImagePcx: boolean;
        showExportToImageBmp: boolean;
        showExportToImageGif: boolean;
        showExportToImageTiff: boolean;
        showExportToXps: boolean;
        showExportDataOnly: boolean;
        showExportToRtf: boolean;
    }
}
export namespace Stimulsoft.Viewer {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiToolbarOptions {
        visible: boolean;
        displayMode: StiToolbarDisplayMode;
        backgroundColor: Color;
        borderColor: Color;
        fontColor: Color;
        fontFamily: string;
        alignment: StiContentAlignment;
        showButtonCaptions: boolean;
        showPrintButton: boolean;
        showOpenButton: boolean;
        showSaveButton: boolean;
        showSendEmailButton: boolean;
        showFindButton: boolean;
        showSignatureButton: boolean;
        showBookmarksButton: boolean;
        showParametersButton: boolean;
        showResourcesButton: boolean;
        showEditorButton: boolean;
        showFullScreenButton: boolean;
        showRefreshButton: boolean;
        showFirstPageButton: boolean;
        showPreviousPageButton: boolean;
        showCurrentPageControl: boolean;
        showNextPageButton: boolean;
        showLastPageButton: boolean;
        showZoomButton: boolean;
        showViewModeButton: boolean;
        showDesignButton: boolean;
        showAboutButton: boolean;
        showPinToolbarButton: boolean;
        printDestination: StiPrintDestination;
        viewMode: StiWebViewMode;
        multiPageWidthCount: number;
        multiPageHeightCount: number;
        private _zoom;
        get zoom(): number;
        set zoom(value: number);
        menuAnimation: boolean;
        showMenuMode: StiShowMenuMode;
        autoHide: boolean;
    }
}
export namespace Stimulsoft.Report.Check {
    enum StiCheckStatus {
        ReportRenderingMessage = 0,
        Information = 1,
        Warning = 2,
        Error = 3
    }
    enum StiCheckObjectType {
        Report = 0,
        Page = 1,
        Component = 2,
        Database = 3,
        DataSource = 4,
        DataRelation = 5,
        DataColumn = 6,
        Variable = 7,
        UserFunction = 8
    }
}
export namespace Stimulsoft.Report.Check {
    class StiCheck {
        element: any;
        get previewVisible(): boolean;
        get elementName(): string;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        objectType: StiCheckObjectType;
        defaultStateEnabled: boolean;
        get enabled(): boolean;
        set enabled(value: boolean);
        actions: StiAction[];
        processCheck(report: StiReport, obj: any): any;
        createPreviewImage(refElementImage: any, refHighlightedElementImage: {
            ref: string;
        }): void;
    }
}
export namespace Stimulsoft.Report.Check {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiCheckEngine {
        private invokeFinishCheckingReport;
        private invokeStartCheckingPages;
        private invokeCheckingPages;
        private invokeFinishCheckingPages;
        private invokeStartCheckingComponents;
        private invokeCheckingComponents;
        private invokeFinishCheckingComponents;
        private invokeStartCheckingDatabases;
        private invokeCheckingDatabases;
        private invokeFinishCheckingDatabases;
        private invokeStartCheckingDataSource;
        private invokeCheckingDataSource;
        private invokeFinishCheckingDataSource;
        private invokeStartCheckingRelations;
        private invokeCheckingRelations;
        private invokeFinishCheckingRelations;
        private invokeStartCheckingVariables;
        private invokeCheckingVariables;
        private invokeFinishCheckingVariables;
        private invokeStartCheckingUserFunctions;
        private invokeCheckingUserFunctions;
        private invokeFinishCheckingUserFunctions;
        private static _checks;
        static get checks(): StiCheck[];
        private _progressValue;
        get progressValue(): number;
        private _progressMaximum;
        get progressMaximum(): number;
        private _progressInformation;
        get progressInformation(): string;
        private static createChecks;
        checkReport(report: StiReport): StiCheck[];
        private static checkObject;
        constructor();
    }
}
export namespace Stimulsoft.Report.Check {
    class StiCheckHelper {
        private _errorsCount;
        get errorsCount(): number;
        private _warningsCount;
        get warningsCount(): number;
        private _informationMessagesCount;
        get informationMessagesCount(): number;
        private _reportRenderingMessagesCount;
        get reportRenderingMessagesCount(): number;
        private _checks;
        get checks(): StiCheck[];
        private _reportRenderingMessagesChecks;
        get reportRenderingMessagesChecks(): StiCheck[];
        get isMessagesPresent(): boolean;
        buildChecks(report: StiReport): void;
        buildReportRenderingMessages(report: StiReport): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiLocalizationExt {
        private static enLanguage;
        static languages: {
            [key: string]: {
                language: string;
                cultureName: string;
                filePath?: string;
                jsonString?: string;
            };
        };
        private static _cultureName;
        static get cultureName(): string;
        static set cultureName(value: string);
        static addLocalizationFile(filePath: string, load?: boolean, language?: string): string;
        static setLocalizationFile(filePath: string, onlyThis?: boolean): void;
        static loadLocalization(localizationXml: string): string;
        static loadLocalizationFile(filePath: string): string;
        private static loadLocalizationXmlInternal;
        static get(category: string, key: string): string;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiAllowDoublePassAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiAllowHtmlTagsInTextAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiApplyGeneralTextFormat extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiCanBreakComponentInContainerAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiCanGrowComponentInContainerAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiCanGrowGrowToHeightComponentInContainerAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiCanGrowWordWrapTextAndWysiwygAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiColumnsWidthGreaterContainerWidthAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiComponentStyleIsNotFoundAtComponentAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiConversionContainerInPanelAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiConversionContourTextInTextAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiConversionSystemTextInTextAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiDeleteComponentAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiFixCrossLinePrimitiveAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiGenerateNewNameComponentAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiGrowToHeightOverlappingAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiMinRowsInColumnsAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiMoveComponentToPageAreaAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiMoveComponentToPrintablePageAreaAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiNegativeSizesOfComponentsAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiVerySmallSizesOfComponentsAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiWordWrapCanGrowTextDoesNotFitAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiDeleteConnectionAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiDeleteDataRelationAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiGenerateNewNameRelationAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiDeleteDataSourceAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiGenerateNewNameDataSourceAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiDeleteLostPointsAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiDeletePageAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiGenerateNewNamePageAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiLargeHeightAtPageAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiOrientationPageToLandscapeAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiOrientationPageToPortraitAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiPrintHeadersFootersFromPreviousPageAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiPrintOnPreviousPageAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiResetPageNumberAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiSwitchWidthAndHeightOfPageAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiEditNameAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiEditPropertyAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiGoToCodeAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiGenerateNewNameVariableAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiComponentCheck extends StiCheck {
        objectType: StiCheckObjectType;
        get elementName(): string;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiAllowHtmlTagsInTextCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiCanBreakComponentInContainerCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiCanGrowComponentInContainerCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiCanGrowGrowToHeightComponentInContainerCheck extends StiComponentCheck {
        defaultStateEnabled: boolean;
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiCanGrowWordWrapTextAndWysiwygCheck extends StiComponentCheck {
        defaultStateEnabled: boolean;
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiChartSeriesValueCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiColumnsWidthGreaterContainerWidthCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiComponentBoundsAreOutOfBand extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        get notAllowToDelete(): boolean;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiComponentDataColumnCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiComponentExpressionCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        componentName: string;
        propertyName: string;
        message: string;
        private checkExpression;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiComponentStyleIsNotFoundAtComponentCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiContainerInEngineV2Check extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiContourTextObsoleteCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiCorruptedCrossLinePrimitiveCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiCountDataDataSourceAtDataBandCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiCrossGroupHeaderNotEqualToCrossGroupFooterOnContainerCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiDataSourcesForImageCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiFontMissingCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiGroupHeaderNotEqualToGroupFooterOnContainerCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiGrowToHeightOverlappingCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiLocationOutsidePageCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        get isOutsidePage(): boolean;
        get isOutsidePrintableArea(): boolean;
        get notAllowToDelete(): boolean;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiMinRowsInColumnsCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiNegativeSizesOfComponentsCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiNoConditionAtGroupCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiNoNameComponentCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiPrintOnDoublePassCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiShowInsteadNullValuesCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiSystemTextObsoleteCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiTextColorEqualToBackColorCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiTextTextFormatCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        check(): boolean;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiTextTextFormatFieldCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        check(): boolean;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiUndefinedComponentCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiVerySmallSizesOfComponentsCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiWidthHeightZeroComponentCheck extends StiComponentCheck {
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiWordWrapCanGrowTextDoesNotFitCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiConnectionCheck extends StiCheck {
        objectType: StiCheckObjectType;
        get elementName(): string;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiUndefinedConnectionCheck extends StiConnectionCheck {
        private report;
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiExpressionElementCheck extends StiComponentCheck {
        defaultStateEnabled: boolean;
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private _expression;
        get expression(): string;
        set expression(value: string);
        private _message;
        get message(): string;
        set message(value: string);
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiFilterCircularDependencyElementCheck extends StiComponentCheck {
        defaultStateEnabled: boolean;
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiDataRelationCheck extends StiCheck {
        private dataBuilder;
        objectType: StiCheckObjectType;
        get elementName(): string;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiDifferentAmountOfKeysInDataRelationCheck extends StiDataRelationCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiKeysInAbsentDataRelationCheck extends StiDataRelationCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiKeysNotFoundRelationCheck extends StiDataRelationCheck {
        get previewVisible(): boolean;
        columns: string;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private isColumnsExist;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiKeysTypesMismatchDataRelationCheck extends StiDataRelationCheck {
        get previewVisible(): boolean;
        columns: string;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private isColumnsExist;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiNoNameDataRelationCheck extends StiDataRelationCheck {
        get previewVisible(): boolean;
        dataSources: string;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiNoNameInSourceDataRelationCheck extends StiDataRelationCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiSourcesInAbsentDataRelationCheck extends StiDataRelationCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiDataColumnCheck extends StiCheck {
        private dataBuilder;
        get previewVisible(): boolean;
        objectType: StiCheckObjectType;
        get elementName(): string;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiCalculatedColumnRecursionCheck extends StiDataColumnCheck {
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private checkForRecursion;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiDataSourceCheck extends StiCheck {
        private dataBuilder;
        objectType: StiCheckObjectType;
        get elementName(): string;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiNoNameDataSourceCheck extends StiDataSourceCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiNoNameInSourceDataSourceCheck extends StiDataSourceCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiUndefinedDataSourceCheck extends StiDataSourceCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    import StiDatabase = Stimulsoft.Report.Dictionary.StiDatabase;
    import StiResource = Stimulsoft.Report.Dictionary.StiResource;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiUsedResourceHelper {
        static getDatabasesUsedResource(report: StiReport, resource: StiResource): StiDatabase[];
        static getComponentsUsedResource(report: StiReport, resource: StiResource): StiComponent[];
        private static getImageComponentsUsedResource;
        private static getRichTextComponentsUsedResource;
        private static getReportsUsedResource;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiPageCheck extends StiCheck {
        get previewVisible(): boolean;
        objectType: StiCheckObjectType;
        get elementName(): string;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiColumnsWidthGreaterPageWidthCheck extends Stimulsoft.Report.Check.StiPageCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiComponentStyleIsNotFoundAtPageCheck extends StiPageCheck {
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiCrossGroupHeaderNotEqualToCrossGroupFooterOnPageCheck extends StiPageCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiGroupHeaderNotEqualToGroupFooterOnPageCheck extends StiPageCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiLargeHeightAtPageCheck extends StiPageCheck {
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiPointPrimitive = Stimulsoft.Report.Components.StiPointPrimitive;
    class StiLostPointsOnPageCheck extends StiPageCheck {
        get previewVisible(): boolean;
        private get page();
        get shortMessage(): string;
        get longMessage(): string;
        lostPointsNames: string;
        status: StiCheckStatus;
        static getLostPointsOnPage(page: StiPage): StiPointPrimitive[];
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiNoNamePageCheck extends StiPageCheck {
        private get page();
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiOrientationPageCheck extends StiPageCheck {
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiPrintHeadersAndFootersFromPreviousPageCheck extends StiPageCheck {
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private getPageCount;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiPrintOnPreviousPageCheck extends StiPageCheck {
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private getPageCount;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiPrintOnPreviousPageCheck2 extends StiPageCheck {
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiResetPageNumberCheck extends StiPageCheck {
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private getPageCount;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiReportCheck extends StiCheck {
        objectType: StiCheckObjectType;
        get elementName(): string;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiDuplicatedNameCheck extends StiReportCheck {
        get elementName(): string;
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private _isDataSource;
        get isDataSource(): boolean;
        set isDataSource(value: boolean);
        private dataBuilder;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiDuplicatedNameInSourceCheck extends StiReportCheck {
        get elementName(): string;
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private _isDataSource;
        get isDataSource(): boolean;
        set isDataSource(value: boolean);
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiDuplicatedNameInSourceInDataRelationReportCheck extends StiReportCheck {
        get previewVisible(): boolean;
        relationsNames: string;
        relationsNameInSource: string;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiIsFirstPageIsLastPageDoublePassCheck extends StiReportCheck {
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiIsFirstPassIsSecondPassCheck extends StiReportCheck {
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiReportRenderingMessageCheck extends StiReportCheck {
        get shortMessage(): string;
        private _longMessage;
        get longMessage(): string;
        status: StiCheckStatus;
        setMessage(message: string): void;
        processCheck(report: StiReport, msg: any): void;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiTotalPageCountDoublePassCheck extends StiReportCheck {
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiUserFunctionCheck extends StiCheck {
        get previewVisible(): boolean;
        objectType: StiCheckObjectType;
        get elementName(): string;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiUserFunctionCSharpScriptValueCheck extends StiUserFunctionCheck {
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiUserFunctionJSScriptValueCheck extends StiUserFunctionCheck {
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiUserFunctionScriptAtInterpretationCheck extends StiUserFunctionCheck {
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiUserFunctionVBScriptValueCheck extends StiUserFunctionCheck {
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiVariableCheck extends StiCheck {
        get previewVisible(): boolean;
        objectType: StiCheckObjectType;
        get elementName(): string;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiVariableNameCheck extends StiVariableCheck {
        private reservedWords;
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Report.Check {
    class StiVariableRecursionCheck extends StiVariableCheck {
        get shortMessage(): string;
        get longMessage(): string;
        status: StiCheckStatus;
        private checkForRecursion;
        processCheck(report: StiReport, obj: any): any;
    }
}
export namespace Stimulsoft.Designer {
    enum StiImagesID {
        BusinessObject = 0,
        CalcColumn = 1,
        CalcColumnBinary = 2,
        CalcColumnBool = 3,
        CalcColumnChar = 4,
        CalcColumnDateTime = 5,
        CalcColumnDecimal = 6,
        CalcColumnFloat = 7,
        CalcColumnImage = 8,
        CalcColumnInt = 9,
        CalcColumnString = 10,
        Class = 11,
        Close = 12,
        ColumnsOrder = 13,
        Connection = 14,
        ConnectionFail = 15,
        DataColumn = 16,
        DataColumnBinary = 17,
        DataColumnBool = 18,
        DataColumnChar = 19,
        DataColumnDateTime = 20,
        DataColumnDecimal = 21,
        DataColumnFloat = 22,
        DataColumnImage = 23,
        DataColumnInt = 24,
        DataColumnString = 25,
        DataSource = 26,
        DataSources = 27,
        DataStore = 28,
        DataTable = 29,
        DataTables = 30,
        Folder = 31,
        Format = 32,
        FormatBoolean = 33,
        FormatCurrency = 34,
        FormatDate = 35,
        FormatGeneral = 36,
        FormatNumber = 37,
        FormatPercentage = 38,
        FormatTime = 39,
        Function = 40,
        HtmlTag = 41,
        LabelType = 42,
        LockedCalcColumn = 43,
        LockedCalcColumnBinary = 44,
        LockedCalcColumnBool = 45,
        LockedCalcColumnChar = 46,
        LockedCalcColumnDateTime = 47,
        LockedCalcColumnDecimal = 48,
        LockedCalcColumnFloat = 49,
        LockedCalcColumnImage = 50,
        LockedCalcColumnInt = 51,
        LockedCalcColumnString = 52,
        LockedConnection = 53,
        LockedDataColumn = 54,
        LockedDataColumnBinary = 55,
        LockedDataColumnBool = 56,
        LockedDataColumnChar = 57,
        LockedDataColumnDateTime = 58,
        LockedDataColumnDecimal = 59,
        LockedDataColumnFloat = 60,
        LockedDataColumnImage = 61,
        LockedDataColumnInt = 62,
        LockedDataColumnString = 63,
        LockedDataSource = 64,
        LockedFolder = 65,
        LockedParameter = 66,
        LockedRelation = 67,
        LockedVariable = 68,
        LockedVariableBinary = 69,
        LockedVariableBool = 70,
        LockedVariableChar = 71,
        LockedVariableDateTime = 72,
        LockedVariableDecimal = 73,
        LockedVariableFloat = 74,
        LockedVariableImage = 75,
        LockedVariableInt = 76,
        LockedVariableString = 77,
        Namespace = 78,
        Parameter = 79,
        Property = 80,
        Queries = 81,
        Query = 82,
        RecentConnection = 83,
        Relation = 84,
        StoredProcedure = 85,
        StoredProcedures = 86,
        SystemVariable = 87,
        SystemVariableColumn = 88,
        SystemVariableGroupLine = 89,
        SystemVariableIsFirstPage = 90,
        SystemVariableIsFirstPageThrough = 91,
        SystemVariableIsLastPage = 92,
        SystemVariableIsLastPageThrough = 93,
        SystemVariableLine = 94,
        SystemVariableLineABC = 95,
        SystemVariableLineRoman = 96,
        SystemVariableLineThrough = 97,
        SystemVariablePageNofM = 98,
        SystemVariablePageNofMThrough = 99,
        SystemVariablePageNumber = 100,
        SystemVariablePageNumberThrough = 101,
        SystemVariableReportAlias = 102,
        SystemVariableReportAuthor = 103,
        SystemVariableReportChanged = 104,
        SystemVariableReportCreated = 105,
        SystemVariableReportDescription = 106,
        SystemVariableReportName = 107,
        SystemVariables = 108,
        SystemVariableTime = 109,
        SystemVariableToday = 110,
        SystemVariableTotalPageCount = 111,
        SystemVariableTotalPageCountThrough = 112,
        UndefinedConnection = 113,
        UndefinedDataSource = 114,
        Variable = 115,
        VariableBinary = 116,
        VariableBool = 117,
        VariableChar = 118,
        VariableDateTime = 119,
        VariableDecimal = 120,
        VariableFloat = 121,
        VariableImage = 122,
        VariableInt = 123,
        VariableString = 124,
        View = 125,
        Views = 126,
        LockedVariableListBool = 127,
        LockedVariableListChar = 128,
        LockedVariableListDateTime = 129,
        LockedVariableListDecimal = 130,
        LockedVariableListFloat = 131,
        LockedVariableListImage = 132,
        LockedVariableListInt = 133,
        LockedVariableListString = 134,
        LockedVariableRangeChar = 135,
        LockedVariableRangeDateTime = 136,
        LockedVariableRangeDecimal = 137,
        LockedVariableRangeFloat = 138,
        LockedVariableRangeInt = 139,
        LockedVariableRangeString = 140,
        VariableListBool = 141,
        VariableListChar = 142,
        VariableListDateTime = 143,
        VariableListDecimal = 144,
        VariableListFloat = 145,
        VariableListImage = 146,
        VariableListInt = 147,
        VariableListString = 148,
        VariableRangeChar = 149,
        VariableRangeDateTime = 150,
        VariableRangeDecimal = 151,
        VariableRangeFloat = 152,
        VariableRangeInt = 153,
        VariableRangeString = 154
    }
    enum StiDesignerPermissions {
        None = 0,
        Create = 1,
        Delete = 2,
        Modify = 4,
        View = 8,
        ModifyView = 12,
        All = 15
    }
    enum StiDesignerTheme {
        Auto = 0,
        Office2013DarkGrayBlue = 1,
        Office2013DarkGrayCarmine = 2,
        Office2013DarkGrayGreen = 3,
        Office2013DarkGrayOrange = 4,
        Office2013DarkGrayPurple = 5,
        Office2013DarkGrayTeal = 6,
        Office2013DarkGrayViolet = 7,
        Office2013LightGrayBlue = 8,
        Office2013LightGrayCarmine = 9,
        Office2013LightGrayGreen = 10,
        Office2013LightGrayOrange = 11,
        Office2013LightGrayPurple = 12,
        Office2013LightGrayTeal = 13,
        Office2013LightGrayViolet = 14,
        Office2013WhiteBlue = 15,
        Office2013WhiteCarmine = 16,
        Office2013WhiteGreen = 17,
        Office2013WhiteOrange = 18,
        Office2013WhitePurple = 19,
        Office2013WhiteTeal = 20,
        Office2013WhiteViolet = 21,
        Office2013VeryDarkGrayBlue = 22,
        Office2013VeryDarkGrayCarmine = 23,
        Office2013VeryDarkGrayGreen = 24,
        Office2013VeryDarkGrayOrange = 25,
        Office2013VeryDarkGrayPurple = 26,
        Office2013VeryDarkGrayTeal = 27,
        Office2013VeryDarkGrayViolet = 28,
        Office2022WhiteBlue = 29,
        Office2022WhiteCarmine = 30,
        Office2022WhiteGreen = 31,
        Office2022WhiteOrange = 32,
        Office2022WhitePurple = 33,
        Office2022WhiteTeal = 34,
        Office2022WhiteViolet = 35,
        Office2022LightGrayBlue = 36,
        Office2022LightGrayCarmine = 37,
        Office2022LightGrayGreen = 38,
        Office2022LightGrayOrange = 39,
        Office2022LightGrayPurple = 40,
        Office2022LightGrayTeal = 41,
        Office2022LightGrayViolet = 42,
        Office2022DarkGrayBlue = 43,
        Office2022DarkGrayCarmine = 44,
        Office2022DarkGrayGreen = 45,
        Office2022DarkGrayOrange = 46,
        Office2022DarkGrayPurple = 47,
        Office2022DarkGrayTeal = 48,
        Office2022DarkGrayViolet = 49,
        Office2022BlackBlue = 50,
        Office2022BlackCarmine = 51,
        Office2022BlackGreen = 52,
        Office2022BlackOrange = 53,
        Office2022BlackPurple = 54,
        Office2022BlackTeal = 55,
        Office2022BlackViolet = 56
    }
    enum StiInterfaceType {
        Auto = 0,
        Mouse = 1,
        Touch = 2
    }
    enum StiFirstDayOfWeek {
        Auto = 0,
        Monday = 1,
        Sunday = 2
    }
    enum StiPropertiesGridPosition {
        Left = 0,
        Right = 1
    }
    enum StiWizardType {
        None = 0,
        StandardReport = 1,
        MasterDetailReport = 2,
        LabelReport = 3,
        InvoicesReport = 4,
        OrdersReport = 5,
        QuotationReport = 6
    }
    enum StiNewReportDictionary {
        Auto = 0,
        DictionaryNew = 1,
        DictionaryMerge = 2
    }
    enum StiUseAliases {
        Auto = 0,
        True = 1,
        False = 2
    }
    enum StiZoomMode {
        PageWidth = -1,
        PageHeight = -2
    }
    enum StiDesignerRibbonType {
        Classic = 0,
        SingleLine = 1
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiDashboardScalingHelper {
        static applyScalingToDashboard(dashboard: StiPage, prevWidth: number, prevHeight: number): void;
        private static getLevel;
        private static round;
        private static round2;
        private static getAllLocations;
        private static topUpFilterElements;
        static makeHorizontalSpacingEqual(dashboard: StiPage): number;
        static makeVerticalSpacingEqual(dashboard: StiPage): number;
        static changeDashboardSettingsValue(report: StiReport, param: any, callbackResult: any): void;
        private static resizeDashboard;
        private static addSvgContents;
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiChangeTypeElementHelper {
        static changeTypeElement(report: StiReport, param: any, callbackResult: any): void;
        static createNewComponent(elementType: string, report: StiReport): StiComponent;
    }
}
export namespace Stimulsoft.Designer {
    import ProcessXmlDataArgs = Stimulsoft.Report.ProcessXmlDataArgs;
    import ProcessXsdDataArgs = Stimulsoft.Report.ProcessXsdDataArgs;
    import ProcessDBaseDataArgs = Stimulsoft.Report.ProcessDBaseDataArgs;
    import ProcessCsvDataArgs = Stimulsoft.Report.ProcessCsvDataArgs;
    import ProcessJsonDataArgs = Stimulsoft.Report.ProcessJsonDataArgs;
    import ProcessGisDataArgs = Stimulsoft.Report.ProcessGisDataArgs;
    import ProcessExcelDataCommand = Stimulsoft.Report.ProcessExcelDataCommand;
    import ProcessSqlDataCommand = Stimulsoft.Report.ProcessSqlDataCommand;
    import ProcessODataDataCommand = Stimulsoft.Report.ProcessODataDataCommand;
    import PrepareVariablesObject = Stimulsoft.Report.PrepareVariablesObject;
    import EndProcessDataArgs = Stimulsoft.Report.EndProcessDataArgs;
    import BeginProcessDataArgs = Stimulsoft.Report.BeginProcessDataArgs;
    import PrepareVariablesArgs = Stimulsoft.Report.PrepareVariablesArgs;
    import StiCheck = Stimulsoft.Report.Check.StiCheck;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiReportUnitType = Stimulsoft.Report.StiReportUnitType;
    import StiViewer = Stimulsoft.Viewer.StiViewer;
    import EventDataArgs = Stimulsoft.Report.EventDataArgs;
    import ReportDataArgs = Stimulsoft.Report.ReportDataArgs;
    import AsyncDataArgs = Stimulsoft.Report.AsyncDataArgs;
    class StiMobileDesigner {
        static setImageSource(htmlImage: any, options: any, name: string, transform: boolean): void;
        static checkImageSource(options: any, name: string): boolean;
        static getImageSource(options: any, name: string): string;
    }
    class StiJsDesigner {
        options: any;
        defaultParameters: any;
        loc: any;
        locName: string;
        designer: StiDesigner;
        startDesignerTimer: any;
        assignReport(report: StiReport): any;
        SendCommandUpdateCache(): any;
        SendCommandLoadReportToViewer(): any;
        SendCommandCloseViewer(): any;
        SendCommandOpenReport(fileContent: any, fileName: string, reportParams: any, filePath?: string, fileSize?: number, addToRecent?: boolean, cloudPath?: string): any;
        ExecuteCommandFromStack(): any;
        Sen(evt: any): any;
        ActionExitDesigner(): any;
        InitializeAboutPanel(): any;
        InitializeProcessImage(): any;
        InitializeErrorMessageForm(): any;
        ActionOpenReport(): any;
        ActionCloseReport(): any;
        SendCommandSaveStyle(stylesCollection: any[]): any;
        SendCommandSaveConditions(conditionsStr: string): any;
        SendCommandSavePage(pageIndex: string): any;
        SendCommandSaveDictionary(): any;
        GetFontNamesItems(): any;
        AddCustomFontsCss(customFontsCss: string): any;
        InitializeSelectDataForm(func: any): any;
        OverrideTextBoxWithOpenDialog(): any;
        InitializeImageForm(func: any): any;
        RunWizard(wizardType: string): any;
        InitializeFileMenu(): any;
        removeAllEvents(): any;
        LoadReport(reportObject: any): any;
        InitializeReportCheckForm(callbackFunction: any): any;
        ShowMainLoadProcess(command: any): any;
        ShowDictionaryLoadProcess(command: any): any;
        receveFromServer(args: any, jsObject: any): any;
        getJsonDemoDataResourceBase64(): any;
        getDemoXMLResourceBase64(): any;
        getDemoXSDResourceBase64(): any;
        assignReportCompleted(): any;
        BackToSelectedComponent(selectedObjectName: string): any;
        SendCommandSaveBlockly(blocklyContent: any, eventName: any): any;
        SaveFileToRecentArray(fileName: any, onlyPath: any, containsDashboard: any, cookieKey?: any, cloudPath?: any): any;
        SendCommandDownloadResource(resourceName: string): any;
        SendCommandDownloadImageContent(imageData: string): any;
        OnSetTheme?: () => any;
        SetZoomBy(param: string): any;
        isDarkModeOS(): any;
        MessageFormForSave(): any;
        MessageFormForEventsAccess(): any;
        ActionSaveReport(nextFunc?: any, autoSave?: boolean): any;
        CloseReport(): any;
        static GetCookie(name: string): any;
        static SetCookie(name: string, value: any): any;
        constructor(parameters: any);
    }
    type PreviewReportArgs = EventDataArgs & ReportDataArgs & AsyncDataArgs & {
        viewer: StiViewer;
        callback: () => void;
    };
    type CloseReportArgs = EventDataArgs & ReportDataArgs & AsyncDataArgs & {
        callback: () => void;
    };
    type OpenReportArgs = EventDataArgs & ReportDataArgs & AsyncDataArgs & {
        callback: () => void;
    };
    type OpenedReportArgs = EventDataArgs & ReportDataArgs & AsyncDataArgs & {
        callback: () => void;
    };
    type SaveReportArgs = EventDataArgs & ReportDataArgs & AsyncDataArgs & {
        autoSave: boolean;
        fileName: string;
        callback: () => void;
    };
    type CreateReportArgs = EventDataArgs & ReportDataArgs & AsyncDataArgs & {
        isWizardUsed: boolean;
        callback: () => void;
    };
    type AssignedReportArgs = EventDataArgs & ReportDataArgs;
    class StiDesigner {
        private _renderAfterCreate;
        private viewState;
        undoLevel: number;
        private callbackResult;
        viewer: StiViewer;
        onPrepareVariables: (args: PrepareVariablesArgs, callback: (result: PrepareVariablesObject[] | PrepareVariablesArgs) => void) => void;
        onBeginProcessData: (args: BeginProcessDataArgs & ProcessODataDataCommand & ProcessSqlDataCommand & ProcessExcelDataCommand & ProcessGisDataArgs & ProcessJsonDataArgs & ProcessCsvDataArgs & ProcessDBaseDataArgs & ProcessXsdDataArgs & ProcessXmlDataArgs, callback: (result: any) => void) => void;
        onEndProcessData: (args: EndProcessDataArgs & ProcessODataDataCommand & ProcessSqlDataCommand & ProcessExcelDataCommand & ProcessGisDataArgs & ProcessJsonDataArgs & ProcessCsvDataArgs & ProcessDBaseDataArgs & ProcessXsdDataArgs & ProcessXmlDataArgs) => void;
        onCreateReport: (args: CreateReportArgs, callback: () => void) => void;
        onCloseReport: (args: CloseReportArgs, callback: () => void) => void;
        onOpenReport: (args: OpenReportArgs, callback: () => void) => void;
        onOpenedReport: (args: OpenedReportArgs, callback: () => void) => void;
        onSaveReport: (args: SaveReportArgs, callback: () => void) => void;
        onSaveAsReport: (args: SaveReportArgs, callback: () => void) => void;
        onPreviewReport: (args: PreviewReportArgs, callback: () => void) => void;
        onExit: (args: EventDataArgs) => void;
        onAssignedReport: (args: AssignedReportArgs) => void;
        designerId: string;
        options: StiDesignerOptions;
        jsObject: StiJsDesigner;
        private _report;
        get report(): StiReport | undefined;
        set report(value: StiReport | undefined);
        private _reportGuid;
        get reportGuid(): string;
        set reportGuid(value: string);
        renderedReport: StiReport;
        private _clipboardId;
        get clipboardId(): string;
        set clipboardId(value: string);
        clipboard: string;
        stylesClipboard: any;
        private _undoArrayId;
        get undoArrayId(): string;
        set undoArrayId(value: string);
        private _undoArray;
        get undoArray(): any[];
        set undoArray(value: any[]);
        private _componentCloneId;
        get componentCloneId(): string;
        set componentCloneId(value: string);
        componentClone: any;
        private _reportCheckers;
        get reportCheckers(): StiCheck[];
        set reportCheckers(value: StiCheck[]);
        get defaultUnit(): StiReportUnitType;
        set defaultUnit(value: StiReportUnitType);
        private _visible;
        get visible(): boolean;
        set visible(value: boolean);
        private _element;
        renderHtml(element?: string | HTMLElement): void;
        private invokePrepareVariables;
        private invokeBeginProcessData;
        private invokeEndProcessData;
        private invokeCreateReport;
        private invokeCloseReport;
        private invokeOpenReport;
        private invokeOpenedReport;
        private invokeSaveReport;
        private getReportDataForSaving;
        private internalSaveReport;
        private invokeSaveAsReport;
        private internalSaveAsReport;
        private invokePreviewReport;
        private invokeExit;
        private invokeAssignedReport;
        static getNewReport(designer: StiDesigner): StiReport;
        private static getNewDashboard;
        private getReportFileName;
        private static asyncPromise;
        private raiseCallbackEventAsync;
        dispatch(): void;
        dispose(): void;
        private getAutoTheme;
        private applyTheme;
        setTheme(theme: StiDesignerTheme): void;
        constructor(options?: StiDesignerOptions, designerId?: string, renderAfterCreate?: boolean);
    }
}
export namespace Stimulsoft.Designer {
    import StiViewerOptions = Stimulsoft.Viewer.StiViewerOptions;
    class StiDesignerOptions {
        appearance: StiAppearanceOptions;
        toolbar: StiToolbarOptions;
        bands: StiBandsOptions;
        crossBands: StiCrossBandsOptions;
        components: StiComponentsOptions;
        dashboardElements: StiDashboardElementsOptions;
        dictionary: StiDictionaryOptions;
        width: string;
        height: string;
        viewerOptions: StiViewerOptions;
        mobileDesignerId: string;
        private productVersion;
        private buildDate;
        private jsMode;
        private netCoreMode;
        private serverMode;
        private cloudMode;
        private allowAutoUpdateCookies;
        private allowAutoUpdateCache;
        private haveSaveAsEvent;
        private haveSaveEvent;
        private haveExitDesignerEvent;
        private useRelativeUrls;
        private useCompression;
        private useCacheForResources;
        private useCacheHelper;
        private focusingX;
        private focusingY;
        private propertiesGridLabelWidth;
        private propertiesGridWidth;
        private closeDesignerWithoutAsking;
        private passQueryParametersForResources;
        private checkReportBeforePreview;
        private saveReportMode;
        private saveReportAsMode;
        private requestTimeout;
        private images;
        private cacheMode;
        private cacheTimeout;
        private requestUrl;
        private cacheItemPriority;
        toParameters(): any;
        private serializeObject;
    }
}
export namespace Stimulsoft.Designer {
    class StiEncodingHelper {
        static decodeString(str: string): string;
        static encode(str: string): string;
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import IStiOnlineMapElement = Stimulsoft.Report.Dashboard.IStiOnlineMapElement;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiOnlineMapElementHelper {
        private onlineMapElement;
        static getBingMapScript(element: IStiElement, showTitle: boolean): Promise<string>;
        private getOnlineMapElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        private getMeterByContainerName;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private setExpression;
        private renameMeter;
        private updateOnlineMapElementProperties;
        private createNewItem;
        private setFunction;
        private setDataColumn;
        private moveMeter;
        constructor(onlineMapElement: IStiOnlineMapElement);
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import IStiDatePickerElement = Stimulsoft.Report.Dashboard.IStiDatePickerElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDatePickerElementHelper {
        private datePickerElement;
        private getDatePickerElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        static isVariablePresent(datePickerElement: IStiDatePickerElement): boolean;
        static isRangeVariablePresent(datePickerElement: IStiDatePickerElement): boolean;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private moveMeter;
        private renameMeter;
        private createNewItem;
        private editField;
        private setDataColumn;
        private setPropertyValue;
        static createDatePickerElementFromDictionary(report: StiReport, param: any, callbackResult: any): void;
        constructor(datePickerElement: IStiDatePickerElement);
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import IStiIndicatorElement = Stimulsoft.Report.Dashboard.IStiIndicatorElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiIndicatorElementHelper {
        private indicatorElement;
        private getIndicatorElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private getMeterByContainerName;
        private moveMeter;
        private setPropertyValue;
        private getIconRanges;
        private getIconRangeItem;
        private setExpression;
        private renameMeter;
        private setFunction;
        private createNewItem;
        private setDataColumn;
        private setValueToManuallyEnteredData;
        private setPropertyValueToIndicatorIconRange;
        private addIndicatorIconRange;
        private removeIndicatorIconRange;
        private static getIndicatorElementStyles;
        static getStylesContent(report: StiReport, param: any, withReportStyles?: boolean): Promise<{
            [key: string]: string | number;
        }[]>;
        static isSeriesPresent(indicatorElement: IStiIndicatorElement): boolean;
        static isTargetPresent(indicatorElement: IStiIndicatorElement): boolean;
        constructor(indicatorElement: IStiIndicatorElement);
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    class StiManuallyDataHelper {
        static convertJSDataToPackedString(jsData: string): string;
        static convertPackedStringToJSData(content: string): string;
    }
}
export namespace Stimulsoft.Designer {
    import StiUserFunction = Stimulsoft.Report.Dictionary.StiUserFunction;
    import StiResource = Stimulsoft.Report.Dictionary.StiResource;
    import StiVirtualSource = Stimulsoft.Report.Dictionary.StiVirtualSource;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiDataColumnsCollection = Stimulsoft.Report.Dictionary.StiDataColumnsCollection;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiPromise = Stimulsoft.System.StiPromise;
    import StiFileDatabase = Stimulsoft.Report.Dictionary.StiFileDatabase;
    import StiDataTransformation = Stimulsoft.Report.Dictionary.StiDataTransformation;
    class StiDictionaryHelper {
        private static currentCulture;
        private static databaseItem4;
        private static databaseItem1;
        private static dataTransformationCategoryItem;
        private static datasourceItem;
        static dataTransformationItem(dataTransformation: StiDataTransformation): {
            [key: string]: string | {
                [key: string]: string | boolean | string[] | unknown;
            }[];
        };
        private static columnItem;
        private static parameterItem;
        private static relationItem;
        private static businessObjectItem;
        private static variableItem;
        private static tableItem;
        private static functionItem;
        private static userFunctionItem;
        private static functionsCategoryItem;
        static resourceItem(resource: StiResource, report: StiReport): any;
        private static imagesGalleryItem;
        private static richTextGalleryItem;
        private static getDictionaryRestrictions;
        static getGroupColumnsProperty(dataSource: StiVirtualSource): string;
        static getResultsProperty(dataSource: StiVirtualSource): string;
        private static setGroupColumnsAndResultsProperty;
        private static headersToJson;
        private static jsonToHeaders;
        private static getDataParameterTypes;
        private static getItemType;
        private static getItemKeyObject;
        private static getItems;
        private static createDataBaseByTypeName;
        private static createDataBaseByServiceName;
        private static createDataAdapterByTypeName;
        private static copyProperties;
        static getColumnsByTypeAndNameOfObject(report: StiReport, props: any): StiDataColumnsCollection;
        private static getDatabaseByName;
        private static updateColumns;
        private static updateParameters;
        private static getVariableBasicType;
        private static getVariableType;
        private static getValueByType;
        private static setDialogInfoItems;
        static getBusinessObjectByFullName(report: StiReport, fullName: string[]): StiBusinessObject;
        private static getAjaxDataFromDatabaseInformation;
        private static convertAjaxDatabaseInfoToDatabaseInfo;
        private static createDataStoreSourceFromParams;
        private static saveDataSourceParam;
        static getViewDataItemValue(item: any, type: Stimulsoft.System.Type): any;
        static createNewDatabaseFromResource(report: StiReport, resource: StiResource): StiFileDatabase;
        static getNewDatabaseName(report: StiReport, fileName: string): string;
        private static isCategoryVariable;
        private static getVariableCategory;
        private static getUniqueName;
        static removeTempSampleData(report: StiReport, dataGuid: string): void;
        private static unPackGraphSqlConnectionString;
        private static packGraphSqlConnectionString;
        private static renameResourceHyperlinkInDatabases;
        private static applyParametersToSqlSourse;
        private static restoreParametersToSqlSourse;
        private static applyDataSourceProps;
        private static applyConnectionProps;
        private static applyColumnProps;
        private static applyParameterProps;
        private static applyRelationProps;
        private static dataSourceContainDataRelation;
        private static dataSourceContainNameInSource;
        private static applyBusinessObjectProps;
        private static applyVariableProps;
        private static applyResourceProps;
        static applyUserFunctionProps(report: StiReport, userFunction: StiUserFunction, userFuncProps: any): void;
        static getIconTypeForColumn(column: StiDataColumn): StiImagesID;
        static getLockedCalcImageIDFromType(type: Stimulsoft.System.Type, inherited: boolean): StiImagesID;
        private static getDataColumnImageIdFromType;
        private static getTypeValueToString;
        private static getTypeVariableToString;
        static getTypeFromString(type: string): Stimulsoft.System.Type;
        static getDictionaryTree(report: StiReport): any;
        static getResourcesTree(report: StiReport): any[];
        static getFunctionsTree(report: StiReport): any[];
        static getUserFunctionsTree(report: StiReport): any[];
        static getSystemVariablesTree(report: StiReport): string[];
        private static getDataBasesTree;
        private static isExistInDatabases;
        private static getObjectsTreeByCategories;
        private static getBusinessObjectsTree;
        private static getChildBusinessObjectsTree;
        private static getVariablesTree;
        private static getColumnsTree1;
        private static getColumnsTree2;
        private static getColumnsTree3;
        private static getParametersTree;
        private static getRelationsTree3;
        private static getRelationsTree2;
        private static getRelationsTree4;
        static getConnectionTypes(report: StiReport, param: any, callbackResult: any, showAdaptersInNewConnectionForm?: boolean): void;
        static getDataAdapterTypes(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditConnection(report: StiReport, param: any, callbackResult: any): void;
        static deleteConnection(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditRelation(report: StiReport, param: any, callbackResult: any): void;
        static deleteRelation(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditColumn(report: StiReport, param: any, callbackResult: any): void;
        static deleteColumn(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditParameter(report: StiReport, param: any, callbackResult: any): void;
        static deleteParameter(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditDataSource(report: StiReport, param: any, callbackResult: any): void;
        static deleteDataSource(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditBusinessObject(report: StiReport, param: any, callbackResult: any): void;
        static deleteBusinessObject(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditVariable(report: StiReport, param: any, callbackResult: any): void;
        static deleteVariable(report: StiReport, param: any, callbackResult: any): void;
        static deleteVariablesCategory(report: StiReport, param: any, callbackResult: any): void;
        static editVariablesCategory(report: StiReport, param: any, callbackResult: any): void;
        static createVariablesCategory(report: StiReport, param: any, callbackResult: any): void;
        static saveCopyVariableCategory(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditResource(report: StiReport, param: any, callbackResult: any): void;
        static deleteResources(report: StiReport, param: any, callbackResult: any): void;
        static deleteResource(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditUserFunction(report: StiReport, param: any, callbackResult: any): void;
        static deleteUserFunction(report: StiReport, param: any, callbackResult: any): void;
        static deleteBusinessObjectCategory(report: StiReport, param: any, callbackResult: any): void;
        static editBusinessObjectCategory(report: StiReport, param: any, callbackResult: any): void;
        static deleteDictionaryTreeBranch(report: StiReport, param: any, callbackResult: any): void;
        static synchronizeDictionaryAsync(report: StiReport, param: any, callbackResult: any): Promise<StiPromise<void>>;
        static newDictionary(report: StiReport, param: any, callbackResult: any): void;
        static getAllConnectionsAsync(report: StiReport, param: any, callbackResult: any): StiPromise<void>;
        static retrieveColumnsAsync(report: StiReport, param: any, callbackResult: any): StiPromise<void>;
        static getDatabaseDataAsync(report: StiReport, param: any, callbackResult: any): StiPromise<void>;
        static applySelectedData(report: StiReport, param: any, callbackResult: any): void;
        static testConnectionAsync(report: StiReport, param: any, callbackResult: any): StiPromise<void>;
        static runQueryScriptAsync(report: StiReport, param: any, callbackResult: any): StiPromise<void>;
        static viewDataAsync(report: StiReport, param: any, callbackResult: any): StiPromise<void>;
        static getSqlParameterTypes(report: StiReport, param: any, callbackResult: any): void;
        static createFieldOnDblClick(report: StiReport, param: any, callbackResult: any): void;
        static getParamsFromQueryString(report: StiReport, param: any, callbackResult: any): void;
        static getImagesGallery(report: StiReport, param: any, callbackResult: any): StiPromise<void>;
        static getRichTextGallery(report: StiReport, param: any, callbackResult: any): void;
        static getSampleConnectionString(report: StiReport, param: any, callbackResult: any): void;
        static createDatabaseFromResource(report: StiReport, param: any, callbackResult: any): void;
        static deleteAllDataSources(report: StiReport, param: any, callbackResult: any): void;
        static getVariableItemsFromDataColumn(report: StiReport, param: any, callbackResult: any): StiPromise<void>;
        static moveDictionaryItem(report: StiReport, param: any, callbackResult: any): void;
        static moveUserFunctionItem(report: StiReport, param: any, callbackResult: any): void;
        static moveConnectionDataToResource(report: StiReport, param: any, callbackResult: any): void;
        static openDictionary(report: StiReport, param: any, callbackResult: any): Promise<void>;
        static mergeDictionary(report: StiReport, param: any, callbackResult: any): Promise<void>;
        static embedAllDataToResources(report: StiReport, param: any, callbackResult: Hashtable): Promise<void>;
        static testODataConnection(report: StiReport, param: any, callbackResult: any): void;
        static duplicateDictionaryElement(report: StiReport, param: any, callbackResult: any): void;
        static setDictionaryElementProperty(report: StiReport, param: any, callbackResult: any): void;
        static prepareToChangeDatabaseType(report: StiReport, param: any, callbackResult: any): void;
        static changeDatabaseType(report: StiReport, param: any, callbackResult: any): void;
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import IStiProgressElement = Stimulsoft.Report.Dashboard.IStiProgressElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiProgressElementHelper {
        private progressElement;
        private getProgressElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private getMeterByContainerName;
        private setExpression;
        private renameMeter;
        private setFunction;
        private moveMeter;
        private createNewItem;
        private setDataColumn;
        private setValueToManuallyEnteredData;
        private setPropertyValue;
        private static getProgressElementStyles;
        static getStylesContent(report: StiReport, param: any, withReportStyles?: boolean): Promise<{
            [key: string]: string | number;
        }[]>;
        static isSeriesPresent(progressElement: IStiProgressElement): boolean;
        constructor(progressElement: IStiProgressElement);
    }
}
export namespace Stimulsoft.Designer {
    import IStiTrendLinesCollection = Stimulsoft.Report.Chart.IStiTrendLinesCollection;
    import IStiChartElement = Stimulsoft.Report.Dashboard.IStiChartElement;
    import IStiSeriesLabels = Stimulsoft.Report.Chart.IStiSeriesLabels;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import IStiArea = Stimulsoft.Report.Chart.IStiArea;
    import IStiConstantLines = Stimulsoft.Report.Chart.IStiConstantLines;
    import IStiStrips = Stimulsoft.Report.Chart.IStiStrips;
    import IStiChartConditionsCollection = Stimulsoft.Report.Chart.IStiChartConditionsCollection;
    import IStiChartFiltersCollection = Stimulsoft.Report.Chart.IStiChartFiltersCollection;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiChartHelper {
        static getChartProperties(chart: IStiChart): any;
        static getSeriesArray(chart: IStiChart): any[];
        static getSeries(series: IStiSeries): any;
        static getConditions(conditions: IStiChartConditionsCollection): any[];
        static getFilters(filters: IStiChartFiltersCollection): any[];
        static getTrendLines(trendLines: IStiTrendLinesCollection): any[];
        static getTypesCollection(chart: IStiChart): any[];
        static getArea(chart: IStiChart): any;
        static getStyle(chart: IStiChart): any;
        static getMainProperties(chart: IStiChart): any;
        static getConstantLines(chart: IStiChart): any[];
        static getConstantLineProperties(constantLine: IStiConstantLines): any;
        static getStrips(chart: IStiChart): any[];
        static getStripsProperties(strip: IStiStrips): any;
        static getLabels(seriesLabels: IStiSeriesLabels): any;
        static getSeriesProperties(series: IStiSeries): any;
        static removeNotBrowsableAreaProperties(area: IStiArea, propertiesCollection: any): any;
        static removeNotBrowsableSeriesProperties(series: IStiSeries, propertiesCollection: any): any;
        static getAreaProperties(area: IStiArea): any;
        static getLabelsProperties(labels: IStiSeriesLabels): any;
        static setConditionsValue(conditions: IStiChartConditionsCollection, conditionValues: any[]): void;
        static setFiltersValue(filters: IStiChartFiltersCollection, filterValues: any[]): void;
        static setTrendLinesValue(trendLines: IStiTrendLinesCollection, trendLinesValues: any[]): void;
        static getChartSampleSvg(svgData: StiSvgData, zoom: number): string;
        private static addDefaultSeries;
        private static setAreaToSimpleMode;
        static cloneChart(chart: IStiChart): IStiChart;
        static cloneChart2(element: IStiChartElement): IStiChart;
        private static getChartStyles;
        private static removeProperties;
        static addSeries(report: StiReport, param: any, callbackResult: any): void;
        static removeSeries(report: StiReport, param: any, callbackResult: any): void;
        static duplicateSeries(report: StiReport, param: any, callbackResult: any): void;
        static seriesMove(report: StiReport, param: any, callbackResult: any): void;
        static addStrip(report: StiReport, param: any, callbackResult: any): void;
        static removeStrip(report: StiReport, param: any, callbackResult: any): void;
        static moveStrip(report: StiReport, param: any, callbackResult: any): void;
        static addConstantLine(report: StiReport, param: any, callbackResult: any): void;
        static removeConstantLine(report: StiReport, param: any, callbackResult: any): void;
        static moveConstantLine(report: StiReport, param: any, callbackResult: any): void;
        static addConstantLineOrStrip(report: StiReport, param: any, callbackResult: any): void;
        static removeConstantLineOrStrip(report: StiReport, param: any, callbackResult: any): void;
        static constantLineOrStripMove(report: StiReport, param: any, callbackResult: any): void;
        static getLabelsContent(report: StiReport, param: any, callbackResult: any): void;
        static getStylesContent(report: StiReport, param: any, callbackResult: any, forStylesControl: boolean, withReportStyles?: boolean): void;
        static setLabelsType(report: StiReport, param: any, callbackResult: any): void;
        static setLabelsType2(component: StiComponent, propertyValue: string): void;
        static setChartStyle(report: StiReport, param: any, callbackResult: any): void;
        static setChartPropertyValue(report: StiReport, param: any, callbackResult: any): void;
        static setContainerValue(report: StiReport, param: any, callbackResult: any): void;
        private static convertSeries;
        private static transferSeriesData;
        private static setSeriesType;
        private static rewriteArgumentDataColumns;
        private static getDraggedDataColumnValue;
        private static convertSeriesToChartSeriesType;
        private static getChartSeriesTypes;
        private static createSeries;
        private static getArgumentDataColumns;
        private static insertSeries;
        private static getSeriesDataColumnPropertyName;
        private static setDataColumnValue;
        private static getDataColumnValue;
        static isAxisAreaChart(chart: IStiChart): boolean;
        static isAxisAreaChart3D(chart: IStiChart): boolean;
        static isClusteredColumnChart(chart: IStiChart): boolean;
        static isClusteredColumnChart3D(chart: IStiChart): boolean;
        static isPieChart(chart: IStiChart): boolean;
        static isDoughnutChart(chart: IStiChart): boolean;
        static isFunnelChart(chart: IStiChart): boolean;
        static isTreemapChart(chart: IStiChart): boolean;
        static isSunburstChart(chart: IStiChart): boolean;
        static isHeatmapChart(chart: IStiChart): boolean;
        static isWaterfallChart(chart: IStiChart): boolean;
        static isPictorialStackedChart(chart: IStiChart): boolean;
        static isPictorialChart(chart: IStiChart): boolean;
        static is3DLineChart(chart: IStiChart): boolean;
        static isRadarChart(chart: IStiChart): boolean;
        static isBubbleChart(chart: IStiChart): boolean;
        static isStackedChart(chart: IStiChart): boolean;
        static updateChart(report: StiReport, param: any, callbackResult: any): void;
        private static insertDataColumn;
        private static createSeriesOrSetDataColumn;
        private static removeDataColumn;
        private static setPropertyValue;
        static moveSeries(chart: IStiChart, param: any, callbackResult: any): void;
        static moveArgument(chart: IStiChart, param: any, callbackResult: any): void;
        static moveMeter(chart: IStiChart, param: any, callbackResult: any): void;
        static swapMeters(chart: IStiChart, param: any, callbackResult: any): void;
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import IStiChartElement = Stimulsoft.Report.Dashboard.IStiChartElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiChartElementHelper {
        private chartElement;
        private getChartElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        static getUserViewStates(chartElement: IStiChartElement): {
            [key: string]: string;
        }[];
        private setPropertySeriesType;
        private showEmptyValuesInSimpleWay;
        private isShowZerosAsOrNullsAs;
        private isShowZeros;
        private isShowNulls;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private setPropertyValue;
        private setPropertyValueToValueMeter;
        private getMeterFromContainer;
        private renameMeter;
        private setExpression;
        private setFunction;
        private setValueToManuallyEnteredData;
        private removeMeter;
        private removeAllMeters;
        private swapMeters;
        private moveMeter;
        private duplicateMeter;
        private insertMeters;
        private createNewItem;
        private isPictorialSeries;
        private setSeriesType;
        private static getChartElementStyles;
        static getStylesContent(report: StiReport, param: any, withReportStyles?: boolean): {
            [key: string]: string | number;
        }[];
        static getValueMeterItems(chartElement: IStiChartElement): {
            [key: string]: string;
        }[];
        static getArgumentMeterItems(chartElement: IStiChartElement): {
            [key: string]: string;
        }[];
        static getSeriesMeterItems(chartElement: IStiChartElement): {
            [key: string]: string;
        }[];
        private setUserViewState;
        private changeViewState;
        private removeUserViewState;
        private createNewUserViewState;
        private getNextItemName;
        static getConstantLines(chartElement: IStiChartElement): any[];
        private static getConstantLineProperties;
        private addConstantLine;
        private removeConstantLine;
        private moveConstantLine;
        static getStrips(chartElement: IStiChartElement): any[];
        private static getStripsProperties;
        private addStrip;
        private removeStrip;
        private moveStrip;
        constructor(chartElement: IStiChartElement);
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiDashboard = Stimulsoft.Report.Dashboard.IStiDashboard;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiTextElement = Stimulsoft.Report.Dashboard.IStiTextElement;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    class StiTextElementHelper {
        private textElement;
        private getTextElementJSProperties;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private setProperty;
        static getMeasureItems(textElement: IStiTextElement): {
            [key: string]: string | string[];
        }[];
        private static getMeasureMeterItem;
        static getMeterFunctions(meter: IStiMeter, dashboard: IStiDashboard): string[];
        private setPropertyMeasure;
        private newMeter;
        private insertMeters;
        private moveMeter;
        private removeMeter;
        private renameMeter;
        private removeAllMeters;
        private duplicateMeter;
        private setFunction;
        private static removeTagsFromText;
        static checkFontProperties(textElement: IStiTextElement): void;
        static setFontProperties(textElement: IStiTextElement, fontAttrs: any): void;
        static getFontProperty(textElement: IStiTextElement): Font;
        static getHorAlignmentProperty(textElement: IStiTextElement): StiTextHorAlignment;
        private static getColorFromText;
        static getForeColorsProperty(textElement: IStiTextElement): any[];
        static createTextElementFromDictionary(report: StiReport, param: any, callbackResult: any): void;
        constructor(textElement: IStiTextElement);
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import IStiNumberBoxElement = Stimulsoft.Report.Dashboard.IStiNumberBoxElement;
    class StiNumberBoxElementHelper {
        private numberBoxElement;
        private getNumberBoxElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        static isVariablePresent(numberBoxElement: IStiNumberBoxElement): boolean;
        static isRangeVariablePresent(numberBoxElement: IStiNumberBoxElement): boolean;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private moveMeter;
        private renameMeter;
        private createNewItem;
        private editField;
        private setDataColumn;
        private setPropertyValue;
        constructor(numberBoxElement: IStiNumberBoxElement);
    }
}
export namespace Stimulsoft.Designer {
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiTitlePadding = Stimulsoft.Report.Dashboard.StiTitlePadding;
    import StiCornerRadius = Stimulsoft.Base.Drawing.StiCornerRadius;
    import DateTime = Stimulsoft.System.DateTime;
    import IStiPivotTableElement = Stimulsoft.Report.Dashboard.IStiPivotTableElement;
    import StiPromise = Stimulsoft.System.StiPromise;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiProgressElement = Stimulsoft.Report.Dashboard.IStiProgressElement;
    import IStiIndicatorElement = Stimulsoft.Report.Dashboard.IStiIndicatorElement;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    import StiMargin = Stimulsoft.Report.Dashboard.StiMargin;
    import StiPadding = Stimulsoft.Report.Dashboard.StiPadding;
    import IStiChartElement = Stimulsoft.Report.Dashboard.IStiChartElement;
    import IStiTableElement = Stimulsoft.Report.Dashboard.IStiTableElement;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiTable = Stimulsoft.Report.Components.Table.StiTable;
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    import StiInteraction = Stimulsoft.Report.Components.StiInteraction;
    import StiBaseCondition = Stimulsoft.Report.Components.StiBaseCondition;
    import StiCondition = Stimulsoft.Report.Components.StiCondition;
    import StiColorScaleCondition = Stimulsoft.Report.Components.StiColorScaleCondition;
    import StiIconSetCondition = Stimulsoft.Report.Components.StiIconSetCondition;
    import StiDataBarCondition = Stimulsoft.Report.Components.StiDataBarCondition;
    import StiConditionsCollection = Stimulsoft.Report.Components.StiConditionsCollection;
    import StiFiltersCollection = Stimulsoft.Report.Components.StiFiltersCollection;
    import StiConditionPermissions = Stimulsoft.Report.Components.StiConditionPermissions;
    import StiConditionBorderSides = Stimulsoft.Report.Components.StiConditionBorderSides;
    import StiMargins = Stimulsoft.Report.Components.StiMargins;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiSubReport = Stimulsoft.Report.Components.StiSubReport;
    import StiShape = Stimulsoft.Report.Components.StiShape;
    import StiRichText = Stimulsoft.Report.Components.StiRichText;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiImage = Stimulsoft.Report.Components.StiImage;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiStylesCollection = Stimulsoft.Report.Styles.StiStylesCollection;
    class StiReportEdit {
        private static rgbToHex;
        static setPropertyValue(report: StiReport, propertyName: string, owner: any, value: any, enumType?: any): void;
        static getPropertyValue(propertyName: string, owner: any): any;
        static getFiltersProperty(obj: any): any;
        static setFiltersProperty(obj: any, value: any): void;
        static lowerFirstChar(text: string): string;
        static lowerFirstCharPropertyNames(text: string): string;
        static upperFirstChar(text: string): string;
        static getPivotTableMeters(pivotTableElement: IStiPivotTableElement): {};
        static metersToHashtable(meters: IStiMeter[]): {
            [key: string]: string;
        };
        static getOnlyBase64Content(base64String: string): string;
        static getPivotTableMetersSeparately(pivotTableElement: IStiPivotTableElement): {
            [key: string]: {
                [key: string]: string;
            };
        };
        static base64ToImageByteArray(base64String: string): number[];
        static base64ToImage(base64String: string): Stimulsoft.System.Drawing.Image;
        static imageToBase64_2(image: number[]): string;
        static imageToBase64(image: Stimulsoft.System.Drawing.Image): string;
        static marginToStr(margin: StiMargin): string;
        static marginsToStr(margins: StiMargins): string;
        static paddingToStr(padding: StiPadding): string;
        static titlePaddingToStr(padding: StiTitlePadding): string;
        static cornerRadiusToStr(cornerRadius: StiCornerRadius): string;
        static fontToStr(font: Font): string;
        static brushToStr(brush: StiBrush): string;
        static borderToStr(border: StiBorder): string;
        static simpleBorderToStr(border: StiSimpleBorder): string;
        static getStringFromColor(color: Color): string;
        static addComponentToPage(component: StiComponent, currentPage: StiPage): void;
        static getParentName(comp: StiComponent): string;
        static getParentIndex(comp: StiComponent): number;
        static getComponentIndex(component: StiComponent): number;
        static getAllChildComponents(component: StiComponent): string;
        static getPropsRebuildPage(report: StiReport, currentPage: StiPage): any;
        static getAllDbsElementsSvgContentsAsync(report: StiReport): Promise<any>;
        static getPageIndexes(report: StiReport): any;
        static setComponentRectWithOffset(comp: StiComponent, newCompRect: RectangleD, command: string, resizeType: string, compProps: any): void;
        static setComponentRect(component: StiComponent, rect: RectangleD, alignToGrid?: boolean, correctOnlySelect?: boolean): void;
        static getComponentRect(component: StiComponent): string;
        static getPageSize(page: StiPage): string;
        static getPageMargins(page: StiPage): string;
        static getAllComponentsPositions(report: StiReport, callbackResult: any): void;
        private static getIconSetItemObject;
        private static getIconSetItemFromObject;
        static strToColor(colorStr: string): Color;
        static strToNumber(value: string): number;
        static dateTimeToStr(value: DateTime): string;
        static strToDateTime(value: string): DateTime;
        static numberToStr(value: number): string;
        static strToBrush(value: string): StiBrush;
        static strToBorder(value: string): StiBorder;
        static strToSimpleBorder(value: string): StiSimpleBorder;
        static strToMargins(str: string): StiMargins;
        static strToMargin(str: string): StiMargin;
        static strToPadding(str: string): StiPadding;
        static strToTitlePadding(str: string): StiTitlePadding;
        static strToCornerRadius(str: string): StiCornerRadius;
        static strToFont(value: string): Font;
        static strBordersToConditionBorderSidesObject(borders: string): StiConditionBorderSides;
        static strPermissionsToConditionPermissionsObject(strPermissions: string): StiConditionPermissions;
        static getReportFileName(report: StiReport): string;
        static createInfographicComponent(componentTypeArray: string, report: StiReport, param: any): StiComponent;
        static createShapeComponent(componentTypeArray: string): StiComponent;
        private static createBarCodeComponent;
        private static applyStyleCollection;
        static applyStyles(comp: StiComponent, stylesCollection: StiStylesCollection): void;
        static getComponentMainProperties(component: StiComponent, zoom: number): {
            [key: string]: string | StiPromise<string>;
        };
        static getTableCells(table: StiTable, zoom: number): any[];
        static getColumnFromColumnPath(columnPath: string, report: StiReport): StiDataColumn;
        static getImageContentForPaint(imageComp: StiImage, requestParams?: any): string;
        private static getCustomIconFromString;
        static getWatermarkImageContentForPaint(page: StiPage, pageProps: any): string;
        static addPrimitivePoints(addedComp: StiComponent, currentPage: StiPage): void;
        static removePrimitivePoints(removiedComp: StiComponent): void;
        static changeRectPrimitivePoints(changedComp: StiComponent, rect: RectangleD): void;
        static checkAllPrimitivePoints(page: StiPage): void;
        static isAlignedByGrid(component: StiComponent): boolean;
        static addSubReportPage(subReport: StiSubReport, callbackResult: any): void;
        static getColorsCollectionProperty(colors: Color[]): string[];
        private static dbsElementDataFiltersIsPresent;
        private static dbsElementUserFiltersIsPresent;
        static getAllProperties(component: StiComponent, requestParams?: any): any;
        static getRichTextProperty(component: StiRichText): string;
        static getSortDataProperty(object: any): string;
        private static getRelationNameByNameInSource;
        private static getSingleSort;
        static getFiltersObject(filters: StiFiltersCollection): any[];
        static getFilterDataProperty(component: StiBaseCondition | StiComponent): string;
        static getFilterOnProperty(component: StiBaseCondition | StiComponent): boolean;
        static getFilterModeProperty(component: StiBaseCondition | StiComponent): string;
        static getSvgContentAsync2(component: StiComponent, zoom?: number): StiPromise<string>;
        static convertConditionsToString(conditions: StiConditionsCollection): string;
        static getConditionsProperty(component: StiComponent): string;
        static getDataBarConditionObject(condition: StiDataBarCondition): {
            [key: string]: string | boolean;
        };
        static getIconSetConditionObject(condition: StiIconSetCondition): {
            [key: string]: string | {
                [key: string]: string;
            };
        };
        static getColorScaleConditionObject(condition: StiColorScaleCondition): {
            [key: string]: string;
        };
        static getHighlightConditionObject(condition: StiCondition): {
            [key: string]: string | boolean;
        };
        static getComponentHeaderSize(component: any): string;
        static getInteractionProperty(interaction: StiInteraction): any;
        static getCrossTabFieldsProperties(crossTab: StiCrossTab): any[];
        static getEventsProperty(element: any): any;
        static getSubReportParametersProperty(subReport: StiSubReport): any[];
        static getShapeTypeProperty(component: StiShape): string;
        static getElementLayoutProperty(layout: StiElementLayout): string;
        static getPreviewSettingsProperty(report: StiReport): {
            [key: string]: string | boolean;
        };
        static getTopNProperty(topN: StiDataTopN): {
            [key: string]: string | number | boolean;
        };
        static getOnlineMapContentAsync(component: StiComponent): StiPromise<string>;
        static getCultures(): any[];
        static getPivotTableConditionsProperty(pivotTableElement: IStiPivotTableElement): any[];
        static getExpressionsProperty(component: StiComponent): {
            [key: string]: string;
        };
        static getStylesProperty(component: any): any[];
        static getDashboardInteractionProperty(dashboardInteraction: IStiDashboardInteraction): any;
        static getChartTrendLinesProperty(chartElement: IStiChartElement): any[];
        static getChartConditionsProperty(chartElement: IStiChartElement): any[];
        static getIndicatorConditionsProperty(indicatorElement: IStiIndicatorElement): any[];
        static getProgressConditionsProperty(progressElement: IStiProgressElement): any[];
        static getTableConditionsProperty(tableElement: IStiTableElement): any[];
        private static getTableMeters;
        private static getDashboardWatermarkProperty;
        private static getWeaveWatermarkImages;
        private static getButtonIconSetProperty;
        private static getButtonVisualStatesProperty;
        private static getButtonStyleColors;
        static setAllProperties(component: StiComponent, props: any[]): void;
        static setSubReportPageProperty(component: any, propertyValue: any): void;
        static setContainerProperty(component: StiComponent, propertyValue: string): void;
        static setShapeTypeProperty(component: StiComponent, shapeType: string): void;
        static setBarCodeTypeProperty(component: StiComponent, propValue: string): void;
        static setMarginsProperty(component: StiComponent, propertyValue: string): void;
        static setTextProperty(component: StiComponent, propertyValue: string): void;
        static setExcelValueProperty(component: StiComponent, propertyValue: string): void;
        static setExcelSheetProperty(component: StiComponent, propertyValue: string): void;
        static setElementLayoutProperty(component: StiComponent, propValue: any): void;
        static setPreviewSettingsProperty(report: StiReport, previewSettings: any, callbackResult: any): void;
        static setColorsCollectionProperty(object_: any, propertyName: string, propertyValue: any[]): void;
        static setTopNProperty(component: any, propertyValue: any): void;
        static setDashboardInteractionProperty(dashboardInteraction: IStiDashboardInteraction, propertyValue: any): void;
        static setChartTrendLinesProperty(component: StiComponent, propertyValue: any): void;
        static setChartConditionsProperty(component: StiComponent, propertyValue: any): void;
        static setPivotTableConditionsProperty(component: StiComponent, propertyValue: any): void;
        static setIndicatorConditionsProperty(component: StiComponent, propertyValue: any): void;
        static setProgressConditionsProperty(component: StiComponent, propertyValue: any): void;
        static setTableConditionsProperty(component: StiComponent, propertyValue: any): void;
        static setExpressionsProperty(component: StiComponent, propertyValue: any): void;
        static setStylesProperty(component: any, propertyValue: any): void;
        private static setDashboardWatermarkProperty;
        static setRichTextProperty(component: StiComponent, propertyValue: string): void;
        static setTextFormatProperty(component: StiComponent, propertyValue: any, propertyName?: string): void;
        static setConditionProperty(component: StiComponent, propertyValue: string): void;
        private static getCorrectName;
        static setDataSourceProperty(component: any, propertyValue: string): void;
        static setDataRelationProperty(component: any, propertyValue: string): void;
        static setMasterComponentProperty(component: StiComponent, propertyValue: string): void;
        static setBusinessObjectProperty(component: StiComponent, propertyValue: string): void;
        static setSortDataProperty1(object: any, sortArray: any[]): void;
        static setSortDataProperty2(object: any, propertyValue: string): void;
        private static getSortArray;
        private static getColumnPathArray;
        private static getChildRelation;
        static setFilterDataProperty1(component: StiBaseCondition | any, filters: any[]): void;
        static setFilterDataProperty2(component: StiBaseCondition | any, propertyValue: string): void;
        private static filterFromObject;
        private static strToFilterDataType;
        private static strToFilterCondition;
        static setFilterOnProperty(component: StiBaseCondition | StiComponent, propertyValue: string): void;
        static setFilterModeProperty(component: StiBaseCondition | StiComponent, propertyValue: string): void;
        static setShiftModeProperty(component: any, propValue: any): void;
        static setRestrictionsProperty(component: StiComponent, propertyValue: string): void;
        static strToIndicatorConditionsPermissions(propertyValue: string): number;
        static strToProgressConditionsPermissions(propertyValue: string): number;
        static strToTableConditionsPermissions(propertyValue: string): number;
        static setAnchorProperty(component: StiComponent, propertyValue: string): void;
        static getConditionsCollectionFromJSObject(propertyValue: string): StiConditionsCollection;
        static setConditionsProperty(component: any, propertyValue: string): void;
        static createHighlightCondition(conditionObject: any): StiBaseCondition;
        static createDataBarCondition(conditionObject: any): StiBaseCondition;
        static createColorScaleCondition(conditionObject: any): StiBaseCondition;
        static createIconSetCondition(conditionObject: any): StiBaseCondition;
        static setInteractionProperty(component: StiComponent, propertyValue: any): void;
        static setChartStyleProperty(component: any, propertyValue: any): void;
        static setGaugeStyleProperty(component: any, propertyValue: any): void;
        static setMapStyleProperty(component: any, propertyValue: any): void;
        static setCrossTabStyleProperty(component: any, propertyValue: any): void;
        static setSubReportParametersProperty(component: any, propertyValue: any): void;
        static writeReportToJsObject(report: StiReport, zoom?: number): any;
        static writeReportToJsObject2(report: StiReport, attachedItems: any, zoom?: number): any;
        static createComponent(report: StiReport, param: any, callbackResult: any): void;
        static removeComponent(report: StiReport, param: any, callbackResult: any): void;
        static changeRectComponent(report: StiReport, param: any, callbackResult: any): void;
        static addPage(report: StiReport, param: any, callbackResult: any): void;
        static removePage(report: StiReport, param: any, callbackResult: any): void;
        static readAllPropertiesFromString(report: StiReport, param: any, callbackResult: any): void;
        static changeUnit(report: StiReport, unitName: string): void;
        static getPreviewPagesAsync(onResult: Function, designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static cloneReportForPreview(report: StiReport): StiReport;
        static setToClipboard(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static getFromClipboard(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static addReportToUndoArray(designer: StiDesigner, report: StiReport, withResources?: boolean): void;
        static getUndoStep(designer: StiDesigner, currentReport: StiReport, param: any, callbackResult: any): StiReport;
        static getRedoStep(designer: StiDesigner, currentReport: StiReport, param: any, callbackResult: any): StiReport;
        static renameComponent(report: StiReport, param: any, callbackResult: any): void;
        static saveComponentClone(designer: StiDesigner, component: StiComponent): void;
        static canceledEditComponent(designer: StiDesigner, currentReport: StiReport, param: any): void;
        static createTextComponentFromDictionary(report: StiReport, param: any, callbackResult: any): void;
        static createComponentFromResource(report: StiReport, param: any, callbackResult: any): void;
        static createElementFromResource(report: StiReport, param: any, callbackResult: any): void;
        private static alignToMaxGrid;
        private static alignToGrid;
        static createDataComponentFromDictionary(report: StiReport, param: any, callbackResult: any): void;
        static setReportProperties(report: StiReport, param: any, callbackResult: any): void;
        static getReportProperties(report: StiReport): any;
        static pageMove(report: StiReport, param: any, callbackResult: any): void;
        static pageMoveToIndex(report: StiReport, param: any, callbackResult: any): void;
        static alignToGridComponents(report: StiReport, param: any, callbackResult: any): void;
        static changeArrangeComponents(report: StiReport, param: any, callbackResult: any): void;
        static duplicatePage(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static setEventValue(report: StiReport, param: any, callbackResult: any): void;
        static changeSizeComponents(report: StiReport, param: any, callbackResult: any): void;
        static createMovingCopyComponent(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static updateReportAliases(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static openPage(report: StiReport, param: any, callbackResult: any): void;
        private static checkSvgContentQueue;
        private static checkSvgContentCheckQueue;
        private static checkSvgContent2;
        static checkSvgContent(checkObject: any): StiPromise<void>;
    }
}
export namespace Stimulsoft.Report.Web {
    class StiBlocklyFontHelper {
        static loadFonts(report: StiReport): string[];
    }
}
export namespace Stimulsoft.Report.Web {
    class StiBlocklyComponentHelper {
        static loadComponents(report: StiReport): string[];
        static loadContainerComponents(report: StiReport): string[];
    }
}
export namespace Stimulsoft.Report.Web {
    class StiBlocklyDataSourceHelper {
        static loadDataSource(report: StiReport): string[];
        static getDataSourceProperties(): string[];
        static getDataSourceMethods(): string[];
    }
}
export namespace Stimulsoft.Report.Web {
    class StiBlocklyVariableHelper {
        static loadVariables(report: StiReport): string[];
    }
}
export namespace Stimulsoft.Report.Web {
    class StiBlocksParser {
        static getCategoryBlock(name: string, color: string, content: string): string;
    }
}
export namespace Stimulsoft.Report.Web {
    import StiUserFunctionsCollection = Stimulsoft.Report.Dictionary.StiUserFunctionsCollection;
    class StiFunctionBlocksParser {
        static getInitFunctionBlocks(userFunctions: StiUserFunctionsCollection): string;
        static getFunctionsGrouppedInCategoriesBlocks(userFunctions: StiUserFunctionsCollection): string;
    }
}
export namespace Stimulsoft.Report.Web {
    import StiUserFunction = Stimulsoft.Report.Dictionary.StiUserFunction;
    class StiBlocklyHelper {
        static get isAssemblyLoaded(): boolean;
        static getResourceFileText(filename: string): string;
        static getToolboxXML(report: StiReport, showCurrentValue: boolean, userFunction: StiUserFunction): string;
        static getBlockyWorkspaceXML(eventValue: string): string;
        static getSampleXML(): string;
        static getBlocklyInitParameters(report: StiReport, param: any, callbackResult: any): void;
        static getInitBlocksJsCode(report: StiReport, userFunction: StiUserFunction): string;
        private static getDrillDownBrushList;
        private static getDrillDownFontList;
        private static getDrillDownComponentList;
        private static getDrillDownComponentGetComponentsList;
        private static getDrillDownVariableList;
        private static getDrillDownDataSourceList;
        private static getDrillDownDataSourcePropertyList;
        private static getDrillDownDataSourceMethodsList;
        private static getDrillDownSystenVariableList;
        private static getDrillDownOptions;
    }
}
export namespace Stimulsoft.Report.Web {
    import StiFunction = Stimulsoft.Report.Dictionary.StiFunction;
    class StiBlocklyBlock {
        id: string;
        name: string;
        tooltip: string;
        helpUrl: string;
        previousStatement: boolean;
        nextStatement: boolean;
        inputsInline: boolean;
        output: boolean;
        color: string;
        valueInputs: StiBlocklyInput[];
        function: StiFunction;
        getXmlToolboxDefinition(): string;
        getJsDefinition(): string;
        private getInputJsDefinitions;
        getTooltip(func?: StiFunction): string;
    }
}
export namespace Stimulsoft.Report.Web {
    import StiUserFunctionArgument = Stimulsoft.Report.Dictionary.StiUserFunctionArgument;
    class StiArgUserFunctionBlock extends StiBlocklyBlock {
        static idKey: string;
        argument: StiUserFunctionArgument;
        getTooltip(): string;
        getXmlToolboxDefinition(): string;
        constructor(argument: StiUserFunctionArgument);
    }
}
export namespace Stimulsoft.Report.Web {
    class StiBlocklyInput {
        fields: StiBlocklyField[];
        getDefinitions(): string;
    }
}
export namespace Stimulsoft.Report.Web {
    class StiBlocklyDummyInput extends StiBlocklyInput {
        getDefinitions(): string;
    }
}
export namespace Stimulsoft.Report.Web {
    class StiBlocklyField {
        name: string;
        getDefinitions(): string;
    }
}
export namespace Stimulsoft.Report.Web {
    class StiBlocklyValueInput extends StiBlocklyInput {
        name: string;
        getDefinitions(): string;
    }
}
export namespace Stimulsoft.Report.Web {
    import StiFunction = Stimulsoft.Report.Dictionary.StiFunction;
    class StiFunctionBlocklyBlock extends StiBlocklyBlock {
        function: StiFunction;
        getTooltip(): string;
        constructor(func: StiFunction);
    }
}
export namespace Stimulsoft.Report.Web {
    import StiFunction = Stimulsoft.Report.Dictionary.StiFunction;
    class StiReturnUserFunctionBlock extends StiBlocklyBlock {
        getTooltip(func?: StiFunction): string;
        constructor();
    }
}
export namespace Stimulsoft.Report.Web {
    import StiUserFunction = Stimulsoft.Report.Dictionary.StiUserFunction;
    class StiUserFunctionBlocklyBlock extends StiBlocklyBlock {
        userFunction: StiUserFunction;
        getTooltip(): string;
        constructor(userFunction: StiUserFunction);
    }
}
export namespace Stimulsoft.Report.Web {
    import StiUserFunction = Stimulsoft.Report.Dictionary.StiUserFunction;
    class StiUserFunctionBlocksParser {
        static getFunctionsGrouppedInCategoriesBlocks(userFunction: StiUserFunction): string;
        static getInitFunctionBlocks(userFunction: StiUserFunction): string;
    }
}
export namespace Stimulsoft.Designer {
    import StiReportUnitType = Stimulsoft.Report.StiReportUnitType;
    import StiWebUIIconSet = Stimulsoft.Viewer.StiWebUIIconSet;
    class StiAppearanceOptions {
        private showOnlyAliasForVariable;
        private showPropertiesWhichUsedFromStyles;
        private showFileMenuHelp;
        private showOnlyAliasForComponents;
        private showOnlyAliasForPages;
        private showOnlyAliasForBusinessObject;
        private showOpenDialog;
        defaultUnit: StiReportUnitType;
        interfaceType: StiInterfaceType;
        showAnimation: boolean;
        showSaveDialog: boolean;
        showTooltips: boolean;
        showTooltipsHelp: boolean;
        showDialogsHelp: boolean;
        fullScreenMode: boolean;
        maximizeAfterCreating: boolean;
        private _showLocalization;
        get showLocalization(): boolean;
        set showLocalization(value: boolean);
        allowChangeWindowTitle: boolean;
        showPropertiesGrid: boolean;
        showReportTree: boolean;
        propertiesGridPosition: StiPropertiesGridPosition;
        showSystemFonts: boolean;
        datePickerFirstDayOfWeek: StiFirstDayOfWeek;
        undoMaxLevel: number;
        wizardTypeRunningAfterLoad: StiWizardType;
        allowWordWrapTextEditors: boolean;
        allowLoadingCustomFontsToClientSide: boolean;
        formatForDateControls: string;
        enableShortCutKeys: boolean;
        defaultRibbonType: StiDesignerRibbonType;
        private _zoom;
        get zoom(): number;
        set zoom(value: number);
        theme: StiDesignerTheme;
        iconSet: StiWebUIIconSet;
        addCustomAttribute: boolean;
        allowPropagationEvents: boolean;
    }
}
export namespace Stimulsoft.Designer {
    class StiBandsOptions {
        showReportTitleBand: boolean;
        showReportSummaryBand: boolean;
        showPageHeaderBand: boolean;
        showPageFooterBand: boolean;
        showGroupHeaderBand: boolean;
        showGroupFooterBand: boolean;
        showHeaderBand: boolean;
        showFooterBand: boolean;
        showColumnHeaderBand: boolean;
        showColumnFooterBand: boolean;
        showDataBand: boolean;
        showHierarchicalBand: boolean;
        showChildBand: boolean;
        showEmptyBand: boolean;
        showOverlayBand: boolean;
        showTable: boolean;
        showTableOfContents: boolean;
    }
}
export namespace Stimulsoft.Designer {
    class StiComponentsOptions {
        showText: boolean;
        showTextInCells: boolean;
        showRichText: boolean;
        showImage: boolean;
        showBarCode: boolean;
        showShape: boolean;
        showPanel: boolean;
        showClone: boolean;
        showCheckBox: boolean;
        showSubReport: boolean;
        showZipCode: boolean;
        showChart: boolean;
        showGauge: boolean;
        showSparkline: boolean;
        showMathFormula: boolean;
        showMap: boolean;
        showElectronicSignature: boolean;
        showPdfDigitalSignature: boolean;
        showHorizontalLinePrimitive: boolean;
        showVerticalLinePrimitive: boolean;
        showRectanglePrimitive: boolean;
        showRoundedRectanglePrimitive: boolean;
    }
}
export namespace Stimulsoft.Designer {
    class StiCrossBandsOptions {
        showCrossTab: boolean;
        showCrossGroupHeaderBand: boolean;
        showCrossGroupFooterBand: boolean;
        showCrossHeaderBand: boolean;
        showCrossFooterBand: boolean;
        showCrossDataBand: boolean;
    }
}
export namespace Stimulsoft.Designer {
    class StiDashboardElementsOptions {
        showTableElement: boolean;
        showCardsElement: boolean;
        showChartElement: boolean;
        showGaugeElement: boolean;
        showPivotTableElement: boolean;
        showIndicatorElement: boolean;
        showProgressElement: boolean;
        showRegionMapElement: boolean;
        showOnlineMapElement: boolean;
        showImageElement: boolean;
        showWebContentElement: boolean;
        showTextElement: boolean;
        showPanelElement: boolean;
        showShapeElement: boolean;
        showListBoxElement: boolean;
        showComboBoxElement: boolean;
        showTreeViewElement: boolean;
        showTreeViewBoxElement: boolean;
        showDatePickerElement: boolean;
        showButtonElement: boolean;
        showNumberBoxElement: boolean;
    }
}
export namespace Stimulsoft.Designer {
    class StiDictionaryOptions {
        showAdaptersInNewConnectionForm: boolean;
        showDictionary: boolean;
        useAliases: StiUseAliases;
        showDictionaryContextMenuProperties: boolean;
        showDictionaryActions: boolean;
        newReportDictionary: StiNewReportDictionary;
        dataSourcesPermissions: StiDesignerPermissions;
        dataTransformationsPermissions: StiDesignerPermissions;
        dataConnectionsPermissions: StiDesignerPermissions;
        dataColumnsPermissions: StiDesignerPermissions;
        dataRelationsPermissions: StiDesignerPermissions;
        businessObjectsPermissions: StiDesignerPermissions;
        variablesPermissions: StiDesignerPermissions;
        resourcesPermissions: StiDesignerPermissions;
    }
}
export namespace Stimulsoft.Designer {
    class StiToolbarOptions {
        private showLayoutButton;
        private showInsertButton;
        private showReportButton;
        private showPageButton;
        visible: boolean;
        showPreviewButton: boolean;
        showSaveButton: boolean;
        showAboutButton: boolean;
        showPublishButton: boolean;
        showFileMenu: boolean;
        showFileMenuNew: boolean;
        showFileMenuOpen: boolean;
        showFileMenuSave: boolean;
        showFileMenuSaveAs: boolean;
        showFileMenuClose: boolean;
        showFileMenuExit: boolean;
        showFileMenuReportSetup: boolean;
        showFileMenuOptions: boolean;
        showFileMenuInfo: boolean;
        showFileMenuAbout: boolean;
        showFileMenuNewReport: boolean;
        showFileMenuNewDashboard: boolean;
        showSetupToolboxButton: boolean;
        showNewPageButton: boolean;
        showNewDashboardButton: boolean;
    }
}
export namespace Stimulsoft.Designer {
    class StiAggregateFunctions {
        static getItems(): any[];
    }
}
export namespace Stimulsoft.Designer {
    import StiBarCode = Stimulsoft.Report.BarCodes.StiBarCode;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiBarCodeHelper {
        static getBarCodeJSObject(barCode: StiBarCode): any;
        static getBarCodeProperties(barCode: StiBarCode): any;
        static applyBarCodeProperty(report: StiReport, param: any, callbackResult: any): void;
    }
}
export namespace Stimulsoft.Designer {
    class StiCodePageHelper {
        static getDBaseCodePageItems(): any[];
        static getCsvCodePageItems(): any[];
    }
}
export namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiConditionDialogHelper {
        static openConditions(report: StiReport, param: any, callbackResult: any): void;
    }
}
export namespace Stimulsoft.Designer {
    class StiConditionsStylesHelper {
        static getPredefinedStylesItems(): any[];
    }
}
export namespace Stimulsoft.Designer {
    import StiCrossField = Stimulsoft.Report.CrossTab.StiCrossField;
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    class StiCrossTabHelper {
        private rowTotals;
        private colTotals;
        private sumHeaders;
        private createdTotals;
        private crossTab;
        private columnsContainer;
        private rowsContainer;
        private summaryContainer;
        private selectedDataSource;
        private selectedBusinessObject;
        private oldLeft;
        private oldTop;
        restorePositions(): void;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private getContainerByName;
        getCrossTabResult(): any[];
        getCrossFieldJSProperies(crossField: StiCrossField): any;
        getFieldsPropertiesForJS(): any;
        static getColorStyles(): any[];
        private updateCrossTab;
        private createRowTotal;
        private createColTotal;
        private swapColumnsAndRows;
        private changeSummaryDirection;
        private copySummaryToRow;
        private copySummaryToColumn;
        private copyHeaderToSummary;
        private copyRowToColumn;
        private copyColumnToRow;
        private copyRowTotalToColumnTotal;
        private copyColumnTotalToRowTotal;
        private copyFieldToField;
        private convertColumnTotal;
        private convertRowTotal;
        private killRightTitle;
        private orderRows;
        constructor(crossTab: StiCrossTab);
    }
}
export namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiCultureHelper {
        static getItems(): any[];
        private static getHashtableObjectForJs;
        private static getGlobalizationContainerObject;
        static getReportGlobalizationStrings(report: StiReport): any[];
        static addReportGlobalizationStrings(report: StiReport, param: any, callbackResult: any): void;
        static editGlobalizationStrings(report: StiReport, param: any, callbackResult: any): void;
        static removeReportGlobalizationStrings(report: StiReport, param: any, callbackResult: any): void;
        static getCultureSettingsFromReport(report: StiReport, param: any, callbackResult: any): void;
        static setCultureSettingsToReport(report: StiReport, param: any, callbackResult: any): void;
        static applyGlobalizationStrings(report: StiReport, param: any, callbackResult: any): void;
        static removeUnlocalizedGlobalizationStrings(report: StiReport, param: any, callbackResult: any): void;
    }
}
export namespace Stimulsoft.Designer {
    import StiDataTransformationColumn = Stimulsoft.Report.Dictionary.StiDataTransformationColumn;
    import StiDictionary = Stimulsoft.Report.Dictionary.StiDictionary;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiDataTransformation = Stimulsoft.Report.Dictionary.StiDataTransformation;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDataTransformationHelper {
        static columnItem(column: StiDataTransformationColumn, dictionary?: StiDictionary, originalType?: string): {
            [key: string]: string | boolean | string[];
        };
        private static actionRuleItem;
        private static getFuncs;
        static createTransformationColumnFromDataColumn(dataColumn: StiDataColumn): StiDataTransformationColumn;
        private static toSumExpression;
        private static toExpression;
        static getColumnFromJSColumnObject(columnObject: any): StiDataTransformationColumn;
        static getSortRuleFromJSSortRuleObject(sortRuleObject: any): StiDataSortRule;
        static getFilterRuleFromJSFilterRuleObject(filterRuleObject: any): StiDataFilterRule;
        static getActionRuleFromJSActionRuleObject(actionRuleObject: any): StiDataActionRule;
        static getViewQueryContent(report: StiReport, param: any, callbackResult: any): Promise<void>;
        private static getDataTableContent;
        private static processRowValue;
        private static getDataValue;
        private static getSortLabels;
        private static getFilterLabels;
        private static isValueCanBeFiltered;
        static getColumns(dataTransformation: StiDataTransformation): {
            [key: string]: string | boolean | string[];
        }[];
        static getSortRules(dataTransformation: StiDataTransformation): {
            [key: string]: string;
        }[];
        static getFilterRules(dataTransformation: StiDataTransformation): any[];
        static getActionRules(dataTransformation: StiDataTransformation): {
            [key: string]: string | number | boolean;
        }[];
        static applyProperties(dataTransformation: StiDataTransformation, dataSourceProps: any, report: StiReport): void;
        static getDataGridContent(dataTransformation?: StiDataTransformation): Promise<{
            [key: string]: string | {
                [key: string]: string | number;
            }[] | (string | {
                [key: string]: string;
            })[][];
        }>;
        static getFilterItemsHelper2(dataTransformation: StiDataTransformation, parameters: any): any;
        static getFilterItemsHelper(report: StiReport, parameters: any): any;
        static executeJSCommand(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): Promise<void>;
        static getDataTransformationFromElement(report: StiReport, param: any): Promise<StiDataTransformation>;
    }
}
export namespace Stimulsoft.Designer {
    class StiDefaultConditions {
        static getItems(): {
            [key: string]: {
                [key: string]: string | boolean | {
                    [key: string]: string;
                };
            };
        };
    }
}
export namespace Stimulsoft.Designer {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDesignReportHelper {
        private report;
        private currentCulture;
        getReportJsObject(): any;
        getPages(): any[];
        getPage(page: StiPage): any;
        private getComponents;
        private getComponent;
        private getReportInfo;
        static applyParamsToReport(report: StiReport, designer: StiDesigner): void;
        static checkAndCorrectDuplicatePageNames(report: StiReport): void;
        static checkEvalEvents(report: StiReport, designer: StiDesigner, callback: (result: boolean) => void): void;
        constructor(report: StiReport);
    }
}
export namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDesignerOptionsHelper {
        static getDefaultDesignerOptions(): {
            [key: string]: string | boolean;
        };
        static getDesignerOptions(designer: StiDesigner): any;
        static applyDesignerOptionsToReport(designerOptions: any, report: StiReport): void;
    }
}
export namespace Stimulsoft.Designer {
    class StiEmptyObject {
    }
}
export namespace Stimulsoft.Designer {
    class StiFontNames {
        static getItems(): {
            key: string;
            value: string;
        }[];
    }
}
export namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiResource = Stimulsoft.Report.Dictionary.StiResource;
    import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
    class StiFontResourceHelper {
        static addFontToReport(report: StiReport, resource: StiResource, resourceItem: any): void;
        static getBase64DataForCssFromResourceContent(resourceType: StiResourceType, content: number[]): string;
        private static getFontFamily;
    }
}
export namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiVariable = Stimulsoft.Report.Dictionary.StiVariable;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiResource = Stimulsoft.Report.Dictionary.StiResource;
    class StiGalleriesHelper {
        static getImageColumns(report: StiReport): StiDataColumn[];
        static getImageVariables(report: StiReport): StiVariable[];
        static getImageResources(report: StiReport): StiResource[];
        static getRichTextColumns(report: StiReport): StiDataColumn[];
        static getRichTextVariables(report: StiReport): StiVariable[];
        static getRichTextResources(report: StiReport): StiResource[];
        static getImageFromColumn(column: StiDataColumn, report: StiReport): Image;
        static isRtfColumn(column: StiDataColumn, report: StiReport): boolean;
        static getRichTextAsHtmlFromColumn(column: StiDataColumn, report: StiReport): string;
        static getHtmlTextFromText(text: string): string;
        static getHtmlStringFromRichTextItem(report: StiReport, itemObject: any): string;
        private static getResource;
        private static getVariable;
    }
}
export namespace Stimulsoft.Designer {
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiGaugeHelper {
        static getGaugeProperties(gauge: StiGauge): any;
        static setGaugeProperties(report: StiReport, param: any, callbackResult: any): void;
        private static getIndicatorColumn;
        private static setIndicatorColumn;
        static getStyle(gauge: StiGauge): {
            [key: string]: string;
        };
        private static getGaugeStyles;
        static getGaugeSampleImage(gauge: StiGauge, width: number, height: number, zoom: number): string;
        static setGaugeStyle(report: StiReport, param: any, callbackResult: any): void;
        static getStylesContent(report: StiReport, param: any, callbackResult: any, forStylesControl: boolean, withReportStyles?: boolean): void;
    }
}
export namespace Stimulsoft.Designer {
    class StiGoogleAccountHelper {
        private static tokenRequestURI;
        private static clientID;
        private static clientSecret;
        private static redirectUrl;
        static googleAuthorizationProcess(parameters: any, jsObject: any): void;
        private static exchangeCodeAtToken;
    }
}
export namespace Stimulsoft.Designer {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiGroup extends StiContainer {
        toString2(application: string): string;
        static createFromString(text: string, application: string): StiGroup;
        static getSelectedComponents(isSelectedFinded: boolean, level: number, cont: StiContainer, allComps: StiComponentsCollection, lists: Hashtable): StiComponentsCollection;
        static getGroupFromPage(page: StiPage): StiGroup;
        private static resetSelection;
        private static getAllComps;
        insertIntoPage(page: StiPage): StiComponentsCollection;
        constructor();
    }
}
export namespace Stimulsoft.Designer {
    class StiHatchStyles {
        private static item;
        static getItems(): {
            key: string;
            value: string;
        }[];
    }
}
export namespace Stimulsoft.Designer {
    class StiIconSetArrays {
        static getItems(): {
            [key: string]: string[];
        };
    }
}
export namespace Stimulsoft.Designer {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiInsertionComponents {
        static insertGroups(currentPage: StiPage, group: StiGroup): void;
        static insertComponents(currentPage: StiPage, comps: StiComponentsCollection, alignToGrid?: boolean): void;
        static insert(currentPage: StiPage, alignToGrid?: boolean): void;
    }
}
export namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiMap = Stimulsoft.Report.Maps.StiMap;
    class StiMapHelper {
        static getMapProperties(map: StiMap): any;
        static getMapLanguages(mapIdent: string): any[];
        static setMapProperties(report: StiReport, param: any, callbackResult: any): void;
        static updateMapData(report: StiReport, param: any, callbackResult: any): void;
        static getMapDataForJS(map: StiMap): any[];
        private static allowGroup;
        private static allowColor;
        static getStyle(map: StiMap): any;
        private static getMapStyles;
        static getMapSampleImage(map: StiMap, width: number, height: number, zoom: number): string;
        static setMapStyle(report: StiReport, param: any, callbackResult: any): void;
        static getStylesContent(report: StiReport, param: any, callbackResult: any, withReportStyles?: boolean): void;
        static getMaps3DIdents(): {
            [key: string]: boolean;
        };
    }
}
export namespace Stimulsoft.Designer {
    class StiPaperSizes {
        static getItems(): string[];
    }
}
export namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiPreviewHelper {
        static getPages(report: StiReport, pageNumber: number, zoom: number, designerId: string): any[];
        private static renderReportPage;
        private static renderPageParameters;
    }
}
export namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiQuickBooksHelper {
        private static stimulsoftClientId;
        private static stimulsoftClientSecret;
        private static oauth2Url;
        private static bearerUrl;
        private static responseType;
        private static scope;
        private static stimulsoftRedirectUrl;
        static getAuthorizationUrl(report: StiReport, param: any, callbackResult: any): void;
        static getTokens(report: StiReport, param: any, callbackResult: any): void;
        static refreshTokens(report: StiReport, param: any, callbackResult: any): void;
    }
}
export namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiReportCheckHelper {
        private static checkItem;
        private static checkActionItem;
        private static getActions;
        private static getChecksJSCollection;
        private static updateCurrentReport;
        private static createImage;
        private static getErrorsCount;
        private static buildReportRenderingMessages;
        static checkReport(designer: StiDesigner, report: StiReport, parameters: any, callbackResult: any, callbackFunc: any): void;
        static getCheckPreview(designer: StiDesigner, report: StiReport, parameters: any, callbackResult: any): void;
        static actionCheck(designer: StiDesigner, report: StiReport, parameters: any, callbackResult: any): void;
        static checkExpression(report: StiReport, parameters: any, callbackResult: any): void;
        static parseExpressionText(report: StiReport, parameters: any, callbackResult: any): void;
    }
}
export namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiReportTreeHelper {
        static moveReportTreeItem(report: StiReport, param: any, callbackResult: any): void;
    }
}
export namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
    class StiResourcesHelper {
        static getReportThumbnailParametersAsync(report: StiReport, zoom: number): Promise<string>;
        static getHtmlColor(color: Color): string;
        static isPackedFile(content: number[]): boolean;
        static getStringContentForJSFromResourceContentAsync(resourceType: StiResourceType, content: number[]): Promise<string>;
        static getResourceContentAsync(report: StiReport, param: any, callbackResult: any): Promise<void>;
        static getResourceText(report: StiReport, param: any, callbackResult: any): void;
        static setResourceText(report: StiReport, param: any, callbackResult: any): void;
        static getResourceViewData(report: StiReport, param: any, callbackResult: any): void;
        static isFontResourceType(resourceType: StiResourceType): boolean;
        static downloadResource(report: StiReport, resourceName: string): void;
        static downloadImageContent(report: StiReport, imageData: string): void;
        static moveImageToResource(report: StiReport, param: any, callbackResult: any): void;
        private static getResourceFileExt;
        private static getImageExt;
        static getCursorPenBase64(): string;
        static getCursorStyleSetBase64(): string;
    }
}
export namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiShape = Stimulsoft.Report.Components.StiShape;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiShapeHelper {
        static getShapeJSObject(shape: StiShape): {
            [key: string]: string | {
                [key: string]: string;
            } | StiPromise<string>;
        };
        private static getShapeProperties;
        static applyShapeProperty(report: StiReport, param: any, callbackResult: any): void;
    }
}
export namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiSparkline = Stimulsoft.Report.Components.StiSparkline;
    class StiSparklineHelper {
        static getSparklineProperties(sparkline: StiSparkline): any;
        static updateSparkline(report: StiReport, param: any, callbackResult: any): void;
        private static setPropertyValue;
        private static getSparklineSampleImage;
        static getStylesContent(report: StiReport, param: any, callbackResult: any): void;
    }
}
export namespace Stimulsoft.Designer {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiStyleConditionsCollection = Stimulsoft.Report.Styles.Conditions.StiStyleConditionsCollection;
    import StiStyleCondition = Stimulsoft.Report.Styles.Conditions.StiStyleCondition;
    import StiStylesCollection = Stimulsoft.Report.Styles.StiStylesCollection;
    class StiStylesHelper {
        private static getStyleProperties;
        static styleItem(style: StiBaseStyle): any;
        static setConditionTypeProperty(styleCondition: StiStyleCondition, propertyValue: string): void;
        static setLocationProperty(styleCondition: StiStyleCondition, propertyValue: string): void;
        static setComponentTypeProperty(styleCondition: StiStyleCondition, propertyValue: string): void;
        static setPlacementProperty(styleCondition: StiStyleCondition, propertyValue: string): void;
        static setStyleConditionsProprty(style: StiBaseStyle, conditions: any[]): void;
        static getStyleConditionsProprty(conditions: StiStyleConditionsCollection): any[];
        static getStyles(report: StiReport): any[];
        static generateNewName(styles: StiStylesCollection, newStyle: StiBaseStyle): void;
        static applyStyleProperties(style: StiBaseStyle, properties: any): void;
        static writeStylesToReport(report: StiReport, stylesCollection: any[]): void;
        private static changeStyleNameInReport;
        static updateStyles(report: StiReport, param: any, callbackResult: any): void;
        static addStyle(report: StiReport, param: any, callbackResult: any): void;
        private static cloneColors;
        static createStyleCollection(report: StiReport, param: any, callbackResult: any): void;
        static createStylesCollectionFromBaseColor(baseColor: Color, name: string): StiStylesCollection;
        static createStylesFromComponents(report: StiReport, param: any, callbackResult: any): void;
        static openStyle(report: StiReport, param: any, callbackResult: any): void;
        static getStylesContentByType(report: StiReport, param: any, callbackResult: any): Promise<void>;
        private static parseElementStyleIdent;
        private static getBaseStyle;
        static createStyleBasedAnotherStyle(report: StiReport, param: any, callbackResult: any): void;
        private static generateStyle;
    }
}
export namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiTable = Stimulsoft.Report.Components.Table.StiTable;
    class StiTableHelper {
        private table;
        private zoom;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private getFirstIndexX;
        private getLastIndexX;
        private getFirstIndexY;
        private getLastIndexY;
        private joinCells;
        private unJoinCells;
        private setSelectedCurrentCells;
        private getSelectedCellNames;
        private getSelectedCellsByNames;
        static getTableStyles(report: StiReport, withReportStyles?: boolean): any[];
        static getTableCellsProperties(table: StiTable, zoom: number): any[];
        private getTableCellsForJS;
        private convertTableCell;
        constructor(table: StiTable, zoom: number);
    }
}
export namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiTableOfContentsHelper {
        private static getIdents;
        static getIdentsCollection(report: StiReport, param: any, callbackResult: any): void;
        static updateComponentsPointerValues(report: StiReport, param: any, callbackResult: any): void;
    }
}
export namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiGeneralFormatService = Stimulsoft.Report.Components.TextFormats.StiGeneralFormatService;
    import StiNumberFormatService = Stimulsoft.Report.Components.TextFormats.StiNumberFormatService;
    import StiCurrencyFormatService = Stimulsoft.Report.Components.TextFormats.StiCurrencyFormatService;
    import StiDateFormatService = Stimulsoft.Report.Components.TextFormats.StiDateFormatService;
    import StiTimeFormatService = Stimulsoft.Report.Components.TextFormats.StiTimeFormatService;
    import StiPercentageFormatService = Stimulsoft.Report.Components.TextFormats.StiPercentageFormatService;
    import StiBooleanFormatService = Stimulsoft.Report.Components.TextFormats.StiBooleanFormatService;
    import StiCustomFormatService = Stimulsoft.Report.Components.TextFormats.StiCustomFormatService;
    class StiTextFormatHelper {
        private static storedCulture;
        static commonTextFormatItem(service: StiFormatService): any;
        static generalTextFormatItem(service: StiGeneralFormatService): any;
        static numberTextFormatItem(service: StiNumberFormatService): any;
        static currencyTextFormatItem(service: StiCurrencyFormatService): any;
        static dateTextFormatItem(service: StiDateFormatService): any;
        static timeTextFormatItem(service: StiTimeFormatService): any;
        static percentageTextFormatItem(service: StiPercentageFormatService): any;
        static booleanTextFormatItem(service: StiBooleanFormatService): any;
        static customTextFormatItem(service: StiCustomFormatService): any;
        private static getStateProperty;
        static getCurrencySymbols(): string[];
        static getFormatService(properties: any): StiFormatService;
        static getTextFormatItem(service: StiFormatService): any;
        static getDateAndTimeFormats(category: string, service: StiFormatService): any[];
        static getTextFormatItems(): any;
        static updateTextFormatItemsByReportCulture(report: StiReport, param: any, callbackResult: any): void;
        static updateSampleTextFormat(report: StiReport, param: any, callbackResult: any): void;
    }
}
export namespace Stimulsoft.Designer {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiViewDataHelper {
        constructor(dataSource: StiDataSource, businessObject?: StiBusinessObject);
        private isDataSourceConnected;
        private dataSource;
        private businessObject;
        resultDataTable: DataTable;
        private fillLevel2;
        private fillLevel4;
        private connectDataSourceFirstTimeAsync;
        buildAsync(): StiPromise<void>;
        private buildBusinessObject;
        private buildDataSourceAsync;
    }
}
export namespace Stimulsoft.Designer {
    import IStiDesignerBase = Stimulsoft.Report.Design.IStiDesignerBase;
    class StiWebDesignerBase implements IStiDesignerBase {
        useAliases: boolean;
    }
}
export namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiWizardHelper {
        private static getGroupsFromDataSource;
        private static getColumnsFromDataSource;
        private static getSortFromDataSource;
        private static getFiltersFromDataSource;
        private static getTotalsFromDataSource;
        private static alignToMaxGrid;
        private static alignToGrid;
        static getReportFromWizardOptions(createdReport: StiReport, reportOptions: any, wizardDataSources: any): StiReport;
        static prepareReportBeforeGetData(report: StiReport, param: any, callbackResult: any, designer: StiDesigner): StiReport;
        static changeReportType(report: StiReport, param: any, callbackResult: any, designer: StiDesigner): void;
        static restoreOldReport(report: StiReport, param: any, callbackResult: any, designer: StiDesigner): void;
        static addJsonDemoDataToReport(report: StiReport, param: any, callbackResult: any, designer: StiDesigner): void;
        static addXmlDemoDataToReport(report: StiReport, param: any, callbackResult: any, designer: StiDesigner): void;
        static addDemoDataToReport(report: StiReport, param: any, callbackResult: any, designer: StiDesigner): void;
        private static getJsonDemoDataResource;
        private static getDemoXMLResource;
        private static getDemoXSDResource;
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiSparkline = Stimulsoft.Report.Components.StiSparkline;
    import StiReport = Stimulsoft.Report.StiReport;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiDashboard = Stimulsoft.Report.Dashboard.IStiDashboard;
    import IStiCardsElement = Stimulsoft.Report.Dashboard.IStiCardsElement;
    class StiCardsElementHelper {
        private cardsElement;
        private getMeterItem;
        private getMetersItems;
        static getMeterFunctions(meter: IStiMeter, dashboard: IStiDashboard): string[];
        private getCardsElementJSProperties;
        static getMeterLabel(meter: IStiMeter): string;
        private static getSparklinesType;
        static getMeterType(meter: IStiMeter): string;
        static getMeterTypeIcon(meter: IStiMeter): string;
        private static checkMeasureMeterTextFormat;
        private static checkMeterTextFormatForPercentOfGrandTotal;
        private static getCardsTitleByTypeAndNameOfObject;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private insertMeters;
        private removeMeter;
        private renameMeter;
        private removeAllMeters;
        private convertMeter;
        private moveMeter;
        private newMeter;
        private duplicateMeter;
        private setFunction;
        private switchToPercentOfGrandTotal;
        private changeSparklinesType;
        private setPropertyValue;
        static createCardsElementFromDictionary(report: StiReport, param: any, callbackResult: any): void;
        private static getCardsElementStyles;
        static getStyleSampleImage(cardsElement: IStiCardsElement, sparkLine: StiSparkline, style: StiBaseStyle, width: number, height: number): string;
        static getStylesContent(report: StiReport, param: any, withReportStyles?: boolean): any[];
        constructor(cardsElement: IStiCardsElement);
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import IStiComboBoxElement = Stimulsoft.Report.Dashboard.IStiComboBoxElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiComboBoxElementHelper {
        private comboBoxElement;
        private getComboBoxElementJSProperties;
        private getMeterHashItem;
        getMetersHash(): {
            [key: string]: {
                [key: string]: string;
            };
        };
        executeJSCommand(parameters: any, callbackResult: any): Promise<void>;
        private moveMeter;
        private createNewItem;
        private editField;
        private renameMeter;
        private setDataColumn;
        private setPropertyValue;
        static createComboBoxElementFromDictionary(report: StiReport, param: any, callbackResult: any): void;
        constructor(comboBoxElement: IStiComboBoxElement);
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import IStiGaugeElement = Stimulsoft.Report.Dashboard.IStiGaugeElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiGaugeElementHelper {
        private gaugeElement;
        private getGaugeElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        private getGaugeRanges;
        private getGaugeRangeItem;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private getMeterByContainerName;
        private moveMeter;
        private setExpression;
        private renameMeter;
        private setFunction;
        private createNewItem;
        private setDataColumn;
        private setValueToManuallyEnteredData;
        private setPropertyValue;
        private setPropertyValueToGaugeRange;
        private addGaugeRange;
        private removeGaugeRange;
        private static getGaugeElementStyles;
        static getStylesContent(report: StiReport, param: any, withReportStyles?: boolean): Promise<{
            [key: string]: string | number;
        }[]>;
        constructor(gaugeElement: IStiGaugeElement);
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import IStiRegionMapElement = Stimulsoft.Report.Dashboard.IStiRegionMapElement;
    import StiMap = Stimulsoft.Report.Maps.StiMap;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiRegionMapElementHelper {
        private regionMapElement;
        private getRegionMapElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        static getMapDataForJS(regionMapElement: IStiRegionMapElement): {
            [key: string]: string;
        }[];
        private static allowGroup;
        private static allowColor;
        private getMeterByContainerName;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private setExpression;
        private renameMeter;
        private createNewItem;
        private setFunction;
        private setDataColumn;
        private moveMeter;
        private setProperties;
        private updateMapData;
        static createMapComponentFromRegionMapElement(regionMapElement: IStiRegionMapElement): StiMap;
        private static getRegionMapStyles;
        static getStylesContent(report: StiReport, param: any, withReportStyles?: boolean): {
            [key: string]: string | number;
        }[];
        constructor(regionMapElement: IStiRegionMapElement);
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDashboardHelper {
        static addDashboard(report: StiReport, param: any, callbackResult: any): void;
        static getDashboardGridLinesColor(page: StiPage): Color;
        static getDashboardGridDotsColor(page: StiPage): Color;
        static getSelectionBorderColor(page: StiPage): Color;
        static getSelectionCornerColor(page: StiPage): Color;
        static getDashboardBackColor(page: StiPage): Color;
        static createDashboardElement(report: StiReport, typeComponent: string): StiComponent;
        static getDashboardStyles(report: StiReport, param: any, withReportStyles?: boolean): Promise<any[]>;
        static getDashboardStyleSampleImage(element: IStiElement, width: number, height: number): Promise<string>;
        static changeDashboardStyle(report: StiReport, param: any, callbackResult: any): void;
        static changeDashboardViewMode(report: StiReport, param: any, callbackResult: any): void;
        static getMobileViewUnplacedElements(report: StiReport, param: any, callbackResult: any): void;
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiElementDataFiltersHelper {
        private currentCulture;
        private element;
        private get dataFilterElement();
        private get userFilterElement();
        private getElementDataFiltersJSProperties;
        private getDataFilterType;
        private getFilters;
        private getDataValuesFromDataPath;
        executeJSCommand(parameters: any, callbackResult: any): Promise<void>;
        private getCurrentOperation;
        private createNewItem;
        private editField;
        private moveFilter;
        private removeFilter;
        private insertFilters;
        private setPropertyValue;
        constructor(element: IStiElement);
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import IStiImageElement = Stimulsoft.Report.Dashboard.IStiImageElement;
    class StiImageElementHelper {
        private imageElement;
        private getImageElementJSProperties;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private setPropertyValue;
        constructor(imageElement: IStiImageElement);
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import IStiListBoxElement = Stimulsoft.Report.Dashboard.IStiListBoxElement;
    class StiListBoxElementHelper {
        private listBoxElement;
        private getListBoxElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        executeJSCommand(parameters: any, callbackResult: any): Promise<void>;
        private moveMeter;
        private createNewItem;
        private editField;
        private renameMeter;
        private setDataColumn;
        private setPropertyValue;
        constructor(listBoxElement: IStiListBoxElement);
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import IStiPivotTableElement = Stimulsoft.Report.Dashboard.IStiPivotTableElement;
    class StiPivotTableElementHelper {
        private pivotTableElement;
        private getPivotTableElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private setPropertyValue;
        private getMeterFromContainer;
        private setExpression;
        private setTopN;
        private renameMeter;
        private setFunction;
        private removeAllMeters;
        private removeMeter;
        private moveMeter;
        private duplicateMeter;
        private insertMeters;
        private createNewItem;
        private swapColumnsRows;
        private swapSummaryDirection;
        constructor(pivotTableElement: IStiPivotTableElement);
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiShapeElement = Stimulsoft.Report.Dashboard.IStiShapeElement;
    class StiShapeElementHelper {
        private shapeElement;
        static createShapeElement(componentTypeArray: string): StiComponent;
        static setShapeTypeProperty(comp: IStiShapeElement, propValue: any): void;
        static getShapeTypeProperty(comp: IStiShapeElement): string;
        private getShapeElementJSProperties;
        private setPropertyValue;
        executeJSCommand(parameters: any, callbackResult: any): void;
        constructor(shapeElement: IStiShapeElement);
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTableElement = Stimulsoft.Report.Dashboard.IStiTableElement;
    import IStiDashboard = Stimulsoft.Report.Dashboard.IStiDashboard;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiTableElementHelper {
        private tableElement;
        private getMeterItem;
        private getMetersItems;
        static getMeterFunctions(meter: IStiMeter, dashboard: IStiDashboard): string[];
        private getTableElementJSProperties;
        static getMeterLabel(meter: IStiMeter): string;
        private static getSparklinesType;
        static getMeterType(meter: IStiMeter): string;
        static getMeterTypeIcon(meter: IStiMeter): string;
        private static checkMeasureMeterTextFormat;
        private static checkMeterTextFormatForPercentOfGrandTotal;
        private static getTableTitleByTypeAndNameOfObject;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private insertMeters;
        private removeMeter;
        private renameMeter;
        private removeAllMeters;
        private convertMeter;
        private moveMeter;
        private newMeter;
        private duplicateMeter;
        private setFunction;
        private switchToPercentOfGrandTotal;
        private changeSparklinesType;
        private setPropertyValue;
        static createTableElementFromDictionary(report: StiReport, param: any, callbackResult: any): void;
        constructor(tableElement: IStiTableElement);
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import IStiTreeViewBoxElement = Stimulsoft.Report.Dashboard.IStiTreeViewBoxElement;
    class StiTreeViewBoxElementHelper {
        private treeViewBoxElement;
        private getTreeViewBoxElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private removeAllMeters;
        private createNewItem;
        private editField;
        private insertMeters;
        private removeMeter;
        private renameMeter;
        private moveMeter;
        private duplicateMeter;
        private setPropertyValue;
        constructor(treeViewBoxElement: IStiTreeViewBoxElement);
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import IStiTreeViewElement = Stimulsoft.Report.Dashboard.IStiTreeViewElement;
    class StiTreeViewElementHelper {
        private treeViewElement;
        private getTreeViewElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private removeAllMeters;
        private insertMeters;
        private createNewItem;
        private editField;
        private removeMeter;
        private renameMeter;
        private moveMeter;
        private duplicateMeter;
        private setPropertyValue;
        constructor(treeViewElement: IStiTreeViewElement);
    }
}
export namespace Stimulsoft.Designer.Dashboards {
    import IStiWebContentElement = Stimulsoft.Report.Dashboard.IStiWebContentElement;
    class StiWebContentElementHelper {
        private webContentElement;
        private getWebContentElementJSProperties;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private setPropertyValue;
        constructor(webContentElement: IStiWebContentElement);
    }
}
