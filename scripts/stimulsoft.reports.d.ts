/*
Stimulsoft.Reports.JS
Version: 2021.3.5
Build date: 2021.07.09
License: https://www.stimulsoft.com/en/licensing/reports
*/
declare namespace Stimulsoft.System {
    class Activator {
        static createInstance(type: Type): any;
    }
}
declare namespace Stimulsoft.System {
    class Attribute {
    }
}
declare namespace Stimulsoft.System {
    class Base64 {
        private static keyStr;
        static encode(input: string): string;
        static decode(input: string): any;
        private static utf8_encode;
        private static utf8_decode;
    }
}
declare namespace Stimulsoft.System.Globalization {
    enum UnicodeCategory {
        UppercaseLetter = 0,
        LowercaseLetter = 1,
        TitlecaseLetter = 2,
        ModifierLetter = 3,
        OtherLetter = 4,
        NonSpacingMark = 5,
        SpacingCombiningMark = 6,
        EnclosingMark = 7,
        DecimalDigitNumber = 8,
        LetterNumber = 9,
        OtherNumber = 10,
        SpaceSeparator = 11,
        LineSeparator = 12,
        ParagraphSeparator = 13,
        Control = 14,
        Format = 15,
        Surrogate = 16,
        PrivateUse = 17,
        ConnectorPunctuation = 18,
        DashPunctuation = 19,
        OpenPunctuation = 20,
        ClosePunctuation = 21,
        InitialQuotePunctuation = 22,
        FinalQuotePunctuation = 23,
        OtherPunctuation = 24,
        MathSymbol = 25,
        CurrencySymbol = 26,
        ModifierSymbol = 27,
        OtherSymbol = 28,
        OtherNotAssigned = 29
    }
}
declare namespace Stimulsoft.System {
    class Char {
        static isUpper(char: string, index?: number): boolean;
        static isLower(char: string, index?: number): boolean;
        static isLetter(char: string, index?: number): boolean;
        static isDigit(char: string | number, index?: number): boolean;
        static isLetterOrDigit(char: string, index?: number): boolean;
        static toLower(char: string): string;
        static toUpper(char: string): string;
        static isWhitespace(char: string, index?: number, allowNbsp?: boolean): boolean;
        private static checkLetter;
        static getUnicodeCategory(char: string, index?: number): number;
        static isControl(char: string, index?: number): boolean;
    }
}
declare namespace Stimulsoft.System {
    class Chars {
        static getUnicodeCategory(char: number): number;
        private static _table_0;
        private static _table_9fc0;
        private static _table_d780;
        private static _table_fa40;
    }
}
declare namespace Stimulsoft.System {
    class Convert {
        private static keyStr;
        static changeType(value: any, type: Type): any;
        static changeType2(value: any, typeCode: TypeCode): any;
        static toDateTime(value: any): DateTime;
        static toString(value: any): string;
        static toFont(value: string): Stimulsoft.System.Drawing.Font;
        static toBoolean(value: any): boolean;
        static toNumber(value: any): number;
        static toDouble(value: any): number;
        static toInt32(value: any, radix?: number): number;
        static toInt64(value: any): number;
        static toUInt64(value: any): number;
        static toUInt32(value: any): number;
        static toBase64String(input: string | number[] | Uint8Array): string;
        static fromBase64String(input: string): number[];
        static fromBase64StringText(input: string): string;
        static fromUTF16LE(input: string | number[] | Uint8Array): number[];
        static isUTF16LE(input: string | number[] | Uint8Array): boolean;
    }
}
declare let __require__: any;
declare namespace Stimulsoft.System {
    class NodeJs {
        private static isInitialize;
        static initialize(onResult?: Function): void;
        private static convertAsync;
        static platform(): any;
        static callRemoteApi(command: any, timeout: number): StiPromise<string>;
        private static applyQueryParameters;
        private static processFirebird;
        private static processMsSql;
        private static processMySql;
        private static processPostgreSQL;
        static stripBom(data: any): any;
        static getFile(filePath: string, binary?: boolean, contentType?: string, headers?: {
            key: string;
            value: string;
        }[]): any;
        static getFileHttp(filePath: string, binary?: boolean, contentType?: string, headers?: {
            key: string;
            value: string;
        }[]): any;
        static saveAs(data: any, fileName: string, type?: string): any;
        static saveFile(filePath: string, fileData: string): void;
        static getFilesNames(filesPath: string): string[];
        static getSep(): string;
        private static fromBase64String;
        private static fromBase64StringText;
        private static toBase64String;
        private static fromUnicodeString;
        private static _isNodeJs;
        static isNodeJs(): boolean;
        static isBuffer(data: any): boolean;
        static isStandaloneVersion: boolean;
        static useWebKit: boolean;
        static consoleLog: boolean;
        private static fillInfo;
        static localizationPath: string;
        private static getLocalizationInfo;
        private static getSetting;
        private static setSetting;
    }
}
declare namespace Stimulsoft.System.Globalization {
    class TextInfo {
        listSeparator: string;
        toTitleCase(str: string): string;
        constructor(listSeparator?: string);
    }
}
declare namespace Stimulsoft.System.Globalization {
    import IFormatProvider = Stimulsoft.System.IFormatProvider;
    import Type = Stimulsoft.System.Type;
    class NumberFormatInfo implements IFormatProvider {
        numberDecimalSeparator: string;
        numberDecimalDigits: number;
        numberGroupSeparator: string;
        numberGroupSizes: number[];
        numberNegativePattern: number;
        currencyDecimalDigits: number;
        currencyDecimalSeparator: string;
        currencyGroupSeparator: string;
        currencyGroupSizes: number[];
        currencyNegativePattern: number;
        currencyPositivePattern: number;
        currencySymbol: string;
        percentDecimalDigits: number;
        percentDecimalSeparator: string;
        percentGroupSeparator: string;
        percentGroupSizes: number[];
        percentNegativePattern: number;
        percentPositivePattern: number;
        percentSymbol: string;
        perMilleSymbol: string;
        positiveInfinitySymbol: string;
        positiveSign: string;
        NaNSymbol: string;
        negativeInfinitySymbol: string;
        negativeSign: string;
        getFormat(formatType: Type): any;
        constructor(numberDecimalSeparator?: string, numberDecimalDigits?: number, numberGroupSeparator?: string, numberGroupSizes?: number[], numberNegativePattern?: number, currencyDecimalDigits?: number, currencyDecimalSeparator?: string, currencyGroupSeparator?: string, currencyGroupSizes?: number[], currencyNegativePattern?: number, currencyPositivePattern?: number, currencySymbol?: string, percentDecimalDigits?: number, percentDecimalSeparator?: string, percentGroupSeparator?: string, percentGroupSizes?: number[], percentNegativePattern?: number, percentPositivePattern?: number, percentSymbol?: string, perMilleSymbol?: string, positiveInfinitySymbol?: string, positiveSign?: string, NaNSymbol?: string, negativeInfinitySymbol?: string, negativeSign?: string);
    }
}
declare namespace Stimulsoft.System.Globalization {
    class DateTimeFormatInfo {
        shortDatePattern: string;
        dateSeparator: string;
        longDatePattern: string;
        dayNames: string[];
        monthNames: string[];
        shortestDayNames: string[];
        abbreviatedMonthNames: string[];
        monthGenitiveNames: string[];
        timeSeparator: string;
        AMDesignator: string;
        PMDesignator: string;
        fullDateTimePattern: string;
        shortTimePattern: string;
        longTimePattern: string;
        yearMonthPattern: string;
        constructor(shortDatePattern: string, dateSeparator: string, longDatePattern: string, dayNames: string[], monthNames: string[], shortestDayNames: string[], abbreviatedMonthNames: string[], monthGenitiveNames: string[], timeSeparator: string, AMDesignator: string, PMDesignator: string, fullDateTimePattern: string, shortTimePattern: string, longTimePattern: string, yearMonthPattern: string);
    }
}
declare namespace Stimulsoft.System.Globalization {
    class CultureInfo {
        numberFormat: NumberFormatInfo;
        dateTimeFormat: DateTimeFormatInfo;
        name: string;
        textInfo: TextInfo;
        fix(): void;
        private static _cultures;
        private static _currentCulture;
        static get currentCulture(): CultureInfo;
        static set currentCulture(val: CultureInfo);
        static get cultures(): {
            [key: string]: CultureInfo;
        };
        static get InvariantCulture(): CultureInfo;
        static getCultureInfo(name: string): CultureInfo;
        constructor(name: string, numberFormat?: NumberFormatInfo, dateTimeFormat?: DateTimeFormatInfo, textInfo?: TextInfo);
    }
}
declare namespace Stimulsoft.System {
    class DateTime {
        private static ticksPerMillisecond;
        private static ticksPerSecond;
        private static ticksPerMinute;
        private static ticksPerHour;
        private static ticksPerDay;
        private static millisPerSecond;
        private static millisPerMinute;
        private static millisPerHour;
        private static millisPerDay;
        private static daysPerYear;
        private static daysPer4Years;
        private static daysPer100Years;
        private static daysPer400Years;
        private static daysTo1601;
        private static daysTo1899;
        private static daysTo10000;
        private static minTicks;
        private static maxTicks;
        private static maxMillis;
        private static fileTimeOffset;
        private static doubleDateOffset;
        private static oADateMinAsTicks;
        private static oADateMinAsDouble;
        private static oADateMaxAsDouble;
        private static datePartYear;
        private static datePartDayOfYear;
        private static datePartMonth;
        private static DatePartDay;
        private static daysToMonth365;
        private static daysToMonth366;
        static minValue: DateTime;
        static maxValue: DateTime;
        static getNetTypeName(): string;
        private innerDate;
        get year(): number;
        get month(): number;
        get monthName(): string;
        get monthGenitiveName(): string;
        get monthShortName(): string;
        get day(): number;
        get dayOfWeek(): DayOfWeek;
        get dayName(): string;
        get dayShortName(): string;
        get hour(): number;
        get minute(): number;
        get second(): number;
        get millisecond(): number;
        get ticks(): number;
        get dayOfYear(): number;
        firstDayOfWeek(): DateTime;
        lastDayOfWeek(): DateTime;
        firstDayOfMonth(): DateTime;
        lastDayOfMonth(): DateTime;
        firstDayOfQuarter(): DateTime;
        lastDayOfQuarter(): DateTime;
        firstDayOfFirthQuarter(): DateTime;
        lastDayOfFirthQuarter(): DateTime;
        firstDayOfSecondQuarter(): DateTime;
        lastDayOfSecondQuarter(): DateTime;
        firstDayOfThirdQuarter(): DateTime;
        lastDayOfThirdQuarter(): DateTime;
        firstDayOfFourthQuarter(): DateTime;
        lastDayOfFourthQuarter(): DateTime;
        firstDayOfYear(): DateTime;
        lastDayOfYear(): DateTime;
        toShortDateString(): string;
        static get now(): DateTime;
        static get today(): DateTime;
        static isLeapYear(year: number): boolean;
        static daysInMonth(year: number, month: number): number;
        static compare(t1: DateTime, t2: DateTime): number;
        private static doubleDateToTicks;
        private static ticksToOADate;
        static ticksNetToTicksJs(ticks: number): number;
        negate(): DateTime;
        addYears(value: number): DateTime;
        addMonths(value: number): DateTime;
        addDays(value: number): DateTime;
        addHours(value: number): DateTime;
        addMinutes(value: number): DateTime;
        addSeconds(value: number): DateTime;
        addMilliseconds(value: number): DateTime;
        addTicks(value: number): DateTime;
        compareTo(value: DateTime): number;
        subtract(value: DateTime): TimeSpan;
        get date(): Date;
        toString(format?: string): string;
        static oaDateToTicks0(oaDate: number): number;
        static ticksToOADate0(ticks: number): number;
        toOADate(): number;
        toOADate2(round: boolean): number;
        toNetJsonString(): string;
        static tryParseExact(d: string, format: string[]): {
            result: DateTime;
            successfully: boolean;
        };
        static fromNetJsonString(jsonDate: string): DateTime;
        static fromOADate(oadate: number): DateTime;
        static fromString(d?: string, logError?: boolean): DateTime;
        static fromString2(format: string, value: string, logError?: boolean): DateTime;
        static isISO8601String(d: string): boolean;
        get timeOfDay(): TimeSpan;
        get date2(): DateTime;
        constructor(param1: Date | number, month?: number, day?: number, hour?: number, minute?: number, second?: number, millisecond?: number);
    }
}
declare namespace Stimulsoft.System {
    enum DayOfWeek {
        Sunday = 0,
        Monday = 1,
        Tuesday = 2,
        Wednesday = 3,
        Thursday = 4,
        Friday = 5,
        Saturday = 6
    }
}
declare namespace Stimulsoft.System {
    class Enum {
        static getName(enumType: any, value: number): string;
        static parse(enumType: any, value: string | number, upperFirstChar?: boolean): number;
        private static upperFirstChar;
        static getNames(enumType: any): string[];
        static getValues(enumType: any): number[];
        name: string;
        value: number;
        toString(): string;
        compareTo(value: Enum): number;
        constructor(name: string, value?: number);
    }
}
declare namespace Stimulsoft.System {
    class Environment {
        static get newLine(): string;
    }
}
declare namespace Stimulsoft.System {
    class Event {
        private eventList;
        get isNull(): boolean;
        get isNotNull(): boolean;
        add(funct: Function, _this: any): void;
        call(...args: any[]): void;
    }
}
declare namespace Stimulsoft.System {
    class EventArgs {
        static empty: EventArgs;
    }
}
declare namespace Stimulsoft.System {
    import IAsIs = Stimulsoft.System.IAsIs;
    function enumerable(value: boolean): (target: any, propertyKey: string, descriptor: PropertyDescriptor) => void;
    function enumType(type: any): (target: any, propertyKey: string, descriptor: PropertyDescriptor) => void;
    class StiObject implements IAsIs {
        value: any;
        is<T>(type: (new (...args: any[]) => T) | Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Interface<T>): T;
        memberwiseClone(isBase?: boolean): any;
        equals(...args: any[]): boolean;
        getHashCode(...args: any[]): number;
        static compareTo(a: any, b: any): number;
        compareTo(object: any): number;
        toBoolean(): boolean;
        toNumber(float?: boolean): number;
        toString(): string;
        getType(): Stimulsoft.System.Type;
        getTypeName(): string;
        getNetTypeName(): string;
        static referenceEquals(objA: any, objB: any): boolean;
        static addEvent(element: any, eventName: string, fn: Function): void;
        static equals(objA: any, objB: any): boolean;
        static isNullOrUndefined: (obj: any) => boolean;
        static disableAllEnumerable(prototype: any, obj: any): void;
        static keys(obj: any): any[];
        static getOwnPropertyNames(obj: any): any[];
        static saveAs(data: any, fileName: string, type?: string): void;
        static init(): void;
        constructor(value: any);
    }
    class StiNumber extends StiObject implements IAsIs {
        value: number;
        getHashCode(...args: any[]): number;
        is(type: any): boolean;
        as(type: any): any;
        memberwiseClone(isBase?: boolean): any;
        compareTo(value: any): number;
        toShort(): number;
        toStringFormat(formatString: string): string;
        getType(): Stimulsoft.System.Type;
        getTypeName(): string;
        getNetTypeName(): string;
        static tryParse(value: string): {
            result: number;
            successfully: boolean;
        };
    }
    class StiString extends StiObject implements IAsIs {
        value: string;
        is(type: any): boolean;
        as(type: any): any;
        memberwiseClone(isBase?: boolean): any;
        replaceAll(searchValue: string, replaceValue: string, startIndex?: number, count?: number): string;
        contains(str: string): boolean;
        compareTo(strB: string): number;
        isBase64String(): boolean;
        remove(startIndex: number, count?: number): string;
        insert(startIndex: number, value: string, removeLength?: number): string;
        padLeft(totalWidth: number, paddingChar?: string): string;
        startsWith(value: string, ignoreCase?: boolean): boolean;
        endsWith(value: string, ignoreCase?: boolean): boolean;
        trimStart(char?: string): string;
        trimEnd(char?: string): string;
        getHashCode(...args: any[]): number;
        toBytesArray(): number[];
        toUnicodeString(): string;
        fromUnicodeString(): string;
        indexOfAny(values: string[]): number;
        regexIndexOf(regex: RegExp, startpos: number): number;
        regexLastIndexOf(regex: RegExp, startpos: number): number;
        split(...separators: string[]): string[];
        getType(): Stimulsoft.System.Type;
        getTypeName(): string;
        getNetTypeName(): string;
        toString(): string;
        static isNullOrEmpty(value: string): boolean;
        static isNullOrWhiteSpace(value: string): boolean;
        static repeat(value: string, n: number): string;
        static fill(value: string, count: number): string;
        static format(str: string, ...values: any[]): string;
        static format1(str: string, values: any[]): string;
        static parseFormatString(formatString: string, values: any[]): string;
        static formatNumber(arg: any, decimalDigits: any, useGroupSeparator: boolean, useSign: boolean): string;
        static customFormat(arg: any, format: string): string;
        static customFormatNumber(arg: number, format: string): string;
        static indexOfAny(str: string, searchChars: string[]): number;
        static join(separator: string, value: string[]): string;
        static fromBytesArray(bytes: number[]): string;
    }
    class StiBoolean extends StiObject implements IAsIs {
        is(type: any): boolean;
        as(type: any): any;
        memberwiseClone(isBase?: boolean): any;
        getHashCode(...args: any[]): number;
        getType(): Stimulsoft.System.Type;
        getTypeName(): string;
        getNetTypeName(): string;
        compareTo(object: boolean): number;
    }
    class StiArray extends StiObject {
        getHashCode(): number;
        getType(): Stimulsoft.System.Type;
        getTypeName(): string;
        getNetTypeName(): string;
        get countItems(): number;
        contains(item: any): boolean;
        remove<T>(item: T): void;
        removeAt(index: number): void;
        insert(index: number, item: any): void;
        clear(): void;
        clone(): any;
        addRange(items: any[]): void;
        removeRange(index: number, count: number): void;
        copyTo(array: any[], index?: number): void;
        getKeys(): string[];
        getByIndex(index: number, keys?: string[]): any;
        setByIndex(index: number, item: any): void;
        removeByIndex(index: number): any;
        sort2(comparer: Stimulsoft.System.Collections.IComparer<any>): any[];
        getLength(dimension: number): number;
        toArray(): any[];
        toNumber(float?: boolean): number;
        peek(): any;
        toList<T>(): Stimulsoft.System.Collections.List<T>;
        static create<T>(t: Stimulsoft.System.Type, count: number, isStructure?: boolean): T[];
        static create2<T>(t: Stimulsoft.System.Type, count1: number, count2: number, isStructure?: boolean): T[][];
        static create3<T>(t: Stimulsoft.System.Type, count1: number, count2: number, count3: number, isStructure?: boolean): T[][][];
        static create1<T>(t: Stimulsoft.System.Type, ...values: any[]): T[];
        static numberSortFunction: () => any;
        static copy: (sourceArray: any[], startIndex: number, destinationArray: any[], count: number) => void;
        static copy2: (sourceArray: any[], sourceIndex: number, destinationArray: any[], destinationIndex: number, count: number) => void;
        static copy3: (sourceArray: any[], destinationArray: any[]) => void;
        static reverse: (array: any[]) => any[];
        static sort: (array: any[]) => any[];
        static sort3(keys: number[], items: any[]): void;
        static clear: (array: any[], index: number, length: number) => any[];
        static distinct<T>(array: T[]): T[];
        static isArray<T>(data: any): data is Array<T>;
        constructor(value: any);
    }
}
interface Object {
    //StiObject;
    stimulsoft(): Stimulsoft.System.StiObject;
}
interface String {
    //StiString;
    stimulsoft(): Stimulsoft.System.StiString;
}
interface Number {
    //StiNumber;
    stimulsoft(): Stimulsoft.System.StiNumber;
}
interface Boolean {
    //StiBoolean;
    stimulsoft(): Stimulsoft.System.StiBoolean;
}
interface Array<T> {
    //StiArray;
    stimulsoft(): Stimulsoft.System.StiArray;
}
declare namespace Stimulsoft.System {
    class EventHandler {
        static _this: any;
        private static handler;
        private args;
        create(script: string, _this: any): Function;
        private static fixName;
        static create(script: string, _this: any): Function;
        constructor(args: string);
    }
}
declare namespace Stimulsoft.System {
    class Exception extends Error {
        innerException?: Exception;
        constructor(message?: string, innerException?: Exception);
    }
}
declare namespace Stimulsoft.System {
    class Guid {
        private id;
        static newGuid(): Guid;
        static newGuidString(): string;
        private static s4;
        toString(): string;
        static get empty(): Guid;
        static compareTo(value: Guid): number;
        constructor(id: string);
    }
}
declare namespace Stimulsoft.System {
    class Interface<T> {
        typeName: string;
        type: T;
        constructor(typeName: string);
    }
}
declare namespace Stimulsoft.System {
    let IAsIs: Interface<IAsIs>;
    interface IAsIs {
        is<T>(type: (new (...args: any[]) => T) | Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Interface<T>): T;
    }
}
declare namespace Stimulsoft.System {
    let ICloneable: Interface<ICloneable>;
    interface ICloneable {
        clone(): any;
    }
}
declare namespace Stimulsoft.System {
    let IComparable: Interface<IComparable>;
    interface IComparable {
        compareTo(obj: any): number;
    }
}
declare namespace Stimulsoft.System {
    let IFormatProvider: Interface<IFormatProvider>;
    interface IFormatProvider {
        getFormat(formatType: Type): any;
    }
}
declare namespace Stimulsoft.System {
    class JSON2 {
        static decode(text: string): any;
        static encode(value: any): string;
        static stiPopulateObject(json: any, object: any): void;
    }
}
interface Math {
    round2(value: number, digits?: number): number;
    roundToEven(value: number, digits?: number, toEven?: boolean): number;
    trunc(x: number): number;
    sign(x: number): number;
    log10(value: number): number;
}
declare namespace Stimulsoft.System {
    enum MidpointRounding {
        ToEven = 1000,
        AwayFromZero = 1001
    }
}
declare namespace Stimulsoft.ExternalLibrary {
    function Moment(inp?: Stimulsoft.ExternalLibrary.Moment.MomentInput, format?: Stimulsoft.ExternalLibrary.Moment.MomentFormatSpecification, strict?: boolean): Stimulsoft.ExternalLibrary.Moment.Moment;
    function Moment(inp?: Stimulsoft.ExternalLibrary.Moment.MomentInput, format?: Stimulsoft.ExternalLibrary.Moment.MomentFormatSpecification, language?: string, strict?: boolean): Stimulsoft.ExternalLibrary.Moment.Moment;
}
declare namespace Stimulsoft.ExternalLibrary.Moment {
    type RelativeTimeKey = "s" | "ss" | "m" | "mm" | "h" | "hh" | "d" | "dd" | "M" | "MM" | "y" | "yy";
    type CalendarKey = "sameDay" | "nextDay" | "lastDay" | "nextWeek" | "lastWeek" | "sameElse" | string;
    type LongDateFormatKey = "LTS" | "LT" | "L" | "LL" | "LLL" | "LLLL" | "lts" | "lt" | "l" | "ll" | "lll" | "llll";
    interface Locale {
        calendar(key?: CalendarKey, m?: Moment, now?: Moment): string;
        longDateFormat(key: LongDateFormatKey): string;
        invalidDate(): string;
        ordinal(n: number): string;
        preparse(inp: string): string;
        postformat(inp: string): string;
        relativeTime(n: number, withoutSuffix: boolean, key: RelativeTimeKey, isFuture: boolean): string;
        pastFuture(diff: number, absRelTime: string): string;
        set(config: any): void;
        months(): string[];
        months(m: Moment, format?: string): string;
        monthsShort(): string[];
        monthsShort(m: Moment, format?: string): string;
        monthsParse(monthName: string, format: string, strict: boolean): number;
        monthsRegex(strict: boolean): RegExp;
        monthsShortRegex(strict: boolean): RegExp;
        week(m: Moment): number;
        firstDayOfYear(): number;
        firstDayOfWeek(): number;
        weekdays(): string[];
        weekdays(m: Moment, format?: string): string;
        weekdaysMin(): string[];
        weekdaysMin(m: Moment): string;
        weekdaysShort(): string[];
        weekdaysShort(m: Moment): string;
        weekdaysParse(weekdayName: string, format: string, strict: boolean): number;
        weekdaysRegex(strict: boolean): RegExp;
        weekdaysShortRegex(strict: boolean): RegExp;
        weekdaysMinRegex(strict: boolean): RegExp;
        isPM(input: string): boolean;
        meridiem(hour: number, minute: number, isLower: boolean): string;
    }
    interface StandaloneFormatSpec {
        format: string[];
        standalone: string[];
        isFormat?: RegExp;
    }
    interface WeekSpec {
        dow: number;
        doy: number;
    }
    type CalendarSpecVal = string | ((m?: MomentInput, now?: Moment) => string);
    interface CalendarSpec {
        sameDay?: CalendarSpecVal;
        nextDay?: CalendarSpecVal;
        lastDay?: CalendarSpecVal;
        nextWeek?: CalendarSpecVal;
        lastWeek?: CalendarSpecVal;
        sameElse?: CalendarSpecVal;
        [x: string]: CalendarSpecVal | void;
    }
    type RelativeTimeSpecVal = (string | ((n: number, withoutSuffix: boolean, key: RelativeTimeKey, isFuture: boolean) => string));
    type RelativeTimeFuturePastVal = string | ((relTime: string) => string);
    interface RelativeTimeSpec {
        future: RelativeTimeFuturePastVal;
        past: RelativeTimeFuturePastVal;
        s: RelativeTimeSpecVal;
        ss: RelativeTimeSpecVal;
        m: RelativeTimeSpecVal;
        mm: RelativeTimeSpecVal;
        h: RelativeTimeSpecVal;
        hh: RelativeTimeSpecVal;
        d: RelativeTimeSpecVal;
        dd: RelativeTimeSpecVal;
        M: RelativeTimeSpecVal;
        MM: RelativeTimeSpecVal;
        y: RelativeTimeSpecVal;
        yy: RelativeTimeSpecVal;
    }
    interface LongDateFormatSpec {
        LTS: string;
        LT: string;
        L: string;
        LL: string;
        LLL: string;
        LLLL: string;
        lts?: string;
        lt?: string;
        l?: string;
        ll?: string;
        lll?: string;
        llll?: string;
    }
    type MonthWeekdayFn = (momentToFormat: Moment, format?: string) => string;
    type WeekdaySimpleFn = (momentToFormat: Moment) => string;
    interface LocaleSpecification {
        months?: string[] | StandaloneFormatSpec | MonthWeekdayFn;
        monthsShort?: string[] | StandaloneFormatSpec | MonthWeekdayFn;
        weekdays?: string[] | StandaloneFormatSpec | MonthWeekdayFn;
        weekdaysShort?: string[] | StandaloneFormatSpec | WeekdaySimpleFn;
        weekdaysMin?: string[] | StandaloneFormatSpec | WeekdaySimpleFn;
        meridiemParse?: RegExp;
        meridiem?: (hour: number, minute: number, isLower: boolean) => string;
        isPM?: (input: string) => boolean;
        longDateFormat?: LongDateFormatSpec;
        calendar?: CalendarSpec;
        relativeTime?: RelativeTimeSpec;
        invalidDate?: string;
        ordinal?: (n: number) => string;
        ordinalParse?: RegExp;
        week?: WeekSpec;
        [x: string]: any;
    }
    interface MomentObjectOutput {
        years: number;
        months: number;
        date: number;
        hours: number;
        minutes: number;
        seconds: number;
        milliseconds: number;
    }
    interface Duration {
        clone(): Duration;
        humanize(withSuffix?: boolean): string;
        abs(): Duration;
        as(units: unitOfTime.Base): number;
        get(units: unitOfTime.Base): number;
        milliseconds(): number;
        asMilliseconds(): number;
        seconds(): number;
        asSeconds(): number;
        minutes(): number;
        asMinutes(): number;
        hours(): number;
        asHours(): number;
        days(): number;
        asDays(): number;
        weeks(): number;
        asWeeks(): number;
        months(): number;
        asMonths(): number;
        years(): number;
        asYears(): number;
        add(inp?: DurationInputArg1, unit?: DurationInputArg2): Duration;
        subtract(inp?: DurationInputArg1, unit?: DurationInputArg2): Duration;
        locale(): string;
        locale(locale: LocaleSpecifier): Duration;
        localeData(): Locale;
        toISOString(): string;
        toJSON(): string;
        lang(locale: LocaleSpecifier): Moment;
        lang(): Locale;
        toIsoString(): string;
    }
    interface MomentRelativeTime {
        future: any;
        past: any;
        s: any;
        ss: any;
        m: any;
        mm: any;
        h: any;
        hh: any;
        d: any;
        dd: any;
        M: any;
        MM: any;
        y: any;
        yy: any;
    }
    interface MomentLongDateFormat {
        L: string;
        LL: string;
        LLL: string;
        LLLL: string;
        LT: string;
        LTS: string;
        l?: string;
        ll?: string;
        lll?: string;
        llll?: string;
        lt?: string;
        lts?: string;
    }
    interface MomentParsingFlags {
        empty: boolean;
        unusedTokens: string[];
        unusedInput: string[];
        overflow: number;
        charsLeftOver: number;
        nullInput: boolean;
        invalidMonth: string | void;
        invalidFormat: boolean;
        userInvalidated: boolean;
        iso: boolean;
        parsedDateParts: any[];
        meridiem: string | void;
    }
    interface MomentParsingFlagsOpt {
        empty?: boolean;
        unusedTokens?: string[];
        unusedInput?: string[];
        overflow?: number;
        charsLeftOver?: number;
        nullInput?: boolean;
        invalidMonth?: string;
        invalidFormat?: boolean;
        userInvalidated?: boolean;
        iso?: boolean;
        parsedDateParts?: any[];
        meridiem?: string;
    }
    interface MomentBuiltinFormat {
        __momentBuiltinFormatBrand: any;
    }
    type MomentFormatSpecification = string | MomentBuiltinFormat | Array<string | MomentBuiltinFormat>;
    namespace unitOfTime {
        type Base = ("year" | "years" | "y" | "month" | "months" | "M" | "week" | "weeks" | "w" | "day" | "days" | "d" | "hour" | "hours" | "h" | "minute" | "minutes" | "m" | "second" | "seconds" | "s" | "millisecond" | "milliseconds" | "ms");
        type _quarter = "quarter" | "quarters" | "Q";
        type _isoWeek = "isoWeek" | "isoWeeks" | "W";
        type _date = "date" | "dates" | "D";
        type DurationConstructor = Base | _quarter;
        type DurationAs = Base;
        type StartOf = Base | _quarter | _isoWeek | _date;
        type Diff = Base | _quarter;
        type MomentConstructor = Base | _date;
        type All = Base | _quarter | _isoWeek | _date | "weekYear" | "weekYears" | "gg" | "isoWeekYear" | "isoWeekYears" | "GG" | "dayOfYear" | "dayOfYears" | "DDD" | "weekday" | "weekdays" | "e" | "isoWeekday" | "isoWeekdays" | "E";
    }
    interface MomentInputObject {
        years?: number;
        year?: number;
        y?: number;
        months?: number;
        month?: number;
        M?: number;
        days?: number;
        day?: number;
        d?: number;
        dates?: number;
        date?: number;
        D?: number;
        hours?: number;
        hour?: number;
        h?: number;
        minutes?: number;
        minute?: number;
        m?: number;
        seconds?: number;
        second?: number;
        s?: number;
        milliseconds?: number;
        millisecond?: number;
        ms?: number;
    }
    interface DurationInputObject extends MomentInputObject {
        quarters?: number;
        quarter?: number;
        Q?: number;
        weeks?: number;
        week?: number;
        w?: number;
    }
    interface MomentSetObject extends MomentInputObject {
        weekYears?: number;
        weekYear?: number;
        gg?: number;
        isoWeekYears?: number;
        isoWeekYear?: number;
        GG?: number;
        quarters?: number;
        quarter?: number;
        Q?: number;
        weeks?: number;
        week?: number;
        w?: number;
        isoWeeks?: number;
        isoWeek?: number;
        W?: number;
        dayOfYears?: number;
        dayOfYear?: number;
        DDD?: number;
        weekdays?: number;
        weekday?: number;
        e?: number;
        isoWeekdays?: number;
        isoWeekday?: number;
        E?: number;
    }
    interface FromTo {
        from: MomentInput;
        to: MomentInput;
    }
    type MomentInput = Moment | Date | string | number | Array<number | string> | MomentInputObject | void;
    type DurationInputArg1 = Duration | number | string | FromTo | DurationInputObject | void;
    type DurationInputArg2 = unitOfTime.DurationConstructor;
    type LocaleSpecifier = string | Moment | Duration | string[] | boolean;
    interface MomentCreationData {
        input: MomentInput;
        format?: MomentFormatSpecification;
        locale: Locale;
        isUTC: boolean;
        strict?: boolean;
    }
    interface Moment extends Object {
        format(format?: string): string;
        startOf(unitOfTime: unitOfTime.StartOf): Moment;
        endOf(unitOfTime: unitOfTime.StartOf): Moment;
        add(amount?: DurationInputArg1, unit?: DurationInputArg2): Moment;
        add(unit: unitOfTime.DurationConstructor, amount: number | string): Moment;
        subtract(amount?: DurationInputArg1, unit?: DurationInputArg2): Moment;
        subtract(unit: unitOfTime.DurationConstructor, amount: number | string): Moment;
        calendar(time?: MomentInput, formats?: CalendarSpec): string;
        clone(): Moment;
        valueOf(): number;
        local(keepLocalTime?: boolean): Moment;
        isLocal(): boolean;
        utc(keepLocalTime?: boolean): Moment;
        isUTC(): boolean;
        isUtc(): boolean;
        parseZone(): Moment;
        isValid(): boolean;
        invalidAt(): number;
        hasAlignedHourOffset(other?: MomentInput): boolean;
        creationData(): MomentCreationData;
        parsingFlags(): MomentParsingFlags;
        year(y: number): Moment;
        year(): number;
        years(y: number): Moment;
        years(): number;
        quarter(): number;
        quarter(q: number): Moment;
        quarters(): number;
        quarters(q: number): Moment;
        month(M: number | string): Moment;
        month(): number;
        months(M: number | string): Moment;
        months(): number;
        day(d: number | string): Moment;
        day(): number;
        days(d: number | string): Moment;
        days(): number;
        date(d: number): Moment;
        date(): number;
        dates(d: number): Moment;
        dates(): number;
        hour(h: number): Moment;
        hour(): number;
        hours(h: number): Moment;
        hours(): number;
        minute(m: number): Moment;
        minute(): number;
        minutes(m: number): Moment;
        minutes(): number;
        second(s: number): Moment;
        second(): number;
        seconds(s: number): Moment;
        seconds(): number;
        millisecond(ms: number): Moment;
        millisecond(): number;
        milliseconds(ms: number): Moment;
        milliseconds(): number;
        weekday(): number;
        weekday(d: number): Moment;
        isoWeekday(): number;
        isoWeekday(d: number | string): Moment;
        weekYear(): number;
        weekYear(d: number): Moment;
        isoWeekYear(): number;
        isoWeekYear(d: number): Moment;
        week(): number;
        week(d: number): Moment;
        weeks(): number;
        weeks(d: number): Moment;
        isoWeek(): number;
        isoWeek(d: number): Moment;
        isoWeeks(): number;
        isoWeeks(d: number): Moment;
        weeksInYear(): number;
        isoWeeksInYear(): number;
        dayOfYear(): number;
        dayOfYear(d: number): Moment;
        from(inp: MomentInput, suffix?: boolean): string;
        to(inp: MomentInput, suffix?: boolean): string;
        fromNow(withoutSuffix?: boolean): string;
        toNow(withoutPrefix?: boolean): string;
        diff(b: MomentInput, unitOfTime?: unitOfTime.Diff, precise?: boolean): number;
        toArray(): number[];
        toDate(): Date;
        toISOString(keepOffset?: boolean): string;
        inspect(): string;
        toJSON(): string;
        unix(): number;
        isLeapYear(): boolean;
        zone(): number;
        zone(b: number | string): Moment;
        utcOffset(): number;
        utcOffset(b: number | string, keepLocalTime?: boolean): Moment;
        isUtcOffset(): boolean;
        daysInMonth(): number;
        isDST(): boolean;
        zoneAbbr(): string;
        zoneName(): string;
        isBefore(inp?: MomentInput, granularity?: unitOfTime.StartOf): boolean;
        isAfter(inp?: MomentInput, granularity?: unitOfTime.StartOf): boolean;
        isSame(inp?: MomentInput, granularity?: unitOfTime.StartOf): boolean;
        isSameOrAfter(inp?: MomentInput, granularity?: unitOfTime.StartOf): boolean;
        isSameOrBefore(inp?: MomentInput, granularity?: unitOfTime.StartOf): boolean;
        isBetween(a: MomentInput, b: MomentInput, granularity?: unitOfTime.StartOf, inclusivity?: "()" | "[)" | "(]" | "[]"): boolean;
        lang(language: LocaleSpecifier): Moment;
        lang(): Locale;
        locale(): string;
        locale(locale: LocaleSpecifier): Moment;
        localeData(): Locale;
        isDSTShifted(): boolean;
        max(inp?: MomentInput, format?: MomentFormatSpecification, strict?: boolean): Moment;
        max(inp?: MomentInput, format?: MomentFormatSpecification, language?: string, strict?: boolean): Moment;
        min(inp?: MomentInput, format?: MomentFormatSpecification, strict?: boolean): Moment;
        min(inp?: MomentInput, format?: MomentFormatSpecification, language?: string, strict?: boolean): Moment;
        get(unit: unitOfTime.All): number;
        set(unit: unitOfTime.All, value: number): Moment;
        set(objectLiteral: MomentSetObject): Moment;
        toObject(): MomentObjectOutput;
    }
    var version: string;
    var fn: Moment;
    function utc(inp?: MomentInput, format?: MomentFormatSpecification, strict?: boolean): Moment;
    function utc(inp?: MomentInput, format?: MomentFormatSpecification, language?: string, strict?: boolean): Moment;
    function unix(timestamp: number): Moment;
    function invalid(flags?: MomentParsingFlagsOpt): Moment;
    function isMoment(m: any): m is Moment;
    function isDate(m: any): m is Date;
    function isDuration(d: any): d is Duration;
    function lang(language?: string, definition?: Locale): string;
    function locale(language?: string | string[], definition?: LocaleSpecification | void): string;
    function localeData(key?: string | string[]): Locale;
    function duration(inp?: DurationInputArg1, unit?: DurationInputArg2): Duration;
    function parseZone(inp?: MomentInput, format?: MomentFormatSpecification, strict?: boolean): Moment;
    function parseZone(inp?: MomentInput, format?: MomentFormatSpecification, language?: string, strict?: boolean): Moment;
    function months(): string[];
    function months(index: number): string;
    function months(format: string, index?: number): string;
    function monthsShort(): string[];
    function monthsShort(index: number): string;
    function monthsShort(format: string, index?: number): string;
    function weekdays(): string[];
    function weekdays(index: number): string;
    function weekdays(format: string, index?: number): string;
    function weekdays(localeSorted: boolean, format?: string | number, index?: number): string;
    function weekdaysShort(): string[];
    function weekdaysShort(index: number): string;
    function weekdaysShort(format: string, index?: number): string;
    function weekdaysShort(localeSorted: boolean, format?: string | number, index?: number): string;
    function weekdaysMin(): string[];
    function weekdaysMin(index: number): string;
    function weekdaysMin(format: string, index?: number): string;
    function weekdaysMin(localeSorted: boolean, format?: number | string, index?: number): string;
    function min(moments: Moment[]): Moment;
    function min(...moments: Moment[]): Moment;
    function max(moments: Moment[]): Moment;
    function max(...moments: Moment[]): Moment;
    function now(): number;
    function defineLocale(language: string, localeSpec: LocaleSpecification | void | any): Locale;
    function updateLocale(language: string, localeSpec: LocaleSpecification | void): Locale;
    function locales(): string[];
    function normalizeUnits(unit: unitOfTime.All): string;
    function relativeTimeThreshold(threshold: string): number | boolean;
    function relativeTimeThreshold(threshold: string, limit: number): boolean;
    function relativeTimeRounding(fn: (num: number) => number): boolean;
    function relativeTimeRounding(): (num: number) => number;
    function calendarFormat(m: Moment, now: Moment): string;
    function parseTwoDigitYear(input: string): number;
    let ISO_8601: MomentBuiltinFormat;
    var RFC_2822: MomentBuiltinFormat;
    var defaultFormat: string;
    var defaultFormatUtc: string;
    var HTML5_FMT: {
        DATETIME_LOCAL: string;
        DATETIME_LOCAL_SECONDS: string;
        DATETIME_LOCAL_MS: string;
        DATE: string;
        TIME: string;
        TIME_SECONDS: string;
        TIME_MS: string;
        WEEK: string;
        MONTH: string;
    };
}
interface ObjectConstructor {
    saveAs(data: any, fileName: string, type?: string): any;
}
declare namespace Stimulsoft.ExternalLibrary.Opentype {
    function parse(data: any): any;
}
declare namespace Stimulsoft.System {
}
declare namespace Stimulsoft.Report {
    import Type = Stimulsoft.System.Type;
    class Range {
        static isRangeType(type: Type): boolean;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        parse(from: string, to: string): void;
        equals(obj: any): boolean;
        get fromStrLoc(): string;
        get toStrLoc(): string;
        toString(): string;
        getHashCode(): number;
        constructor();
    }
    class CharRange extends Range {
        from: string;
        to: string;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        contains(value: string): boolean;
        constructor(from?: string, to?: string);
    }
    class DateTimeRange extends Range {
        from: Stimulsoft.System.NullableDateTime;
        to: Stimulsoft.System.NullableDateTime;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        get fromDate(): Stimulsoft.System.DateTime;
        get toDate(): Stimulsoft.System.DateTime;
        contains(value: Stimulsoft.System.DateTime): boolean;
        toString(): string;
        constructor(from?: Stimulsoft.System.DateTime, to?: Stimulsoft.System.DateTime);
    }
    class TimeSpanRange extends Range {
        from: Stimulsoft.System.NullableTimeSpan;
        to: Stimulsoft.System.NullableTimeSpan;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        get fromTime(): Stimulsoft.System.TimeSpan;
        get toTime(): Stimulsoft.System.TimeSpan;
        contains(value: Stimulsoft.System.TimeSpan): boolean;
        toString(): string;
        constructor(from?: Stimulsoft.System.TimeSpan, to?: Stimulsoft.System.TimeSpan);
    }
    class DecimalRange extends Range {
        from: number;
        to: number;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class FloatRange extends Range {
        from: number;
        to: number;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class DoubleRange extends Range {
        from: number;
        to: number;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class ByteRange extends Range {
        from: number;
        to: number;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class ShortRange extends Range {
        from: number;
        to: number;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class IntRange extends Range {
        from: number;
        to: number;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class LongRange extends Range {
        from: number;
        to: number;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class GuidRange extends Range {
        from: Stimulsoft.System.Guid;
        to: Stimulsoft.System.Guid;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        contains(value: Stimulsoft.System.Guid): boolean;
        constructor(from?: Stimulsoft.System.Guid, to?: Stimulsoft.System.Guid);
    }
    class StringRange extends Range {
        from: string;
        to: string;
        get rangeName(): string;
        get rangeType(): Stimulsoft.System.Type;
        get fromObject(): any;
        set fromObject(value: any);
        get toObject(): any;
        set toObject(value: any);
        contains(value: string): boolean;
        constructor(from?: string, to?: string);
    }
}
declare namespace Stimulsoft.System {
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    class ResourceManager {
        private resource;
        getString(name: string, culture: CultureInfo): string;
    }
}
declare namespace Stimulsoft.System {
    class StiError {
        private static lastErrorMessage;
        static errorMessageForm: any;
        static showError(e: any, showForm?: boolean, infoForm?: boolean): void;
    }
}
declare namespace Stimulsoft.System {
    class StiPromise<T> {
        private _this;
        returnValue: T;
        private _tryFunctions;
        private _finallyFunction;
        private _timeout;
        private _startTime;
        private _callTry;
        private _callCatch;
        private _callFinaly;
        private _callTimeout;
        private _catchArgument;
        private _finalyArgument;
        private timeoutHanderId;
        private assignFunction;
        private _catchFunctions;
        try(tryFunction: Function, _this?: any): StiPromise<T>;
        catch(catchFunction: Function, _this?: any): StiPromise<T>;
        finally(finallyFunction: Function, _this?: any): StiPromise<T>;
        this(_this: any): StiPromise<T>;
        timeout(timeout: number): StiPromise<T>;
        callTry(returnValue?: T): StiPromise<T>;
        callCatch(catchArgument?: any): void;
        private callFinally;
        callTimeout(): void;
        private nextPromises;
        abort(previusPromise?: StiPromise<any>): StiPromise<T>;
        private abortFunction;
        onAbort(abortFunction: Function): void;
        constructor();
    }
}
declare namespace Stimulsoft.System {
    enum StringComparison {
        CurrentCulture = 0,
        CurrentCultureIgnoreCase = 1,
        InvariantCulture = 2,
        InvariantCultureIgnoreCase = 3,
        Ordinal = 4,
        OrdinalIgnoreCase = 5
    }
}
declare namespace Stimulsoft.System {
    class SwitchSymbolFormatter {
        private numberSymbol;
        private isValid;
        formatValue(format: string, source: any): string;
        constructor(numberSymbol?: string);
    }
}
declare namespace Stimulsoft.System {
    class TimeSpan {
        static ticksPerMillisecond: number;
        private static millisecondsPerTick;
        static ticksPerSecond: number;
        private static secondsPerTick;
        static ticksPerMinute: number;
        private static minutesPerTick;
        static ticksPerHour: number;
        private static hoursPerTick;
        static ticksPerDay: number;
        private static daysPerTick;
        private static millisPerSecond;
        private static millisPerMinute;
        private static millisPerHour;
        private static millisPerDay;
        static maxSeconds: number;
        static minSeconds: number;
        static maxMilliSeconds: number;
        static minMilliSeconds: number;
        static ticksPerTenthSecond: number;
        static get zero(): TimeSpan;
        static getNetTypeName(): string;
        private static _minValue;
        static get minValue(): TimeSpan;
        private static _maxValue;
        static get maxValue(): TimeSpan;
        private _ticks;
        get ticks(): number;
        get days(): number;
        get hours(): number;
        get milliseconds(): number;
        get minutes(): number;
        get seconds(): number;
        get totalDays(): number;
        get totalHours(): number;
        get totalMilliseconds(): number;
        get totalMinutes(): number;
        get totalSeconds(): number;
        static fromString(value: string, format?: string): TimeSpan;
        private static interval;
        static fromTicks(value: number): TimeSpan;
        static fromSeconds(value: number): TimeSpan;
        static fromMilliseconds(value: number): TimeSpan;
        add(value: number): TimeSpan;
        add2(value: TimeSpan): TimeSpan;
        toString(format?: string): string;
        negate(): TimeSpan;
        private static timeToTicks;
        static create(days?: number, hours?: number, minutes?: number, seconds?: number, milliseconds?: number): TimeSpan;
        constructor(param1?: number, minutes?: number, seconds?: number, milliseconds?: number);
    }
}
declare namespace Stimulsoft.System {
    enum TypeCode {
        Empty = 0,
        Object = 1,
        DBNull = 2,
        Boolean = 3,
        Char = 4,
        SByte = 5,
        Byte = 6,
        Int16 = 7,
        UInt16 = 8,
        Int32 = 9,
        UInt32 = 10,
        Int64 = 11,
        UInt64 = 12,
        Single = 13,
        Double = 14,
        Decimal = 15,
        DateTime = 16,
        String = 18
    }
}
declare namespace Stimulsoft.System {
    import TypeCode = Stimulsoft.System.TypeCode;
    class TypeHelper {
        private static types;
        static getTypes(): Stimulsoft.System.Type[];
        static isValueType(type: Type): boolean;
    }
    class Type {
        apply(thisArg: any, argArray?: any): any;
        call(thisArg: any, ...argArray: any[]): any;
        bind(thisArg: any, ...argArray: any[]): any;
        prototype: any;
        length: number;
        arguments: any;
        caller: Function;
        name: string;
        [Symbol.hasInstance]: any;
        static getType(value: any): Type;
        static getTypeName(value: any): string;
        static getTypeCode(value: any): TypeCode;
        static isNumericType(type: Type): boolean;
        static isIntegerType(type: Type): boolean;
        static isDateType(type: Type): boolean;
        static isArrayType(type: Type): boolean;
        static getHashCode(type: any): number;
    }
    type KeyObjectType = {
        [key: string]: {};
    };
    class Byte {
    }
    class ByteArray {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class Decimal {
    }
    class Double {
    }
    class Float {
    }
    class Int {
    }
    class Int16 {
    }
    class Int32 {
    }
    class Int64 {
    }
    class Short {
    }
    class Long {
    }
    class SByte {
    }
    class Single extends Number {
    }
    class UInt {
    }
    class UInt16 {
    }
    class UInt32 {
    }
    class UInt64 {
    }
    class UShort {
    }
    class ULong {
    }
    class Nullable {
    }
    class NullableBoolean extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableByte extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableChar extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableDateTime extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableTimeSpan extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableDecimal extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableDouble extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableFloat extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableGuid extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableInt extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableInt16 extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableInt32 extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableInt64 extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableShort extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableLong extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableSByte extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableSingle extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableUInt extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableUInt16 extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableUInt32 extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableUInt64 extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableUShort extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class NullableULong extends Nullable {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftByteRange extends Stimulsoft.Report.ByteRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftCharRange extends Stimulsoft.Report.CharRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftDateTimeRange extends Stimulsoft.Report.DateTimeRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftDecimalRange extends Stimulsoft.Report.DecimalRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftDoubleRange extends Stimulsoft.Report.DoubleRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftFloatRange extends Stimulsoft.Report.FloatRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftGuidRange extends Stimulsoft.Report.GuidRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftIntRange extends Stimulsoft.Report.IntRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftLongRange extends Stimulsoft.Report.LongRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftShortRange extends Stimulsoft.Report.ShortRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftStringRange extends Stimulsoft.Report.StringRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftTimeSpanRange extends Stimulsoft.Report.TimeSpanRange {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftList {
        static isListType(type: Type): boolean;
    }
    class StimulsoftBoolList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftByteList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftCharList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftDateTimeList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftDecimalList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftDoubleList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftFloatList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftGuidList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftIntList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftLongList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftShortList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftStringList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
    class StimulsoftTimeSpanList extends StimulsoftList {
        static getTypeName(): string;
        static getNetTypeName(): string;
    }
}
declare namespace Stimulsoft.ExternalLibrary.XXH {
    function h32(value: string, seed: number): number;
}
declare namespace Stimulsoft.ExternalLibrary.xmldoc {
    class XmlDocument {
        constructor(xmlString: string);
    }
}
declare namespace Stimulsoft.System.Collections {
    class CollectionBase<T> implements ICollection<T> {
        list: T[];
        toList(): List<T>;
        toCast<C>(): C[];
        get count(): number;
        get length(): number;
        clear(): void;
        add(value: T): void;
        addRange(data: T[] | CollectionBase<T>): void;
        remove(item: T): void;
        removeAt(index: number): void;
        indexOf(item: T): number;
        getByIndex(index: number): T;
        setByIndex(index: number, value: T): void;
        insert(index: number, value: T): void;
        contains(item: T | any): boolean;
    }
}
declare namespace Stimulsoft.System.Collections {
    class Hashtable<K = any, V = any> {
        private ignoreCase;
        private isSimpleKeys;
        keys: List<K>;
        values: List<V>;
        private indexObject;
        constructor(options?: {
            ignoreCase: boolean;
        });
        get(key: K): V;
        set(key: K, value: V): void;
        add(key: K, value: V): void;
        contains(key: K): boolean;
        containsKey(key: K): boolean;
        containsValue(value: V): boolean;
        remove(key: K): void;
        clear(): void;
        copyTo(array: V[], arrayIndex: number): void;
        get count(): number;
        clone(): Hashtable<K, V>;
    }
}
declare namespace Stimulsoft.System.Collections {
    class Dictionary<K, V> extends Hashtable<K, V> {
        get pairs(): Array<{
            key: K;
            value: V;
        }>;
        tryGetValue(key: K, out: {
            ref: V;
        }): boolean;
    }
}
declare namespace Stimulsoft.System.Collections {
    class DictionaryEntry {
        key: any;
        value: any;
    }
}
declare namespace Stimulsoft.System.Collections {
    import DateTime = Stimulsoft.System.DateTime;
    class List<T> extends Array<T> {
        constructor(items?: T[] | number);
        static create<T>(t: Stimulsoft.System.Type, ...values: any[]): List<T>;
        get countItems(): number;
        addRange(items: List<T> | T[]): void;
        removeRange(index: number, count: number): void;
        getRange(index: number, count: number): List<T>;
        add(item: T): void;
        insert(index: number, item: T): void;
        getKeys(): string[];
        getByIndex(index: number, keys?: string[]): T;
        setByIndex(index: number, item: T): void;
        removeByIndex(index: number): List<T>;
        copyTo(array: any[], index?: number): void;
        clear(): void;
        peek(): T;
        remove(item: T): void;
        removeAt(index: number): void;
        exists(predicate: (value: T) => boolean): boolean;
        fullOuterJoin<K>(inner: List<T>, outerKeySelector: (value: T) => K, innerKeySelector: (value: T) => K, resultSelector: (value1: T, value2: T) => T, __this?: any): List<T>;
        toList(): List<T>;
        findIndex2(match: (value: T) => boolean): number;
        findLastIndex2(match: (value: T) => boolean): number;
        zip<S, R>(second: List<S>, resultSelector: (first: T, second: S) => R): List<R>;
        static repeat<T>(element: T, count: number): List<T>;
        
        join2<U, K, V>(inner: List<U>, outerKeySelector: (value: T) => K, innerKeySelector: (value: U) => K, resultSelector: (value1: T, value2: U) => V, __this?: any): List<V>;
        groupJoin<U, K, V>(inner: List<U>, outerKeySelector: (value: T) => K, innerKeySelector: (value: U) => K, resultSelector: (value1: T, value2: List<U>) => V, __this?: any): List<V>;
        
        
        selectMany2<C>(collectionSelector: (value: T) => List<C>, resultSelector: (value1: T, value2: C) => C, __this?: any): List<C>;
        
        orderByDescending<K>(keySelector: (value: T) => K, comparer?: IComparer<K>): List<T>;
        groupBy<K>(keySelector: (value: T) => K, comparer?: IEqualityComparer<K>, __this?: any): List<Grouping<K, T>>;
        cast<S>(): List<S>;
        toDictionary<K, V>(keySelector: (item: T) => K, elementSelector: (item: T) => V): Dictionary<K, V>;
        toLookup<K>(keySelector: (value: T) => K, __this?: any): Hashtable;
        
        aggregate(func: (av: T, e: T) => T): T;
        aggregate2(seed: T, func: (av: T, e: T) => T): T;
        count2(selector?: (value: T) => boolean, __this?: any): number;
        max<S>(selector?: (value: T) => S): S;
        min<S>(selector?: (value: T) => S): S;
        sum(selector?: (value: T) => number): number;
        all(predicate?: (value: T) => boolean, __this?: any): boolean;
        any(predicate?: (value: T) => boolean, __this?: any): boolean;
        contains(item: T): boolean;
        
        take(count: number): List<T>;
        defaultIfEmpty(): List<T>;
        distinct(): List<T>;
        except(second: List<T>): List<T>;
        union(second: List<T>): List<T>;
        sequenceEqual(second: List<T>): boolean;
        first(selector?: (value: T) => boolean, __this?: any): T;
        firstOrDefault(predicate?: (value: T) => boolean): T;
        lastOrDefault(): T;
        whereEqualsTo(values1: any, values2: any): List<any[]>;
        whereArrayItemEqualsTo(itemIndex: number, value: any): List<any[]>;
        whereArrayItemStringEqualsTo(itemIndex: number, value: string): List<any[]>;
        whereFirstOrDefaultArrayItemStringEqualsTo(itemIndex: number, value: string): any[];
        static toString2(value: any): string;
        getArrayItem(itemIndex: number): List<any[]>;
        tryCastValueOrFirstDefaultToNullableNumber(): List<number | null>;
        tryCastToNullableNumber(): List<number | null>;
        tryCastToNumber(): List<number | null>;
        tryCastToBool(): List<boolean | null>;
        tryCastToDateTime(): List<DateTime>;
        tryCastToNullableDateTime(): List<DateTime | null>;
        tryCastToTimeSpan(): List<TimeSpan>;
        tryCastToNullableTimeSpan(): List<TimeSpan | null>;
        tryCastToString(): List<string>;
        firstOrDefaultAsNullableNumber(): number | null;
        firstOrDefaultAsNumber(): number;
        static getValueOrFirstOrDefault(value: any): any;
        static add2(a: any, b: any): List<any>;
        static sub(a: any, b: any): List<any>;
        static mult(a: any, b: any): List<any>;
        static bitwiseAnd(a: any, b: any): List<any>;
        static bitwiseXOr(a: any, b: any): List<any>;
        static bitwiseOr(a: any, b: any): List<any>;
        static div(a: any, b: any): List<any>;
    }
}
declare namespace Stimulsoft.System.Collections {
    class Grouping<K, V> extends List<V> {
        key: K;
    }
}
declare namespace Stimulsoft.System.Collections {
    let ICollection: ICollection<any>;
    interface ICollection<T> {
        list: T[];
        clear(): void;
        removeAt(index: number): void;
        count: number;
        length: number;
        getByIndex(index: number): T;
        toCast<C>(): C[];
    }
}
declare namespace Stimulsoft.System.Collections {
    let IComparer: IComparer<any>;
    interface IComparer<T> {
        compare(x: T, y: T): number;
    }
}
declare namespace Stimulsoft.System.Collections {
    let IEnumerator: Interface<IEnumerator>;
    interface IEnumerator {
        current: any;
        moveNext(): boolean;
        reset(): void;
    }
}
declare namespace Stimulsoft.System.Collections {
    let IEqualityComparer: IEqualityComparer<any>;
    interface IEqualityComparer<T> {
        equals(x: T, y: T): boolean;
        getHashCode(obj: T): number;
    }
}
declare namespace Stimulsoft.System.Collections {
    class Queue<T> {
        dequeue(): T;
        enqueue(item: T): void;
        get count(): number;
        clear(): void;
    }
}
declare namespace Stimulsoft.System.Collections {
    class Stack<T> {
        pop(): T;
        push(item: T): void;
        clear(): void;
    }
}
declare namespace Stimulsoft.System.Crypt {
    class AES {
        private key;
        private data;
        private nDataBytes;
        private blockSize;
        private iv;
        private prevBlock;
        private SBOX;
        private INV_SBOX;
        private SUB_MIX_0;
        private SUB_MIX_1;
        private SUB_MIX_2;
        private SUB_MIX_3;
        private INV_SUB_MIX_0;
        private INV_SUB_MIX_1;
        private INV_SUB_MIX_2;
        private INV_SUB_MIX_3;
        private RCON;
        private nRounds;
        private invKeySchedule;
        private keySchedule;
        private doReset;
        private process;
        private processBlock;
        private xorBlock;
        private pkcs7pad;
        private pkcs7Unpad;
        private encryptBlock;
        private decryptBlock;
        private doCryptBlock;
        static encrypt(text: string, key: string): string;
        private encrypt;
        static decrypt(text: string, key: string): string;
        private decrypt;
        constructor();
    }
}
declare namespace Stimulsoft.System.Crypt {
    class BigInteger {
        private static BI_RM;
        private static BI_RC;
        private static canary;
        private static j_lm;
        private static dbits;
        private static lowprimes;
        private static lplim;
        static staticConstructor(): void;
        private static fromInt;
        static ZERO: BigInteger;
        static ONE: BigInteger;
        get DV(): number;
        get DB(): number;
        get DM(): number;
        private BI_FP;
        private get FV();
        private get F1();
        private get F2();
        t: number;
        s: number;
        am(i: number, x: number, w: BigInteger, j: number, c: number, n: number): number;
        static int2char(n: any): string;
        private int2char;
        private intAt;
        copyTo(r: BigInteger): void;
        private fromInt;
        static fromString(s: any, b?: number): BigInteger;
        fromString(s: any, b?: number): void;
        clamp(): void;
        toString(radix: number): string;
        private negate;
        abs(): BigInteger;
        compareTo(a: BigInteger): number;
        private nbits;
        bitLength(): number;
        dlShiftTo(n: number, r: BigInteger): void;
        drShiftTo(n: number, r: BigInteger): void;
        private lShiftTo;
        private rShiftTo;
        subTo(a: BigInteger, r: BigInteger): void;
        multiplyTo(a: BigInteger, r: BigInteger): void;
        squareTo(r: BigInteger): void;
        divRemTo(m: BigInteger, q: BigInteger, r: BigInteger): void;
        mod(a: BigInteger): BigInteger;
        invDigit(): number;
        private isEven;
        private exp;
        modPowInt(e: number, m: BigInteger): BigInteger;
        private clone;
        private intValue;
        private byteValue;
        private shortValue;
        private chunkSize;
        private signum;
        private toRadix;
        private fromRadix;
        static fromNumber(a: number, b: number, c: SecureRandom): BigInteger;
        fromNumber(a: number, b: number, c: SecureRandom): void;
        private fromNumber2;
        toByteArray(): number[];
        private bitwiseTo;
        private op_or;
        private shiftLeft;
        private shiftRight;
        private lbit;
        private getLowestSetBit;
        private testBit;
        private addTo;
        private add;
        subtract(a: BigInteger): BigInteger;
        multiply(a: BigInteger): BigInteger;
        square(): BigInteger;
        divide(a: any): BigInteger;
        private remainder;
        private multiply2;
        addOffset2(n: number, w: number): void;
        multiplyLowerTo(a: BigInteger, n: number, r: BigInteger): void;
        multiplyUpperTo(a: BigInteger, n: number, r: BigInteger): void;
        private modPow;
        gcd(a: BigInteger): BigInteger;
        private modInt;
        modInverse(m: BigInteger): BigInteger;
        isProbablePrime(t: any): boolean;
        private millerRabin;
    }
}
declare namespace Stimulsoft.System.Crypt {
    class RSAKey {
        private n;
        private e;
        private d;
        private p;
        private q;
        private dmp1;
        private dmq1;
        private coeff;
        verifyString(message: string, signature: string): boolean;
        private base64toHex;
        private parseBigInt;
        private pkcs1pad2;
        private pkcs1unpad2;
        setPublic(N: string, E: string): void;
        setPrivate(N: string, E: string, D: string): void;
        setPrivateEx(N: string, E: string, D: string, P: string, Q: string, DP: string, DQ: string, C: string): void;
        generate(B: number, E: string): void;
        doPublic(x: BigInteger): BigInteger;
        private doPrivate;
        encrypt(text: string): string;
        decrypt(ctext: string): string;
        constructor();
    }
}
declare namespace Stimulsoft.System.Crypt {
    class SHA1 {
        private blockLength;
        private state;
        private K;
        static signature: string;
        static hex(data: string): string;
        hex(data: string): string;
        private getMD;
        private rotl;
        private round;
        private paddingData;
        private toHex;
        private fromBigEndian32;
        private toBigEndian32;
        private unpack;
        private pack;
    }
}
declare namespace Stimulsoft.System.Crypt {
    class SHA2 {
        private static HASH_224;
        private static HASH_256;
        private static HASH_384;
        private static HASH_512;
        private static HASH_512_224;
        private static HASH_512_256;
        private static ROUNDS_256;
        private static ROUNDS_512;
        private static HEX_DIGITS;
        private rotate;
        private sigma;
        private sum;
        private aggregate;
        private conglomerate;
        private compress;
        private hash;
        SHA2_224(sData: string): string;
        SHA2_256(sData: string | number[]): string | number[];
        SHA2_384(sData: string | number[]): string | number[];
        SHA2_512(sData: string | number[]): string | number[];
        SHA2_512_224(sData: string): string;
        SHA2_512_256(sData: string): string;
        static SHA256(sData: number[]): number[];
    }
}
declare namespace Stimulsoft.System.Crypt {
    class SecureRandom {
        private state;
        private pool;
        private position;
        private seedInteger;
        private seedTime;
        private getByte;
        nextBytes(ba: number[], count?: number): void;
        createNextBytes(count: number): number[];
        constructor();
    }
}
declare namespace Stimulsoft.ExternalLibrary.aesjs.ModeOfOperation {
    class cbc {
        encrypt(data: number[]): Uint8Array | number[];
        decrypt(data: number[]): Uint8Array | number[];
        constructor(key: number[], iv: number[]);
    }
    class ecb {
        encrypt(data: number[]): Uint8Array | number[];
        decrypt(data: number[]): Uint8Array | number[];
        constructor(key: number[]);
    }
}
declare namespace Stimulsoft.ExternalLibrary.aesjs.padding.pkcs7 {
    class pad extends Array {
        constructor(forEncrypt: number[]);
    }
}
declare namespace Stimulsoft.System.Data {
    class DataStorage {
        values: any[];
        private _column;
        static createStorage(column: DataColumn, type: Type): DataStorage;
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
declare namespace Stimulsoft.System.Data {
    class BooleanStorage extends DataStorage {
        setValue(recordNo: number, value: any): void;
    }
}
declare namespace Stimulsoft.System.Data {
    class ByteArrayStorage extends DataStorage {
    }
}
declare namespace Stimulsoft.System.Data {
    class CharStorage extends DataStorage {
        setValue(recordNo: number, value: any): void;
    }
}
declare namespace Stimulsoft.System.Data {
    class DBNull {
        static value: DBNull;
    }
}
declare namespace Stimulsoft.System.Data {
    class DataColumn {
        clone(): DataColumn;
        private _caption;
        get caption(): string;
        set caption(value: string);
        storage: DataStorage;
        columnName: string;
        dataType: Type;
        table: DataTable;
        getRecord(record: number): any;
        setRecord(record: number, value: any): void;
        setTable(table: DataTable): void;
        delete(): void;
        private insureStorage;
        changeType(dataType: Type): void;
        constructor(columnName: string, dataType?: Type, caption?: string);
    }
}
declare namespace Stimulsoft.System.Data {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class DataColumnCollection extends CollectionBase<DataColumn> {
        table: DataTable;
        private baseAdd;
        private baseRemove;
        add(column: DataColumn): void;
        contains(columnName: string): boolean;
        remove(column: DataColumn): void;
        removeByName(name: string): void;
        getByName(name: string): DataColumn;
        getIndexByName(name: string): number;
        constructor(table: DataTable);
    }
}
declare namespace Stimulsoft.System.Data {
    class DataKey {
        columns: DataColumn[];
        get table(): DataTable;
        get columnsReference(): any[];
        getKeyValues(record: number): any[];
        getRows(values: any[], valueColumns: DataColumn[]): any[];
        toArray(): any[];
        constructor(columns: DataColumn[], copyColumns: boolean);
    }
}
declare namespace Stimulsoft.System.Data {
    class DataRelation {
        childKey: DataKey;
        parentKey: DataKey;
        dataSet: DataSet;
        relationName: string;
        get parentTable(): DataTable;
        get childTable(): DataTable;
        get parentColumns(): any[];
        get childColumns(): any[];
        private create;
        setDataSet(dataSet: DataSet): void;
        static getChildRows(parentKey: DataKey, childKey: DataKey, parentRow: DataRow): any[];
        static getParentRows(parentKey: DataKey, childKey: DataKey, childRow: DataRow): any[];
        constructor(relationName: string, parentColumns: DataColumn[], childColumns: DataColumn[]);
    }
}
declare namespace Stimulsoft.System.Data {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class DataRelationCollection extends CollectionBase<DataRelation> {
        addCore(relation: DataRelation): void;
        add(relation: DataRelation): void;
        addRange(relations: any[]): void;
        internalIndexOf(name: string): number;
        contains(name: string): boolean;
        getByName(name: string): DataRelation;
        getDataSet(): DataSet;
    }
}
declare namespace Stimulsoft.System.Data {
    import List = Stimulsoft.System.Collections.List;
    class DataRow {
        _recordIndex: number;
        get recordIndex(): number;
        static create(table: DataTable): DataRow;
        columns: DataColumnCollection;
        table: DataTable;
        private getColumnIndex;
        gett(column: any): any;
        sett(column: any, value: any): void;
        get itemArray(): any[];
        getValue(column: any): any;
        setValue(column: any, value: any): void;
        getValueByIndex(columnIndex: number): any;
        setValueByIndex(columnIndex: number, value: any): void;
        getDataColumn(columnName: string): DataColumn;
        getChildRows(relationName: string): any[];
        getParentRow(relationName: string): DataRow;
        getParentRows(relationName: string): any[];
        getKeyValues(key: DataKey): any[];
        static copyToDataTable(source: List<DataRow>): DataTable;
    }
}
declare namespace Stimulsoft.System.Data {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class DataRowCollection extends CollectionBase<DataRow> {
        table: DataTable;
        add(row: DataRow): number;
        remove(row: DataRow): void;
        addArray(row: DataRow): number;
        removeArray(row: DataRow): void;
        copyTo(array: any[], startIndex: number): void;
        private replaceValues;
        private quickSort;
        sort(...parameters: any[]): any;
        gett(rowIndex: number, columnIndex: number): any;
        constructor(table: DataTable);
    }
}
declare namespace Stimulsoft.System.Text {
    class XMLConvert {
        static encodeName(name: string): string;
        static decodeName(name: string): string;
        private static fromHex;
        private static toHex;
    }
}
declare namespace Stimulsoft.System.Xml {
    import List = Stimulsoft.System.Collections.List;
    class XmlNode {
        nodeName: string;
        nodeType: XmlNodeType;
        childNodes: List<XmlNode>;
        localName: string;
        textContent: string;
        get firstChild(): XmlNode;
        attributes: XmlAttrCollection;
        parentNode: XmlNode;
        setParentNode(node: XmlNode): void;
        getAttribute(name?: string): string;
        item(index: number): XmlNode;
        getNodeByName(name?: string): XmlNode;
        getNodesByName(name?: string): XmlNode[];
    }
}
declare namespace Stimulsoft.System.Xml {
    enum XmlNodeType {
        ATTRIBUTE_NODE = 0,
        ELEMENT_NODE = 1,
        TEXT_NODE = 2,
        DOCUMENT_NODE = 3
    }
}
declare namespace Stimulsoft.System.Xml {
    class XmlConverter {
        static toXml(xmlString: string): XmlNode;
        static toXml2(xmlString: string): XmlNode;
        private static toXmlNode2;
        private static toXmlNode;
        static getXmlDocumentFromString(xmlString: string): any;
        static getAttributesArray(xmlDocument: any): any[];
        static getNodeType2(xmlDocument: any): number;
        static getNodeType(xmlDocument: any): number;
        static getNodeName(xmlDocument: any): string;
        static getNodeLocalName2(xmlDocument: {
            name: string;
        }): string;
        static getNodeLocalName(xmlDocument: any): string;
        static getText(str: string): string;
        static getChildNodesArray(xmlDocument: any): any[];
    }
}
declare namespace Stimulsoft.System.Data {
    enum JsonRelationDirection {
        ChildToParent = 0,
        ParentToChild = 1
    }
    class DataSet {
        private dataNode;
        private schemaNode;
        private isRetrieveColumns;
        private structureFromSchema;
        dataSetName: string;
        tables: DataTableCollection;
        relations: DataRelationCollection;
        enforceConstraints: boolean;
        private complexTypeNodes;
        private _tryParseDateTime;
        get tryParseDateTime(): boolean;
        set tryParseDateTime(value: boolean);
        static tryParseDateTime: boolean;
        dispose(): void;
        private correctJsonString;
        private correctJson;
        readJsonFile(filePath: string, jsonRelationDirection?: JsonRelationDirection): void;
        readJson(param: string | number[] | Uint8Array | any, jsonRelationDirection?: JsonRelationDirection): void;
        private processObject2;
        private processObject;
        private processTable;
        private processArray;
        readXmlFile(filePath: string): void;
        readXml(param: string | number[] | Uint8Array | any): void;
        readXmlSchemaFile(filePath: string): void;
        readXmlSchema(param: string | number[] | any): void;
        private fillDataSet;
        private parseSchema;
        private parseAdoNetSchema;
        private extractKey;
        private extractReference;
        private extractRelationsFromAdoNetRelationships;
        private parseUnknownSchema;
        private extractTableFromElementNode;
        private extractColumnsFromComplexTypeNode;
        private extractColumnFromElementNode;
        private inferSchemaFromData;
        private inferTableFromNode;
        private inferColumnsFromNode;
        private inferColumnFromNode;
        private fillTable;
        private fillRow;
        private addNodeValueToRowIntoColumn;
        private linkTables;
        private getStorageTypeOrDefault;
        private findTable;
        private findColumns;
        writeXml(writeSchema?: boolean): string;
        private writeXsd;
        private getTypeFromStorageType;
        constructor(dataSetName?: string);
    }
}
declare namespace Stimulsoft.System.Data {
    class DataSetRelationCollection extends DataRelationCollection {
        private dataSet;
        addCore(relation: DataRelation): void;
        getDataSet(): DataSet;
        constructor(dataSet: DataSet);
    }
}
declare namespace Stimulsoft.System.Data {
    import List = Stimulsoft.System.Collections.List;
    class DataTable {
        private needCleanCache;
        private _index;
        get index(): any[];
        columns: DataColumnCollection;
        rows: DataRowCollection;
        tableName: string;
        dataSet: DataSet;
        defaultView: DataView;
        private _childRelations;
        get childRelations(): DataRelationCollection;
        set childRelations(value: DataRelationCollection);
        private _parentRelations;
        get parentRelations(): DataRelationCollection;
        set parentRelations(value: DataRelationCollection);
        setDataSet(dataSet: DataSet): void;
        addRow(row: DataRow): number;
        removeRow(row: DataRow): void;
        addNewRow(): DataRow;
        private _extendedProperties;
        get extendedProperties(): any;
        newRow(): DataRow;
        clone(): DataTable;
        copy(): DataTable;
        toList(): List<DataColumn>;
        loadDataRow(values: any[], acceptChanges?: boolean): DataRow;
        constructor(tableName?: string);
    }
}
declare namespace Stimulsoft.System.Data {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class DataTableCollection extends CollectionBase<DataTable> {
        add(table: DataTable): void;
        remove(table: DataTable): void;
        private baseAdd;
        private baseRemove;
        dataSet: DataSet;
        getByName(name: string): DataTable;
        private checkTableName;
        constructor(dataSet: DataSet);
    }
}
declare namespace Stimulsoft.System.Data {
    class DataTableRelationCollection extends DataRelationCollection {
        private table;
        private parentCollection;
        private addCache;
        addCore(relation: DataRelation): void;
        getDataSet(): DataSet;
        constructor(table: DataTable, parentCollection: boolean);
    }
}
declare namespace Stimulsoft.System.Data {
    class DataView {
        clone(): DataView;
        rowFilter: string;
        sort: string;
        table: DataTable;
        private ands;
        toTable(_and?: boolean): DataTable;
        private filter;
        private parseConditions;
        private parse;
        constructor(table: DataTable);
    }
}
declare namespace Stimulsoft.System.Data {
    class DateTimeStorage extends DataStorage {
        setValue(recordNo: number, value: any): void;
    }
}
declare namespace Stimulsoft.System.Data {
    class NumberStorage extends DataStorage {
        setValue(recordNo: number, value: any): void;
    }
}
declare namespace Stimulsoft.System.Data {
    class ObjectStorage extends DataStorage {
    }
}
declare namespace Stimulsoft.System.Data {
    enum StorageType {
        ObjectType = 1,
        BooleanType = 3,
        CharType = 4,
        SByteType = 5,
        ByteType = 6,
        Number16Type = 7,
        Unumber16Type = 8,
        NumberType = 9,
        Number32Type = 9,
        Unumber32Type = 10,
        Number64Type = 11,
        Unumber64Type = 12,
        SingleType = 13,
        DoubleType = 14,
        DecimalType = 15,
        DateTimeType = 16,
        TimeSpanType = 17,
        StringType = 18,
        GuidType = 19,
        ByteArrayType = 20,
        IntType = 30,
        Int16Type = 31,
        Int32Type = 32,
        Int64Type = 33,
        UInt16Type = 34,
        UInt32Type = 35,
        UInt64Type = 36
    }
}
declare namespace Stimulsoft.System.Data {
    class StringStorage extends DataStorage {
        setValue(recordNo: number, value: any): void;
    }
}
declare namespace Stimulsoft.System.Data {
    class TimeSpanStorage extends DataStorage {
        setValue(recordNo: number, value: any): void;
    }
}
declare namespace Stimulsoft.System.Drawing {
    import IAsIs = Stimulsoft.System.IAsIs;
    class Brush implements IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
    }
}
declare namespace Stimulsoft.System.Drawing {
    class Brushes {
        static get aliceBlue(): Brush;
        static get antiqueWhite(): Brush;
        static get aqua(): Brush;
        static get aquamarine(): Brush;
        static get azure(): Brush;
        static get beige(): Brush;
        static get bisque(): Brush;
        static get black(): Brush;
        static get blanchedAlmond(): Brush;
        static get blue(): Brush;
        static get blueViolet(): Brush;
        static get brown(): Brush;
        static get burlyWood(): Brush;
        static get cadetBlue(): Brush;
        static get chartreuse(): Brush;
        static get chocolate(): Brush;
        static get coral(): Brush;
        static get cornflowerBlue(): Brush;
        static get cornsilk(): Brush;
        static get crimson(): Brush;
        static get cyan(): Brush;
        static get darkBlue(): Brush;
        static get darkCyan(): Brush;
        static get darkGoldenrod(): Brush;
        static get darkGray(): Brush;
        static get darkGreen(): Brush;
        static get darkKhaki(): Brush;
        static get darkMagenta(): Brush;
        static get darkOliveGreen(): Brush;
        static get darkOrange(): Brush;
        static get darkOrchid(): Brush;
        static get darkRed(): Brush;
        static get darkSalmon(): Brush;
        static get darkSeaGreen(): Brush;
        static get darkSlateBlue(): Brush;
        static get darkSlateGray(): Brush;
        static get darkTurquoise(): Brush;
        static get darkViolet(): Brush;
        static get deepPink(): Brush;
        static get deepSkyBlue(): Brush;
        static get dimGray(): Brush;
        static get dodgerBlue(): Brush;
        static get firebrick(): Brush;
        static get floralWhite(): Brush;
        static get forestGreen(): Brush;
        static get fuchsia(): Brush;
        static get gainsboro(): Brush;
        static get ghostWhite(): Brush;
        static get gold(): Brush;
        static get goldenrod(): Brush;
        static get gray(): Brush;
        static get green(): Brush;
        static get greenYellow(): Brush;
        static get honeydew(): Brush;
        static get hotPink(): Brush;
        static get indianRed(): Brush;
        static get indigo(): Brush;
        static get ivory(): Brush;
        static get khaki(): Brush;
        static get lavender(): Brush;
        static get lavenderBlush(): Brush;
        static get lawnGreen(): Brush;
        static get lemonChiffon(): Brush;
        static get lightBlue(): Brush;
        static get lightCoral(): Brush;
        static get lightCyan(): Brush;
        static get lightGoldenrodYellow(): Brush;
        static get lightGray(): Brush;
        static get lightGreen(): Brush;
        static get lightPink(): Brush;
        static get lightSalmon(): Brush;
        static get lightSeaGreen(): Brush;
        static get lightSkyBlue(): Brush;
        static get lightSlateGray(): Brush;
        static get lightSteelBlue(): Brush;
        static get lightYellow(): Brush;
        static get lime(): Brush;
        static get limeGreen(): Brush;
        static get linen(): Brush;
        static get magenta(): Brush;
        static get maroon(): Brush;
        static get mediumAquamarine(): Brush;
        static get mediumBlue(): Brush;
        static get mediumOrchid(): Brush;
        static get mediumPurple(): Brush;
        static get mediumSeaGreen(): Brush;
        static get mediumSlateBlue(): Brush;
        static get mediumSpringGreen(): Brush;
        static get mediumTurquoise(): Brush;
        static get mediumVioletRed(): Brush;
        static get midnightBlue(): Brush;
        static get mintCream(): Brush;
        static get mistyRose(): Brush;
        static get moccasin(): Brush;
        static get navajoWhite(): Brush;
        static get navy(): Brush;
        static get oldLace(): Brush;
        static get olive(): Brush;
        static get oliveDrab(): Brush;
        static get orange(): Brush;
        static get orangeRed(): Brush;
        static get orchid(): Brush;
        static get paleGoldenrod(): Brush;
        static get paleGreen(): Brush;
        static get paleTurquoise(): Brush;
        static get paleVioletRed(): Brush;
        static get papayaWhip(): Brush;
        static get peachPuff(): Brush;
        static get peru(): Brush;
        static get pink(): Brush;
        static get plum(): Brush;
        static get powderBlue(): Brush;
        static get purple(): Brush;
        static get red(): Brush;
        static get rosyBrown(): Brush;
        static get royalBlue(): Brush;
        static get saddleBrown(): Brush;
        static get salmon(): Brush;
        static get sandyBrown(): Brush;
        static get seaGreen(): Brush;
        static get seaShell(): Brush;
        static get sienna(): Brush;
        static get silver(): Brush;
        static get skyBlue(): Brush;
        static get slateBlue(): Brush;
        static get slateGray(): Brush;
        static get snow(): Brush;
        static get springGreen(): Brush;
        static get steelBlue(): Brush;
        static get tan(): Brush;
        static get teal(): Brush;
        static get thistle(): Brush;
        static get tomato(): Brush;
        static get turquoise(): Brush;
        static get violet(): Brush;
        static get wheat(): Brush;
        static get white(): Brush;
        static get whiteSmoke(): Brush;
        static get yellow(): Brush;
        static get yellowGreen(): Brush;
    }
}
declare namespace Stimulsoft.System.Drawing {
    class Color {
        static get aliceBlue(): Color;
        static get antiqueWhite(): Color;
        static get aqua(): Color;
        static get aquamarine(): Color;
        static get azure(): Color;
        static get beige(): Color;
        static get bisque(): Color;
        static get black(): Color;
        static get blanchedAlmond(): Color;
        static get blue(): Color;
        static get blueViolet(): Color;
        static get brown(): Color;
        static get burlyWood(): Color;
        static get cadetBlue(): Color;
        static get chartreuse(): Color;
        static get chocolate(): Color;
        static get coral(): Color;
        static get cornflowerBlue(): Color;
        static get cornsilk(): Color;
        static get crimson(): Color;
        static get cyan(): Color;
        static get darkBlue(): Color;
        static get darkCyan(): Color;
        static get darkGoldenrod(): Color;
        static get darkGray(): Color;
        static get darkGreen(): Color;
        static get darkKhaki(): Color;
        static get darkMagenta(): Color;
        static get darkOliveGreen(): Color;
        static get darkOrange(): Color;
        static get darkOrchid(): Color;
        static get darkRed(): Color;
        static get darkSalmon(): Color;
        static get darkSeaGreen(): Color;
        static get darkSlateBlue(): Color;
        static get darkSlateGray(): Color;
        static get darkTurquoise(): Color;
        static get darkViolet(): Color;
        static get deepPink(): Color;
        static get deepSkyBlue(): Color;
        static get dimGray(): Color;
        static get dodgerBlue(): Color;
        static get firebrick(): Color;
        static get floralWhite(): Color;
        static get forestGreen(): Color;
        static get fuchsia(): Color;
        static get gainsboro(): Color;
        static get ghostWhite(): Color;
        static get gold(): Color;
        static get goldenrod(): Color;
        static get gray(): Color;
        static get green(): Color;
        static get greenYellow(): Color;
        static get honeydew(): Color;
        static get hotPink(): Color;
        static get indianRed(): Color;
        static get indigo(): Color;
        static get ivory(): Color;
        static get khaki(): Color;
        static get lavender(): Color;
        static get lavenderBlush(): Color;
        static get lawnGreen(): Color;
        static get lemonChiffon(): Color;
        static get lightBlue(): Color;
        static get lightCoral(): Color;
        static get lightCyan(): Color;
        static get lightGoldenrodYellow(): Color;
        static get lightGray(): Color;
        static get lightGreen(): Color;
        static get lightPink(): Color;
        static get lightSalmon(): Color;
        static get lightSeaGreen(): Color;
        static get lightSkyBlue(): Color;
        static get lightSlateGray(): Color;
        static get lightSteelBlue(): Color;
        static get lightYellow(): Color;
        static get lime(): Color;
        static get limeGreen(): Color;
        static get linen(): Color;
        static get magenta(): Color;
        static get maroon(): Color;
        static get mediumAquamarine(): Color;
        static get mediumBlue(): Color;
        static get mediumOrchid(): Color;
        static get mediumPurple(): Color;
        static get mediumSeaGreen(): Color;
        static get mediumSlateBlue(): Color;
        static get mediumSpringGreen(): Color;
        static get mediumTurquoise(): Color;
        static get mediumVioletRed(): Color;
        static get midnightBlue(): Color;
        static get mintCream(): Color;
        static get mistyRose(): Color;
        static get moccasin(): Color;
        static get navajoWhite(): Color;
        static get navy(): Color;
        static get oldLace(): Color;
        static get olive(): Color;
        static get oliveDrab(): Color;
        static get orange(): Color;
        static get orangeRed(): Color;
        static get orchid(): Color;
        static get paleGoldenrod(): Color;
        static get paleGreen(): Color;
        static get paleTurquoise(): Color;
        static get paleVioletRed(): Color;
        static get papayaWhip(): Color;
        static get peachPuff(): Color;
        static get peru(): Color;
        static get pink(): Color;
        static get plum(): Color;
        static get powderBlue(): Color;
        static get purple(): Color;
        static get red(): Color;
        static get rosyBrown(): Color;
        static get royalBlue(): Color;
        static get saddleBrown(): Color;
        static get salmon(): Color;
        static get sandyBrown(): Color;
        static get seaGreen(): Color;
        static get seaShell(): Color;
        static get sienna(): Color;
        static get silver(): Color;
        static get skyBlue(): Color;
        static get slateBlue(): Color;
        static get slateGray(): Color;
        static get snow(): Color;
        static get springGreen(): Color;
        static get steelBlue(): Color;
        static get tan(): Color;
        static get teal(): Color;
        static get thistle(): Color;
        static get tomato(): Color;
        static get turquoise(): Color;
        static get violet(): Color;
        static get wheat(): Color;
        static get white(): Color;
        static get whiteSmoke(): Color;
        static get yellow(): Color;
        static get yellowGreen(): Color;
        static get transparent(): Color;
        static get empty(): Color;
        static fromName(name: string): Color;
        private _a;
        get a(): number;
        set a(value: number);
        private _r;
        get r(): number;
        set r(value: number);
        private _g;
        get g(): number;
        set g(value: number);
        private _b;
        get b(): number;
        set b(value: number);
        private static customName;
        name: string;
        get isNamedColor(): boolean;
        equals(color: Color): boolean;
        toString(): string;
        static fromArgb(alpha: number, red?: any, green?: number, blue?: number): Color;
        toArgb(): number;
        getHashCode(): number;
    }
}
declare namespace Stimulsoft.System.Drawing {
    class ColorTranslator {
        private static colorCache;
        static toHtml(color: Color): string;
        static toHtml2(color: Color, useNamedColor: boolean): string;
        static fromHtml(text: string): Color;
    }
}
declare namespace Stimulsoft.System.Drawing {
    enum ContentAlignment {
        TopLeft = 1,
        TopCenter = 2,
        TopRight = 4,
        MiddleLeft = 16,
        MiddleCenter = 32,
        MiddleRight = 64,
        BottomLeft = 256,
        BottomCenter = 512,
        BottomRight = 1024
    }
}
declare namespace Stimulsoft.System.Drawing {
    class Font implements ICloneable {
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        private _fontFamily;
        get fontFamily(): FontFamily;
        get name(): string;
        private _size;
        get size(): number;
        get sizeInPoints(): number;
        private _style;
        get style(): FontStyle;
        private _unit;
        get unit(): GraphicsUnit;
        get bold(): boolean;
        get italic(): boolean;
        get strikeout(): boolean;
        get underline(): boolean;
        private _toString;
        toString(): string;
        private _height;
        getHeight(): number;
        private hashCode;
        getHashCode(): number;
        constructor(family?: string, emSize?: number, style?: FontStyle, unit?: GraphicsUnit);
    }
}
declare namespace Stimulsoft.System.Drawing {
    class FontFamily {
        private static _families;
        static get families(): FontFamily[];
        private _name;
        get name(): string;
        isStyleAvailable(style: FontStyle): boolean;
        static cleanFamilies(): void;
        constructor(name: string);
    }
}
declare namespace Stimulsoft.System.Drawing {
    class FontResources {
        static getSize(font: Font, text: string): Size;
        private static _standardFontWidths;
        static get standardFontWidths(): any[];
        private static _standardFontInfo;
        static get standardFontInfo(): any[];
        private static family_Helvetica;
        private static family_Courier;
        private static family_Times_Roman;
        private static fontName;
    }
}
declare namespace Stimulsoft.System.Drawing {
    enum FontStyle {
        Regular = 0,
        Bold = 1,
        Italic = 2,
        Strikeout = 4,
        Underline = 8
    }
}
declare namespace Stimulsoft.System.Drawing {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    type OpentypeFontType = {
        font: any;
        data: any;
        filePath: string;
        autoLoad?: boolean;
        used?: boolean;
    };
    export class Graphics {
        private context;
        static measureBearingScale: number;
        drawImage(image: Image, point: Point): void;
        drawRectangle(pen: Pen, rect: Rectangle): void;
        fillRectangle(brush: Brush, x: number, y: number, width: number, height: number): void;
        drawLine(pen: Pen, x1: number, y1: number, x2: number, y2: number): void;
        drawString(text: string, font: Font, brush: Brush, x: number, y: number): void;
        translateTransform(dx: number, dy: number): void;
        static opentypeFonts: Hashtable<string, Hashtable<FontStyle, OpentypeFontType>>;
        static getOpentypeFont(fontName: string, fontStyle: FontStyle): any;
        static clearAutoLoadFonts(): void;
        static addOpentypeFont(font: any, fontName?: string, binFont?: any, filePath?: string, fontStyle?: FontStyle, store?: boolean): void;
        static addOpentypeFontFile(filePath: string, fontName?: string, fontStyle?: FontStyle, store?: boolean): void;
        static addOpentypeFontFileAsync(callback: () => {}, filePath: string, fontName?: string, fontStyle?: FontStyle, store?: boolean): void;
        static getCustomFontsCss(): string;
        static getCustomFontName(fontName: string, fontStyle: FontStyle): string;
        static allowStyle(fontName: string, fontStyle: FontStyle): boolean;
        private static measureDiv;
        private static measureHash;
        static measureString(text: string, font: Font, width?: number, useCache?: boolean, multiple?: number, angle?: number, replaceTags?: boolean): Size;
        private static isWordWrapSymbol;
        static measureChars(chars: number[], count: number, font: Font): Size;
        private static rotate;
        static clearCache(): void;
        constructor(context: CanvasRenderingContext2D);
    }
    export {};
}
declare namespace Stimulsoft.System.Drawing {
    enum GraphicsUnit {
        Pixel = 2,
        Point = 3
    }
}
declare namespace Stimulsoft.System.Drawing.Imaging {
    class ImageFormat {
        private static _tiff;
        static get Tiff(): ImageFormat;
        private static _png;
        static get Png(): ImageFormat;
        private static _gif;
        static get Gif(): ImageFormat;
        private static _jpeg;
        static get Jpeg(): ImageFormat;
        private static _bmp;
        static get Bmp(): ImageFormat;
        private static _svg;
        static get Svg(): ImageFormat;
        static getImageFormat(dataBytes: number[]): ImageFormat;
        private header;
        private guid;
        private checkHeader;
        getWidth(dataBytes: number[], base64?: string): number;
        getHeight(dataBytes: number[], base64?: string): number;
        getHorizontalResolution(dataBytes: number[]): number;
        getVerticalResolution(dataBytes: number[]): number;
        get mimeType(): string;
        toString(): string;
        constructor(guid: string);
    }
}
declare namespace Stimulsoft.System.Drawing {
    import ImageFormat = Stimulsoft.System.Drawing.Imaging.ImageFormat;
    class Image {
        data: any;
        private _imageFormat;
        get imageFormat(): ImageFormat;
        private _width;
        get width(): number;
        private _height;
        get height(): number;
        private _horizontalResolution;
        get horizontalResolution(): number;
        private _verticalResolution;
        get verticalResolution(): number;
        imageData: any;
        get base64(): string;
        set base64(value: string);
        get bytes(): number[];
        set bytes(value: number[]);
        static fromFile(path: string): Image;
        static fromBytes(bytes: number[]): Image;
        static fromBase64(base64: string): Image;
        private setData;
        convertAsync(imageFormat: ImageFormat, flate?: boolean, rect?: Rectangle): Promise<Image>;
        tryConvertSync(imageFormat: ImageFormat): boolean;
        dispose(): void;
        clone(): Image;
        aspectRatio: boolean;
        multipleFactor: number;
        margins: any;
        horAlignment: number;
        vertAlignment: number;
        imageRotation: number;
        stretch: boolean;
        zoom: number;
        url: string;
    }
}
declare namespace Stimulsoft.System.Drawing {
    enum Orientation {
        Horizontal = 0,
        Vertical = 1
    }
}
declare namespace Stimulsoft.System.Drawing {
    import LineCap = Stimulsoft.System.Drawing.Drawing2D.LineCap;
    import DashStyle = Stimulsoft.System.Drawing.Drawing2D.DashStyle;
    class Pen {
        brush: Brush;
        color: Color;
        endCap: LineCap;
        startCap: LineCap;
        width: number;
        dashStyle: DashStyle;
        lineJoin: string;
        constructor(color: Color);
    }
}
declare namespace Stimulsoft.System.Drawing {
    class Point {
        x: number;
        y: number;
        get isEmpty(): boolean;
        static get empty(): Point;
        toString(): string;
        equals(point: Point): boolean;
        constructor(x?: number, y?: number);
    }
}
declare namespace Stimulsoft.System.Drawing {
    class Rectangle {
        clone(): Rectangle;
        static get empty(): Rectangle;
        static union(a: Rectangle, b: Rectangle): Rectangle;
        inflate(width: number, height: number): Rectangle;
        normalize(): Rectangle;
        multiply(multipleFactor: number): Rectangle;
        offsetRect(offsettingRectangle: Rectangle): Rectangle;
        intersectsWith(rect: Rectangle): boolean;
        alignToGrid(gridSize: number, aligningToGrid: boolean): Rectangle;
        fitToRectangle(rectangle: Rectangle): Rectangle;
        get isEmpty(): boolean;
        get isEmptyF(): boolean;
        contains(x: number, y: number): boolean;
        static convertFromXml(text: string): Rectangle;
        x: number;
        y: number;
        width: number;
        height: number;
        get left(): number;
        set left(value: number);
        get top(): number;
        set top(value: number);
        get right(): number;
        set right(value: number);
        get bottom(): number;
        set bottom(value: number);
        get location(): Point;
        set location(value: Point);
        get size(): Size;
        set size(value: Size);
        toString(): string;
        constructor(x?: number, y?: number, width?: number, height?: number);
    }
}
declare namespace Stimulsoft.System.Drawing {
    class Size {
        static get empty(): Size;
        width: number;
        height: number;
        get isEmpty(): boolean;
        isDefault(): boolean;
        swap(): Size;
        round(digits?: number): Size;
        static convertFromXml(text: string): Size;
        constructor(width: number, height: number);
    }
}
declare namespace Stimulsoft.System.Drawing {
    class SolidBrush extends Brush {
        color: Color;
        constructor(color: Color);
    }
}
declare namespace Stimulsoft.System.Drawing {
    enum StringAlignment {
        Near = 0,
        Center = 1,
        Far = 2
    }
}
declare namespace Stimulsoft.System.Drawing {
    import HotkeyPrefix = Stimulsoft.System.Drawing.Text.HotkeyPrefix;
    class StringFormat {
        alignment: StringAlignment;
        formatFlags: StringFormatFlags;
        hotkeyPrefix: HotkeyPrefix;
        lineAlignment: StringAlignment;
        trimming: StringTrimming;
    }
}
declare namespace Stimulsoft.System.Drawing {
    enum StringFormatFlags {
        DirectionRightToLeft = 1,
        DirectionVertical = 2,
        FitBlackBox = 4,
        DisplayFormatControl = 32,
        NoFontFallback = 1024,
        MeasureTrailingSpaces = 2048,
        NoWrap = 4096,
        LineLimit = 8192,
        NoClip = 16384
    }
}
declare namespace Stimulsoft.System.Drawing {
    enum StringTrimming {
        None = 0,
        Character = 1,
        Word = 2,
        EllipsisCharacter = 3,
        EllipsisWord = 4,
        EllipsisPath = 5
    }
}
declare namespace Stimulsoft.System.Drawing.Drawing2D {
    enum DashStyle {
        Solid = 0,
        Dash = 1,
        Dot = 2,
        DashDot = 3,
        DashDotDot = 4,
        Custom = 5
    }
}
declare namespace Stimulsoft.System.Drawing.Drawing2D {
    enum HatchStyle {
        Min = 0,
        Horizontal = 0,
        Vertical = 1,
        ForwardDiagonal = 2,
        BackwardDiagonal = 3,
        Max = 4,
        Cross = 4,
        LargeGrid = 4,
        DiagonalCross = 5,
        Percent05 = 6,
        Percent10 = 7,
        Percent20 = 8,
        Percent25 = 9,
        Percent30 = 10,
        Percent40 = 11,
        Percent50 = 12,
        Percent60 = 13,
        Percent70 = 14,
        Percent75 = 15,
        Percent80 = 16,
        Percent90 = 17,
        LightDownwardDiagonal = 18,
        LightUpwardDiagonal = 19,
        DarkDownwardDiagonal = 20,
        DarkUpwardDiagonal = 21,
        WideDownwardDiagonal = 22,
        WideUpwardDiagonal = 23,
        LightVertical = 24,
        LightHorizontal = 25,
        NarrowVertical = 26,
        NarrowHorizontal = 27,
        DarkVertical = 28,
        DarkHorizontal = 29,
        DashedDownwardDiagonal = 30,
        DashedUpwardDiagonal = 31,
        DashedHorizontal = 32,
        DashedVertical = 33,
        SmallConfetti = 34,
        LargeConfetti = 35,
        ZigZag = 36,
        Wave = 37,
        DiagonalBrick = 38,
        HorizontalBrick = 39,
        Weave = 40,
        Plaid = 41,
        Divot = 42,
        DottedGrid = 43,
        DottedDiamond = 44,
        Shingle = 45,
        Trellis = 46,
        Sphere = 47,
        SmallGrid = 48,
        SmallCheckerBoard = 49,
        LargeCheckerBoard = 50,
        OutlinedDiamond = 51,
        SolidDiamond = 52
    }
}
declare namespace Stimulsoft.System.Drawing.Drawing2D {
    enum LineCap {
        AnchorMask = 240,
        ArrowAnchor = 20,
        Custom = 255,
        DiamondAnchor = 19,
        Flat = 0,
        NoAnchor = 16,
        Round = 2,
        RoundAnchor = 18,
        Square = 1,
        SquareAnchor = 17,
        Triangle = 3
    }
}
declare namespace Stimulsoft.System.Drawing.Drawing2D {
    import Point = Stimulsoft.System.Drawing.Point;
    class Matrix {
        a: number;
        c: number;
        b: number;
        d: number;
        tx: number;
        ty: number;
        get elements(): number[];
        constructor(...arg: any[]);
        private setValues;
        private reset;
        clone(): Matrix;
        toString(): string;
        translate(x: number, y: number): Matrix;
        scale(scaleX: number, scaleY: number): Matrix;
        rotate(angle: number): Matrix;
        isIdentity(): boolean;
        transformPoints(points: Point[]): void;
        multiply(matrix2: Matrix): this;
    }
}
declare namespace Stimulsoft.System.Drawing.Imaging {
    enum EncoderValue {
        ColorTypeCMYK = 0,
        ColorTypeYCCK = 1,
        CompressionLZW = 2,
        CompressionCCITT3 = 3,
        CompressionCCITT4 = 4,
        CompressionRle = 5,
        CompressionNone = 6,
        ScanMethodInterlaced = 7,
        ScanMethodNonInterlaced = 8,
        VersionGif87 = 9,
        VersionGif89 = 10,
        RenderProgressive = 11,
        RenderNonProgressive = 12,
        TransformRotate90 = 13,
        TransformRotate180 = 14,
        TransformRotate270 = 15,
        TransformFlipHorizontal = 16,
        TransformFlipVertical = 17,
        MultiFrame = 18,
        LastFrame = 19,
        Flush = 20,
        FrameDimensionTime = 21,
        FrameDimensionResolution = 22,
        FrameDimensionPage = 23
    }
}
declare namespace Stimulsoft.System.Drawing.Imaging {
    class ImageCodecInfo {
        clsid: Guid;
        codecName: string;
        filenameExtension: string;
        formatDescription: string;
        formatID: Guid;
        mimeType: string;
        version: number;
        static getImageDecoders(): ImageCodecInfo[];
        static getImageEncoders(): ImageCodecInfo[];
    }
}
declare namespace Stimulsoft.System.Drawing.Printing {
    enum PaperKind {
        A2 = 66,
        A3 = 8,
        A3Extra = 63,
        A3ExtraTransverse = 68,
        A3Rotated = 76,
        A3Transverse = 67,
        A4 = 9,
        A4Extra = 53,
        A4Plus = 60,
        A4Rotated = 77,
        A4Small = 10,
        A4Transverse = 55,
        A5 = 11,
        A5Extra = 64,
        A5Rotated = 78,
        A5Transverse = 61,
        A6 = 70,
        A6Rotated = 83,
        APlus = 57,
        B4 = 12,
        B4Envelope = 33,
        B4JisRotated = 79,
        B5 = 13,
        B5Envelope = 34,
        B5Extra = 65,
        B5JisRotated = 80,
        B5Transverse = 62,
        B6Envelope = 35,
        B6Jis = 88,
        B6JisRotated = 89,
        BPlus = 58,
        C3Envelope = 29,
        C4Envelope = 30,
        C5Envelope = 28,
        C65Envelope = 32,
        C6Envelope = 31,
        CSheet = 24,
        Custom = 0,
        DLEnvelope = 27,
        DSheet = 25,
        ESheet = 26,
        Executive = 7,
        Folio = 14,
        GermanLegalFanfold = 41,
        GermanStandardFanfold = 40,
        InviteEnvelope = 47,
        IsoB4 = 42,
        ItalyEnvelope = 36,
        JapaneseDoublePostcard = 69,
        JapaneseDoublePostcardRotated = 82,
        JapaneseEnvelopeChouNumber3 = 73,
        JapaneseEnvelopeChouNumber3Rotated = 86,
        JapaneseEnvelopeChouNumber4 = 74,
        JapaneseEnvelopeChouNumber4Rotated = 87,
        JapaneseEnvelopeKakuNumber2 = 71,
        JapaneseEnvelopeKakuNumber2Rotated = 84,
        JapaneseEnvelopeKakuNumber3 = 72,
        JapaneseEnvelopeKakuNumber3Rotated = 85,
        JapaneseEnvelopeYouNumber4 = 91,
        JapaneseEnvelopeYouNumber4Rotated = 92,
        JapanesePostcard = 43,
        JapanesePostcardRotated = 81,
        Ledger = 4,
        Legal = 5,
        LegalExtra = 51,
        Letter = 1,
        LetterExtra = 50,
        LetterExtraTransverse = 56,
        LetterPlus = 59,
        LetterRotated = 75,
        LetterSmall = 2,
        LetterTransverse = 54,
        MonarchEnvelope = 37,
        Note = 18,
        Number10Envelope = 20,
        Number11Envelope = 21,
        Number12Envelope = 22,
        Number14Envelope = 23,
        Number9Envelope = 19,
        PersonalEnvelope = 38,
        Prc16K = 93,
        Prc16KRotated = 106,
        Prc32K = 94,
        Prc32KBig = 95,
        Prc32KBigRotated = 108,
        Prc32KRotated = 107,
        PrcEnvelopeNumber1 = 96,
        PrcEnvelopeNumber10 = 105,
        PrcEnvelopeNumber10Rotated = 118,
        PrcEnvelopeNumber1Rotated = 109,
        PrcEnvelopeNumber2 = 97,
        PrcEnvelopeNumber2Rotated = 110,
        PrcEnvelopeNumber3 = 98,
        PrcEnvelopeNumber3Rotated = 111,
        PrcEnvelopeNumber4 = 99,
        PrcEnvelopeNumber4Rotated = 112,
        PrcEnvelopeNumber5 = 100,
        PrcEnvelopeNumber5Rotated = 113,
        PrcEnvelopeNumber6 = 101,
        PrcEnvelopeNumber6Rotated = 114,
        PrcEnvelopeNumber7 = 102,
        PrcEnvelopeNumber7Rotated = 115,
        PrcEnvelopeNumber8 = 103,
        PrcEnvelopeNumber8Rotated = 116,
        PrcEnvelopeNumber9 = 104,
        PrcEnvelopeNumber9Rotated = 117,
        Quarto = 15,
        Standard10x11 = 45,
        Standard10x14 = 16,
        Standard11x17 = 17,
        Standard12x11 = 90,
        Standard15x11 = 46,
        Standard9x11 = 44,
        Statement = 6,
        Tabloid = 3,
        TabloidExtra = 52,
        USStandardFanfold = 39
    }
}
declare namespace Stimulsoft.System.Drawing.Printing {
    class PaperSize {
        private createdByDefaultConstructor;
        private _kind;
        get kind(): number;
        private _name;
        get name(): string;
        set name(value: string);
        private _width;
        get width(): number;
        set width(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        constructor(kind?: number, name?: string, width?: number, height?: number);
    }
}
declare namespace Stimulsoft.System.Drawing.Printing {
    enum PrinterUnit {
        Display = 0,
        ThousandthsOfAnInch = 1,
        HundredthsOfAMillimeter = 2,
        TenthsOfAMillimeter = 3
    }
}
declare namespace Stimulsoft.System.Drawing.Printing {
    class PrinterUnitConvert {
        static convert(value: number, fromUnit: PrinterUnit, toUnit: PrinterUnit): number;
        private static unitsPerDisplay;
    }
}
declare namespace Stimulsoft.System.Drawing.Printing.PrinterSettings {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class PaperSizeCollection extends CollectionBase<PaperSize> {
    }
}
declare namespace Stimulsoft.System.Drawing.Printing.PrinterSettings {
    class PrinterSettings {
        get paperSizes(): PaperSizeCollection;
    }
}
declare namespace Stimulsoft.System.Drawing.Text {
    enum HotkeyPrefix {
        Hide = 0,
        None = 1,
        Show = 2
    }
}
declare namespace Stimulsoft.System.Globalization {
    class Calendar {
        static getWeekOfYear(time: DateTime, rule?: CalendarWeekRule, firstDayOfWeek?: DayOfWeek): number;
        private static getFirstDayWeekOfYear;
        private static getWeekOfYearFullDays;
        static getDaysInYear(year: number): number;
        static getWeekOfMonth(time: DateTime, rule?: CalendarWeekRule, firstDayOfWeek?: DayOfWeek): number;
    }
}
declare namespace Stimulsoft.System.Globalization {
    enum CalendarWeekRule {
        FirstDay = 0,
        FirstFullWeek = 1,
        FirstFourDayWeek = 2
    }
}
declare namespace Stimulsoft.System.Globalization {
    class RegionInfo {
        name: string;
        nativeName: string;
        threeLetterISORegionName: string;
        threeLetterWindowsRegionName: string;
        twoLetterISORegionName: string;
        constructor(name: string);
    }
}
declare namespace Stimulsoft.System.IO {
    enum SeekOrigin {
        Begin = 0,
        Current = 1,
        End = 2
    }
}
declare namespace Stimulsoft.System.IO {
    class File {
        static getFile(filePath: string, binary?: boolean, contentType?: string, headers?: {
            key: string;
            value: string;
        }[]): any;
        static getFileAsync(callback: Function, filePath: string, binary?: boolean, contentType?: string): void;
        static saveFile(filePath: string, fileData: string): void;
        static getFilesNames(filePath: string): string[];
    }
}
declare namespace Stimulsoft.System.IO {
    class Http {
        static getFile(filePath: string, binary?: boolean, contentType?: string, headers?: {
            key: string;
            value: string;
        }[]): any;
        static getFileAsync(callback: Function, filePath: string, binary?: boolean, contentType?: string): void;
        static getUrlParameters(): {
            name: string;
            value: string;
        }[];
    }
}
declare namespace Stimulsoft.System.IO {
    class MemoryStream {
        private static memStreamMaxLength;
        private _origin;
        private _buffer;
        private _position;
        get position(): number;
        get length(): number;
        get canSeek(): boolean;
        get canWrite(): boolean;
        setLength(length: number): void;
        toArray(): number[];
        writeTo(stream: MemoryStream): void;
        writeByte(byte: number): void;
        write(array: number[], offset?: number, length?: number): void;
        writeBytes(array: Uint8Array, offset?: number, length?: number): void;
        writeLine1(inputString?: string, ...values: any[]): void;
        writeLine(inputString?: string): void;
        writeString(inputString: string, newLine?: boolean): void;
        read(array: number[], offset?: number, length?: number): number;
        seek(offset: number, origin: SeekOrigin): number;
        flush(): void;
        close(): void;
        copyTo(stream: MemoryStream): void;
        constructor(array?: number[]);
    }
}
declare namespace Stimulsoft.System.IO {
    class Path {
        static Combine(path1: string, path2: string): string;
        static getFileNameWithoutExtension(path: string): string;
        static getExtension(path: string): string;
        static getSep(): string;
    }
}
declare namespace Stimulsoft.System.IO {
    import Encoding = Stimulsoft.System.Text.Encoding;
    class StreamReader {
        private stream;
        private encoding;
        constructor(stream: MemoryStream, encoding?: Encoding);
        read(): string;
        readLine(): string;
        private readLineInternal;
    }
}
declare namespace Stimulsoft.System.Text {
    class Encoding {
        private static CodePageDefault;
        private static CodePageNoOEM;
        private static CodePageNoMac;
        private static CodePageNoThread;
        private static CodePageNoSymbol;
        private static CodePageUnicode;
        private static CodePageBigEndian;
        private static CodePageWindows1251;
        private static CodePageWindows1252;
        private static CodePageMacGB2312;
        private static CodePageGB2312;
        private static CodePageMacKorean;
        private static CodePageDLLKorean;
        private static ISO2022JP;
        private static ISO2022JPESC;
        private static ISO2022JPSISO;
        private static ISOKorean;
        private static ISOSimplifiedCN;
        private static EUCJP;
        private static ChineseHZ;
        private static DuplicateEUCCN;
        private static EUCCN;
        private static EUCKR;
        private static CodePageASCII;
        private static ISO_8859_1;
        private static ISCIIAssemese;
        private static ISCIIBengali;
        private static ISCIIDevanagari;
        private static ISCIIGujarathi;
        private static ISCIIKannada;
        private static ISCIIMalayalam;
        private static ISCIIOriya;
        private static ISCIIPanjabi;
        private static ISCIITamil;
        private static ISCIITelugu;
        private static GB18030;
        private static ISO_8859_8I;
        private static ISO_8859_8_Visual;
        private static ENC50229;
        private static CodePageUTF7;
        private static CodePageUTF8;
        private static CodePageUTF32;
        private static CodePageUTF32BE;
        static ASCII: Encoding;
        static BigEndianUnicode: Encoding;
        static Default: Encoding;
        static Unicode: Encoding;
        static UTF32: Encoding;
        static UTF7: Encoding;
        static UTF8: Encoding;
        static Windows1251: Encoding;
        private static _windows_1251;
        private _webName;
        get webName(): string;
        private _encodingName;
        get encodingName(): string;
        getBytes(str: string): number[];
        getString(bytes: number[] | Uint8Array): string;
        static getEncoding(codepage: number): Encoding;
        private static fromCodePageToUnicode;
        constructor(name: string, webName?: string);
    }
}
declare namespace Stimulsoft.System.Text {
    class StringBuilder {
        private isNew;
        private partArray;
        private appendSingle;
        appendThese(items: any[]): StringBuilder;
        append(...items: any[]): StringBuilder;
        appendCount(item: any, count?: number): StringBuilder;
        appendLine(...items: any[]): StringBuilder;
        appendLines(items: any[]): StringBuilder;
        appendFormat(str: string, ...values: any[]): StringBuilder;
        insert(index: number, value: string, count?: number): StringBuilder;
        remove(startIndex: number, length: number): StringBuilder;
        get isEmpty(): boolean;
        get length(): number;
        set length(value: number);
        private latest;
        toString(): string;
        join(delimiter: string): string;
        clear(): void;
        dispose(): void;
        charAt(index: number): string;
        charCodeAt(index: number): number;
        setByIndex(index: number, value: string): void;
        private formatError;
        replace(searchValue: string, replaceValue: string): StringBuilder;
        constructor(value?: string);
    }
}
declare namespace Stimulsoft.System.IO {
    import StringBuilder = Stimulsoft.System.Text.StringBuilder;
    class TextWriter {
        private sb;
        write(value: any): void;
        writeLine(value?: any): void;
        close(): void;
        flush(): void;
        getStringBuilder(): StringBuilder;
    }
}
declare namespace Stimulsoft.System.IO {
    import Encoding = Stimulsoft.System.Text.Encoding;
    import TextWriter = Stimulsoft.System.IO.TextWriter;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StreamWriter extends TextWriter {
        private stream;
        private encoding;
        private cn;
        writeLine(value: string): void;
        write(value: string): void;
        close(): void;
        flush(): void;
        constructor(stream: MemoryStream, encoding?: Encoding);
    }
}
declare namespace Stimulsoft.System.Text {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiReportObjectStringConverter {
        static convertStringToColorArray(str: string): Color[];
        static convertStringToColor(str: string): Color;
        private static getByName;
    }
}
declare namespace Stimulsoft.System.Text {
    import Font = Stimulsoft.System.Drawing.Font;
    class TextUtils {
        static splitString(inputString: string, removeControl: boolean): string[];
        static trimEndWhiteSpace(inputString: string): string;
        static trimEndWhiteSpace2(inputString: string, removeControl: boolean): string;
        private static isWordWrapSymbol;
        static getWordWrapTextLines(st: string, font: Font, needWidthAlign: boolean, textW: number): string[];
    }
}
declare namespace Stimulsoft.System.Xml {
    enum Formatting {
        None = 0,
        Indented = 1
    }
}
declare namespace Stimulsoft.System.Xml {
    class XmlAttr {
        private _name;
        get name(): string;
        set name(value: string);
        private _value;
        get value(): string;
        set value(value: string);
    }
}
declare namespace Stimulsoft.System.Xml {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class XmlAttrCollection extends CollectionBase<XmlAttr> {
        getNamedItem(name: string): XmlAttr;
    }
}
declare namespace Stimulsoft.System.Xml {
    class XmlCharType {
        static fWhitespace: number;
        static fLetter: number;
        static fNCStartName: number;
        static fNCName: number;
        static fCharData: number;
        static fPublicId: number;
        static fText: number;
        static fAttrValue: number;
        private static charPropertiesSize;
        static get instance(): XmlCharType;
        private static s_CharProperties;
        charProperties: number[];
        private static initInstance;
        private static setProperties;
        private static s_Whitespace;
        private static s_Letter;
        private static s_NCStartName;
        private static s_NCName;
        private static s_CharData;
        private static s_PublicID;
        private static s_Text;
        private static s_AttrValue;
        constructor(charProperties: any[]);
    }
}
declare namespace Stimulsoft.System.Xml {
    class XmlReservedNs {
        static NsCollationBase: string;
        static NsCollCodePoint: string;
        static NsDataType: string;
        static NsDataTypeAlias: string;
        static NsDataTypeOld: string;
        static NsExsltCommon: string;
        static NsExsltDates: string;
        static NsExsltMath: string;
        static NsExsltRegExps: string;
        static NsExsltSets: string;
        static NsExsltStrings: string;
        static NsMsxsl: string;
        static NsWdXsl: string;
        static NsXdr: string;
        static NsXdrAlias: string;
        static NsXml: string;
        static NsXmlNs: string;
        static NsXQueryDataType: string;
        static NsXQueryFunc: string;
        static NsXs: string;
        static NsXsd: string;
        static NsXsi: string;
        static NsXslDebug: string;
        static NsXslt: string;
        static NsXsltInternal: string;
    }
}
declare namespace Stimulsoft.System.Xml {
    enum XmlSpace {
        Default = 1,
        None = 0,
        Preserve = 2
    }
}
declare namespace Stimulsoft.System.Xml {
    import TextWriter = Stimulsoft.System.IO.TextWriter;
    class XmlTextEncoder {
        private textWriter;
        private inAttribute;
        quoteChar: string;
        private attrValue;
        private cacheAttrValue;
        private xmlCharType;
        private surHighStart;
        private surHighEnd;
        private surLowStart;
        private surLowEnd;
        startAttribute(cacheAttrValue: boolean): void;
        endAttribute(): void;
        get attributeValue(): string;
        private writeSurrogateChar;
        write(text: string): void;
        writeRawWithSurrogateChecking(text: string): void;
        private writeStringFragment;
        private writeCharEntityImpl;
        private writeEntityRefImpl;
        constructor(textWriter: TextWriter);
    }
}
declare namespace Stimulsoft.System.Xml {
    import Encoding = Stimulsoft.System.Text.Encoding;
    import TextWriter = Stimulsoft.System.IO.TextWriter;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class XmlTextWriter {
        private static stateTableDefault;
        private static stateTableDocument;
        textWriter: TextWriter;
        private xmlEncoder;
        private encoding;
        formatting: Formatting;
        private indented;
        indentation: number;
        private indentChar;
        private stack;
        private top;
        private stateTable;
        private currentState;
        private lastToken;
        private quoteChar;
        private curQuoteChar;
        private namespaces;
        private specialAttr;
        private prefixForXmlNs;
        private _flush;
        private nsStack;
        private nsTop;
        private nsHashtable;
        private useNsHashtable;
        private xmlCharType;
        private namespaceStackInitialSize;
        private maxNamespacesWalkCount;
        writeStartDocument(standalone?: boolean): void;
        writeEndDocument(): void;
        writeDocType(name: string, pubid: string, sysid: string, subset: string): void;
        writeStartElement(localName: string): void;
        private writeStartElement3;
        writeEndElement(): void;
        writeFullEndElement(): void;
        writeStartAttribute(prefix: string, localName: string, ns: string): void;
        writeEndAttribute(): void;
        writeString(text: string): void;
        writeRaw(data: string): void;
        close(): void;
        flush(): void;
        writeName(name: string): void;
        writeQualifiedName(localName: string, ns: string): void;
        private startDocument;
        private autoComplete;
        private autoCompleteAll;
        private internalWriteEndElement;
        private writeEndStartTag;
        private writeEndAttributeQuote;
        private indent;
        private pushNamespace;
        private addNamespace;
        private addToNamespaceHashtable;
        private popNamespaces;
        private generatePrefix;
        private internalWriteProcessingInstruction;
        private lookupNamespace;
        private lookupNamespaceInCurrentScope;
        private findPrefix;
        private internalWriteName;
        private validateName;
        private handleSpecialAttribute;
        private verifyPrefixXml;
        private pushStack;
        private flushEncoders;
        writeAttributeString(localName: string, value: string): void;
        writeElementString(localName: string, value: string): void;
        writeElementString2(localName: string, ns: string, value: string): void;
        writeElementString3(prefix: string, localName: string, ns: string, value: string): void;
        constructor_(encoding: Encoding, w?: MemoryStream): void;
        constructor(encoding: Encoding, w?: MemoryStream);
    }
}
declare namespace Stimulsoft.Base {
    enum StiAnimationType {
        Opacity = 0,
        Scale = 1,
        Translation = 2,
        Rotation = 3,
        Column = 4,
        Points = 5,
        PieSegment = 6
    }
    enum StiTokenType {
        None = 0,
        Dot = 1,
        Comma = 2,
        Colon = 3,
        SemiColon = 4,
        Shl = 5,
        Shr = 6,
        Assign = 7,
        Equal = 8,
        NotEqual = 9,
        LeftEqual = 10,
        Left = 11,
        RightEqual = 12,
        Right = 13,
        Or = 14,
        And = 15,
        Not = 16,
        DoubleOr = 17,
        DoubleAnd = 18,
        Copyright = 19,
        Question = 20,
        Plus = 21,
        Minus = 22,
        Mult = 23,
        Div = 24,
        Splash = 25,
        Percent = 26,
        Ampersand = 27,
        Sharp = 28,
        Dollar = 29,
        Euro = 30,
        DoublePlus = 31,
        DoubleMinus = 32,
        LPar = 33,
        RPar = 34,
        LBrace = 35,
        RBrace = 36,
        LBracket = 37,
        RBracket = 38,
        Value = 39,
        Ident = 40,
        Unknown = 41,
        EOF = 42
    }
    enum StiLevel {
        Basic = 0,
        Standard = 1,
        Professional = 2
    }
    enum StiAutoBool {
        Auto = 0,
        True = 1,
        False = 2
    }
    enum StiRelationDirection {
        ParentToChild = 1,
        ChildToParent = 0
    }
    enum StiGisDataType {
        Wkt = 0,
        GeoJSON = 1
    }
    enum StiSummaryColumnType {
        Sum = 0,
        Min = 1,
        Max = 2,
        Count = 3,
        Average = 4
    }
}
declare namespace Stimulsoft.Base {
    let IStiApp: System.Interface<IStiApp>;
    interface IStiApp extends IStiAppCell {
        getDictionary(): IStiAppDictionary;
    }
}
declare namespace Stimulsoft.Base {
    let IStiAppAlias: System.Interface<IStiAppAlias>;
    interface IStiAppAlias {
        getAlias(): string;
    }
}
declare namespace Stimulsoft.Base {
    let IStiAppCalcDataColumn: System.Interface<IStiAppCalcDataColumn>;
    interface IStiAppCalcDataColumn extends IStiAppDataColumn {
    }
}
declare namespace Stimulsoft.Base {
    import IAsIs = Stimulsoft.System.IAsIs;
    let IStiAppCell: System.Interface<IStiAppCell>;
    interface IStiAppCell extends IAsIs {
        getKey(): string;
        setKey(key: string): void;
    }
}
declare namespace Stimulsoft.Base {
    let IStiAppComponent: System.Interface<IStiAppComponent>;
    interface IStiAppComponent extends IStiAppCell {
        getName(): string;
        getApp(): IStiApp;
    }
}
declare namespace Stimulsoft.Base {
    let IStiAppConnection: System.Interface<IStiAppConnection>;
    interface IStiAppConnection extends IStiAppCell {
        getName(): string;
    }
}
declare namespace Stimulsoft.Base {
    let IStiAppDataCell: System.Interface<IStiAppDataCell>;
    interface IStiAppDataCell extends IStiAppCell {
        getName(): string;
    }
}
declare namespace Stimulsoft.Base {
    import Type = Stimulsoft.System.Type;
    let IStiAppDataColumn: System.Interface<IStiAppDataColumn>;
    interface IStiAppDataColumn extends IStiAppDataCell {
        getNameInSource(): string;
        getDataType(): Type;
    }
}
declare namespace Stimulsoft.Base {
    import List = Stimulsoft.System.Collections.List;
    let IStiAppDataRelation: System.Interface<IStiAppDataRelation>;
    interface IStiAppDataRelation extends IStiAppCell {
        getName(): string;
        getDictionary(): IStiAppDictionary;
        getParentDataSource(): IStiAppDataSource;
        getChildDataSource(): IStiAppDataSource;
        fetchParentColumns(): List<string>;
        fetchChildColumns(): List<string>;
        getActiveState(): boolean;
    }
}
declare namespace Stimulsoft.Base {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import List = Stimulsoft.System.Collections.List;
    let IStiAppDataSource: System.Interface<IStiAppDataSource>;
    interface IStiAppDataSource extends IStiAppCell {
        getNameInSource(): string;
        getName(): string;
        getDataTable2(allowConnectToData: boolean): Promise<DataTable>;
        getDictionary(): IStiAppDictionary;
        fetchColumns(): List<IStiAppDataColumn>;
        getConnection(): IStiAppConnection;
        fetchParentRelations(activePreferred: boolean): List<IStiAppDataRelation>;
        fetchChildRelations(activePreferred: boolean): List<IStiAppDataRelation>;
        fetchColumnValues(names: List<string>): List<any[]>;
    }
}
declare namespace Stimulsoft.Base {
    import List = Stimulsoft.System.Collections.List;
    let IStiAppDictionary: System.Interface<IStiAppDictionary>;
    interface IStiAppDictionary {
        fetchDataSources(): List<IStiAppDataSource>;
        fetchDataRelations(): List<IStiAppDataRelation>;
        fetchVariables(): List<IStiAppVariable>;
        getDataSourceByName(name: string): IStiAppDataSource;
        getColumnByName(name: string): IStiAppDataColumn;
        getVariableByName(name: string): IStiAppVariable;
        getVariableValueByName(name: string): any;
        isSystemVariable(name: string): boolean;
        getSystemVariableValue(name: string): any;
        getApp(): IStiApp;
        openConnections(connections: List<IStiAppConnection>): List<IStiAppConnection>;
        closeConnections(connections: List<IStiAppConnection>): void;
    }
}
declare namespace Stimulsoft.Base {
    let IStiAppExpressionCollection: System.Interface<IStiAppExpressionCollection>;
    interface IStiAppExpressionCollection {
        expressions: StiAppExpressionCollection;
    }
}
declare namespace Stimulsoft.Base {
    import List = Stimulsoft.System.Collections.List;
    let IStiAppFunction: System.Interface<IStiAppFunction>;
    interface IStiAppFunction extends IStiAppCell {
        getName(): string;
        invoke(arguments: List<any>): any;
    }
}
declare namespace Stimulsoft.Base {
    let IStiAppVariable: System.Interface<IStiAppVariable>;
    interface IStiAppVariable extends IStiAppDataCell {
        getValue(): any;
    }
}
declare namespace Stimulsoft.Base {
    import Font = Stimulsoft.System.Drawing.Font;
    let IStiGetFonts: System.Interface<IStiGetFonts>;
    interface IStiGetFonts {
        getFonts(): Font[];
    }
}
declare namespace Stimulsoft.Base {
    import List = Stimulsoft.System.Collections.List;
    let IStiReport: System.Interface<IStiReport>;
    interface IStiReport extends IStiApp {
        fetchPages(): List<IStiReportPage>;
    }
}
declare namespace Stimulsoft.Base {
    let IStiReportComponent: System.Interface<IStiReportComponent>;
    interface IStiReportComponent extends IStiAppComponent {
        getReport(): IStiReport;
    }
}
declare namespace Stimulsoft.Base {
    let IStiReportPage: System.Interface<IStiReportPage>;
    interface IStiReportPage extends IStiReportComponent {
        parseExpression(text: string): string;
    }
}
declare namespace Stimulsoft.Base {
    class StiActivator {
        static createObject(_type: Stimulsoft.System.Type): any;
        static createObject2(typeString: string): any;
    }
}
declare namespace Stimulsoft.Base {
    class StiAlignValue {
        static alignToMaxGrid(value: number, gridSize: number, aligningToGrid: boolean): number;
        static alignToMinGrid(value: number, gridSize: number, aligningToGrid: boolean): number;
        static alignToGrid(value: number, gridSize: number, aligningToGrid: boolean): number;
    }
}
declare namespace Stimulsoft.Base.JsonReportObject {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    let IStiJsonReportObject: System.Interface<IStiJsonReportObject>;
    interface IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): any;
    }
}
declare namespace Stimulsoft.Base {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiAppExpression implements ICloneable, IStiJsonReportObject {
        private static ImplementsStiAppExpression;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private upperFirstChar;
        private lowerFirstChar;
        clone(): StiAppExpression;
        name: string;
        expression: string;
        get isEmpty(): boolean;
        constructor(name: string, expression: string);
    }
}
declare namespace Stimulsoft.Base {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiAppExpressionCollection extends CollectionBase<StiAppExpression> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        add2(name: string, expression: string): void;
        addRange2(props: StiAppExpressionCollection): void;
        contains2(name: string): boolean;
        remove2(name: string): void;
        getByName(name: string): StiAppExpression;
        setByName(name: string, value: StiAppExpression): void;
        clone(): StiAppExpressionCollection;
    }
}
declare namespace Stimulsoft.Base {
    class StiAppExpressionHelper {
        static isExpressionSpecified(component: any, propName: string): boolean;
        static getExpression(component: any, propName: string): StiAppExpression;
        static getExpressionValue(component: any, propName: string): string;
        static setExpression(component: any, propName: string, expression: string): void;
        static removeExpression(component: any, propName: string): void;
    }
}
declare namespace Stimulsoft.Base {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiAppFunctions {
        static functionsToCompile: Hashtable<any, any>;
        static functionsToCompileLower: Hashtable<any, any>;
        static functions: Hashtable<any, any>;
        static functionsLower: Hashtable<any, any>;
        static getFunctions(isCompile: boolean, isCaseSensitive: boolean): IStiAppFunction[];
        static getFunctions2(functionName: string, isCompile: boolean, isCaseSensitive: boolean): IStiAppFunction[];
    }
}
declare namespace Stimulsoft.Base {
    class StiAppKey {
        static getOrGeneratedKey(component: IStiReportComponent): string;
        static getOrGeneratedKey2(app: IStiApp): string;
        static getOrGeneratedKey3(dictionary: IStiAppDictionary): string;
        static getOrGeneratedKey4(dataSource: IStiAppDataSource): string;
    }
}
declare namespace Stimulsoft.Base {
    class StiEncryption {
        private static randomSeed;
        private static rand_m;
        private static rand_a;
        private static rand_c;
        static encrypt(src: number[], key: number[]): number[];
        static encrypt2(src: number[], password: string): number[];
        static encryptS(src: string, password: string): string;
        static decrypt(src: number[], key: number[]): number[];
        static decrypt2(src: number[], password: string): number[];
        static decryptS(src: string, password: string): string;
        static generateRandomKey(): number[];
        private static encryptAdv;
        private static decryptAdv;
        private static cryptXor;
        private static cryptShift;
        private static shiftLeft;
        private static shiftRight;
        private static cryptRandom;
        private static getMixArray;
        private static setRandomSeed;
        private static getRandom;
        private static getKeyFromPassword;
    }
}
declare namespace Stimulsoft.Base {
    import List = Stimulsoft.System.Collections.List;
    import DateTime = Stimulsoft.System.DateTime;
    class StiJson {
        static prettyPrint: boolean;
        static dateToJsonDate(date: DateTime): string;
        static jsonDateFormatToDate(jsonDate: string): DateTime;
        name: string;
        value: any;
        private isProperty;
        private isArray;
        properties(): List<StiJson>;
        removeProperty(propertyName: string): void;
        addPropertyNumber(propertyName: string, value: number, defaultValue?: number): void;
        addPropertyNumberNoDefaultValue(propertyName: string, value: number): void;
        addPropertyJObject(propertyName: string, value: StiJson): void;
        addPropertyJObjectArray(propertyName: string, values: StiJson[]): void;
        addPropertyIdent(propertyName: string, value: string): void;
        addPropertyBool(propertyName: string, value: boolean, defaultValue?: boolean): void;
        addPropertyDateTime(propertyName: string, value: DateTime): void;
        addPropertyEnum(propertyName: string, enumType: any, value: any, defaultValue?: any): void;
        addPropertyString(propertyName: string, value: string, defaultValue?: string): void;
        addPropertyStringNullOrEmpty(propertyName: string, value: string): void;
        get count(): number;
        serialize(indent?: number): string;
        deserialize(text: any): void;
        private deserializeFromObject;
        toString(): string;
        constructor(name?: string, value?: any, isProperty?: boolean);
    }
}
declare namespace Stimulsoft.Base {
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCID {
        private static key;
        private static undefined;
        private static prefix;
        private machineAddress;
        private machineName;
        private machineUserName;
        private machineGuid;
        saveToString(): string;
        saveToJsonObject(): StiJson;
        loadFromString(value: string): void;
        loadFromJsonObject(jObject: StiJson): void;
        static getDefault(): string;
        private static getDeveloperCID;
        private static getCurrentMachineName;
        private static getCurrentMachineGuid;
        private static getCurrentMachineAddress;
        private static getCurrentMachineUserName;
        static isCID(cid: string): boolean;
        constructor(machineName: string, machineAddress?: string, machineUserName?: string, machineGuid?: string);
    }
}
declare namespace Stimulsoft.Base.Localization {
    class StiLocalization {
        static languages: any;
        static English: {
            "@language": string;
            "@description": string;
            "@cultureName": string;
            A_WebViewer: {
                AbbreviatedDayFriday: string;
                AbbreviatedDayMonday: string;
                AbbreviatedDaySaturday: string;
                AbbreviatedDaySunday: string;
                AbbreviatedDayThursday: string;
                AbbreviatedDayTuesday: string;
                AbbreviatedDayWednesday: string;
                Attachment: string;
                ButtonNext: string;
                ButtonPrev: string;
                ButtonSend: string;
                CategoryAlreadyExists: string;
                DayFriday: string;
                DayMonday: string;
                DaySaturday: string;
                DaySunday: string;
                DayThursday: string;
                DayTuesday: string;
                DayWednesday: string;
                Email: string;
                EmailOptions: string;
                FirstPage: string;
                Hours: string;
                LabelFrom: string;
                LabelSelectExportFormat: string;
                LabelTo: string;
                LastPage: string;
                Loading: string;
                Message: string;
                Minutes: string;
                Days: string;
                MonthApril: string;
                MonthAugust: string;
                MonthDecember: string;
                MonthFebruary: string;
                MonthJanuary: string;
                MonthJuly: string;
                MonthJune: string;
                MonthMarch: string;
                MonthMay: string;
                MonthNovember: string;
                MonthOctober: string;
                MonthSeptember: string;
                NextPage: string;
                OnePage: string;
                Page: string;
                PageOf: string;
                PreviousPage: string;
                PrintContinue: string;
                PrintReport: string;
                PrintToPdf: string;
                PrintToXps: string;
                PrintWithoutPreview: string;
                PrintWithPreview: string;
                SaveReport: string;
                Subject: string;
                TabItemContacts: string;
                TextComputer: string;
                TextItemsRoot: string;
                TodayDate: string;
                WholeReport: string;
            };
            Adapters: {
                AdapterBusinessObjects: string;
                AdapterConnection: string;
                AdapterCrossTabDataSource: string;
                AdapterCsvFiles: string;
                AdapterDataTables: string;
                AdapterDataViews: string;
                AdapterDB2Connection: string;
                AdapterDBaseFiles: string;
                AdapterFirebirdConnection: string;
                AdapterInformixConnection: string;
                AdapterMySQLConnection: string;
                AdapterOdbcConnection: string;
                AdapterOleDbConnection: string;
                AdapterOracleConnection: string;
                AdapterOracleODPConnection: string;
                AdapterPostgreSQLConnection: string;
                AdapterSqlCeConnection: string;
                AdapterSqlConnection: string;
                AdapterSQLiteConnection: string;
                AdapterTeradataConnection: string;
                AdapterUniDirectConnection: string;
                AdapterUserSources: string;
                AdapterVirtualSource: string;
                AdapterVistaDBConnection: string;
            };
            BarCode: {
                Post: string;
                TwoDimensional: string;
            };
            Buttons: {
                Add: string;
                AddAllColumns: string;
                Attach: string;
                Build: string;
                Buttons: string;
                Cancel: string;
                Check: string;
                Close: string;
                Delete: string;
                Design: string;
                Down: string;
                Duplicate: string;
                Export: string;
                ForceDelete: string;
                Help: string;
                Install: string;
                LessOptions: string;
                LoadDataSet: string;
                More: string;
                MoreApps: string;
                MoreOptions: string;
                MoveLeft: string;
                MoveRight: string;
                MoveToResource: string;
                No: string;
                Ok: string;
                Open: string;
                Print: string;
                Publish: string;
                QuickPrint: string;
                Remove: string;
                RemoveAll: string;
                Rename: string;
                RestoreDefaults: string;
                Reverse: string;
                Save: string;
                SaveCopy: string;
                SetAll: string;
                ShowLess: string;
                ShowMore: string;
                ShowSpecific: string;
                Submit: string;
                SwitchTo: string;
                Test: string;
                Up: string;
                Upgrade: string;
                UpgradeNow: string;
                Upload: string;
                Waiting: string;
                Yes: string;
            };
            Chart: {
                AddCondition: string;
                AddConstantLine: string;
                AddFilter: string;
                AddSeries: string;
                AddStrip: string;
                AddTrendLine: string;
                Area: string;
                Axes: string;
                AxisReverse: string;
                AxisX: string;
                AxisY: string;
                BoxAndWhisker: string;
                Bubble: string;
                Candlestick: string;
                ChartConditionsCollectionForm: string;
                ChartEditorForm: string;
                ChartFiltersCollectionForm: string;
                ChartType: string;
                CheckBoxAutoRotation: string;
                ClusteredBar: string;
                ClusteredColumn: string;
                Common: string;
                ConstantLine: string;
                ConstantLinesEditorForm: string;
                DataColumns: string;
                Doughnut: string;
                Financial: string;
                FullStackedArea: string;
                FullStackedBar: string;
                FullStackedColumn: string;
                FullStackedLine: string;
                FullStackedSpline: string;
                FullStackedSplineArea: string;
                Funnel: string;
                FunnelWeightedSlices: string;
                Gantt: string;
                GridInterlaced: string;
                GridLines: string;
                Histogram: string;
                LabelAlignment: string;
                LabelAlignmentHorizontal: string;
                LabelAlignmentVertical: string;
                LabelAngle: string;
                LabelArgumentDataColumn: string;
                LabelAutoRotation: string;
                LabelCloseValueDataColumn: string;
                LabelEndValueDataColumn: string;
                LabelHighValueDataColumn: string;
                LabelHorizontal: string;
                LabelLowValueDataColumn: string;
                LabelMinorCount: string;
                LabelOpenValueDataColumn: string;
                Labels: string;
                LabelsCenter: string;
                LabelSeriesName: string;
                LabelsInside: string;
                LabelsInsideBase: string;
                LabelsInsideEnd: string;
                LabelsNone: string;
                LabelsOutside: string;
                LabelsOutsideBase: string;
                LabelsOutsideEnd: string;
                LabelsStyleCategory: string;
                LabelsStyleCategoryPercentOfTotal: string;
                LabelsStyleCategoryValue: string;
                LabelsStylePercentOfTotal: string;
                LabelsStyleValue: string;
                LabelsTwoColumns: string;
                LabelTextAfter: string;
                LabelTextBefore: string;
                LabelTitleAlignment: string;
                LabelValueDataColumn: string;
                LabelValueType: string;
                LabelVertical: string;
                LabelVisible: string;
                Legend: string;
                LegendSpacing: string;
                Line: string;
                ListOfValues: string;
                Marker: string;
                MoveConstantLineDown: string;
                MoveConstantLineUp: string;
                MoveSeriesDown: string;
                MoveSeriesUp: string;
                MoveStripDown: string;
                MoveStripUp: string;
                NoConditions: string;
                NoFilters: string;
                Pareto: string;
                Pictorial: string;
                Pie: string;
                Radar: string;
                RadarArea: string;
                RadarColumn: string;
                RadarLine: string;
                RadarPoint: string;
                Range: string;
                RangeBar: string;
                RemoveCondition: string;
                RemoveConstantLine: string;
                RemoveFilter: string;
                RemoveSeries: string;
                RemoveStrip: string;
                RunChartWizard: string;
                Scatter: string;
                ScatterLine: string;
                ScatterSpline: string;
                Series: string;
                SeriesColorsCollectionForm: string;
                SeriesEditorForm: string;
                Serieses: string;
                SparklinesArea: string;
                SparklinesColumn: string;
                SparklinesLine: string;
                SparklinesWinLoss: string;
                Spline: string;
                SplineArea: string;
                SplineRange: string;
                StackedArea: string;
                StackedBar: string;
                StackedColumn: string;
                StackedLine: string;
                StackedSpline: string;
                StackedSplineArea: string;
                SteppedArea: string;
                SteppedLine: string;
                SteppedRange: string;
                Stock: string;
                Strip: string;
                StripsEditorForm: string;
                Style: string;
                Sunburst: string;
                Treemap: string;
                TrendLinesEditorForm: string;
                Waterfall: string;
            };
            CharterMapEditor: {
                Characters: string;
            };
            ChartRibbon: {
                Axes: string;
                AxesArrowStyle: string;
                AxesArrowStyleLines: string;
                AxesArrowStyleNone: string;
                AxesArrowStyleTriangle: string;
                AxesLabel: string;
                AxesLabelsNone: string;
                AxesLabelsOneLine: string;
                AxesLabelsTwoLines: string;
                AxesReverseHorizontal: string;
                AxesReverseVertical: string;
                AxesTicks: string;
                AxesTicksMajor: string;
                AxesTicksMinor: string;
                AxesTicksNone: string;
                AxesVisible: string;
                AxesXAxis: string;
                AxesXTopAxis: string;
                AxesYAxis: string;
                AxesYRightAxis: string;
                CenterLabels: string;
                ChangeType: string;
                GridLines: string;
                GridLinesHorizontal: string;
                GridLinesVertical: string;
                HorAlCenter: string;
                HorAlLeft: string;
                HorAlLeftOutside: string;
                HorAlRight: string;
                HorAlRightOutside: string;
                HorizontalMajor: string;
                HorizontalMajorMinor: string;
                HorizontalMinor: string;
                HorizontalNone: string;
                InsideBaseLabels: string;
                InsideEndLabels: string;
                Labels: string;
                Legend: string;
                LegendHorizontalAlignment: string;
                LegendMarker: string;
                LegendMarkerAlignmentLeft: string;
                LegendMarkerAlignmentRight: string;
                LegendMarkerVisible: string;
                LegendVerticalAlignment: string;
                LegendVisible: string;
                NoneLabels: string;
                OutsideBaseLabels: string;
                OutsideEndLabels: string;
                OutsideLabels: string;
                ribbonBarAxis: string;
                ribbonBarChartStyles: string;
                ribbonBarChartType: string;
                ribbonBarLabels: string;
                ribbonBarLegend: string;
                Style: string;
                TwoColumnsPieLabels: string;
                VertAlBottom: string;
                VertAlBottomOutside: string;
                VertAlCenter: string;
                VertAlTop: string;
                VertAlTopOutside: string;
                VerticalMajor: string;
                VerticalMajorMinor: string;
                VerticalMinor: string;
                VerticalNone: string;
            };
            Cloud: {
                AcceptTermsAndPrivacyPolicy: string;
                Account: string;
                AccountSettings: string;
                AddAPlace: string;
                AreYouSureYouWantDeleteReport: string;
                Authorize: string;
                AuthorizeWithLicenseKey: string;
                ButtonChangePassword: string;
                ButtonDeleteAll: string;
                ButtonDesign: string;
                ButtonLater: string;
                ButtonLogInWith: string;
                ButtonLogout: string;
                ButtonPublish: string;
                ButtonPurchase: string;
                ButtonRecover: string;
                ButtonRenew: string;
                ButtonResendEmail: string;
                ButtonResetPassword: string;
                ButtonRun: string;
                ButtonScheduler: string;
                ButtonShare: string;
                ButtonSignUp: string;
                ButtonSignUpWith: string;
                ButtonSkip: string;
                ButtonView: string;
                ButtonWhereUsed: string;
                Cancel: string;
                CheckBoxMoveToRecycleBin: string;
                CheckBoxRememberMe: string;
                CheckForUpdate: string;
                Cloud: string;
                Collection: string;
                Create: string;
                CreateError: string;
                CreateNewCollection: string;
                CreateYourTeam: string;
                CreatingReport: string;
                DashboardWindowTitleNew: string;
                DeleteFile: string;
                DoNotAskMe: string;
                ExecutionError: string;
                ExpiredDate: string;
                FileStorageWindowTitleEdit: string;
                FileStorageWindowTitleNew: string;
                FolderWindowTitleEdit: string;
                FolderWindowTitleNew: string;
                ForExample: string;
                GroupBoxAttachedItems: string;
                HyperlinkAgreeToTerms: string;
                HyperlinkAlreadyHaveAccount: string;
                HyperlinkForgotPassword: string;
                HyperlinkHavePassword: string;
                HyperlinkRegisterAccount: string;
                InstallSamples: string;
                Invitations: string;
                Invite: string;
                LabelAddCloudFolder: string;
                LabelAddFolder: string;
                labelCollectionName: string;
                LabelCreated: string;
                LabelCreateFolder: string;
                LabelCreateNewDashboard: string;
                LabelCreateReportTemplate: string;
                LabelCurrentPassword: string;
                LabelDataFile: string;
                LabelDataUrl: string;
                LabelEndDate: string;
                labelFileName: string;
                LabelForeground: string;
                LabelFromReport: string;
                LabelFromReportCode: string;
                LabelInviteUser: string;
                LabelLastLogin: string;
                LabelLastTime: string;
                LabelModified: string;
                LabelNewPassword: string;
                LabelNextTime: string;
                labelPassword: string;
                LabelPermission: string;
                LabelPicture: string;
                LabelRenderedReport: string;
                LabelResponseAsFile: string;
                LabelResultType: string;
                LabelStartDate: string;
                LabelSeparateReport: string;
                LabelShowReport: string;
                labelUserName: string;
                License: string;
                LicenseInformation: string;
                LicenseKey: string;
                Login: string;
                MyTeam: string;
                NofM: string;
                Open: string;
                OpenFile: string;
                OperationCreate: string;
                OperationDelete: string;
                OperationDownload: string;
                OperationGetList: string;
                OperationLogin: string;
                OperationRename: string;
                OperationUpload: string;
                page: string;
                Platforms: string;
                Port: string;
                PrivacyPolicy: string;
                Products: string;
                Proxy: string;
                PublishMessage: string;
                questionOpenThisFile: string;
                questionOverrideItem: string;
                questionRemoveItem: string;
                RefreshList: string;
                ReportDocumentFormatNotRecognized: string;
                ReportTemplateFormatNotRecognized: string;
                RequestChangesWhenSavingToCloud: string;
                RibbonButtonAddRole: string;
                RibbonButtonAddUser: string;
                RibbonButtonAddWorkspace: string;
                RibbonButtonFolder: string;
                RibbonTabUsers: string;
                Root: string;
                RootFolder: string;
                Save: string;
                SaveAccountSettings: string;
                SaveAsType: string;
                SaveFile: string;
                SavingToStimulsoftCloudPleaseWait: string;
                SearchForOnlineTemplates: string;
                ShareWindowTitleNew: string;
                ShowAllFiles: string;
                ShowNotificationMessages: string;
                Subscriptions: string;
                TabItemEmbedCode: string;
                TabItemQRCode: string;
                TabItemShare: string;
                Team: string;
                TermsOfUse: string;
                TextActivated: string;
                TextActivationDate: string;
                TextDelete: string;
                TextDeletingItems: string;
                TextDescriptionChanges: string;
                TextFirstName: string;
                TextFromTo: string;
                TextItemsWorkspace: string;
                TextLastName: string;
                TextModify: string;
                TextNewsLetters: string;
                TextNoFavoriteFiles: string;
                TextNoFiles: string;
                TextNoNotifications: string;
                TextNoRecentFiles: string;
                TextOwner: string;
                TextProfile: string;
                TextReports: string;
                TextRestoringItems: string;
                TextRole: string;
                TextRun: string;
                TextUser: string;
                TextUserName: string;
                TimeHoursAgoFive: string;
                TimeHoursAgoFour: string;
                TimeHoursAgoOne: string;
                TimeHoursAgoThree: string;
                TimeHoursAgoTwo: string;
                TimeMinutesAgoFive: string;
                TimeMinutesAgoFour: string;
                TimeMinutesAgoLessOne: string;
                TimeMinutesAgoN: string;
                TimeMinutesAgoOne: string;
                TimeMinutesAgoThree: string;
                TimeMinutesAgoTwo: string;
                TimeToday: string;
                TimeYesterday: string;
                ToolTipAddRole: string;
                ToolTipAddUser: string;
                ToolTipAspNet: string;
                ToolTipAspNetMvc: string;
                ToolTipAttach: string;
                ToolTipCreate: string;
                ToolTipDelete: string;
                ToolTipDeleted: string;
                ToolTipDownload: string;
                ToolTipEdit: string;
                ToolTipGridMode: string;
                ToolTipInfo: string;
                ToolTipJs: string;
                ToolTipPublish: string;
                ToolTipRecover: string;
                ToolTipRunWithoutPreview: string;
                ToolTipShare: string;
                ToolTipSort: string;
                ToolTipThumbnailMode: string;
                ToolTipViewFile: string;
                ToolTipViewReport: string;
                WeDidntFindAnything: string;
                WindowDescriptionDelete: string;
                WindowDescriptionRecover: string;
                WindowTitleDelete: string;
                WindowTitleForgotPassword: string;
                WindowTitleLogin: string;
                WindowTitleRecover: string;
                WindowTitleRoleEdit: string;
                WindowTitleRoleNew: string;
                WindowTitleSignUp: string;
                WindowTitleUserEdit: string;
                WindowTitleUserNew: string;
                WindowTitleWorkspaceEdit: string;
                WindowTitleWorkspaceNew: string;
                WizardBlankReportDescription: string;
                WizardExcelDescription: string;
                WizardJsonDescription: string;
                WizardPrivateShare: string;
                WizardPrivateShareDescription: string;
                WizardPublicShare: string;
                WizardPublicShareDescription: string;
                WizardRegisteredShare: string;
                WizardRegisteredShareDescription: string;
                WizardTeamShare: string;
                WizardTeamShareDescription: string;
                WizardXmlDescription: string;
            };
            Scheduler: {
                Schedulers: string;
                Schedule: string;
                Scheduler: string;
                NoSchedulers: string;
                PleaseSelectSchedulerType: string;
                NewScheduler: string;
                EditScheduler: string;
                NewAction: string;
                ActionRunReport: string;
                TextPressPlusIconAddNewAction: string;
                SmtpSettings: string;
                NoShedulers: string;
                SenderEmail: string;
                Host: string;
                Logs: string;
                NoLogs: string;
                EnableSSL: string;
                AdvancedSettings: string;
                WizardOnce: string;
                WizardOnceDescription: string;
                WizardHourly: string;
                WizardHourlyDescription: string;
                WizardDaily: string;
                WizardDailyDescription: string;
                WizardWeekly: string;
                WizardWeeklyDescription: string;
                WizardMonthly: string;
                WizardMonthlyDescription: string;
                RepeatTaskEvery: string;
                ForADuractionOf: string;
                StopAllRunningTasksAtEndOfRepetitionDuraction: string;
                DelayTaskForUpToRandomDelay: string;
                StopTasksIfItRunsLongerThan: string;
                Expire: string;
                LabelRunAtTime: string;
                LabelRunEvery: string;
                LabelRunAtDay: string;
                RadioButtonDay: string;
                DayDayX: string;
                DayLast: string;
                DayAll: string;
                DayNone: string;
                RadioButtonOn: string;
                NumberOfDayFirst: string;
                NumberOfDaySecond: string;
                NumberOfDayThird: string;
                NumberOfDayFourth: string;
                NumberOfDayLast: string;
                NumberOfDayAll: string;
                NumberOfDayNone: string;
                DaysOfWeekAll: string;
                DaysOfWeekNone: string;
                MonthAll: string;
                MonthNone: string;
                LabelRunAtMonth: string;
                LabelDaysOfWeek: string;
                TextDragDropReportHere: string;
                ToolTipSetParameters: string;
                GetFolder: string;
                TextDragDropDestinationHere: string;
                LabelResultName: string;
                CheckBoxOverwriteIfExists: string;
                LabelTo: string;
                LabelSubject: string;
                LabelMessage: string;
                GroupBoxFiles: string;
                MessagePropertyNotSet: string;
                MessageInvalidName: string;
                MessageInvalidTaskName: string;
            };
            Components: {
                StiBarCode: string;
                StiButton: string;
                StiChart: string;
                StiCheckBox: string;
                StiChildBand: string;
                StiClone: string;
                StiColumnFooterBand: string;
                StiColumnHeaderBand: string;
                StiComboBox: string;
                StiComponent: string;
                StiContainer: string;
                StiContourText: string;
                StiCrossColumn: string;
                StiCrossColumnTotal: string;
                StiCrossDataBand: string;
                StiCrossFooterBand: string;
                StiCrossGroupFooterBand: string;
                StiCrossGroupHeaderBand: string;
                StiCrossHeaderBand: string;
                StiCrossRow: string;
                StiCrossRowTotal: string;
                StiCrossSummary: string;
                StiCrossSummaryHeader: string;
                StiCrossTab: string;
                StiCrossTitle: string;
                StiDashboard: string;
                StiDataBand: string;
                StiDatePicker: string;
                StiEmptyBand: string;
                StiFooterBand: string;
                StiGauge: string;
                StiGroupFooterBand: string;
                StiGroupHeaderBand: string;
                StiHeaderBand: string;
                StiHierarchicalBand: string;
                StiHorizontalLinePrimitive: string;
                StiImage: string;
                StiIndicator: string;
                StiListBox: string;
                StiMap: string;
                StiMathFormula: string;
                StiOnlineMap: string;
                StiOverlayBand: string;
                StiPage: string;
                StiPageFooterBand: string;
                StiPageHeaderBand: string;
                StiPanel: string;
                StiPivotColumn: string;
                StiPivotRow: string;
                StiPivotSummary: string;
                StiPivotTable: string;
                StiProgress: string;
                StiRectanglePrimitive: string;
                StiRegionMap: string;
                StiReport: string;
                StiReportSummaryBand: string;
                StiReportTitleBand: string;
                StiRichText: string;
                StiRoundedRectanglePrimitive: string;
                StiShape: string;
                StiSparkline: string;
                StiSubReport: string;
                StiSystemText: string;
                StiTable: string;
                StiTableOfContents: string;
                StiText: string;
                StiTextInCells: string;
                StiTreeView: string;
                StiTreeViewBox: string;
                StiVerticalLinePrimitive: string;
                StiWinControl: string;
                StiZipCode: string;
            };
            Dashboard: {
                AddRange: string;
                AfterGroupingData: string;
                AllowUserDrillDown: string;
                AllowUserColumnSelection: string;
                AllowUserFiltering: string;
                AllowUserSorting: string;
                Blank: string;
                Blanks: string;
                BooleanFilters: string;
                CannotLoadDashboard: string;
                ChangeChartType: string;
                ChangeMapType: string;
                ClearAllFormatting: string;
                ClearFilterFrom: string;
                ColorScale: string;
                ColumnInteractions: string;
                CustomFilter: string;
                DashboardsNotSupportedIntheWPFDesigner: string;
                DataBars: string;
                DataFilterGrouping: string;
                DataNotDefined: string;
                DateFilters: string;
                Dimension: string;
                Dimensions: string;
                DragDropData: string;
                DragDropDataFromDictionary: string;
                DrillDown: string;
                DrillDownFiltered: string;
                DrillDownSelected: string;
                DrillUp: string;
                DuplicateField: string;
                EditExpression: string;
                EditField: string;
                EmptyDashboardFooter: string;
                EmptyDashboardHeader: string;
                FieldInteractions: string;
                FieldTypeRestrictionHint: string;
                FirstLastPoints: string;
                FirstRowIndex: string;
                FullRowSelect: string;
                HighLowPoints: string;
                ImageNotSpecified: string;
                Indicator: string;
                InitialValue: string;
                LimitRows: string;
                Measure: string;
                Measures: string;
                Metrics: string;
                NewDimension: string;
                NewField: string;
                NewMeasure: string;
                NoRanges: string;
                NoResult: string;
                NSelected: string;
                Nulls: string;
                NumberFilters: string;
                ParentElement: string;
                RangeMode: string;
                RangeType: string;
                RemoveActions: string;
                RemoveAllFields: string;
                RemoveField: string;
                RemoveMobileSurface: string;
                ReplaceValues: string;
                ReportSnapshot: string;
                RowsCount: string;
                RunFieldsEditor: string;
                RunFieldsEditorInfo: string;
                SelectAll: string;
                ShowAllValue: string;
                ShowAsPercentages: string;
                ShowBlanks: string;
                SkipFirstRows: string;
                SortAZ: string;
                SortLargestToSmallest: string;
                SortNewestToOldest: string;
                SortOldestToNewest: string;
                SortSmallestToLargest: string;
                SortZA: string;
                Sparklines: string;
                StringFilters: string;
                TransformationHint: string;
                Trend: string;
                ViewEditCompilationNotice: string;
                ViewModeDesktop: string;
                ViewModeMobile: string;
            };
            Database: {
                Connection: string;
                Database: string;
                DatabaseDB2: string;
                DatabaseFirebird: string;
                DatabaseInformix: string;
                DatabaseJson: string;
                DatabaseMySQL: string;
                DatabaseOdbc: string;
                DatabaseOleDb: string;
                DatabaseOracle: string;
                DatabaseOracleODP: string;
                DatabasePostgreSQL: string;
                DatabaseSql: string;
                DatabaseSqlCe: string;
                DatabaseSQLite: string;
                DatabaseTeradata: string;
                DatabaseUniDirect: string;
                DatabaseVistaDB: string;
                DatabaseXml: string;
            };
            DatePickerRanges: {
                CurrentMonth: string;
                CurrentQuarter: string;
                CurrentWeek: string;
                CurrentYear: string;
                DaysAgo: string;
                FirstQuarter: string;
                FourthQuarter: string;
                Index: string;
                Last14Days: string;
                Last30Days: string;
                Last7Days: string;
                MonthToDate: string;
                NextMonth: string;
                NextQuarter: string;
                NextWeek: string;
                NextYear: string;
                PreviousMonth: string;
                PreviousQuarter: string;
                PreviousWeek: string;
                PreviousYear: string;
                Quarter: string;
                QuarterToDate: string;
                SecondQuarter: string;
                ThirdQuarter: string;
                Today: string;
                Tomorrow: string;
                WeekToDate: string;
                Year: string;
                YearToDate: string;
                Yesterday: string;
            };
            DesignerFx: {
                AlreadyExists: string;
                CanNotLoadThisReportTemplate: string;
                CloseDataSourceEditor: string;
                CloseEditor: string;
                CompilingReport: string;
                Connecting: string;
                ConnectionError: string;
                ConnectionSuccessfull: string;
                Continue: string;
                DecryptionError: string;
                EmailSuccessfullySent: string;
                ErrorAtSaving: string;
                ErrorCode: string;
                ErrorServer: string;
                ExportingReport: string;
                LoadingCode: string;
                LoadingConfiguration: string;
                LoadingData: string;
                LoadingDocument: string;
                LoadingImages: string;
                LoadingLanguage: string;
                LoadingReport: string;
                PreviewAs: string;
                RenderingReport: string;
                ReportSuccessfullySaved: string;
                RetrieveError: string;
                RetrievingColumns: string;
                SavingConfiguration: string;
                SavingReport: string;
                Saving: string;
                TestConnection: string;
                TextNotFound: string;
            };
            Desktop: {
                Beginner: string;
                ButtonAddCloud: string;
                ButtonAddFolder: string;
                ButtonCreateDashboard: string;
                ButtonCreateReport: string;
                ChooseYourSkillLevel: string;
                Creator: string;
                Developer: string;
                DoYouWantToInstallReports: string;
                InstallSamplesDesc: string;
                PleaseAnswerWhoAreYou: string;
                SkillLevel: string;
                WhoAreYou: string;
                WhoAreYouBeginnerDescription: string;
                WhoAreYouCreatorDescription: string;
                WhoAreYouDeveloperDescription: string;
            };
            Dialogs: {
                StiButtonControl: string;
                StiCheckBoxControl: string;
                StiCheckedListBoxControl: string;
                StiComboBoxControl: string;
                StiDateTimePickerControl: string;
                StiForm: string;
                StiGridControl: string;
                StiGroupBoxControl: string;
                StiLabelControl: string;
                StiListBoxControl: string;
                StiListViewControl: string;
                StiLookUpBoxControl: string;
                StiNumericUpDownControl: string;
                StiPanelControl: string;
                StiPictureBoxControl: string;
                StiRadioButtonControl: string;
                StiReportControl: string;
                StiRichTextBoxControl: string;
                StiTextBoxControl: string;
                StiTreeViewControl: string;
            };
            Editor: {
                AllowSQLFormatting: string;
                BetweenMetrics: string;
                CantFind: string;
                CollapseToDefinitions: string;
                Column: string;
                EntireScope: string;
                Find: string;
                FindNext: string;
                FindWhat: string;
                FromCursor: string;
                GotoLine: string;
                InsertLink: string;
                InsertSymbol: string;
                Line: string;
                LineNumber: string;
                LineNumberIndex: string;
                MarkAll: string;
                MatchCase: string;
                MatchWholeWord: string;
                Outlining: string;
                PromptOnReplace: string;
                MaximumDimensions: string;
                Replace: string;
                ReplaceAll: string;
                ReplaceWith: string;
                Search: string;
                SearchHiddenText: string;
                SearchUp: string;
                SelectionOnly: string;
                ShowAutoGeneratedCode: string;
                ShowLineNumbers: string;
                StopOutlining: string;
                titleFind: string;
                titleGotoLine: string;
                titleReplace: string;
                ToggleAllOutlining: string;
                ToggleOutliningExpansion: string;
                TypeToSearch: string;
                UseRegularExpressions: string;
            };
            Errors: {
                ComponentIsNotRelease: string;
                ContainerIsNotValidForComponent: string;
                DataNotFound: string;
                DataNotLoaded: string;
                Error: string;
                ErrorsList: string;
                FieldRequire: string;
                FileNotFound: string;
                IdentifierIsNotValid: string;
                ImpossibleFindDataSource: string;
                NameExists: string;
                NoServices: string;
                NotAssign: string;
                NotCorrectFormat: string;
                OneTableOfContentsAllowed: string;
                PrimaryColumnAction: string;
                RelationsNotFound: string;
                ReportCannotBeSaveDueToErrors: string;
                ServiceNotFound: string;
            };
            ExceptionProvider: {
                Assemblies: string;
                ClickIgnore: string;
                Exception: string;
                ExceptionReport: string;
                Framework: string;
                General: string;
                Message: string;
                Number: string;
                PleaseEnterDetailedInformation: string;
                SaveToFile: string;
                SendErrorFailed: string;
                SendErrorSuccess: string;
                Source: string;
                StackTrace: string;
                YourPreviousWorkSession: string;
                YouCanRestore: string;
            };
            Export: {
                AddPageBreaks: string;
                AllBands: string;
                AllowAddOrModifyTextAnnotations: string;
                AllowCopyTextAndGraphics: string;
                AllowEditable: string;
                AllowModifyContents: string;
                AllowPrintDocument: string;
                Auto: string;
                BandsFilter: string;
                CancelExport: string;
                Color: string;
                Compressed: string;
                CompressToArchive: string;
                ContinuousPages: string;
                DataAndHeaders: string;
                DataAndHeadersFooters: string;
                DataOnly: string;
                DigitalSignature: string;
                DigitalSignatureCertificateNotSelected: string;
                DigitalSignatureError: string;
                DocumentSecurity: string;
                DotMatrixMode: string;
                EmbeddedFonts: string;
                EmbeddedImageData: string;
                EnableAnimation: string;
                Encoding: string;
                EncryptionError: string;
                EscapeCodes: string;
                Exactly: string;
                ExceptEditableFields: string;
                ExportDataOnly: string;
                ExportEachPageToSheet: string;
                Exporting: string;
                ExportingCalculatingCoordinates: string;
                ExportingCreatingDocument: string;
                ExportingFormatingObjects: string;
                ExportingReport: string;
                ExportMode: string;
                ExportModeFrame: string;
                ExportModeTable: string;
                ExportObjectFormatting: string;
                ExportPageBreaks: string;
                ExportRtfTextAsImage: string;
                ExportTypeBmpFile: string;
                ExportTypeCalcFile: string;
                ExportTypeCsvFile: string;
                ExportTypeDataFile: string;
                ExportTypeDbfFile: string;
                ExportTypeDifFile: string;
                ExportTypeExcel2007File: string;
                ExportTypeExcelFile: string;
                ExportTypeExcelXmlFile: string;
                ExportTypeGifFile: string;
                ExportTypeHtml5File: string;
                ExportTypeHtmlFile: string;
                ExportTypeImageFile: string;
                ExportTypeJpegFile: string;
                ExportTypeJsonFile: string;
                ExportTypeMetafile: string;
                ExportTypeMhtFile: string;
                ExportTypePcxFile: string;
                ExportTypePdfFile: string;
                ExportTypePngFile: string;
                ExportTypePpt2007File: string;
                ExportTypeRtfFile: string;
                ExportTypeSvgFile: string;
                ExportTypeSvgzFile: string;
                ExportTypeSylkFile: string;
                ExportTypeTiffFile: string;
                ExportTypeTxtFile: string;
                ExportTypeWord2007File: string;
                ExportTypeWriterFile: string;
                ExportTypeXmlFile: string;
                ExportTypeXpsFile: string;
                GetCertificateFromCryptoUI: string;
                ImageCompressionMethod: string;
                ImageCutEdges: string;
                ImageFormat: string;
                ImageGrayscale: string;
                ImageMonochrome: string;
                ImageQuality: string;
                ImageResolution: string;
                ImageResolutionMode: string;
                ImageType: string;
                labelEncryptionKeyLength: string;
                labelOwnerPassword: string;
                labelSubjectNameString: string;
                labelUserPassword: string;
                MonochromeDitheringType: string;
                MoreSettings: string;
                MultipleFiles: string;
                NoMoreThan: string;
                OpenAfterExport: string;
                PdfACompliance: string;
                PrintingReport: string;
                RemoveEmptySpaceAtBottom: string;
                RestrictEditing: string;
                Scale: string;
                Separator: string;
                Settings: string;
                SkipColumnHeaders: string;
                StandardPDFFonts: string;
                TiffCompressionScheme: string;
                title: string;
                TxtBorderType: string;
                TxtBorderTypeDouble: string;
                TxtBorderTypeSimple: string;
                TxtBorderTypeSingle: string;
                TxtCutLongLines: string;
                TxtDrawBorder: string;
                TxtKillSpaceGraphLines: string;
                TxtKillSpaceLines: string;
                TxtPutFeedPageCode: string;
                Type: string;
                UseDefaultSystemEncoding: string;
                UseDigitalSignature: string;
                UseEscapeCodes: string;
                UseOnePageHeaderAndFooter: string;
                UsePageHeadersAndFooters: string;
                UseUnicode: string;
                X: string;
                Y: string;
                Zoom: string;
            };
            FileFilters: {
                AllFiles: string;
                AllImageFiles: string;
                BitmapFiles: string;
                BmpFiles: string;
                CalcFiles: string;
                CsvFiles: string;
                DashboardTemplates: string;
                DataSetXmlData: string;
                DataSetXmlSchema: string;
                DbfFiles: string;
                DictionaryFiles: string;
                DifFiles: string;
                DllFiles: string;
                DocumentFiles: string;
                EmfFiles: string;
                EncryptedDocumentFiles: string;
                EncryptedReportFiles: string;
                Excel2007Files: string;
                ExcelAllFiles: string;
                ExcelFiles: string;
                ExcelXmlFiles: string;
                ExeFiles: string;
                GifFiles: string;
                HtmlFiles: string;
                InheritedLanguageFiles: string;
                JpegFiles: string;
                JsonDocumentFiles: string;
                JsonFiles: string;
                JsonReportFiles: string;
                LanguageFiles: string;
                LanguageForSilverlightFiles: string;
                MetaFiles: string;
                MhtFiles: string;
                PackedDocumentFiles: string;
                PackedReportFiles: string;
                PageFiles: string;
                PcxFiles: string;
                PdfFiles: string;
                PngFiles: string;
                Ppt2007Files: string;
                ReportEmbededDataFiles: string;
                ReportFiles: string;
                RtfFiles: string;
                StandaloneReportFiles: string;
                StylesFiles: string;
                SvgFiles: string;
                SvgzFiles: string;
                SylkFiles: string;
                TiffFiles: string;
                TxtFiles: string;
                Word2007Files: string;
                WordFiles: string;
                WriterFiles: string;
                XmlFiles: string;
                XpsFiles: string;
                ZipArchives: string;
            };
            Formats: {
                custom01: string;
                custom02: string;
                custom03: string;
                custom04: string;
                custom05: string;
                custom06: string;
                custom07: string;
                custom08: string;
                custom09: string;
                custom10: string;
                custom11: string;
                custom12: string;
                custom13: string;
                custom14: string;
                custom15: string;
                custom16: string;
                custom17: string;
                custom18: string;
                date01: string;
                date02: string;
                date03: string;
                date04: string;
                date05: string;
                date06: string;
                date07: string;
                date08: string;
                date09: string;
                date10: string;
                date11: string;
                date12: string;
                date13: string;
                date14: string;
                date15: string;
                date16: string;
                date17: string;
                date18: string;
                date19: string;
                date20: string;
                date21: string;
                date22: string;
                time01: string;
                time02: string;
                time03: string;
                time04: string;
                time06: string;
            };
            FormBand: {
                AddFilter: string;
                AddGroup: string;
                AddResult: string;
                AddSort: string;
                And: string;
                Ascending: string;
                Descending: string;
                NoFilters: string;
                NoSort: string;
                RemoveFilter: string;
                RemoveGroup: string;
                RemoveResult: string;
                RemoveSort: string;
                SortBy: string;
                ThenBy: string;
                title: string;
            };
            FormColorBoxPopup: {
                Color: string;
                Custom: string;
                NoColor: string;
                Others: string;
                System: string;
                Web: string;
            };
            FormConditions: {
                AaBbCcYyZz: string;
                AddCondition: string;
                AddLevel: string;
                AssignExpression: string;
                BreakIfTrue: string;
                BreakIfTrueToolTip: string;
                ChangeFont: string;
                ComponentIsEnabled: string;
                NoConditions: string;
                RemoveCondition: string;
                SelectStyle: string;
                title: string;
            };
            FormCrossTabDesigner: {
                Columns: string;
                DataSource: string;
                Properties: string;
                Rows: string;
                Summary: string;
                Swap: string;
                title: string;
            };
            FormDatabaseEdit: {
                AccessToken: string;
                AccountKey: string;
                AccountName: string;
                AuthorizationCode: string;
                BlobContentType: string;
                BlobName: string;
                ClientId: string;
                ClientSecret: string;
                ConnectionString: string;
                ContainerName: string;
                DashboardConnections: string;
                DatabaseSecret: string;
                DatasetId: string;
                DB2Edit: string;
                DB2New: string;
                EditConnection: string;
                Favorites: string;
                FirebirdEdit: string;
                FirebirdNew: string;
                FirstRowIsHeader: string;
                GetAuthorizationCode: string;
                GetTokens: string;
                GisEdit: string;
                GisNew: string;
                ImportData: string;
                InformixEdit: string;
                InformixNew: string;
                InitialCatalog: string;
                JsonEdit: string;
                JsonNew: string;
                MySQLEdit: string;
                MySQLNew: string;
                NewConnection: string;
                OdbcEdit: string;
                OdbcNew: string;
                OleDbEdit: string;
                OleDbNew: string;
                OracleEdit: string;
                OracleNew: string;
                OracleODPEdit: string;
                OracleODPNew: string;
                PathData: string;
                PathGisData: string;
                PathJsonData: string;
                PathSchema: string;
                PathToData: string;
                Pin: string;
                PostgreSQLEdit: string;
                PostgreSQLNew: string;
                ProjectId: string;
                PromptUserNameAndPassword: string;
                RecentConnections: string;
                RedirectUrl: string;
                RefreshAccessToken: string;
                RefreshToken: string;
                RelationDirection: string;
                ReportConnections: string;
                SelectData: string;
                ServiceAccountKeyFile: string;
                SpreadsheetId: string;
                SqlCeEdit: string;
                SqlCeNew: string;
                SqlEdit: string;
                SQLiteEdit: string;
                SQLiteNew: string;
                SqlNew: string;
                TeradataEdit: string;
                TeradataNew: string;
                Token: string;
                UniDirectEdit: string;
                UniDirectNew: string;
                Unpin: string;
                UseBearerAuthentication: string;
                UseOwnClientID: string;
                UseToken: string;
                VistaDBEdit: string;
                VistaDBNew: string;
                XmlEdit: string;
                XmlNew: string;
                XmlType: string;
            };
            FormDesigner: {
                Code: string;
                ColumnsOne: string;
                ColumnsThree: string;
                ColumnsTwo: string;
                CompilingReport: string;
                DockingPanels: string;
                HtmlPreview: string;
                JsPreview: string;
                labelPleaseSelectTypeOfInterface: string;
                LoadImage: string;
                LocalizePropertyGrid: string;
                MarginsNarrow: string;
                MarginsNormal: string;
                MarginsWide: string;
                OrderToolbars: string;
                Others: string;
                Pages: string;
                Preview: string;
                PropertyChange: string;
                RTPreview: string;
                SetupToolbox: string;
                ShowDescription: string;
                SLPreview: string;
                title: string;
                WebPreview: string;
            };
            FormDictionaryDesigner: {
                Actions: string;
                AutoSort: string;
                BusinessObjectEdit: string;
                CalcColumnEdit: string;
                CalcColumnNew: string;
                CategoryEdit: string;
                CategoryNew: string;
                Child: string;
                ChildOfBusinessObject: string;
                ChildSource: string;
                ClickHere: string;
                ColumnEdit: string;
                ColumnNew: string;
                CreateNewDataSource: string;
                CreateNewReport: string;
                CsvSeparatorComma: string;
                CsvSeparatorOther: string;
                CsvSeparatorSemicolon: string;
                CsvSeparatorSpace: string;
                CsvSeparatorSystem: string;
                CsvSeparatorTab: string;
                DatabaseEdit: string;
                DatabaseNew: string;
                DataParameterEdit: string;
                DataParameterNew: string;
                DataSetToBusinessObjects: string;
                DataSourceEdit: string;
                DataSourceNew: string;
                DataSourcesNew: string;
                DataTransformationEdit: string;
                DataTransformationNew: string;
                Delete: string;
                DesignTimeQueryText: string;
                DictionaryMerge: string;
                DictionaryNew: string;
                DictionaryOpen: string;
                DictionarySaveAs: string;
                DragNewDataSource: string;
                DragNewReport: string;
                EditQuery: string;
                ExecutedSQLStatementSuccessfully: string;
                ExpressionNew: string;
                HideUnsupportedDatabases: string;
                GetColumnsFromAssembly: string;
                ImportRelations: string;
                LabelSeparator: string;
                MarkUsedItems: string;
                NewBusinessObject: string;
                NewItem: string;
                OpenAssembly: string;
                Parent: string;
                ParentSource: string;
                Queries: string;
                QueryNew: string;
                QueryText: string;
                QueryTimeout: string;
                RelationEdit: string;
                RelationNew: string;
                ResourceEdit: string;
                ResourceNew: string;
                RetrieveColumns: string;
                RetrieveColumnsAllowRun: string;
                RetrieveColumnsAndParameters: string;
                RetrieveParameters: string;
                RetrievingDatabaseInformation: string;
                Run: string;
                SelectTypeOfBusinessObject: string;
                SkipSchemaWizard: string;
                SortItems: string;
                Synchronize: string;
                SynchronizeHint: string;
                TextDropDataFileHere: string;
                TextDropFileHere: string;
                TextDropImageHere: string;
                title: string;
                ValueNew: string;
                VariableEdit: string;
                VariableNew: string;
                ViewData: string;
                ViewQuery: string;
            };
            FormFormatEditor: {
                Boolean: string;
                BooleanDisplay: string;
                BooleanValue: string;
                Currency: string;
                CurrencySymbol: string;
                Custom: string;
                Date: string;
                DateTimeFormat: string;
                DecimalDigits: string;
                DecimalSeparator: string;
                FormatMask: string;
                Formats: string;
                General: string;
                GroupSeparator: string;
                GroupSize: string;
                nameFalse: string;
                nameNo: string;
                nameOff: string;
                nameOn: string;
                nameTrue: string;
                nameYes: string;
                NegativeInRed: string;
                NegativePattern: string;
                Number: string;
                Percentage: string;
                PercentageSymbol: string;
                PositivePattern: string;
                Properties: string;
                Sample: string;
                SampleText: string;
                TextFormat: string;
                Time: string;
                title: string;
                UseAbbreviation: string;
                UseGroupSeparator: string;
                UseLocalSetting: string;
            };
            FormGlobalizationEditor: {
                AddCulture: string;
                AutoLocalizeReportOnRun: string;
                CreateNewCulture: string;
                GetCulture: string;
                qnGetCulture: string;
                qnSetCulture: string;
                RemoveCulture: string;
                SetCulture: string;
                title: string;
            };
            FormInteraction: {
                HyperlinkExternalDocuments: string;
                HyperlinkUsingInteractionBookmark: string;
                HyperlinkUsingInteractionTag: string;
            };
            FormOptions: {
                AutoSave: string;
                AutoSaveReportToReportClass: string;
                BlankDashboard: string;
                BlankForm: string;
                BlankReport: string;
                Default: string;
                DefaultScriptMode: string;
                Drawing: string;
                DrawMarkersWhenMoving: string;
                EditAfterInsert: string;
                EnableAutoSaveMode: string;
                FillBands: string;
                FillComponents: string;
                FillContainers: string;
                FillCrossBands: string;
                GenerateLocalizedName: string;
                Grid: string;
                GridDots: string;
                GridLines: string;
                GridMode: string;
                GridSize: string;
                groupAutoSaveOptions: string;
                groupColorScheme: string;
                groupGridDrawingOptions: string;
                groupGridOptions: string;
                groupGridSize: string;
                groupMainOptions: string;
                groupMarkersStyle: string;
                groupOptionsOfQuickInfo: string;
                groupPleaseSelectTypeOfGui: string;
                groupReportDisplayOptions: string;
                labelColorScheme: string;
                labelInfoAutoSave: string;
                labelInfoDrawing: string;
                labelInfoGrid: string;
                labelInfoGui: string;
                labelInfoMain: string;
                labelInfoQuickInfo: string;
                Main: string;
                MarkersStyle: string;
                MarkersStyleCorners: string;
                MarkersStyleDashedRectangle: string;
                MarkersStyleNone: string;
                MessageLeftRightNotValid: string;
                MessageTopBottomNotValid: string;
                Minutes: string;
                SaveReportEvery: string;
                ScaleMode: string;
                SelectUILanguage: string;
                ShowDialogForms: string;
                ShowDimensionLines: string;
                ShowOldGaugeEditor: string;
                StartScreen: string;
                title: string;
                UseComponentColor: string;
                UseLastFormat: string;
                Welcome: string;
            };
            FormPageSetup: {
                ApplyTo: string;
                Bottom: string;
                Columns: string;
                groupColumns: string;
                groupImage: string;
                groupMargins: string;
                groupOrientation: string;
                groupPaper: string;
                groupPaperSource: string;
                groupText: string;
                Height: string;
                labelAngle: string;
                labelColumnGaps: string;
                labelColumnWidth: string;
                labelImageAlignment: string;
                labelImageTransparency: string;
                labelInfoColumns: string;
                labelInfoPaper: string;
                labelInfoUnit: string;
                labelInfoWatermark: string;
                labelMultipleFactor: string;
                labelPaperSourceOfFirstPage: string;
                labelPaperSourceOfOtherPages: string;
                labelSelectBrush: string;
                labelSelectColor: string;
                labelSelectFont: string;
                labelSelectImage: string;
                labelText: string;
                Left: string;
                Margins: string;
                NumberOfColumns: string;
                Orientation: string;
                PageOrientationLandscape: string;
                PageOrientationPortrait: string;
                Paper: string;
                RebuildReport: string;
                Right: string;
                ScaleContent: string;
                Size: string;
                title: string;
                Top: string;
                Width: string;
            };
            FormReportSetup: {
                groupDates: string;
                groupDescription: string;
                groupMainParameters: string;
                groupNames: string;
                groupScript: string;
                groupUnits: string;
                labelInfoDescription: string;
                labelInfoMain: string;
                labelNumberOfPass: string;
                labelReportCacheMode: string;
                ReportChanged: string;
                ReportCreated: string;
                title: string;
            };
            FormRichTextEditor: {
                Bullets: string;
                FontName: string;
                FontSize: string;
                Insert: string;
                title: string;
            };
            FormStyleDesigner: {
                Add: string;
                AddCollectionName: string;
                ApplyStyleCollectionToReportComponents: string;
                ApplyStyles: string;
                ColorCollectionEditor: string;
                CreateNewComponentStyle: string;
                CreateStyleCollection: string;
                CreateStyleOnBase: string;
                Duplicate: string;
                EditColors: string;
                FromStyle: string;
                GetStyle: string;
                MoreStyles: string;
                NotSpecified: string;
                Open: string;
                Predefined: string;
                qnApplyStyleCollection: string;
                Remove: string;
                RemoveExistingStyles: string;
                Save: string;
                Style: string;
                StyleCollectionsNotFound: string;
                title: string;
            };
            FormSystemTextEditor: {
                Condition: string;
                LabelDataBand: string;
                LabelDataColumn: string;
                LabelShowInsteadNullValues: string;
                LabelSummaryFunction: string;
                pageExpression: string;
                pageSummary: string;
                pageSystemVariable: string;
                RunningTotal: string;
                SummaryRunning: string;
                SummaryRunningByColumn: string;
                SummaryRunningByPage: string;
                SummaryRunningByReport: string;
            };
            FormTitles: {
                ChartWizardForm: string;
                ConditionEditorForm: string;
                ConnectionSelectForm: string;
                ContainerSelectForm: string;
                DataAdapterServiceSelectForm: string;
                DataRelationSelectForm: string;
                DataSetName: string;
                DataSourceSelectForm: string;
                DataSourcesNewForm: string;
                DataStoreViewerForm: string;
                DesignerApplication: string;
                EventEditorForm: string;
                ExpressionEditorForm: string;
                GroupConditionForm: string;
                InteractionDrillDownPageSelectForm: string;
                MasterComponentSelectForm: string;
                PageAddForm: string;
                PageSizeForm: string;
                PagesManagerForm: string;
                PromptForm: string;
                ReportWizard: string;
                ServiceSelectForm: string;
                SqlExpressionsForm: string;
                SubReportPageSelectForm: string;
                TextEditorForm: string;
                ViewDataForm: string;
                ViewerApplication: string;
            };
            FormViewer: {
                Bookmarks: string;
                Close: string;
                CollapseAll: string;
                CompressedDocumentFile: string;
                ContextMenu: string;
                DocumentFile: string;
                Editor: string;
                EncryptedDocumentFile: string;
                ExpandAll: string;
                Export: string;
                Find: string;
                FirstPage: string;
                FullScreen: string;
                GoToPage: string;
                HorScrollBar: string;
                LabelPageN: string;
                LastPage: string;
                NextPage: string;
                Open: string;
                PageControl: string;
                PageDelete: string;
                PageDesign: string;
                PageNew: string;
                PageNofM: string;
                PageofM: string;
                PageSize: string;
                PageViewModeContinuous: string;
                PageViewModeMultiplePages: string;
                PageViewModeSinglePage: string;
                Parameters: string;
                PrevPage: string;
                Print: string;
                qnPageDelete: string;
                Save: string;
                SendEMail: string;
                StatusBar: string;
                Thumbnails: string;
                title: string;
                titlePageSettings: string;
                Toolbar: string;
                VerScrollBar: string;
                ViewMode: string;
                Zoom: string;
                ZoomMultiplePages: string;
                ZoomOnePage: string;
                ZoomPageWidth: string;
                ZoomTwoPages: string;
                ZoomXXPages: string;
                ZoomXXPagesCancel: string;
            };
            FormViewerFind: {
                Close: string;
                FindNext: string;
                FindPrevious: string;
                FindWhat: string;
            };
            Gauge: {
                AddNewItem: string;
                BarRangeList: string;
                GaugeEditorForm: string;
                Kind: string;
                LinearBar: string;
                LinearMarker: string;
                LinearRange: string;
                LinearRangeList: string;
                LinearScale: string;
                LinearTickLabelCustom: string;
                LinearTickLabelMajor: string;
                LinearTickLabelMinor: string;
                LinearTickMarkCustom: string;
                LinearTickMarkMajor: string;
                LinearTickMarkMinor: string;
                Needle: string;
                RadialBar: string;
                RadialMarker: string;
                RadialRange: string;
                RadialRangeList: string;
                RadialScale: string;
                RadialTickLabelCustom: string;
                RadialTickLabelMajor: string;
                RadialTickLabelMinor: string;
                RadialTickMarkCustom: string;
                RadialTickMarkMajor: string;
                RadialTickMarkMinor: string;
                StateIndicator: string;
                StateIndicatorFilter: string;
                TickCustomValue: string;
            };
            Gui: {
                barname_cancel: string;
                barname_caption: string;
                barname_msginvalidname: string;
                barname_name: string;
                barname_ok: string;
                barrename_caption: string;
                barsys_autohide_tooltip: string;
                barsys_close_tooltip: string;
                barsys_customize_tooltip: string;
                ClickAndDragPickColor: string;
                colorpicker_morecolors: string;
                colorpicker_nofill: string;
                colorpicker_standardcolorslabel: string;
                colorpicker_themecolorslabel: string;
                colorpickerdialog_alphalabel: string;
                colorpickerdialog_bluelabel: string;
                colorpickerdialog_cancelbutton: string;
                colorpickerdialog_caption: string;
                colorpickerdialog_colormodellabel: string;
                colorpickerdialog_currentcolorlabel: string;
                colorpickerdialog_customcolorslabel: string;
                colorpickerdialog_greenlabel: string;
                colorpickerdialog_newcolorlabel: string;
                colorpickerdialog_okbutton: string;
                colorpickerdialog_redlabel: string;
                colorpickerdialog_rgblabel: string;
                colorpickerdialog_standardcolorslabel: string;
                colorpickerdialog_tabcustom: string;
                colorpickerdialog_tabstandard: string;
                cust_btn_close: string;
                cust_btn_delete: string;
                cust_btn_keyboard: string;
                cust_btn_new: string;
                cust_btn_rename: string;
                cust_btn_reset: string;
                cust_btn_resetusage: string;
                cust_caption: string;
                cust_cbo_fade: string;
                cust_cbo_none: string;
                cust_cbo_random: string;
                cust_cbo_slide: string;
                cust_cbo_system: string;
                cust_cbo_unfold: string;
                cust_chk_delay: string;
                cust_chk_fullmenus: string;
                cust_chk_showsk: string;
                cust_chk_showst: string;
                cust_lbl_cats: string;
                cust_lbl_cmds: string;
                cust_lbl_cmdsins: string;
                cust_lbl_menuan: string;
                cust_lbl_other: string;
                cust_lbl_pmt: string;
                cust_lbl_tlbs: string;
                cust_mnu_addremove: string;
                cust_mnu_cust: string;
                cust_mnu_reset: string;
                cust_mnu_tooltip: string;
                cust_msg_delete: string;
                cust_pm_begingroup: string;
                cust_pm_delete: string;
                cust_pm_name: string;
                cust_pm_reset: string;
                cust_pm_stydef: string;
                cust_pm_styimagetext: string;
                cust_pm_stytextonly: string;
                cust_tab_commands: string;
                cust_tab_options: string;
                cust_tab_toolbars: string;
                mdisysmenu_close: string;
                mdisysmenu_maximize: string;
                mdisysmenu_minimize: string;
                mdisysmenu_move: string;
                mdisysmenu_next: string;
                mdisysmenu_restore: string;
                mdisysmenu_size: string;
                mdisystt_close: string;
                mdisystt_minimize: string;
                mdisystt_restore: string;
                monthcalendar_clearbutton: string;
                monthcalendar_todaybutton: string;
                navbar_navpaneoptions: string;
                navbar_showfewerbuttons: string;
                navbar_showmorebuttons: string;
                navPaneCollapseTooltip: string;
                navPaneExpandTooltip: string;
                sys_custombar: string;
                sys_morebuttons: string;
            };
            HelpComponents: {
                StiBarCode: string;
                StiChart: string;
                StiChartElement: string;
                StiCheckBox: string;
                StiChildBand: string;
                StiClone: string;
                StiColumnFooterBand: string;
                StiColumnHeaderBand: string;
                StiComboBoxElement: string;
                StiContainer: string;
                StiCrossDataBand: string;
                StiCrossFooterBand: string;
                StiCrossGroupFooterBand: string;
                StiCrossGroupHeaderBand: string;
                StiCrossHeaderBand: string;
                StiCrossTab: string;
                StiDataBand: string;
                StiDatePickerElement: string;
                StiEmptyBand: string;
                StiFilterCategory: string;
                StiFooterBand: string;
                StiGauge: string;
                StiGaugeElement: string;
                StiGroupFooterBand: string;
                StiGroupHeaderBand: string;
                StiHeaderBand: string;
                StiHierarchicalBand: string;
                StiHorizontalLinePrimitive: string;
                StiImage: string;
                StiImageElement: string;
                StiIndicatorElement: string;
                StiListBoxElement: string;
                StiMap: string;
                StiMapCategory: string;
                StiMapElement: string;
                StiOnlineMapElement: string;
                StiOverlayBand: string;
                StiPageFooterBand: string;
                StiPageHeaderBand: string;
                StiPanel: string;
                StiPanelElement: string;
                StiPivotTableElement: string;
                StiProgressElement: string;
                StiRectanglePrimitive: string;
                StiRegionMapElement: string;
                StiReportSummaryBand: string;
                StiReportTitleBand: string;
                StiRichText: string;
                StiRoundedRectanglePrimitive: string;
                StiShape: string;
                StiShapeElement: string;
                StiSubReport: string;
                StiTable: string;
                StiTableElement: string;
                StiText: string;
                StiTextElement: string;
                StiTextInCells: string;
                StiTreeViewBoxElement: string;
                StiTreeViewElement: string;
                StiVerticalLinePrimitive: string;
                StiWinControl: string;
                StiZipCode: string;
            };
            HelpDesigner: {
                ActiveRelation: string;
                Align: string;
                AlignBottom: string;
                AlignCenter: string;
                AlignComponentBottom: string;
                AlignComponentCenter: string;
                AlignComponentLeft: string;
                AlignComponentMiddle: string;
                AlignComponentRight: string;
                AlignComponentTop: string;
                AlignLeft: string;
                AlignMiddle: string;
                AlignRight: string;
                AlignToGrid: string;
                AlignTop: string;
                AlignWidth: string;
                Angle: string;
                AngleWatermark: string;
                Background: string;
                biConditions: string;
                BorderColor: string;
                BorderSidesAll: string;
                BorderSidesBottom: string;
                BorderSidesLeft: string;
                BorderSidesNone: string;
                BorderSidesRight: string;
                BorderSidesTop: string;
                BorderStyle: string;
                BringToFront: string;
                CenterHorizontally: string;
                CenterVertically: string;
                Close: string;
                Columns: string;
                ComponentSize: string;
                CopyStyle: string;
                CopyToClipboard: string;
                CurrencySymbol: string;
                DashboardNew: string;
                DataStore: string;
                DateTimeFormat: string;
                DockingPanels: string;
                DockStyleBottom: string;
                DockStyleFill: string;
                DockStyleLeft: string;
                DockStyleNone: string;
                DockStyleRight: string;
                DockStyleTop: string;
                FontGrow: string;
                FontName: string;
                FontNameWatermark: string;
                FontShrink: string;
                FontSize: string;
                FontSizeWatermark: string;
                FontStyleBold: string;
                FontStyleBoldWatermark: string;
                FontStyleItalic: string;
                FontStyleItalicWatermark: string;
                FontStyleUnderline: string;
                FontStyleUnderlineWatermark: string;
                FormatBoolean: string;
                FormatCurrency: string;
                FormatCustom: string;
                FormatDate: string;
                FormatGeneral: string;
                FormatNumber: string;
                FormatPercentage: string;
                FormatTime: string;
                FormNew: string;
                GridMode: string;
                ImageAlignment: string;
                ImageTransparency: string;
                Interaction: string;
                LineSpacing: string;
                Link: string;
                LoadImage: string;
                Lock: string;
                MainMenu: string;
                MakeHorizontalSpacingEqual: string;
                MakeVerticalSpacingEqual: string;
                Margins: string;
                menuCheckIssues: string;
                menuDesignerOptions: string;
                menuEditClearContents: string;
                menuEditCopy: string;
                menuEditCut: string;
                menuEditDelete: string;
                menuEditPaste: string;
                menuFAQPage: string;
                menuGlobalizationStrings: string;
                menuHelpAboutProgramm: string;
                menuHomePage: string;
                menuPageOptions: string;
                menuPagesManager: string;
                menuPreviewSettings: string;
                menuPrint: string;
                menuPrintPreview: string;
                menuPrintQuick: string;
                menuReportOptions: string;
                menuStyleDesigner: string;
                menuSupport: string;
                menuViewAlignToGrid: string;
                menuViewNormal: string;
                menuViewPageBreakPreview: string;
                menuViewQuickInfo: string;
                menuViewShowGrid: string;
                menuViewShowHeaders: string;
                menuViewShowOrder: string;
                menuViewShowRulers: string;
                MoveBackward: string;
                MoveForward: string;
                Orientation: string;
                PageDelete: string;
                PageNew: string;
                PageSetup: string;
                PageSize: string;
                PagesManager: string;
                PressF1: string;
                Redo: string;
                ReportNew: string;
                ReportOpen: string;
                ReportPreview: string;
                ReportSave: string;
                SelectAll: string;
                SelectUILanguage: string;
                SendToBack: string;
                ServicesConfigurator: string;
                Shadow: string;
                ShowBehind: string;
                ShowImageBehind: string;
                ShowToolbox: string;
                StimulsoftHelp: string;
                StyleDesigner: string;
                TellMeMore: string;
                Text: string;
                TextBrush: string;
                TextBrushWatermark: string;
                TextColor: string;
                TextFormat: string;
                ToolbarStyle: string;
                Undo: string;
                WordWrap: string;
                Zoom: string;
            };
            HelpDialogs: {
                StiButtonControl: string;
                StiCheckBoxControl: string;
                StiCheckedListBoxControl: string;
                StiComboBoxControl: string;
                StiDateTimePickerControl: string;
                StiGridControl: string;
                StiGroupBoxControl: string;
                StiLabelControl: string;
                StiListBoxControl: string;
                StiListViewControl: string;
                StiLookUpBoxControl: string;
                StiNumericUpDownControl: string;
                StiPanelControl: string;
                StiPictureBoxControl: string;
                StiRadioButtonControl: string;
                StiRichTextBoxControl: string;
                StiTextBoxControl: string;
                StiTreeViewControl: string;
            };
            HelpViewer: {
                AddPageBreaks: string;
                AllowAddOrModifyTextAnnotations: string;
                AllowCopyTextAndGraphics: string;
                AllowEditable: string;
                AllowModifyContents: string;
                AllowPrintDocument: string;
                Bookmarks: string;
                BorderType: string;
                Close: string;
                CloseDotMatrix: string;
                Compressed: string;
                CompressToArchive: string;
                ContinuousPages: string;
                CurrentPage: string;
                CutEdges: string;
                CutLongLines: string;
                DigitalSignature: string;
                DitheringType: string;
                DotMatrixMode: string;
                DrawBorder: string;
                Edit: string;
                EmbeddedFonts: string;
                EmbeddedImageData: string;
                Encoding: string;
                EncodingData: string;
                EncryptionKeyLength: string;
                ExportDataOnly: string;
                ExportEachPageToSheet: string;
                ExportMode: string;
                ExportModeHtml: string;
                ExportModeRtf: string;
                ExportObjectFormatting: string;
                ExportPageBreaks: string;
                ExportRtfTextAsImage: string;
                Find: string;
                FullScreen: string;
                GetCertificateFromCryptoUI: string;
                ImageCompressionMethod: string;
                ImageFormat: string;
                ImageQuality: string;
                ImageQualityPdf: string;
                ImageResolution: string;
                ImageType: string;
                KillSpaceLines: string;
                MultipleFiles: string;
                Open: string;
                OpenAfterExport: string;
                OwnerPassword: string;
                PageAll: string;
                PageDelete: string;
                PageDesign: string;
                PageFirst: string;
                PageGoTo: string;
                PageLast: string;
                PageNew: string;
                PageNext: string;
                PagePrevious: string;
                PageSize: string;
                Parameters: string;
                PdfACompliance: string;
                Print: string;
                PutFeedPageCode: string;
                RangePages: string;
                RemoveEmptySpaceAtBottom: string;
                Resources: string;
                RestrictEditing: string;
                Save: string;
                ScaleHtml: string;
                ScaleImage: string;
                SendEMail: string;
                Separator: string;
                SkipColumnHeaders: string;
                StandardPdfFonts: string;
                SubjectNameString: string;
                Thumbnails: string;
                TiffCompressionScheme: string;
                ToolEditor: string;
                TypeExport: string;
                UseDefaultSystemEncoding: string;
                UseOnePageHeaderAndFooter: string;
                UsePageHeadersAndFooters: string;
                UserPassword: string;
                UseUnicode: string;
                ViewModeContinuous: string;
                ViewModeMultiplePages: string;
                ViewModeSinglePage: string;
                ZoomMultiplePages: string;
                ZoomOnePage: string;
                ZoomPageWidth: string;
                ZoomTwoPages: string;
                ZoomTxt: string;
            };
            Interface: {
                Mouse: string;
                MouseDescription: string;
                Touch: string;
                TouchDescription: string;
            };
            MainMenu: {
                menuCheckIssues: string;
                menuContextClone: string;
                menuContextDesign: string;
                menuContextTextFormat: string;
                menuConvertToCheckBox: string;
                menuConvertToImage: string;
                MenuConvertToRichText: string;
                menuConvertToText: string;
                menuDeleteColumn: string;
                menuDeleteRow: string;
                menuEdit: string;
                menuEditBusinessObjectFromDataSetNew: string;
                menuEditBusinessObjectNew: string;
                menuEditCalcColumnNew: string;
                menuEditCantRedo: string;
                menuEditCantUndo: string;
                menuEditCategoryNew: string;
                menuEditClearContents: string;
                menuEditColumnNew: string;
                menuEditConnectionNew: string;
                menuEditCopy: string;
                menuEditCut: string;
                menuEditDataParameterNew: string;
                menuEditDataSourceNew: string;
                menuEditDataSourcesNew: string;
                menuEditDataTransformationNew: string;
                menuEditDelete: string;
                menuEditEdit: string;
                menuEditImportRelations: string;
                menuEditPaste: string;
                menuEditRedo: string;
                menuEditRedoText: string;
                menuEditRelationNew: string;
                menuEditRemoveUnused: string;
                menuEditResourceNew: string;
                menuEditSelectAll: string;
                menuEditSynchronize: string;
                menuEditUndo: string;
                menuEditUndoText: string;
                menuEditVariableNew: string;
                menuEditViewData: string;
                menuEmbedAllDataToResources: string;
                menuFile: string;
                menuFileClose: string;
                menuFileDashboardDelete: string;
                menuFileDashboardNew: string;
                menuFileDashboardOpen: string;
                menuFileDashboardSaveAs: string;
                menuFileExit: string;
                menuFileExportXMLSchema: string;
                menuFileFormNew: string;
                menuFileImportXMLSchema: string;
                menuFileMerge: string;
                menuFileMergeXMLSchema: string;
                menuFileNew: string;
                menuFileOpen: string;
                menuFilePageDelete: string;
                menuFilePageNew: string;
                menuFilePageOpen: string;
                menuFilePageSaveAs: string;
                menuFilePageSetup: string;
                menuFileRecentDocuments: string;
                menuFileRecentLocations: string;
                menuFileReportNew: string;
                menuFileReportOpen: string;
                menuFileReportOpenFromGoogleDocs: string;
                menuFileReportPreview: string;
                menuFileReportSave: string;
                menuFileReportSaveAs: string;
                menuFileReportSaveAsToGoogleDocs: string;
                menuFileReportSetup: string;
                menuFileReportWizardNew: string;
                menuFileSave: string;
                menuFileSaveAs: string;
                menuHelp: string;
                menuHelpAboutProgramm: string;
                menuHelpContents: string;
                menuHelpDemos: string;
                menuHelpDocumentation: string;
                menuHelpFAQPage: string;
                menuHelpForum: string;
                menuHelpHowToRegister: string;
                menuHelpProductHomePage: string;
                menuHelpSamples: string;
                menuHelpSupport: string;
                menuHelpTrainingCourses: string;
                menuHelpVideos: string;
                menuInsertColumnToLeft: string;
                menuInsertColumnToRight: string;
                menuInsertRowAbove: string;
                menuInsertRowBelow: string;
                menuJoinCells: string;
                menuMakeThisRelationActive: string;
                menuSelectColumn: string;
                menuSelectRow: string;
                menuTable: string;
                menuTools: string;
                menuToolsDataStore: string;
                menuToolsDictionary: string;
                menuToolsOptions: string;
                menuToolsPagesManager: string;
                menuToolsServicesConfigurator: string;
                menuToolsStyleDesigner: string;
                menuView: string;
                menuViewAlignToGrid: string;
                menuViewNormal: string;
                menuViewOptions: string;
                menuViewPageBreakPreview: string;
                menuViewQuickInfo: string;
                menuViewQuickInfoNone: string;
                menuViewQuickInfoOverlay: string;
                menuViewQuickInfoShowAliases: string;
                menuViewQuickInfoShowComponentsNames: string;
                menuViewQuickInfoShowContent: string;
                menuViewQuickInfoShowEvents: string;
                menuViewQuickInfoShowFields: string;
                menuViewQuickInfoShowFieldsOnly: string;
                menuViewShowGrid: string;
                menuViewShowHeaders: string;
                menuViewShowInsertTab: string;
                menuViewShowOrder: string;
                menuViewShowRulers: string;
                menuViewShowToolbox: string;
                menuViewToolbars: string;
            };
            Map: {
                LinkDataForm: string;
                MapEditorForm: string;
            };
            MathFormula: {
                Alphabets: string;
                Arrows: string;
                Formulas: string;
                Maths: string;
                Operators: string;
            };
            Messages: {
                LatexFormat: string;
                ChangeRequestTimeout: string;
                DoNotShowAgain: string;
                MessageTimeOutExpired: string;
                RenderingWillOccurInTheInterpretationMode: string;
                ResourceCannotBeDeleted: string;
                ShareURLOfTheItemHasBeenUpdated: string;
                ShareYourReportYouShouldSave: string;
                TextRegistrationSuccessfully: string;
                ThisFieldIsNotSpecified: string;
                ThisFunctionEmbedsAllReportDataToTheReport: string;
                YouNeedToLoginFirstToStartUsingTheSoftware: string;
            };
            Notices: {
                AccessDenied: string;
                AccountLocked: string;
                ActivationExpiriedBeforeFirstRelease: string;
                ActivationLicenseIsNotCorrect: string;
                ActivationLockedAccount: string;
                ActivationLockedAccountExt: string;
                ActivationMaxActivationsReached: string;
                ActivationMaxComputersReached: string;
                ActivationServerIsNotAvailableNow: string;
                ActivationServerVersionNotAllowed: string;
                ActivationSomeTroublesOccurred: string;
                ActivationTrialExpired: string;
                ActivationUserNameOrPasswordIsWrong: string;
                ActivationWrongAccountType: string;
                Alert: string;
                AuthAccountCantBeUsedNow: string;
                AuthAccountIsNotActivated: string;
                AuthCantChangeRoleBecauseLastAdministratorUser: string;
                AuthCantChangeRoleBecauseLastSupervisorUser: string;
                AuthCantChangeSystemRole: string;
                AuthCantDeleteHimselfUser: string;
                AuthCantDeleteLastAdministratorUser: string;
                AuthCantDeleteLastSupervisorUser: string;
                AuthCantDeleteSystemRole: string;
                AuthCantDisableUserBecauseLastAdministratorUser: string;
                AuthCantDisableUserBecauseLastSupervisorUser: string;
                AuthFirstNameIsNotSpecified: string;
                AuthLastNameIsNotSpecified: string;
                AuthOAuthIdNotSpecified: string;
                AuthPasswordIsNotCorrect: string;
                AuthPasswordIsNotSpecified: string;
                AuthPasswordIsTooShort: string;
                AuthRoleCantBeDeletedBecauseUsedByUsers: string;
                AuthRoleNameAlreadyExists: string;
                AuthRoleNameIsSystemRole: string;
                AuthSendMessageWithInstructions: string;
                AuthTokenIsNotCorrect: string;
                AuthUserHasLoggedOut: string;
                AuthUserNameAlreadyExists: string;
                AuthUserNameEmailIsBlocked: string;
                AuthUserNameIsNotSpecified: string;
                AuthUserNameNotAssociatedWithYourAccount: string;
                AuthUserNameOrPasswordIsNotCorrect: string;
                AuthUserNameShouldLookLikeAnEmailAddress: string;
                AuthWorkspaceNameAlreadyInUse: string;
                CommandTimeOut: string;
                Congratulations: string;
                EndDateShouldBeGreaterThanCurrentDate: string;
                EndDateShouldBeGreaterThanStartDate: string;
                ExecutionError: string;
                IsIdentical: string;
                IsNotAuthorized: string;
                IsNotCorrect: string;
                IsNotDeleted: string;
                IsNotEqual: string;
                IsNotFound: string;
                IsNotRecognized: string;
                IsNotSpecified: string;
                IsRequiredFile: string;
                ItemCantBeAttachedToItself: string;
                ItemCantBeDeletedBecauseItemIsAttachedToOtherItems: string;
                ItemCantBeMovedToSpecifiedPlace: string;
                ItemDoesNotSupport: string;
                KeyAndToKeyAreEqual: string;
                MaximumComputers: string;
                MessageMaximumFileSizeExceeded: string;
                NewDesignerAvailable: string;
                NewProduct: string;
                NewVersionsAvailable: string;
                NotificationFailed: string;
                NotificationFailedAddFollowingFiles: string;
                NotificationFilesUploadingComplete: string;
                NotificationFileUploading: string;
                NotificationItemDelete: string;
                NotificationItemDeleteComplete: string;
                NotificationItemRestore: string;
                NotificationItemRestoreComplete: string;
                NotificationItemTransfer: string;
                NotificationItemTransferComplete: string;
                NotificationItemWaitingProcessing: string;
                NotificationMailing: string;
                NotificationMailingComplete: string;
                NotificationMailingWaitingProcessing: string;
                NotificationOperationAborted: string;
                NotificationRecycleBinCleaning: string;
                NotificationRecycleBinCleaningComplete: string;
                NotificationRecycleBinWaitingProcessing: string;
                NotificationReportExporting: string;
                NotificationReportExportingComplete: string;
                NotificationReportRendering: string;
                NotificationReportRenderingComplete: string;
                NotificationReportWaitingProcessing: string;
                NotificationSchedulerRunning: string;
                NotificationSchedulerRunningComplete: string;
                NotificationSchedulerWaitingProcessing: string;
                NotificationTitleFilesUploading: string;
                NotificationTitleItemRefreshing: string;
                NotificationTitleItemTransferring: string;
                NotificationTitleMailing: string;
                NotificationTitleReportExporting: string;
                NotificationTitleReportRendering: string;
                NotificationTitleSchedulerRunning: string;
                NotificationTransferring: string;
                NotificationTransferringComplete: string;
                NotificationValueIsNotCorrect: string;
                OutOfRange: string;
                ParsingCommandException: string;
                PleaseLogin: string;
                QuotaMaximumComputingCyclesCountExceeded: string;
                QuotaMaximumDataRowsCountExceeded: string;
                QuotaMaximumFileSizeExceeded: string;
                QuotaMaximumItemsCountExceeded: string;
                QuotaMaximumRefreshCountExceeded: string;
                QuotaMaximumReportPagesCountExceeded: string;
                QuotaMaximumResourcesCountExceeded: string;
                QuotaMaximumResourceSizeExceeded: string;
                QuotaMaximumUsersCountExceeded: string;
                QuotaMaximumWorkspacesCountExceeded: string;
                SchedulerCantRunItSelf: string;
                SessionTimeOut: string;
                SnapshotAlreadyProcessed: string;
                SpecifiedItemIsNot: string;
                SubscriptionExpired: string;
                SubscriptionExpiredDate: string;
                SubscriptionExpiredExt: string;
                SubscriptionsOut10: string;
                SubscriptionsOut20: string;
                SuccessfullyRenewed: string;
                TrialToLicense: string;
                VersionCopyFromItem: string;
                VersionCreatedFromFile: string;
                VersionCreatedFromItem: string;
                VersionLoadedFromFile: string;
                VersionNewItemCreation: string;
                Warning: string;
                WindowClosePreventWhileUploading: string;
                WithSpecifiedKeyIsNotFound: string;
                WouldYouLikeToUpdateNow: string;
                YourTimeSessionHasExpired: string;
                YourTrialHasExpired: string;
                YourTrialWillExpire: string;
                YouUsingTrialVersion: string;
            };
            NuGet: {
                AlreadyDownloaded: string;
                AssemblyLoadedSuccessfully: string;
                AssemblyNotFound: string;
                Author: string;
                Dependencies: string;
                Download: string;
                DownloadAll: string;
                DownloadAndInstall: string;
                DownloadDataAdapter: string;
                Downloads: string;
                IAccept: string;
                IDecline: string;
                LicenceFormDesc: string;
                LicenceFormDesc1: string;
                LicenceFormTitle: string;
                License: string;
                ProjectUrl: string;
                ReportAbuse: string;
                RetrievingInformation: string;
                Tags: string;
                Title: string;
                ViewLicense: string;
            };
            Panels: {
                Dictionary: string;
                Messages: string;
                Properties: string;
                ReportTree: string;
            };
            Password: {
                gbPassword: string;
                lbPasswordLoad: string;
                lbPasswordSave: string;
                PasswordNotEntered: string;
                StiLoadPasswordForm: string;
                StiSavePasswordForm: string;
            };
            Permissions: {
                AdminAPI: string;
                AdminBackgroundTasks: string;
                AdminPermissions: string;
                AdminRecycleBin: string;
                AdminShare: string;
                AdminTransfers: string;
                ItemCalendars: string;
                ItemCloudStorages: string;
                ItemContactLists: string;
                ItemDashboards: string;
                ItemDataSources: string;
                ItemFiles: string;
                ItemFolders: string;
                ItemReportSnapshots: string;
                ItemReportTemplates: string;
                ItemSchedulers: string;
                ReportDesignerBusinessObjects: string;
                ReportDesignerDataColumns: string;
                ReportDesignerDataConnections: string;
                ReportDesignerDataRelations: string;
                ReportDesignerDataSources: string;
                ReportDesignerDictionaryActions: string;
                ReportDesignerRestrictions: string;
                ReportDesignerVariables: string;
                SystemBackupRestore: string;
                SystemEmailTemplates: string;
                SystemLicensing: string;
                SystemMonitoring: string;
                SystemUpdate: string;
                SystemWorkspaces: string;
                TextAdministration: string;
                TextItems: string;
                TextReportDesigner: string;
                TextSystem: string;
                TextUsers: string;
                UserHimself: string;
                UserRoles: string;
                Users: string;
                UserWorkspace: string;
            };
            PlacementComponent: {
                MoveLeftFreeSpace: string;
                MoveRightFreeSpace: string;
            };
            PropertyCategory: {
                AppearanceCategory: string;
                AreaCategory: string;
                ArgumentCategory: string;
                AxisCategory: string;
                BarCodeAdditionalCategory: string;
                BarCodeCategory: string;
                BehaviorCategory: string;
                ButtonCategory: string;
                CapNeedle: string;
                CellCategory: string;
                ChartAdditionalCategory: string;
                ChartCategory: string;
                ChartMap: string;
                CheckCategory: string;
                ColorsCategory: string;
                ColumnsCategory: string;
                ComboBoxCategory: string;
                CommonCategory: string;
                ControlCategory: string;
                ControlsEventsCategory: string;
                CrossTabCategory: string;
                DashboardCategory: string;
                DataCategory: string;
                DataCells: string;
                DatePickerCategory: string;
                DescriptionCategory: string;
                DesignCategory: string;
                DisplayCategory: string;
                EngineCategory: string;
                ExportCategory: string;
                ExportEventsCategory: string;
                FooterTableCategory: string;
                GaugeCategory: string;
                GlobalizationCategory: string;
                GridLinesCategory: string;
                HeaderTableCategory: string;
                HierarchicalCategory: string;
                ImageAdditionalCategory: string;
                ImageCategory: string;
                IndicatorCategory: string;
                InterlacingCategory: string;
                LabelsCategory: string;
                LegendCategory: string;
                ListBoxCategory: string;
                MainCategory: string;
                MarkerCategory: string;
                MiscCategory: string;
                MouseEventsCategory: string;
                NavigationCategory: string;
                NavigationEventsCategory: string;
                Needle: string;
                OnlineMapCategory: string;
                OptionsCategory: string;
                PageAdditionalCategory: string;
                PageCategory: string;
                PageColumnBreakCategory: string;
                ParametersCategory: string;
                PivotTableCategory: string;
                PositionCategory: string;
                PrimitiveCategory: string;
                PrintEventsCategory: string;
                ProgressCategory: string;
                RegionMapCategory: string;
                RenderEventsCategory: string;
                SeriesCategory: string;
                SeriesLabelsCategory: string;
                ShapeCategory: string;
                Size: string;
                SubReportCategory: string;
                TableCategory: string;
                TableOfContents: string;
                TextAdditionalCategory: string;
                TextCategory: string;
                TitleCategory: string;
                TreeViewBoxCategory: string;
                TreeViewCategory: string;
                TrendLineCategory: string;
                TickMarkMajorCategory: string;
                TickMarkMinorCategory: string;
                TickLabelMajorCategory: string;
                TickLabelMinorCategory: string;
                LinearScaleBarCategory: string;
                LinearScaleCategory: string;
                RadialScaleBarCategory: string;
                NeedleCategory: string;
                ValueCategory: string;
                ValueCloseCategory: string;
                ValueEndCategory: string;
                ValueEventsCategory: string;
                ValueHighCategory: string;
                ValueLowCategory: string;
                ValueOpenCategory: string;
                ViewCategory: string;
                WeightCategory: string;
                WinControlCategory: string;
                ZipCodeCategory: string;
            };
            PropertyColor: {
                AliceBlue: string;
                AntiqueWhite: string;
                Aqua: string;
                Aquamarine: string;
                Azure: string;
                Beige: string;
                Bisque: string;
                Black: string;
                BlanchedAlmond: string;
                Blue: string;
                BlueViolet: string;
                Brown: string;
                BurlyWood: string;
                CadetBlue: string;
                Carmine: string;
                Chartreuse: string;
                Chocolate: string;
                Coral: string;
                CornflowerBlue: string;
                Cornsilk: string;
                Crimson: string;
                Cyan: string;
                DarkBlue: string;
                DarkCyan: string;
                DarkGoldenrod: string;
                DarkGray: string;
                DarkGreen: string;
                DarkKhaki: string;
                DarkMagenta: string;
                DarkOliveGreen: string;
                DarkOrange: string;
                DarkOrchid: string;
                DarkRed: string;
                DarkSalmon: string;
                DarkSeaGreen: string;
                DarkSlateBlue: string;
                DarkSlateGray: string;
                DarkTurquoise: string;
                DarkViolet: string;
                DeepPink: string;
                DeepSkyBlue: string;
                DimGray: string;
                DodgerBlue: string;
                Firebrick: string;
                FloralWhite: string;
                ForestGreen: string;
                Fuchsia: string;
                Gainsboro: string;
                GhostWhite: string;
                Gold: string;
                Goldenrod: string;
                Gray: string;
                Green: string;
                GreenYellow: string;
                Honeydew: string;
                HotPink: string;
                IndianRed: string;
                Indigo: string;
                Ivory: string;
                Khaki: string;
                Lavender: string;
                LavenderBlush: string;
                LawnGreen: string;
                LemonChiffon: string;
                LightBlue: string;
                LightCoral: string;
                LightCyan: string;
                LightGoldenrodYellow: string;
                LightGray: string;
                LightGreen: string;
                LightPink: string;
                LightSalmon: string;
                LightSeaGreen: string;
                LightSkyBlue: string;
                LightSlateGray: string;
                LightSteelBlue: string;
                LightYellow: string;
                Lime: string;
                LimeGreen: string;
                Linen: string;
                Magenta: string;
                Maroon: string;
                MediumAquamarine: string;
                MediumBlue: string;
                MediumOrchid: string;
                MediumPurple: string;
                MediumSeaGreen: string;
                MediumSlateBlue: string;
                MediumSpringGreen: string;
                MediumTurquoise: string;
                MediumVioletRed: string;
                MidnightBlue: string;
                MintCream: string;
                MistyRose: string;
                Moccasin: string;
                NavajoWhite: string;
                Navy: string;
                OldLace: string;
                Olive: string;
                OliveDrab: string;
                Orange: string;
                OrangeRed: string;
                Orchid: string;
                PaleGoldenrod: string;
                PaleGreen: string;
                PaleTurquoise: string;
                PaleVioletRed: string;
                PapayaWhip: string;
                PeachPuff: string;
                Peru: string;
                Pink: string;
                Plum: string;
                PowderBlue: string;
                Purple: string;
                Red: string;
                RosyBrown: string;
                RoyalBlue: string;
                SaddleBrown: string;
                Salmon: string;
                SandyBrown: string;
                SeaGreen: string;
                SeaShell: string;
                Sienna: string;
                Silver: string;
                SkyBlue: string;
                SlateBlue: string;
                SlateGray: string;
                Snow: string;
                SpringGreen: string;
                SteelBlue: string;
                Tan: string;
                Teal: string;
                Thistle: string;
                Tomato: string;
                Transparent: string;
                Turquoise: string;
                VeryDarkGray: string;
                Violet: string;
                Wheat: string;
                White: string;
                WhiteSmoke: string;
                Yellow: string;
                YellowGreen: string;
            };
            PropertyEnum: {
                boolFalse: string;
                boolTrue: string;
                BorderStyleFixed3D: string;
                BorderStyleFixedSingle: string;
                BorderStyleNone: string;
                ChartAxesTicksAll: string;
                ChartAxesTicksMajor: string;
                ChartAxesTicksNone: string;
                ChartGridLinesAll: string;
                ChartGridLinesMajor: string;
                ChartGridLinesNone: string;
                ComboBoxStyleDropDown: string;
                ComboBoxStyleDropDownList: string;
                ComboBoxStyleSimple: string;
                ContentAlignmentBottomCenter: string;
                ContentAlignmentBottomLeft: string;
                ContentAlignmentBottomRight: string;
                ContentAlignmentMiddleCenter: string;
                ContentAlignmentMiddleLeft: string;
                ContentAlignmentMiddleRight: string;
                ContentAlignmentTopCenter: string;
                ContentAlignmentTopLeft: string;
                ContentAlignmentTopRight: string;
                DataGridLineStyleNone: string;
                DataGridLineStyleSolid: string;
                DateTimePickerFormatCustom: string;
                DateTimePickerFormatLong: string;
                DateTimePickerFormatShort: string;
                DateTimePickerFormatTime: string;
                DialogResultAbort: string;
                DialogResultCancel: string;
                DialogResultIgnore: string;
                DialogResultNo: string;
                DialogResultNone: string;
                DialogResultOK: string;
                DialogResultRetry: string;
                DialogResultYes: string;
                DuplexDefault: string;
                DuplexHorizontal: string;
                DuplexSimplex: string;
                DuplexVertical: string;
                FormStartPositionCenterParent: string;
                FormStartPositionCenterScreen: string;
                FormStartPositionManual: string;
                FormStartPositionWindowsDefaultBounds: string;
                FormStartPositionWindowsDefaultLocation: string;
                FormWindowStateMaximized: string;
                FormWindowStateMinimized: string;
                FormWindowStateNormal: string;
                HorizontalAlignmentCenter: string;
                HorizontalAlignmentLeft: string;
                HorizontalAlignmentRight: string;
                HotkeyPrefixHide: string;
                HotkeyPrefixNone: string;
                HotkeyPrefixShow: string;
                LeftRightAlignmentLeft: string;
                LeftRightAlignmentRight: string;
                PictureBoxSizeModeAutoSize: string;
                PictureBoxSizeModeCenterImage: string;
                PictureBoxSizeModeNormal: string;
                PictureBoxSizeModeStretchImage: string;
                RelationDirectionChildToParent: string;
                RelationDirectionParentToChild: string;
                RightToLeftInherit: string;
                RightToLeftNo: string;
                RightToLeftYes: string;
                SelectionModeMultiExtended: string;
                SelectionModeMultiSimple: string;
                SelectionModeNone: string;
                SelectionModeOne: string;
                StiAnchorModeBottom: string;
                StiAnchorModeLeft: string;
                StiAnchorModeRight: string;
                StiAnchorModeTop: string;
                StiAngleAngle0: string;
                StiAngleAngle180: string;
                StiAngleAngle270: string;
                StiAngleAngle45: string;
                StiAngleAngle90: string;
                StiArrowStyleArc: string;
                StiArrowStyleArcAndCircle: string;
                StiArrowStyleCircle: string;
                StiArrowStyleLines: string;
                StiArrowStyleNone: string;
                StiArrowStyleTriangle: string;
                StiBorderSidesAll: string;
                StiBorderSidesBottom: string;
                StiBorderSidesLeft: string;
                StiBorderSidesNone: string;
                StiBorderSidesRight: string;
                StiBorderSidesTop: string;
                StiBorderStyleBump: string;
                StiBorderStyleEtched: string;
                StiBorderStyleFlat: string;
                StiBorderStyleNone: string;
                StiBorderStyleRaised: string;
                StiBorderStyleRaisedInner: string;
                StiBorderStyleRaisedOuter: string;
                StiBorderStyleSunken: string;
                StiBorderStyleSunkenInner: string;
                StiBorderStyleSunkenOuter: string;
                StiBrushTypeGlare: string;
                StiBrushTypeGradient0: string;
                StiBrushTypeGradient180: string;
                StiBrushTypeGradient270: string;
                StiBrushTypeGradient45: string;
                StiBrushTypeGradient90: string;
                StiBrushTypeSolid: string;
                StiCalculationModeCompilation: string;
                StiCalculationModeInterpretation: string;
                StiCapStyleArrow: string;
                StiCapStyleDiamond: string;
                StiCapStyleNone: string;
                StiCapStyleOpen: string;
                StiCapStyleOval: string;
                StiCapStyleSquare: string;
                StiCapStyleStealth: string;
                StiChartLabelsStyleCategory: string;
                StiChartLabelsStyleCategoryPercentOfTotal: string;
                StiChartLabelsStyleCategoryValue: string;
                StiChartLabelsStylePercentOfTotal: string;
                StiChartLabelsStyleValue: string;
                StiChartTitleDockBottom: string;
                StiChartTitleDockLeft: string;
                StiChartTitleDockRight: string;
                StiChartTitleDockTop: string;
                StiChartTrendLineTypeExponential: string;
                StiChartTrendLineTypeLinear: string;
                StiChartTrendLineTypeLogarithmic: string;
                StiChartTrendLineTypeNone: string;
                StiCheckStyleCheck: string;
                StiCheckStyleCheckRectangle: string;
                StiCheckStyleCross: string;
                StiCheckStyleCrossCircle: string;
                StiCheckStyleCrossRectangle: string;
                StiCheckStyleDotCircle: string;
                StiCheckStyleDotRectangle: string;
                StiCheckStyleNone: string;
                StiCheckStyleNoneCircle: string;
                StiCheckStyleNoneRectangle: string;
                StiCheckSumNo: string;
                StiCheckSumYes: string;
                StiCode11CheckSumAuto: string;
                StiCode11CheckSumNone: string;
                StiCode11CheckSumOneDigit: string;
                StiCode11CheckSumTwoDigits: string;
                StiColorScaleTypeColor2: string;
                StiColorScaleTypeColor3: string;
                StiColumnDirectionAcrossThenDown: string;
                StiColumnDirectionDownThenAcross: string;
                StiCrossHorAlignmentCenter: string;
                StiCrossHorAlignmentLeft: string;
                StiCrossHorAlignmentNone: string;
                StiCrossHorAlignmentRight: string;
                StiDashboardContentAlignmentCenter: string;
                StiDashboardContentAlignmentLeft: string;
                StiDashboardContentAlignmentRight: string;
                StiDashboardContentAlignmentStretchX: string;
                StiDashboardContentAlignmentStretchXY: string;
                StiDateSelectionModeAutoRange: string;
                StiDateSelectionModeRange: string;
                StiDateSelectionModeSingle: string;
                StiDateTimeTypeDate: string;
                StiDateTimeTypeDateAndTime: string;
                StiDateTimeTypeTime: string;
                StiDesignerScaleModeAutomaticScaling: string;
                StiDesignerScaleModeScaling100: string;
                StiDesignerSpecificationAuto: string;
                StiDesignerSpecificationBeginner: string;
                StiDesignerSpecificationBICreator: string;
                StiDesignerSpecificationDeveloper: string;
                StiDirectionBottomToTop: string;
                StiDirectionLeftToRight: string;
                StiDirectionRightToLeft: string;
                StiDirectionTopToBottom: string;
                StiDisplayNameTypeFull: string;
                StiDisplayNameTypeNone: string;
                StiDisplayNameTypeShort: string;
                StiDockStyleBottom: string;
                StiDockStyleFill: string;
                StiDockStyleLeft: string;
                StiDockStyleNone: string;
                StiDockStyleRight: string;
                StiDockStyleTop: string;
                StiDrillDownModeMultiPage: string;
                StiDrillDownModeSinglePage: string;
                StiEanSupplementTypeFiveDigit: string;
                StiEanSupplementTypeNone: string;
                StiEanSupplementTypeTwoDigit: string;
                StiEmptyCellsAsConnectPointsWithLine: string;
                StiEmptyCellsAsGap: string;
                StiEmptyCellsAsZero: string;
                StiEmptySizeModeAlignFooterToBottom: string;
                StiEmptySizeModeAlignFooterToTop: string;
                StiEmptySizeModeDecreaseLastRow: string;
                StiEmptySizeModeIncreaseLastRow: string;
                StiEnumeratorTypeABC: string;
                StiEnumeratorTypeArabic: string;
                StiEnumeratorTypeNone: string;
                StiEnumeratorTypeRoman: string;
                StiExtendedStyleBoolFalse: string;
                StiExtendedStyleBoolFromStyle: string;
                StiExtendedStyleBoolTrue: string;
                StiFilterConditionBeginningWith: string;
                StiFilterConditionBetween: string;
                StiFilterConditionContaining: string;
                StiFilterConditionEndingWith: string;
                StiFilterConditionEqualTo: string;
                StiFilterConditionGreaterThan: string;
                StiFilterConditionGreaterThanOrEqualTo: string;
                StiFilterConditionIsBlank: string;
                StiFilterConditionIsNotBlank: string;
                StiFilterConditionIsNotNull: string;
                StiFilterConditionIsNull: string;
                StiFilterConditionLessThan: string;
                StiFilterConditionLessThanOrEqualTo: string;
                StiFilterConditionNotBetween: string;
                StiFilterConditionNotContaining: string;
                StiFilterConditionNotEqualTo: string;
                StiFilterDataTypeBoolean: string;
                StiFilterDataTypeDateTime: string;
                StiFilterDataTypeExpression: string;
                StiFilterDataTypeNumeric: string;
                StiFilterDataTypeString: string;
                StiFilterEngineReportEngine: string;
                StiFilterEngineSQLQuery: string;
                StiFilterItemArgument: string;
                StiFilterItemExpression: string;
                StiFilterItemValue: string;
                StiFilterItemValueClose: string;
                StiFilterItemValueEnd: string;
                StiFilterItemValueHigh: string;
                StiFilterItemValueLow: string;
                StiFilterItemValueOpen: string;
                StiFilterModeAnd: string;
                StiFilterModeOr: string;
                StiFontIconGroupAccessibilityIcons: string;
                StiFontIconGroupBrandIcons: string;
                StiFontIconGroupDirectionalIcons: string;
                StiFontIconGroupGenderIcons: string;
                StiFontIconGroupMedicalIcons: string;
                StiFontIconGroupPaymentIcons: string;
                StiFontIconGroupSpinnerIcons: string;
                StiFontIconGroupTransportationIcons: string;
                StiFontIconGroupVideoPlayerIcons: string;
                StiFontIconGroupWebApplicationIcons: string;
                StiFontSizeModeAuto: string;
                StiFontSizeModeTarget: string;
                StiFontSizeModeValue: string;
                StiFormStartModeOnEnd: string;
                StiFormStartModeOnPreview: string;
                StiFormStartModeOnStart: string;
                StiGaugeCalculationModeAuto: string;
                StiGaugeCalculationModeCustom: string;
                StiGaugeRangeModePercentage: string;
                StiGaugeRangeModeValue: string;
                StiGaugeRangeTypeColor: string;
                StiGaugeRangeTypeNone: string;
                StiGaugeTypeBullet: string;
                StiGaugeTypeFullCircular: string;
                StiGaugeTypeHalfCircular: string;
                StiGaugeTypeHorizontalLinear: string;
                StiGaugeTypeLinear: string;
                StiGroupSortDirectionAscending: string;
                StiGroupSortDirectionDescending: string;
                StiGroupSortDirectionNone: string;
                StiHorAlignmentCenter: string;
                StiHorAlignmentLeft: string;
                StiHorAlignmentRight: string;
                StiIconAlignmentBottom: string;
                StiIconAlignmentLeft: string;
                StiIconAlignmentNone: string;
                StiIconAlignmentRight: string;
                StiIconAlignmentTop: string;
                StiImageProcessingDuplicatesTypeGlobalHide: string;
                StiImageProcessingDuplicatesTypeGlobalMerge: string;
                StiImageProcessingDuplicatesTypeGlobalRemoveImage: string;
                StiImageProcessingDuplicatesTypeHide: string;
                StiImageProcessingDuplicatesTypeMerge: string;
                StiImageProcessingDuplicatesTypeNone: string;
                StiImageProcessingDuplicatesTypeRemoveImage: string;
                StiImageRotationFlipHorizontal: string;
                StiImageRotationFlipVertical: string;
                StiImageRotationNone: string;
                StiImageRotationRotate180: string;
                StiImageRotationRotate90CCW: string;
                StiImageRotationRotate90CW: string;
                StiInteractionOnClick: string;
                StiInteractionOnClickApplyFilter: string;
                StiInteractionOnClickDrillDown: string;
                StiInteractionOnClickOpenHyperlink: string;
                StiInteractionOnClickShowDashboard: string;
                StiInteractionOnHoverNone: string;
                StiInteractionOnHoverShowHyperlink: string;
                StiInteractionOnHoverShowToolTip: string;
                StiInteractionOpenHyperlinkDestinationCurrentTab: string;
                StiInteractionOpenHyperlinkDestinationNewTab: string;
                StiItemSelectionModeMulti: string;
                StiItemSelectionModeOne: string;
                StiKeepDetailsKeepDetailsTogether: string;
                StiKeepDetailsKeepFirstDetailTogether: string;
                StiKeepDetailsKeepFirstRowTogether: string;
                StiKeepDetailsNone: string;
                StiLabelsPlacementAutoRotation: string;
                StiLabelsPlacementNone: string;
                StiLabelsPlacementOneLine: string;
                StiLabelsPlacementTwoLines: string;
                StiLegendDirectionBottomToTop: string;
                StiLegendDirectionLeftToRight: string;
                StiLegendDirectionRightToLeft: string;
                StiLegendDirectionTopToBottom: string;
                StiLegendHorAlignmentCenter: string;
                StiLegendHorAlignmentLeft: string;
                StiLegendHorAlignmentLeftOutside: string;
                StiLegendHorAlignmentRight: string;
                StiLegendHorAlignmentRightOutside: string;
                StiLegendVertAlignmentBottom: string;
                StiLegendVertAlignmentBottomOutside: string;
                StiLegendVertAlignmentCenter: string;
                StiLegendVertAlignmentTop: string;
                StiLegendVertAlignmentTopOutside: string;
                StiMapModeChoropleth: string;
                StiMapModeOnline: string;
                StiMapTypeGroup: string;
                StiMapTypeHeatmap: string;
                StiMapTypeHeatmapWithGroup: string;
                StiMapTypeIndividual: string;
                StiMapTypeNone: string;
                StiMapTypePoints: string;
                StiMarkerAlignmentCenter: string;
                StiMarkerAlignmentLeft: string;
                StiMarkerAlignmentRight: string;
                StiMarkerTypeCircle: string;
                StiMarkerTypeHalfCircle: string;
                StiMarkerTypeHexagon: string;
                StiMarkerTypeRectangle: string;
                StiMarkerTypeStar5: string;
                StiMarkerTypeStar6: string;
                StiMarkerTypeStar7: string;
                StiMarkerTypeStar8: string;
                StiMarkerTypeTriangle: string;
                StiNestedFactorHigh: string;
                StiNestedFactorLow: string;
                StiNestedFactorNormal: string;
                StiNumberOfPassDoublePass: string;
                StiNumberOfPassSinglePass: string;
                StiOnlineMapHeatmapColorGradientTypeAddRange: string;
                StiOnlineMapHeatmapColorGradientTypeBlackAquaWhite: string;
                StiOnlineMapHeatmapColorGradientTypeBlueRed: string;
                StiOnlineMapHeatmapColorGradientTypeColorSpectrum: string;
                StiOnlineMapHeatmapColorGradientTypeDeepSea: string;
                StiOnlineMapHeatmapColorGradientTypeHeatedMetal: string;
                StiOnlineMapHeatmapColorGradientTypeIncandescent: string;
                StiOnlineMapHeatmapColorGradientTypeSteppedColors: string;
                StiOnlineMapHeatmapColorGradientTypeSunrise: string;
                StiOnlineMapHeatmapColorGradientTypeVisibleSpectrum: string;
                StiOnlineMapLocationTypeAdminDivision1: string;
                StiOnlineMapLocationTypeAdminDivision2: string;
                StiOnlineMapLocationTypeAuto: string;
                StiOnlineMapLocationTypeCountryRegion: string;
                StiOnlineMapLocationTypeNeighborhood: string;
                StiOnlineMapLocationTypePopulatedPlace: string;
                StiOnlineMapLocationTypePostcode1: string;
                StiOnlineMapLocationTypePostcode2: string;
                StiOnlineMapLocationTypePostcode3: string;
                StiOnlineMapLocationTypePostcode4: string;
                StiOrientationHorizontal: string;
                StiOrientationHorizontalRight: string;
                StiOrientationVertical: string;
                StiPageOrientationLandscape: string;
                StiPageOrientationPortrait: string;
                StiPenStyleDash: string;
                StiPenStyleDashDot: string;
                StiPenStyleDashDotDot: string;
                StiPenStyleDot: string;
                StiPenStyleDouble: string;
                StiPenStyleNone: string;
                StiPenStyleSolid: string;
                StiPlesseyCheckSumModulo10: string;
                StiPlesseyCheckSumModulo11: string;
                StiPlesseyCheckSumNone: string;
                StiPreviewModeDotMatrix: string;
                StiPreviewModeStandard: string;
                StiPreviewModeStandardAndDotMatrix: string;
                StiPrintOnEvenOddPagesTypeIgnore: string;
                StiPrintOnEvenOddPagesTypePrintOnEvenPages: string;
                StiPrintOnEvenOddPagesTypePrintOnOddPages: string;
                StiPrintOnTypeAllPages: string;
                StiPrintOnTypeExceptFirstAndLastPage: string;
                StiPrintOnTypeExceptFirstPage: string;
                StiPrintOnTypeExceptLastPage: string;
                StiPrintOnTypeOnlyFirstAndLastPage: string;
                StiPrintOnTypeOnlyFirstPage: string;
                StiPrintOnTypeOnlyLastPage: string;
                StiProcessAtEndOfPage: string;
                StiProcessAtEndOfReport: string;
                StiProcessAtNone: string;
                StiProcessingDuplicatesTypeBasedOnTagHide: string;
                StiProcessingDuplicatesTypeBasedOnTagMerge: string;
                StiProcessingDuplicatesTypeBasedOnTagRemoveText: string;
                StiProcessingDuplicatesTypeBasedOnValueAndTagHide: string;
                StiProcessingDuplicatesTypeBasedOnValueAndTagMerge: string;
                StiProcessingDuplicatesTypeBasedOnValueRemoveText: string;
                StiProcessingDuplicatesTypeGlobalBasedOnValueAndTagHide: string;
                StiProcessingDuplicatesTypeGlobalBasedOnValueAndTagMerge: string;
                StiProcessingDuplicatesTypeGlobalBasedOnValueRemoveText: string;
                StiProcessingDuplicatesTypeGlobalHide: string;
                StiProcessingDuplicatesTypeGlobalMerge: string;
                StiProcessingDuplicatesTypeGlobalRemoveText: string;
                StiProcessingDuplicatesTypeHide: string;
                StiProcessingDuplicatesTypeMerge: string;
                StiProcessingDuplicatesTypeNone: string;
                StiProcessingDuplicatesTypeRemoveText: string;
                StiProgressElementModeCircle: string;
                StiProgressElementModeDataBars: string;
                StiProgressElementModePie: string;
                StiRadarStyleXFCircle: string;
                StiRadarStyleXFPolygon: string;
                StiReportCacheModeAuto: string;
                StiReportCacheModeOff: string;
                StiReportCacheModeOn: string;
                StiReportUnitTypeCentimeters: string;
                StiReportUnitTypeHundredthsOfInch: string;
                StiReportUnitTypeInches: string;
                StiReportUnitTypeMillimeters: string;
                StiReportUnitTypePixels: string;
                StiRestrictionsAll: string;
                StiRestrictionsAllowChange: string;
                StiRestrictionsAllowDelete: string;
                StiRestrictionsAllowMove: string;
                StiRestrictionsAllowResize: string;
                StiRestrictionsAllowSelect: string;
                StiRestrictionsNone: string;
                StiSelectionModeFirst: string;
                StiSelectionModeFromVariable: string;
                StiSelectionModeNothing: string;
                StiSeriesLabelsValueTypeArgument: string;
                StiSeriesLabelsValueTypeArgumentValue: string;
                StiSeriesLabelsValueTypeSeriesTitle: string;
                StiSeriesLabelsValueTypeSeriesTitleArgument: string;
                StiSeriesLabelsValueTypeSeriesTitleValue: string;
                StiSeriesLabelsValueTypeTag: string;
                StiSeriesLabelsValueTypeValue: string;
                StiSeriesLabelsValueTypeValueArgument: string;
                StiSeriesLabelsValueTypeWeight: string;
                StiSeriesSortDirectionAscending: string;
                StiSeriesSortDirectionDescending: string;
                StiSeriesSortTypeArgument: string;
                StiSeriesSortTypeNone: string;
                StiSeriesSortTypeValue: string;
                StiSeriesXAxisBottomXAxis: string;
                StiSeriesXAxisTopXAxis: string;
                StiSeriesYAxisLeftYAxis: string;
                StiSeriesYAxisRightYAxis: string;
                StiShapeDirectionDown: string;
                StiShapeDirectionLeft: string;
                StiShapeDirectionRight: string;
                StiShapeDirectionUp: string;
                StiShiftModeDecreasingSize: string;
                StiShiftModeIncreasingSize: string;
                StiShiftModeNone: string;
                StiShiftModeOnlyInWidthOfComponent: string;
                StiShowSeriesLabelsFromChart: string;
                StiShowSeriesLabelsFromSeries: string;
                StiShowSeriesLabelsNone: string;
                StiShowXAxisBoth: string;
                StiShowXAxisBottom: string;
                StiShowXAxisCenter: string;
                StiShowYAxisBoth: string;
                StiShowYAxisCenter: string;
                StiShowYAxisLeft: string;
                StiSizeModeAutoSize: string;
                StiSizeModeFit: string;
                StiSortDirectionAsc: string;
                StiSortDirectionDesc: string;
                StiSortDirectionNone: string;
                StiSortTypeByDisplayValue: string;
                StiSortTypeByValue: string;
                StiSqlSourceTypeStoredProcedure: string;
                StiSqlSourceTypeTable: string;
                StiStyleComponentTypeChart: string;
                StiStyleComponentTypeCheckBox: string;
                StiStyleComponentTypeCrossTab: string;
                StiStyleComponentTypeImage: string;
                StiStyleComponentTypePrimitive: string;
                StiStyleComponentTypeText: string;
                StiStyleConditionTypeComponentName: string;
                StiStyleConditionTypeComponentType: string;
                StiStyleConditionTypeLocation: string;
                StiStyleConditionTypePlacement: string;
                StiSummaryValuesAllValues: string;
                StiSummaryValuesSkipNulls: string;
                StiSummaryValuesSkipZerosAndNulls: string;
                StiTablceCellTypeCheckBox: string;
                StiTablceCellTypeImage: string;
                StiTablceCellTypeRichText: string;
                StiTablceCellTypeText: string;
                StiTableAutoWidthNone: string;
                StiTableAutoWidthPage: string;
                StiTableAutoWidthTable: string;
                StiTableAutoWidthTypeFullTable: string;
                StiTableAutoWidthTypeLastColumns: string;
                StiTableAutoWidthTypeNone: string;
                StiTargetModePercentage: string;
                StiTargetModeVariation: string;
                StiTextHorAlignmentCenter: string;
                StiTextHorAlignmentLeft: string;
                StiTextHorAlignmentRight: string;
                StiTextHorAlignmentWidth: string;
                StiTextPositionCenterBottom: string;
                StiTextPositionCenterTop: string;
                StiTextPositionLeftBottom: string;
                StiTextPositionLeftTop: string;
                StiTextPositionRightBottom: string;
                StiTextPositionRightTop: string;
                StiTextQualityStandard: string;
                StiTextQualityTypographic: string;
                StiTextQualityWysiwyg: string;
                StiTimeDateStepNone: string;
                StiTimeDateStepSecond: string;
                StiTimeDateStepMinute: string;
                StiTimeDateStepHour: string;
                StiTimeDateStepDay: string;
                StiTimeDateStepMonth: string;
                StiTimeDateStepYear: string;
                StiTitlePositionInside: string;
                StiTitlePositionOutside: string;
                StiTopNModeNone: string;
                StiTopNModeTop: string;
                StiTopNModeBottom: string;
                StiTypeModeList: string;
                StiTypeModeNullableValue: string;
                StiTypeModeRange: string;
                StiTypeModeValue: string;
                StiVertAlignmentBottom: string;
                StiVertAlignmentCenter: string;
                StiVertAlignmentTop: string;
                StiViewModeNormal: string;
                StiViewModePageBreakPreview: string;
                StiXmlTypeAdoNetXml: string;
                StiXmlTypeXml: string;
                StringAlignmentCenter: string;
                StringAlignmentFar: string;
                StringAlignmentNear: string;
                StringTrimmingCharacter: string;
                StringTrimmingEllipsisCharacter: string;
                StringTrimmingEllipsisPath: string;
                StringTrimmingEllipsisWord: string;
                StringTrimmingNone: string;
                StringTrimmingWord: string;
            };
            PropertyEvents: {
                AfterPrintEvent: string;
                AfterSelectEvent: string;
                BeforePrintEvent: string;
                BeginRenderEvent: string;
                CheckedChangedEvent: string;
                ClickEvent: string;
                ClosedFormEvent: string;
                ClosingFormEvent: string;
                ColumnBeginRenderEvent: string;
                ColumnEndRenderEvent: string;
                ConnectedEvent: string;
                ConnectingEvent: string;
                DisconnectedEvent: string;
                DisconnectingEvent: string;
                DoubleClickEvent: string;
                EndRenderEvent: string;
                EnterEvent: string;
                ExportedEvent: string;
                ExportingEvent: string;
                FillParametersEvent: string;
                GetArgumentEvent: string;
                GetBarCodeEvent: string;
                GetBookmarkEvent: string;
                GetPointerEvent: string;
                GetCheckedEvent: string;
                GetCollapsedEvent: string;
                GetCrossValueEvent: string;
                GetCutPieListEvent: string;
                GetDataUrlEvent: string;
                GetDisplayCrossValueEvent: string;
                GetDrillDownReportEvent: string;
                GetExcelSheetEvent: string;
                GetExcelValueEvent: string;
                GetHyperlinkEvent: string;
                GetImageDataEvent: string;
                GetImageURLEvent: string;
                GetListOfArgumentsEvent: string;
                GetListOfHyperlinksEvent: string;
                GetListOfTagsEvent: string;
                GetListOfToolTipsEvent: string;
                GetListOfValuesEndEvent: string;
                GetListOfValuesEvent: string;
                GetListOfWeights: string;
                GetListOfWeightsEvent: string;
                GetSummaryExpressionEvent: string;
                GetTagEvent: string;
                GetTitleEvent: string;
                GetToolTipEvent: string;
                GetValueEndEvent: string;
                GetValueEvent: string;
                GetWeightEvent: string;
                LeaveEvent: string;
                LoadFormEvent: string;
                MouseDownEvent: string;
                MouseEnterEvent: string;
                MouseLeaveEvent: string;
                MouseMoveEvent: string;
                MouseUpEvent: string;
                NewAutoSeriesEvent: string;
                PositionChangedEvent: string;
                PrintedEvent: string;
                PrintingEvent: string;
                ProcessCellEvent: string;
                ProcessChartEvent: string;
                RenderingEvent: string;
                ReportCacheProcessingEvent: string;
                SelectedIndexChangedEvent: string;
                StateRestoreEvent: string;
                StateSaveEvent: string;
                ValueChangedEvent: string;
            };
            PropertyHatchStyle: {
                BackwardDiagonal: string;
                Cross: string;
                DarkDownwardDiagonal: string;
                DarkHorizontal: string;
                DarkUpwardDiagonal: string;
                DarkVertical: string;
                DashedDownwardDiagonal: string;
                DashedHorizontal: string;
                DashedUpwardDiagonal: string;
                DashedVertical: string;
                DiagonalBrick: string;
                DiagonalCross: string;
                Divot: string;
                DottedDiamond: string;
                DottedGrid: string;
                ForwardDiagonal: string;
                Horizontal: string;
                HorizontalBrick: string;
                LargeCheckerBoard: string;
                LargeConfetti: string;
                LargeGrid: string;
                LightDownwardDiagonal: string;
                LightHorizontal: string;
                LightUpwardDiagonal: string;
                LightVertical: string;
                NarrowHorizontal: string;
                NarrowVertical: string;
                OutlinedDiamond: string;
                Percent05: string;
                Percent10: string;
                Percent20: string;
                Percent25: string;
                Percent30: string;
                Percent40: string;
                Percent50: string;
                Percent60: string;
                Percent70: string;
                Percent75: string;
                Percent80: string;
                Percent90: string;
                Plaid: string;
                Shingle: string;
                SmallCheckerBoard: string;
                SmallConfetti: string;
                SmallGrid: string;
                SolidDiamond: string;
                Sphere: string;
                Trellis: string;
                Vertical: string;
                Wave: string;
                Weave: string;
                WideDownwardDiagonal: string;
                WideUpwardDiagonal: string;
                ZigZag: string;
            };
            PropertyMain: {
                AcceptsReturn: string;
                AcceptsTab: string;
                Actual: string;
                AddClearZone: string;
                Advanced: string;
                AggregateFunction: string;
                AggregateFunctions: string;
                Alias: string;
                Alignment: string;
                AllowApplyBorderColor: string;
                AllowApplyBrush: string;
                AllowApplyBrushNegative: string;
                AllowApplyColorNegative: string;
                AllowApplyLineColor: string;
                AllowApplyStyle: string;
                AllowExpressions: string;
                AllowHtmlTags: string;
                AllowSeries: string;
                AllowSeriesElements: string;
                AllowSorting: string;
                AllowUseBackColor: string;
                AllowUseBorder: string;
                AllowUseBorderFormatting: string;
                AllowUseBorderSides: string;
                AllowUseBorderSidesFromLocation: string;
                AllowUseBrush: string;
                AllowUseFont: string;
                AllowUseForeColor: string;
                AllowUseHorAlignment: string;
                AllowUseImage: string;
                AllowUseNegativeTextBrush: string;
                AllowUserValues: string;
                AllowUseTextBrush: string;
                AllowUseTextFormat: string;
                AllowUseTextOptions: string;
                AllowUseVertAlignment: string;
                AllowUsingAsSqlParameter: string;
                AlternatingBackColor: string;
                AlternatingCellBackColor: string;
                AlternatingCellForeColor: string;
                AlternatingDataColor: string;
                AlternatingDataForeground: string;
                Always: string;
                Anchor: string;
                Angle: string;
                Antialiasing: string;
                Area: string;
                Argument: string;
                ArgumentDataColumn: string;
                ArgumentFormat: string;
                Arguments: string;
                ArrowHeight: string;
                ArrowStyle: string;
                ArrowWidth: string;
                AspectRatio: string;
                Author: string;
                Auto: string;
                AutoCalculateCenterPoint: string;
                AutoDataColumns: string;
                AutoDataRows: string;
                AutoLocalizeReportOnRun: string;
                AutoRefresh: string;
                AutoRotate: string;
                AutoScale: string;
                AutoSeriesColorDataColumn: string;
                AutoSeriesKeyDataColumn: string;
                AutoSeriesTitleDataColumn: string;
                AutoWidth: string;
                AutoWidthType: string;
                AvailableInTheViewer: string;
                AxisLabelsColor: string;
                AxisLineColor: string;
                AxisTitleColor: string;
                AxisValue: string;
                BackColor: string;
                Background: string;
                BackgroundColor: string;
                BandColor: string;
                BarCodeType: string;
                BasicStyleColor: string;
                Blend: string;
                Blocks: string;
                Bold: string;
                Bookmark: string;
                Border: string;
                BorderBrush: string;
                BorderColor: string;
                BorderColorNegative: string;
                Borders: string;
                BorderSize: string;
                BorderStyle: string;
                BorderWidth: string;
                Bottom: string;
                BottomSide: string;
                BreakIfLessThan: string;
                Brush: string;
                BrushNegative: string;
                BrushType: string;
                BubbleBackColor: string;
                BubbleBorderColor: string;
                BusinessObject: string;
                CacheAllData: string;
                CacheTotals: string;
                CalcInvisible: string;
                CalculatedDataColumn: string;
                CalculationMode: string;
                CanBreak: string;
                Cancel: string;
                CanGrow: string;
                CanShrink: string;
                Categories: string;
                Category: string;
                CategoryConnections: string;
                CellBackColor: string;
                CellDockStyle: string;
                CellForeColor: string;
                CellHeight: string;
                CellType: string;
                CellWidth: string;
                Center: string;
                CenterPoint: string;
                ChartAreaBorderColor: string;
                ChartAreaBrush: string;
                ChartAreaShowShadow: string;
                ChartType: string;
                Checked: string;
                CheckOnClick: string;
                CheckStyle: string;
                CheckStyleForFalse: string;
                CheckStyleForTrue: string;
                Checksum: string;
                CheckSum: string;
                CheckSum1: string;
                CheckSum2: string;
                Child: string;
                ChildColumns: string;
                ChildSource: string;
                ClearFormat: string;
                CloneContainer: string;
                CloseValues: string;
                Code: string;
                CodePage: string;
                Collapsed: string;
                CollapseGroupFooter: string;
                CollapsingEnabled: string;
                Collate: string;
                CollectionName: string;
                Color: string;
                ColorDataColumn: string;
                ColorEach: string;
                ColorMeter: string;
                Colors: string;
                ColorScaleCondition: string;
                ColorScaleType: string;
                Column: string;
                ColumnCount: string;
                ColumnDirection: string;
                ColumnGaps: string;
                ColumnHeaderBackColor: string;
                ColumnHeaderForeColor: string;
                ColumnHeadersVisible: string;
                Columns: string;
                ColumnWidth: string;
                CommandTimeout: string;
                CompanyPrefix: string;
                ComponentStyle: string;
                Condition: string;
                ConditionOptions: string;
                Conditions: string;
                ConnectionString: string;
                ConnectOnStart: string;
                ConstantLines: string;
                Container: string;
                ContinuousText: string;
                ContentAlignment: string;
                ContourColor: string;
                Converting: string;
                ConvertNulls: string;
                CornerRadius: string;
                Copies: string;
                Count: string;
                CountData: string;
                Create: string;
                CreateFieldOnDoubleClick: string;
                CreateLabel: string;
                CrossFiltering: string;
                Culture: string;
                CustomFonts: string;
                CustomFormat: string;
                CutPieList: string;
                Data: string;
                DataAdapter: string;
                DataAdapters: string;
                DataBarCondition: string;
                DataBindings: string;
                DataCells: string;
                DataColor: string;
                DataColumn: string;
                DataColumns: string;
                DataField: string;
                DataForeground: string;
                DataRelation: string;
                DataRows: string;
                DataSource: string;
                DataSources: string;
                DataTextField: string;
                DataTransformation: string;
                DataType: string;
                DataUrl: string;
                DateInfo: string;
                DateTimeStep: string;
                Default: string;
                DefaultColor: string;
                DefaultHeightCell: string;
                DefaultNamespace: string;
                DependentColumn: string;
                DependentValue: string;
                Description: string;
                Destination: string;
                DetectUrls: string;
                DeviceWidth: string;
                DialogResult: string;
                Diameter: string;
                Direction: string;
                Disabled: string;
                DisplayNameType: string;
                DisplayValue: string;
                Distance: string;
                DistanceBetweenTabs: string;
                Dock: string;
                DockableTable: string;
                DockStyle: string;
                DrawBorder: string;
                DrawHatch: string;
                DrawLine: string;
                DrillDown: string;
                DrillDownEnabled: string;
                DrillDownMode: string;
                DrillDownPage: string;
                DrillDownParameter1: string;
                DrillDownParameter2: string;
                DrillDownParameter3: string;
                DrillDownParameter4: string;
                DrillDownParameter5: string;
                DrillDownParameters: string;
                DrillDownReport: string;
                DropDownAlign: string;
                DropDownStyle: string;
                DropDownWidth: string;
                DropShadow: string;
                Duplex: string;
                Editable: string;
                Effects: string;
                EmptyBorderBrush: string;
                EmptyBorderWidth: string;
                EmptyBrush: string;
                EmptyValue: string;
                Enabled: string;
                EnableLog: string;
                EncodingMode: string;
                EncodingType: string;
                EndCap: string;
                EndColor: string;
                EndValue: string;
                EndValues: string;
                EndWidth: string;
                EngineVersion: string;
                EnumeratorSeparator: string;
                EnumeratorType: string;
                ErrorCorrectionLevel: string;
                ErrorsCorrectionLevel: string;
                EvenStyle: string;
                ExceedMargins: string;
                ExcelSheet: string;
                ExcelValue: string;
                Exponential: string;
                ExportAsImage: string;
                Expression: string;
                ExtensionDigit: string;
                FaqPage: string;
                Field: string;
                FieldIs: string;
                File: string;
                Fill: string;
                FillColor: string;
                Filter: string;
                FilterElements: string;
                FilterEngine: string;
                FilterMode: string;
                FilterOn: string;
                Filters: string;
                FirstTabOffset: string;
                FixedWidth: string;
                Flat: string;
                FlatMode: string;
                Focus: string;
                Font: string;
                FontBold: string;
                FontItalic: string;
                FontName: string;
                FontSize: string;
                FontSizeMode: string;
                FontStrikeout: string;
                FontSubscript: string;
                FontSuperscript: string;
                FontUnderline: string;
                FontUnit: string;
                FooterCanBreak: string;
                FooterCanGrow: string;
                FooterCanShrink: string;
                FooterColor: string;
                FooterFont: string;
                FooterForeColor: string;
                FooterForeground: string;
                FooterPrintAtBottom: string;
                FooterPrintIfEmpty: string;
                FooterPrintOn: string;
                FooterPrintOnAllPages: string;
                FooterPrintOnEvenOddPages: string;
                FooterRowsCount: string;
                Footers: string;
                ForeColor: string;
                Format: string;
                From: string;
                FrozenColumns: string;
                FullConvertExpression: string;
                Function: string;
                Functions: string;
                GisSettings: string;
                GlobalizationStrings: string;
                GlobalizedName: string;
                GlyphColor: string;
                GridColor: string;
                GridLineColor: string;
                GridLinesHor: string;
                GridLinesHorColor: string;
                GridLinesHorRight: string;
                GridLineStyle: string;
                GridLinesVert: string;
                GridLinesVertColor: string;
                GridOutline: string;
                Group: string;
                GroupDataColumn: string;
                GroupMeter: string;
                GrowToHeight: string;
                Heatmap: string;
                HeatmapWithGroup: string;
                Header: string;
                HeaderBackColor: string;
                HeaderCanBreak: string;
                HeaderCanGrow: string;
                HeaderCanShrink: string;
                HeaderColor: string;
                HeaderFont: string;
                HeaderForeColor: string;
                HeaderForeground: string;
                HeaderPrintAtBottom: string;
                HeaderPrintIfEmpty: string;
                HeaderPrintOn: string;
                HeaderPrintOnAllPages: string;
                HeaderPrintOnEvenOddPages: string;
                HeaderRowsCount: string;
                Headers: string;
                HeaderText: string;
                Heading: string;
                HeatmapColors: string;
                Height: string;
                HideSeriesWithEmptyTitle: string;
                HideZeros: string;
                High: string;
                HighlightCondition: string;
                HighValues: string;
                HorAlignment: string;
                HorSpacing: string;
                HotBackColor: string;
                HotColumnHeaderBackColor: string;
                HotForeColor: string;
                HotGlyphColor: string;
                HotHeaderColor: string;
                HotkeyPrefix: string;
                HotRowHeaderBackColor: string;
                HotSelectedBackColor: string;
                HotSelectedForeColor: string;
                HotSelectedGlyphColor: string;
                HtmlTags: string;
                Hyperlink: string;
                HyperlinkDataColumn: string;
                HyperlinkPattern: string;
                Icon: string;
                IconAlignment: string;
                IconColor: string;
                IconSet: string;
                IconSetCondition: string;
                Idents: string;
                Image: string;
                ImageAlign: string;
                ImageAlignment: string;
                ImageData: string;
                ImageHorAlignment: string;
                ImageMultipleFactor: string;
                ImageRotation: string;
                ImageStretch: string;
                ImageTiling: string;
                ImageTransparency: string;
                ImageURL: string;
                ImageVertAlignment: string;
                ImportRelations: string;
                Increment: string;
                Indent: string;
                IndividualColor: string;
                InitBy: string;
                InitialSelection: string;
                InitialSelectionSource: string;
                Insert: string;
                Interaction: string;
                InterlacedBrush: string;
                InterlacingHor: string;
                InterlacingHorBrush: string;
                InterlacingVert: string;
                InterlacingVertBrush: string;
                Interpolation: string;
                IsReversed: string;
                Italic: string;
                Item: string;
                ItemHeight: string;
                Items: string;
                KeepChildTogether: string;
                KeepCrossTabTogether: string;
                KeepDetails: string;
                KeepDetailsTogether: string;
                KeepFooterTogether: string;
                KeepGroupFooterTogether: string;
                KeepGroupHeaderTogether: string;
                KeepGroupTogether: string;
                KeepHeaderTogether: string;
                KeepMergedCellsTogether: string;
                KeepReportSummaryTogether: string;
                KeepSubReportTogether: string;
                Key: string;
                KeyDataColumn: string;
                KeyMeter: string;
                KeyMeters: string;
                Keys: string;
                Label: string;
                LabelColor: string;
                LabelForeground: string;
                LabelRotationMode: string;
                Labels: string;
                LabelsColor: string;
                LabelShadowForeground: string;
                LabelsOffset: string;
                Language: string;
                LargeHeight: string;
                LargeHeightFactor: string;
                Latitude: string;
                LaTexExpression: string;
                Layout: string;
                Left: string;
                LeftSide: string;
                Legend: string;
                LegendBorderColor: string;
                LegendBrush: string;
                LegendLabelsColor: string;
                LegendTitleColor: string;
                LegendValueType: string;
                Length: string;
                LengthUnderLabels: string;
                Lighting: string;
                LimitRows: string;
                Linear: string;
                LinearBarBorderBrush: string;
                LinearBarBrush: string;
                LinearBarEmptyBorderBrush: string;
                LinearBarEmptyBrush: string;
                LineColor: string;
                LineColorNegative: string;
                LineLength: string;
                LineLimit: string;
                LineMarker: string;
                LinearScaleBrush: string;
                LinesOfUnderline: string;
                LineSpacing: string;
                LineStyle: string;
                LineWidth: string;
                Linked: string;
                ListOfArguments: string;
                ListOfHyperlinks: string;
                ListOfTags: string;
                ListOfToolTips: string;
                ListOfValues: string;
                ListOfValuesClose: string;
                ListOfValuesEnd: string;
                ListOfValuesHigh: string;
                ListOfValuesLow: string;
                ListOfValuesOpen: string;
                ListOfWeights: string;
                Localizable: string;
                Location: string;
                Locked: string;
                Logarithmic: string;
                LogarithmicScale: string;
                Longitude: string;
                Low: string;
                LowValues: string;
                MajorInterval: string;
                MapID: string;
                Maps: string;
                MapStyle: string;
                MapType: string;
                Margin: string;
                Margins: string;
                Marker: string;
                MarkerAlignment: string;
                MarkerAngle: string;
                MarkerBorder: string;
                MarkerBrush: string;
                MarkerColor: string;
                MarkerSize: string;
                MarkerType: string;
                MarkerVisible: string;
                MasterComponent: string;
                MasterKeyDataColumn: string;
                MatrixSize: string;
                MaxDate: string;
                MaxDropDownItems: string;
                MaxHeight: string;
                Maximum: string;
                MaximumValue: string;
                MaxLength: string;
                MaxNumberOfLines: string;
                MaxSize: string;
                MaxValue: string;
                MaxWidth: string;
                MergeDuplicates: string;
                MergeHeaders: string;
                Mid: string;
                MinDate: string;
                MinHeight: string;
                Minimum: string;
                MinimumFontSize: string;
                MinimumValue: string;
                MinorColor: string;
                MinorCount: string;
                MinorInterval: string;
                MinorLength: string;
                MinorStyle: string;
                MinorVisible: string;
                MinRowsInColumn: string;
                MinSize: string;
                MinValue: string;
                MinWidth: string;
                MirrorMargins: string;
                Mode: string;
                Module: string;
                Move: string;
                Multiline: string;
                MultipleFactor: string;
                Name: string;
                NameDataColumn: string;
                NameInSource: string;
                NameMeter: string;
                NameParent: string;
                Namespaces: string;
                NeedleBorderBrush: string;
                NeedleBorderWidth: string;
                NeedleBrush: string;
                NeedleCapBorderBrush: string;
                NeedleCapBrush: string;
                Negative: string;
                NegativeColor: string;
                NegativeSeriesColors: string;
                NegativeTextBrush: string;
                NestedLevel: string;
                NewColumnAfter: string;
                NewColumnBefore: string;
                NewPageAfter: string;
                NewPageBefore: string;
                NextPage: string;
                NoElements: string;
                NoIcon: string;
                NullText: string;
                NumberOfColumns: string;
                NumberOfCopies: string;
                NumberOfPass: string;
                NumberOfValues: string;
                OddStyle: string;
                Offset: string;
                OffsetAngle: string;
                OnClick: string;
                OnDataManipulation: string;
                OnHover: string;
                OnlyText: string;
                OpenValues: string;
                Operation: string;
                Options: string;
                Orientation: string;
                OthersText: string;
                Padding: string;
                PageHeight: string;
                PageNumbers: string;
                PageWidth: string;
                Paper: string;
                PaperSize: string;
                PaperSourceOfFirstPage: string;
                PaperSourceOfOtherPages: string;
                Parameter: string;
                Parameters: string;
                ParametersDateFormat: string;
                ParametersOrientation: string;
                ParentColumns: string;
                ParentSource: string;
                ParentValue: string;
                ParetoSeriesColors: string;
                PasswordChar: string;
                Path: string;
                PathData: string;
                PathSchema: string;
                Pattern: string;
                Placement: string;
                PlaceOnToolbox: string;
                PointAtCenter: string;
                Position: string;
                Positive: string;
                PositiveColor: string;
                PreferredColumnWidth: string;
                PreferredRowHeight: string;
                PreventIntersection: string;
                PreviewMode: string;
                PreviewSettings: string;
                Printable: string;
                PrintAtBottom: string;
                PrinterName: string;
                PrinterSettings: string;
                PrintHeadersFootersFromPreviousPage: string;
                PrintIfDetailEmpty: string;
                PrintIfEmpty: string;
                PrintIfParentDisabled: string;
                PrintOn: string;
                PrintOnAllPages: string;
                PrintOnEvenOddPages: string;
                PrintOnPreviousPage: string;
                PrintTitleOnAllPages: string;
                PrintVerticalBars: string;
                ProcessAt: string;
                ProcessAtEnd: string;
                ProcessingDuplicates: string;
                ProcessTilde: string;
                ProductHomePage: string;
                Provider: string;
                Property: string;
                RadarStyle: string;
                RadialBarBorderBrush: string;
                RadialBarBrush: string;
                RadialBarEmptyBorderBrush: string;
                RadialBarEmptyBrush: string;
                Radius: string;
                RadiusMode: string;
                Range: string;
                RangeColorMode: string;
                RangeFrom: string;
                RangeMode: string;
                RangeScrollEnabled: string;
                RangeTo: string;
                RangeType: string;
                Ratio: string;
                RatioY: string;
                ReadOnly: string;
                RecentFonts: string;
                ReconnectOnEachRow: string;
                ReferencedAssemblies: string;
                Refresh: string;
                RefreshTime: string;
                Regular: string;
                Relation: string;
                RelationName: string;
                Relations: string;
                RelativeHeight: string;
                RelativeWidth: string;
                RemoveUnusedDataBeforeStart: string;
                RenderTo: string;
                ReportAlias: string;
                ReportAuthor: string;
                ReportCacheMode: string;
                ReportDescription: string;
                ReportIcon: string;
                ReportImage: string;
                ReportName: string;
                ReportUnit: string;
                RequestFromUser: string;
                RequestParameters: string;
                ResetDataSource: string;
                ResetPageNumber: string;
                Resize: string;
                Resource: string;
                Resources: string;
                Restrictions: string;
                RetrieveOnlyUsedData: string;
                ReturnValue: string;
                ReverseHor: string;
                ReverseVert: string;
                Right: string;
                RightSide: string;
                RightToLeft: string;
                Rotation: string;
                RotationLabels: string;
                RotationMode: string;
                Round: string;
                RoundValues: string;
                RowCount: string;
                RowHeaderBackColor: string;
                RowHeaderForeColor: string;
                RowHeadersVisible: string;
                RowHeaderWidth: string;
                Rows: string;
                Scale: string;
                ScaleHor: string;
                ScriptLanguage: string;
                SegmentPerHeight: string;
                SegmentPerWidth: string;
                SelectedBackColor: string;
                SelectedCellBackColor: string;
                SelectedCellForeColor: string;
                SelectedDataColor: string;
                SelectedDataForeground: string;
                SelectedForeColor: string;
                SelectedGlyphColor: string;
                SelectedIndex: string;
                SelectedItem: string;
                SelectedKey: string;
                SelectedValue: string;
                Selection: string;
                SelectionBackColor: string;
                SelectionEnabled: string;
                SelectionForeColor: string;
                SelectionMode: string;
                SeparatorColor: string;
                SerialNumber: string;
                Series: string;
                SeriesColors: string;
                SeriesLabels: string;
                SeriesLabelsBorderColor: string;
                SeriesLabelsBrush: string;
                SeriesLabelsColor: string;
                SeriesLabelsLineColor: string;
                SeriesLighting: string;
                SeriesShowBorder: string;
                SeriesShowShadow: string;
                SeriesTitle: string;
                Shadow: string;
                ShadowBrush: string;
                ShadowColor: string;
                ShadowSize: string;
                ShapeType: string;
                Shift: string;
                ShiftMode: string;
                ShortName: string;
                ShortValue: string;
                ShowPlacemark: string;
                ShowAllValue: string;
                ShowBehind: string;
                ShowBubble: string;
                ShowDialog: string;
                ShowEdgeValues: string;
                ShowHyperlink: string;
                ShowImageBehind: string;
                ShowInLegend: string;
                ShowInnerPoints: string;
                ShowInPercent: string;
                ShowLabels: string;
                ShowLabelText: string;
                ShowLegend: string;
                ShowMarker: string;
                ShowMeanMarkers: string;
                ShowNulls: string;
                ShowOthers: string;
                ShowPercents: string;
                ShowTotalSummary: string;
                ShowQuietZoneIndicator: string;
                ShowQuietZones: string;
                ShowScrollBar: string;
                ShowSelectAll: string;
                ShowSeriesLabels: string;
                ShowShadow: string;
                ShowTotal: string;
                ShowUpDown: string;
                ShowValue: string;
                ShowXAxis: string;
                ShowYAxis: string;
                ShowZeros: string;
                ShrinkFontToFit: string;
                ShrinkFontToFitMinimumSize: string;
                Side: string;
                Sides: string;
                Simple: string;
                Size: string;
                SizeMode: string;
                Skin: string;
                SkipFirst: string;
                SkipIndices: string;
                SkipIndicesObj: string;
                SkipMajorValues: string;
                SkipValues: string;
                SkipValuesObj: string;
                Smoothing: string;
                Sort: string;
                SortBy: string;
                SortDirection: string;
                Sorted: string;
                SortingColumn: string;
                SortingEnabled: string;
                SortType: string;
                Space: string;
                SpaceRatio: string;
                Spacing: string;
                SqlCommand: string;
                StartAngle: string;
                StartCap: string;
                StartColor: string;
                StartFromZero: string;
                StartMode: string;
                StartNewPage: string;
                StartNewPageIfLessThan: string;
                StartPosition: string;
                StartValue: string;
                StartWidth: string;
                Step: string;
                Stop: string;
                StopBeforePage: string;
                StopBeforePrint: string;
                StoreImagesInResources: string;
                Stretch: string;
                StretchToPrintArea: string;
                Strikeout: string;
                StripBrush: string;
                Strips: string;
                Stroke: string;
                StructuredAppendPosition: string;
                StructuredAppendTotal: string;
                Style: string;
                StyleColors: string;
                Styles: string;
                SubReportPage: string;
                Summaries: string;
                Summary: string;
                SummaryAlignment: string;
                SummaryExpression: string;
                SummarySortDirection: string;
                SummaryType: string;
                SummaryValues: string;
                SupplementCode: string;
                SupplementType: string;
                SweepAngle: string;
                SystemFonts: string;
                SystemVariable: string;
                SystemVariables: string;
                Table: string;
                Tag: string;
                TargetColor: string;
                TagDataColumn: string;
                TagValue: string;
                Target: string;
                TargetIcon: string;
                TargetMode: string;
                Tension: string;
                Text: string;
                TextAfter: string;
                TextAlign: string;
                TextAlignment: string;
                TextBefore: string;
                TextBrush: string;
                TextColor: string;
                TextFormat: string;
                TextOnly: string;
                TextOptions: string;
                TextQuality: string;
                TickLabelMajorFont: string;
                TickLabelMajorTextBrush: string;
                TickLabelMinorFont: string;
                TickLabelMinorTextBrush: string;
                TickMarkMajorBorder: string;
                TickMarkMajorBorderWidth: string;
                TickMarkMajorBrush: string;
                TickMarkMinorBorder: string;
                TickMarkMinorBorderWidth: string;
                TickMarkMinorBrush: string;
                Ticks: string;
                Title: string;
                TitleBeforeHeader: string;
                TitleColor: string;
                TitleDirection: string;
                TitleFont: string;
                TitleVisible: string;
                To: string;
                Today: string;
                ToolTip: string;
                ToolTipDataColumn: string;
                Top: string;
                Topmost: string;
                TopmostLine: string;
                TopN: string;
                TopSide: string;
                Total: string;
                TotalLabel: string;
                Totals: string;
                TrackColor: string;
                TransparentColor: string;
                TrendLine: string;
                TrendLineColor: string;
                TrendLines: string;
                TrendLineShowShadow: string;
                TrimExcessData: string;
                Trimming: string;
                Type: string;
                TypeName: string;
                Types: string;
                Underline: string;
                UndoLimit: string;
                Unit: string;
                UnlimitedBreakable: string;
                UnlimitedHeight: string;
                UnlimitedWidth: string;
                UpperMarks: string;
                UseAliases: string;
                UseExternalReport: string;
                UseParentStyles: string;
                UseRangeColor: string;
                UseRectangularSymbols: string;
                UseSeriesColor: string;
                UseStyleOfSummaryInColumnTotal: string;
                UseStyleOfSummaryInRowTotal: string;
                UseValuesFromTheSpecifiedRange: string;
                Value: string;
                ValueClose: string;
                ValueDataColumn: string;
                ValueDataColumnClose: string;
                ValueDataColumnEnd: string;
                ValueDataColumnHigh: string;
                ValueDataColumnLow: string;
                ValueDataColumnOpen: string;
                ValueEnd: string;
                ValueFormat: string;
                ValueHigh: string;
                ValueLow: string;
                ValueMeter: string;
                ValueOpen: string;
                Values: string;
                ValueType: string;
                ValueTypeSeparator: string;
                Variable: string;
                Variables: string;
                Variation: string;
                Version: string;
                VertAlignment: string;
                VertSpacing: string;
                ViewMode: string;
                Visible: string;
                VisualStates: string;
                Watermark: string;
                Weight: string;
                WeightDataColumn: string;
                Weights: string;
                Width: string;
                WindowState: string;
                WordWrap: string;
                Wrap: string;
                WrapGap: string;
                XAxis: string;
                XTopAxis: string;
                YAxis: string;
                YRightAxis: string;
                ZeroColor: string;
                Zoom: string;
            };
            PropertySystemColors: {
                ActiveBorder: string;
                ActiveCaption: string;
                ActiveCaptionText: string;
                AppWorkspace: string;
                Control: string;
                ControlDark: string;
                ControlDarkDark: string;
                ControlLight: string;
                ControlLightLight: string;
                ControlText: string;
                Desktop: string;
                GrayText: string;
                Highlight: string;
                HighlightText: string;
                HotTrack: string;
                InactiveBorder: string;
                InactiveCaption: string;
                InactiveCaptionText: string;
                Info: string;
                InfoText: string;
                Menu: string;
                MenuText: string;
                ScrollBar: string;
                Window: string;
                WindowFrame: string;
                WindowText: string;
            };
            PromptForm: {
                CacheLoginData: string;
            };
            QueryBuilder: {
                AddObject: string;
                AddSubQuery: string;
                AllObjects: string;
                BadFromObjectExpression: string;
                BadObjectName: string;
                BadSelectStatement: string;
                Collections: string;
                CreateLinksFromForeignKeys: string;
                CriteriaAlias: string;
                CriteriaCriteria: string;
                CriteriaExpression: string;
                CriteriaGroupBy: string;
                CriteriaOr: string;
                CriteriaOutput: string;
                CriteriaSortOrder: string;
                CriteriaSortType: string;
                Database: string;
                DataSourceProperties: string;
                DialectDontSupportDatabases: string;
                DialectDontSupportSchemas: string;
                DialectDontSupportUnions: string;
                DialectDontSupportUnionsBrackets: string;
                DialectDontSupportUnionsBracketsInSubQuery: string;
                DialectDontSupportUnionsInSubQueries: string;
                Edit: string;
                EncloseWithBrackets: string;
                Expressions: string;
                InsertEmptyItem: string;
                JoinExpression: string;
                LabelAlias: string;
                LabelFilterObjectsBySchemaName: string;
                LabelJoinExpression: string;
                LabelLeftColumn: string;
                LabelLeftObject: string;
                LabelObject: string;
                LabelRightColumn: string;
                LabelRightObject: string;
                LinkProperties: string;
                MetadataProviderCantExecSQL: string;
                MetaProviderCantLoadMetadata: string;
                MetaProviderCantLoadMetadataForDatabase: string;
                MoveDown: string;
                MoveUp: string;
                NewUnionSubQuery: string;
                NoConnectionObject: string;
                NoTransactionObject: string;
                Objects: string;
                ProcedureParameters: string;
                Procedures: string;
                qnSaveChanges: string;
                Query: string;
                QueryBuilder: string;
                QueryParameters: string;
                QueryProperties: string;
                Remove: string;
                RemoveBrackets: string;
                RunQueryBuilder: string;
                SelectAllFromLeft: string;
                SelectAllFromRight: string;
                SwitchToDerivedTable: string;
                Tables: string;
                UnexpectedTokenAt: string;
                Unions: string;
                UnionSubMenu: string;
                ViewQuery: string;
                Views: string;
            };
            Questions: {
                qnConfiguration: string;
                qnDictionaryNew: string;
                qnLanguageNew: string;
                qnPageDelete: string;
                qnRemove: string;
                qnRemoveService: string;
                qnRemoveServiceCategory: string;
                qnRemoveUnused: string;
                qnReplace: string;
                qnRestoreDefault: string;
                qnSaveChanges: string;
                qnSaveChangesToPreviewPage: string;
                qnSynchronize: string;
                qnSynchronizeServices: string;
            };
            Report: {
                ActiveRelation: string;
                Address: string;
                Alphabetical: string;
                Bands: string;
                Basic: string;
                BasicConfiguration: string;
                BusinessObjects: string;
                Categorized: string;
                Charts: string;
                Checking: string;
                ClickForMoreDetails: string;
                CollapseAll: string;
                Collection: string;
                CompilingReport: string;
                Complete: string;
                Components: string;
                ConnectingToData: string;
                CopyOf: string;
                CreateNewReportPageForm: string;
                CreatingReport: string;
                CrossBands: string;
                Dialogs: string;
                EditStyles: string;
                Enhancements: string;
                Errors: string;
                EventsTab: string;
                ExpandAll: string;
                FilterAnd: string;
                FilterOr: string;
                FinishingReport: string;
                FirstPass: string;
                FixedBugs: string;
                Gallery: string;
                GenerateNewCode: string;
                History: string;
                Infographics: string;
                InfoMessage: string;
                InformationMessages: string;
                LabelAlias: string;
                LabelAuthor: string;
                LabelBackground: string;
                LabelCategory: string;
                LabelCentimeters: string;
                LabelCollectionName: string;
                LabelColor: string;
                LabelCountData: string;
                LabelDataBand: string;
                LabelDataColumn: string;
                LabelDefaultValue: string;
                LabelExpression: string;
                LabelFactorLevel: string;
                LabelFontName: string;
                LabelFunction: string;
                LabelHundredthsOfInch: string;
                LabelInches: string;
                LabelMillimeters: string;
                LabelName: string;
                LabelNameInSource: string;
                LabelNestedLevel: string;
                LabelPassword: string;
                LabelPixels: string;
                LabelQueryTimeout: string;
                LabelSystemVariable: string;
                LabelTableOfContentsHint: string;
                LabelTotals: string;
                LabelType: string;
                LabelUserName: string;
                LabelValue: string;
                LoadingReport: string;
                nameAssembly: string;
                NewFeatures: string;
                No: string;
                NoFixes: string;
                NoIssues: string;
                NoNewVersions: string;
                NotAssigned: string;
                Null: string;
                Obsoleted: string;
                Office2010Back: string;
                PageNofM: string;
                PreparingReport: string;
                Professional: string;
                ProfessionalConfiguration: string;
                PropertiesTab: string;
                RangeAll: string;
                RangeCurrentPage: string;
                RangeInfo: string;
                RangePage: string;
                RangePages: string;
                ReportChecker: string;
                ReportRenderingMessages: string;
                RestartDesigner: string;
                SaveReportPagesOrFormsFromReport: string;
                SavingReport: string;
                SecondPass: string;
                Shapes: string;
                Standard: string;
                StandardConfiguration: string;
                StiEmptyBrush: string;
                StiGlareBrush: string;
                StiGlassBrush: string;
                StiGradientBrush: string;
                StiHatchBrush: string;
                StiSolidBrush: string;
                StyleBad: string;
                StyleGood: string;
                StyleNeutral: string;
                StyleNormal: string;
                StyleNote: string;
                StyleWarning: string;
                VisualDefault: string;
                VisualDisabled: string;
                VisualHovered: string;
                VisualPressed: string;
                VisualChecked: string;
                Warnings: string;
                WhatsNewInVersion: string;
                When: string;
                WhenAnd: string;
                WhenValueIs: string;
            };
            ReportInfo: {
                CheckIssuesAdditionalDescription: string;
                EncryptWithPassword: string;
                EncryptWithPasswordAdditionalDescription: string;
                EncryptWithPasswordDescription: string;
                Info: string;
                ReportOptions: string;
                ReportOptionsAdditionalDescription: string;
            };
            ReportOpen: {
                Browse: string;
                Import: string;
            };
            Services: {
                categoryContextTools: string;
                categoryDesigner: string;
                categoryDictionary: string;
                categoryExport: string;
                categoryLanguages: string;
                categoryPanels: string;
                categoryRender: string;
                categoryShapes: string;
                categorySL: string;
                categorySystem: string;
                categoryTextFormat: string;
            };
            Shapes: {
                Arrow: string;
                BasicShapes: string;
                BentArrow: string;
                BlockArrows: string;
                Chevron: string;
                ComplexArrow: string;
                DiagonalDownLine: string;
                DiagonalUpLine: string;
                Division: string;
                Equal: string;
                EquationShapes: string;
                Flowchart: string;
                FlowchartCard: string;
                FlowchartCollate: string;
                FlowchartDecision: string;
                FlowchartManualInput: string;
                FlowchartOffPageConnector: string;
                FlowchartPreparation: string;
                FlowchartSort: string;
                Frame: string;
                HorizontalLine: string;
                InsertShapes: string;
                LeftAndRightLine: string;
                Lines: string;
                Minus: string;
                Multiply: string;
                Octagon: string;
                Oval: string;
                Parallelogram: string;
                Plus: string;
                Rectangle: string;
                Rectangles: string;
                RegularPentagon: string;
                RoundedRectangle: string;
                ServiceCategory: string;
                ShapeStyles: string;
                SnipDiagonalSideCornerRectangle: string;
                SnipSameSideCornerRectangle: string;
                TopAndBottomLine: string;
                Trapezoid: string;
                Triangle: string;
                VerticalLine: string;
            };
            SystemVariables: {
                Column: string;
                GroupLine: string;
                IsFirstPage: string;
                IsFirstPageThrough: string;
                IsLastPage: string;
                IsLastPageThrough: string;
                Line: string;
                LineABC: string;
                LineRoman: string;
                LineThrough: string;
                PageCopyNumber: string;
                PageNofM: string;
                PageNofMThrough: string;
                PageNumber: string;
                PageNumberThrough: string;
                ReportAlias: string;
                ReportAuthor: string;
                ReportChanged: string;
                ReportCreated: string;
                ReportDescription: string;
                ReportName: string;
                Time: string;
                Today: string;
                TotalPageCount: string;
                TotalPageCountThrough: string;
            };
            TableRibbon: {
                BuiltIn: string;
                Delete: string;
                DeleteColumns: string;
                DeleteRows: string;
                DeleteTable: string;
                DistributeColumns: string;
                DistributeRows: string;
                InsertAbove: string;
                InsertBelow: string;
                InsertLeft: string;
                InsertRight: string;
                PlainTables: string;
                ribbonBarRowsColumns: string;
                ribbonBarTable: string;
                ribbonBarTableStyles: string;
                Select: string;
                SelectColumn: string;
                SelectRow: string;
                SelectTable: string;
            };
            Toolbars: {
                Align: string;
                AlignBottom: string;
                AlignCenter: string;
                AlignLeft: string;
                AlignMiddle: string;
                AlignRight: string;
                AlignToGrid: string;
                AlignTop: string;
                AlignWidth: string;
                BringToFront: string;
                CenterHorizontally: string;
                CenterVertically: string;
                Conditions: string;
                FontGrow: string;
                FontName: string;
                FontShrink: string;
                FontSize: string;
                FontStyleBold: string;
                FontStyleItalic: string;
                FontStyleUnderline: string;
                Link: string;
                Lock: string;
                MakeHorizontalSpacingEqual: string;
                MakeSameHeight: string;
                MakeSameSize: string;
                MakeSameWidth: string;
                MakeVerticalSpacingEqual: string;
                MoveBackward: string;
                MoveForward: string;
                Order: string;
                SendToBack: string;
                Size: string;
                StyleDesigner: string;
                Styles: string;
                TabHome: string;
                TabLayout: string;
                TabPage: string;
                TabView: string;
                TextBrush: string;
                ToolbarAlignment: string;
                ToolbarArrange: string;
                ToolbarBorders: string;
                ToolbarClipboard: string;
                ToolbarDockStyle: string;
                ToolbarFont: string;
                ToolbarFormatting: string;
                ToolbarLayout: string;
                ToolbarPageSetup: string;
                ToolbarStandard: string;
                ToolbarStyle: string;
                ToolbarTextFormat: string;
                ToolbarTools: string;
                ToolbarViewOptions: string;
                ToolbarWatermarkImage: string;
                ToolbarWatermarkText: string;
            };
            Toolbox: {
                Create: string;
                Hand: string;
                Select: string;
                Style: string;
                TextEditor: string;
                title: string;
            };
            WelcomeScreen: {
                AllDownloadsWillCanceled: string;
                Description: string;
                GetStarted: string;
                GetStartedWithDashboards: string;
                GetStartedWithReports: string;
                MoreReports: string;
                ShowNextTime: string;
                Title: string;
            };
            Wizards: {
                BlankDashboard: string;
                BlankForm: string;
                BlankReport: string;
                ButtonBack: string;
                ButtonCancel: string;
                ButtonFinish: string;
                ButtonNext: string;
                ColumnsOrder: string;
                Company: string;
                Custom: string;
                DataRelation: string;
                DataSource: string;
                DataSources: string;
                DefaultThemes: string;
                Filters: string;
                FromReportTemplate: string;
                GetData: string;
                groupCreateNewDashboard: string;
                groupCreateNewPageOrForm: string;
                groupCreateNewReport: string;
                Groups: string;
                groupTemplates: string;
                groupWizards: string;
                infoColumnsOrder: string;
                infoCompanyInfo: string;
                infoDataSource: string;
                infoDataSources: string;
                infoFilters: string;
                infoGroups: string;
                infoLabelSettings: string;
                infoLanguages: string;
                infoLayout: string;
                infoRelation: string;
                infoSelectColumns: string;
                infoSelectTemplate: string;
                infoSort: string;
                infoThemes: string;
                infoTotals: string;
                LabelDirection: string;
                LabelHeight: string;
                LabelHorizontalGap: string;
                LabelLabelType: string;
                LabelLeftMargin: string;
                LabelNumberOfColumns: string;
                LabelNumberOfRows: string;
                LabelPageHeight: string;
                LabelPageWidth: string;
                LabelReport: string;
                LabelSettings: string;
                LabelSize: string;
                LabelTopMargin: string;
                LabelVerticalGap: string;
                LabelWidth: string;
                Layout: string;
                Mapping: string;
                MarkAll: string;
                MasterDetailReport: string;
                NoFunction: string;
                OpenExistingReport: string;
                OpenFrom: string;
                Preview: string;
                Reset: string;
                Results: string;
                RunWizard: string;
                SelectColumns: string;
                SelectTemplate: string;
                Sort: string;
                StandardReport: string;
                Themes: string;
                title: string;
                Totals: string;
                UseDemoData: string;
                UsingReportWizard: string;
                YouHaveNotOpenedAnyReportRecently: string;
            };
            Zoom: {
                EmptyValue: string;
                MultiplePages: string;
                OnePage: string;
                PageHeight: string;
                PageWidth: string;
                TwoPages: string;
                ZoomTo100: string;
            };
        };
        static setLocalization(localizationXml: string, onlyThis?: boolean): void;
        private static _cultureName;
        static get cultureName(): string;
        static set cultureName(value: string);
        static addLocalizationFile(filePath: string, load?: boolean, language?: string): string;
        static setLocalizationFile(filePath: string, onlyThis?: boolean): void;
        static getJsonStringLocalization(): string;
        static loadLocalization(localizationXml: any, extension?: boolean): string;
        static loadLocalizationFile(filePath: string): string;
        private static loadLocalizationXmlInternal;
        static get(category: string, key: string): string;
    }
}
declare namespace Stimulsoft.Base {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiChartNotSupportedException {
        static message: string;
        static getTextJson(chartJson: StiJson): StiJson;
        static getTextXml(chartXml: XmlNode): XmlNode;
        get message(): string;
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiColor {
        static get(color: string): Color;
        static get2(...colors: string[]): Color[];
    }
}
declare namespace Stimulsoft.Base {
    class StiConvert {
        static changeType(value: any, conversionType: Stimulsoft.System.Type, convertNulls?: boolean): any;
    }
}
declare namespace Stimulsoft.Base {
    class StiDashboardNotSupportedException {
        get message(): string;
    }
}
declare namespace Stimulsoft.Base {
    class StiExportNotSupportedException {
        get message(): string;
    }
}
declare namespace Stimulsoft.Base {
    import FontFamily = Stimulsoft.System.Drawing.FontFamily;
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    class StiFontCollection {
        static addOpentypeFont(font: any, fontName?: string, binFont?: any, filePath?: string, fontStyle?: FontStyle, store?: boolean): void;
        static addOpentypeFontFile(filePath: string, fontName?: string, fontStyle?: FontStyle, store?: boolean): void;
        static addOpentypeFontFileAsync(callback: () => {}, filePath: string, fontName?: string, fontStyle?: FontStyle, store?: boolean): void;
        static setOpentypeFontsFolder(folderPatch: string): void;
        static getFontFamilies(): FontFamily[];
        static getBinFont(fontName: string, fontStyle?: FontStyle): any;
        static getBinFonts(): string[];
    }
}
declare namespace Stimulsoft.Base {
    class StiGuidUtils {
        static newGuid(): string;
    }
}
declare namespace Stimulsoft.Base {
    class StiJsonChecker {
        static isValidJson(strInput: string): boolean;
    }
}
declare namespace Stimulsoft.Base {
    class StiKeyHelper {
        static generateKey(): string;
        static isKey(key: string): boolean;
        static isCorrectKey(key: string): boolean;
        static isEmptyKey(key: string): boolean;
        static isEmptyKey2(key1: string, key2: string): boolean;
        static selectKey(key1: string, key2: string): string;
        static isEqualKeys(key1: string, key2: string): boolean;
        static getOrGeneratedKey(key: string): string;
        static getOrGeneratedKey2(key1: string, key2: string): string;
    }
}
declare namespace Stimulsoft.Base {
    class StiKeyObject {
        key: string;
        isStored: string;
        constructor();
    }
}
declare namespace Stimulsoft.Base {
    import List = Stimulsoft.System.Collections.List;
    class StiLexer {
        private _text;
        get text(): string;
        set text(value: string);
        baseText: string;
        private positions;
        positionInText: number;
        savePosToken(): void;
        getPosition(positionInText: number): StiPosition;
        skip(): void;
        waitLparen2(): boolean;
        waitComma2(): boolean;
        waitAssign2(): boolean;
        waitRparen2(): boolean;
        waitLbrace2(): boolean;
        waitSemicolon2(): boolean;
        waitRbrace2(): boolean;
        scanNumber(): StiToken;
        scanIdent(): StiToken;
        scanString(): StiToken;
        scanChar(): StiToken;
        ungetToken(): void;
        getToken(): StiToken;
        reset(): void;
        static replaceWithPrefix(textValue: string, prefix: string, oldValue: string, newValue: string): string;
        replaceWithPrefix(prefix: string, oldValue: string, newValue: string): void;
        replaceWithNotEqualPrefix(prefix: StiTokenType, oldValue: string, newValue: string): void;
        static identExists(str: string, name: string, caseSensitive: boolean): boolean;
        static getAllTokens(str: string): List<StiToken>;
        constructor(textValue: string);
    }
}
declare namespace Stimulsoft.Base {
    class StiMD5Helper {
        static MD5(string: any, convertToUtf8?: boolean): any[];
    }
}
declare namespace Stimulsoft.Base {
    class StiObjectConverter {
        static convertToNumber(value: any): number;
    }
}
declare namespace Stimulsoft.Base {
    class StiPosition {
        line: number;
        column: number;
        constructor(line: number, column: number);
    }
}
declare namespace Stimulsoft.Base {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRepositoryItems implements ICloneable {
        implements(): any[];
        clone(): any;
        private items;
        private valueBoolFalse;
        private valueBoolTrue;
        setNumber(key: string, value: number, defaultValue: number): void;
        getNumber(key: string, defaultValue: number): number;
        setBool(key: string, value: boolean, defaultValue: boolean): void;
        getBool(key: string, defaultValue: boolean): boolean;
        set(key: string, value: any, defaultValue: any): void;
        get(key: string, defaultValue: any): any;
        isPresent(key: string): boolean;
    }
}
declare namespace Stimulsoft.Base {
    class StiScale {
        static xx(value: number): number;
        static yy(value: number): number;
        static factor: number;
    }
}
declare namespace Stimulsoft.Base {
    class StiSettings {
        static get(name: string, def: string): string;
        static set(name: string, value: string): void;
    }
}
declare namespace Stimulsoft.Base {
    class StiToken {
        index: number;
        length: number;
        type: StiTokenType;
        data: string;
        toString(): string;
        constructor(type: StiTokenType, index?: number, length?: number, obj?: any);
    }
}
declare namespace Stimulsoft.Base {
    class StiTypeFinder {
        private static findTypes;
        private static getCorrectTypeName;
        static getStiType(typeName: string): Stimulsoft.System.Type;
        private static addTypeFF;
        private static getTypeFF;
        static findType(exType: Stimulsoft.System.Type, typeForFinding: Stimulsoft.System.Type): boolean;
    }
}
declare namespace Stimulsoft.Base {
    class StiTypeWrapper {
        private _type;
        get type(): Stimulsoft.System.Type;
        toString(): string;
        static toString(type: Stimulsoft.System.Type): string;
        private static _simpleTypes;
        static get simpleTypes(): Stimulsoft.System.Type[];
        private static _simpleBaseTypes;
        static get simpleBaseTypes(): Stimulsoft.System.Type[];
        static getTypeWrappers(): StiTypeWrapper[];
        constructor(type: Stimulsoft.System.Type);
    }
}
declare namespace Stimulsoft.Base {
    class StiUrl {
        static combine(uriParts: string[]): string;
    }
}
declare namespace Stimulsoft {
    class StiVersion {
        static version: string;
        static creationDate: string;
        static created: System.DateTime;
        static versionInfo: string;
        static platform(): string;
    }
}
declare namespace Stimulsoft.Base {
    import DateTime = Stimulsoft.System.DateTime;
    class StringExt {
        static tryParseDateTime(value: string, refDateTime: {
            ref: DateTime;
        }): boolean;
        private static tryParseUsingDate;
        private static tryParseJsonDateTime;
        private static tryParseJsonDateTimeInNewDate;
    }
}
declare namespace Stimulsoft.Base.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    class Font {
        Name: string;
        Size: number;
        Color: Color;
        SelectedColor: Color;
        IsBold: boolean;
        getGdiFont(zoom?: number, fontSize?: number, baseFont?: Stimulsoft.System.Drawing.Font): Stimulsoft.System.Drawing.Font;
        getCachedGdiFont(): Stimulsoft.System.Drawing.Font;
        private cachedFont;
        constructor(name: string, size: number, color: Color, isBold?: boolean);
    }
    export class StiElementConsts {
        static TitleFont: Font;
        static ForegroundColor: Color;
        static BackgroundColor: Color;
        static TreeView: {
            ItemHeight: number;
        };
        static ComboBox: {
            ItemHeight: number;
        };
        static ListBox: {
            ItemHeight: number;
            CheckBoxWidth: number;
        };
        static Table: {
            Font: Font;
            BorderColor: Color;
            Height: number;
            getHeight: (font: Stimulsoft.System.Drawing.Font, scale?: number) => number;
            Header: {
                BackgroundColor: Color;
            };
        };
    }
    export {};
}
declare namespace Stimulsoft.Base {
    enum StiDataFormatType {
        Xml = 0,
        Json = 1
    }
    enum StiRetrieveColumnsMode {
        KeyInfo = 0,
        SchemaOnly = 1,
        FillSchema = 2
    }
    enum StiConnectionIdent {
        Db2DataSource = 1,
        InformixDataSource = 2,
        MsAccessDataSource = 3,
        MsSqlDataSource = 4,
        MySqlDataSource = 5,
        OdbcDataSource = 6,
        OleDbDataSource = 7,
        FirebirdDataSource = 8,
        PostgreSqlDataSource = 9,
        OracleDataSource = 10,
        SqlCeDataSource = 11,
        SqLiteDataSource = 12,
        SybaseDataSource = 13,
        TeradataDataSource = 14,
        VistaDbDataSource = 15,
        UniversalDevartDataSource = 16,
        ODataDataSource = 17,
        CsvDataSource = 18,
        DBaseDataSource = 19,
        DynamicsNavDataSource = 20,
        ExcelDataSource = 21,
        JsonDataSource = 22,
        XmlDataSource = 23,
        DropboxCloudStorage = 24,
        GoogleDriveCloudStorage = 25,
        OneDriveCloudStorage = 26,
        SharePointCloudStorage = 27,
        DataWorldDataSource = 28,
        QuickBooksDataSource = 29,
        Unspecified = 30
    }
    enum StiConnectionOrder {
        MsSqlDataSource = 10,
        MySqlDataSource = 20,
        OdbcDataSource = 30,
        OleDbDataSource = 40,
        OracleDataSource = 50,
        MsAccessDataSource = 60,
        PostgreSqlDataSource = 70,
        FirebirdDataSource = 80,
        SqlCeDataSource = 90,
        SqLiteDataSource = 100,
        Db2DataSource = 110,
        InformixDataSource = 120,
        SybaseDataSource = 130,
        TeradataDataSource = 140,
        VistaDbDataSource = 150,
        UniversalDevartDataSource = 160,
        ODataDataSource = 170,
        ExcelDataSource = 180,
        JsonDataSource = 190,
        XmlDataSource = 200,
        CsvDataSource = 210,
        DBaseDataSource = 220,
        DynamicsNavDataSource = 230,
        DropboxCloudStorage = 240,
        GoogleDriveCloudStorage = 250,
        OneDriveCloudStorage = 260,
        SharePointCloudStorage = 270,
        DataWorldDataSource = 330,
        QuickBooksDataSource = 340,
        Unspecified = 0
    }
    enum StiFileType {
        Unknown = 1,
        ReportSnapshot = 2,
        Pdf = 3,
        Xps = 4,
        PowerPoint = 5,
        Html = 6,
        Text = 7,
        RichText = 8,
        Word = 9,
        OpenDocumentWriter = 10,
        Excel = 11,
        OpenDocumentCalc = 12,
        Data = 13,
        Image = 14,
        Xml = 15,
        Xsd = 16,
        Csv = 17,
        Dbf = 18,
        Sylk = 19,
        Dif = 20,
        Json = 21
    }
}
declare namespace Stimulsoft.Base {
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import DataTable = Stimulsoft.System.Data.DataTable;
    let IStiBIDataCache: System.Interface<IStiBIDataCache>;
    interface IStiBIDataCache {
        exists(dataSource: IStiAppDataSource): boolean;
        exists2(tableKey: string): boolean;
        remove(tableKey: string): void;
        clean(appKey: string): void;
        cleanAll(): void;
        getTableCount(): number;
        getRowCount(tableKey: string): number;
        getSchema(tableKey: string): DataTable;
        getData(tableKey: string): DataTable;
        runQuery(query: string): DataTable;
        add(appKey: string, tableKey: string, dataTable: DataTable): void;
        getTableName(appKey: string, tableKey: string): string;
    }
}
declare namespace Stimulsoft.Base {
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiBIDataCacheHelper {
        private static checkInitialization;
        static exists(tableKey: string): boolean;
        static remove(tableKey: string): void;
        static clean(appKey: string): void;
        static cleanAll(): void;
        static getTableCount(): number;
        static getRowCount(tableKey: string): number;
        static runQuery(query: string): DataTable;
        static get(tableKey: string, loadData?: boolean): DataTable;
        static add(app: IStiApp, tableKey: string, dataTable: DataTable): void;
        static add2(appKey: string, tableKey: string, dataTable: DataTable): void;
        static getTableName(appKey: string, tableKey: string): string;
    }
}
declare namespace Stimulsoft.Base {
    class StiBIDataCacheOptions {
        static enabled: boolean;
        static cache: IStiBIDataCache;
    }
}
declare namespace Stimulsoft.Base.Data.StiDbType {
    enum Db2 {
        Invalid = 0,
        SmallInt = 1,
        Integer = 2,
        BigInt = 3,
        Real = 4,
        Double = 5,
        Float = 6,
        Decimal = 7,
        Numeric = 8,
        Date = 9,
        Time = 10,
        Timestamp = 11,
        Char = 12,
        VarChar = 13,
        LongVarChar = 14,
        Binary = 15,
        VarBinary = 16,
        LongVarBinary = 17,
        Graphic = 18,
        VarGraphic = 19,
        LongVarGraphic = 20,
        Clob = 21,
        Blob = 22,
        DbClob = 23,
        Datalink = 24,
        RowId = 25,
        Xml = 26,
        Real370 = 27,
        DecimalFloat = 28,
        DynArray = 29,
        BigSerial = 30,
        BinaryXml = 31,
        TimeStampWithTimeZone = 32,
        Cursor = 33,
        Serial = 34,
        Int8 = 35,
        Serial8 = 36,
        Money = 37,
        DateTime = 38,
        Text = 39,
        Byte = 40,
        SmallFloat = 1002,
        Null = 1003,
        NChar = 1006,
        NVarChar = 1007,
        Boolean = 1015,
        Other = 1016
    }
    enum DevartMySql {
        BigInt = 1,
        Binary = 2,
        Bit = 3,
        Blob = 4,
        Char = 5,
        Date = 6,
        DateTime = 7,
        Decimal = 8,
        Double = 9,
        Float = 10,
        Int = 11,
        SmallInt = 12,
        Text = 13,
        Time = 14,
        TimeStamp = 15,
        TinyInt = 16,
        VarBinary = 17,
        VarChar = 18,
        Year = 19,
        Guid = 20,
        Geometry = 21
    }
    enum DevartOracle {
        Array = 1,
        BFile = 2,
        Blob = 3,
        Boolean = 4,
        Char = 5,
        Clob = 6,
        Cursor = 7,
        Date = 8,
        Double = 9,
        Float = 10,
        Integer = 11,
        IntervalDS = 12,
        IntervalYM = 13,
        Long = 14,
        LongRaw = 15,
        NChar = 16,
        NClob = 17,
        NVarChar = 18,
        Number = 19,
        Object = 20,
        Ref = 21,
        Raw = 22,
        RowId = 23,
        Table = 24,
        TimeStamp = 25,
        TimeStampLTZ = 26,
        TimeStampTZ = 27,
        VarChar = 28,
        Xml = 29,
        AnyData = 30,
        Byte = 31,
        Int16 = 32,
        Int64 = 33
    }
    enum DevartPostgreSql {
        Row = 1,
        Array = 2,
        LargeObject = 3,
        Boolean = 16,
        ByteA = 17,
        BigInt = 20,
        SmallInt = 21,
        Int = 23,
        Text = 25,
        Json = 114,
        Xml = 142,
        Point = 600,
        LSeg = 601,
        Path = 602,
        Box = 603,
        Polygon = 604,
        Line = 628,
        CIdr = 650,
        Real = 700,
        Double = 701,
        Circle = 718,
        Money = 790,
        MacAddr = 829,
        Inet = 869,
        Char = 1042,
        VarChar = 1043,
        Date = 1082,
        Time = 1083,
        TimeStamp = 1114,
        TimeStampTZ = 1184,
        Interval = 1186,
        TimeTZ = 1266,
        Bit = 1560,
        VarBit = 1562,
        Numeric = 1700,
        Uuid = 2950,
        IntRange = 3904,
        NumericRange = 3906,
        TimeStampRange = 3908,
        TimeStampTZRange = 3910,
        DateRange = 3912,
        BigIntRange = 3926
    }
    enum Firebird {
        Array = 0,
        BigInt = 1,
        Binary = 2,
        Boolean = 3,
        Char = 4,
        Date = 5,
        Decimal = 6,
        Double = 7,
        Float = 8,
        Guid = 9,
        Integer = 10,
        Numeric = 11,
        SmallInt = 12,
        Text = 13,
        Time = 14,
        TimeStamp = 15,
        VarChar = 16
    }
    enum Informix {
        Char = 0,
        SmallInt = 1,
        Integer = 2,
        Float = 3,
        SmallFloat = 4,
        Real = 4,
        Decimal = 5,
        Serial = 6,
        Date = 7,
        Money = 8,
        Null = 9,
        DateTime = 10,
        Byte = 11,
        Text = 12,
        VarChar = 13,
        NChar = 15,
        NVarChar = 16,
        Int8 = 17,
        Serial8 = 18,
        Other = 99,
        LVarChar = 101,
        LongVarChar = 101,
        Blob = 110,
        Clob = 111,
        Boolean = 126,
        Invalid = 200,
        BigInt = 203,
        Double = 205,
        Numeric = 208,
        Time = 210,
        Timestamp = 211,
        Binary = 215,
        VarBinary = 216,
        LongVarBinary = 217,
        BigSerial = 230
    }
    enum MySql {
        Decimal = 0,
        Byte = 1,
        Int16 = 2,
        Int32 = 3,
        Float = 4,
        Double = 5,
        Timestamp = 7,
        Int64 = 8,
        Int24 = 9,
        Date = 10,
        Time = 11,
        DateTime = 12,
        Year = 13,
        Newdate = 14,
        VarString = 15,
        Bit = 16,
        NewDecimal = 246,
        Enum = 247,
        Set = 248,
        TinyBlob = 249,
        MediumBlob = 250,
        LongBlob = 251,
        Blob = 252,
        VarChar = 253,
        String = 254,
        Geometry = 255,
        UByte = 501,
        UInt16 = 502,
        UInt32 = 503,
        UInt64 = 508,
        UInt24 = 509,
        Binary = 600,
        VarBinary = 601,
        TinyText = 749,
        MediumText = 750,
        LongText = 751,
        Text = 752,
        Guid = 800
    }
    enum MsSql {
        BigInt = 0,
        Binary = 1,
        Bit = 2,
        Char = 3,
        DateTime = 4,
        Decimal = 5,
        Float = 6,
        Image = 7,
        Int = 8,
        Money = 9,
        NChar = 10,
        NText = 11,
        NVarChar = 12,
        Real = 13,
        UniqueIdentifier = 14,
        SmallDateTime = 15,
        SmallInt = 16,
        SmallMoney = 17,
        Text = 18,
        Timestamp = 19,
        TinyInt = 20,
        VarBinary = 21,
        VarChar = 22,
        Variant = 23,
        Xml = 25,
        Udt = 29,
        Structured = 30,
        Date = 31,
        Time = 32,
        DateTime2 = 33,
        DateTimeOffset = 34
    }
    enum Odbc {
        BigInt = 1,
        Binary = 2,
        Bit = 3,
        Char = 4,
        DateTime = 5,
        Decimal = 6,
        Numeric = 7,
        Double = 8,
        Image = 9,
        Int = 10,
        NChar = 11,
        NText = 12,
        NVarChar = 13,
        Real = 14,
        UniqueIdentifier = 15,
        SmallDateTime = 16,
        SmallInt = 17,
        Text = 18,
        Timestamp = 19,
        TinyInt = 20,
        VarBinary = 21,
        VarChar = 22,
        Date = 23,
        Time = 24
    }
    enum OleDb {
        Empty = 0,
        SmallInt = 2,
        Integer = 3,
        Single = 4,
        Double = 5,
        Currency = 6,
        Date = 7,
        BSTR = 8,
        IDispatch = 9,
        Error = 10,
        Boolean = 11,
        Variant = 12,
        IUnknown = 13,
        Decimal = 14,
        TinyInt = 16,
        UnsignedTinyInt = 17,
        UnsignedSmallInt = 18,
        UnsignedInt = 19,
        BigInt = 20,
        UnsignedBigInt = 21,
        Filetime = 64,
        Guid = 72,
        Binary = 128,
        Char = 129,
        WChar = 130,
        Numeric = 131,
        DBDate = 133,
        DBTime = 134,
        DBTimeStamp = 135,
        PropVariant = 138,
        VarNumeric = 139,
        VarChar = 200,
        LongVarChar = 201,
        VarWChar = 202,
        LongVarWChar = 203,
        VarBinary = 204,
        LongVarBinary = 205
    }
    enum Oracle {
        BFile = 101,
        Blob = 102,
        Byte = 103,
        Char = 104,
        Clob = 105,
        Date = 106,
        Decimal = 107,
        Double = 108,
        Long = 109,
        LongRaw = 110,
        Int16 = 111,
        Int32 = 112,
        Int64 = 113,
        IntervalDS = 114,
        IntervalYM = 115,
        NClob = 116,
        NChar = 117,
        NVarchar2 = 119,
        Raw = 120,
        RefCursor = 121,
        Single = 122,
        TimeStamp = 123,
        TimeStampLTZ = 124,
        TimeStampTZ = 125,
        Varchar2 = 126,
        XmlType = 127,
        BinaryDouble = 132,
        BinaryFloat = 133
    }
    enum OracleClient {
        BFile = 1,
        Blob = 2,
        Char = 3,
        Clob = 4,
        Cursor = 5,
        DateTime = 6,
        IntervalDayToSecond = 7,
        IntervalYearToMonth = 8,
        LongRaw = 9,
        LongVarChar = 10,
        NChar = 11,
        NClob = 12,
        Number = 13,
        NVarChar = 14,
        Raw = 15,
        RowId = 16,
        Timestamp = 18,
        TimestampLocal = 19,
        TimestampWithTZ = 20,
        VarChar = 22,
        Byte = 23,
        UInt16 = 24,
        UInt32 = 25,
        SByte = 26,
        Int16 = 27,
        Int32 = 28,
        Float = 29,
        Double = 30
    }
    enum PostgreSql {
        Array = -2147483648,
        Bigint = 1,
        Boolean = 2,
        Box = 3,
        Bytea = 4,
        Circle = 5,
        Char = 6,
        Date = 7,
        Double = 8,
        Integer = 9,
        Line = 10,
        LSeg = 11,
        Money = 12,
        Numeric = 13,
        Path = 14,
        Point = 15,
        Polygon = 16,
        Real = 17,
        Smallint = 18,
        Text = 19,
        Time = 20,
        Timestamp = 21,
        Varchar = 22,
        Refcursor = 23,
        Inet = 24,
        Bit = 25,
        TimestampTZ = 26,
        Uuid = 27,
        Xml = 28,
        Oidvector = 29,
        Interval = 30,
        TimeTZ = 31,
        Name = 32,
        Abstime = 33,
        MacAddr = 34,
        Json = 35,
        Jsonb = 36,
        Hstore = 37
    }
    enum SqlCe {
        BigInt = 0,
        Binary = 1,
        Bit = 2,
        Char = 3,
        DateTime = 4,
        Decimal = 5,
        Float = 6,
        Image = 7,
        Int = 8,
        Money = 9,
        NChar = 10,
        NText = 11,
        NVarChar = 12,
        Real = 13,
        UniqueIdentifier = 14,
        SmallDateTime = 15,
        SmallInt = 16,
        SmallMoney = 17,
        Text = 18,
        Timestamp = 19,
        TinyInt = 20,
        VarBinary = 21,
        VarChar = 22,
        Variant = 23,
        Xml = 25,
        Udt = 29,
        Structured = 30,
        Date = 31,
        Time = 32,
        DateTime2 = 33,
        DateTimeOffset = 34
    }
    enum SqLite {
        Uninitialized = 0,
        Int64 = 1,
        Double = 2,
        Text = 3,
        Blob = 4,
        Null = 5,
        DateTime = 10,
        None = 11
    }
    enum Sybase {
        UnsignedBigInt = -208,
        UnsignedInt = -207,
        UnsignedSmallInt = -206,
        NVarChar = -205,
        NChar = -204,
        TimeStamp = -203,
        SmallDateTime = -202,
        SmallMoney = -201,
        Money = -200,
        Unitext = -10,
        UniVarChar = -9,
        UniChar = -8,
        Bit = -7,
        TinyInt = -6,
        BigInt = -5,
        Image = -4,
        VarBinary = -3,
        Binary = -2,
        Text = -1,
        Unsupported = 0,
        Char = 1,
        Numeric = 2,
        Decimal = 3,
        Integer = 4,
        SmallInt = 5,
        Real = 7,
        Double = 8,
        VarChar = 12,
        Date = 91,
        Time = 92,
        BigDateTime = 93,
        DateTime = 93
    }
    enum Teradata {
        BigInt = 90,
        Blob = 100,
        Byte = 110,
        ByteInt = 120,
        Char = 130,
        Clob = 140,
        Date = 150,
        Decimal = 160,
        Double = 170,
        Graphic = 180,
        Integer = 190,
        IntervalDay = 200,
        IntervalDayToHour = 210,
        IntervalDayToMinute = 220,
        IntervalDayToSecond = 230,
        IntervalHour = 240,
        IntervalHourToMinute = 250,
        IntervalHourToSecond = 260,
        IntervalMinute = 270,
        IntervalMinuteToSecond = 280,
        IntervalSecond = 290,
        IntervalYear = 300,
        IntervalYearToMonth = 310,
        IntervalMonth = 320,
        SmallInt = 330,
        Time = 340,
        TimeWithZone = 350,
        Timestamp = 360,
        TimestampWithZone = 370,
        VarByte = 380,
        VarChar = 390,
        VarGraphic = 400,
        PeriodDate = 410,
        PeriodTime = 420,
        PeriodTimeWithTimeZone = 430,
        PeriodTimestamp = 440,
        PeriodTimestampWithTimeZone = 450,
        Number = 460,
        Xml = 480,
        Json = 500,
        AnyType = 65535
    }
    enum Universal {
        Array = 0,
        BigInt = 1,
        Binary = 2,
        Bit = 3,
        Blob = 4,
        Boolean = 5,
        Byte = 6,
        Char = 7,
        Clob = 8,
        Currency = 9,
        Cursor = 10,
        Date = 11,
        DateTime = 12,
        Decimal = 13,
        Double = 14,
        Guid = 15,
        Int = 16,
        IntervalDS = 17,
        IntervalYM = 18,
        NChar = 19,
        NClob = 20,
        NVarChar = 21,
        Object = 22,
        Single = 23,
        SmallInt = 24,
        TinyInt = 25,
        Time = 26,
        TimeStamp = 27,
        VarChar = 28,
        Xml = 29,
        TimeStampTZ = 30,
        DateTime2 = 31
    }
    enum VistaDb {
        Uninitialized = -1,
        Char = 1,
        NChar = 2,
        VarChar = 3,
        NVarChar = 4,
        Text = 5,
        NText = 6,
        TinyInt = 8,
        SmallInt = 9,
        Int = 10,
        BigInt = 11,
        Real = 12,
        Float = 13,
        Decimal = 14,
        Money = 15,
        SmallMoney = 16,
        Bit = 17,
        DateTime = 19,
        Image = 20,
        UniqueIdentifier = 22,
        SmallDateTime = 23,
        Timestamp = 24,
        Binary = 25,
        VarBinary = 26,
        Time = 27,
        Date = 28,
        DateTime2 = 29,
        DateTimeOffset = 30,
        Unknown = 31
    }
    enum Pdo {
        String = 0
    }
}
declare namespace Stimulsoft.ExternalLibrary.XLSX {
    interface IProperties {
        LastAuthor?: string;
        Author?: string;
        CreatedDate?: Date;
        ModifiedDate?: Date;
        Application?: string;
        AppVersion?: string;
        Company?: string;
        DocSecurity?: string;
        Manager?: string;
        HyperlinksChanged?: boolean;
        SharedDoc?: boolean;
        LinksUpToDate?: boolean;
        ScaleCrop?: boolean;
        Worksheets?: number;
        SheetNames?: string[];
    }
    interface IParsingOptions {
        cellFormula?: boolean;
        cellHTML?: boolean;
        cellNF?: boolean;
        cellStyles?: boolean;
        cellDates?: boolean;
        sheetStubs?: boolean;
        sheetRows?: number;
        bookDeps?: boolean;
        bookFiles?: boolean;
        bookProps?: boolean;
        bookSheets?: boolean;
        bookVBA?: boolean;
        password?: string;
        type?: string;
    }
    interface IWorkBook {
        Sheets: {
            [sheet: string]: IWorkSheet;
        };
        SheetNames: string[];
        Props: IProperties;
    }
    interface IWorkSheet {
        [cell: string]: IWorkSheetCell;
    }
    interface IWorkSheetCell {
        t: string;
        v: string;
        r?: string;
        h?: string;
        w?: string;
        f?: string;
        c?: string;
        z?: string;
        l?: string;
        s?: string;
    }
    interface IUtils {
        sheet_to_json<T>(worksheet: IWorkSheet): T[];
        sheet_to_csv(worksheet: IWorkSheet): any;
        sheet_to_formulae(worksheet: IWorkSheet): any;
    }
    let utils: IUtils;
    function readFile(filename: string, opts?: IParsingOptions): IWorkBook;
    function read(data: any, opts?: IParsingOptions): IWorkBook;
}
declare namespace Stimulsoft.Base.Data.Connectors {
    class StiConnectionStringHelper {
        static getConnectionStringKey(connectionString: string, key: string): string;
        static getConnectionStringKey2(connectionString: string): string;
        static setConnectionStringKey(connectionString: string, key: string, value: string): string;
        static removeConnectionStringKey(connectionString: string, key: string): string;
    }
}
declare namespace Stimulsoft.Base {
    class StiDataLoaderHelperData {
        name: string;
        array: any;
        toList(): StiDataLoaderHelperData[];
        constructor(name: string, array: any);
    }
    class StiDataLoaderHelper {
        static loadMultiple(path: string, fileExt: string, binary: boolean, headers: {
            key: string;
            value: string;
        }[]): StiDataLoaderHelperData[];
        static loadSingle(path: string, binary: boolean, headers: {
            key: string;
            value: string;
        }[]): StiDataLoaderHelperData;
    }
}
declare namespace Stimulsoft.Base {
    class StiFileUrlHelper {
        static get(path: string): number[];
    }
}
declare namespace Stimulsoft.Base {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiCsvHelper {
        static codePageCodes: number[];
        static codePageNames: string[];
        static getTable(path: string, codePage?: number, separator?: string): DataTable;
        static getDataSet(data: number[], tableName: string, codePage: number, separator: string): DataSet;
        static getTable2(data: number[], codePage?: number, separator?: string, loadData?: boolean): DataTable;
        private static splitToColumns;
    }
}
declare namespace Stimulsoft.Base {
    class StiDataNameValidator {
        static correct(str: string): string;
    }
}
declare namespace Stimulsoft.Base {
    class StiFileItemTable {
        static defaultCsvTableName: string;
        static defaultDBaseTableName: string;
    }
}
declare namespace Stimulsoft.Base {
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiDataWorldConnector {
        getColumns(collectionName: string): StiDataColumnSchema[];
        getDataTable(collectionName: string, query: string): DataTable;
        getSampleConnectionString(): string;
        retrieveSchema(allowException?: boolean): StiDataSchema;
        testConnection(): StiTestConnectionResult;
        static get(connectionString: string): StiDataWorldConnector;
        connectionString: string;
        constructor(connectionString: string);
    }
}
declare namespace Stimulsoft.Base {
    import List = Stimulsoft.System.Collections.List;
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiDataWorldHelper {
        urlBase: string;
        private getDefaultWebClient;
        getTableNames(): List<string>;
        getColumns(collectionName: string): List<StiDataColumnSchema>;
        getDataTable(collectionName: string, query: string): DataTable;
        testConnection(): StiTestConnectionResult;
        retrieveSchema(): StiDataSchema;
        private getConnectionStringKey;
        private getConnectionStringKey1;
        connectionString: string;
        get owner(): string;
        get token(): string;
        get database(): string;
        constructor(connectionString: string);
    }
}
declare namespace Stimulsoft.Base {
    class StiObjectSchema {
        name: string;
    }
}
declare namespace Stimulsoft.Base {
    import List = Stimulsoft.System.Collections.List;
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiDataSchema extends StiObjectSchema {
        tables: List<StiDataTableSchema>;
        views: List<StiDataTableSchema>;
        storedProcedures: List<StiDataTableSchema>;
        queries: List<StiDataTableSchema>;
        relations: List<StiDataRelationSchema>;
        connectionIdent: StiConnectionIdent;
        isEmpty(): boolean;
        getDataSet(): DataSet;
        sort(): StiDataSchema;
        constructor(ident?: StiConnectionIdent);
    }
}
declare namespace Stimulsoft.Base {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import Type = Stimulsoft.System.Type;
    class StiODataHelper {
        connectionString: string;
        get address(): string;
        get userName(): string;
        get password(): string;
        get addressBearer(): string;
        get clientId(): string;
        headers: {
            key: string;
            value: string;
        }[];
        private getConnectionStringKey;
        private getConnectionStringKey1;
        private bearerAccessToken;
        retrieveSchema(): StiDataSchema;
        fillDataTable(table: DataTable, query: string): void;
        testConnection(): StiTestConnectionResult;
        static getNetType(dbType: string): Type;
        static getBearerAccessToken(url: string, userName: string, password: string, clientId: string): string;
        private getDefaultWebClient;
        constructor(connectionString: string);
    }
}
declare namespace Stimulsoft.Base {
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiQuickBooksConnector {
        private stimulsoftClientId;
        private stimulsoftClientSecret;
        private oauth2Url;
        private bearerUrl;
        private baseUrl;
        private stimulsoftRedirectUrl;
        private responseType;
        private scope;
        private state;
        connectionString: string;
        connectionIdent: StiConnectionIdent;
        connectionOrder: StiConnectionOrder;
        name: string;
        isAvailable: boolean;
        get useApp(): boolean;
        set useApp(value: boolean);
        get clientId(): string;
        set clientId(value: string);
        get clientIdPrivate(): string;
        set clientIdPrivate(value: string);
        get clientSecret(): string;
        set clientSecret(value: string);
        get clientSecretPrivate(): string;
        set clientSecretPrivate(value: string);
        get redirectURL(): string;
        set redirectURL(value: string);
        get redirectURLPrivate(): string;
        set redirectURLPrivate(value: string);
        get authorizationCode(): string;
        set authorizationCode(value: string);
        get realmId(): string;
        set realmId(value: string);
        get accessToken(): string;
        set accessToken(value: string);
        get refreshToken(): string;
        set refreshToken(value: string);
        connectionTimeout: number;
        fillAuthorizationCode(): void;
        private getDefaultWebClient;
        private getAuthorizationUrl;
        fillTokens(): void;
        refreshAccessToken(): void;
        private getTableNames;
        private getColumns;
        retrieveSchema(allowException?: boolean): StiDataSchema;
        getDataTable(collectionName: string, query: string): DataTable;
        fillDataTable(table: DataTable, query: string): void;
        private executeQuery;
        private removeUnsupportedColumns;
        private correctRefColumns;
        getSampleConnectionString(): string;
        static Get(connectionString?: string): StiQuickBooksConnector;
        constructor(connectionString?: string);
    }
}
declare namespace Stimulsoft.Base {
    class StiTestConnectionResult {
        success: boolean;
        notice: string;
        static makeWrong(notice: string): StiTestConnectionResult;
        static makeWrong2(exception: string): StiTestConnectionResult;
        static makeWrong3(): StiTestConnectionResult;
        static makeFine(): StiTestConnectionResult;
    }
}
declare namespace Stimulsoft.Base {
    class StiDataColumnSchema extends StiObjectSchema {
        type: Stimulsoft.System.Type;
        constructor(name?: string, type?: Stimulsoft.System.Type);
    }
}
declare namespace Stimulsoft.Base {
    class StiDataParameterSchema extends StiObjectSchema {
        type: Stimulsoft.System.Type;
        value: any;
        constructor(name?: string, type?: Stimulsoft.System.Type);
    }
}
declare namespace Stimulsoft.Base {
    class StiDataRelationSchema {
        name: string;
        parentSourceName: string;
        childSourceName: string;
        childColumns: string[];
        parentColumns: string[];
    }
}
declare namespace Stimulsoft.Base {
    class StiDataTableSchema extends StiObjectSchema {
        columns: StiDataColumnSchema[];
        parameters: StiDataParameterSchema[];
        query: string;
        static newTableOrView(name: string): StiDataTableSchema;
        static newTable(name: string): StiDataTableSchema;
        static newView(name: string): StiDataTableSchema;
        static newProcedure(name: string): StiDataTableSchema;
        constructor(name?: string, query?: string);
    }
}
declare namespace Stimulsoft.Base.Design {
    let IStiDefault: System.Interface<IStiDefault>;
    interface IStiDefault {
        isDefault(): boolean;
    }
}
declare namespace Stimulsoft.Base.Drawing {
    enum StiCheckState {
        Unchecked = 1,
        Checked = 2,
        Indeterminate = 3
    }
    enum StiAction {
        None = 0,
        Move = 1,
        Select = 2,
        SizeLeft = 3,
        SizeRight = 4,
        SizeTop = 5,
        SizeBottom = 6,
        SizeLeftTop = 7,
        SizeLeftBottom = 8,
        SizeRightTop = 9,
        SizeRightBottom = 10,
        ResizeColumns = 11,
        ResizeRows = 12,
        SelectColumn = 13,
        SelectRow = 14
    }
    enum StiBorderSides {
        None = 0,
        All = 15,
        Top = 1,
        Left = 2,
        Right = 4,
        Bottom = 8
    }
    enum StiPenStyle {
        Solid = 0,
        Dash = 1,
        DashDot = 2,
        DashDotDot = 3,
        Dot = 4,
        Double = 5,
        None = 6
    }
    enum StiRotationMode {
        LeftTop = 0,
        LeftCenter = 1,
        LeftBottom = 2,
        CenterTop = 3,
        CenterCenter = 4,
        CenterBottom = 5,
        RightTop = 6,
        RightCenter = 7,
        RightBottom = 8
    }
    enum StiShadowSides {
        Top = 1,
        Right = 2,
        Edge = 4,
        Bottom = 8,
        Left = 16,
        All = 31
    }
    enum StiVertAlignment {
        Top = 0,
        Center = 1,
        Bottom = 2
    }
    enum StiTextHorAlignment {
        Left = 0,
        Center = 1,
        Right = 2,
        Width = 3
    }
    enum StiHorAlignment {
        Left = 1,
        Center = 2,
        Right = 3
    }
    enum StiTextDockMode {
        Top = 0,
        Bottom = 1,
        Left = 2,
        Right = 3
    }
    enum StiBrushIdent {
        Empty = 1,
        Solid = 2,
        Gradient = 3,
        Glare = 4,
        Glass = 5,
        Hatch = 6
    }
    enum StiBorderIdent {
        Border = 1,
        AdvancedBorder = 2
    }
    enum StiCapStyle {
        None = 0,
        Arrow = 1,
        Open = 2,
        Stealth = 3,
        Diamond = 4,
        Square = 5,
        Oval = 6
    }
    enum StiTableColumnVisibility {
        True = 0,
        False = 1,
        Expression = 2
    }
}
declare namespace Stimulsoft.Base.Drawing {
    let PointD: typeof System.Drawing.Point;
}
declare namespace Stimulsoft.Base.Drawing {
    let RectangleD: typeof System.Drawing.Rectangle;
}
declare namespace Stimulsoft.Base.Drawing {
    let SizeD: typeof System.Drawing.Size;
}
declare namespace Stimulsoft.Base.Drawing {
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiActionUtils {
        static pointInEdge(x: number, y: number, point: Point, size: number): boolean;
        static pointInRect(x: number, y: number, rect: Rectangle): boolean;
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import IAsIs = Stimulsoft.System.IAsIs;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    import Brush = Stimulsoft.System.Drawing.Brush;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiBrush implements ICloneable, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        clone(): StiBrush;
        memberwiseClone(): StiBrush;
        equals(obj: any): boolean;
        static convertToBrush(text: string): StiBrush;
        static loadFromXml(text: string): StiBrush;
        static light(baseBrush: StiBrush, value: number): StiBrush;
        static dark(baseBrush: StiBrush, value: number): StiBrush;
        static getBrush(brush: StiBrush, rect: Rectangle): Brush;
        static toColor(brush: StiBrush): Color;
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSolidBrush extends StiBrush {
        memberwiseClone(): StiBrush;
        private _color;
        get color(): Color;
        set color(value: Color);
        constructor(color?: Color);
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import IAsIs = Stimulsoft.System.IAsIs;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    class StiBorder implements ICloneable, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        private bits;
        clone(): StiBorder;
        equals(obj: StiBorder | any): boolean;
        getSizeOffset(): number;
        getHashCode(): number;
        private defaultHashCode;
        getSizeIncludingSide(): number;
        draw(g: Graphics, rect: Rectangle, zoom: number, emptyColor?: Color, drawBorderFormatting?: boolean, drawBorderSides?: boolean): void;
        drawBorderShadow(g: Graphics, rect: Rectangle, zoom: number): void;
        get isTopBorderSidePresent(): boolean;
        get isBottomBorderSidePresent(): boolean;
        get isLeftBorderSidePresent(): boolean;
        get isRightBorderSidePresent(): boolean;
        get isAllBorderSidesPresent(): boolean;
        private get isDefaultShadowBrush();
        get side(): StiBorderSides;
        set side(value: StiBorderSides);
        get color(): Color;
        set color(value: Color);
        get size(): number;
        set size(value: number);
        get style(): StiPenStyle;
        set style(value: StiPenStyle);
        private _shadowBrush;
        get shadowBrush(): StiBrush;
        set shadowBrush(value: StiBrush);
        get shadowSize(): StiPenStyle;
        set shadowSize(value: StiPenStyle);
        get dropShadow(): boolean;
        set dropShadow(value: boolean);
        get topmost(): boolean;
        set topmost(value: boolean);
        isDefault(): boolean;
        static loadFromXml(text: string): StiBorder;
        constructor(side?: StiBorderSides, color?: Color, size?: number, style?: StiPenStyle, dropShadow?: boolean, shadowSize?: number, shadowBrush?: StiBrush, topmost?: boolean);
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiAdvancedBorder extends StiBorder {
        clone(): StiAdvancedBorder;
        equals(obj: StiAdvancedBorder | any): boolean;
        getHashCode(): number;
        private _leftSide;
        get leftSide(): StiBorderSide;
        private _rightSide;
        get rightSide(): StiBorderSide;
        private _topSide;
        get topSide(): StiBorderSide;
        private _bottomSide;
        get bottomSide(): StiBorderSide;
        get isTopBorderSidePresent(): boolean;
        get isBottomBorderSidePresent(): boolean;
        get isLeftBorderSidePresent(): boolean;
        get isRightBorderSidePresent(): boolean;
        get isAllBorderSidesPresent(): boolean;
        get side(): StiBorderSides;
        set side(value: StiBorderSides);
        get color(): Color;
        set color(value: Color);
        get size(): number;
        set size(value: number);
        get style(): StiPenStyle;
        set style(value: StiPenStyle);
        isDefault(): boolean;
        constructor(topSide?: StiBorderSide, bottomSide?: StiBorderSide, leftSide?: StiBorderSide, rightSide?: StiBorderSide, dropShadow?: boolean, shadowSize?: number, shadowBrush?: StiBrush, topmost?: boolean);
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiAlignHelper {
        static alignToGrid(value: number, gridSize: number, aligningToGrid: boolean): number;
        static alignToGrid2(rect: Rectangle, gridSize: number, aligningToGrid: boolean): Rectangle;
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBorderSide implements ICloneable {
        implements(): any[];
        clone(): StiBorderSide;
        equals(obj: StiBorderSide | any): boolean;
        getHashCode(): number;
        getSizeOffset(): number;
        side: StiBorderSides;
        private _color;
        get color(): Color;
        set color(value: Color);
        private _size;
        get size(): number;
        set size(value: number);
        private _style;
        get style(): StiPenStyle;
        set style(value: StiPenStyle);
        isDefault(): boolean;
        constructor(color?: Color, size?: number, style?: StiPenStyle);
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCap implements ICloneable {
        implements(): any[];
        clone(): StiCap;
        private _width;
        get width(): number;
        set width(value: number);
        private _style;
        get style(): StiCapStyle;
        set style(value: StiCapStyle);
        private _height;
        get height(): number;
        set height(value: number);
        private _fill;
        get fill(): boolean;
        set fill(value: boolean);
        private _color;
        get color(): Color;
        set color(value: Color);
        loadFromXml(xmlNode: XmlNode): void;
        constructor(width?: number, style?: StiCapStyle, height?: number, fill?: boolean, color?: Color);
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiColorUtils {
        static changeLightness(color: Color, correctionFactor: number): Color;
        static changeDarkness(color: Color, percDarker: number): Color;
        static light(baseColor: Color, value: number): Color;
        static mixingColors(color1: Color, color2: Color, alpha: number): Color;
        static dark(baseColor: Color, value: number): Color;
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Brush = Stimulsoft.System.Drawing.Brush;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiDrawing {
        static fillRectangle(g: Graphics, brush: Brush, arg: number | Rectangle, y?: number, width?: number, height?: number): void;
    }
}
declare namespace Stimulsoft.Base.Drawing {
    class StiEmptyBrush extends StiBrush {
        equals(obj: any): boolean;
        private defaultHashCode;
        getHashCode(): number;
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import Font = Stimulsoft.System.Drawing.Font;
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    class StiFontUtils {
        static correctStyle(fontName: string, style: FontStyle): FontStyle;
        static changeFontName(font: Font, newFontName: string): Font;
        static changeFontSize(font: Font, newFontSize: number): Font;
        static changeFontStyle(font: Font, style: FontStyle): Font;
        static changeFontStyle2(fontName: string, fontSize: number, style: FontStyle): Font;
        static changeFontStyleBold(font: Font, bold: boolean): Font;
        static changeFontStyleItalic(font: Font, italic: boolean): Font;
        static changeFontStyleUnderline(font: Font, underline: boolean): Font;
        static changeFontStyleStrikeout(font: Font, strikeout: boolean): Font;
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGlareBrush extends StiBrush {
        memberwiseClone(): StiBrush;
        private _startColor;
        get startColor(): Color;
        set startColor(value: Color);
        private _endColor;
        get endColor(): Color;
        set endColor(value: Color);
        private _angle;
        get angle(): number;
        set angle(value: number);
        private _focus;
        get focus(): number;
        set focus(value: number);
        private _scale;
        get scale(): number;
        set scale(value: number);
        equals(obj: any): boolean;
        private defaultHashCode;
        getHashCode(): number;
        constructor(startColor?: Color, endColor?: Color, angle?: number, focus?: number, scale?: number);
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiGlassBrush extends StiBrush {
        memberwiseClone(): StiBrush;
        private _color;
        get color(): Color;
        set color(value: Color);
        private _drawHatch;
        get drawHatch(): boolean;
        set drawHatch(value: boolean);
        private _blend;
        get blend(): number;
        set blend(value: number);
        equals(obj: any): boolean;
        private defaultHashCode;
        getHashCode(): number;
        getTopColor(): Color;
        getTopColorLight(): Color;
        getBottomColor(): Color;
        getBottomColorLight(): Color;
        getTopRectangle(rect: Rectangle): Rectangle;
        getBottomRectangle(rect: Rectangle): Rectangle;
        constructor(color?: Color, drawHatch?: boolean, blend?: number);
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGradientBrush extends StiBrush {
        memberwiseClone(): StiBrush;
        private _startColor;
        get startColor(): Color;
        set startColor(value: Color);
        private _endColor;
        get endColor(): Color;
        set endColor(value: Color);
        private _angle;
        get angle(): number;
        set angle(value: number);
        equals(obj: any): boolean;
        private defaultHashCode;
        getHashCode(): number;
        constructor(startColor?: Color, endColor?: Color, angle?: number);
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    import HatchStyle = Stimulsoft.System.Drawing.Drawing2D.HatchStyle;
    class StiHatchBrush extends StiBrush {
        memberwiseClone(): StiBrush;
        private _backColor;
        get backColor(): Color;
        set backColor(value: Color);
        private _foreColor;
        get foreColor(): Color;
        set foreColor(value: Color);
        private _style;
        get style(): HatchStyle;
        set style(value: HatchStyle);
        equals(obj: any): boolean;
        private defaultHashCode;
        getHashCode(): number;
        constructor(style?: HatchStyle, foreColor?: Color, backColor?: Color);
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import ImageCodecInfo = Stimulsoft.System.Drawing.Imaging.ImageCodecInfo;
    class StiImageCodecInfo {
        static getImageCodec(mimeType: string): ImageCodecInfo;
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImageConverter {
        static imageToString(image: Image): string;
        static imageToBytes(image: Image, allowNulls?: boolean): number[];
        static bytesToImage(bytes: number[], width?: number, height?: number, stretch?: boolean, aspectRatio?: boolean): Image;
        static stringToImage(str: string): Image;
        static stringToByteArray(str: string): number[];
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImageFromURL {
        static loadBitmap(url: string): Image;
        static loadImage(url: string): Image;
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import DashStyle = Stimulsoft.System.Drawing.Drawing2D.DashStyle;
    class StiPenUtils {
        static getPenStyle(penStyle: StiPenStyle): DashStyle;
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiSimpleBorder implements ICloneable, IStiJsonReportObject {
        clone(): any;
        getBorder(): StiBorder;
        getSizeOffset(): number;
        getSize(): number;
        getSizeIncludingSide(): number;
        get isTopBorderSidePresent(): boolean;
        get isBottomBorderSidePresent(): boolean;
        get isLeftBorderSidePresent(): boolean;
        get isRightBorderSidePresent(): boolean;
        get isAllBorderSidesPresent(): boolean;
        side: StiBorderSides;
        color: Color;
        private shouldSerializeColor;
        size: number;
        style: StiPenStyle;
        isDefault(): boolean;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        constructor(side?: StiBorderSides, color?: Color, size?: number, style?: StiPenStyle);
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import List = Stimulsoft.System.Collections.List;
    import Size = Stimulsoft.System.Drawing.Size;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Font = Stimulsoft.System.Drawing.Font;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    class StiTextDrawing {
        static measureString(g: Graphics, text: string, font: Font, width?: number, textOptions?: StiTextOptions, ha?: StiTextHorAlignment, va?: StiVertAlignment, antialiasing?: boolean, allowHtmlTags?: boolean): Size;
        private static correctFontSize;
        static splitTextWordwrap(text: string, g: Graphics, font: Font, rect: Rectangle, textOptions: StiTextOptions, ha: StiTextHorAlignment, typographic: boolean): List<LineInfo>;
        static splitTextWordwrap2(text: string, g: Graphics, font: Font, rect: Rectangle, sf: StringFormat, horAlignWidth?: boolean): List<LineInfo>;
        private static makeLineInfo;
        static splitString(inputString: string, removeControl: boolean): List<string>;
        static getStringFormat(textOptions: StiTextOptions, ha: StiTextHorAlignment, va: StiVertAlignment, zoom: number): StringFormat;
        static getAlignment(alignment: StiTextHorAlignment): StringAlignment;
        static getAlignment2(alignment: StiVertAlignment): StringAlignment;
        static getStringFormat2(textOptions: StiTextOptions, ha: StiTextHorAlignment, va: StiVertAlignment, antialiasing: boolean, zoom: number): StringFormat;
        static measureTrailingSpaces: boolean;
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
    import HotkeyPrefix = Stimulsoft.System.Drawing.Text.HotkeyPrefix;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTextOptions implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromXml(str: string): StiTextOptions;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiTextOptions;
        private bits;
        getStringFormat(antialiasing?: boolean, zoom?: number): StringFormat;
        get rightToLeft(): boolean;
        set rightToLeft(value: boolean);
        get lineLimit(): boolean;
        set lineLimit(value: boolean);
        private _wordWrap;
        get wordWrap(): boolean;
        set wordWrap(value: boolean);
        get angle(): number;
        set angle(value: number);
        get firstTabOffset(): number;
        set firstTabOffset(value: number);
        get distanceBetweenTabs(): number;
        set distanceBetweenTabs(value: number);
        get hotkeyPrefix(): HotkeyPrefix;
        set hotkeyPrefix(value: HotkeyPrefix);
        get trimming(): StringTrimming;
        set trimming(value: StringTrimming);
        isDefault(): boolean;
        getHashCode(): number;
        constructor(rightToLeft?: boolean, lineLimit?: boolean, wordWrap?: boolean, angle?: number, hotkeyPrefix?: HotkeyPrefix, trimming?: StringTrimming, firstTabOffset?: number, distanceBetweenTabs?: number);
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import List = Stimulsoft.System.Collections.List;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StringBuilder = Stimulsoft.System.Text.StringBuilder;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Font = Stimulsoft.System.Drawing.Font;
    import Size = Stimulsoft.System.Drawing.Size;
    import StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiTextRenderer {
        private static precisionDigits;
        private static defaultParagraphLineHeight;
        static precisionModeFactor: number;
        static precisionModeEnabled: boolean;
        static correctionEnabled: boolean;
        static maxFontSize: number;
        static compatibility2009: boolean;
        static optimizeBottomMargin: boolean;
        private static hashFonts;
        private static getTabsWidth;
        static getFontIndex(fontName: string, fontSize: number, bold: boolean, italic: boolean, underlined: boolean, strikeout: boolean, superOrSubscript: boolean, tempFontList: List<StiFontState>): number;
        private static getFontIndex2;
        private static htmlNameToColor;
        static interpreteFontSizeInHtmlTagsAsInHtml: boolean;
        private static _htmlEscapeSequence;
        private static get htmlEscapeSequence();
        private static convertStringToTag;
        static parseHtmlToStates(inputHtml: string, baseState: StiHtmlState, storeStack?: boolean): StiHtmlState[];
        static prepareStateText(stateText: StringBuilder): StringBuilder;
        static stateToHtml(state: StiHtmlState, state2: StiHtmlState, text: string, lineInfoIndent: number): string;
        private static getIndentString;
        private static bulletBlack;
        private static bulletWhite;
        private static insertMarker;
        private static stackToString;
        private static listLevelsToString;
        private static parseHtmlTag;
        private static parseTagIntoPairs;
        private static parseMarkerTypeAttribute;
        private static parseStyleAttributes;
        private static parseStyleAttribute;
        private static stringToListLevels;
        private static stringToStack;
        private static parseFontSize;
        private static parseSizeToEm;
        private static parseColor;
        static measureString(maxWidth: number, font: Font, text: string, angle?: number, allowHtmlTags?: boolean): Size;
        static getTextLinesAndWidths(g: Graphics, REFtext: any, font: Font, bounds: Rectangle, lineSpacing: number, wordWrap: boolean, rightToLeft: boolean, scale: number, angle: number, trimming: StringTrimming, allowHtmlTags: boolean, REFtextLines: any, REFlinesInfo: any): string[];
        static drawTextForOutput(g: Graphics, text: string, font: Font, bounds: Rectangle, foreColor: Color, backColor: Color, lineSpacing: number, horAlign: StiTextHorAlignment, vertAlign: StiVertAlignment, wordWrap: boolean, rightToLeft: boolean, scale: number, angle: number, trimming: StringTrimming, lineLimit: boolean, allowHtmlTags: boolean, outRunsList: List<RunInfo>, outFontsList: List<StiFontState>, textOptions: StiTextOptions): void;
        static measureText(g: Graphics, text: string, font: Font, bounds: Rectangle, lineSpacing: number, wordWrap: boolean, rightToLeft: boolean, scale: number, angle: number, trimming: StringTrimming, lineLimit: boolean, allowHtmlTags: boolean, textOptions: StiTextOptions): Size;
        private static drawTextBase;
        private static drawTextBase2;
        static StiForceWidthAlignTag: string;
        private static getFontWidth;
        private static getFontWidth2;
        private static isWordWrapSymbol2;
        private static isNotWordWrapSymbol;
        private static isNotWordWrapSymbol2;
        private static isCJKWordWrap;
        private static isCJKSymbol;
    }
    class StiFontState {
        fontName: string;
        fontBase: Font;
        fontScaled: Font;
        superOrSubscriptIndex: number;
        parentFontIndex: number;
        hFont: number;
        hFontScaled: number;
        hScriptCache: number;
        hScriptCacheScaled: number;
        lineHeight: number;
        ascend: number;
        descend: number;
        elipsisWidth: number;
        emValue: number;
        private _fontNameReal;
        get fontNameReal(): string;
    }
    class LineInfo {
        begin: number;
        length: number;
        needWidthAlign: boolean;
        get end(): number;
        set end(value: number);
        width: number;
        widths: number[];
        justifyOffset: number;
        text: string;
        indexOfMaxFont: number;
        lineHeight: number;
        textAlignment: StiTextHorAlignment;
        indent: number;
    }
    class RunInfo {
        text: string;
        xPos: number;
        yPos: number;
        widths: number[];
        glyphWidths: number[];
        textColor: Color;
        backColor: Color;
        fontIndex: number;
        glyphIndexList: number[];
        scaleList: number[];
        href: string;
    }
    enum StiHtmlTag {
        None = 0,
        B = 1,
        I = 2,
        U = 3,
        S = 4,
        Sup = 5,
        Sub = 6,
        Font = 7,
        FontName = 8,
        FontSize = 9,
        FontColor = 10,
        Backcolor = 11,
        LetterSpacing = 12,
        WordSpacing = 13,
        LineHeight = 14,
        TextAlign = 15,
        P = 16,
        Br = 17,
        OrderedList = 18,
        UnorderedList = 19,
        ListItem = 20,
        A = 21,
        Unknown = 22
    }
    enum StiHtmlTag2State {
        Start = 0,
        End = 1,
        Empty = 2
    }
    class StiHtmlTag2 {
        tag: StiHtmlTag;
        tagName: string;
        attributes: List<TagPair>;
        state: StiHtmlTag2State;
        get isStart(): boolean;
        get isEnd(): boolean;
        get isEmpty(): boolean;
        isStartTag(tag: StiHtmlTag): boolean;
        isEndTag(tag: StiHtmlTag): boolean;
        equals(tag2: StiHtmlTag2): boolean;
        toString(): string;
        constructor(tag?: StiHtmlTag, state?: StiHtmlTag2State);
    }
    class StiHtmlTagsState {
        clone(): StiHtmlTagsState;
        getStyleAttribute(name: string): string;
        bold: boolean;
        italic: boolean;
        underline: boolean;
        strikeout: boolean;
        fontSize: number;
        fontName: string;
        fontColor: Color;
        backColor: Color;
        subsript: boolean;
        superscript: boolean;
        letterSpacing: number;
        wordSpacing: number;
        lineHeight: number;
        textAlign: StiTextHorAlignment;
        isColorChanged: boolean;
        isBackcolorChanged: boolean;
        tag: StiHtmlTag2;
        indent: number;
        htmlStyle: string;
        href: string;
        styleAttributes: Hashtable;
        constructor(bold: any, italic?: boolean, underline?: boolean, strikeout?: boolean, fontSize?: number, fontName?: string, fontColor?: Color, backColor?: Color, superscript?: boolean, subscript?: boolean, letterSpacing?: number, wordSpacing?: number, lineHeight?: number, textAlign?: StiTextHorAlignment);
    }
    class StiHtmlState {
        clone(): StiHtmlState;
        ts: StiHtmlTagsState;
        text: StringBuilder;
        fontIndex: number;
        posBegin: number;
        tagsStack: StiHtmlTagsState[];
        listLevels: number[];
        toString(): string;
        constructor(ts: any, posBegin?: number);
    }
    class TagPair {
        key: string;
        keyBase: string;
        value: string;
    }
}
declare namespace Stimulsoft.Base {
    enum StiPlanIdent {
        OnlineTrial = 100,
        OnlineStandard = 101,
        ServerTrial = 200,
        ServerTeam5 = 201,
        ServerTeam10 = 202,
        ServerTeam25 = 203,
        ServerTeam50 = 204,
        ServerBusiness = 205,
        ServerEnterprise = 206,
        ServerWorldWide = 207,
        Test = 300
    }
    enum StiPlanFeatureIdent {
        Cycles = 1
    }
}
declare namespace Stimulsoft.Base.Helpers {
    import DateTime = Stimulsoft.System.DateTime;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    enum DateTimeFormat {
        USA_DATE = 0,
        UK_DATE = 1
    }
    class ParsedDateTime {
        readonly indexOfDate: number;
        readonly lengthOfDate: number;
        readonly indexOfTime: number;
        readonly lengthOfTime: number;
        readonly dateTime: DateTime;
        readonly isDateFound: boolean;
        readonly isTimeFound: boolean;
        readonly utcOffset: TimeSpan;
        readonly isUtcOffsetFound: boolean;
        utcDateTime: DateTime;
        constructor(indexOfDate: number, lengthOfDate: number, indexOfTime: number, lengthOfTime: number, dateTime: DateTime, utcOffset?: TimeSpan);
    }
    class DateTimeRoutines {
        private static _defaultDate;
        static get defaultDate(): DateTime;
        static set defaultDate(value: DateTime);
        static defaultDateIsNow: boolean;
        static tryParseDateTime(str: string, defaultFormat: DateTimeFormat, refDateTime: {
            ref: DateTime;
        }): boolean;
        static tryParseDateTime2(str: string, defaultFormat: DateTimeFormat, refParsedDateTime: {
            ref: ParsedDateTime;
        }): boolean;
        static tryParseDateOrTime2(str: string, defaultFormat: DateTimeFormat, refParsedDateTime: {
            ref: ParsedDateTime;
        }): boolean;
        static tryParseTime2(str: string, defaultFormat: DateTimeFormat, refParsedTime: {
            ref: ParsedDateTime;
        }, parsedDate: ParsedDateTime): boolean;
        static tryParseDate2(str: string, defaultFormat: DateTimeFormat, refParsedDate: {
            ref: ParsedDateTime;
        }): boolean;
        private static tryParseDateInternal;
        private static convertToDate;
    }
}
declare namespace Stimulsoft.Base.Helpers {
    import Size = Stimulsoft.System.Drawing.Size;
    import List = Stimulsoft.System.Collections.List;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiBingMapHelper {
        static _bingKey: string;
        static bingMapKey: string;
        static bingKeysUrl: string;
        private static defaultBingKey;
        private static Script;
        static get BingKey(): string;
        static getImageAsync(size: Size, map: {
            mapImage: string;
        }, pushPins?: List<string>): StiPromise<string>;
        private static base64ArrayBuffer;
        private static getBingUrl;
        static getScript(mapData: {
            [key: string]: string;
        }): string;
        private static getCacheKey;
    }
}
declare namespace Stimulsoft.Base.Helpers {
    class StiComponentProgressHelper {
        progressDelta: number;
        timerInterval: number;
        private static lockCompletedProgressHandler;
        static currentValue: number;
        static add(comp: IStiAppComponent): void;
    }
}
declare namespace Stimulsoft.Base.Helpers {
    import List = Stimulsoft.System.Collections.List;
    class StiOnlineMapRepaintHelper {
        timerInterval: number;
        browserLifetime: number;
        static init(): void;
        static fetchAllComponents(report: IStiReport): List<IStiAppComponent>;
        static clean(reportKey: string): void;
    }
}
declare namespace Stimulsoft.Base {
    class StiPacker {
        private static encryptedId;
        static allowPacking: boolean;
        static pack(bytes: number[]): number[];
        static unpack(bytes: number[]): number[];
        static packAndEncrypt(bytes: number[], encryptedId: string): number[];
        static unpackAndDecrypt(bytes: number[], encryptedId: string): number[];
        static packAndEncryptToString(bytes: number[]): string;
        static unpackAndDecrypt2(str: string): number[];
        static packToString(bytes: number[]): string;
        static unpackFromString(str: string): number[];
        static packToBytes(str: string, allowPacking?: boolean): number[];
        static unpackToString(bytes: number[]): string;
        private static addZipSignature;
        static isPacked(bytes: number[]): boolean;
        private static isPacked2;
    }
}
declare namespace Stimulsoft.Base.Helpers {
    class StiValueComparer {
        static equalValues(value1: any, value2: any): boolean;
        static compareArrays(a: any[], b: any[]): boolean;
    }
}
declare namespace Stimulsoft.Base.Helpers {
    import DateTime = Stimulsoft.System.DateTime;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    class StiValueHelper {
        static isZero(value: any): boolean;
        static equalDecimal(value1: any, value2: any): boolean;
        static tryToString(value: any): string;
        static tryToNumber(value: any): number;
        static tryToBool(value: any): boolean;
        static tryToDateTime(value: any): DateTime;
        static tryToTimeSpan(value: any): TimeSpan;
        static tryToNullableNumber(value: any): number | null;
        static tryToNullableDateTime(value: any): DateTime | null;
        static tryToNullableTimeSpan(value: any): TimeSpan | null;
        static parseNumber(value: string): number;
        private static normalizeFloatingPointValue;
    }
}
declare namespace Stimulsoft.Base {
    enum StiJsonSaveMode {
        Report = 0,
        Document = 1
    }
}
declare namespace Stimulsoft.Base.StiJsonReportObjectHelper {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    import StiCap = Stimulsoft.Base.Drawing.StiCap;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Font = Stimulsoft.System.Drawing.Font;
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    import GraphicsUnit = Stimulsoft.System.Drawing.GraphicsUnit;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import Size = Stimulsoft.System.Drawing.Size;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    class Serialize {
        static fontArial8(font: Font): string;
        static font(font: Font, defaultFamily?: string, defaultEmSize?: number, defaultStyle?: FontStyle, defaultUnit?: GraphicsUnit): string;
        static rectangleD(rect: Rectangle): string;
        static sizeD(size: Size | Size): string;
        static jColor(color: Color, defColor?: Color): string;
        static colorArray(array: Color[]): StiJson;
        static stringArray(array: string[]): StiJson;
        static boolArray(array: boolean[]): StiJson;
        static numberArray(array: number[]): StiJson;
        static objectArray(list: IStiJsonReportObject[], mode: StiJsonSaveMode): StiJson;
        static size(size: Size): StiJson;
        static point(pos: Point): StiJson;
        static jCap(cap: StiCap): string;
        static jBrush(brush: StiBrush, defaultBrush?: StiBrush): string;
        static jBorderSide(side: StiBorderSide): string;
        static jBorder(border: StiBorder): string;
        static jBorder2(border: StiSimpleBorder): string;
    }
    class Deserialize {
        static stringArray(jObject: StiJson): string[];
        static numberArray(jObject: StiJson): number[];
        static boolArray(jObject: StiJson): boolean[];
        static font(text: string, defaultFont: Font): Font;
        static jBorderSide(text: string): StiBorderSide;
        static jCap(text: string): StiCap;
        static border(text: string): StiBorder;
        static simpleBorder(text: string): StiSimpleBorder;
        static color(value: string): Color;
        static brush(text: string): StiBrush;
        static colorArray(jObject: StiJson): Color[];
        static size(jObject: StiJson): Size;
        static rectangleD(text: string): Rectangle;
        static sizeD(text: string): Size;
        static point(jObject: StiJson): Point;
    }
}
declare namespace Stimulsoft.Base {
    import DataSet = Stimulsoft.System.Data.DataSet;
    import JsonRelationDirection = Stimulsoft.System.Data.JsonRelationDirection;
    class StiJsonToDataSetConverter {
        static getDataSet(param: string | number[] | any, jsonRelationDirection?: JsonRelationDirection): DataSet;
    }
}
declare namespace Stimulsoft.Base.Licenses {
    enum StiProductIdent {
        Ultimate = 1,
        Net = 2,
        Wpf = 3,
        Web = 4,
        Silverlight = 5,
        Js = 6,
        Java = 7,
        Php = 8,
        NetCore = 9,
        Uwp = 10,
        Flex = 11,
        BIDesigner = 12,
        DbsJs = 13,
        DbsWin = 14,
        DbsWeb = 15,
        BIDesktop = 16,
        BIServer = 17,
        BICloud = 18,
        CloudReports = 20,
        CloudDashboards = 21,
        Angular = 22,
        DbsAngular = 23,
        DbsPhp = 24
    }
    enum StiActivationType {
        Server = 1,
        Developer = 2
    }
}
declare namespace Stimulsoft.Base.Licenses {
    class StiCryptHelper {
        static decrypt(str: string, password: string): string;
        static encrypt(str: string, password?: string): string;
        static recrypt(str: string, oldPassword: string, newPassword: string): string;
    }
}
declare namespace Stimulsoft.Base.Licenses {
    class StiRsaPublicKey {
        static getKey(): any;
    }
}
declare namespace Stimulsoft.Base.Licenses {
    class StiLicenseObject {
        encryptKey: string;
        loadFromString(str: string): void;
        saveToString(): string;
        loadFromBytes(bytes: number[]): void;
        decryptFromBytes(bytes: number[]): void;
        decryptFromString(str: string): void;
    }
}
declare namespace Stimulsoft.Base.Licenses {
    import List = Stimulsoft.System.Collections.List;
    import DateTime = Stimulsoft.System.DateTime;
    class StiLicenseKey extends StiLicenseObject {
        activationDate: DateTime;
        signature: string;
        owner: string;
        userName: string;
        startDate: DateTime;
        endDate: DateTime;
        seviceId: string;
        planId: StiPlanIdent;
        products: List<StiLicenseProduct>;
        productName: string;
        productLogo: number[];
        productFavIcon: number[];
        productDescription: string;
        productUrl: string;
        clone(): StiLicenseKey;
        static get1(bytes: number[]): StiLicenseKey;
        static get2(str: string): StiLicenseKey;
        constructor();
    }
}
declare namespace Stimulsoft.Base {
    class StiLicense {
        static licenseKey: any;
        static _key: string;
        static get key(): string;
        static set key(value: string);
        static get Key(): string;
        static set Key(value: string);
        static setNewLicenseKey(value: string, throwException?: boolean): void;
        private static isValidLicenseKey;
        static loadFromFile(file: string): void;
        static loadFromString(licenseKey: string): void;
    }
}
declare namespace Stimulsoft.Base.Licenses {
    class StiLicenseActivationResponse extends StiLicenseObject {
        encryptKey: string;
        licenseKey: StiLicenseKey;
        exception: string;
        resultSuccess: boolean;
        resultNotice: StiNotice;
    }
}
declare namespace Stimulsoft.Base.Licenses {
    class StiLicenseKeyContainer extends StiKeyObject {
        checkSum: string;
        license: number[];
    }
}
declare namespace Stimulsoft.Base.Licenses {
    import StiProductIdent = Stimulsoft.Base.Licenses.StiProductIdent;
    class StiLicenseKeyValidator {
        private static indexValidator;
        static isValidOn(ident: StiProductIdent): boolean;
        static isValidOnDbsJS(): boolean;
        static isValidOnAnyDbs(): boolean;
        static isValidOnJS(): boolean;
        static isValidOnAnyReports(): boolean;
        static isValidOnAnyPlatform(): boolean;
        static isValidOnBI(): boolean;
        private static isJSPlatform;
        private static isAnyDbsPlatform;
        private static isAnyReportsPlatform;
        private static isDbsJSPlatform;
        private static isBIPlatform;
        private static getLicenseKey;
    }
}
declare namespace Stimulsoft.Base.Licenses {
    import DateTime = Stimulsoft.System.DateTime;
    class StiLicenseProduct {
        expirationDate: DateTime;
        ident: StiProductIdent;
    }
}
declare namespace Stimulsoft.Base.Map {
    import List = Stimulsoft.System.Collections.List;
    let IStiMapKeyHelper: System.Interface<IStiMapKeyHelper>;
    interface IStiMapKeyHelper {
        getMapIdents(key: string): List<string>;
        getIsoAlpha2FromName(country: string, mapId: string): string;
        getIsoAlpha3FromName(country: string, mapId: string): string;
        getNameFromIsoAlpha2(alpha3: string, mapId: string): string;
        getNameFromIsoAlpha3(alpha3: string, mapId: string): string;
        normalizeName(name: string, mapId: string, report: IStiReport): string;
    }
}
declare namespace Stimulsoft.Base.Meters {
    let IStiArgumentMeter: System.Interface<IStiArgumentMeter>;
    interface IStiArgumentMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiBubbleColumn: System.Interface<IStiBubbleColumn>;
    interface IStiBubbleColumn {
        allowCustomColors: boolean;
        positiveColor: Color;
        negativeColor: Color;
    }
}
declare namespace Stimulsoft.Base.Meters {
    let IStiColorMapMeter: System.Interface<IStiColorMapMeter>;
    interface IStiColorMapMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiColorScaleColumn: System.Interface<IStiColorScaleColumn>;
    interface IStiColorScaleColumn {
        minimumColor: Color;
        maximumColor: Color;
    }
}
declare namespace Stimulsoft.Base.Meters {
    let IStiDataBarsColumn: System.Interface<IStiDataBarsColumn>;
    interface IStiDataBarsColumn {
    }
}
declare namespace Stimulsoft.Base.Meters {
    let IStiDimensionColumn: System.Interface<IStiDimensionColumn>;
    interface IStiDimensionColumn {
        showHyperlink: boolean;
        hyperlinkPattern: string;
    }
}
declare namespace Stimulsoft.Base.Meters {
    let IStiDimensionMeter: System.Interface<IStiDimensionMeter>;
    interface IStiDimensionMeter extends IStiMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    let IStiGroupMapMeter: System.Interface<IStiGroupMapMeter>;
    interface IStiGroupMapMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    let IStiIndicatorColumn: System.Interface<IStiIndicatorColumn>;
    interface IStiIndicatorColumn {
    }
}
declare namespace Stimulsoft.Base.Meters {
    let IStiKeyMapMeter: System.Interface<IStiKeyMapMeter>;
    interface IStiKeyMapMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    let IStiLocalizedMeter: System.Interface<IStiLocalizedMeter>;
    interface IStiLocalizedMeter {
        localizedName: string;
    }
}
declare namespace Stimulsoft.Base.Meters {
    let IStiMaxGaugeMeter: System.Interface<IStiMaxGaugeMeter>;
    interface IStiMaxGaugeMeter extends IStiMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    let IStiMeasureColumn: System.Interface<IStiMeasureColumn>;
    interface IStiMeasureColumn {
    }
}
declare namespace Stimulsoft.Base.Meters {
    let IStiMeasureMeter: System.Interface<IStiMeasureMeter>;
    interface IStiMeasureMeter extends IStiMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    import ICloneable = Stimulsoft.System.ICloneable;
    import IAsIs = Stimulsoft.System.IAsIs;
    let IStiMeter: System.Interface<IStiMeter>;
    interface IStiMeter extends IAsIs, ICloneable {
        getUniqueCode(): number;
        key: string;
        expression: string;
        label: string;
    }
}
declare namespace Stimulsoft.Base.Meters {
    let IStiMinGaugeMeter: System.Interface<IStiMinGaugeMeter>;
    interface IStiMinGaugeMeter extends IStiMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    let IStiNameMapMeter: System.Interface<IStiNameMapMeter>;
    interface IStiNameMapMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    let IStiPivotColumn: System.Interface<IStiPivotColumn>;
    interface IStiPivotColumn {
    }
}
declare namespace Stimulsoft.Base.Meters {
    let IStiPivotRow: System.Interface<IStiPivotRow>;
    interface IStiPivotRow {
    }
}
declare namespace Stimulsoft.Base.Meters {
    let IStiPivotSummary: System.Interface<IStiPivotSummary>;
    interface IStiPivotSummary {
    }
}
declare namespace Stimulsoft.Base.Meters {
    let IStiSeriesMeter: System.Interface<IStiSeriesMeter>;
    interface IStiSeriesMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiSparklinesColumn: System.Interface<IStiSparklinesColumn>;
    interface IStiSparklinesColumn {
        allowCustomColors: boolean;
        showHighLowPoints: boolean;
        showFirstLastPoints: boolean;
        positiveColor: Color;
        negativeColor: Color;
    }
}
declare namespace Stimulsoft.Base.Meters {
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    let IStiTableColumn: System.Interface<IStiTableColumn>;
    interface IStiTableColumn {
        visible: boolean;
        showTotalSummary: boolean;
        summaryType: StiSummaryColumnType;
        visibility: StiTableColumnVisibility;
        visibilityExpression: string;
        summaryAlignment: StiHorAlignment;
    }
}
declare namespace Stimulsoft.Base.Meters {
    let IStiTargetMeter: System.Interface<IStiTargetMeter>;
    interface IStiTargetMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    let IStiValueMapMeter: System.Interface<IStiValueMapMeter>;
    interface IStiValueMapMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    let IStiValueMeter: System.Interface<IStiValueMeter>;
    interface IStiValueMeter {
    }
}
declare namespace Stimulsoft.Base {
    enum StiNoticeIdent {
        ActivationMaxActivationsReached = 1,
        ActivationExpiriedBeforeFirstRelease = 2,
        ActivationLicenseIsNotCorrect = 3,
        ActivationLockedAccount = 4,
        ActivationServerVersionNotAllowed = 5,
        ActivationServerIsNotAvailableNow = 6,
        ActivationSomeTroublesOccurred = 7,
        ActivationUserNameOrPasswordIsWrong = 8,
        ActivationWrongAccountType = 9,
        AuthAccountCantBeUsedNow = 10,
        AuthAccountIsNotActivated = 11,
        AuthCantChangeSystemRole = 12,
        AuthCantChangeRoleBecauseLastAdministratorUser = 13,
        AuthCantChangeRoleBecauseLastSupervisorUser = 14,
        AuthCantDeleteHimselfUser = 15,
        AuthCantDeleteLastAdministratorUser = 16,
        AuthCantDeleteLastSupervisorUser = 17,
        AuthCantDeleteSystemRole = 18,
        AuthCantDisableUserBecauseLastAdministratorUser = 19,
        AuthCantDisableUserBecauseLastSupervisorUser = 20,
        AuthOAuthIdNotSpecified = 21,
        AuthPasswordIsTooShort = 22,
        AuthPasswordIsNotSpecified = 23,
        AuthPasswordIsNotCorrect = 24,
        AuthRequestsLimitIsExceeded = 25,
        AuthRoleCantBeDeletedBecauseUsedByUsers = 26,
        AuthRoleNameAlreadyExists = 27,
        AuthRoleNameIsSystemRole = 28,
        AuthUserHasLoggedOut = 29,
        AuthUserNameAlreadyExists = 30,
        AuthUserNameIsNotSpecified = 31,
        AuthUserNameOrPasswordIsNotCorrect = 32,
        AuthUserNameShouldLookLikeAnEmailAddress = 33,
        AuthWorkspaceNameAlreadyInUse = 34,
        CommandTimeOut = 35,
        CustomMessage = 36,
        ExecutionError = 37,
        IsNotAuthorized = 38,
        IsNotDeleted = 39,
        IsNotCorrect = 40,
        IsNotEqual = 41,
        IsNotFound = 42,
        IsNotRecognized = 43,
        IsNotSpecified = 44,
        ItemCantBeDeletedBecauseItemIsAttachedToOtherItems = 45,
        ItemCantBeMovedToSpecifiedPlace = 46,
        ItemDoesNotSupport = 47,
        KeyAndToKeyIsEqual = 48,
        NotificationFailed = 49,
        NotificationFileUploading = 50,
        NotificationFilesUploadingComplete = 51,
        NotificationItemDelete = 52,
        NotificationItemDeleteComplete = 53,
        NotificationItemRestore = 54,
        NotificationItemRestoreComplete = 55,
        NotificationItemTransfer = 56,
        NotificationItemTransferComplete = 57,
        NotificationItemWaitingProcessing = 58,
        NotificationOperationAborted = 59,
        NotificationRecycleBinCleaning = 60,
        NotificationRecycleBinCleaningComplete = 61,
        NotificationRecycleBinWaitingProcessing = 62,
        NotificationReportCompiling = 63,
        NotificationReportDataProcessing = 64,
        NotificationReportExporting = 65,
        NotificationReportExportingComplete = 66,
        NotificationReportRendering = 67,
        NotificationReportRenderingComplete = 68,
        NotificationReportSaving = 69,
        NotificationReportWaitingProcessing = 70,
        NotificationSchedulerRunning = 71,
        NotificationSchedulerRunningComplete = 72,
        NotificationSchedulerWaitingProcessing = 73,
        NotificationTransferring = 74,
        NotificationTransferringComplete = 75,
        NotificationTitleFilesUploading = 76,
        NotificationTitleItemRefreshing = 77,
        NotificationTitleItemTransferring = 78,
        NotificationTitleReportExporting = 79,
        NotificationTitleReportRendering = 80,
        NotificationTitleSchedulerRunning = 81,
        QuotaMaximumComputingCyclesCountExceeded = 82,
        QuotaMaximumFileSizeExceeded = 83,
        QuotaMaximumItemsCountExceeded = 84,
        QuotaMaximumReportPagesCountExceeded = 85,
        QuotaMaximumUsersCountExceeded = 86,
        QuotaMaximumWorkspacesCountExceeded = 87,
        AccessDenied = 88,
        OutOfRange = 89,
        ParsingCommandException = 90,
        SchedulerCantRunItSelf = 91,
        SessionTimeOut = 92,
        SnapshotAlreadyProcessed = 93,
        SpecifiedItemIsNot = 94,
        WithSpecifiedKeyIsNotFound = 95,
        VersionCopyFromItem = 96,
        VersionCreatedFromFile = 97,
        VersionCreatedFromItem = 98,
        VersionNewItemCreation = 99,
        VersionLoadedFromFile = 100
    }
}
declare namespace Stimulsoft.Base {
    class StiNotice {
        ident: StiNoticeIdent;
        arguments: string[];
        customMessage: string;
    }
}
declare namespace Stimulsoft.Base.Services {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiRepositoryItems = Stimulsoft.Base.StiRepositoryItems;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiService implements ICloneable, IAsIs {
        clone(cloneProperties?: boolean, cloneComponents?: boolean, base?: boolean): any;
        memberwiseClone(base?: boolean): StiService;
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        isPropertyPresent(key: any): boolean;
        private _properties;
        get properties(): StiRepositoryItems;
        set properties(value: StiRepositoryItems);
        protected isPropertiesInitializedProtected(): boolean;
        get serviceCategory(): string;
        get serviceName(): string;
        get serviceInfo(): string;
        get serviceType(): Stimulsoft.System.Type;
        get serviceEnabled(): boolean;
        set serviceEnabled(value: boolean);
    }
}
declare namespace Stimulsoft.ExternalLibrary.JSZip {
    interface JSZip {
        file(path: string): JSZipObject;
        file(path: RegExp): JSZipObject[];
        file(path: string, data: any, options?: JSZipFileOptions): JSZip;
        folder(name: string): JSZip;
        folder(name: RegExp): JSZipObject[];
        filter(predicate: (relativePath: string, file: JSZipObject) => boolean): JSZipObject[];
        remove(path: string): JSZip;
        generate(options?: JSZipGeneratorOptions): any;
        load(data: any, options: JSZipLoadOptions): JSZip;
    }
    interface JSZipObject {
        name: string;
        dir: boolean;
        date: Date;
        comment: string;
        options: JSZipObjectOptions;
        asText(): string;
        asBinary(): string;
        asArrayBuffer(): ArrayBuffer;
        asUint8Array(): Uint8Array;
    }
    interface JSZipFileOptions {
        base64?: boolean;
        binary?: boolean;
        date?: Date;
        compression?: string;
        comment?: string;
        optimizedBinaryString?: boolean;
        createFolders?: boolean;
    }
    interface JSZipObjectOptions {
        base64: boolean;
        binary: boolean;
        dir: boolean;
        date: Date;
        compression: string;
    }
    interface JSZipGeneratorOptions {
        base64?: boolean;
        compression?: string;
        type?: string;
        comment?: string;
    }
    interface JSZipLoadOptions {
        base64?: boolean;
        checkCRC32?: boolean;
        optimizedBinaryString?: boolean;
        createFolders?: boolean;
    }
    interface JSZipSupport {
        arraybuffer: boolean;
        uint8array: boolean;
        blob: boolean;
        nodebuffer: boolean;
    }
    interface DEFLATE {
        compress(input: string | number[] | Uint8Array, compressionOptions: {
            level: number;
        }): Uint8Array;
        uncompress(input: string | number[] | Uint8Array): Uint8Array;
    }
    let prototype: JSZip;
    let support: JSZipSupport;
    let compressions: {
        DEFLATE: DEFLATE;
    };
}
declare namespace Stimulsoft.ExternalLibrary {
    function JSZip(data?: any, options?: Stimulsoft.ExternalLibrary.JSZip.JSZipLoadOptions): Stimulsoft.ExternalLibrary.JSZip.JSZip;
}
declare namespace Stimulsoft.Base {
    class StiGZipHelper {
        private static DefaultLevel;
        private static DefaultMethod;
        private static ID1;
        private static ID2;
        private static _crcTable;
        static get crcTable(): number[];
        static crc32(data: number[]): number;
        private static putByte;
        private static putShort;
        private static putLong;
        private static putString;
        private static readByte;
        private static readShort;
        private static readLong;
        private static readString;
        private static readBytes;
        static pack(data2: string | number[] | Uint8Array, name?: string): string | number[];
        static unpack(data: string | number[] | Uint8Array): string | number[];
    }
}
declare namespace Stimulsoft.Base.Zip {
    import DateTime = Stimulsoft.System.DateTime;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiZipWriter20 {
        static convertToArray(useUnicode: boolean, str: string): number[];
        static getDosTime(dt: DateTime): number;
        private _mainStream;
        private zip;
        begin(stream: MemoryStream, leaveOpen: boolean): void;
        addFile(fileName: string, dataStream: MemoryStream, closeDataStream?: boolean): void;
        end(): void;
        constructor();
    }
}
declare namespace Stimulsoft.Data.Helpers {
    import DateTime = Stimulsoft.System.DateTime;
    class StiDateTimeCorrector {
        static correct(dateTime: DateTime): DateTime;
    }
}
declare namespace Stimulsoft.Data.Comparers {
    class StiObjectComparer {
        equals(x: any, y: any): boolean;
        getHashCode(x: any): number;
        static readonly default: StiObjectComparer;
        static compare(x: any, y: any): number;
        private static defaultCompare;
        private static dateTimeCompare;
        private static arrayCompare;
    }
}
declare namespace Stimulsoft.Data.Comparers {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    class StiArrayComparer implements IComparer<any[]> {
        compare(x: any[], y: any[]): number;
    }
}
declare namespace Stimulsoft.Data.Comparers {
    import IEqualityComparer = Stimulsoft.System.Collections.IEqualityComparer;
    class StiArrayEqualityComparer implements IEqualityComparer<any[]> {
        equals(x: any[], y: any[]): boolean;
        getHashCode(x: any[]): number;
    }
}
declare namespace Stimulsoft.Data.Comparers {
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    class StiDataActionComparer implements IComparer<StiDataActionRule> {
        compare(x: StiDataActionRule, y: StiDataActionRule): number;
    }
}
declare namespace Stimulsoft.Data.Comparers {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import DataRow = Stimulsoft.System.Data.DataRow;
    class StiDataRowComparer implements IComparer<DataRow> {
        compare(x: DataRow, y: DataRow): number;
    }
}
declare namespace Stimulsoft.Data.Engine {
    enum StiDataJoinType {
        Inner = 1,
        Left = 2,
        Right = 3,
        Cross = 4,
        Full = 5
    }
    enum StiDataSortDirection {
        Ascending = 1,
        Descending = 2,
        None = 3
    }
    enum StiDataFilterCondition {
        EqualTo = 0,
        NotEqualTo = 1,
        GreaterThan = 2,
        GreaterThanOrEqualTo = 3,
        LessThan = 4,
        LessThanOrEqualTo = 5,
        Between = 6,
        NotBetween = 7,
        Containing = 8,
        NotContaining = 9,
        BeginningWith = 10,
        EndingWith = 11,
        IsNull = 12,
        IsNotNull = 13,
        IsBlank = 14,
        IsNotBlank = 15,
        IsBlankOrNull = 16,
        IsFalse = 17,
        PairEqualTo = 18,
        MapEqualTo = 19
    }
    enum StiDataFilterOperation {
        AND = 0,
        OR = 1
    }
    enum StiDataActionType {
        Limit = 0,
        Replace = 1,
        RunningTotal = 2,
        Percentage = 3
    }
    enum StiDataFilterConditionGroupType {
        Equal = 0,
        NotEqual = 1,
        Custom = 2,
        Empty = 3
    }
    enum StiDataRequestOption {
        None = 0,
        AllowOpenConnections = 1,
        AllowDataSort = 2,
        DisallowTransform = 4,
        All = 3
    }
    enum StiDataTopNMode {
        None = 0,
        Top = 1,
        Bottom = 2
    }
    enum StiDataFormatKind {
        General = 0,
        Boolean = 1,
        Currency = 2,
        Date = 3,
        Number = 4,
        Percentage = 5,
        Time = 6
    }
    enum StiDataJoinEngine {
        V1 = 0,
        V2 = 1,
        V3 = 2,
        V4 = 3
    }
}
declare namespace Stimulsoft.Data.Engine {
    let IStiAllowSortByVariation: System.Interface<IStiAllowSortByVariation>;
    let ImplementsIStiAllowSortByVariation: any[];
    interface IStiAllowSortByVariation {
    }
}
declare namespace Stimulsoft.Data.Engine {
    let IStiCrossFiltering: System.Interface<IStiCrossFiltering>;
    let ImplementsIStiCrossFiltering: any[];
    interface IStiCrossFiltering {
        crossFiltering: boolean;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    let IStiDataFilters: System.Interface<IStiDataFilters>;
    let ImplementsIStiDataFilters: any[];
    interface IStiDataFilters {
        dataFilters: List<StiDataFilterRule>;
    }
}
declare namespace Stimulsoft.Data.Engine {
    let IStiDataFormat: System.Interface<IStiDataFormat>;
    interface IStiDataFormat {
        getDataFormat(): StiDataFormatKind;
    }
}
declare namespace Stimulsoft.Data.Engine {
    let IStiDataTopN: System.Interface<IStiDataTopN>;
    let ImplementsIStiDataTopN: any[];
    interface IStiDataTopN {
        topN: StiDataTopN;
    }
}
declare namespace Stimulsoft.Data.Engine {
    let IStiDataTransformationElement: System.Interface<IStiDataTransformationElement>;
    let ImplementsIStiDataTransformationElement: any[];
    interface IStiDataTransformationElement {
        dataTransformation: any;
        isDefaultDataTransformation(): boolean;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    let IStiDrillDownElement: System.Interface<IStiDrillDownElement>;
    let ImplementsIStiDrillDownElement: any[];
    interface IStiDrillDownElement {
        drillDownFilters: List<StiDataFilterRule>;
        drillDownFiltersList: List<List<StiDataFilterRule>>;
        drillDownCurrentLevel: number;
        drillDownLevelCount: number;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    let IStiRetrieval: System.Interface<IStiRetrieval>;
    let ImplementsIStiRetrieval: any[];
    interface IStiRetrieval {
        retrieveUsedDataNames(group: string): List<string>;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    import IStiRetrieval = Stimulsoft.Data.Engine.IStiRetrieval;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    let IStiQueryObject: System.Interface<IStiQueryObject>;
    let ImplementsIStiQueryObject: any[];
    interface IStiQueryObject extends IStiRetrieval {
        getDictionary(): IStiAppDictionary;
        getDataSources(dataNames: List<string>): List<IStiAppDataSource>;
    }
}
declare namespace Stimulsoft.Data.Engine {
    let IStiSkipNormalizeDate: System.Interface<IStiSkipNormalizeDate>;
    interface IStiSkipNormalizeDate {
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    let IStiTransformActions: System.Interface<IStiTransformActions>;
    let ImplementsIStiTransformActions: any[];
    interface IStiTransformActions {
        transformActions: List<StiDataActionRule>;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    let IStiTransformFilters: System.Interface<IStiTransformFilters>;
    let ImplementsIStiTransformFilters: any[];
    interface IStiTransformFilters {
        transformFilters: List<StiDataFilterRule>;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    let IStiTransformSorts: System.Interface<IStiTransformSorts>;
    let ImplementsIStiTransformSorts: any[];
    interface IStiTransformSorts {
        transformSorts: List<StiDataSortRule>;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IAsIs = Stimulsoft.System.IAsIs;
    import List = Stimulsoft.System.Collections.List;
    let IStiUserFilters: System.Interface<IStiUserFilters>;
    let ImplementsIStiUserFilters: any[];
    interface IStiUserFilters extends IAsIs {
        userFilters: List<StiDataFilterRule>;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    let IStiUserSorts: System.Interface<IStiUserSorts>;
    let ImplementsIStiUserSorts: any[];
    interface IStiUserSorts {
        userSorts: List<StiDataSortRule>;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    abstract class LogicalExpressionVisitor {
        abstract visit1(expression: LogicalExpression): any;
        abstract visit2(expression: TernaryExpression): any;
        abstract visit3(expression: BinaryExpression): any;
        abstract visit4(expression: UnaryExpression): any;
        abstract visit5(expression: ValueExpression): any;
        abstract visit6(expression: Functionn): any;
        abstract visit7(expression: Identifier): any;
    }
}
declare namespace Stimulsoft.Data.Helpers {
    import IStiReport = Stimulsoft.Base.IStiReport;
    import LogicalExpression = Stimulsoft.Data.Expressions.NCalc.Domain.LogicalExpression;
    import List = Stimulsoft.System.Collections.List;
    class StiExpressionHelper {
        private static expressionToArguments;
        static newExpression(expression: string): Stimulsoft.Data.Expressions.NCalc.Expression;
        static prepareExpression(expression: string): string;
        static escapeExpression(expression: string): string;
        static replaceFunction(expression: string, newFunction: string): string;
        static removeFunction(expression: string): string;
        static isPercentOfGrandTotal(expression: string): boolean;
        static isAggregationFunctionPresent(expression: string): boolean;
        static isFunctionPresent(expression: string): boolean;
        static getFunction(expression: string): string;
        static getArguments(expression: string): List<string>;
        static compile(expression: string): LogicalExpression;
        static getFirstArgumentFromExpression(expression: string): string;
        static parseReportExpression(report: IStiReport, text: string, withBraces: boolean): string;
        static fetchBlocksFromExpression(inputExpression: string): List<string>;
        static replaceExpressionBlocksByValues(inputExpression: string, values: List<string>): string;
        static isTimeExpression(str: string): boolean;
    }
}
declare namespace Stimulsoft.Data.Extensions {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import DataRelation = Stimulsoft.System.Data.DataRelation;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    class DataTableExt {
        static nullTable: DataTable;
        static getUniqueName(table: DataTable, meter: IStiMeter): string;
        static getUniqueName2(table: DataTable, meter: IStiMeter, baseName: string): string;
        static getUniqueName3(table: DataTable, baseName: string): string;
        static parentRelationList(table: DataTable): List<DataRelation>;
        static childRelationList(table: DataTable): List<DataRelation>;
    }
}
declare namespace Stimulsoft.Data.Extensions {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiDataTableExt {
        static toNetTable(table: StiDataTable, onlyColumns?: boolean): DataTable;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiReport = Stimulsoft.Base.IStiReport;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import List = Stimulsoft.System.Collections.List;
    class StiDataActionOperator {
        private static lockObject;
        private static netCache;
        private static meterCache;
        static apply(inTable: DataTable, actions: List<StiDataActionRule>, report: IStiReport, hash: number): DataTable;
        static applyAfterGrouping(inTable: StiDataTable, actions: List<StiDataActionRule>, report: IStiReport, hash: number): StiDataTable;
        static cleanCache(appKey: string): void;
        private static getCacheKey;
        private static getCacheKey2;
        private static getFromCache;
        private static getFromCache2;
        private static addToCache;
        private static addToCache2;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import ICloneable = Stimulsoft.System.ICloneable;
    abstract class StiDataRule implements ICloneable {
        clone(): any;
        abstract getUniqueCode(): number;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDataActionRule extends StiDataRule implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        type: StiDataActionType;
        key: string;
        path: string;
        startIndex: number;
        rowsCount: number;
        initialValue: string;
        valueFrom: string;
        valueTo: string;
        matchCase: boolean;
        matchWholeWord: boolean;
        afterGroupingData: boolean;
        static loadFromJson(json: StiJson): StiDataActionRule;
        static loadFromXml(xmlNode: XmlNode): StiDataActionRule;
        getUniqueCode(): number;
        static create1(key: string, path: string): StiDataActionRule;
        static create2(key: string, path: string, startIndex: number, rowsCount: number, afterGroupingData: boolean): StiDataActionRule;
        static create3(key: string, path: string, valueFrom: string, valueTo: string, matchCase: boolean, matchWholeWord: boolean): StiDataActionRule;
        static create4(key: string, path: string, initialValue: string): StiDataActionRule;
        constructor(key?: string, path?: string, type?: StiDataActionType, startIndex?: number, rowsCount?: number, afterGroupingData?: boolean, valueFrom?: string, valueTo?: string, matchCase?: boolean, matchWholeWord?: boolean, initialValue?: string);
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiReport = Stimulsoft.Base.IStiReport;
    import List = Stimulsoft.System.Collections.List;
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiDataActionRuleHelper {
        static toList(...rules: StiDataActionRule[]): List<StiDataActionRule>;
        static validate(rules: List<StiDataActionRule>, columnKeys: List<string>): List<StiDataActionRule>;
        private static getColumnIndex;
        static applyActions(table: DataTable, actions: List<StiDataActionRule>, columnKeys: List<string>, columnNames: List<string>, report: IStiReport): void;
        private static applyLimitAction;
        private static applyReplaceAction;
        private static applyRunningTotalAction;
        private static applyPercentageAction;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiDataAnalyzer {
        static analyze(query: IStiQueryObject, group: string, meters: List<IStiMeter>, option?: StiDataRequestOption, userSorts?: List<StiDataSortRule>, userFilters?: List<StiDataFilterRule>, dataFilters?: List<StiDataFilterRule>, dataActions?: List<StiDataActionRule>, transformSorts?: List<StiDataSortRule>, transformFilters?: List<StiDataFilterRule>, transformActions?: List<StiDataActionRule>, drillDownFilters?: List<StiDataFilterRule>): Promise<StiDataTable>;
        private static unionFilters;
        private static unionNames;
        private static getUniqueCode;
        private static getUniqueCode2;
    }
}
declare namespace Stimulsoft.Data.Engine {
    class StiDataColumnRuleHelper {
        static isGoodColumnName(columnName: string): boolean;
        static getGoodColumnName(columnName: string): string;
        private static keywords;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiAppConnection = Stimulsoft.Base.IStiAppConnection;
    import List = Stimulsoft.System.Collections.List;
    class StiDataConnections {
        private static connections;
        static isConnectionActive(connection: IStiAppConnection): boolean;
        static registerConnection(connection: IStiAppConnection, items: List<object>): void;
        static unRegisterConnections(connections: List<IStiAppConnection>): List<object>;
        static unRegisterConnection(connection: IStiAppConnection): List<object>;
    }
}
declare namespace Stimulsoft.Data.Extensions {
    import List = Stimulsoft.System.Collections.List;
    import DateTime = Stimulsoft.System.DateTime;
    class ListExt extends List<any> {
        static compare(a: any, b: any): any;
        private static compareValues;
        static isList(value: any): boolean;
        static isBoolList(value: any): boolean;
        static toList(value: any): List<any>;
        static toStringList(value: any): List<string>;
        static toNumberList(value: any): List<number>;
        static toBoolList(value: any): List<boolean>;
        static toNullableDateTimeList(value: any): List<DateTime | null>;
        static toStringArray(value: any): string[];
        static toNumberArray(value: any): number[];
    }
}
declare namespace Stimulsoft.Data.Exceptions {
    abstract class StiDataException {
        message: string;
        constructor(message?: string);
    }
}
declare namespace Stimulsoft.Data.Exceptions {
    class StiArgumentNotFoundException extends StiDataException {
        private _functionName;
        get functionName(): string;
        private _argumentName;
        get argumentName(): string;
        constructor(functionName: string, argumentName: string);
    }
}
declare namespace Stimulsoft.Data.Exceptions {
    class StiArgumentCountException extends StiDataException {
        private _functionName;
        get functionName(): string;
        constructor(functionName: string);
    }
}
declare namespace Stimulsoft.Data.Exceptions {
    class StiFunctionNotFoundException extends StiDataException {
        private _name;
        get name(): string;
        constructor(name: string);
    }
}
declare namespace Stimulsoft.Data.Types {
    class SimpleValue {
        private _value;
        get value(): any;
        constructor(value: any);
    }
}
declare namespace Stimulsoft.Data.Options {
    import MidpointRounding = Stimulsoft.System.MidpointRounding;
    class StiDataOptions {
        static allowNulls: boolean;
        static roundType: MidpointRounding;
    }
}
declare namespace Stimulsoft.Data.Types {
    import DateTime = Stimulsoft.System.DateTime;
    class DateTimeValue {
        value: DateTime;
        constructor(value: any);
    }
}
declare namespace Stimulsoft.Data.Functions {
    import Type = Stimulsoft.System.Type;
    import IStiAppFunction = Stimulsoft.Base.IStiAppFunction;
    import DayOfWeek = Stimulsoft.System.DayOfWeek;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import List = Stimulsoft.System.Collections.List;
    import DateTime = Stimulsoft.System.DateTime;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    class Funcs {
        static count(value: any): number;
        static countIf(value: any, condition: any): number;
        static distinct(value: any): any;
        static distinctCount(value: any): number;
        static distinctCountIf(value: any, condition: any): number;
        static first(value: any): any;
        static last(value: any): any;
        static all(value: any): any;
        static isAggregationFunction(functionn: string): boolean;
        static avg(value: any): number;
        static avgNulls(value: any): number;
        static avgDate(value: any): DateTime | null;
        static avgTime(value: any): TimeSpan | null;
        static max(value: any): number;
        static maxNulls(value: number): number;
        static maxD(value: any): number;
        static maxI(value: any): number;
        static maxDate(value: any): DateTime | null;
        static maxTime(value: any): TimeSpan | null;
        static maxStr(value: any): string;
        static median(value: any): number;
        static min(value: any): number;
        static minNulls(value: any): number;
        static minDate(value: any): DateTime | null;
        static minTime(value: any): TimeSpan | null;
        static minMaxDateString(value: any): string;
        static minStr(value: any): string;
        static mode(value: any): number;
        static sum(value: any): number;
        static sumNulls(value: any): number;
        static sumD(value: any): number;
        static sumI(value: any): number;
        static sumTime(value: any): TimeSpan;
        static sumDistinct(value: any): number;
        static sumIf(value: any, condition: any): number;
        static sumDIf(value: any, condition: any): number;
        static sumIIf(value: any, condition: any): number;
        static sumTimeIf(value: any, condition: any): TimeSpan;
        static sumDistinctIf(value: any, condition: any): number;
        private static getCondition;
        private static getConditions;
        static dayOfWeekIdent(dateTime: DateTime | null): DayOfWeek | null;
        static dayOfWeekIdentObject(value: any): any;
        static dayOfWeekIndex(dateTime: DateTime | null): number;
        static dayOfWeekIndexObject(value: any): any;
        static dayOfWeek(date: DateTime | null): string;
        static dayOfWeekObject(value: any): any;
        static dayOfWeek2(date: DateTime | null, localized: boolean): string;
        static dayOfWeekObject2(value: any, localized: boolean): any;
        static dayOfWeek3(date: DateTime | null, culture: string): string;
        static dayOfWeekObject3(value: any, culture: string): any;
        static dayOfWeek4(date: DateTime | null, culture: string, upperCase: boolean): string;
        static dayOfWeekObject4(value: any, culture: string, upperCase: boolean): any;
        static daysInMonth(year: number, month: number): number;
        static daysInMonthObject(value1: any, value2: any): any;
        static daysInMonth2(date: DateTime | null): number;
        static daysInMonthObject2(value: any): any;
        static daysInYear(year: number): number;
        static daysInYear2(date: DateTime | null): number;
        static daysInYearObject(value: any): any;
        static monthIdent(dateTime: DateTime | null): StiMonth | null;
        static monthIdentObject(value: any): any;
        static month(dateTime: DateTime | null): number;
        static monthObject(value: any): any;
        static monthName(date: DateTime | null): string;
        static monthNameObject(value: any): any;
        static monthName2(date: DateTime | null, localized: boolean): string;
        static monthNameObject2(value: any, localized: boolean): any;
        static monthName3(date: DateTime | null, culture: string): string;
        static monthNameObject3(value: any, culture: string): any;
        static monthName4(date: DateTime | null, culture: string, upperCase: boolean): string;
        static monthNameObject4(value: any, culture: string, upperCase: boolean): any;
        static addMonthsObject(date: any, months: number): any;
        static addYears(date: DateTime, years: number): DateTime;
        static addYearsObject(date: any, years: number): any;
        static day(dateTime: DateTime | null): number;
        static dayObject(value: any): any;
        static dateDiff(date1: DateTime | null, date2: DateTime | null): TimeSpan | null;
        static dateDiffObject(value1: any, value2: any): any;
        static dateTime(value: any): any;
        static dayOfYear(dateTime: DateTime | null): any;
        static dayOfYearObject(value: any): any;
        static financialQuarter(dateTime: DateTime | null): StiQuarter | null;
        static financialQuarterObject(value: any): any;
        static financialQuarterIndex(dateTime: DateTime | null): number;
        static financialQuarterIndexObject(value: any): any;
        static hour(dateTime: DateTime | null): number;
        static hourObject(value: any): any;
        static makeDate(year: number, month?: number, day?: number): DateTime;
        static makeDateObject(year: any, month?: any, day?: any): any;
        static makeDateTime(year: number, month?: number, day?: number, hour?: number, minute?: number, second?: number): DateTime;
        static makeDateTimeObject(year: any, month?: any, day?: any, hour?: any, minute?: any, second?: any): any;
        static makeTime(hour: number, minute?: number, second?: number): DateTime;
        static makeTimeObject(hour: any, minute?: any, second?: any): any;
        static minute(dateTime: DateTime | null): number;
        static minuteObject(value: any): any;
        static now(): DateTime;
        static quarterName(dateTime: DateTime | null, localized?: boolean): string;
        static quarterNameObject(value: any, localized?: boolean): any;
        static quarter(dateTime: DateTime | null): StiQuarter | null;
        static quarterObject(value: any): any;
        static quarterIndex(dateTime: DateTime | null): number;
        static quarterIndexObject(value: any): any;
        static second(dateTime: DateTime | null): number;
        static secondObject(value: any): any;
        static time(value: any): any;
        static year(dateTime: DateTime | null): number;
        static yearObject(value: any): any;
        static yearMonth(dateTime: DateTime | null): string;
        static yearMonthObject(value: any): any;
        static getDateDimensionFunctions(): List<string>;
        static image(value: any, width?: number, height?: number): any;
        static isValidUrl(hyperlink: string): boolean;
        static localize(func: string): string;
        static abs(value: number): number;
        static absObject(value: any): any;
        static acos(value: number): number;
        static acosObject(value: any): any;
        static asin(value: number): number;
        static asinObject(value: any): any;
        static atan(value: number): any;
        static atanObject(value: any): any;
        static ceiling(value: number): number;
        static ceilingObject(value: any): any;
        static cos(value: number): number;
        static cosObject(value: any): any;
        static div(value1: number, value2: number, zeroResult?: number | null): number | null;
        static divObject(value1: any, value2: any, zeroResult?: any): number;
        static exp(value: number): number;
        static expObject(value: any): any;
        static floor(value: number): number;
        static floorObject(value: any): any;
        static log(value: number): number;
        static logObject(value: any): any;
        static round(value: number, decimals?: number): number;
        static roundObject(value: any, decimals?: number): any;
        static sign(value: number): number;
        static signObject(value: any): any;
        static sin(value: number): number;
        static sinObject(value: any): any;
        static sqrt(value: number): number;
        static sqrtObject(value: any): any;
        static tan(value: number): number;
        static tanObject(value: any): any;
        static truncate(value: number): number;
        static truncateObject(value: any): any;
        static isMeasureFunction(expression: string): boolean;
        static getMeasureFunctions(): List<string>;
        static getAggregateMeasureFunctions(): List<string>;
        static getCommonMeasureFunctions(): List<string>;
        static calculate(functionn: string, values: List<object>): any;
        private static iso2Cache;
        static getMapIdents(key: string): List<string>;
        static getIso2ConvertedValues(name: string): List<string>;
        static iso2(name: string, mapId?: string): string;
        static iso2Object(value: any, mapId?: string): any;
        static iso2ToName(alpha2: string, mapId?: string): string;
        static iso2ToNameObject(value: any, mapId?: string): any;
        static iso3(name: string, mapId?: string): string;
        static iso3Object(value: any, mapId?: string): any;
        static iso3ToName(alpha3: string, mapId?: string): string;
        static iso3ToNameObject(value: any, mapId?: string): any;
        static normalizeName(alpha3: string, mapId?: string): string;
        static normalizeNameObject(value: any, mapId?: string): any;
        private static toProperCaseCache;
        private static toLowerCaseCache;
        private static toUpperCaseCache;
        private static toDataNameCache;
        static format(format: string, value: any): string;
        static formatObject(format: string, value: any): any;
        static insert(str: string, startIndex: number, subStr: string): string;
        static insertObject(value: any, startIndex: number, subStr: string): any;
        static isDataEqual(dataSource: IStiAppDataSource, dataColumnName: string, searchColumnName: string): boolean;
        static left(str: string, length?: number): string;
        static leftObject(value: any, length?: number): any;
        static length2(str: string): number;
        static lengthObject(value: any): any;
        static remove(str: string, startIndex: number, count: number): string;
        static removeObject(value: any, startIndex: number, count: number): any;
        static replace(str: string, oldValue: string, newValue: string): string;
        static replaceObject(value: any, oldValue: string, newValue: string): any;
        static right(str: string, length?: number): string;
        static rightObject(value: any, length?: number): any;
        static toDataName(name: string): string;
        static toExpression(name: string): string;
        static toExpression2(sourceName: string, columnName: string): string;
        static toLowerCase(str: string): string;
        static toLowerCaseObject(value: any): any;
        static toProperCase(str: string): string;
        static toProperCaseObject(value: any): any;
        static toString(value: any): string;
        static toStringObject(value: any): any;
        static toUpperCase(str: string): string;
        static toUpperCaseObject(value: any): any;
        static trim(str: string): string;
        static trimObject(value: any): any;
        static trimStart(str: string): string;
        static trimStartObject(value: any): any;
        static trimEnd(str: string): string;
        static trimEndObject(value: any): any;
        static substring(str: string, startIndex: number, length?: number): string;
        static substringObject(value: any, startIndex: number, length?: number): any;
        static getSystemVariable(variable: StiSystemVariableObject, line: number): any;
        static existsCustomFunction(funcName: string): boolean;
        static getCustomFunctions(funcName: string): List<IStiAppFunction>;
        static getCustomFunction(funcName: string, argumentTypes: List<Type>): IStiAppFunction;
        static invokeCustomFunction(funcName: string, argumentss: List<any>): any;
        static skipNulls(values: List<any>): List<any>;
        static optionalSkipNulls(values: List<object>): List<object>;
        private static arabics;
        private static romans;
        private static subs;
        private static abc;
        private static abcRu;
        static toRoman(value: number): string;
        static toABC(value: number): string;
        static toABCNumeric(value: number): string;
        static toABCRu(value: number): string;
        static toArabic(value: string | number, useEasternDigits: boolean): string;
    }
}
declare namespace Stimulsoft.Data.Functions {
    import Enum = Stimulsoft.System.Enum;
    enum StiQuarter {
        Q1 = 1,
        Q2 = 2,
        Q3 = 3,
        Q4 = 4
    }
    class StiMonth extends Enum {
        static January: StiMonth;
        static February: StiMonth;
        static March: StiMonth;
        static April: StiMonth;
        static May: StiMonth;
        static June: StiMonth;
        static July: StiMonth;
        static August: StiMonth;
        static September: StiMonth;
        static October: StiMonth;
        static November: StiMonth;
        static December: StiMonth;
        static 1: StiMonth;
        static 2: StiMonth;
        static 3: StiMonth;
        static 4: StiMonth;
        static 5: StiMonth;
        static 6: StiMonth;
        static 7: StiMonth;
        static 8: StiMonth;
        static 9: StiMonth;
        static 10: StiMonth;
        static 11: StiMonth;
        static 12: StiMonth;
    }
    class StiDayOfWeek extends Enum {
        static Sunday: StiDayOfWeek;
        static Monday: StiDayOfWeek;
        static Tuesday: StiDayOfWeek;
        static Wednesday: StiDayOfWeek;
        static Thursday: StiDayOfWeek;
        static Friday: StiDayOfWeek;
        static Saturday: StiDayOfWeek;
        static 0: StiDayOfWeek;
        static 1: StiDayOfWeek;
        static 2: StiDayOfWeek;
        static 3: StiDayOfWeek;
        static 4: StiDayOfWeek;
        static 5: StiDayOfWeek;
        static 6: StiDayOfWeek;
    }
    class StiSystemVariableObject {
        static Line: StiSystemVariableObject;
        static LineABC: StiSystemVariableObject;
        static LineRoman: StiSystemVariableObject;
        private value;
        constructor(value: string);
    }
}
declare namespace Stimulsoft.Data.Parsers {
    import FunctionArgs = Stimulsoft.Data.Expressions.NCalc.FunctionArgs;
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    abstract class StiDataParser {
        protected runFunction(funcName: string, args: FunctionArgs): any;
        protected getVariableValue(name: string): any;
        protected isVariable(name: string): boolean;
        protected isSystemVariable(name: string): any;
        protected getSystemVariableValue(name: string): any;
        private static getObjectFromArg;
        private static evaluateArgs;
        private static getObjectFromArg0;
        private static getObjectFromArg1;
        private static getObjectFromArg2;
        private static getDataColumnFromArg0;
        protected getDataColumnIndex(columnName: string): number;
        private dataEqual;
        protected getDimensionIndex(dimension: IStiDimensionMeter): number;
        dictionary: IStiAppDictionary;
        table: DataTable;
        meters: List<IStiMeter>;
        isGrandTotal: boolean;
        private nameToIndex;
        private nameToValue;
        private nameToVariable;
        constructor(dictionary: IStiAppDictionary, table: DataTable, meters: List<IStiMeter>);
    }
}
declare namespace Stimulsoft.Data.Parsers {
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import Grouping = Stimulsoft.System.Collections.Grouping;
    class StiMeasureDataParser extends StiDataParser {
        calculate(): List<any[]>;
        calculateMeter(meter: IStiMeter, keys?: any[], rows?: List<object[]>): any;
        private calculateDimension;
        private calculateMeasureFunction;
        private calculateMeasureExpression;
        private getMeasureColumn;
        private getExpression;
        private getDataRowValue;
        private grandRows;
        private currentRows;
        private queryToExpression;
        private expressionToPair;
        constructor(dictionary: IStiAppDictionary, table: DataTable, meters: List<IStiMeter>, grandRows: List<Grouping<any[], any[]>>);
    }
}
declare namespace Stimulsoft.Data.Parsers {
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiDimensionDataParser extends StiDataParser {
        calculate(row: any[], meters: List<IStiMeter>): any[];
        private static normalizeDates;
        private static getMeter;
        private static normalizeDate;
        private calculateDimension;
        private getDimensionGroupColumn;
        private calculateDimensionExpression;
        private calculateDimensionGroup;
        private normalizeEnum;
        private getExpression;
        protected dimensions: List<IStiDimensionMeter>;
        private currentRow;
        private queryToExpression;
        private expressionToColumn;
        constructor(dictionary: IStiAppDictionary, table: DataTable, meters: List<IStiMeter>);
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    class StiDataCreator {
        static create(dict: IStiAppDictionary, meters: List<IStiMeter>): StiDataTable;
        private static convert;
        private static getData;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiAppDataColumn = Stimulsoft.Base.IStiAppDataColumn;
    class StiDataExpressionHelper {
        static getDataColumnFromExpression(query: IStiQueryObject, expression: string): IStiAppDataColumn;
        static isDateDataColumnInExpression(query: IStiQueryObject, expression: string): boolean;
        static isNumericDataColumnInExpression(query: IStiQueryObject, expression: string): boolean;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    class StiDataFilterComparer implements IComparer<any> {
        convertStrings: boolean;
        compare(x: any, y: any): number;
        constructor(convertStrings?: boolean);
    }
}
declare namespace Stimulsoft.Data.Engine {
    class StiDataFilterHelper {
        static convertStringToCondition(condition: string): StiDataFilterCondition;
        static convertConditionToString(condition: StiDataFilterCondition): string;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDataFilterRule extends StiDataRule implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        static loadFromJson(json: StiJson): StiDataFilterRule;
        static loadFromXml(xmlNode: XmlNode): StiDataFilterRule;
        toString(): string;
        getUniqueCode(): number;
        toList(): List<StiDataFilterRule>;
        getStringRepresentation(): string;
        private getValue;
        key: string;
        elementKey: string;
        path: string;
        path2: string;
        condition: StiDataFilterCondition;
        value: string;
        value2: string;
        isEnabled: boolean;
        isExpression: boolean;
        constructor(key?: string, path?: string, condition?: StiDataFilterCondition, value?: string, value2?: string, isEnabled?: boolean, isExpression?: boolean, path2?: string);
    }
}
declare namespace Stimulsoft.Data.Exceptions {
    class StiTypeNotRecognizedException extends StiDataException {
        constructor(type: any);
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiApp = Stimulsoft.Base.IStiApp;
    import IStiReport = Stimulsoft.Base.IStiReport;
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDataColumn = Stimulsoft.Base.IStiAppDataColumn;
    import Type = Stimulsoft.System.Type;
    import StiDataFilerRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    class StiDataFilterRuleHelper {
        static toList(...rules: StiDataFilterRule[]): List<StiDataFilterRule>;
        static validate(rules: List<StiDataFilerRule>, columnKeys: List<string>): List<StiDataFilterRule>;
        static getDataTableFilterQuery(rules: List<StiDataFilterRule>, columns: List<IStiAppDataColumn>, report: IStiReport): string;
        static getDataTableFilterQuery2(rules: List<StiDataFilterRule>, columnNames: List<string>, columnTypes: List<Type>, report: IStiReport): string;
        private static getFullPath;
        private static getFilterGroupQuery;
        private static getValue;
        private static getColumnIndex;
        private static getColumnIndex2;
        private static getCondition;
        private static getQueryValue;
        private static getFilterOperation;
        static getFilterRulesHash(app: IStiApp, rules: List<StiDataFilterRule>): number;
        private static getFilterRulesHash2;
        private static getFilterRuleHash3;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiReport = Stimulsoft.Base.IStiReport;
    import List = Stimulsoft.System.Collections.List;
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiDataFiltrator {
        private static lockObject;
        private static meterCache;
        private static netCache;
        static filter(inTable: DataTable, filters: List<StiDataFilterRule>, report: IStiReport, hash: number): DataTable;
        static filter2(inTable: StiDataTable, filters: List<StiDataFilterRule>, report: IStiReport, hash: number): StiDataTable;
        private static filterMapIdents;
        private static simplify;
        static cleanCache(appKey: string): void;
        private static getCacheKey;
        private static getCacheKey2;
        private static getFromCache;
        private static getFromCache2;
        private static addToCache;
        private static addToCache2;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiDataGrouper {
        static group(dictionary: IStiAppDictionary, joinedTable: DataTable, meters: List<IStiMeter>): StiDataTable;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import IStiApp = Stimulsoft.Base.IStiApp;
    class StiDataJoiner {
        private static cache;
        static joinEngine: StiDataJoinEngine;
        static join(tables: List<DataTable>, links: List<StiDataLink>, meters: List<IStiMeter>, app: IStiApp): DataTable;
        private static copyColumns;
        private static mergeInSequence;
        private static findLink;
        private static getCacheKey;
        private static getFromCache;
        private static addToCache;
        static cleanCache(appKey: string): void;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiDataLink implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        parentTable: string;
        childTable: string;
        parentColumn: string;
        childColumn: string;
        get parentKey(): string;
        get childKey(): string;
        key: string;
        active: boolean;
        static loadFromJson(json: StiJson): StiDataLink;
        static loadFromXml(xmlNode: XmlNode): StiDataLink;
        toString(): string;
        private nullStr;
        constructor(parentTable?: string, childTable?: string, parentColumn?: string, childColumn?: string, active?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    class StiDataLinkHelper {
        static getLinks(dictionary: IStiAppDictionary): List<StiDataLink>;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiApp = Stimulsoft.Base.IStiApp;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import List = Stimulsoft.System.Collections.List;
    class StiDataPicker {
        private static lockObject;
        private static cache;
        static fetch(query: IStiQueryObject, group: string, option?: StiDataRequestOption, filterNames?: List<string>, links?: List<StiDataLink>): Promise<List<DataTable>>;
        private static getRelationLevel;
        static retrieveUsedDataSources(query: IStiQueryObject, group: string, filterNames: List<string>): List<IStiAppDataSource>;
        static fetch2(app: IStiApp, dataSourceName: string, option?: StiDataRequestOption): Promise<DataTable>;
        static fetch3(app: IStiApp, dataSource: IStiAppDataSource, option?: StiDataRequestOption): Promise<DataTable>;
        static isAllBICached(query: IStiQueryObject, group: string, option?: StiDataRequestOption): boolean;
        static getDataTable(app: IStiApp, dataSource: IStiAppDataSource, option?: StiDataRequestOption): Promise<DataTable>;
        static getDataTable2(option: StiDataRequestOption, dataSource: IStiAppDataSource): Promise<DataTable>;
        static processCalculatedColumns(dataTable: DataTable, dataSource: IStiAppDataSource): DataTable;
        static addTableNameToColumnNames(table: DataTable, dataSource: IStiAppDataSource): void;
        static getFromCache(dataSource: IStiAppDataSource): DataTable;
        static existsInCache(dataSource: IStiAppDataSource): boolean;
        static addToCache(dataSource: IStiAppDataSource, dataTable: {
            ref: DataTable;
        }): void;
        private static getCacheKey;
        static cleanCache(appKey: string): void;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import DataRow = Stimulsoft.System.Data.DataRow;
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiDataRowJoiner {
        join(type: StiDataJoinType, link: StiDataLink, meters: List<IStiMeter>): List<DataRow>;
        private leftJoinRows;
        private innerJoinRows;
        private leftJoinRowsV1;
        private leftJoinRowsV2V3;
        private calculateIndexes;
        private isNumericType;
        private crossJoinRows;
        private fullJoinRows;
        private getHashCode;
        private splitRows;
        private getFieldIndex;
        private resultTable;
        private table1;
        private table2;
        private resultColumnIndexes;
        private column1Indexes;
        private column2Indexes;
        constructor(resultTable: DataTable, table1: DataTable, table2: DataTable);
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDataSortRule extends StiDataRule implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        static loadFromJson(json: StiJson): StiDataSortRule;
        static loadFromXml(xmlNode: XmlNode): StiDataSortRule;
        toString(): string;
        getUniqueCode(): number;
        key: string;
        direction: StiDataSortDirection;
        constructor(key?: string, direction?: StiDataSortDirection);
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDataColumn = Stimulsoft.Base.IStiAppDataColumn;
    class StiDataSortRuleHelper {
        static toList(...rules: StiDataSortRule[]): List<StiDataSortRule>;
        static validate(rules: List<StiDataSortRule>, columnKeys: List<string>): List<StiDataSortRule>;
        static getDataTableSortQuery(rules: List<StiDataSortRule>, columns: List<IStiAppDataColumn>): string;
        static getDataTableSortQuery2(rules: List<StiDataSortRule>, columnKeys: List<string>, columnNames: List<string>): string;
        static getSortDirection(rules: List<StiDataSortRule>, columnKey: string): StiDataSortDirection;
        static setSortDirection(rules: List<StiDataSortRule>, columnKeys: List<string>, columnKey: string, direction: StiDataSortDirection): List<StiDataSortRule>;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    class StiDataSortVariation {
        static ident: string;
        static isVariationSort(sort: List<StiDataSortRule>): boolean;
        static createVariationSort(direction: StiDataSortDirection): List<StiDataSortRule>;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiApp = Stimulsoft.Base.IStiApp;
    import List = Stimulsoft.System.Collections.List;
    class StiDataSorter {
        private static lockObject;
        private static hashCache;
        static sort(inTable: StiDataTable, sorts: List<StiDataSortRule>, app: IStiApp, hash: number, option?: StiDataRequestOption): StiDataTable;
        private static getFixedDataSortRules;
        static cleanCache(appKey: string): void;
        private static getCacheKey;
        private static getFromCache;
        private static addToCache;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import List = Stimulsoft.System.Collections.List;
    class StiDataSourceChainFinder {
        static find(dataSources: List<IStiAppDataSource>): List<IStiAppDataSource>;
        private static find3;
        static findInParent(dataSource1: IStiAppDataSource, dataSource2: IStiAppDataSource, dataPath?: List<string>): List<IStiAppDataSource>;
        static findInChild(dataSource1: IStiAppDataSource, dataSource2: IStiAppDataSource, dataPath?: List<string>): List<IStiAppDataSource>;
        static findInBoth(dataSource1: IStiAppDataSource, dataSource2: IStiAppDataSource): List<IStiAppDataSource>;
        private static getDataPoint;
        private static getActiveRelations;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    class StiDataSourcePicker {
        static fetch(query: IStiQueryObject, group: string, dataNames: List<string>, dataSources: List<IStiAppDataSource>): List<IStiAppDataSource>;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiDataTable {
        static nullTable: StiDataTable;
        meters: List<IStiMeter>;
        rows: List<any[]>;
        get isNull(): boolean;
        get isEmpty(): boolean;
        constructor(meters?: List<IStiMeter>, rows?: List<any[]>);
    }
}
declare namespace Stimulsoft.Data.Engine {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiDataTopN implements IStiJsonReportObject, ICloneable {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        static createFromJsonObject(jObject: StiJson): StiDataTopN;
        static createFromXml(xmlNode: XmlNode): StiDataTopN;
        clone(): StiDataTopN;
        mode: StiDataTopNMode;
        count: number;
        showOthers: boolean;
        othersText: string;
        measureField: string;
        isDefault(): boolean;
        toString(): string;
        getUniqueCode(): number;
        constructor(mode?: StiDataTopNMode, count?: number, showOthers?: boolean, othersText?: string, measureField?: string);
    }
}
declare namespace Stimulsoft.Data.Engine {
    class StiErrorStack {
        private static keyToError;
        static setOk(key: string): void;
        static setError(key: string, error: string): void;
        static getError(key: string): string;
        static isFail(key: string): boolean;
    }
}
declare namespace Stimulsoft.Data.Exceptions {
    class StiBingException extends StiDataException {
        constructor(message: string);
    }
}
declare namespace Stimulsoft.Data.Exceptions {
    class StiColumnNotFoundException extends StiDataException {
        private _name;
        get name(): string;
        constructor(name: string);
    }
}
declare namespace Stimulsoft.Data.Exceptions {
    class StiSystemVariableNotRecognizedException extends StiDataException {
        constructor(name: string);
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import List = Stimulsoft.System.Collections.List;
    class ANTLRStringStream implements ICharStream {
        private static ImplementsANTLRStringStream;
        implements(): any[];
        protected data: string[];
        protected n: number;
        protected p: number;
        protected markDepth: number;
        protected markers: List<CharStreamState>;
        protected lastMarker: number;
        name: string;
        constructor(input?: string, data?: string[], numberOfActualCharsInArray?: number, sourceName?: string);
        get index(): number;
        line: number;
        charPositionInLine: number;
        reset(): void;
        consume(): void;
        la(i: number): number;
        lt(i: number): number;
        get count(): number;
        mark(): number;
        rewind(m?: number): void;
        release(marker: number): void;
        seek(index: number): void;
        substring(start: number, length: number): string;
        get sourceName(): string;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class ANTLRReaderStream extends ANTLRStringStream {
        readBufferSize: number;
        initialBufferSize: number;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class ANTLRInputStream extends ANTLRReaderStream {
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class ParserRuleReturnScope<TToken> implements IRuleReturnScope<TToken> {
        private static ImplementsParserRuleReturnScope;
        implements(): any[];
        start: TToken;
        stop: TToken;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class AstParserRuleReturnScope<TTree, TToken> extends ParserRuleReturnScope<TToken> implements IAstRuleReturnScope<TTree>, IAstRuleReturnScope<any> {
        private static ImplementsAstParserRuleReturnScope;
        implements(): any[];
        tree: TTree;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import List = Stimulsoft.System.Collections.List;
    class BaseRecognizer {
        memoRuleFailed: number;
        memoRuleUnknown: number;
        static initialFollowStackSize: number;
        defaultTokenChannel: number;
        hidden: number;
        nextTokenRuleName: string;
        state: RecognizerSharedState;
        constructor(state?: RecognizerSharedState);
        setState(value: RecognizerSharedState): void;
        protected initDFAs(): void;
        reset(): void;
        match(input: IIntStream, ttype: number, follow: BitSet): any;
        matchAny(input: IIntStream): void;
        mismatchIsUnwantedToken(input: IIntStream, ttype: number): boolean;
        mismatchIsMissingToken(input: IIntStream, follow: BitSet): boolean;
        reportError(e: RecognitionException): void;
        displayRecognitionError(tokenNames: string[], e: RecognitionException): void;
        getErrorMessage(e: RecognitionException, tokenNames: string[]): string;
        get numberOfSyntaxErrors(): number;
        getErrorHeader(e: RecognitionException): string;
        getTokenErrorDisplay(t: IToken): string;
        emitErrorMessage(msg: string): void;
        recover(input: IIntStream, re: RecognitionException): void;
        beginResync(): void;
        endResync(): void;
        protected computeErrorRecoverySet(): BitSet;
        protected computeContextSensitiveRuleFOLLOW(): BitSet;
        protected combineFollows(exact: boolean): BitSet;
        protected recoverFromMismatchedToken(input: IIntStream, ttype: number, follow: BitSet): any;
        recoverFromMismatchedSet(input: IIntStream, e: RecognitionException, follow: BitSet): any;
        protected getCurrentInputSymbol(input: IIntStream): any;
        protected getMissingSymbol(input: IIntStream, e: RecognitionException, expectedTokenType: number, follow: BitSet): any;
        consumeUntil(input: IIntStream, tokenType: number): void;
        consumeUntil2(input: IIntStream, set: BitSet): void;
        protected pushFollow(fset: BitSet): void;
        protected popFollow(): void;
        get backtrackingLevel(): number;
        set backtrackingLevel(value: number);
        get failed(): boolean;
        tokenNames: string[];
        grammarFileName: string;
        get sourceName(): string;
        toStrings(tokens: List<IToken>): List<string>;
        getRuleMemoization(ruleIndex: number, ruleStartIndex: number): number;
        alreadyParsedRule(input: IIntStream, ruleIndex: number): boolean;
        memoize(input: IIntStream, ruleIndex: number, ruleStartIndex: number): void;
        getRuleMemoizationCacheSize(): number;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class BitSet {
        private static BITS;
        private static LOG_BITS;
        private static MOD_MASK;
        _bits: number[];
        static create(bits: number[]): BitSet;
        constructor(nbits?: number);
        static of(el: number): BitSet;
        static of2(a: number, b: number): BitSet;
        static of3(a: number, b: number, c: number): BitSet;
        static of4(a: number, b?: number, c?: number, d?: number): BitSet;
        or(a: BitSet): BitSet;
        add(el: number): void;
        growToInclude(bit: number): void;
        orInPlace(a: BitSet): void;
        private setSize;
        private static bitMask;
        clone(): any;
        size(): number;
        getHashCode(): number;
        equals(other: any): boolean;
        member(el: number): boolean;
        remove(el: number): void;
        isNil(): boolean;
        private static numWordsToHold;
        numBits(): number;
        lengthInLongWords(): number;
        toArray(): number[];
        private static wordNumber;
        toString(tokenNames?: string[]): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import List = Stimulsoft.System.Collections.List;
    class BufferedTokenStream implements ITokenStream, ITokenStreamInformation {
        private static ImplementsBufferedTokenStream;
        implements(): any[];
        private _tokenSource;
        _tokens: List<IToken>;
        private _lastMarker;
        protected _p: number;
        constructor(tokenSource?: ITokenSource);
        get tokenSource(): ITokenSource;
        set tokenSource(value: ITokenSource);
        get index(): number;
        range: number;
        get count(): number;
        get sourceName(): string;
        get lastToken(): IToken;
        get lastRealToken(): IToken;
        maxLookBehind: number;
        mark(): number;
        release(marker: number): void;
        rewind(marker?: number): void;
        reset(): void;
        seek(index: number): void;
        consume(): void;
        protected sync(i: number): void;
        protected fetch(n: number): void;
        get(i: number): IToken;
        la(i: number): number;
        protected lb(k: number): IToken;
        lt(k: number): IToken;
        protected setup(): void;
        getTokens(start: number, stop: number, types: BitSet): List<IToken>;
        toString(): string;
        toString2(start: number, stop: number): string;
        fill(): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class CharStreamConstants {
        static endOfFile: number;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class CharStreamState {
        p: number;
        line: number;
        charPositionInLine: number;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class ClassicToken implements IToken {
        private static ImplementsClassicToken;
        implements(): any[];
        index: number;
        constructor(type: number, text: string, channel: number);
        text: string;
        type: number;
        line: number;
        charPositionInLine: number;
        channel: number;
        startIndex: number;
        stopIndex: number;
        get tokenIndex(): number;
        set tokenIndex(value: number);
        inputStream: ICharStream;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class CommonToken implements IToken {
        private static ImplementsCommonToken;
        implements(): any[];
        input: ICharStream;
        _text: string;
        index: number;
        start: number;
        stop: number;
        constructor();
        static create1(type: number): CommonToken;
        static create2(input: ICharStream, type: number, channel: number, start: number, stop: number): CommonToken;
        static create3(type: number, text: string): CommonToken;
        static create4(oldToken: IToken): CommonToken;
        get text(): string;
        set text(value: string);
        type: number;
        line: number;
        charPositionInLine: number;
        channel: number;
        get startIndex(): number;
        set startIndex(value: number);
        get stopIndex(): number;
        set stopIndex(value: number);
        get tokenIndex(): number;
        set tokenIndex(value: number);
        get inputStream(): ICharStream;
        set inputStream(value: ICharStream);
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class CommonTokenStream extends BufferedTokenStream {
        channel: number;
        constructor(tokenSource?: ITokenSource, channel?: number);
        consume(): void;
        lb(k: number): IToken;
        lt(k: number): IToken;
        skipOffTokenChannels(i: number): number;
        protected skipOffTokenChannelsReverse(i: number): number;
        reset(): void;
        setup(): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class DFA {
        protected eot: number[];
        protected eof: number[];
        protected min: string[];
        protected max: string[];
        protected accept: number[];
        protected special: number[];
        protected transition: number[][];
        protected decisionNumber: number;
        protected recognizer: BaseRecognizer;
        debug: boolean;
        constructor();
        description: string;
        predict(input: IIntStream): number;
        private dfaDebugMessage;
        private dfaDebugInvalidSymbol;
        protected noViableAlt(s: number, input: IIntStream): void;
        error(nvae: NoViableAltException): void;
        static specialStateTransitionDefault(dfa: DFA, s: number, input: IIntStream): number;
        static unpackEncodedString(encodedString: string): number[];
        static unpackEncodedStringToUnsignedChars(encodedString: string): string[];
        protected debugRecognitionException(ex: RecognitionException): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import List = Stimulsoft.System.Collections.List;
    class BaseTree implements ITree {
        private static ImplementsBaseTree;
        implements(): any[];
        constructor(node?: ITree);
        children: List<ITree>;
        get childCount(): number;
        parent: ITree;
        childIndex: number;
        get isNil(): boolean;
        protected _tokenStartIndex: number;
        get tokenStartIndex(): number;
        set tokenStartIndex(value: number);
        protected _tokenStopIndex: number;
        get tokenStopIndex(): number;
        set tokenStopIndex(value: number);
        protected _type: number;
        get type(): number;
        set type(value: number);
        protected _text: string;
        get text(): string;
        set text(value: string);
        line: number;
        charPositionInLine: number;
        getChild(i: number): ITree;
        getFirstChildWithType(type: number): ITree;
        addChild(t: ITree): void;
        addChildren(kids: List<ITree>): void;
        setChild(i: number, t: ITree): void;
        insertChild(i: number, t: ITree): void;
        deleteChild(i: number): any;
        replaceChildren(startChildIndex: number, stopChildIndex: number, t: any): void;
        createChildrenList(): List<ITree>;
        freshenParentAndChildIndexes(offset?: number): void;
        freshenParentAndChildIndexesDeeply(offset?: number): void;
        sanityCheckParentAndChildIndexes(parent?: ITree, i?: number): void;
        hasAncestor(ttype: number): boolean;
        getAncestor(ttype: number): ITree;
        getAncestors(): List<ITree>;
        toStringTree(): string;
        toString(): string;
        dupNode(): ITree;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class CommonTree extends BaseTree {
        private _token;
        protected startIndex: number;
        protected stopIndex: number;
        parent: CommonTree;
        childIndex: number;
        constructor(node?: CommonTree | IToken);
        get isNil(): boolean;
        get text(): string;
        token: IToken;
        get tokenStartIndex(): number;
        set tokenStartIndex(value: number);
        get tokenStopIndex(): number;
        set tokenStopIndex(value: number);
        get type(): number;
        dupNode(): ITree;
        setUnknownTokenBoundaries(): void;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    let ITreeNodeStream: System.Interface<ITreeNodeStream>;
    interface ITreeNodeStream extends IIntStream {
        get(i: number): ITreeNodeStream;
        lt(k: number): any;
        treeSource: any;
        tokenStream: ITokenStream;
        treeAdaptor: ITreeAdaptor;
        uniqueNavigationNodes: boolean;
        toString(start: any, stop: any): string;
        replaceChildren(parent: any, startChildIndex: number, stopChildIndex: number, t: any): any;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    import ITreeNodeStream = Stimulsoft.Data.Expressions.Antlr.Runtime.Tree.ITreeNodeStream;
    class RecognitionException extends Exception {
        private _k;
        private _c;
        constructor(message?: string, input?: IIntStream, k?: number, innerException?: Exception);
        get unexpectedType(): number;
        approximateLineInfo: boolean;
        input: IIntStream;
        get lookahead(): number;
        token: IToken;
        node: any;
        get character(): string;
        set character(value: string);
        index: number;
        line: number;
        charPositionInLine: number;
        protected extractInformationFromTreeNodeStream(input: ITreeNodeStream): void;
        protected extractInformationFromTreeNodeStream2(input: ITreeNodeStream, k: number): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    class EarlyExitException extends RecognitionException {
        constructor(message?: string, decisionNumber?: number, input?: IIntStream, innerException?: Exception);
        decisionNumber: number;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    class FailedPredicateException extends RecognitionException {
        constructor(message?: string, input?: IIntStream, ruleName?: string, predicateText?: string, innerException?: Exception);
        ruleName: string;
        predicateText: string;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Attribute = Stimulsoft.System.Attribute;
    class GrammarRuleAttribute extends Attribute {
        constructor(name: string);
        name: string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    let IAstRuleReturnScope: IAstRuleReturnScope<any>;
    interface IAstRuleReturnScope<TAstLabel> {
        tree: TAstLabel;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    let ICharStream: System.Interface<ICharStream>;
    interface ICharStream extends IIntStream {
        substring(start: number, length: number): string;
        lt(i: number): number;
        line: number;
        charPositionInLine: number;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    let IIntStream: System.Interface<IIntStream>;
    interface IIntStream {
        consume(): any;
        la(i: number): number;
        mark(): number;
        index: number;
        rewind(marker?: number): any;
        release(marker: number): any;
        seek(index: number): any;
        count: number;
        sourceName: string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    let IRuleReturnScope: IRuleReturnScope<any>;
    interface IRuleReturnScope<TLabel> {
        start: TLabel;
        stop: TLabel;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    let ITemplateRuleReturnScope: ITemplateRuleReturnScope<any>;
    interface ITemplateRuleReturnScope<TTemplate> {
        template: TTemplate;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    let IToken: System.Interface<IToken>;
    interface IToken {
        text: string;
        type: number;
        line: number;
        charPositionInLine: number;
        channel: number;
        startIndex: number;
        stopIndex: number;
        tokenIndex: number;
        inputStream: ICharStream;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    let ITokenSource: System.Interface<ITokenSource>;
    interface ITokenSource {
        nextToken(): IToken;
        sourceName: string;
        tokenNames: string[];
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    let ITokenStream: System.Interface<ITokenStream>;
    interface ITokenStream extends IIntStream {
        lt(k: number): IToken;
        range: number;
        get(i: number): IToken;
        tokenSource: ITokenSource;
        toString(start: number, stop: number): string;
        toString(start: IToken, stop: IToken): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    let ITokenStreamInformation: System.Interface<ITokenStreamInformation>;
    interface ITokenStreamInformation {
        lastToken: IToken;
        lastRealToken: IToken;
        maxLookBehind: number;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import List = Stimulsoft.System.Collections.List;
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    class LegacyCommonTokenStream implements ITokenStream {
        private static ImplementsLegacyCommonTokenStream;
        implements(): any[];
        _tokenSource: ITokenSource;
        protected tokens: List<IToken>;
        protected channelOverrideMap: Dictionary<number, number>;
        protected discardSet: List<number>;
        protected channel: number;
        protected discardOffChannelTokens: boolean;
        protected lastMarker: number;
        protected p: number;
        constructor(tokenSource?: ITokenSource, channel?: number);
        get index(): number;
        range: number;
        setTokenSource(tokenSource: ITokenSource): void;
        fillBuffer(): void;
        consume(): void;
        protected skipOffTokenChannels(i: number): number;
        protected skipOffTokenChannelsReverse(i: number): number;
        setTokenTypeChannel(ttype: number, channel: number): void;
        discardTokenType(ttype: number): void;
        setDiscardOffChannelTokens(discardOffChannelTokens: boolean): void;
        getTokens(): List<IToken>;
        getTokens2(start: number, stop: number, types?: BitSet): List<IToken>;
        lt(k: number): IToken;
        protected lb(k: number): IToken;
        get(i: number): IToken;
        la(i: number): number;
        mark(): number;
        release(marker: number): void;
        get count(): number;
        rewind(marker?: number): void;
        reset(): void;
        seek(index: number): void;
        tokenSource: ITokenSource;
        get sourceName(): string;
        toString(): string;
        toString2(start: number, stop: number): string;
        toString3(start: IToken, stop: IToken): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class Lexer extends BaseRecognizer implements ITokenSource {
        private static ImplementsLexer;
        implements(): any[];
        protected input: ICharStream;
        constructor(input?: ICharStream, state?: RecognizerSharedState);
        get text(): string;
        set text(value: string);
        get line(): number;
        set line(value: number);
        get charPositionInLine(): number;
        set charPositionInLine(value: number);
        reset(): void;
        nextToken(): IToken;
        getEndOfFileToken(): IToken;
        skip(): void;
        mTokens(): void;
        get charStream(): ICharStream;
        set charStream(value: ICharStream);
        get sourceName(): string;
        emit2(token: IToken): void;
        emit(): IToken;
        match3(s: string): void;
        matchAny(): void;
        match2(c: number): void;
        matchRange(a: number, b: number): void;
        get charIndex(): number;
        reportError(e: RecognitionException): void;
        getErrorMessage(e: RecognitionException, tokenNames: string[]): string;
        getCharErrorDisplay(c: number): string;
        recover2(re: RecognitionException): void;
        protected parseNextToken(): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    class MismatchedSetException extends RecognitionException {
        constructor(message?: string, expecting?: BitSet, input?: IIntStream, innerException?: Exception);
        expecting: BitSet;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    class MismatchedNotSetException extends MismatchedSetException {
        constructor(message?: string, expecting?: BitSet, input?: IIntStream, innerException?: Exception);
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    class MismatchedRangeException extends RecognitionException {
        constructor(message?: string, a?: number, b?: number, input?: IIntStream, innerException?: Exception);
        a: number;
        b: number;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import List = Stimulsoft.System.Collections.List;
    import Exception = Stimulsoft.System.Exception;
    class MismatchedTokenException extends RecognitionException {
        constructor(message?: string, expecting?: number, input?: IIntStream, tokenNames?: List<string>, innerException?: Exception);
        expecting: number;
        tokenNames: List<string>;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    import ITreeNodeStream = Stimulsoft.Data.Expressions.Antlr.Runtime.Tree.ITreeNodeStream;
    class MismatchedTreeNodeException extends RecognitionException {
        constructor(message?: string, expecting?: number, input?: ITreeNodeStream, innerException?: Exception);
        expecting: number;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import List = Stimulsoft.System.Collections.List;
    import Exception = Stimulsoft.System.Exception;
    class MissingTokenException extends MismatchedTokenException {
        private _inserted;
        constructor(message?: string, expecting?: number, input?: IIntStream, inserted?: any, tokenNames?: List<string>, innerException?: Exception);
        get missingType(): number;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    class NoViableAltException extends RecognitionException {
        constructor(message: string, grammarDecisionDescription: string, decisionNumber: number, stateNumber: number, input: IIntStream, k?: number, innerException?: Exception);
        decisionNumber: number;
        grammarDecisionDescription: string;
        stateNumber: number;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class Parser extends BaseRecognizer {
        input: ITokenStream;
        constructor(input: ITokenStream, state?: RecognizerSharedState);
        reset(): void;
        protected getCurrentInputSymbol(input: IIntStream): any;
        protected getMissingSymbol(input: IIntStream, e: RecognitionException, expectedTokenType: number, follow: BitSet): any;
        get tokenStream(): ITokenStream;
        set tokenStream(value: ITokenStream);
        get sourceName(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    class RecognizerSharedState {
        following: BitSet[];
        _fsp: number;
        errorRecovery: boolean;
        lastErrorIndex: number;
        failed: boolean;
        syntaxErrors: number;
        backtracking: number;
        ruleMemo: Array<Dictionary<number, number>>;
        token: IToken;
        tokenStartCharIndex: number;
        tokenStartLine: number;
        tokenStartCharPositionInLine: number;
        channel: number;
        type: number;
        text: string;
        constructor();
        static recognizerSharedState(state: RecognizerSharedState): RecognizerSharedState;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class TemplateParserRuleReturnScope<TTemplate, TToken> extends ParserRuleReturnScope<TToken> implements ITemplateRuleReturnScope<TTemplate>, ITemplateRuleReturnScope<any> {
        private static ImplementsTemplateParserRuleReturnScope;
        implements(): any[];
        template: TTemplate;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class TokenChannels {
        static default: number;
        static hidden: number;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Type = Stimulsoft.System.Type;
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    import List = Stimulsoft.System.Collections.List;
    class TokenRewriteStream extends CommonTokenStream {
        DEFAULT_PROGRAM_NAME: string;
        PROGRAM_INIT_SIZE: number;
        MIN_TOKEN_INDEX: number;
        protected programs: Dictionary<string, List<RewriteOperation>>;
        protected lastRewriteTokenIndexes: Dictionary<string, number>;
        protected init(): void;
        constructor(tokenSource?: ITokenSource, channel?: number);
        rollback(programName: string, instructionIndex: number): void;
        deleteProgram(programName?: string): void;
        unsertAfter(programName: string, index: number, text: string): void;
        insertBefore(programName: string, index: number, text: string): void;
        replace(programName: string, from: number, to: number, text: any): void;
        replace2(programName: string, from: IToken, to: IToken, text: any): void;
        delete(programName: string, from: IToken, to: IToken): void;
        protected getLastRewriteTokenIndex(programName: string): number;
        protected setLastRewriteTokenIndex(programName: string, i: number): void;
        protected getProgram(name: string): List<RewriteOperation>;
        private initializeProgram;
        toOriginalString(): string;
        toOriginalString2(start: number, end: number): string;
        toString(): string;
        toString3(programName: string, start: number, end: number): string;
        protected reduceToSingleOperationPerIndex(rewrites: List<RewriteOperation>): Dictionary<number, RewriteOperation>;
        protected catOpText(a: string, b: string): string;
        protected getKindOfOps(rewrites: List<RewriteOperation>, kind: Type, before?: number): List<RewriteOperation>;
        toDebugString(start?: number, end?: number): string;
    }
    class RewriteOperation {
        instructionIndex: number;
        index: number;
        text: string;
        protected stream: TokenRewriteStream;
        constructor(stream: TokenRewriteStream, index: number, text?: string);
        execute(buf: string): number;
        toString(): string;
    }
    class InsertBeforeOp extends RewriteOperation {
        constructor(stream: TokenRewriteStream, index: number, text: string);
        execute(buf: string): number;
    }
    class ReplaceOp extends RewriteOperation {
        lastIndex: number;
        constructor(stream: TokenRewriteStream, from: number, to: number, text: string);
        execute(buf: string): number;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class TokenTypes {
        static endOfFile: number;
        static invalid: number;
        static endOfRule: number;
        static down: number;
        static up: number;
        static min: number;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class Tokens {
        static skip: IToken;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Misc {
    import List = Stimulsoft.System.Collections.List;
    class ListStack<T> extends List<T> {
        peek(depth?: number): T;
        tryPeek(ref: {
            item: T;
        }): boolean;
        tryPeek2(depth: number, ref: {
            item: T;
        }): boolean;
        pop(): T;
        tryPop(ref: {
            item: T;
        }): boolean;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Misc {
    import List = Stimulsoft.System.Collections.List;
    class FastQueue<T> {
        _data: List<T>;
        _p: number;
        get count(): number;
        range: number;
        get(i: number): T;
        dequeue(): T;
        enqueue(o: T): void;
        peek(): T;
        clear(): void;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Misc {
    class LookaheadStream<T> extends FastQueue<T> {
        private _currentElementIndex;
        private _previousElement;
        _eof: T;
        _lastMarker: number;
        _markDepth: number;
        get endOfFile(): T;
        set endOfFile(value: T);
        get previousElement(): T;
        reset(): void;
        nextElement(): T;
        isEndOfFile(o: T): boolean;
        dequeue(): T;
        consume(): void;
        syncAhead(need: number): void;
        fill(n: number): void;
        get count(): number;
        lt(k: number): T;
        get index(): number;
        mark(): number;
        release(marker: number): void;
        rewind2(marker: number): void;
        rewind(): void;
        seek(index: number): void;
        lb(k: number): T;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import LookaheadStream = Stimulsoft.Data.Expressions.Antlr.Runtime.Misc.LookaheadStream;
    class UnbufferedTokenStream extends LookaheadStream<IToken> implements ITokenStream, ITokenStreamInformation {
        private static ImplementsUnbufferedTokenStream;
        implements(): any[];
        tokenSource: ITokenSource;
        protected tokenIndex: number;
        protected channel: number;
        private _realTokens;
        constructor(tokenSource: ITokenSource);
        get sourceName(): string;
        get lastToken(): IToken;
        get lastRealToken(): IToken;
        maxLookBehind: number;
        mark(): number;
        release(marker: number): void;
        clear(): void;
        consume(): void;
        extElement(): IToken;
        isEndOfFile(o: IToken): boolean;
        get(i: number): IToken;
        la(i: number): number;
        toString2(start: IToken | number, stop: IToken | number): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import List = Stimulsoft.System.Collections.List;
    import Exception = Stimulsoft.System.Exception;
    class UnwantedTokenException extends MismatchedTokenException {
        constructor(message?: string, expecting?: number, input?: IIntStream, tokenNames?: List<string>, innerException?: Exception);
        get unexpectedToken(): IToken;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Misc {
    class Action {
    }
    class Func<TResult> extends Function {
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Misc {
    class RegexOptionsHelper {
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import ITree = Stimulsoft.Data.Expressions.Antlr.Runtime.Tree.ITree;
    class AntlrRuntime_BaseTreeDebugView {
        private _tree;
        constructor(tree: BaseTree);
        get children(): ITree[];
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class TreeRuleReturnScope<TTree> implements IRuleReturnScope<TTree> {
        private static ImplementsTreeRuleReturnScope;
        implements(): any[];
        private _start;
        start: TTree;
        stop: TTree;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class AstTreeRuleReturnScope<TOutputTree, TInputTree> extends TreeRuleReturnScope<TInputTree> implements IAstRuleReturnScope<TOutputTree>, IAstRuleReturnScope<any> {
        private static ImplementsAstTreeRuleReturnScope;
        implements(): any[];
        tree: TOutputTree;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    class BaseTreeAdaptor implements ITreeAdaptor {
        private static ImplementsBaseTreeAdaptor;
        implements(): any[];
        protected treeToUniqueIDMap: Dictionary<any, number>;
        protected uniqueNodeID: number;
        nil(): any;
        errorNode(input: ITokenStream, start: IToken, stop: IToken, e: RecognitionException): any;
        isNil(tree: any): boolean;
        dupNode(type?: number, treeNode?: any, text?: string): any;
        dupTree(t: any, parent?: any): any;
        addChild(t: any, child: any): void;
        becomeRoot(newRoot: any, oldRoot: any): any;
        rulePostProcessing(root: any): any;
        becomeRoot2(newRoot: IToken, oldRoot: any): any;
        create5(tokenType: number, fromToken: IToken): any;
        create2(tokenType: number, fromToken: IToken, text: string): any;
        create3(fromToken: IToken, text: string): any;
        create4(tokenType: number, text: string): any;
        getType(t: number): number;
        setType(t: any, type: number): void;
        getText(t: any): string;
        setText(t: any, text: string): void;
        getChild(t: any, i: number): any;
        setChild(t: any, i: number, child: any): void;
        deleteChild(t: any, i: number): any;
        getChildCount(t: any): number;
        getUniqueID(node: any): number;
        createToken2(tokenType: number, text: string): IToken;
        createToken(fromToken: IToken): IToken;
        create(payload: IToken): any;
        dupNode2(treeNode: any): any;
        getToken(t: any): IToken;
        setTokenBoundaries(t: any, startToken: IToken, stopToken: IToken): void;
        getTokenStartIndex(t: any): number;
        getTokenStopIndex(t: any): number;
        getParent(t: any): any;
        setParent(t: any, parent: any): any;
        getChildIndex(t: any): number;
        setChildIndex(t: any, index: number): void;
        replaceChildren(parent: any, startChildIndex: number, stopChildIndex: number, t: any): void;
        getTree(t: any): ITree;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import List = Stimulsoft.System.Collections.List;
    import Stack = Stimulsoft.System.Collections.Stack;
    class BufferedTreeNodeStream implements ITreeNodeStream, ITokenStreamInformation {
        private static ImplementsBufferedTreeNodeStream;
        implements(): any[];
        DEFAULT_INITIAL_BUFFER_SIZE: number;
        INITIAL_CALL_STACK_SIZE: number;
        down: any;
        up: any;
        eof: any;
        nodes: List<any>;
        protected root: any;
        protected tokens: ITokenStream;
        adaptor: ITreeAdaptor;
        uniqueNavigationNodes: boolean;
        protected p: number;
        protected lastMarker: number;
        protected calls: Stack<number>;
        constructor(adaptor?: ITreeAdaptor, tree?: any, initialBufferSize?: number);
        get count(): number;
        get treeSource(): any;
        get sourceName(): string;
        get tokenStream(): ITokenStream;
        set tokenStream(value: ITokenStream);
        get treeAdaptor(): ITreeAdaptor;
        set treeAdaptor(value: ITreeAdaptor);
        get lastToken(): IToken;
        get lastRealToken(): IToken;
        maxLookBehind: number;
        fillBuffer(): void;
        fillBuffer2(t: any): void;
        protected getNodeIndex(node: any): number;
        protected addNavigationNode(ttype: number): void;
        get(i: number): any;
        lt(k: number): any;
        getCurrentSymbol(): any;
        protected lb(k: number): any;
        consume(): void;
        la(i: number): number;
        mark(): number;
        release(marker: number): void;
        get index(): number;
        rewind2(marker: number): void;
        rewind(): void;
        seek(index: number): void;
        push(index: number): void;
        pop(): number;
        reset(): void;
        iterator(): List<any>;
        replaceChildren(parent: any, startChildIndex: number, stopChildIndex: number, t: any): void;
        toTokenTypeString(): string;
        toTokenString(start: number, stop: number): string;
        toString(start: any, stop: any): string;
    }
    class StreamIterator extends List<any> {
        _outer: BufferedTreeNodeStream;
        _index: number;
        constructor(outer: BufferedTreeNodeStream);
        get current(): any;
        dispose(): void;
        moveNext(): boolean;
        reset(): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class CommonErrorNode extends CommonTree {
        input: IIntStream;
        start: IToken;
        stop: IToken;
        trappedException: RecognitionException;
        constructor(input: ITokenStream, start: IToken, stop: IToken, e: RecognitionException);
        get isNil(): boolean;
        get text(): string;
        get type(): number;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class CommonTreeAdaptor extends BaseTreeAdaptor {
        create(payload: IToken): CommonTree;
        createToken2(tokenType: number, text: string): IToken;
        createToken(fromToken: IToken): IToken;
        getToken(t: any): IToken;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import LookaheadStream = Stimulsoft.Data.Expressions.Antlr.Runtime.Misc.LookaheadStream;
    class CommonTreeNodeStream extends LookaheadStream<any> implements ITreeNodeStream, IPositionTrackingStream {
        private static ImplementsCommonTreeNodeStream;
        implements(): any[];
        DEFAULT_INITIAL_BUFFER_SIZE: number;
        INITIAL_CALL_STACK_SIZE: number;
        private _root;
        protected tokens: ITokenStream;
        private _adaptor;
        private _it;
        private _calls;
        private _hasNilRoot;
        private _level;
        private _previousLocationElement;
        constructor(adaptor: ITreeAdaptor, tree: any);
        get sourceName(): string;
        get tokenStream(): ITokenStream;
        set tokenStream(value: ITokenStream);
        get treeAdaptor(): ITreeAdaptor;
        set treeAdaptor(value: ITreeAdaptor);
        get treeSource(): any;
        uniqueNavigationNodes: boolean;
        reset(): void;
        nextElement(): any;
        dequeue(): any;
        isEndOfFile(o: any): boolean;
        la(i: number): number;
        push(index: number): void;
        pop(): number;
        getKnownPositionElement(allowApproximateLocation: boolean): any;
        hasPositionInformation(node: any): boolean;
        replaceChildren(parent: any, startChildIndex: number, stopChildIndex: number, t: any): void;
        toString1(start: any, stop: any): string;
        toTokenTypeString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    import List = Stimulsoft.System.Collections.List;
    class DotTreeGenerator {
        headerLines: string[];
        footer: string;
        nodeFormat: string;
        edgeFormat: string;
        nodeToNumberMap: Dictionary<any, number>;
        nodeNumber: number;
        toDot2(tree: any, adaptor: ITreeAdaptor): string;
        toDot(tree: ITree): string;
        protected defineNodes(tree: any, adaptor: ITreeAdaptor): List<string>;
        defineEdges(tree: any, adaptor: ITreeAdaptor): List<string>;
        protected getNodeText(adaptor: ITreeAdaptor, t: any): string;
        protected getNodeNumber(t: any): number;
        protected fixString(text: string): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    let IPositionTrackingStream: System.Interface<IPositionTrackingStream>;
    interface IPositionTrackingStream {
        getKnownPositionElement(allowApproximateLocation: boolean): any;
        hasPositionInformation(element: any): boolean;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import List = Stimulsoft.System.Collections.List;
    let ITree: System.Interface<ITree>;
    interface ITree {
        getChild(i: number): ITree;
        childCount: number;
        parent: ITree;
        hasAncestor(ttype: number): boolean;
        getAncestor(ttype: number): ITree;
        getAncestors(): List<ITree>;
        childIndex: number;
        freshenParentAndChildIndexes(): any;
        addChild(t: ITree): any;
        setChild(i: number, t: ITree): any;
        deleteChild(i: number): any;
        replaceChildren(startChildIndex: number, stopChildIndex: number, t: any): any;
        isNil: boolean;
        tokenStartIndex: number;
        tokenStopIndex: number;
        dupNode(): ITree;
        type: number;
        text: string;
        line: number;
        charPositionInLine: number;
        toStringTree(): string;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    let ITreeAdaptor: System.Interface<ITreeAdaptor>;
    interface ITreeAdaptor {
        create(payload: IToken): any;
        create2(tokenType: number, fromToken: IToken, text: string): any;
        create3(fromToken: IToken, text: string): any;
        create4(tokenType: number, text: string): any;
        dupNode2(treeNode: any): any;
        dupNode(type?: number, treeNode?: any, text?: string): any;
        dupTree(tree: any): any;
        nil(): any;
        errorNode(input: ITokenStream, start: IToken, stop: IToken, e: RecognitionException): any;
        isNil(tree: any): boolean;
        addChild(t: any, child: any): any;
        becomeRoot(newRoot: IToken | any, oldRoot: any): any;
        rulePostProcessing(root: any): any;
        getUniqueID(node: any): number;
        getType(t: any): number;
        setType(t: any, type: number): any;
        getText(t: any): string;
        setText(t: any, text: string): any;
        getToken(t: any): IToken;
        setTokenBoundaries(t: any, startToken: IToken, stopToken: IToken): any;
        getTokenStartIndex(t: any): number;
        getTokenStopIndex(t: any): number;
        getChild(t: any, i: number): any;
        setChild(t: any, i: number, child: any): any;
        deleteChild(t: any, i: number): any;
        getChildCount(t: any): number;
        getParent(t: any): any;
        setParent(t: any, parent: any): any;
        getChildIndex(t: any): number;
        setChildIndex(t: any, index: number): any;
        replaceChildren(parent: any, startChildIndex: number, stopChildIndex: number, t: any): any;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    let ITreeVisitorAction: System.Interface<ITreeVisitorAction>;
    interface ITreeVisitorAction {
        pre(t: any): any;
        post(t: any): any;
    }
    class TreeVisitorAction implements ITreeVisitorAction {
        private static ImplementsTreeVisitorAction;
        implements(): any[];
        pre(t: any): any;
        post(t: any): any;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import List = Stimulsoft.System.Collections.List;
    class ParseTree extends BaseTree {
        payload: any;
        hiddenTokens: List<IToken>;
        constructor(label: any);
        get text(): string;
        _tokenStartIndex: number;
        _tokenStopIndex: number;
        _type: number;
        dupNode(): ITree;
        toString(): string;
        toStringWithHiddenTokens(): string;
        toInputString(): string;
        protected toStringLeaves(buf: string): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Exception = Stimulsoft.System.Exception;
    class RewriteCardinalityException extends Exception {
        private _elementDescription;
        constructor(message?: string, elementDescription?: string, innerException?: Exception);
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Exception = Stimulsoft.System.Exception;
    class RewriteEarlyExitException extends RewriteCardinalityException {
        constructor(message?: string, elementDescription?: string, innerException?: Exception);
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Exception = Stimulsoft.System.Exception;
    class RewriteEmptyStreamException extends RewriteCardinalityException {
        constructor(message?: string, elementDescription?: string, innerException?: Exception);
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import List = Stimulsoft.System.Collections.List;
    class RewriteRuleElementStream {
        protected cursor: number;
        protected singleElement: any;
        protected elements: List<any>;
        protected dirty: boolean;
        protected elementDescription: string;
        protected adaptor: ITreeAdaptor;
        constructor(adaptor: ITreeAdaptor, elementDescription: string, oneElement?: any, elements?: List<any>);
        reset(): void;
        add(el: any): void;
        nextTree(): any;
        nextCore(): any;
        protected dup(el: any): any;
        protected toTree(el: any): any;
        get hasNext(): boolean;
        get count(): number;
        get description(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import List = Stimulsoft.System.Collections.List;
    class RewriteRuleNodeStream extends RewriteRuleElementStream {
        constructor(adaptor: ITreeAdaptor, elementDescription: string, oneElement?: any, elements?: List<any>);
        nextNode(): any;
        protected toTree(el: any): any;
        protected dup(el: any): any;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import List = Stimulsoft.System.Collections.List;
    class RewriteRuleSubtreeStream extends RewriteRuleElementStream {
        constructor(adaptor: ITreeAdaptor, elementDescription: string, oneElement?: any, elements?: List<any>);
        nextNode(): any;
        protected dup(el: any): any;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import List = Stimulsoft.System.Collections.List;
    class RewriteRuleTokenStream extends RewriteRuleElementStream {
        constructor(adaptor: ITreeAdaptor, elementDescription: string, oneElement?: any, elements?: List<any>);
        nextNode(): any;
        nextToken(): IToken;
        toTree(el: any): any;
        protected dup(el: any): any;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class TemplateTreeRuleReturnScope<TTemplate, TTree> extends TreeRuleReturnScope<TTree> implements ITemplateRuleReturnScope<TTemplate>, ITemplateRuleReturnScope<any> {
        private static ImplementsTemplateTreeRuleReturnScope;
        implements(): any[];
        template: TTemplate;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class TreeParser extends BaseRecognizer {
        DOWN: number;
        UP: number;
        static dotdot: string;
        static doubleEtc: string;
        protected input: ITreeNodeStream;
        constructor(input: ITreeNodeStream, state?: RecognizerSharedState);
        reset(): void;
        setTreeNodeStream(input: ITreeNodeStream): void;
        getTreeNodeStream(): ITreeNodeStream;
        get sourceName(): string;
        protected getCurrentInputSymbol(input: IIntStream): any;
        protected getMissingSymbol(input: IIntStream, e: RecognitionException, expectedTokenType: number, follow: BitSet): any;
        matchAny(ignore: IIntStream): void;
        protected recoverFromMismatchedToken(input: IIntStream, ttype: number, follow: BitSet): any;
        getErrorHeader(e: RecognitionException): string;
        getErrorMessage(e: RecognitionException, tokenNames: string[]): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Action = Stimulsoft.Data.Expressions.Antlr.Runtime.Misc.Action;
    class TreeFilter extends TreeParser {
        protected originalTokenStream: ITokenStream;
        protected originalAdaptor: ITreeAdaptor;
        constructor(input: ITreeNodeStream, state?: RecognizerSharedState);
        applyOnce(t: any, whichRule: Action): void;
        downup(t: any): void;
        protected topdown(): void;
        protected bottomup(): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import List = Stimulsoft.System.Collections.List;
    import Queue = Stimulsoft.System.Collections.Queue;
    class TreeIterator extends List<any> {
        protected adaptor: ITreeAdaptor;
        protected root: any;
        protected tree: any;
        protected firstTime: boolean;
        private reachedEof;
        up: any;
        down: any;
        eof: any;
        protected nodes: Queue<any>;
        constructor(adaptor: ITreeAdaptor, tree: any);
        current: any;
        dispose(): void;
        moveNext(): boolean;
        reset(): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class TreePatternLexer {
        static begin: number;
        static end: number;
        static id: number;
        static arg: number;
        static percent: number;
        static colon: number;
        static dot: number;
        protected pattern: string;
        protected p: number;
        protected c: number;
        protected n: number;
        sval: string;
        error: boolean;
        constructor(pattern: string);
        nextToken(): number;
        consume(): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class TreePatternParser {
        protected tokenizer: TreePatternLexer;
        protected ttype: number;
        protected wizard: TreeWizard;
        protected adaptor: ITreeAdaptor;
        constructor(tokenizer: TreePatternLexer, wizard: TreeWizard, adaptor: ITreeAdaptor);
        pattern(): any;
        parseTree(): any;
        parseNode(): any;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class TreeRewriter extends TreeParser {
        protected showTransformations: boolean;
        protected originalTokenStream: ITokenStream;
        protected originalAdaptor: ITreeAdaptor;
        constructor(input: ITreeNodeStream, state: RecognizerSharedState);
        applyOnce(t: any, whichRule: Misc.Func<IAstRuleReturnScope<any>>): any;
        applyRepeatedly(t: any, whichRule: Misc.Func<IAstRuleReturnScope<any>>): any;
        downup(t: any, showTransformations?: boolean): any;
        protected topdown(): IAstRuleReturnScope<any>;
        protected bottomup(): IAstRuleReturnScope<any>;
        protected reportTransformation(oldTree: any, newTree: any): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class TreeVisitor {
        protected adaptor: ITreeAdaptor;
        constructor(adaptor?: ITreeAdaptor);
        visit(t: any, action: ITreeVisitorAction): any;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    import List = Stimulsoft.System.Collections.List;
    import Action = Stimulsoft.Data.Expressions.Antlr.Runtime.Misc.Action;
    class TreeWizard {
        protected adaptor: ITreeAdaptor;
        protected tokenNameToTypeMap: Dictionary<string, number>;
        computeTokenTypes(tokenNames: string[]): Dictionary<string, number>;
        getTokenType(tokenName: string): number;
        index(t: any): Dictionary<number, List<any>>;
        protected indexCore(t: any, m: Dictionary<number, List<any>>): void;
        find(t: any, ttype: number): List<any>;
        find2(t: any, pattern: string): List<any>;
        findFirst(t: any, ttype: number): any;
        findFirst2(t: any, pattern: string): any;
        visit(t: any, ttype: number, visitor: IContextVisitor): void;
        visit2(t: any, ttype: number, action: Action): void;
        protected visitCore(t: any, parent: any, childIndex: number, ttype: number, visitor: IContextVisitor): void;
        visit3(t: any, pattern: string, visitor: IContextVisitor): void;
        parse(t: any, pattern: string, labels: Dictionary<string, any>): boolean;
        parse2(t: any, pattern: string): boolean;
        parseCore(t1: any, tpattern: TreePattern, labels: Dictionary<string, any>): boolean;
        create(pattern: string): any;
        static equals(t1: any, t2: any, adaptor: ITreeAdaptor): boolean;
        protected static equalsCore(t1: any, t2: any, adaptor: ITreeAdaptor): boolean;
    }
    let IContextVisitor: System.Interface<IContextVisitor>;
    interface IContextVisitor {
        visit(t: any, parent: any, childIndex: number, labels: Dictionary<string, any>): any;
    }
    class Visitor implements IContextVisitor {
        private static ImplementsVisitor;
        implements(): any[];
        visit2(t: any, parent: any, childIndex: number, labels: Dictionary<string, any>): void;
        visit(t: any): void;
    }
    class ActionVisitor extends Visitor {
        _action: Action;
        constructor(action: Action);
        visit(t: any): void;
    }
    class TreePattern extends CommonTree {
        label: string;
        hasTextArg: boolean;
        constructor(payload: IToken);
        toString(): string;
    }
    class WildcardTreePattern extends TreePattern {
        constructor(payload: IToken);
    }
    class TreePatternTreeAdaptor extends CommonTreeAdaptor {
        create(payload: IToken): any;
    }
    class FindTreeWizardVisitor extends Visitor {
        _nodes: List<any>;
        constructor(nodes: List<any>);
        visit(t: any): void;
    }
    class FindTreeWizardContextVisitor implements IContextVisitor {
        private static ImplementsFindTreeWizardContextVisitor;
        implements(): any[];
        _outer: TreeWizard;
        _tpattern: TreePattern;
        _subtrees: List<any>;
        constructor(outer: TreeWizard, tpattern: TreePattern, subtrees: List<any>);
        visit(t: any, parent: any, childIndex: number, labels: Dictionary<string, any>): void;
    }
    class VisitTreeWizardContextVisitor implements IContextVisitor {
        private static ImplementsVisitTreeWizardContextVisitor;
        implements(): any[];
        _outer: TreeWizard;
        _visitor: IContextVisitor;
        _labels: Dictionary<string, any>;
        _tpattern: TreePattern;
        constructor(outer: TreeWizard, visitor: IContextVisitor, labels: Dictionary<string, any>, tpattern: TreePattern);
        visit(t: any, parent: any, childIndex: number, unusedlabels: Dictionary<string, any>): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc {
    import Exception = Stimulsoft.System.Exception;
    class EvaluationException extends Exception {
        constructor(message: string, innerException?: Exception);
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc {
    enum EvaluateOptions {
        None = 1,
        IgnoreCase = 2,
        NoCache = 4,
        IterateParameters = 8,
        RoundAwayFromZero = 16
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class LogicalExpression {
        static bs: string;
        private static extractString;
        and(operand: LogicalExpression | any): BinaryExpression;
        dividedBy(operand: LogicalExpression | any): BinaryExpression;
        equalsTo(operand: LogicalExpression | any): BinaryExpression;
        greaterThan(operand: LogicalExpression | any): BinaryExpression;
        greaterOrEqualThan(operand: LogicalExpression | any): BinaryExpression;
        lesserThan(operand: LogicalExpression | any): BinaryExpression;
        lesserOrEqualThan(operand: LogicalExpression | any): BinaryExpression;
        minus(operand: LogicalExpression | any): BinaryExpression;
        modulo(operand: LogicalExpression | any): BinaryExpression;
        notEqual(operand: LogicalExpression | any): BinaryExpression;
        or(operand: LogicalExpression | any): BinaryExpression;
        plus(operand: LogicalExpression | any): BinaryExpression;
        mult(operand: LogicalExpression | any): BinaryExpression;
        bitwiseOr(operand: LogicalExpression | any): BinaryExpression;
        bitwiseAnd(operand: LogicalExpression | any): BinaryExpression;
        bitwiseXOr(operand: LogicalExpression | any): BinaryExpression;
        leftShift(operand: LogicalExpression | any): BinaryExpression;
        rightShift(operand: LogicalExpression | any): BinaryExpression;
        toString(): string;
        accept(visitor: LogicalExpressionVisitor): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    import LogicalExpressionVisitor = Stimulsoft.Data.Expressions.NCalc.Domain.LogicalExpressionVisitor;
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    class EvaluationVisitor extends LogicalExpressionVisitor {
        private _options;
        private get ignoreCase();
        constructor(options: EvaluateOptions);
        result: any;
        evaluate(expression: LogicalExpression): any;
        visit1(expression: LogicalExpression): void;
        private static commonTypes;
        private static getMostPreciseType;
        compareUsingMostPreciseType(a: any, b: any): any;
        visit2(expression: TernaryExpression): void;
        private static isReal;
        visit3(expression: BinaryExpression): void;
        visit4(expression: UnaryExpression): void;
        visit5(expression: ValueExpression): void;
        visit6(functionn: Functionn): void;
        private checkCase;
        evaluateFunction: (name: string, args: FunctionArgs) => void;
        private onEvaluateFunction;
        visit7(parameter: Identifier): void;
        evaluateParameter: (...args: any[]) => void;
        private onEvaluateParameter;
        parameters: Dictionary<string, any>;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc {
    import BaseRecognizer = Stimulsoft.Data.Expressions.Antlr.Runtime.BaseRecognizer;
    import DFA = Stimulsoft.Data.Expressions.Antlr.Runtime.DFA;
    import NoViableAltException = Stimulsoft.Data.Expressions.Antlr.Runtime.NoViableAltException;
    import RecognizerSharedState = Stimulsoft.Data.Expressions.Antlr.Runtime.RecognizerSharedState;
    import Lexer = Stimulsoft.Data.Expressions.Antlr.Runtime.Lexer;
    import ICharStream = Stimulsoft.Data.Expressions.Antlr.Runtime.ICharStream;
    export class NCalcLexer extends Lexer {
        EOF: number;
        DATETIME: number;
        DIGIT: number;
        E: number;
        EscapeSequence: number;
        FALSE: number;
        FLOAT: number;
        HexDigit: number;
        ID: number;
        INTEGER: number;
        LETTER: number;
        NAME: number;
        STRING: number;
        TRUE: number;
        UnicodeEscape: number;
        WS: number;
        T__19: number;
        T__20: number;
        T__21: number;
        T__22: number;
        T__23: number;
        T__24: number;
        T__25: number;
        T__26: number;
        T__27: number;
        T__28: number;
        T__29: number;
        T__30: number;
        T__31: number;
        T__32: number;
        T__33: number;
        T__34: number;
        T__35: number;
        T__36: number;
        T__37: number;
        T__38: number;
        T__39: number;
        T__40: number;
        T__41: number;
        T__42: number;
        T__43: number;
        T__44: number;
        T__45: number;
        T__46: number;
        T__47: number;
        T__48: number;
        constructor(input?: ICharStream, state?: RecognizerSharedState);
        mT__19(): void;
        mT__20(): void;
        mT__21(): void;
        mT__22(): void;
        mT__23(): void;
        mT__24(): void;
        mT__25(): void;
        mT__26(): void;
        mT__27(): void;
        mT__28(): void;
        mT__29(): void;
        mT__30(): void;
        mT__31(): void;
        mT__32(): void;
        mT__33(): void;
        enterRule_T__34(): void;
        leaveRule_T__34(): void;
        mT__34(): void;
        mT__35(): void;
        mT__36(): void;
        mT__37(): void;
        mT__38(): void;
        mT__39(): void;
        mT__40(): void;
        mT__41(): void;
        mT__42(): void;
        mT__43(): void;
        mT__44(): void;
        enterRule_T__45(): void;
        leaveRule_T__45(): void;
        mT__45(): void;
        mT__46(): void;
        mT__47(): void;
        mT__48(): void;
        mTRUE(): void;
        mFALSE(): void;
        mID(): void;
        mINTEGER(): void;
        mFLOAT(): void;
        mSTRING(): void;
        mDATETIME(): void;
        mNAME(): void;
        mE(): void;
        mLETTER(): void;
        mDIGIT(): void;
        mEscapeSequence(): void;
        mHexDigit(): void;
        mUnicodeEscape(): void;
        mWS(): void;
        mTokens(): void;
        dfa7: DFA7;
        dfa14: DFA14;
        initDFAs(): void;
    }
    class DFA7 extends DFA {
        static DFA7_eotS: string;
        static DFA7_eofS: string;
        static DFA7_minS: string;
        static DFA7_maxS: string;
        static DFA7_acceptS: string;
        static DFA7_specialS: string;
        private static DFA7_transitionS;
        private static DFA7_eot;
        private static DFA7_eof;
        private static DFA7_min;
        private static DFA7_max;
        private static DFA7_accept;
        private static DFA7_special;
        private static DFA7_transition;
        static initialize(): void;
        constructor(recognizer: BaseRecognizer);
        description: string;
        error(nvae: NoViableAltException): void;
    }
    class DFA14 extends DFA {
        static DFA14_eotS: string;
        static DFA14_eofS: string;
        static DFA14_minS: string;
        static DFA14_maxS: string;
        static DFA14_acceptS: string;
        static DFA14_specialS: string;
        private static DFA14_transitionS;
        private static DFA14_eot;
        private static DFA14_eof;
        private static DFA14_min;
        private static DFA14_max;
        private static DFA14_accept;
        private static DFA14_special;
        private static DFA14_transition;
        static initialize(): void;
        constructor(recognizer: BaseRecognizer);
        description: string;
        error(nvae: NoViableAltException): void;
    }
    export {};
}
declare namespace Stimulsoft.Data.Expressions.NCalc {
    import LogicalExpression = Stimulsoft.Data.Expressions.NCalc.Domain.LogicalExpression;
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    import List = Stimulsoft.System.Collections.List;
    class ReaderWriterLock {
        releaseReaderLock(): void;
        releaseWriterLock(): void;
        acquireReaderLock(t: number): void;
        acquireWriterLock(t: number): void;
    }
    class WeakReference {
        constructor(t: LogicalExpression);
        isAlive: boolean;
    }
    class Expression {
        static Timeout: {
            Infinite: number;
        };
        options: EvaluateOptions;
        protected originalExpression: string;
        constructor();
        static create1(expression: string, options?: EvaluateOptions): Expression;
        static create2(expression: LogicalExpression, options?: EvaluateOptions): Expression;
        private static _cacheEnabled;
        private static _compiledExpressions;
        private static rwl;
        static get cacheEnabled(): boolean;
        static set cacheEnabled(value: boolean);
        private static cleanCache;
        static compile(expression: string, nocache: boolean): LogicalExpression;
        hasErrors(): boolean;
        error: string;
        parsedExpression: LogicalExpression;
        protected parameterEnumerators: Dictionary<string, List<any>>;
        protected parametersBackup: Dictionary<string, any>;
        evaluate(): any;
        evaluateFunction: any;
        evaluateParameter: any;
        parameters: Dictionary<string, any>;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc {
    import List = Stimulsoft.System.Collections.List;
    import EventArgs = Stimulsoft.System.EventArgs;
    class FunctionArgs extends EventArgs {
        private _result;
        get result(): any;
        set result(value: any);
        hasResult: boolean;
        parameters: List<Expression>;
        evaluateParameters(): any[];
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class Functionn extends LogicalExpression {
        constructor(identifier: Identifier, expressions: LogicalExpression[]);
        identifier: Identifier;
        expressions: LogicalExpression[];
        accept(visitor: LogicalExpressionVisitor): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class UnaryExpression extends LogicalExpression {
        constructor(type: UnaryExpressionType, expression: LogicalExpression);
        expression: LogicalExpression;
        type: UnaryExpressionType;
        accept(visitor: LogicalExpressionVisitor): void;
    }
    enum UnaryExpressionType {
        Not = 0,
        Negate = 1,
        BitwiseNot = 2
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class BinaryExpression extends LogicalExpression {
        constructor(type: BinaryExpressionType, leftExpression: LogicalExpression, rightExpression: LogicalExpression);
        leftExpression: LogicalExpression;
        rightExpression: LogicalExpression;
        type: BinaryExpressionType;
        accept(visitor: LogicalExpressionVisitor): void;
    }
    enum BinaryExpressionType {
        And = 0,
        Or = 1,
        NotEqual = 2,
        LesserOrEqual = 3,
        GreaterOrEqual = 4,
        Lesser = 5,
        Greater = 6,
        Equal = 7,
        Minus = 8,
        Plus = 9,
        Modulo = 10,
        Div = 11,
        Times = 12,
        BitwiseOr = 13,
        BitwiseAnd = 14,
        BitwiseXOr = 15,
        LeftShift = 16,
        RightShift = 17,
        Unknown = 18
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class TernaryExpression extends LogicalExpression {
        constructor(leftExpression: LogicalExpression, middleExpression: LogicalExpression, rightExpression: LogicalExpression);
        leftExpression: LogicalExpression;
        middleExpression: LogicalExpression;
        rightExpression: LogicalExpression;
        accept(visitor: LogicalExpressionVisitor): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class ValueExpression extends LogicalExpression {
        constructor(value: any, type?: ValueType);
        value: any;
        type: ValueType;
        accept(visitor: LogicalExpressionVisitor): void;
    }
    enum ValueType {
        Integer = 0,
        String = 1,
        DateTime = 2,
        Float = 3,
        Boolean = 4
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class Identifier extends LogicalExpression {
        constructor(name: string);
        name: string;
        accept(visitor: LogicalExpressionVisitor): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc {
    import ValueExpression = Stimulsoft.Data.Expressions.NCalc.Domain.ValueExpression;
    import Identifier = Stimulsoft.Data.Expressions.NCalc.Domain.Identifier;
    import RecognitionException = Stimulsoft.Data.Expressions.Antlr.Runtime.RecognitionException;
    import RecognizerSharedState = Stimulsoft.Data.Expressions.Antlr.Runtime.RecognizerSharedState;
    import Parser = Stimulsoft.Data.Expressions.Antlr.Runtime.Parser;
    import ITokenStream = Stimulsoft.Data.Expressions.Antlr.Runtime.ITokenStream;
    import List = Stimulsoft.System.Collections.List;
    import AstParserRuleReturnScope = Stimulsoft.Data.Expressions.Antlr.Runtime.AstParserRuleReturnScope;
    import IToken = Stimulsoft.Data.Expressions.Antlr.Runtime.IToken;
    import LogicalExpression = Stimulsoft.Data.Expressions.NCalc.Domain.LogicalExpression;
    import ITreeAdaptor = Stimulsoft.Data.Expressions.Antlr.Runtime.Tree.ITreeAdaptor;
    export class NCalcParser extends Parser {
        tokenNames: string[];
        EOF: number;
        DATETIME: number;
        DIGIT: number;
        E: number;
        EscapeSequence: number;
        FALSE: number;
        FLOAT: number;
        HexDigit: number;
        ID: number;
        INTEGER: number;
        LETTER: number;
        NAME: number;
        STRING: number;
        TRUE: number;
        UnicodeEscape: number;
        WS: number;
        T__19: number;
        T__20: number;
        T__21: number;
        T__22: number;
        T__23: number;
        T__24: number;
        T__25: number;
        T__26: number;
        T__27: number;
        T__28: number;
        T__29: number;
        T__30: number;
        T__31: number;
        T__32: number;
        T__33: number;
        T__34: number;
        T__35: number;
        T__36: number;
        T__37: number;
        T__38: number;
        T__39: number;
        T__40: number;
        T__41: number;
        T__42: number;
        T__43: number;
        T__44: number;
        T__45: number;
        T__46: number;
        T__47: number;
        T__48: number;
        constructor(input: ITokenStream, state?: RecognizerSharedState);
        createTreeAdaptor(adaptor: {
            ref: ITreeAdaptor;
        }): void;
        adaptor: ITreeAdaptor;
        grammarFileName: string;
        private bs;
        private extractString;
        errors: List<string>;
        displayRecognitionError(tokenNames: string[], e: RecognitionException): void;
        onCreated(): void;
        enterRule(ruleName: string, ruleIndex: number): void;
        leaveRule(ruleName: string, ruleIndex: number): void;
        traceIn(ruleName: string, ruleIndex: number): void;
        enterRule_ncalcExpression(): void;
        leaveRule_ncalcExpression(): void;
        ncalcExpression(): ncalcExpression_return;
        enterRule_logicalExpression(): void;
        leaveRule_logicalExpression(): void;
        private logicalExpression;
        enterRule_conditionalExpression(): void;
        leaveRule_conditionalExpression(): void;
        private conditionalExpression;
        enterRule_booleanAndExpression(): void;
        leaveRule_booleanAndExpression(): void;
        booleanAndExpression(): booleanAndExpression_return;
        enterRule_bitwiseOrExpression(): void;
        leaveRule_bitwiseOrExpression(): void;
        bitwiseOrExpression(): bitwiseOrExpression_return;
        enterRule_bitwiseXOrExpression(): void;
        leaveRule_bitwiseXOrExpression(): void;
        bitwiseXOrExpression(): bitwiseXOrExpression_return;
        enterRule_bitwiseAndExpression(): void;
        leaveRule_bitwiseAndExpression(): void;
        bitwiseAndExpression(): bitwiseAndExpression_return;
        enterRule_equalityExpression(): void;
        leaveRule_equalityExpression(): void;
        equalityExpression(): equalityExpression_return;
        enterRule_relationalExpression(): void;
        leaveRule_relationalExpression(): void;
        relationalExpression(): relationalExpression_return;
        enterRule_shiftExpression(): void;
        leaveRule_shiftExpression(): void;
        shiftExpression(): shiftExpression_return;
        enterRule_additiveExpression(): void;
        leaveRule_additiveExpression(): void;
        additiveExpression(): additiveExpression_return;
        enterRule_multiplicativeExpression(): void;
        leaveRule_multiplicativeExpression(): void;
        multiplicativeExpression(): multiplicativeExpression_return;
        enterRule_unaryExpression(): void;
        leaveRule_unaryExpression(): void;
        unaryExpression(): unaryExpression_return;
        enterRule_primaryExpression(): void;
        leaveRule_primaryExpression(): void;
        primaryExpression(): primaryExpression_return;
        enterRule_value(): void;
        leaveRule_value(): void;
        value(): value_return;
        enterRule_identifier(): void;
        leaveRule_identifier(): void;
        identifier(): identifier_return;
        enterRule_expressionList(): void;
        leaveRule_expressionList(): void;
        expressionList(): expressionList_return;
        enterRule_arguments(): void;
        leaveRule_arguments(): void;
        arguments(): arguments_return;
    }
    class ncalcExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class booleanAndExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: any): void;
    }
    class bitwiseOrExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class bitwiseXOrExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class bitwiseAndExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class equalityExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class relationalExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class shiftExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class additiveExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class multiplicativeExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class unaryExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class primaryExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class value_return extends AstParserRuleReturnScope<any, IToken> {
        value: ValueExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class identifier_return extends AstParserRuleReturnScope<any, IToken> {
        value: Identifier;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class expressionList_return extends AstParserRuleReturnScope<any, IToken> {
        value: List<LogicalExpression>;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class arguments_return extends AstParserRuleReturnScope<any, IToken> {
        value: List<LogicalExpression>;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    export {};
}
declare namespace Stimulsoft.Data.Expressions.NCalc {
    class Numbers {
        private static convertIfString;
        static add(a: any, b: any): any;
        static soustract(a: any, b: any): any;
        static multiply(a: any, b: any): any;
        static divide(a: any, b: any): any;
        static modulo(a: any, b: any): any;
        static max(a: any, b: any): any;
        static min(a: any, b: any): any;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc {
    import EventArgs = Stimulsoft.System.EventArgs;
    class ParameterArgs extends EventArgs {
        private _result;
        get result(): any;
        set result(value: any);
        hasResult: boolean;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class SerializationVisitor extends LogicalExpressionVisitor {
        private _numberFormatInfo;
        constructor();
        result: string;
        visit1(expression: LogicalExpression): void;
        visit2(expression: TernaryExpression): void;
        visit3(expression: BinaryExpression): void;
        visit4(expression: UnaryExpression): void;
        visit5(expression: ValueExpression): void;
        visit6(functionn: Functionn): void;
        visit7(parameter: Identifier): void;
        encapsulateNoValue(expression: LogicalExpression): void;
    }
}
declare namespace Stimulsoft.Data.Helpers {
    class StiHumanReadableHelper {
        static getSize(size: number): string;
        static getHumanReadableName(name: string): string;
    }
}
declare namespace Stimulsoft.Data.Helpers {
    class StiMoneyNameHelper {
        static isMoneyName(name: string): boolean;
    }
}
declare namespace Stimulsoft.Data.Extensions {
    import DataColumn = Stimulsoft.System.Data.DataColumn;
    class DataColumnExt {
        static isNumericType(column: DataColumn): boolean;
        static isDateType(column: DataColumn): boolean;
        static isIntegerType(column: DataColumn): boolean;
        static isMoneyName(column: DataColumn): boolean;
        static getHumanReadableName(column: DataColumn): string;
    }
}
declare namespace Stimulsoft.Data.Extensions {
    class DataTimeExt {
    }
}
declare namespace Stimulsoft.Data.Extensions {
    class EnumerableRowCollectionExt {
    }
}
declare namespace Stimulsoft.Data.Extensions {
}
declare namespace Stimulsoft.Data.Helpers {
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiLabelHelper {
        private static cache;
        static getLabel(meter: IStiMeter): string;
    }
}
declare namespace Stimulsoft.Data.Extensions {
    import List = Stimulsoft.System.Collections.List;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class ListTableExt {
        static toNetTable(source: List<any[]>, meters: List<IStiMeter>, onlyColumns?: boolean): DataTable;
        private static loadDataRow;
        private static findType;
        private static findTypeInRows;
    }
}
declare namespace Stimulsoft.Data.Extensions {
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    class StiMeterExt {
        static indexOf(meters: List<IStiMeter>, meter: IStiMeter): number;
        static getDimensions(meters: List<IStiMeter>): List<IStiDimensionMeter>;
    }
}
declare namespace Stimulsoft.Data.Extensions {
    class TOuterExt {
    }
}
declare namespace Stimulsoft.Data.Functions {
    import DateTime = Stimulsoft.System.DateTime;
    class StiDayOfWeekToStrHelper {
        private static days;
        private static defaultUpperCaseList;
        private static cultureIndexes;
        static dayOfWeek(date: DateTime): string;
        static dayOfWeek2(date: DateTime, localized: boolean): string;
        static dayOfWeek3(dayOfWeek: StiDayOfWeek, culture: string): string;
        static dayOfWeek4(dateTime: DateTime, culture: string, upperCase: boolean): string;
        static dayOfWeek5(str: string): StiDayOfWeek | null;
        static dayOfWeek6(dateTime: DateTime, culture: string): string;
        static addCulture(monthNames: string[], cultureNames: string[], defaultUpperCase: boolean): void;
        static initialize(): void;
    }
}
declare namespace Stimulsoft.Data.Functions {
    class StiExtValueConverter {
        static isEligable(value: any, culture: string): boolean;
        static convert(value: any, culture: string): string;
    }
}
declare namespace Stimulsoft.Data.Functions {
    import DateTime = Stimulsoft.System.DateTime;
    class StiMonthToStrHelper {
        private static months;
        private static defaultUpperCaseList;
        private static cultureIndexes;
        static monthName(dateTime: DateTime): string;
        static monthName2(dateTime: DateTime, localized: boolean): string;
        static monthName3(dateTime: DateTime, culture: string): string;
        static monthName4(dateTime: DateTime, culture: string, upperCase: boolean): string;
        static monthName5(month: StiMonth, culture: string): string;
        static addCulture(monthNames: string[], cultureNames: string[], defaultUpperCase: boolean): void;
        static month2(value: number): StiMonth;
        static month(str: string): StiMonth | null;
        static initialize(): void;
    }
}
declare namespace Stimulsoft.Data.Helpers {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import Type = Stimulsoft.System.Type;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiDataTableConverter {
        static toNetTable(dataTable: StiDataTable, types?: Type[]): DataTable;
        private static getDataType;
    }
}
declare namespace Stimulsoft.Data.Helpers {
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiUsedDataHelper {
        static getMany(...meters: IStiMeter[]): List<string>;
        static getMany2(meters: List<IStiMeter>): List<string>;
        static getSingle(meter: IStiMeter): List<string>;
        static getSingle2(expression: string): List<string>;
    }
}
declare namespace Stimulsoft.Data.Parsers {
    class StiFunctionColumnPair {
        private _function;
        get function(): string;
        set function(value: string);
        private _columnName;
        get columnName(): string;
        set columnName(value: string);
    }
}
declare namespace Stimulsoft.Report {
    enum StiParserType {
        ReportParser = 0,
        DataParser = 1
    }
    enum StiNestedFactor {
        High = 0,
        Normal = 1,
        Low = 2
    }
    enum StiResizeReportOptions {
        ProcessAllPages = 1,
        RebuildReport = 2,
        RescaleContent = 4,
        PageOrientationChanged = 8,
        ShowProgressOnRebuildReport = 16,
        AllowPageMarginsRescaling = 32
    }
    enum StiCalculationMode {
        Compilation = 0,
        Interpretation = 1
    }
    enum StiReportLanguageType {
        CSharp = 0,
        VB = 1,
        JS = 2
    }
    enum StiReportUnitType {
        Centimeters = 0,
        HundredthsOfInch = 1,
        Inches = 2,
        Millimeters = 3
    }
    enum StiGridMode {
        Lines = 0,
        Dots = 1
    }
    enum StiReportPass {
        None = 0,
        First = 1,
        Second = 2
    }
    enum StiNumberOfPass {
        SinglePass = 0,
        DoublePass = 1
    }
    enum StiExportFormat {
        None = 0,
        Pdf = 1,
        Xps = 2,
        HtmlTable = 3,
        HtmlSpan = 4,
        HtmlDiv = 5,
        Rtf = 6,
        RtfTable = 7,
        RtfFrame = 8,
        RtfWinWord = 9,
        RtfTabbedText = 10,
        Text = 11,
        Excel = 12,
        ExcelXml = 13,
        Excel2007 = 14,
        Word2007 = 15,
        Xml = 16,
        Csv = 17,
        Dif = 18,
        Sylk = 19,
        Image = 20,
        ImageGif = 21,
        ImageBmp = 22,
        ImagePng = 23,
        ImageTiff = 24,
        ImageJpeg = 25,
        ImagePcx = 26,
        ImageEmf = 27,
        ImageSvg = 28,
        ImageSvgz = 29,
        Mht = 30,
        Dbf = 31,
        Html = 32,
        Ods = 33,
        Odt = 34,
        Ppt2007 = 35,
        Html5 = 36,
        Data = 37,
        Json = 38,
        Document = 1000
    }
    enum StiReportCacheMode {
        Off = 0,
        On = 1,
        Auto = 2
    }
    enum StiReportResourceType {
        Bitmap = 0,
        Metafile = 1,
        Report = 2
    }
    enum StiRangeType {
        All = 1,
        CurrentPage = 2,
        Pages = 3
    }
    enum StiHtmlType {
        Html = 1,
        Html5 = 2,
        Mht = 3
    }
    enum ImageFormat {
        Bmp = 0,
        Emf = 1,
        Exif = 2,
        Gif = 3,
        Guid = 4,
        Icon = 5,
        Jpeg = 6,
        MemoryBmp = 7,
        Png = 8,
        Tiff = 9,
        Wmf = 10
    }
    enum StiArabicDigitsType {
        Standard = 0,
        Eastern = 1
    }
    enum StiBrushType {
        Solid = 0,
        Glare = 1,
        Gradient0 = 2,
        Gradient90 = 3,
        Gradient180 = 4,
        Gradient270 = 5,
        Gradient45 = 6
    }
    enum StiComponentId {
        StiComponent = 0,
        StiBarCode = 1,
        StiButtonControl = 2,
        StiChart = 3,
        StiSparkline = 4,
        StiChartCommon = 5,
        StiCheckBox = 6,
        StiCheckBoxControl = 7,
        StiCheckedListBoxControl = 8,
        StiChildBand = 9,
        StiClone = 10,
        StiColumnFooterBand = 11,
        StiColumnHeaderBand = 12,
        StiComboBoxControl = 13,
        StiContainer = 14,
        StiContourText = 15,
        StiCrossColumn = 16,
        StiCrossColumnTotal = 17,
        StiCrossDataBand = 18,
        StiCrossFooterBand = 19,
        StiCrossGroupFooterBand = 20,
        StiCrossGroupHeaderBand = 21,
        StiCrossHeaderBand = 22,
        StiCrossRow = 23,
        StiCrossRowTotal = 24,
        StiCrossSummary = 25,
        StiCrossTab = 26,
        StiCrossTitle = 27,
        StiDashboardPage = 28,
        StiDataBand = 29,
        StiDateTimePickerControl = 30,
        StiEmptyBand = 31,
        StiFooterBand = 32,
        StiForm = 33,
        StiGridControl = 34,
        StiGroupBoxControl = 35,
        StiGroupFooterBand = 36,
        StiGroupHeaderBand = 37,
        StiHeaderBand = 38,
        StiHierarchicalBand = 39,
        StiHorizontalLinePrimitive = 40,
        StiImage = 41,
        StiLabelControl = 42,
        StiListBoxControl = 43,
        StiListViewControl = 44,
        StiLookUpBoxControl = 45,
        StiNumericUpDownControl = 46,
        StiOverlayBand = 47,
        StiPage = 48,
        StiPageFooterBand = 49,
        StiPageHeaderBand = 50,
        StiPanel = 51,
        StiPanelControl = 52,
        StiPictureBoxControl = 53,
        StiRadioButtonControl = 54,
        StiRectanglePrimitive = 55,
        StiReportControl = 56,
        StiReportSummaryBand = 57,
        StiReportTitleBand = 58,
        StiRichText = 59,
        StiRichTextBoxControl = 60,
        StiRoundedRectanglePrimitive = 61,
        StiShape = 62,
        StiSubReport = 63,
        StiSystemText = 64,
        StiTable = 65,
        StiTableCell = 66,
        StiText = 67,
        StiTextBoxControl = 68,
        StiTextInCells = 69,
        StiTreeViewControl = 70,
        StiVerticalLinePrimitive = 71,
        StiWinControl = 72,
        StiUndefinedComponent = 73,
        StiZipCode = 74,
        StiTableCellCheckBox = 75,
        StiTableCellImage = 76,
        StiTableCellRichText = 77,
        StiDataColumn = 78,
        StiCalcDataColumn = 79,
        StiBusinessObject = 80,
        StiDataSource = 81,
        StiDataStoreSource = 82,
        StiFileDataSource = 83,
        StiDataRelation = 84,
        StiVariable = 85,
        StiResource = 86,
        StiReport = 87,
        StiStyle = 88,
        StiCrossTabStyle = 89,
        StiChartStyle = 90,
        StiMapStyle = 91,
        StiTableStyle = 92,
        StiGaugeStyle = 93,
        StiIndicatorStyle = 94,
        StiDialogStyle = 95,
        StiDataParameter = 96,
        StiCrossField = 97,
        StiCrossTotal = 98,
        StiCrossCell = 99,
        StiCrossHeader = 100,
        StiCrossSummaryHeader = 101,
        StiStartPointPrimitive = 102,
        StiEndPointPrimitive = 103,
        StiEvent = 104,
        StiTableOfContents = 105,
        StiChartElement = 106,
        StiGaugeElement = 107,
        StiImageElement = 108,
        StiIndicatorElement = 109,
        StiRegionMapElement = 110,
        StiOnlineMapElement = 111,
        StiTableElement = 112,
        StiPivotTableElement = 113,
        StiProgressElement = 114,
        StiTextElement = 115,
        StiPanelElement = 116,
        StiShapeElement = 117,
        StiTreeViewElement = 118,
        StiTreeViewBoxElement = 119,
        StiListBoxElement = 120,
        StiComboBoxElement = 121,
        StiDatePickerElement = 122,
        StiDateRangeElement = 123,
        StiDashboard = 124,
        StiSeries = 125,
        StiBubbleSeries = 126,
        StiClusteredColumnSeries = 127,
        StiParetoSeries = 128,
        StiLineSeries = 129,
        StiSteppedLineSeries = 130,
        StiSplineSeries = 131,
        StiAreaSeries = 132,
        StiBoxAndWhiskerSeries = 133,
        StiSteppedAreaSeries = 134,
        StiSplineAreaSeries = 135,
        StiStackedColumnSeries = 136,
        StiStackedLineSeries = 137,
        StiStackedSplineSeries = 138,
        StiStackedAreaSeries = 139,
        StiStackedSplineAreaSeries = 140,
        StiFullStackedColumnSeries = 141,
        StiFullStackedLineSeries = 142,
        StiFullStackedAreaSeries = 143,
        StiFullStackedSplineSeries = 144,
        StiFullStackedSplineAreaSeries = 145,
        StiClusteredBarSeries = 146,
        StiStackedBarSeries = 147,
        StiTreemapSeries = 148,
        StiSunburstSeries = 149,
        StiWaterfallSeries = 150,
        StiPictorialSeries = 151,
        StiHistogramSeries = 152,
        StiFullStackedBarSeries = 153,
        StiPieSeries = 154,
        StiDoughnutSeries = 155,
        StiGanttSeries = 156,
        StiScatterSeries = 157,
        StiScatterLineSeries = 158,
        StiScatterSplineSeries = 159,
        StiRadarAreaSeries = 160,
        StiRadarLineSeries = 161,
        StiRadarPointSeries = 162,
        StiRangeSeries = 163,
        StiSteppedRangeSeries = 164,
        StiFunnelSeries = 165,
        StiFunnelWeightedSlicesSeries = 166,
        StiRangeBarSeries = 167,
        StiSplineRangeSeries = 168,
        StiCandlestickSeries = 169,
        StiStockSeries = 170,
        StiChartTitle = 171,
        StiLineMarker = 172,
        StiMarker = 173,
        StiChartTable = 174,
        StiSeriesTopN = 175,
        StiSeriesInteraction = 176,
        StiTrendLine = 177,
        StiSeriesLabels = 178,
        StiNoneLabels = 179,
        StiInsideEndAxisLabels = 180,
        StiInsideBaseAxisLabels = 181,
        StiCenterTreemapLabels = 182,
        StiCenterAxisLabels = 183,
        StiOutsideEndAxisLabels = 184,
        StiOutsideBaseAxisLabels = 185,
        StiOutsideAxisLabels = 186,
        StiLeftAxisLabels = 187,
        StiValueAxisLabels = 188,
        StiRightAxisLabels = 189,
        StiCenterFunnelLabels = 190,
        StiCenterPieLabels = 191,
        StiOutsidePieLabels = 192,
        StiTwoColumnsPieLabels = 193,
        StiOutsideLeftFunnelLabels = 194,
        StiOutsideRightFunnelLabels = 195,
        StiLegend = 196,
        StiClusteredColumnArea = 197,
        StiPieArea = 198,
        StiTreemapArea = 199,
        StiSunburstArea = 200,
        StiWaterfallArea = 201,
        StiHistorgamArea = 202,
        StiFunnelArea = 203,
        StiFunnelWeightedSlicesArea = 204,
        StiPictorialArea = 205,
        StiRadarAreaArea = 206,
        StiRadarLineArea = 207,
        StiRadarPointArea = 208,
        StiStackedColumnArea = 209,
        StiGridLines = 210,
        StiInterlacing = 211,
        StiXAxis = 212,
        StiXTopAxis = 213,
        StiYAxis = 214,
        StiYRightAxis = 215,
        StiRadarGridLines = 216,
        StiXRadarAxis = 217,
        StiYRadarAxis = 218,
        StiDialogInfoItem = 219,
        StiStringDialogInfoItem = 220,
        StiGuidDialogInfoItem = 221,
        StiCharDialogInfoItem = 222,
        StiBoolDialogInfoItem = 223,
        StiImageDialogInfoItem = 224,
        StiDateTimeDialogInfoItem = 225,
        StiTimeSpanDialogInfoItem = 226,
        StiDoubleDialogInfoItem = 227,
        StiDecimalDialogInfoItem = 228,
        StiLongDialogInfoItem = 229,
        StiExpressionDialogInfoItem = 230,
        StiStringRangeDialogInfoItem = 231,
        StiGuidRangeDialogInfoItem = 232,
        StiByteArrayRangeDialogInfoItem = 233,
        StiCharRangeDialogInfoItem = 234,
        StiDateTimeRangeDialogInfoItem = 235,
        StiTimeSpanRangeDialogInfoItem = 236,
        StiDoubleRangeDialogInfoItem = 237,
        StiDecimalRangeDialogInfoItem = 238,
        StiLongRangeDialogInfoItem = 239,
        StiExpressionRangeDialogInfoItem = 240,
        OracleConnectionStringBuilder = 241,
        StiStrips = 242,
        StiConstantLines = 243,
        StiShapeTypeService = 244,
        StiDiagonalDownLineShapeType = 245,
        StiRoundedRectangleShapeType = 246,
        StiTriangleShapeType = 247,
        StiComplexArrowShapeType = 248,
        StiBentArrowShapeType = 249,
        StiChevronShapeType = 250,
        StiEqualShapeType = 251,
        StiFlowchartCollateShapeType = 252,
        StiFlowchartOffPageConnectorShapeType = 253,
        StiArrowShapeType = 254,
        StiOctagonShapeType = 255,
        StiAustraliaPost4StateBarCodeType = 256,
        StiCode11BarCodeType = 257,
        StiCode128aBarCodeType = 258,
        StiCode128bBarCodeType = 259,
        StiCode128cBarCodeType = 260,
        StiCode128AutoBarCodeType = 261,
        StiCode39BarCodeType = 262,
        StiCode39ExtBarCodeType = 263,
        StiCode93BarCodeType = 264,
        StiCode93ExtBarCodeType = 265,
        StiCodabarBarCodeType = 266,
        StiEAN128aBarCodeType = 267,
        StiEAN128bBarCodeType = 268,
        StiEAN128cBarCodeType = 269,
        StiEAN128AutoBarCodeType = 270,
        StiGS1_128BarCodeType = 271,
        StiEAN13BarCodeType = 272,
        StiEAN8BarCodeType = 273,
        StiFIMBarCodeType = 274,
        StiIsbn10BarCodeType = 275,
        StiIsbn13BarCodeType = 276,
        StiITF14BarCodeType = 277,
        StiJan13BarCodeType = 278,
        StiJan8BarCodeType = 279,
        StiMsiBarCodeType = 280,
        StiPdf417BarCodeType = 281,
        StiPharmacodeBarCodeType = 282,
        StiPlesseyBarCodeType = 283,
        StiPostnetBarCodeType = 284,
        StiQRCodeBarCodeType = 285,
        StiRoyalMail4StateBarCodeType = 286,
        StiDutchKIXBarCodeType = 287,
        StiSSCC18BarCodeType = 288,
        StiUpcABarCodeType = 289,
        StiUpcEBarCodeType = 290,
        StiUpcSup2BarCodeType = 291,
        StiUpcSup5BarCodeType = 292,
        StiInterleaved2of5BarCodeType = 293,
        StiStandard2of5BarCodeType = 294,
        StiDataMatrixBarCodeType = 295,
        StiMaxicodeBarCodeType = 296,
        StiDatabase = 297,
        StiFileDatabase = 298,
        StiCsvDatabase = 299,
        StiDBaseDatabase = 300,
        StiExcelDatabase = 301,
        StiJsonDatabase = 302,
        StiXmlDatabase = 303,
        StiSqlDatabase = 304,
        StiGauge = 305,
        StiMap = 306,
        StiFullStackedColumnArea = 307,
        StiClusteredBarArea = 308,
        StiStackedBarArea = 309,
        StiFullStackedBarArea = 310,
        StiDoughnutArea = 311,
        StiLineArea = 312,
        StiParetoArea = 313,
        StiBoxAndWhiskerArea = 314,
        StiSteppedLineArea = 315,
        StiStackedLineArea = 316,
        StiFullStackedLineArea = 317,
        StiSplineArea = 318,
        StiStackedSplineArea = 319,
        StiFullStackedSplineArea = 320,
        StiAreaArea = 321,
        StiSteppedAreaArea = 322,
        StiStackedAreaArea = 323,
        StiFullStackedAreaArea = 324,
        StiSplineAreaArea = 325,
        StiStackedSplineAreaArea = 326,
        StiFullStackedSplineAreaArea = 327,
        StiGanttArea = 328,
        StiScatterArea = 329,
        StiBubbleArea = 330,
        StiRangeArea = 331,
        StiSteppedRangeArea = 332,
        StiRangeBarArea = 333,
        StiSplineRangeArea = 334,
        StiCandlestickArea = 335,
        StiStockArea = 336,
        StiInsideEndPieLabels = 337,
        StiTrendLineNone = 338,
        StiTrendLineLinear = 339,
        StiTrendLineExponential = 340,
        StiTrendLineLogarithmic = 341,
        StiDB2Database = 342,
        StiDotConnectUniversalDatabase = 343,
        StiFirebirdDatabase = 344,
        StiInformixDatabase = 345,
        StiMongoDbDatabase = 346,
        StiAzureTableStorageDatabase = 347,
        StiMySqlDatabase = 348,
        StiMSAccessDatabase = 349,
        StiOdbcDatabase = 350,
        StiOleDbDatabase = 351,
        StiOracleDatabase = 352,
        StiPostgreSQLDatabase = 353,
        StiSQLiteDatabase = 354,
        StiSqlCeDatabase = 355,
        StiSybaseDatabase = 356,
        StiTeradataDatabase = 357,
        StiVistaDBDatabase = 358,
        StiODataDatabase = 359,
        StiDataTableSource = 360,
        StiDataViewSource = 361,
        StiUndefinedDataSource = 362,
        StiCsvSource = 363,
        StiDBaseSource = 364,
        StiBusinessObjectSource = 365,
        StiCrossTabDataSource = 366,
        StiEnumerableSource = 367,
        StiUserSource = 368,
        StiVirtualSource = 369,
        StiDataTransformation = 370,
        StiOracleODPSource = 371,
        StiFirebirdSource = 372,
        StiInformixSource = 373,
        StiMongoDbSource = 374,
        StiAzureTableStorageSource = 375,
        StiAzureBlobStorageSource = 376,
        StiMSAccessSource = 377,
        StiMySqlSource = 378,
        StiDataWorldSource = 379,
        StiQuickBooksSource = 380,
        StiOdbcSource = 381,
        StiOleDbSource = 382,
        StiOracleSource = 383,
        StiPostgreSQLSource = 384,
        StiSqlCeSource = 385,
        StiSQLiteSource = 386,
        StiSqlSource = 387,
        StiNoSqlSource = 388,
        StiSybaseSource = 389,
        StiTeradataSource = 390,
        StiVistaDBSource = 391,
        StiDB2Source = 392,
        StiDiagonalUpLineShapeType = 393,
        StiHorizontalLineShapeType = 394,
        StiLeftAndRightLineShapeType = 395,
        StiOvalShapeType = 396,
        StiRectangleShapeType = 397,
        StiTopAndBottomLineShapeType = 398,
        StiVerticalLineShapeType = 399,
        StiDivisionShapeType = 400,
        StiFlowchartCardShapeType = 401,
        StiFlowchartDecisionShapeType = 402,
        StiFlowchartManualInputShapeType = 403,
        StiFlowchartSortShapeType = 404,
        StiFrameShapeType = 405,
        StiMinusShapeType = 406,
        StiMultiplyShapeType = 407,
        StiParallelogramShapeType = 408,
        StiPlusShapeType = 409,
        StiRegularPentagonShapeType = 410,
        StiTrapezoidShapeType = 411,
        StiSnipSameSideCornerRectangleShapeType = 412,
        StiSnipDiagonalSideCornerRectangleShapeType = 413,
        StiFlowchartPreparationShapeType = 414,
        StiRadialScale = 415,
        StiLinearScale = 416,
        StiLinearBar = 417,
        StiRadialBar = 418,
        StiNeedle = 419,
        StiRadialMarker = 420,
        StiScaleRangeList = 421,
        StiRadialRange = 422,
        StiStateIndicator = 423,
        StiStateIndicatorFilter = 424,
        StiRadialRangeList = 425,
        StiLinearRangeList = 426,
        StiLinearRange = 427,
        StiLinearTickMarkMajor = 428,
        StiLinearTickMarkMinor = 429,
        StiLinearTickMarkCustomValue = 430,
        StiLinearTickLabelMajor = 431,
        StiLinearTickLabelMinor = 432,
        StiLinearTickLabelCustom = 433,
        StiLinearTickLabelCustomValue = 434,
        StiRadialTickMarkMajor = 435,
        StiRadialTickMarkMinor = 436,
        StiRadialTickMarkCustom = 437,
        StiRadialTickMarkCustomValue = 438,
        StiRadialTickLabelMajor = 439,
        StiRadialTickLabelMinor = 440,
        StiRadialTickLabelCustom = 441,
        StiRadialTickLabelCustomValue = 442,
        StiLinearMarker = 443,
        StiLinearTickMarkCustom = 444,
        StiLinearIndicatorRangeInfo = 445,
        StiRadialIndicatorRangeInfo = 446,
        StiBlueDashboardControlStyle = 447,
        StiBlueDashboardIndicatorStyle = 448,
        StiBlueDashboardPageStyle = 449,
        StiBlueDashboardPivotStyle = 450,
        StiBlueDashboardProgressStyle = 451,
        StiBlueDashboardTableStyle = 452,
        StiOrangeDashboardControlStyle = 453,
        StiOrangeDashboardIndicatorStyle = 454,
        StiOrangeDashboardPageStyle = 455,
        StiOrangeDashboardPivotStyle = 456,
        StiOrangeDashboardProgressStyle = 457,
        StiOrangeDashboardTableStyle = 458,
        StiGreenDashboardControlStyle = 459,
        StiGreenDashboardIndicatorStyle = 460,
        StiGreenDashboardPageStyle = 461,
        StiGreenDashboardProgressStyle = 462,
        StiGreenDashboardPivotStyle = 463,
        StiGreenDashboardTableStyle = 464,
        StiTurquoiseDashboardControlStyle = 465,
        StiTurquoiseDashboardIndicatorStyle = 466,
        StiTurquoiseDashboardPageStyle = 467,
        StiTurquoiseDashboardProgressStyle = 468,
        StiTurquoiseDashboardPivotStyle = 469,
        StiTurquoiseDashboardTableStyle = 470,
        StiSlateGrayDashboardControlStyle = 471,
        StiSlateGrayDashboardIndicatorStyle = 472,
        StiSlateGrayDashboardPageStyle = 473,
        StiSlateGrayDashboardProgressStyle = 474,
        StiSlateGrayDashboardPivotStyle = 475,
        StiSlateGrayDashboardTableStyle = 476,
        StiDarkBlueDashboardControlStyle = 477,
        StiDarkBlueDashboardIndicatorStyle = 478,
        StiDarkBlueDashboardPageStyle = 479,
        StiDarkBlueDashboardProgressStyle = 480,
        StiDarkBlueDashboardPivotStyle = 481,
        StiDarkBlueDashboardTableStyle = 482,
        StiYellowDashboardPageStyle = 483,
        StiDarkGrayDashboardControlStyle = 484,
        StiDarkGrayDashboardIndicatorStyle = 485,
        StiDarkGrayDashboardPageStyle = 486,
        StiDarkGrayDashboardProgressStyle = 487,
        StiDarkGrayDashboardPivotStyle = 488,
        StiDarkGrayDashboardTableStyle = 489,
        StiDarkTurquoiseDashboardControlStyle = 490,
        StiDarkTurquoiseDashboardIndicatorStyle = 491,
        StiDarkTurquoiseDashboardPageStyle = 492,
        StiDarkTurquoiseDashboardProgressStyle = 493,
        StiDarkTurquoiseDashboardPivotStyle = 494,
        StiDarkTurquoiseDashboardTableStyle = 495,
        StiSilverDashboardControlStyle = 496,
        StiSilverDashboardIndicatorStyle = 497,
        StiSilverDashboardPageStyle = 498,
        StiSilverDashboardPivotStyle = 499,
        StiSilverDashboardProgressStyle = 500,
        StiSilverDashboardTableStyle = 501,
        StiAliceBlueDashboardControlStyle = 502,
        StiAliceBlueDashboardIndicatorStyle = 503,
        StiAliceBlueDashboardPageStyle = 504,
        StiAliceBlueDashboardPivotStyle = 505,
        StiAliceBlueDashboardProgressStyle = 506,
        StiAliceBlueDashboardTableStyle = 507,
        StiDarkGreenDashboardControlStyle = 508,
        StiDarkGreenDashboardIndicatorStyle = 509,
        StiDarkGreenDashboardPageStyle = 510,
        StiDarkGreenDashboardProgressStyle = 511,
        StiDarkGreenDashboardPivotStyle = 512,
        StiDarkGreenDashboardTableStyle = 513,
        StiCustomDashboardControlStyle = 514,
        StiCustomDashboardPivotStyle = 515,
        StiCustomDashboardIndicatorStyle = 516,
        StiCustomDashboardProgressStyle = 517,
        StiCustomDashboardTableStyle = 518,
        StiDataWorldDatabase = 519,
        StiQuickBooksDatabase = 520,
        StiCosmosDbDatabase = 521,
        StiSybaseAdsDatabase = 522,
        StiBigQueryDatabase = 523,
        StiAzureBlobStorageDatabase = 524,
        StiFirebaseDatabase = 525,
        StiGoogleSheetsDatabase = 526,
        StiGisDatabase = 527,
        StiCosmosDbSource = 528,
        StiSybaseAdsSource = 529
    }
    enum StiRenderedWith {
        Unknown = 0,
        Net = 1,
        Wpf = 2,
        Silverlight = 3,
        WinRT = 4,
        Flex = 5,
        Java = 6,
        JS = 7
    }
    enum StiRankOrder {
        Asc = 0,
        Desc = 1
    }
    enum StiXmlType {
        AdoNetXml = 0,
        Xml = 1
    }
    enum StiStyleElements {
        Font = 1,
        Border = 2,
        Brush = 4,
        TextBrush = 8,
        TextOptions = 16,
        HorAlignment = 32,
        VertAlignment = 64,
        All = 127
    }
    enum StiDateRangeKind {
        CurrentMonth = 0,
        CurrentQuarter = 1,
        CurrentWeek = 2,
        CurrentYear = 3,
        NextMonth = 4,
        NextQuarter = 5,
        NextWeek = 6,
        NextYear = 7,
        PreviousMonth = 8,
        PreviousQuarter = 9,
        PreviousWeek = 10,
        PreviousYear = 11,
        FirstQuarter = 12,
        SecondQuarter = 13,
        ThirdQuarter = 14,
        FourthQuarter = 15,
        MonthToDate = 16,
        QuarterToDate = 17,
        WeekToDate = 18,
        YearToDate = 19,
        Today = 20,
        Tomorrow = 21,
        Yesterday = 22,
        Last7Days = 23,
        Last14Days = 24,
        Last30Days = 25
    }
    enum StiDashboardViewerSettings {
        None = 0,
        ShowToolBar = 1,
        ShowRefreshButton = 2,
        ShowOpenButton = 4,
        ShowFullScreenButton = 8,
        ShowMenuButton = 16,
        ShowEditButton = 32,
        ShowReportSnapshots = 64,
        ShowExports = 128,
        All = 255
    }
    enum StiElementMeterAction {
        None = 0,
        Rename = 1,
        Delete = 2,
        ClearAll = 3
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiBusinessObjectsCollection extends CollectionBase<StiBusinessObject> implements IStiJsonReportObject, ICloneable, IComparer<any> {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private directionFactor;
        compare(x: any, y: any): number;
        protected onSet(index: number, oldValue: any, newValue: any): void;
        protected onInsert(index: number, value: any): void;
        remove(source: StiBusinessObject): void;
        _cachedBusinessObjects: Hashtable;
        get cachedBusinessObjects(): Hashtable;
        getByName(name: string): StiBusinessObject;
        setByName(name: string, value: StiBusinessObject): void;
        clone(): any;
        sort(order?: StiSortOrder, sortColumns?: boolean): void;
        connect(): void;
        disconnect(): void;
        dictionary: StiDictionary;
        parentBusinessObject: StiBusinessObject;
        constructor(dictionary: StiDictionary, parentBusinessObject: StiBusinessObject);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IAsIs = Stimulsoft.System.IAsIs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBusinessObjectsCollection = Stimulsoft.Report.Dictionary.StiBusinessObjectsCollection;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IEnumerator = Stimulsoft.System.Collections.IEnumerator;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiBusinessObject implements ICloneable, IStiStateSaveRestore, IStiEnumerator, IStiInherited, IStiJsonReportObject, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _states;
        protected get states(): StiStatesManager;
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        clearAllStates(): void;
        private _inherited;
        get inherited(): boolean;
        set inherited(value: boolean);
        protected positionValue: number;
        get position(): number;
        set position(value: number);
        countFiltered: number;
        get count(): number;
        protected isBofValue: boolean;
        get isBof(): boolean;
        set isBof(value: boolean);
        protected isEofValue: boolean;
        get isEof(): boolean;
        set isEof(value: boolean);
        private _isEmpty;
        get isEmpty(): boolean;
        private enumeratorReset;
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        clone(): StiBusinessObject;
        currentObject: any;
        get current(): any;
        private get report();
        private _businessObjects;
        get businessObjects(): StiBusinessObjectsCollection;
        set businessObjects(value: StiBusinessObjectsCollection);
        private _columns;
        get columns(): StiDataColumnsCollection;
        set columns(value: StiDataColumnsCollection);
        private _guid;
        get guid(): string;
        set guid(value: string);
        private _category;
        get category(): string;
        set category(value: string);
        private _name;
        get name(): string;
        set name(value: string);
        private _alias;
        get alias(): string;
        set alias(value: string);
        private _businessObjectValue;
        get businessObjectValue(): any;
        set businessObjectValue(value: any);
        private _dictionary;
        get dictionary(): StiDictionary;
        set dictionary(value: StiDictionary);
        private _parentBusinessObject;
        get parentBusinessObject(): StiBusinessObject;
        set parentBusinessObject(value: StiBusinessObject);
        private _ownerBand;
        get ownerBand(): StiDataBand;
        set ownerBand(value: StiDataBand);
        private _key;
        get key(): string;
        set key(value: string);
        private static _fieldsIgnoreList;
        static get fieldsIgnoreList(): Hashtable;
        static set fieldsIgnoreList(value: Hashtable);
        getLevel(): number;
        private checkEnumerator;
        setPrevValue(): void;
        setNextValue(): void;
        restoreCurrentValue(): void;
        getTopParentBusinessObject(): StiBusinessObject;
        createEnumerator(): void;
        private sortData;
        private sortDataByGroups;
        filterData(): void;
        private destroyEnumerator;
        setDetails(): void;
        private updateChilds;
        private getBusinessObjectDataFromParent;
        getColumnIndex(columnName: string): number;
        getBusinessObjectData(isColumnsRetrieve?: boolean): any;
        getFullName(): string;
        getCorrectFullName(): string;
        toString(): string;
        connect(): void;
        disconnect(): void;
        private isEnumeratorCreated;
        private specPrevValue;
        private specNextValue;
        private specNextValueRead;
        private specMoveNextResult;
        private specStoredCurrentValue;
        enumerator: IEnumerator;
        protected rowToLevel: Hashtable;
        specSetPrevValue: boolean;
        specSetNextValue: boolean;
        specFilterData: boolean;
        specSortGroup: boolean;
        specTotalsCalculation: boolean;
        previousResetException: boolean;
        getByName(name: string): any;
        constructor(category?: string, name?: string, alias?: string, guid?: string, key?: string);
    }
}
declare namespace Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiValueEventHandler: EventHandler;
    class StiValueEventArgs extends EventArgs {
        value: any;
        displayValue: string;
        constructor(value?: any);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    import StiBusinessObjectsCollection = Stimulsoft.Report.Dictionary.StiBusinessObjectsCollection;
    class StiBusinessObjectHelper {
        static getElementType(arrayType: Type): Type;
        private static getElement;
        static getAlias(valueProp: string): string;
        static isAllowUseProperty(valueProp: string): boolean;
        private static getType;
        private static getDataColumn;
        private static getDataColumn2;
        private static getColumnsFromObject;
        private static getColumnsFromClass;
        static getColumnsFromData(data: any, includeChildDataSources?: boolean): StiDataColumnsCollection;
        static isDataColumn(type: Type): boolean;
        static getBusinessObjectFromGuid(report: StiReport, guid: string): StiBusinessObject;
        static getBusinessObjectsFromReport(data: StiBusinessObjectsCollection | StiReport): StiBusinessObject[];
    }
}
declare namespace Stimulsoft.Report.Events {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiEvent implements ICloneable, IStiJsonReportObject {
        private static ImplementsStiEvent;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        protected get propertyName(): string;
        private _script;
        get script(): string;
        set script(value: string);
        private parent;
        set(parent: Stimulsoft.Report.Components.StiComponent, value: string): void;
        constructor(script?: string | Stimulsoft.Report.Components.StiComponent);
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiGetCollapsedEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiEndRenderEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiRenderingEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiBeginRenderEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Expressions {
    import IAsIs = Stimulsoft.System.IAsIs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiExpression implements ICloneable, IStiJsonReportObject, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private val;
        get value(): string;
        set value(value: string);
        protected getValueProp(): string;
        protected setValueProp(value: string): void;
        parentComponent: any;
        fullConvert: boolean;
        get applyFormat(): boolean;
        genAddEvent: boolean;
        toString(): string;
        clone(): any;
        constructor(value?: string);
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiConditionsCollection extends CollectionBase<StiBaseCondition> implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private isBorderSides;
        private convertIconSetItemFromString;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiConditionsCollection;
        addRange(conditions: StiConditionsCollection, addOnlyNotEqual?: boolean): void;
    }
}
declare namespace Stimulsoft.Report {
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiBase extends StiService implements IStiName {
        memberwiseClone(baseClone?: boolean): StiBase;
        private _name;
        get name(): string;
        set name(value: string);
        getName(): string;
        setName(value: string): void;
        implements(): any[];
        get localizedName(): string;
        get localizedCategory(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiGetToolTipEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiGetHyperlinkEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiGetTagEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiGetBookmarkEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiBeforePrintEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiAfterPrintEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiGetDrillDownReportEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiClickEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiDoubleClickEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiMouseEnterEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiMouseLeaveEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiGetPointerEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiGetPointerEvent = Stimulsoft.Report.Events.StiGetPointerEvent;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import StiPaintEventArgs = Stimulsoft.Report.Events.StiPaintEventArgs;
    import StiGetDrillDownReportEventArgs = Stimulsoft.Report.Events.StiGetDrillDownReportEventArgs;
    import StiGetToolTipEvent = Stimulsoft.Report.Events.StiGetToolTipEvent;
    import StiGetHyperlinkEvent = Stimulsoft.Report.Events.StiGetHyperlinkEvent;
    import StiGetTagEvent = Stimulsoft.Report.Events.StiGetTagEvent;
    import StiGetBookmarkEvent = Stimulsoft.Report.Events.StiGetBookmarkEvent;
    import StiBeforePrintEvent = Stimulsoft.Report.Events.StiBeforePrintEvent;
    import StiAfterPrintEvent = Stimulsoft.Report.Events.StiAfterPrintEvent;
    import StiGetDrillDownReportEvent = Stimulsoft.Report.Events.StiGetDrillDownReportEvent;
    import StiClickEvent = Stimulsoft.Report.Events.StiClickEvent;
    import StiDoubleClickEvent = Stimulsoft.Report.Events.StiDoubleClickEvent;
    import StiMouseEnterEvent = Stimulsoft.Report.Events.StiMouseEnterEvent;
    import StiMouseLeaveEvent = Stimulsoft.Report.Events.StiMouseLeaveEvent;
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBase = Stimulsoft.Report.StiBase;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiConditionsCollection = Stimulsoft.Report.Components.StiConditionsCollection;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import IStiReportComponent = Stimulsoft.Base.IStiReportComponent;
    import IStiApp = Stimulsoft.Base.IStiApp;
    import IStiReport = Stimulsoft.Base.IStiReport;
    import IStiAppExpressionCollection = Stimulsoft.Base.IStiAppExpressionCollection;
    import StiAppExpressionCollection = Stimulsoft.Base.StiAppExpressionCollection;
    class StiComponent extends StiBase implements IStiComponentGuid, IStiCanGrow, IStiCanShrink, IStiUnitConvert, IStiShift, IStiGrowToHeight, IStiAnchor, IStiConditions, IStiPrintOn, IStiInherited, IStiStateSaveRestore, IStiJsonReportObject, IStiReportComponent, IStiComponent, IStiGetFonts, IStiAppExpressionCollection {
        private static ImplementsStiComponent;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        protected loadRectangleDFromXml(text: string): RectangleD;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        private _infographicsDisplayRectangle;
        get infographicsDisplayRectangle(): RectangleD;
        set infographicsDisplayRectangle(value: RectangleD);
        private _isSelected;
        get isSelected(): boolean;
        set isSelected(value: boolean);
        select(): void;
        invert(): void;
        reset(): void;
        getApp(): IStiApp;
        getKey(): string;
        setKey(key: string): void;
        getReport(): IStiReport;
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        private _states;
        get states(): StiStatesManager;
        getStates(): StiStatesManager;
        clearAllStates(): void;
        get shift(): boolean;
        set shift(value: boolean);
        getShift(): boolean;
        private _shiftMode;
        get shiftMode(): StiShiftMode;
        set shiftMode(value: StiShiftMode);
        private _guid;
        get guid(): string;
        set guid(value: string);
        newGuid(): void;
        private _printOn;
        get printOn(): StiPrintOnType;
        set printOn(value: StiPrintOnType);
        clone(cloneProperties?: boolean, cloneComponents?: boolean, base?: boolean): any;
        memberwiseClone(base?: boolean): StiComponent;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        private _canShrink;
        get canShrink(): boolean;
        set canShrink(value: boolean);
        getCanShrink(): boolean;
        private _canGrow;
        get canGrow(): boolean;
        set canGrow(value: boolean);
        getCanGrow(): boolean;
        setCanGrow(value: boolean): void;
        private _growToHeight;
        get growToHeight(): boolean;
        set growToHeight(value: boolean);
        getGrowToHeight(): boolean;
        private _anchor;
        get anchor(): StiAnchorMode;
        set anchor(value: StiAnchorMode);
        private _conditions;
        get conditions(): StiConditionsCollection;
        set conditions(value: StiConditionsCollection);
        getConditions(): StiConditionsCollection;
        setConditions(value: StiConditionsCollection): void;
        private static propertyInherited;
        get inherited(): boolean;
        set inherited(value: boolean);
        getActualSize(): SizeD;
        get report(): StiReport;
        set report(value: StiReport);
        private _interaction;
        get interaction(): StiInteraction;
        set interaction(value: StiInteraction);
        getFonts(): Font[];
        expressions: StiAppExpressionCollection;
        private shouldSerializeExpressions;
        doPointer(createNewGuid?: boolean): void;
        private doGetPointer;
        doBookmark(): boolean;
        private doGetBookmark;
        get printable(): boolean;
        set printable(value: boolean);
        private _isRendered;
        get isRendered(): boolean;
        set isRendered(value: boolean);
        private static propertyRenderedCount;
        get renderedCount(): number;
        set renderedCount(value: number);
        allowPrintOn(): boolean;
        get isEnabled(): boolean;
        prepare(): void;
        unPrepare(): void;
        setReportVariables(): void;
        internalRenderAsync(): Promise<StiComponent>;
        internalRender(): StiComponent;
        renderAsync(): Promise<StiComponent>;
        render(): StiComponent;
        paint(g: Stimulsoft.System.Drawing.Graphics): void;
        get dockStyle(): StiDockStyle;
        set dockStyle(value: StiDockStyle);
        getDockStyle(): StiDockStyle;
        get isAutomaticDock(): boolean;
        getDockRegion(parent: StiComponent, useColumns?: boolean): RectangleD;
        dockToContainer(): void;
        dockToContainer2(rect: RectangleD): RectangleD;
        private checkWidth;
        private checkHeight;
        private disableCheckWidthHeight;
        private static propertyMinSize;
        get minSize(): SizeD;
        set minSize(value: SizeD);
        getMinSize(): SizeD;
        setMinSize(value: SizeD): void;
        private static propertyMaxSize;
        get maxSize(): SizeD;
        set maxSize(value: SizeD);
        getMaxSize(): SizeD;
        setMaxSize(value: SizeD): void;
        private _left;
        get left(): number;
        set left(value: number);
        getLeft(): number;
        setLeft(value: number): void;
        private _top;
        get top(): number;
        set top(value: number);
        getTop(): number;
        setTop(value: number): void;
        private _width;
        get width(): number;
        set width(value: number);
        getWidth(): number;
        setWidth(value: number): void;
        private _height;
        get height(): number;
        set height(value: number);
        getHeight(): number;
        setHeight(value: number): void;
        get right(): number;
        get bottom(): number;
        getBottom(): number;
        get clientRectangle(): RectangleD;
        set clientRectangle(value: RectangleD);
        protected setClientRectangle(value: RectangleD): void;
        get displayRectangle(): RectangleD;
        set displayRectangle(value: RectangleD);
        getDisplayRectangle(): RectangleD;
        setDisplayRectangle(value: RectangleD): void;
        setDirectDisplayRectangle(rect: RectangleD): void;
        get selectRectangle(): RectangleD;
        set selectRectangle(value: RectangleD);
        defaultClientRectangle: RectangleD;
        private _parentBookmark;
        get parentBookmark(): StiBookmark;
        set parentBookmark(value: StiBookmark);
        private _currentBookmark;
        get currentBookmark(): StiBookmark;
        set currentBookmark(value: StiBookmark);
        private _parentPointer;
        get parentPointer(): StiBookmark;
        set parentPointer(value: StiBookmark);
        private _currentPointer;
        get currentPointer(): StiBookmark;
        set currentPointer(value: StiBookmark);
        invokeEvents(): void;
        get isGetToolTipHandlerEmpty(): boolean;
        private static eventGetToolTip;
        protected onGetToolTip(): void;
        invokeGetToolTip(sender: any, e: StiValueEventArgs): void;
        get getToolTipEvent(): StiGetToolTipEvent;
        set getToolTipEvent(value: StiGetToolTipEvent);
        get isGetHyperlinkHandlerEmpty(): boolean;
        private static eventGetHyperlink;
        protected onGetHyperlink(e: StiValueEventArgs): void;
        invokeGetHyperlink(sender: any, e: StiValueEventArgs): void;
        get getHyperlinkEvent(): StiGetHyperlinkEvent;
        set getHyperlinkEvent(value: StiGetHyperlinkEvent);
        get isGetTagHandlerEmpty(): boolean;
        private static eventGetTag;
        protected onGetTag(e: StiValueEventArgs): void;
        invokeGetTag(sender: any, e: StiValueEventArgs): void;
        get getTagEvent(): StiGetTagEvent;
        set getTagEvent(value: StiGetTagEvent);
        get isGetPointerHandlerEmpty(): boolean;
        private static eventGetPointer;
        protected onGetPointer(e: StiValueEventArgs): void;
        invokeGetPointer(sender: any, e: StiValueEventArgs): void;
        get getPointerEvent(): StiGetPointerEvent;
        set getPointerEvent(value: StiGetPointerEvent);
        get isGetBookmarkHandlerEmpty(): boolean;
        private static eventGetBookmark;
        protected onGetBookmark(): void;
        invokeGetBookmark(sender: any, e: EventArgs): void;
        get getBookmarkEvent(): StiGetBookmarkEvent;
        set getBookmarkEvent(value: StiGetBookmarkEvent);
        private static eventBeforePrint;
        protected onBeforePrint(e: EventArgs): void;
        invokeBeforePrint(sender: StiComponent, e: EventArgs): void;
        applyConditions(sender: StiComponent, conditions: any[], e: EventArgs): void;
        get beforePrintEvent(): StiBeforePrintEvent;
        set beforePrintEvent(value: StiBeforePrintEvent);
        private static eventAfterPrint;
        protected onAfterPrint(e: EventArgs): void;
        invokeAfterPrint(sender: any, e: EventArgs): void;
        get afterPrintEvent(): StiAfterPrintEvent;
        set afterPrintEvent(value: StiAfterPrintEvent);
        private static eventGetDrillDownReport;
        protected onGetDrillDownReport(e: StiGetDrillDownReportEventArgs): void;
        invokeGetDrillDownReport(sender: any, e: StiGetDrillDownReportEventArgs): void;
        get getDrillDownReportEvent(): StiGetDrillDownReportEvent;
        set getDrillDownReportEvent(value: StiGetDrillDownReportEvent);
        get isClickHandlerEmpty(): boolean;
        private static eventClick;
        protected onClick(e: EventArgs): void;
        invokeClick(sender: any, e: EventArgs): void;
        get clickEvent(): StiClickEvent;
        set clickEvent(value: StiClickEvent);
        get isDoubleClickHandlerEmpty(): boolean;
        private static eventDoubleClick;
        protected onDoubleClick(e: EventArgs): void;
        invokeDoubleClick(sender: any, e: EventArgs): void;
        get doubleClickEvent(): StiDoubleClickEvent;
        set doubleClickEvent(value: StiDoubleClickEvent);
        get isMouseEnterHandlerEmpty(): boolean;
        private static eventMouseEnter;
        protected onMouseEnter(e: EventArgs): void;
        invokeMouseEnter(sender: any, e: EventArgs): void;
        get mouseEnterEvent(): StiMouseEnterEvent;
        set mouseEnterEvent(value: StiMouseEnterEvent);
        get isMouseLeaveHandlerEmpty(): boolean;
        private static eventMouseLeave;
        protected onMouseLeave(e: EventArgs): void;
        invokeMouseLeave(sender: any, e: EventArgs): void;
        get mouseLeaveEvent(): StiMouseLeaveEvent;
        set mouseLeaveEvent(value: StiMouseLeaveEvent);
        private static eventPainting;
        protected onPainting(e: StiPaintEventArgs): void;
        invokePainting(sender: StiComponent, e: StiPaintEventArgs): void;
        private static eventPainted;
        protected onPainted(e: StiPaintEventArgs): void;
        invokePainted(sender: StiComponent, e: StiPaintEventArgs): void;
        pointerValue: any;
        get pointer(): string;
        set pointer(value: string);
        get bookmarkValue(): any;
        set bookmarkValue(value: any);
        get bookmark(): string;
        set bookmark(value: string);
        get toolTipValue(): any;
        set toolTipValue(value: any);
        get toolTip(): string;
        set toolTip(value: string);
        get hyperlinkValue(): any;
        set hyperlinkValue(value: any);
        get hyperlink(): string;
        set hyperlink(value: string);
        get tagValue(): any;
        set tagValue(value: any);
        get tag(): string;
        set tag(value: string);
        private _alias;
        get alias(): string;
        set alias(value: string);
        private _events;
        protected get events(): Hashtable;
        protected static propertyRestrictions: string;
        get restrictions(): StiRestrictions;
        set restrictions(value: StiRestrictions);
        getRestrictions(): StiRestrictions;
        setRestrictions(value: StiRestrictions): void;
        get ignoreNamingRule(): boolean;
        set ignoreNamingRule(value: boolean);
        setName(value: string): void;
        protected static propertyPlaceOnToolbox: string;
        get placeOnToolbox(): boolean;
        set placeOnToolbox(value: boolean);
        get toolboxPosition(): number;
        get isPrinting(): boolean;
        get isExporting(): boolean;
        get isDesigning(): boolean;
        allowDelete(): boolean;
        get priority(): number;
        get componentType(): StiComponentType;
        protected static propertyDockable: string;
        get dockable(): boolean;
        set dockable(value: boolean);
        get highlightState(): StiHighlightState;
        set highlightState(value: StiHighlightState);
        private _componentPlacement;
        get componentPlacement(): string;
        set componentPlacement(value: string);
        private _drillDownParameters;
        get drillDownParameters(): any[];
        set drillDownParameters(value: any[]);
        protected static propertyComponentStyle: string;
        get componentStyle(): string;
        set componentStyle(value: string);
        getComponentStyle(): string;
        setComponentStyle(value: string): void;
        protected static propertyLocked: string;
        get locked(): boolean;
        set locked(value: boolean);
        protected static propertyLinked: string;
        get linked(): boolean;
        set linked(value: boolean);
        getLinked(): boolean;
        setLinked(value: boolean): void;
        get enabled(): boolean;
        set enabled(value: boolean);
        getEnabled(): boolean;
        setEnabled(value: boolean): void;
        private static propertyUseParentStyles;
        get useParentStyles(): boolean;
        set useParentStyles(value: boolean);
        getUseParentStyles(): boolean;
        setUseParentStyles(value: boolean): void;
        private _page;
        get page(): StiPage;
        set page(value: StiPage);
        protected getPage(): StiPage;
        protected setPage(value: StiPage): void;
        private _parent;
        get parent(): StiContainer;
        set parent(value: StiContainer);
        isExportAsImage(format: StiExportFormat): boolean;
        private lockOnResize;
        private invokeOnResizeComponent;
        onResizeComponent(oldSize: SizeD, newSize: SizeD): void;
        clearContents(): void;
        toString(): string;
        get isCross(): boolean;
        canContainIn(component: StiComponent): boolean;
        componentToPage(value: PointD | RectangleD): any;
        pageToComponent(value: PointD | RectangleD): any;
        static isParentSelect(component: StiComponent): boolean;
        static doOffsetRect(component: StiComponent, rect: RectangleD, offsetRect: RectangleD): RectangleD;
        getPaintRectangle(convertToHInches?: boolean, convertByZoom?: boolean, docking?: boolean): RectangleD;
        setPaintRectangle(rect: RectangleD): void;
        getDisplayRectangle2(): RectangleD;
        getDataBand(): StiDataBand;
        getGroupHeaderBand(): StiGroupHeaderBand;
        getContainer(): StiContainer;
        checkForParentComponent(comp: StiComponent): boolean;
        getComponentStyle2(): StiBaseStyle;
        private bits;
        constructor(rect?: RectangleD, isSuper?: boolean);
        protected construct(rect?: RectangleD): void;
    }
}
declare namespace Stimulsoft.Report.Components {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Font = Stimulsoft.System.Drawing.Font;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    class StiComponentDivider {
        static breakText(g: Graphics, rect: RectangleD, REFtext: any, font: Font, textOptions: StiTextOptions, textQuality: StiTextQuality, allowHtmlTags: boolean, textComp: StiText): string;
        static breakContainer(maxAllowedHeight: number, renderedContainer: StiContainer): StiContainer;
        static breakContainerV2(maxAllowedHeight: number, renderedContainer: StiContainer): StiContainer;
        private static getDivideLine;
        private static searchDivideLine;
    }
}
declare namespace Stimulsoft.Report.Components {
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiContainer extends StiComponent implements IStiBorder, IStiBrush, IStiBreakable, IStiIgnoryStyle, IStiJsonReportObject, IStiGetFonts {
        private static ImplementsStiContainer;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        parseContainerFromXml(xmlNode: XmlNode): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        protected static propertyCanBreak: string;
        get canBreak(): boolean;
        set canBreak(value: boolean);
        break(dividedComponent: StiComponent, devideFactor: number, REFdivideLine: any): boolean;
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean, convertComponents?: boolean): void;
        private _border;
        get border(): StiBorder;
        set border(value: StiBorder);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        getActualSize(isFirstPass?: boolean, REFneedSecondPass?: any): SizeD;
        getFonts(): Font[];
        private _containerInfo;
        get containerInfo(): StiContainerInfo;
        get priority(): number;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get componentType(): StiComponentType;
        parentComponentIsBand: boolean;
        parentComponentIsCrossBand: boolean;
        private _collapsedValue;
        get collapsedValue(): any;
        set collapsedValue(value: any);
        private _collapsingIndex;
        get collapsingIndex(): number;
        set collapsingIndex(value: number);
        private _collapsingTreePath;
        get collapsingTreePath(): string;
        set collapsingTreePath(value: string);
        get hasSelected(): boolean;
        defaultClientRectangle: Rectangle;
        private _components;
        get components(): StiComponentsCollection;
        set components(value: StiComponentsCollection);
        protected static propertyBlocked: string;
        get blocked(): boolean;
        set blocked(value: boolean);
        setParentStylesToChilds(style?: Stimulsoft.Report.Styles.StiBaseStyle): void;
        offsetLocation(offsetX: number, offsetY: number): void;
        changePosition(delta: Rectangle): void;
        normalize(): void;
        sortByPriority(): void;
        bringToFront(): void;
        sendToBack(): void;
        moveForward(): void;
        moveBackward(): void;
        alignTo(aligning: StiAligning): void;
        private getContainerInRectPrivate;
        getContainerInRect(rect: Rectangle, component: StiComponent): StiContainer;
        private getSizesTable;
        private getNodeSize;
        private getContainerInRect2Private;
        getContainerInRect2(rect: Rectangle, component: StiComponent, hash: Hashtable): StiContainer;
        private getIncorrect2;
        correct2(onlySelect: boolean): void;
        getIncorrect(onlySelect?: boolean): StiComponentsCollection;
        correct(onlySelect?: boolean): void;
        checkLargeHeight(needFullCalculation?: boolean): void;
        resetSelection(): void;
        getSelectedComponents(): StiComponentsCollection;
        getSelectedComponents2(REFcomps: any): void;
        getSelectedRectangle(): Rectangle;
        makeHorizontalSpacingEqual(): void;
        makeVerticalSpacingEqual(): void;
        makeSameSize(size: SizeD): void;
        makeSameWidth(width: number): void;
        makeSameHeight(height: number): void;
        setCenterHorizontally(): void;
        setCenterVertically(): void;
        selectAll(): void;
        containerToPage(value: Point | Rectangle): any;
        private containerToPageRectangle;
        private containerToPagePoint;
        pageToContainer(value: Point | Rectangle): any;
        getComponents(): StiComponentsCollection;
        getComponents2(REFcomps: any): void;
        getComponentsList(): StiComponent[];
        moveComponentsToPage(): void;
        constructor(rect?: Rectangle, isSuper?: boolean);
        protected construct(rect?: Rectangle): void;
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBand extends StiContainer implements IStiResetPageNumber, IStiJsonReportObject, IStiCanGrow, IStiConditions {
        private static ImplementsStiBand;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        canContainIn(component: StiComponent): boolean;
        get componentType(): StiComponentType;
        protected getComponentType(): StiComponentType;
        clone(cloneProperties: boolean, cloneComponents: boolean): StiBand;
        private _resetPageNumber;
        get resetPageNumber(): boolean;
        set resetPageNumber(value: boolean);
        private _bandInfo;
        get bandInfo(): StiBandInfo;
        getDockStyle(): StiDockStyle;
        setDockStyle(value: StiDockStyle): void;
        get isAutomaticDock(): boolean;
        get printable(): boolean;
        set printable(value: boolean);
        get minHeight(): number;
        set minHeight(value: number);
        getMinHeight(): number;
        setMinHeight(value: number): void;
        get maxHeight(): number;
        set maxHeight(value: number);
        getMaxHeight(): number;
        setMaxHeight(value: number): void;
        defaultClientRectangle: RectangleD;
        getDisplayRectangle(): RectangleD;
        setDisplayRectangle(value: RectangleD): void;
        setDirectDisplayRectangle(rect: RectangleD): void;
        get selectRectangle(): RectangleD;
        set selectRectangle(value: RectangleD);
        get nestedLevel(): number;
        private _rectangleMoveComponent;
        get rectangleMoveComponent(): RectangleD;
        set rectangleMoveComponent(value: RectangleD);
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        getHeaderText(): string;
        get headerSize(): number;
        get footerSize(): number;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDynamicBand extends StiBand implements IStiPageBreak, IStiBreakable, IStiPrintAtBottom, IStiJsonReportObject {
        private _implementsStiDynamicBand;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _printAtBottom;
        get printAtBottom(): boolean;
        set printAtBottom(value: boolean);
        break(dividedComponent: StiComponent, devideFactor: number, divLine: number): boolean;
        private _newPageBefore;
        get newPageBefore(): boolean;
        set newPageBefore(value: boolean);
        private _newPageAfter;
        get newPageAfter(): boolean;
        set newPageAfter(value: boolean);
        private _newColumnBefore;
        get newColumnBefore(): boolean;
        set newColumnBefore(value: boolean);
        private _newColumnAfter;
        get newColumnAfter(): boolean;
        set newColumnAfter(value: boolean);
        private _skipFirst;
        get skipFirst(): boolean;
        set skipFirst(value: boolean);
        private _breakIfLessThan;
        get breakIfLessThan(): number;
        set breakIfLessThan(value: number);
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiGetCollapsedEvent = Stimulsoft.Report.Events.StiGetCollapsedEvent;
    import StiEndRenderEvent = Stimulsoft.Report.Events.StiEndRenderEvent;
    import StiRenderingEvent = Stimulsoft.Report.Events.StiRenderingEvent;
    import StiBeginRenderEvent = Stimulsoft.Report.Events.StiBeginRenderEvent;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDataBand extends StiDynamicBand implements IStiDataSource, Stimulsoft.Report.Dictionary.IStiEnumerator, IStiMasterComponent, IStiDataRelation, IStiOddEvenStyles, IStiSort, IStiFilter, IStiPrintOnAllPages, IStiPrintIfDetailEmpty, IStiKeepDetailsTogether, IStiResetPageNumber, IStiRenderMaster, IStiBusinessObject, IStiJsonReportObject {
        private static ImplementsStiDataBand;
        implements(): any[];
        jsonMasterComponentTemp: string;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        static loadXmlSort(xmlNode: XmlNode): string[];
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        private _masterComponent;
        get masterComponent(): StiComponent;
        set masterComponent(value: StiComponent);
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        get keepDetailsTogether(): boolean;
        set keepDetailsTogether(value: boolean);
        private _keepDetails;
        get keepDetails(): StiKeepDetails;
        set keepDetails(value: StiKeepDetails);
        private _sort;
        get sort(): string[];
        set sort(value: string[]);
        clone(cloneProperties: boolean, cloneComponents: boolean): StiBand;
        private _printOnAllPages;
        get printOnAllPages(): boolean;
        set printOnAllPages(value: boolean);
        private _printIfDetailEmpty;
        get printIfDetailEmpty(): boolean;
        set printIfDetailEmpty(value: boolean);
        get isDataSourceEmpty(): boolean;
        get dataSource(): StiDataSource;
        private _dataSourceName;
        get dataSourceName(): string;
        set dataSourceName(value: string);
        get isBusinessObjectEmpty(): boolean;
        get businessObject(): StiBusinessObject;
        private _businessObjectGuid;
        get businessObjectGuid(): string;
        set businessObjectGuid(value: string);
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        isEofValue: boolean;
        get isEof(): boolean;
        set isEof(value: boolean);
        isBofValue: boolean;
        get isBof(): boolean;
        set isBof(value: boolean);
        get isEmpty(): boolean;
        positionValue: number;
        get position(): number;
        set position(value: number);
        get count(): number;
        get dataRelation(): StiDataRelation;
        private _dataRelationName;
        get dataRelationName(): string;
        set dataRelationName(value: string);
        private _filterMode;
        get filterMode(): StiFilterMode;
        set filterMode(value: StiFilterMode);
        private _filterEngine;
        get filterEngine(): StiFilterEngine;
        set filterEngine(value: StiFilterEngine);
        private _filterMethodHandler;
        get filterMethodHandler(): Function;
        set filterMethodHandler(value: Function);
        private _filters;
        get filters(): StiFiltersCollection;
        set filters(value: StiFiltersCollection);
        get filter(): string;
        set filter(value: string);
        private _filterOn;
        get filterOn(): boolean;
        set filterOn(value: boolean);
        static propertyEvenStyle: string;
        get evenStyle(): string;
        set evenStyle(value: string);
        static propertyOddStyle: string;
        get oddStyle(): string;
        set oddStyle(value: string);
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        getHeaderText(): string;
        doBookmark(): boolean;
        doPointer(createNewGuid?: boolean): void;
        invokeGroupRendering(): void;
        private _dataBandInfo;
        get dataBandInfo(): StiDataBandInfo;
        renderAsync(): Promise<StiComponent>;
        render(): StiComponent;
        renderMasterAsync(): Promise<void>;
        renderMaster(): void;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get priority(): number;
        protected getComponentType(): StiComponentType;
        private static eventBeginRender;
        protected onBeginRender(): void;
        invokeBeginRender(): void;
        get beginRenderEvent(): StiBeginRenderEvent;
        set beginRenderEvent(value: StiBeginRenderEvent);
        private static eventRendering;
        protected onRendering(): void;
        invokeRendering(): void;
        get renderingEvent(): StiRenderingEvent;
        set renderingEvent(value: StiRenderingEvent);
        private static eventEndRender;
        protected onEndRender(): void;
        invokeEndRender(): void;
        get endRenderEvent(): StiEndRenderEvent;
        set endRenderEvent(value: StiEndRenderEvent);
        private static eventGetCollapsed;
        protected onGetCollapsed(e: StiValueEventArgs): void;
        invokeGetCollapsed(e: StiValueEventArgs): void;
        get getCollapsedEvent(): StiGetCollapsedEvent;
        set getCollapsedEvent(value: StiGetCollapsedEvent);
        private _collapsed;
        get collapsed(): string;
        set collapsed(value: string);
        private _rightToLeft;
        get rightToLeft(): boolean;
        set rightToLeft(value: boolean);
        getRightToLeft(): boolean;
        setRightToLeft(value: boolean): void;
        getColumnWidth(): number;
        private _columnGaps;
        get columnGaps(): number;
        set columnGaps(value: number);
        private _columnWidth;
        get columnWidth(): number;
        set columnWidth(value: number);
        private _columns;
        get columns(): number;
        set columns(value: number);
        private _minRowsInColumn;
        get minRowsInColumn(): number;
        set minRowsInColumn(value: number);
        private _columnDirection;
        get columnDirection(): StiColumnDirection;
        set columnDirection(value: StiColumnDirection);
        private _lineThrough;
        get lineThrough(): number;
        set lineThrough(value: number);
        private _line;
        get line(): number;
        set line(value: number);
        private _selectedLine;
        get selectedLine(): number;
        set selectedLine(value: number);
        private _resetDataSource;
        get resetDataSource(): boolean;
        set resetDataSource(value: boolean);
        private _calcInvisible;
        get calcInvisible(): boolean;
        set calcInvisible(value: boolean);
        private _countData;
        get countData(): number;
        set countData(value: number);
        private _limitRows;
        get limitRows(): string;
        set limitRows(value: string);
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiFillParametersEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiGetSubReportEventHandler: EventHandler;
    class StiGetSubReportEventArgs extends EventArgs {
        report: StiReport;
        subReportName: string;
        constructor(subReportName: string);
    }
}
declare namespace Stimulsoft.Report.Helpers {
    import StiResource = Stimulsoft.Report.Dictionary.StiResource;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiHyperlinkProcessor {
        static getBytes(report: StiReport, hyperlink: string): number[];
        static getImage(report: StiReport, hyperlink: string): Image;
        static getString(report: StiReport, hyperlink: string): string;
        static getResource(report: StiReport, resourceName: string): StiResource;
        private static getVariable;
        static getServerNameFromHyperlink(hyperlink: string): string;
        static getResourceNameFromHyperlink(hyperlink: string): string;
        static getVariableNameFromHyperlink(hyperlink: string): string;
        static getDataColumnNameFromHyperlink(hyperlink: string): string;
        static getRealDataColumnFromHyperlink(report: StiReport, hyperlink: string): string;
        static getFileNameFromHyperlink(hyperlink: string): string;
        static isServerHyperlink(hyperlink: string): boolean;
        static isResourceHyperlink(hyperlink: string): boolean;
        static isVariableHyperlink(hyperlink: string): boolean;
        static isDataColumnHyperlink(hyperlink: string): boolean;
        static isFileHyperlink(hyperlink: string): boolean;
        static createResourceName(name: string): string;
        static createVariableName(name: string): string;
        static createFileName(path: string): string;
        static hyperlinkToString(hyperlink: string): string;
        static serverIdent: string;
        static resourceIdent: string;
        static variableIdent: string;
        static dataColumnIdent: string;
        static fileIdent: string;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiFillParametersEventArgs = Stimulsoft.Report.Events.StiFillParametersEventArgs;
    import StiFillParametersEvent = Stimulsoft.Report.Events.StiFillParametersEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiSubReport extends StiContainer implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentType(): StiComponentType;
        clone(): StiSubReport;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        get width(): number;
        set width(value: number);
        setClientRectangle(value: RectangleD): void;
        private updateSubReportPageWidth;
        getExternalSubReport(): StiReport;
        protected getSubReportFromUrl(url: string): StiReport;
        protected getSubReportFromFile(url: string): StiReport;
        private static eventFillParameters;
        protected onFillParameters(e: StiFillParametersEventArgs): void;
        invokeFillParameters(sender: StiComponent, e: StiFillParametersEventArgs): void;
        get fillParametersEvent(): StiFillParametersEvent;
        set fillParametersEvent(value: StiFillParametersEvent);
        get useExternalReport(): boolean;
        private _keepSubReportTogether;
        get keepSubReportTogether(): boolean;
        set keepSubReportTogether(value: boolean);
        get subReportPage(): StiPage;
        set subReportPage(value: StiPage);
        private _subReportPageGuid;
        get subReportPageGuid(): string;
        set subReportPageGuid(value: string);
        private _subReportUrl;
        get subReportUrl(): string;
        set subReportUrl(value: string);
        private _parameters;
        get parameters(): StiParametersCollection;
        set parameters(value: StiParametersCollection);
        static getSubReportForPage(page: StiPage): StiSubReport;
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiComponentsCollection extends CollectionBase<StiComponent> implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(): StiComponentsCollection;
        memberwiseClone(): StiComponentsCollection;
        private addCore;
        add(component: StiComponent): void;
        indexOf(param: string | StiComponent | any): number;
        insertRange(index: number, components: StiComponentsCollection): void;
        insert(index: number, component: StiComponent): void;
        remove(component: StiComponent, clearParent?: boolean): void;
        getByName(name: string): StiComponent;
        setByName(name: string, component: StiComponent): void;
        sortByPriority(): void;
        sortByTopPosition(): void;
        sortByBottomPosition(): void;
        sortByLeftPosition(): void;
        sortByRightPosition(): void;
        sortBandsByTopPosition(): void;
        sortBandsByLeftPosition(): void;
        getComponentByName(componentName: string, container: StiContainer): StiComponent;
        getPageByAlias(alias: string): StiPage;
        setParent(parent: StiContainer): void;
        private parent;
        constructor(parent?: StiContainer);
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiComponentsOwnerRenderer: System.Interface<IStiComponentsOwnerRenderer>;
    interface IStiComponentsOwnerRenderer {
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiContainerHelper {
        static notCheckSizeMark: string;
        static checkSize(component: StiComponent): void;
        private static componentPlacedOnBand;
        static checkContainerGrowToHeight(component: StiComponent): void;
    }
}
declare namespace Stimulsoft.Report.Components {
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiEndRenderEvent = Stimulsoft.Report.Events.StiEndRenderEvent;
    import StiRenderingEvent = Stimulsoft.Report.Events.StiRenderingEvent;
    import StiBeginRenderEvent = Stimulsoft.Report.Events.StiBeginRenderEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEmptyBand extends StiBand implements IStiOddEvenStyles, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        getHeaderText(): string;
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get priority(): number;
        get evenStyle(): string;
        set evenStyle(value: string);
        get oddStyle(): string;
        set oddStyle(value: string);
        private static eventBeginRender;
        protected onBeginRender(e: EventArgs): void;
        invokeBeginRender(): void;
        get beginRenderEvent(): StiBeginRenderEvent;
        set beginRenderEvent(value: StiBeginRenderEvent);
        private static eventRendering;
        protected onRendering(e: EventArgs): void;
        invokeRendering(): void;
        get renderingEvent(): StiRenderingEvent;
        set renderingEvent(value: StiRenderingEvent);
        private static eventEndRender;
        protected onEndRender(e: EventArgs): void;
        invokeEndRender(): void;
        get endRenderEvent(): StiEndRenderEvent;
        set endRenderEvent(value: StiEndRenderEvent);
        createNew(): StiComponent;
        private _sizeMode;
        get sizeMode(): StiEmptySizeMode;
        set sizeMode(value: StiEmptySizeMode);
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import Font = Stimulsoft.System.Drawing.Font;
    let IStiFont: System.Interface<IStiFont>;
    let ImplementsIStiFont: any[];
    interface IStiFont {
        font: Font;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiBrush: System.Interface<IStiBrush>;
    interface IStiBrush {
        brush: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    let IStiBorder: System.Interface<IStiBorder>;
    interface IStiBorder {
        border: StiBorder;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import Type = Stimulsoft.System.Type;
    class StiBuilder {
        private static typeToBuilder;
        static getBuilder(componentType: Type): StiBuilder;
        setReportVariables(masterComp: Stimulsoft.Report.Components.StiComponent): void;
        prepare(masterComp: Stimulsoft.Report.Components.StiComponent): void;
        unPrepare(masterComp: Stimulsoft.Report.Components.StiComponent): void;
        internalRenderAsync(masterComp: Stimulsoft.Report.Components.StiComponent): Promise<Stimulsoft.Report.Components.StiComponent>;
        internalRender(masterComp: Stimulsoft.Report.Components.StiComponent): Stimulsoft.Report.Components.StiComponent;
        renderAsync(masterComp: Stimulsoft.Report.Components.StiComponent): Promise<Stimulsoft.Report.Components.StiComponent>;
        render(masterComp: Stimulsoft.Report.Components.StiComponent): Stimulsoft.Report.Components.StiComponent;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiTextBrush: System.Interface<IStiTextBrush>;
    interface IStiTextBrush {
        textBrush: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiComponentHelper {
        static fillComponentPlacement(component: StiComponent): void;
    }
}
declare namespace Stimulsoft.Report.Styles.Conditions {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiStyleConditionElement = Stimulsoft.Report.Styles.Conditions.Elements.StiStyleConditionElement;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiStyleConditionsCollection extends CollectionBase<StiStyleCondition> implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiStyleConditionsCollection;
        add(param: StiStyleCondition | StiStyleConditionElement[] | any): void;
        addRange(conditions: StiStyleCondition[] | StiStyleConditionsCollection | any): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiBaseStyle = Stimulsoft.Report.Styles.IStiBaseStyle;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiChartStyle: System.Interface<IStiChartStyle>;
    interface IStiChartStyle extends IStiBaseStyle, ICloneable, IStiJsonReportObject {
        styleIdent: StiElementStyleIdent;
        core: IStiStyleCoreXF;
        serviceEnabled: boolean;
        allowDashboard: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import IStiComponent = Stimulsoft.Report.Components.IStiComponent;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiFiltersCollection = Stimulsoft.Report.Components.StiFiltersCollection;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import IStiCanGrow = Stimulsoft.Report.Components.IStiCanGrow;
    import IStiCanShrink = Stimulsoft.Report.Components.IStiCanShrink;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiImageRotation = Stimulsoft.Report.Components.StiImageRotation;
    let IStiChart: System.Interface<IStiChart>;
    interface IStiChart extends IStiComponent, IStiName, IStiCanGrow, IStiCanShrink, IStiGetFonts {
        seriesLabelsConditions: IStiChartConditionsCollection;
        series: IStiSeriesCollection;
        area: IStiArea;
        style: IStiChartStyle;
        seriesLabels: IStiSeriesLabels;
        legend: IStiLegend;
        title: IStiChartTitle;
        table: IStiChartTable;
        strips: IStiStripsCollection;
        constantLines: IStiConstantLinesCollection;
        horSpacing: number;
        vertSpacing: number;
        isDesigning: boolean;
        isAnimation: boolean;
        brush: StiBrush;
        core: IStiChartCoreXF;
        allowApplyStyle: boolean;
        masterComponent: IStiComponent;
        jsonMasterComponentTemp: string;
        dataSourceName: string;
        chartInfo: IStiChartInfo;
        processAtEnd: boolean;
        convertToHInches(value: number): number;
        saveState(stateName: string): any;
        restoreState(stateName: string): any;
        customStyleName: string;
        name: string;
        border: StiBorder;
        filters: StiFiltersCollection;
        filterMode: StiFilterMode;
        filterOn: boolean;
        dataSource: StiDataSource;
        dataRelation: StiDataRelation;
        countData: number;
        businessObject: StiBusinessObject;
        canGrow: boolean;
        canShrink: boolean;
        rotation: StiImageRotation;
        editorType: StiChartEditorType;
        page: StiPage;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): any;
    }
}
declare namespace Stimulsoft.Report.Styles {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiStyleConditionsCollection = Stimulsoft.Report.Styles.Conditions.StiStyleConditionsCollection;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiBaseStyle extends StiService implements IStiBaseStyle, ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        equals(obj: any, allowEqualName?: boolean, allowEqualDescription?: boolean): boolean;
        static getStyle(component: StiComponent, styleElements?: StiStyleElements | StiBaseStyle, componentStyle?: StiBaseStyle): StiBaseStyle;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
        getStyleFromComponents(comps: StiComponentsCollection, styleElements: StiStyleElements): void;
        toString(): string;
        private _collectionName;
        get collectionName(): string;
        set collectionName(value: string);
        private _conditions;
        get conditions(): StiStyleConditionsCollection;
        set conditions(value: StiStyleConditionsCollection);
        private _description;
        get description(): string;
        set description(value: string);
        private _name;
        get name(): string;
        set name(value: string);
        get dashboardName(): string;
        report: StiReport;
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
declare namespace Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiGetExcelValueEventHandler: EventHandler;
    class StiGetExcelValueEventArgs extends EventArgs {
        value: string;
        storeToPrinted: boolean;
    }
}
declare namespace Stimulsoft.Report.Components.TextFormats {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiService = Stimulsoft.Base.Services.StiService;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiFormatService extends StiService implements IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static createFromJsonObject(jObject: StiJson): StiFormatService;
        loadFromXml(xmlNode: XmlNode): void;
        static loadFormatFromXml(xmlNode: XmlNode, report?: StiReport): StiFormatService;
        static loadFromJsonObjectInternal(jObject: StiJson): StiFormatService;
        get position(): number;
        get sample(): any;
        get nativeFormatString(): string;
        get isFormatStringFromVariable(): boolean;
        private _stringFormat;
        get stringFormat(): string;
        set stringFormat(value: string);
        format(arg: any): string;
        format2(format: string, arg: any): string;
        createNew(): StiFormatService;
    }
}
declare namespace Stimulsoft.Report.Components.TextFormats {
    class StiCustomFormatService extends StiFormatService {
        get sample(): any;
        createNew(): StiFormatService;
        constructor(stringFormat?: string);
    }
}
declare namespace Stimulsoft.Report.Components.TextFormats {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiTimeFormatService extends StiFormatService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        get sample(): any;
        format(arg: any): string;
        format2(stringFormat: string, arg: any): string;
        createNew(): StiFormatService;
        constructor(stringFormat?: string);
    }
}
declare namespace Stimulsoft.Report.Components.TextFormats {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDateFormatService extends StiFormatService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get sample(): any;
        format(arg: any): string;
        format2(stringFormat: string, arg: any): string;
        private static formatQuarter;
        private _nullDisplay;
        get nullDisplay(): string;
        set nullDisplay(value: string);
        createNew(): StiFormatService;
        constructor(stringFormat?: string, nullDisplay?: string);
    }
}
declare namespace Stimulsoft.Report.Components {
    enum StiTextFormatState {
        None = 0,
        DecimalDigits = 1,
        DecimalSeparator = 2,
        GroupSeparator = 4,
        GroupSize = 8,
        PositivePattern = 16,
        NegativePattern = 32,
        CurrencySymbol = 64,
        PercentageSymbol = 128,
        Abbreviation = 256,
        NegativeInRed = 512
    }
    enum StiIconSet {
        None = 0,
        Full = 1,
        ArrowsColored3 = 2,
        ArrowsColored4 = 3,
        ArrowsColored5 = 4,
        ArrowsGray3 = 5,
        ArrowsGray4 = 6,
        ArrowsGray5 = 7,
        Flags3 = 8,
        Latin4 = 9,
        Quarters5 = 10,
        QuartersGreen5 = 11,
        QuartersRed5 = 12,
        Ratings3 = 13,
        Ratings4 = 14,
        Ratings5 = 15,
        RedToBlack4 = 16,
        Signs3 = 17,
        Squares5 = 18,
        Stars3 = 19,
        Stars5 = 20,
        SymbolsCircled3 = 21,
        SymbolsUncircled3 = 22,
        TrafficLights4 = 23,
        TrafficLightsRimmed3 = 24,
        TrafficLightsUnrimmed3 = 25,
        Triangles3 = 26
    }
    enum StiIcon {
        None = 0,
        ArrowRightDownGray = 1,
        ArrowRightUpGray = 2,
        ArrowDownGray = 3,
        ArrowRightGray = 4,
        ArrowUpGray = 5,
        ArrowUpGreen = 6,
        ArrowDownRed = 7,
        ArrowRightYellow = 8,
        ArrowRightDownYellow = 9,
        ArrowRightUpYellow = 10,
        CheckGreen = 11,
        CircleBlack = 12,
        CircleGreen = 13,
        CircleCheckGreen = 14,
        CircleRed = 15,
        CircleCrossRed = 16,
        CircleYellow = 17,
        CircleExclamationYellow = 18,
        CrossRed = 19,
        ExclamationYellow = 20,
        FlagGreen = 21,
        FlagRed = 22,
        FlagYellow = 23,
        FromRedToBlackGray = 24,
        FromRedToBlackPink = 25,
        FromRedToBlackRed = 26,
        Latin1 = 27,
        Latin2 = 28,
        Latin3 = 29,
        Latin4 = 30,
        LightsGreen = 31,
        LightsRed = 32,
        LightsYellow = 33,
        MinusYellow = 34,
        QuarterFull = 35,
        QuarterFullGreen = 36,
        QuarterFullRed = 37,
        QuarterHalf = 38,
        QuarterHalfGreen = 39,
        QuarterHalfRed = 40,
        QuarterNone = 41,
        QuarterNoneGreen = 42,
        QuarterNoneRed = 43,
        QuarterQuarter = 44,
        QuarterQuarterGreen = 45,
        QuarterQuarterRed = 46,
        QuarterThreeFourth = 47,
        QuarterThreeFourthGreen = 48,
        QuarterThreeFourthRed = 49,
        Rating0 = 50,
        Rating1 = 51,
        Rating2 = 52,
        Rating3 = 53,
        Rating4 = 54,
        RhombRed = 55,
        Square0 = 56,
        Square1 = 57,
        Square2 = 58,
        Square3 = 59,
        Square4 = 60,
        StarFull = 61,
        StarHalf = 62,
        StarNone = 63,
        StarQuarter = 64,
        StarThreeFourth = 65,
        TriangleGreen = 66,
        TriangleRed = 67,
        TriangleYellow = 68
    }
    enum StiIconSetOperation {
        MoreThan = 0,
        MoreThanOrEqual = 1
    }
    enum StiIconSetValueType {
        Value = 0,
        Percent = 1
    }
    enum StiProcessAt {
        None = 0,
        EndOfReport = 1,
        EndOfPage = 2
    }
    enum StiMinimumType {
        Auto = 0,
        Value = 1,
        Percent = 2,
        Minimum = 3
    }
    enum StiMidType {
        Auto = 0,
        Value = 1,
        Percent = 2
    }
    enum StiMaximumType {
        Auto = 0,
        Value = 1,
        Percent = 2,
        Maximum = 3
    }
    enum StiDrillDownMode {
        SinglePage = 0,
        MultiPage = 1
    }
    enum StiConditionBorderSides {
        None = 0,
        All = 15,
        Top = 1,
        Left = 2,
        Right = 4,
        Bottom = 8,
        NotAssigned = 16
    }
    enum StiConditionPermissions {
        None = 0,
        Font = 1,
        FontSize = 2,
        FontStyleBold = 4,
        FontStyleItalic = 8,
        FontStyleUnderline = 16,
        FontStyleStrikeout = 32,
        TextColor = 64,
        BackColor = 128,
        Borders = 256,
        All = 511
    }
    enum StiQuickInfoType {
        None = 0,
        ShowComponentsNames = 1,
        ShowAliases = 2,
        ShowFieldsOnly = 3,
        ShowFields = 4,
        ShowEvents = 5,
        ShowContent = 6
    }
    enum StiAngle {
        Angle0 = 0,
        Angle90 = 90,
        Angle180 = 180,
        Angle270 = 270
    }
    enum StiDockStyle {
        Left = 0,
        Right = 1,
        Top = 2,
        Bottom = 3,
        None = 4,
        Fill = 5
    }
    enum StiFilterCondition {
        EqualTo = 0,
        NotEqualTo = 1,
        GreaterThan = 2,
        GreaterThanOrEqualTo = 3,
        LessThan = 4,
        LessThanOrEqualTo = 5,
        Between = 6,
        NotBetween = 7,
        Containing = 8,
        NotContaining = 9,
        BeginningWith = 10,
        EndingWith = 11,
        IsNull = 12,
        IsNotNull = 13
    }
    enum StiFilterItem {
        Argument = 0,
        Value = 1,
        ValueEnd = 2,
        Expression = 3,
        ValueOpen = 4,
        ValueClose = 5,
        ValueLow = 6,
        ValueHigh = 7
    }
    enum StiFilterDataType {
        String = 0,
        Numeric = 1,
        DateTime = 2,
        Boolean = 3,
        Expression = 4
    }
    enum StiFilterMode {
        And = 0,
        Or = 1
    }
    enum StiFilterEngine {
        ReportEngine = 0,
        SQLQuery = 1
    }
    enum StiKeepDetails {
        None = 0,
        KeepFirstRowTogether = 1,
        KeepFirstDetailTogether = 2,
        KeepDetailsTogether = 3
    }
    enum StiPrintOnType {
        AllPages = 0,
        ExceptFirstPage = 1,
        ExceptLastPage = 2,
        ExceptFirstAndLastPage = 3,
        OnlyFirstPage = 4,
        OnlyLastPage = 8,
        OnlyFirstAndLastPage = 12
    }
    enum StiPrintOnEvenOddPagesType {
        Ignore = 0,
        PrintOnEvenPages = 1,
        PrintOnOddPages = 2
    }
    enum StiShiftMode {
        None = 0,
        IncreasingSize = 1,
        DecreasingSize = 2,
        OnlyInWidthOfComponent = 4
    }
    enum StiAnchorMode {
        Top = 1,
        Bottom = 2,
        Left = 4,
        Right = 8
    }
    enum StiProcessingDuplicatesType {
        None = 0,
        Merge = 1,
        Hide = 2,
        RemoveText = 3,
        BasedOnTagMerge = 4,
        BasedOnTagHide = 5,
        BasedOnTagRemoveText = 6,
        GlobalMerge = 7,
        GlobalHide = 8,
        GlobalRemoveText = 9,
        BasedOnValueRemoveText = 10,
        BasedOnValueAndTagMerge = 11,
        BasedOnValueAndTagHide = 12,
        GlobalBasedOnValueRemoveText = 13,
        GlobalBasedOnValueAndTagMerge = 14,
        GlobalBasedOnValueAndTagHide = 15
    }
    enum StiImageProcessingDuplicatesType {
        None = 0,
        Merge = 1,
        Hide = 2,
        RemoveImage = 3,
        GlobalMerge = 4,
        GlobalHide = 5,
        GlobalRemoveImage = 6
    }
    enum StiCheckStyle {
        Cross = 0,
        Check = 1,
        CrossRectangle = 2,
        CheckRectangle = 3,
        CrossCircle = 4,
        DotCircle = 5,
        DotRectangle = 6,
        NoneCircle = 7,
        NoneRectangle = 8,
        None = 9
    }
    enum StiToolboxCategory {
        Bands = 0,
        Cross = 1,
        Components = 2,
        Shapes = 3,
        Controls = 4,
        Dashboards = 5
    }
    enum StiComponentToolboxPosition {
        Component = 0,
        ReportTitleBand = 1,
        ReportSummaryBand = 2,
        PageHeaderBand = 3,
        PageFooterBand = 4,
        GroupHeaderBand = 5,
        GroupFooterBand = 6,
        HeaderBand = 7,
        FooterBand = 8,
        ColumnHeaderBand = 9,
        ColumnFooterBand = 10,
        DataBand = 11,
        HierarchicalBand = 13,
        ChildBand = 14,
        EmptyBand = 15,
        OverlayBand = 16,
        CrossGroupHeaderBand = 21,
        CrossGroupFooterBand = 22,
        CrossHeaderBand = 23,
        CrossFooterBand = 24,
        CrossDataBand = 25,
        Text = 101,
        TextInCells = 102,
        SystemText = 103,
        ContourText = 104,
        RichText = 105,
        Image = 106,
        BarCode = 107,
        Shape = 108,
        Line = 109,
        Container = 110,
        Panel = 110,
        Clone = 112,
        CheckBox = 113,
        SubReport = 114,
        WinControl = 115,
        ZipCode = 116,
        TableOfContents = 117,
        HorizontalLinePrimitive = 150,
        VerticalLinePrimitive = 151,
        RectanglePrimitive = 152,
        RoundedRectanglePrimitive = 153,
        Chart = 200,
        Table = 201,
        CrossTab = 202,
        Map = 210,
        Sparkline = 225,
        Gauge = 220,
        TableElement = 301,
        ChartElement = 302,
        ComboBoxElement = 400,
        GaugeElement = 303,
        PivotTableElement = 304,
        IndicatorElement = 305,
        ProgressElement = 306,
        RegionMapElement = 307,
        ListBoxElement = 308,
        OnlineMapElement = 309,
        ImageElement = 310,
        TextElement = 311,
        PanelElement = 312,
        ShapeElement = 313,
        TreeViewElement = 314,
        TreeViewBoxElement = 315,
        DatePickerElement = 316,
        UserCode = 1000
    }
    enum StiComponentPriority {
        Component = 0,
        CrossTab = 1500,
        SubReportsV1 = 1500,
        SubReportsV2 = 0,
        Container = 0,
        Panel = 0,
        ReportTitleBandBefore = -400,
        ReportTitleBandAfterV1 = -200,
        ReportTitleBandAfterV2 = 200,
        ReportSummaryBand = 500,
        PageHeaderBandBefore = -200,
        PageHeaderBandAfter = -400,
        PageFooterBandBottom = -300,
        PageFooterBandTop = 1000,
        GroupHeaderBand = 300,
        GroupFooterBand = 300,
        HeaderBand = 300,
        FooterBand = 300,
        ColumnHeaderBand = 300,
        ColumnFooterBand = 300,
        DataBand = 300,
        Table = 300,
        ChildBand = 300,
        EmptyBand = 300,
        TableOfContents = 300,
        OverlayBand = 700,
        Primitive = 1500,
        CrossGroupHeaderBand = 300,
        CrossGroupFooterBand = 300,
        CrossHeaderBand = 300,
        CrossFooterBand = 300,
        CrossDataBand = 300
    }
    enum StiComponentType {
        Simple = 0,
        Master = 1,
        Detail = 2,
        Static = 3
    }
    enum StiRestrictions {
        None = 0,
        AllowMove = 1,
        AllowResize = 2,
        AllowSelect = 4,
        AllowChange = 8,
        AllowDelete = 16,
        All = 31
    }
    enum StiHighlightState {
        Hide = 0,
        Show = 1,
        Active = 2
    }
    enum StiAligning {
        Left = 0,
        Center = 1,
        Right = 2,
        Top = 3,
        Middle = 4,
        Bottom = 5
    }
    enum StiColumnDirection {
        DownThenAcross = 0,
        AcrossThenDown = 1
    }
    enum StiEmptySizeMode {
        IncreaseLastRow = 0,
        DecreaseLastRow = 1,
        AlignFooterToBottom = 2,
        AlignFooterToTop = 3
    }
    enum StiGroupSortDirection {
        Ascending = 0,
        Descending = 1,
        None = 2
    }
    enum StiGroupSummaryType {
        Avg = 0,
        AvgDate = 1,
        AvgTime = 2,
        Count = 3,
        CountDistinct = 4,
        MaxDate = 5,
        MaxTime = 6,
        Max = 7,
        MinDate = 8,
        MinTime = 9,
        Min = 10,
        Median = 11,
        Mode = 12,
        Sum = 13,
        SumTime = 14
    }
    enum StiPageOrientation {
        Portrait = 0,
        Landscape = 1
    }
    enum StiTextQuality {
        Standard = 0,
        Typographic = 1,
        Wysiwyg = 2
    }
    enum StiSystemTextType {
        Totals = 0,
        SystemVariables = 1,
        Expression = 2,
        DataColumn = 3,
        None = 4
    }
    enum StiBrushType {
        Solid = 0,
        Gradient = 1
    }
    enum StiColorScaleType {
        Color2 = 0,
        Color3 = 1
    }
    enum StiDataBarDirection {
        Default = 0,
        LeftToRight = 1,
        RighToLeft = 2
    }
    enum StiInteractionSortDirection {
        Ascending = 0,
        Descending = 1,
        None = 2
    }
    enum StiImageRotation {
        None = 0,
        Rotate90CW = 1,
        Rotate90CCW = 2,
        Rotate180 = 3,
        FlipHorizontal = 4,
        FlipVertical = 5
    }
    enum StiDashboardViewMode {
        Desktop = 0,
        Mobile = 1
    }
    enum StiSparklineType {
        Line = 0,
        Area = 1,
        Column = 2,
        WinLoss = 3
    }
}
declare namespace Stimulsoft.Report.Components.TextFormats {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import NumberFormatInfo = Stimulsoft.System.Globalization.NumberFormatInfo;
    import StiTextFormatState = Stimulsoft.Report.Components.StiTextFormatState;
    class StiNumberFormatService extends StiFormatService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        private bits;
        get nullDisplay(): string;
        set nullDisplay(value: string);
        get negativePattern(): number;
        set negativePattern(value: number);
        get decimalSeparator(): string;
        set decimalSeparator(value: string);
        get decimalDigits(): number;
        set decimalDigits(value: number);
        get groupSeparator(): string;
        set groupSeparator(value: string);
        get groupSize(): number;
        set groupSize(value: number);
        get useGroupSeparator(): boolean;
        set useGroupSeparator(value: boolean);
        get useLocalSetting(): boolean;
        set useLocalSetting(value: boolean);
        private _totalNumberCapacity;
        get totalNumberCapacity(): number;
        set totalNumberCapacity(value: number);
        get sample(): any;
        get nativeFormatString(): string;
        equals(obj: any): boolean;
        get state(): StiTextFormatState;
        set state(value: StiTextFormatState);
        fillLocalSetting(format: NumberFormatInfo): void;
        format(arg: any): string;
        format2(stringFormat: string, arg: any): string;
        formatStr(format: NumberFormatInfo, arg: any): string;
        createNew(): StiFormatService;
        constructor(negativePattern?: number, decimalPlaces?: number, decimalSeparator?: string, decimalDigits?: number, groupSeparator?: string, groupSize?: number, useGroupSeparator?: boolean, useLocalSetting?: boolean, nullDisplay?: string, state?: StiTextFormatState);
    }
}
declare namespace Stimulsoft.Report.Components.TextFormats {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import NumberFormatInfo = Stimulsoft.System.Globalization.NumberFormatInfo;
    class StiCurrencyFormatService extends StiNumberFormatService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _positivePattern;
        get positivePattern(): number;
        set positivePattern(value: number);
        private _symbol;
        get symbol(): string;
        set symbol(value: string);
        get nativeFormatString(): string;
        get sample(): any;
        equals(obj: any): boolean;
        format(arg: any): string;
        format2(stringFormat: string, arg: any): string;
        private formatAsCurrency;
        private getCurrencySymbol;
        private getPositivePattern;
        private getNegativePattern;
        formatStr(format: NumberFormatInfo, arg: any): string;
        createNew(): StiFormatService;
        constructor(positivePattern?: number, negativePattern?: number, decimalPlaces?: number, decimalSeparator?: string, decimalDigits?: number, groupSeparator?: string, groupSize?: number, symbol?: string, useGroupSeparator?: boolean, useLocalSetting?: boolean, nullDisplay?: string, state?: StiTextFormatState);
    }
}
declare namespace Stimulsoft.Report.Components.TextFormats {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import NumberFormatInfo = Stimulsoft.System.Globalization.NumberFormatInfo;
    class StiPercentageFormatService extends StiCurrencyFormatService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        format(arg: any): string;
        format2(stringFormat: string, arg: any): string;
        formatStr(format: NumberFormatInfo, arg: any): string;
        createNew(): StiFormatService;
        constructor(positivePattern?: number, negativePattern?: number, decimalPlaces?: number, decimalSeparator?: string, decimalDigits?: number, groupSeparator?: string, groupSize?: number, symbol?: string, useGroupSeparator?: boolean, useLocalSetting?: boolean, nullDisplay?: string, state?: StiTextFormatState);
    }
}
declare namespace Stimulsoft.Report.Components.TextFormats {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiGeneralFormatService extends StiFormatService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        get sample(): string;
        equals(obj: any): boolean;
        static default: StiGeneralFormatService;
        createNew(): StiFormatService;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiGetValueEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiGetValueEventHandler: EventHandler;
    class StiGetValueEventArgs extends EventArgs {
        value: string;
        storeToPrinted: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiEditable: System.Interface<IStiEditable>;
    interface IStiEditable {
        editable: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    let IStiText: System.Interface<IStiText>;
    interface IStiText {
        text: string;
        textValue: string;
        setText(getValue: any): any;
        linesOfUnderline: StiPenStyle;
        hideZeros: boolean;
        processingDuplicates: StiProcessingDuplicatesType;
        onlyText: boolean;
        maxNumberOfLines: number;
        getTextInternal(): string;
        setTextInternal(value: string): any;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetValueEvent = Stimulsoft.Report.Events.StiGetValueEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiEditable = Stimulsoft.Report.Components.IStiEditable;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiSimpleText extends StiComponent implements IStiText, IStiEditable, IStiJsonReportObject {
        private static ImplementsStiSimpleText;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        protected static propertyGlobalizedName: string;
        get globalizedName(): string;
        set globalizedName(value: string);
        clone(cloneProperties?: boolean, cloneComponents?: boolean, base?: boolean): StiSimpleText;
        memberwiseClone(base?: boolean): StiSimpleText;
        getTextWithoutZero(text: string): string;
        setText(getValue?: any, value?: string): void;
        private setTextTo;
        private _linesOfUnderline;
        get linesOfUnderline(): StiPenStyle;
        set linesOfUnderline(value: StiPenStyle);
        get linesOfUnderlining(): boolean;
        set linesOfUnderlining(value: boolean);
        private _hideZeros;
        get hideZeros(): boolean;
        set hideZeros(value: boolean);
        get mergeDuplicates(): boolean;
        set mergeDuplicates(value: boolean);
        private static propertyProcessingDuplicates;
        get processingDuplicates(): StiProcessingDuplicatesType;
        set processingDuplicates(value: StiProcessingDuplicatesType);
        private static propertyMaxNumberOfLines;
        get maxNumberOfLines(): number;
        set maxNumberOfLines(value: number);
        processText(text: string): string;
        private static propertyOnlyText;
        get onlyText(): boolean;
        set onlyText(value: boolean);
        private _editable;
        get editable(): boolean;
        set editable(value: boolean);
        get processAtEnd(): boolean;
        set processAtEnd(value: boolean);
        protected static propertyProcessAt: string;
        get processAt(): StiProcessAt;
        set processAt(value: StiProcessAt);
        invokeRenderTo(textBox: StiSimpleText): void;
        private _text;
        get text(): string;
        set text(value: string);
        getTextInternal(): string;
        setTextInternal(value: string): void;
        private _textValue;
        get textValue(): string;
        set textValue(value: string);
        private static eventGetValue;
        protected onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiComponent, e: StiGetValueEventArgs): void;
        checkDuplicates(sender: StiComponent, e: StiGetValueEventArgs): void;
        get getValueEvent(): StiGetValueEvent;
        set getValueEvent(value: StiGetValueEvent);
        private static eventTextProcess;
        protected onTextProcess(e: StiValueEventArgs): void;
        invokeTextProcess(sender: StiComponent, e: StiValueEventArgs): void;
        private applyConditionsAssignExpression;
        _totalValueHelp: string;
        get totalValueHelp(): string;
        set totalValueHelp(value: string);
        constructor(rect?: RectangleD, isSuper?: boolean);
        protected construct(rect?: RectangleD): void;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiGetExcelValueEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiGetExcelValueEvent = Stimulsoft.Report.Events.StiGetExcelValueEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiEditable = Stimulsoft.Report.Components.IStiEditable;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    import StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiGetExcelValueEventArgs = Stimulsoft.Report.Events.StiGetExcelValueEventArgs;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiText extends StiSimpleText implements IStiTextOptions, IStiAutoWidth, IStiTextHorAlignment, IStiVertAlignment, IStiBorder, IStiFont, IStiBrush, IStiTextBrush, IStiTextFormat, IStiBreakable, IStiGlobalizationProvider, IStiEditable, IStiJsonReportObject, IStiGetFonts {
        private static ImplementsStiText;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        parseTextFromXml(xmlNode: XmlNode): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        private _indicator;
        get indicator(): StiIndicator;
        set indicator(value: StiIndicator);
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        private static propertyCanBreak;
        get canBreak(): boolean;
        set canBreak(value: boolean);
        break(dividedComponent: StiComponent, devideFactor: number, REFdivideLine: any): boolean;
        private static propertyAutoWidth;
        get autoWidth(): boolean;
        set autoWidth(value: boolean);
        protected static propertyRenderTo: string;
        get renderTo(): string;
        set renderTo(value: string);
        invokeRenderTo(textFrom: StiSimpleText): void;
        private getVisibleTextForRenderTo;
        private _horAlignment;
        get horAlignment(): StiTextHorAlignment;
        set horAlignment(value: StiTextHorAlignment);
        private _vertAlignment;
        get vertAlignment(): StiVertAlignment;
        set vertAlignment(value: StiVertAlignment);
        static defaultFont: Font;
        private _font;
        get font(): Font;
        set font(value: Font);
        private _border;
        get border(): StiBorder;
        set border(value: StiBorder);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _textBrush;
        get textBrush(): StiBrush;
        set textBrush(value: StiBrush);
        private _textFormat;
        get textFormat(): StiFormatService;
        set textFormat(value: StiFormatService);
        private _format;
        get format(): string;
        set format(value: string);
        private _textOptions;
        get textOptions(): StiTextOptions;
        set textOptions(value: StiTextOptions);
        clone(cloneProperties?: boolean, cloneComponents?: boolean, base?: boolean): StiText;
        memberwiseClone(base?: boolean): StiText;
        getFonts(): Font[];
        convertTextMargins(rect: RectangleD, convert: boolean): RectangleD;
        convertTextBorders(rect: RectangleD, convert: boolean): RectangleD;
        getTextForPaint(): string;
        getActualSize(): SizeD;
        prepare(): void;
        private _excelDataValue;
        get excelDataValue(): string;
        set excelDataValue(value: string);
        get excelValue(): string;
        set excelValue(value: string);
        invokeEvents(): void;
        private static eventGetExcelValue;
        protected onGetExcelValue(e: StiGetExcelValueEventArgs): void;
        invokeGetExcelValue(sender: StiComponent, e: StiGetExcelValueEventArgs): void;
        get getExcelValueEvent(): StiGetExcelValueEvent;
        set getExcelValueEvent(value: StiGetExcelValueEvent);
        protected static propertyNullValue: string;
        get nullValue(): string;
        set nullValue(value: string);
        protected static propertyType: string;
        get type(): StiSystemTextType;
        set type(value: StiSystemTextType);
        get wordWrap(): boolean;
        set wordWrap(value: boolean);
        get rightToLeft(): boolean;
        set rightToLeft(value: boolean);
        get trimming(): StringTrimming;
        set trimming(value: StringTrimming);
        get angle(): number;
        set angle(value: number);
        private static propertyLineSpacing;
        get lineSpacing(): number;
        set lineSpacing(value: number);
        private static propertyExportAsImage;
        get exportAsImage(): boolean;
        set exportAsImage(value: boolean);
        private static propertyTextQuality;
        get textQuality(): StiTextQuality;
        set textQuality(value: StiTextQuality);
        private static propertyAllowHtmlTags;
        get allowHtmlTags(): boolean;
        set allowHtmlTags(value: boolean);
        private static propertyMargins;
        get margins(): StiMargins;
        set margins(value: StiMargins);
        private static propertyShrinkFontToFit;
        get shrinkFontToFit(): boolean;
        set shrinkFontToFit(value: boolean);
        private static propertyShrinkFontToFitMinimumSize;
        get shrinkFontToFitMinimumSize(): number;
        set shrinkFontToFitMinimumSize(value: number);
        createNew(): StiComponent;
        checkAllowHtmlTags(): boolean;
        getActualFont(text: string, minFontSize?: number): Font;
        constructor(rect?: RectangleD, isSuper?: boolean);
        protected construct(rect?: RectangleD): void;
    }
}
declare namespace Stimulsoft.Report.CrossTab {
    import StiConditionPermissions = Stimulsoft.Report.Components.StiConditionPermissions;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiText = Stimulsoft.Report.Components.StiText;
    import StiRestrictions = Stimulsoft.Report.Components.StiRestrictions;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import IStiBorder = Stimulsoft.Report.Components.IStiBorder;
    import IStiBrush = Stimulsoft.Report.Components.IStiBrush;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import IStiTextBrush = Stimulsoft.Report.Components.IStiTextBrush;
    import IStiTextHorAlignment = Stimulsoft.Report.Components.IStiTextHorAlignment;
    import IStiVertAlignment = Stimulsoft.Report.Components.IStiVertAlignment;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import IStiCrossTabField = Stimulsoft.Report.Components.IStiCrossTabField;
    class StiCrossField extends StiText implements IStiTextHorAlignment, IStiVertAlignment, IStiBorder, IStiFont, IStiBrush, IStiTextBrush, IStiCrossTabField, IStiJsonReportObject {
        private static ImplementsStiCrossField;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        protected get defaultHorAlignment(): StiTextHorAlignment;
        get locked(): boolean;
        set locked(value: boolean);
        get linked(): boolean;
        set linked(value: boolean);
        protected onProcessCell(e: StiProcessCellEventArgs): void;
        invokeProcessCell(e: StiProcessCellEventArgs): void;
        processCellEvent: StiProcessCellEvent;
        get helpUrl(): string;
        toString(): string;
        get localizedCategory(): string;
        getRestrictions(): StiRestrictions;
        setRestrictions(value: StiRestrictions): void;
        getTextBoxFromField(): StiText;
        get cellText(): string;
        private _mergeHeaders;
        get mergeHeaders(): boolean;
        set mergeHeaders(value: boolean);
        originalValue: any;
        disabledByCondition: boolean;
        conditionBrush: StiBrush;
        conditionTextBrush: StiBrush;
        conditionPermissions: StiConditionPermissions;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Dictionary.Design {
    import Type = Stimulsoft.System.Type;
    class StiDataColumnConverter {
        static convertTypeToString(type: Type): string;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import List = Stimulsoft.System.Collections.List;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiAppDataColumn = Stimulsoft.Base.IStiAppDataColumn;
    import Type = Stimulsoft.System.Type;
    import IStiAppAlias = Stimulsoft.Base.IStiAppAlias;
    class StiDataColumn implements IStiJsonReportObject, ICloneable, IStiName, IStiAppDataColumn, IStiAppAlias, IStiInherited {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiDataColumn;
        memberwiseClone(): StiDataColumn;
        getNameInSource(): string;
        getDataType(): Type;
        getName(): string;
        getAlias(): string;
        getKey(): string;
        setKey(key: string): void;
        private _name;
        get name(): string;
        set name(value: string);
        get inherited(): boolean;
        set inherited(value: boolean);
        dataColumnsCollection: StiDataColumnsCollection;
        private _dataSource;
        get dataSource(): StiDataSource;
        set dataSource(value: StiDataSource);
        private _businessObject;
        get businessObject(): StiBusinessObject;
        set businessObject(value: StiBusinessObject);
        private _index;
        get index(): number;
        set index(value: number);
        private _nameInSource;
        get nameInSource(): string;
        set nameInSource(value: string);
        private _alias;
        get alias(): string;
        set alias(value: string);
        private _type;
        get type(): Stimulsoft.System.Type;
        set type(value: Stimulsoft.System.Type);
        private _key;
        get key(): string;
        set key(value: string);
        getColumnPath(): string;
        toString(): string;
        static getDataColumnFromColumnName(dictionary: StiDictionary, column: string, allowRelationName?: boolean): StiDataColumn;
        static getRelationName(dictionary: StiDictionary, dataSource: StiDataSource, relationName: string): string;
        static getDataFromBusinessObject(dictionary: StiDictionary, column: string): any;
        static getBusinessObjectFromDataColumn(dictionary: StiDictionary, column: string): StiBusinessObject;
        static getDataFromDataColumn(dictionary: StiDictionary, column: string, useRelationName?: boolean): any;
        static getDataSourceFromDataColumn(dictionary: StiDictionary, column: string): StiDataSource;
        static getColumnNameFromDataColumn(dictionary: StiDictionary, column: string): string;
        static getDataListFromDataColumn(dictionary: StiDictionary, column: string, maxRows?: number, firstPositionInDataSource?: boolean): any[];
        static getDatasFromDataColumn(dictionary: StiDictionary, column: string, maxRows?: number, firstPositionInDataSource?: boolean): any[];
        static getDatasFromDataSourceWithExpression(data: any, expression: string, maxRows?: number, firstPositionInDataSource?: boolean): List<string>;
        constructor(nameInSource?: string, name?: string, alias?: string, type?: Stimulsoft.System.Type, key?: string);
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Color = Stimulsoft.System.Drawing.Color;
    import Image = Stimulsoft.System.Drawing.Image;
    import List = Stimulsoft.System.Collections.List;
    class StiSparkline extends StiComponent implements IStiExportImageExtended, IStiDataRelation, IStiBorder, IStiBrush {
        private static implementsStiSparkline;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        get dataRelation(): StiDataRelation;
        dataRelationName: string;
        getImage(REFzoom: any): Image;
        getImage2(): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        clone(cloneProperties: boolean): StiSparkline;
        brush: StiBrush;
        border: StiBorder;
        get priority(): number;
        get localizedCategory(): string;
        defaultClientRectangle: Rectangle;
        get componentType(): StiComponentType;
        get toolboxPosition(): number;
        toolboxCategory: () => StiToolboxCategory;
        get localizedName(): string;
        helpUrl: () => string;
        createNew: () => StiSparkline;
        fetchValues(): List<any>;
        getDataSource(): StiDataSource;
        private _valueDataColumn;
        get valueDataColumn(): string;
        set valueDataColumn(value: string);
        values: number[];
        get valuesContainer(): string;
        set valuesContainer(value: string);
        type: StiSparklineType;
        showHighLowPoints: boolean;
        showFirstLastPoints: boolean;
        positiveColor: Color;
        negativeColor: Color;
        protected construct(rect?: Rectangle): void;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiComponentBuilder extends StiBuilder {
        setReportVariables(masterComp: StiComponent): void;
        prepare(masterComp: StiComponent): void;
        unPrepare(masterComp: StiComponent): void;
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
        renderAsync(masterComp: StiComponent): Promise<StiComponent>;
        render(masterComp: StiComponent): StiComponent;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiPrintIfEmpty: System.Interface<IStiPrintIfEmpty>;
    interface IStiPrintIfEmpty {
        printIfEmpty: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    let IStiDataRelation: System.Interface<IStiDataRelation>;
    interface IStiDataRelation {
        dataRelation: StiDataRelation;
        dataRelationName: string;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiSort: System.Interface<IStiSort>;
    interface IStiSort {
        sort: string[];
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiCrossTab: System.Interface<IStiCrossTab>;
    interface IStiCrossTab {
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiFilter: System.Interface<IStiFilter>;
    interface IStiFilter {
        filterMethodHandler: Function;
        filterMode: StiFilterMode;
        filters: StiFiltersCollection;
        filterOn: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    let IStiDataSource: System.Interface<IStiDataSource>;
    interface IStiDataSource {
        dataSource: StiDataSource;
        dataSourceName: string;
        isDataSourceEmpty: boolean;
        first(): any;
        prior(): any;
        next(): any;
        last(): any;
        position: number;
        count: number;
        isEof: boolean;
        isBof: boolean;
        isEmpty: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    let IStiBusinessObject: System.Interface<IStiBusinessObject>;
    interface IStiBusinessObject {
        businessObject: StiBusinessObject;
        businessObjectGuid: string;
        isBusinessObjectEmpty: boolean;
        first(): any;
        prior(): any;
        next(): any;
        last(): any;
        position: number;
        count: number;
        isEof: boolean;
        isBof: boolean;
        isEmpty: boolean;
    }
}
declare namespace Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiFillParametersEventHandler: EventHandler;
    class StiFillParametersEventArgs extends EventArgs {
        private val;
        get value(): Array<{
            key: string;
            value: any;
        }>;
        set value(value: Array<{
            key: string;
            value: any;
        }>);
        constructor(value?: Array<{
            key: string;
            value: any;
        }>);
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiResetPageNumber: System.Interface<IStiResetPageNumber>;
    interface IStiResetPageNumber {
        resetPageNumber: boolean;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiGetExcelSheetEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiColumnEndRenderEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiColumnBeginRenderEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Components {
    import PaperKind = Stimulsoft.System.Drawing.Printing.PaperKind;
    import PaperSize = Stimulsoft.System.Drawing.Printing.PaperSize;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiPageHelper {
        static getPaperSizeFromPaperKind(paperKind: PaperKind): PaperSize;
        static getPaperSize(page: StiPage, paperSize: PaperSize): SizeD;
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiMargins implements IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode, defLeft?: number, defRight?: number, defTop?: number, defBotttom?: number): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromText(text: string): StiMargins;
        static loadFromXml(xmlNode: XmlNode): StiMargins;
        clone(): any;
        equals(obj: any): boolean;
        private _left;
        get left(): number;
        set left(value: number);
        private _right;
        get right(): number;
        set right(value: number);
        private _top;
        get top(): number;
        set top(value: number);
        private _bottom;
        get bottom(): number;
        set bottom(value: number);
        get isEmpty(): boolean;
        static empty: StiMargins;
        static create(all?: number): StiMargins;
        constructor(left?: number, right?: number, top?: number, bottom?: number);
    }
}
declare namespace Stimulsoft.Report.Engine {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiComponentInfo implements ICloneable {
        implements(): any[];
        clone(): StiComponentInfo;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiPageInfo extends StiComponentInfo {
        overlays: StiComponentsCollection;
        indexOfStartRenderedPages: number;
        masterDataBand: StiDataBand;
        isReportTitlesRendered: boolean;
        renderedCount: number;
        positionFromTop: number;
        positionFromBottom: number;
    }
}
declare namespace Stimulsoft.Report.Units {
    import IAsIs = Stimulsoft.System.IAsIs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Size = Stimulsoft.System.Drawing.Size;
    class StiUnit implements IAsIs {
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        static saveToJsonObject(unit: StiUnit): StiJson;
        static loadFromJsonObject(jObject: StiJson): StiUnit;
        static loadFromXml(xmlNode: XmlNode): StiUnit;
        static getUnitFromReportUnit(reportUnit: StiReportUnitType): StiUnit;
        private static _centimeters;
        static get Centimeters(): StiCentimetersUnit;
        private static _hundredthsOfInch;
        static get HundredthsOfInch(): StiHundredthsOfInchUnit;
        private static _inches;
        static get Inches(): StiInchesUnit;
        private static _millimeters;
        static get Millimeters(): StiMillimetersUnit;
        get rulerStep(): number;
        get factor(): number;
        get shortName(): string;
        get name(): string;
        convertToHInches(value: number): number;
        convertFromHInches(value: number): number;
        convertRectangleToHInches(rect: Rectangle): Rectangle;
        convertRectangleFromHInches(rect: Rectangle): Rectangle;
        convertSizeToHInches(size: Size): Size;
        convertSizeFromHInches(size: Size): Size;
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ContentAlignment = Stimulsoft.System.Drawing.ContentAlignment;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiWatermark implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiWatermark;
        font: Font;
        textBrush: StiBrush;
        text: string;
        angle: number;
        enabled: boolean;
        showImageBehind: boolean;
        showBehind: boolean;
        rightToLeft: boolean;
        imageMultipleFactor: number;
        private _imageTransparency;
        get imageTransparency(): number;
        set imageTransparency(value: number);
        private _image;
        get image(): Image;
        set image(value: Image);
        private _imageHyperlink;
        get imageHyperlink(): string;
        set imageHyperlink(value: string);
        private cachedImage;
        getImage(report: StiReport): Image;
        imageAlignment: ContentAlignment;
        imageTiling: boolean;
        imageStretch: boolean;
        aspectRatio: boolean;
        enabledExpression: string;
        private getTransparentedImage;
        private disposeCachedImage;
        constructor(textBrush?: StiBrush, text?: string, angle?: number, font?: Font, showBehind?: boolean, enabled?: boolean, aspectRatio?: boolean, rightToLeft?: boolean);
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiBreakable: System.Interface<IStiBreakable>;
    interface IStiBreakable {
        canBreak: boolean;
        break(dividedComponent: StiComponent, devideFactor: number, REFdivideLine: any): boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiBreakable = Stimulsoft.Report.Components.IStiBreakable;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiPanel extends StiContainer implements IStiBreakable, IStiJsonReportObject {
        private static ImplementsStiPanel;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _rightToLeft;
        get rightToLeft(): boolean;
        set rightToLeft(value: boolean);
        private _columnGaps;
        get columnGaps(): number;
        set columnGaps(value: number);
        private _columnWidth;
        get columnWidth(): number;
        set columnWidth(value: number);
        private _columns;
        get columns(): number;
        set columns(value: number);
        getColumnWidth(): number;
    }
}
declare namespace Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiGetExcelSheetEventHandler: EventHandler;
    class StiGetExcelSheetEventArgs extends EventArgs {
        value: string;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetExcelSheetEventArgs = Stimulsoft.Report.Events.StiGetExcelSheetEventArgs;
    import StiBeginRenderEvent = Stimulsoft.Report.Events.StiBeginRenderEvent;
    import StiRenderingEvent = Stimulsoft.Report.Events.StiRenderingEvent;
    import StiEndRenderEvent = Stimulsoft.Report.Events.StiEndRenderEvent;
    import StiColumnBeginRenderEvent = Stimulsoft.Report.Events.StiColumnBeginRenderEvent;
    import StiColumnEndRenderEvent = Stimulsoft.Report.Events.StiColumnEndRenderEvent;
    import StiGetExcelSheetEvent = Stimulsoft.Report.Events.StiGetExcelSheetEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiShiftMode = Stimulsoft.Report.Components.StiShiftMode;
    import StiMargins = Stimulsoft.Report.Components.StiMargins;
    import StiPageInfo = Stimulsoft.Report.Components.StiPageInfo;
    import StiPageOrientation = Stimulsoft.Report.Components.StiPageOrientation;
    import StiWatermark = Stimulsoft.Report.Components.StiWatermark;
    import PaperKind = Stimulsoft.System.Drawing.Printing.PaperKind;
    import IStiResetPageNumber = Stimulsoft.Report.Components.IStiResetPageNumber;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiReportPage = Stimulsoft.Base.IStiReportPage;
    class StiPage extends StiPanel implements IStiResetPageNumber, IStiReportPage, IStiJsonReportObject {
        private static ImplementsStiPage;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        private _resetPageNumber;
        get resetPageNumber(): boolean;
        set resetPageNumber(value: boolean);
        convertToHInches(unit: StiUnit, value: number): number;
        convertFromHInchesRect(unit: StiUnit, rect: RectangleD): RectangleD;
        convertFromHInches(unit: StiUnit, value: number): number;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        parseExpression(text: string): string;
        private _pageInfo;
        get pageInfo(): StiPageInfo;
        get isAutomaticDock(): boolean;
        get left(): number;
        set left(value: number);
        get top(): number;
        set top(value: number);
        getWidth(): number;
        setWidth(value: number): void;
        getHeight(): number;
        setHeight(value: number): void;
        get right(): number;
        get bottom(): number;
        get clientRectangle(): RectangleD;
        set clientRectangle(value: RectangleD);
        getDisplayRectangle(): RectangleD;
        get shiftMode(): StiShiftMode;
        set shiftMode(value: StiShiftMode);
        get printable(): boolean;
        set printable(value: boolean);
        get page(): StiPage;
        set page(value: StiPage);
        get parent(): StiContainer;
        set parent(value: StiContainer);
        invokeEvents(): void;
        private static eventBeginRender;
        protected onBeginRender(): void;
        invokeBeginRender(): void;
        get beginRenderEvent(): StiBeginRenderEvent;
        set beginRenderEvent(value: StiBeginRenderEvent);
        private static eventRendering;
        protected onRendering(): void;
        invokeRendering(): void;
        get renderingEvent(): StiRenderingEvent;
        set renderingEvent(value: StiRenderingEvent);
        private static eventEndRender;
        protected onEndRender(): void;
        invokeEndRender(): void;
        get endRenderEvent(): StiEndRenderEvent;
        set endRenderEvent(value: StiEndRenderEvent);
        private static eventColumnBeginRender;
        protected onColumnBeginRender(): void;
        invokeColumnBeginRender(sender?: any): void;
        get columnBeginRenderEvent(): StiColumnBeginRenderEvent;
        set columnBeginRenderEvent(value: StiColumnBeginRenderEvent);
        private static eventColumnEndRender;
        protected onColumnEndRender(): void;
        invokeColumnEndRender(sender?: any): void;
        get columnEndRenderEvent(): StiColumnEndRenderEvent;
        set columnEndRenderEvent(value: StiColumnEndRenderEvent);
        private static eventGetExcelSheet;
        protected onGetExcelSheet(e: StiGetExcelSheetEventArgs): void;
        invokeGetExcelSheet(sender: StiComponent, e: StiGetExcelSheetEventArgs): void;
        get getExcelSheetEvent(): StiGetExcelSheetEvent;
        set getExcelSheetEvent(value: StiGetExcelSheetEvent);
        private _excelSheetValue;
        get excelSheetValue(): string;
        set excelSheetValue(value: string);
        private _excelSheet;
        get excelSheet(): string;
        set excelSheet(value: string);
        get zoom(): number;
        get gridSize(): number;
        private _printOnPreviousPage;
        get printOnPreviousPage(): boolean;
        set printOnPreviousPage(value: boolean);
        private _printHeadersFootersFromPreviousPage;
        get printHeadersFootersFromPreviousPage(): boolean;
        set printHeadersFootersFromPreviousPage(value: boolean);
        private _paperSize;
        get paperSize(): PaperKind;
        set paperSize(value: PaperKind);
        private _paperSourceOfFirstPage;
        get paperSourceOfFirstPage(): string;
        set paperSourceOfFirstPage(value: string);
        private _paperSourceOfOtherPages;
        get paperSourceOfOtherPages(): string;
        set paperSourceOfOtherPages(value: string);
        private _numberOfCopies;
        get numberOfCopies(): number;
        set numberOfCopies(value: number);
        private _unlimitedBreakable;
        get unlimitedBreakable(): boolean;
        set unlimitedBreakable(value: boolean);
        private _largeHeight;
        get largeHeight(): boolean;
        set largeHeight(value: boolean);
        private _largeHeightFactor;
        get largeHeightFactor(): number;
        set largeHeightFactor(value: number);
        private _largeHeightAutoFactor;
        get largeHeightAutoFactor(): number;
        set largeHeightAutoFactor(value: number);
        private _currentWidthSegment;
        get currentWidthSegment(): number;
        set currentWidthSegment(value: number);
        private _currentHeightSegment;
        get currentHeightSegment(): number;
        set currentHeightSegment(value: number);
        private _stopBeforePrint;
        get stopBeforePrint(): number;
        set stopBeforePrint(value: number);
        private _skip;
        get skip(): boolean;
        set skip(value: boolean);
        private _stretchToPrintArea;
        get stretchToPrintArea(): boolean;
        set stretchToPrintArea(value: boolean);
        private _titleBeforeHeader;
        get titleBeforeHeader(): boolean;
        set titleBeforeHeader(value: boolean);
        private _unlimitedHeight;
        get unlimitedHeight(): boolean;
        set unlimitedHeight(value: boolean);
        private _unlimitedWidth;
        get unlimitedWidth(): boolean;
        set unlimitedWidth(value: boolean);
        private _offsetRectangle;
        get offsetRectangle(): RectangleD;
        set offsetRectangle(value: RectangleD);
        private _orientation;
        get orientation(): StiPageOrientation;
        set orientation(value: StiPageOrientation);
        get locked(): boolean;
        set locked(value: boolean);
        get linked(): boolean;
        set linked(value: boolean);
        private _pageWidth;
        get pageWidth(): number;
        set pageWidth(value: number);
        private _pageHeight;
        get pageHeight(): number;
        set pageHeight(value: number);
        private _segmentPerWidth;
        get segmentPerWidth(): number;
        set segmentPerWidth(value: number);
        private _segmentPerHeight;
        get segmentPerHeight(): number;
        set segmentPerHeight(value: number);
        private _watermark;
        get watermark(): StiWatermark;
        set watermark(value: StiWatermark);
        margins: StiMargins;
        private _mirrorMargins;
        get mirrorMargins(): boolean;
        set mirrorMargins(value: boolean);
        private _report;
        get report(): StiReport;
        set report(value: StiReport);
        get unit(): StiUnit;
        private _reportUnit;
        get reportUnit(): StiUnit;
        set reportUnit(value: StiUnit);
        private _drillDownActivated;
        get drillDownActivated(): boolean;
        set drillDownActivated(value: boolean);
        get isDashboard(): boolean;
        get isPage(): boolean;
        private _cacheGuid;
        get cacheGuid(): string;
        set cacheGuid(value: string);
        newCacheGuid(): void;
        private getIsPageTotalDataBand;
        clearPage(): void;
        private removeNewPageContainers;
        private getComponentsCount2;
        getComponentsCount(): number;
        resizePage(factorX: number, factorY: number, allowPageMarginsRescaling?: boolean): void;
        toString(): string;
        constructor(report?: StiReport, isSuper?: boolean);
        protected construct(report?: StiReport | any): void;
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiChildBand extends StiDynamicBand implements IStiKeepChildTogether, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _keepChildTogether;
        get keepChildTogether(): boolean;
        set keepChildTogether(value: boolean);
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        protected getComponentType(): StiComponentType;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get priority(): number;
        private _printIfParentDisabled;
        get printIfParentDisabled(): boolean;
        set printIfParentDisabled(value: boolean);
        createNew(): StiComponent;
        getMaster(): StiBand;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiRenderMaster: System.Interface<IStiRenderMaster>;
    interface IStiRenderMaster {
        renderMasterAsync(): Promise<void>;
        renderMaster(): void;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiSubReport = Stimulsoft.Report.Components.StiSubReport;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiSubReportsHelper {
        static getMasterDataBand(parent: StiContainer): StiDataBand;
        static getParentBand(parent: StiContainer): StiBand;
        static renderSubReportAsync(containerOfSubReport: StiContainer, subReport: StiSubReport): Promise<void>;
        static renderSubReport(containerOfSubReport: StiContainer, subReport: StiSubReport): void;
        static specialSubReportHeight: number;
        private static renderInternalSubReportAsync;
        private static renderInternalSubReport;
        static renderExternalSubReportsWithoutHelpOfUnlimitedHeightPagesOldMode: boolean;
        private static renderExternalSubReportAsync;
        private static renderExternalSubReport;
        static renderDataBandsInContainerAsync(containerOfDataBands: StiContainer, container: StiContainer, skipStaticBands?: boolean): Promise<void>;
        static renderDataBandsInContainer(containerOfDataBands: StiContainer, container: StiContainer, skipStaticBands?: boolean): void;
    }
}
declare namespace Stimulsoft.Report.Styles {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCrossTabStyle extends StiBaseStyle implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        backColor: Color;
        get color(): Color;
        set color(value: Color);
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        columnHeaderBackColor: Color;
        columnHeaderForeColor: Color;
        rowHeaderBackColor: Color;
        rowHeaderForeColor: Color;
        hotColumnHeaderBackColor: Color;
        hotRowHeaderBackColor: Color;
        cellForeColor: Color;
        lineColor: Color;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
    }
}
declare namespace Stimulsoft.Report.CrossTab.Core {
    enum StiSortDirection {
        Asc = 0,
        Desc = 1,
        None = 2
    }
    enum StiSummaryType {
        None = 0,
        Sum = 1,
        Average = 2,
        Min = 3,
        Max = 4,
        Count = 5,
        CountDistinct = 6,
        Image = 7
    }
    enum StiSummaryValues {
        AllValues = 0,
        SkipZerosAndNulls = 1,
        SkipNulls = 2
    }
    enum StiSortType {
        ByValue = 0,
        ByDisplayValue = 1
    }
    enum StiFieldType {
        Column = 0,
        Row = 1,
        Cell = 2
    }
    enum StiSummaryDirection {
        LeftToRight = 0,
        UpToDown = 1
    }
    enum StiEnumeratorType {
        None = 0,
        Arabic = 1,
        Roman = 2,
        ABC = 3
    }
    enum StiEnumeratorSeparator {
        Dot = 0,
        Dash = 1,
        Colon = 2,
        RoundBrackets = 3,
        SquareBrackets = 4
    }
    enum StiCellType {
        HeaderCol = 0,
        HeaderColMain = 1,
        HeaderColTotal = 2,
        HeaderColTotalMain = 3,
        HeaderColSummary = 4,
        HeaderColSummaryTotal = 5,
        HeaderRow = 6,
        HeaderRowMain = 7,
        HeaderRowTotal = 8,
        HeaderRowTotalMain = 9,
        HeaderRowSummary = 10,
        HeaderRowSummaryTotal = 11,
        Cell = 12,
        CellTotal = 13,
        LeftTopLine = 14,
        LeftTopLineMain = 15,
        RightTopLine = 16,
        RightTopLineMain = 17,
        CornerCol = 18,
        CornerColMain = 19,
        CornerRow = 20,
        CornerRowMain = 21
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFilter implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiFilter;
        memberwiseClone(): StiFilter;
        private _condition;
        get condition(): StiFilterCondition;
        set condition(value: StiFilterCondition);
        private _dataType;
        get dataType(): StiFilterDataType;
        set dataType(value: StiFilterDataType);
        private _column;
        get column(): string;
        set column(value: string);
        private _item;
        get item(): StiFilterItem;
        set item(value: StiFilterItem);
        private valueObj1;
        get value1(): string;
        set value1(value: string);
        private valueObj2;
        get value2(): string;
        set value2(value: string);
        private _expression;
        get expression(): string;
        set expression(value: string);
        constructor(item?: StiFilterItem, column?: string, condition?: StiFilterCondition, value1?: string, value2?: string, dataType?: StiFilterDataType, expression?: string);
    }
}
declare namespace Stimulsoft.Report.CrossTab {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import StiComponentType = Stimulsoft.Report.Components.StiComponentType;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiSummaryDirection = Stimulsoft.Report.CrossTab.Core.StiSummaryDirection;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import StiFilterEngine = Stimulsoft.Report.Components.StiFilterEngine;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiDataSource = Stimulsoft.Report.Components.IStiDataSource;
    import IStiFilter = Stimulsoft.Report.Components.IStiFilter;
    import IStiCrossTab = Stimulsoft.Report.Components.IStiCrossTab;
    import IStiSort = Stimulsoft.Report.Components.IStiSort;
    import IStiDataRelation = Stimulsoft.Report.Components.IStiDataRelation;
    import IStiPrintIfEmpty = Stimulsoft.Report.Components.IStiPrintIfEmpty;
    import IStiBusinessObject = Stimulsoft.Report.Components.IStiBusinessObject;
    class StiCrossTab extends StiContainer implements IStiDataSource, IStiFilter, IStiCrossTab, IStiSort, IStiDataRelation, IStiPrintIfEmpty, IStiBusinessObject, IStiJsonReportObject {
        private static ImplementsStiCrossTab;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        get helpUrl(): string;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        private _printIfEmpty;
        get printIfEmpty(): boolean;
        set printIfEmpty(value: boolean);
        get dataRelation(): StiDataRelation;
        private _dataRelationName;
        get dataRelationName(): string;
        set dataRelationName(value: string);
        get dataSource(): StiDataSource;
        private _dataSourceName;
        get dataSourceName(): string;
        set dataSourceName(value: string);
        get isDataSourceEmpty(): boolean;
        get isBusinessObjectEmpty(): boolean;
        get businessObject(): StiBusinessObject;
        private _businessObjectGuid;
        get businessObjectGuid(): string;
        set businessObjectGuid(value: string);
        private _sort;
        get sort(): string[];
        set sort(value: string[]);
        get canBreak(): boolean;
        set canBreak(value: boolean);
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        get isEof(): boolean;
        set isEof(value: boolean);
        get isBof(): boolean;
        set isBof(value: boolean);
        get isEmpty(): boolean;
        get position(): number;
        set position(value: number);
        get count(): number;
        clone(): StiCrossTab;
        packService(): void;
        private _crossTabInfo;
        get crossTabInfo(): StiCrossTabInfo;
        private _filterEngine;
        get filterEngine(): StiFilterEngine;
        set filterEngine(value: StiFilterEngine);
        private _filterMode;
        get filterMode(): StiFilterMode;
        set filterMode(value: StiFilterMode);
        filterMethodHandler: Function;
        private _filters;
        get filters(): Stimulsoft.Report.Components.StiFiltersCollection;
        set filters(value: Stimulsoft.Report.Components.StiFiltersCollection);
        get filter(): string;
        set filter(value: string);
        private _filterOn;
        get filterOn(): boolean;
        set filterOn(value: boolean);
        canContainIn(component: StiComponent): boolean;
        get localizedCategory(): string;
        get priority(): number;
        defaultClientRectangle: RectangleD;
        get componentType(): StiComponentType;
        get localizedName(): string;
        private _crossTabStyleIndex;
        get crossTabStyleIndex(): number;
        set crossTabStyleIndex(value: number);
        private _crossTabStyleColor;
        get crossTabStyleColor(): any;
        set crossTabStyleColor(value: any);
        get crossTabStyle(): string;
        set crossTabStyle(value: string);
        setComponentStyle(value: string): void;
        updateStyles(): void;
        getCellColor(): Color;
        applyFieldStyle(field: StiCrossField): void;
        private _horAlignment;
        get horAlignment(): StiCrossHorAlignment;
        set horAlignment(value: StiCrossHorAlignment);
        private _printTitleOnAllPages;
        get printTitleOnAllPages(): boolean;
        set printTitleOnAllPages(value: boolean);
        private _summaryDirection;
        get summaryDirection(): StiSummaryDirection;
        set summaryDirection(value: StiSummaryDirection);
        private _keepCrossTabTogether;
        get keepCrossTabTogether(): boolean;
        set keepCrossTabTogether(value: boolean);
        private _emptyValue;
        get emptyValue(): string;
        set emptyValue(value: string);
        private _wrap;
        get wrap(): boolean;
        set wrap(value: boolean);
        private _wrapGap;
        get wrapGap(): number;
        set wrapGap(value: number);
        private _rightToLeft;
        get rightToLeft(): boolean;
        set rightToLeft(value: boolean);
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiGetSummaryExpressionEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiGetGroupConditionEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiGetSummaryExpressionEvent = Stimulsoft.Report.Events.StiGetSummaryExpressionEvent;
    import StiGetGroupConditionEvent = Stimulsoft.Report.Events.StiGetGroupConditionEvent;
    import StiGetCollapsedEvent = Stimulsoft.Report.Events.StiGetCollapsedEvent;
    import StiBeginRenderEvent = Stimulsoft.Report.Events.StiBeginRenderEvent;
    import StiRenderingEvent = Stimulsoft.Report.Events.StiRenderingEvent;
    import StiEndRenderEvent = Stimulsoft.Report.Events.StiEndRenderEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    class StiGroupHeaderBand extends StiDynamicBand implements IStiGroup, IStiPrintOnAllPages, IStiKeepGroupTogether, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean, cloneComponents: boolean): StiGroupHeaderBand;
        private _keepGroupHeaderTogether;
        get keepGroupHeaderTogether(): boolean;
        set keepGroupHeaderTogether(value: boolean);
        private _keepGroupTogether;
        get keepGroupTogether(): boolean;
        set keepGroupTogether(value: boolean);
        private _startNewPage;
        get startNewPage(): boolean;
        set startNewPage(value: boolean);
        get startNewPageIfLessThan(): number;
        set startNewPageIfLessThan(value: number);
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        private _sortDirection;
        get sortDirection(): StiGroupSortDirection;
        set sortDirection(value: StiGroupSortDirection);
        private _summarySortDirection;
        get summarySortDirection(): StiGroupSortDirection;
        set summarySortDirection(value: StiGroupSortDirection);
        private _summaryType;
        get summaryType(): StiGroupSummaryType;
        set summaryType(value: StiGroupSummaryType);
        private _printOnAllPages;
        get printOnAllPages(): boolean;
        set printOnAllPages(value: boolean);
        private _groupHeaderBandInfo;
        get groupHeaderBandInfo(): StiGroupHeaderBandInfo;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        protected getComponentType(): StiComponentType;
        get priority(): number;
        getDataBand(): StiDataBand;
        private _line;
        get line(): number;
        set line(value: number);
        private static eventGetSummaryExpression;
        protected onGetSummaryExpression(e: StiValueEventArgs): void;
        invokeGetSummaryExpression(e: StiValueEventArgs): void;
        get getSummaryExpressionEvent(): StiGetSummaryExpressionEvent;
        set getSummaryExpressionEvent(value: StiGetSummaryExpressionEvent);
        private static eventGetValue;
        protected onGetValue(e: StiValueEventArgs): void;
        invokeGetValue(e: StiValueEventArgs): void;
        get getValueEvent(): StiGetGroupConditionEvent;
        set getValueEvent(value: StiGetGroupConditionEvent);
        private static eventGetCollapsed;
        protected onGetCollapsed(e: StiValueEventArgs): void;
        invokeGetCollapsed(e: StiValueEventArgs): void;
        get getCollapsedEvent(): StiGetCollapsedEvent;
        set getCollapsedEvent(value: StiGetCollapsedEvent);
        private static eventBeginRender;
        protected onBeginRender(): void;
        invokeBeginRender(): void;
        get beginRenderEvent(): StiBeginRenderEvent;
        set beginRenderEvent(value: StiBeginRenderEvent);
        private static eventRendering;
        protected onRendering(): void;
        invokeRendering(): void;
        get renderingEvent(): StiRenderingEvent;
        set renderingEvent(value: StiRenderingEvent);
        private static eventEndRender;
        protected onEndRender(): void;
        invokeEndRender(): void;
        get endRenderEvent(): StiEndRenderEvent;
        set endRenderEvent(value: StiEndRenderEvent);
        private _condition;
        get condition(): string;
        set condition(value: string);
        private _summaryExpression;
        get summaryExpression(): string;
        set summaryExpression(value: string);
        private _collapsed;
        get collapsed(): string;
        set collapsed(value: string);
        getHeaderText(): string;
        createNew(): StiComponent;
        getCurrentConditionValue(): any;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiContainerBuilder extends StiComponentBuilder {
        static getRenderContainer(comp: StiComponent, type?: Stimulsoft.System.Type): StiContainer;
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiBandBuilder extends StiContainerBuilder {
        static getChildBands(masterBand: StiBand): StiComponentsCollection;
        static getSubReports(masterBand: StiBand): StiComponentsCollection;
        prepare(masterComp: StiComponent): void;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiGroupHeaderBand = Stimulsoft.Report.Components.StiGroupHeaderBand;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiGroupHeaderBandBuilder extends StiBandBuilder {
        static getMaster(masterGroupHeaderBand: StiGroupHeaderBand): StiDataBand;
        static getCurrentConditionValue(masterGroupHeaderBand: StiGroupHeaderBand): any;
        static getCurrentSummaryExpressionValue(masterGroupHeaderBand: StiGroupHeaderBand): any;
        setReportVariables(masterComp: StiComponent): void;
        prepare(masterComp: StiComponent): void;
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHierarchicalBand extends StiDataBand implements IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        private _keyDataColumn;
        get keyDataColumn(): string;
        set keyDataColumn(value: string);
        private _masterKeyDataColumn;
        get masterKeyDataColumn(): string;
        set masterKeyDataColumn(value: string);
        private _parentValue;
        get parentValue(): string;
        set parentValue(value: string);
        private _indent;
        get indent(): number;
        set indent(value: number);
        private _headers;
        get headers(): string;
        set headers(value: string);
        private _footers;
        get footers(): string;
        set footers(value: string);
        private _hierarchicalBandInfo;
        get hierarchicalBandInfo(): StiHierarchicalBandInfo;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IStiAppCell = Stimulsoft.Base.IStiAppCell;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import DataRow = Stimulsoft.System.Data.DataRow;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import Type = Stimulsoft.System.Type;
    import ICloneable = Stimulsoft.System.ICloneable;
    import List = Stimulsoft.System.Collections.List;
    import IEnumerator = Stimulsoft.System.Collections.IEnumerator;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiDataCollection = Stimulsoft.Report.Dictionary.StiDataCollection;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import StiPromise = Stimulsoft.System.StiPromise;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import IStiAppDataColumn = Stimulsoft.Base.IStiAppDataColumn;
    import IStiAppConnection = Stimulsoft.Base.IStiAppConnection;
    import IStiAppDataRelation = Stimulsoft.Base.IStiAppDataRelation;
    class StiDataSource implements ICloneable, IStiAppCell, IStiAppDataSource, IStiStateSaveRestore, IStiEnumerator, IStiName, IStiAlias, IStiInherited, IStiJsonReportObject {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        getNameInSource(): string;
        getName(): string;
        getDataTable2(allowConnectToData: boolean): Promise<DataTable>;
        getDictionary(): IStiAppDictionary;
        fetchColumns(): List<IStiAppDataColumn>;
        getConnection(): IStiAppConnection;
        fetchParentRelations(activePreferred: boolean): List<IStiAppDataRelation>;
        fetchChildRelations(activePreferred: boolean): List<IStiAppDataRelation>;
        fetchColumnValues(names: List<string>): List<any[]>;
        getKey(): string;
        setKey(key: string): void;
        private _inherited;
        get inherited(): boolean;
        set inherited(value: boolean);
        get current(): any;
        moveNext(): boolean;
        reset(): void;
        getEnumerator(): IEnumerator;
        private _name;
        get name(): string;
        set name(value: string);
        protected positionValue: number;
        get position(): number;
        set position(value: number);
        get realCount(): number;
        get count(): number;
        protected isBofValue: boolean;
        get isBof(): boolean;
        set isBof(value: boolean);
        protected isEofValue: boolean;
        get isEof(): boolean;
        set isEof(value: boolean);
        get isEmpty(): boolean;
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        clone(): StiDataSource;
        memberwiseClone(): StiDataSource;
        private _states;
        protected get states(): StiStatesManager;
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        clearAllStates(): void;
        private nameOfDataBandWhichInitDataSource;
        isInited: boolean;
        initForSubreport: boolean;
        xmlRefAttrValue: string;
        private relationNameStored;
        private resFilterMethod;
        private resSortColumns;
        private isEqualSort;
        setData(dataBand: StiDataBand, relationName: string, filterMethod: any, sortColumns: string[], reinit: boolean, component: StiComponent): void;
        getConditions(dataBand: StiDataBand): any[][][];
        setDetails(relationName: string): void;
        setFilter(filterMethod: any): void;
        setSort(conditions: any[][][], sortColumns: string[], component: StiComponent, databand: StiDataBand, groupHeaders: StiComponentsCollection): void;
        resetDetailsRows(): void;
        resetData(): void;
        getDataRow(index: number): DataRow;
        getParentData(relation: string): StiDataRow;
        getParentRelations(): Stimulsoft.Report.Dictionary.StiDataRelationsCollection;
        getChildRelations(): Stimulsoft.Report.Dictionary.StiDataRelationsCollection;
        getParentDataSource(relationName: string, allowRelationName?: boolean): StiDataSource;
        getChildDataSource(relationName: string): StiDataSource;
        parseSqlQuery(baseSqlCommand: string, dataSource: StiSqlSource): string;
        protected invokeConnecting(): void;
        protected invokeDisconnecting(): void;
        connectAsync(datas: StiDataCollection, loadData: boolean): StiPromise<void>;
        connect(datas: StiDataCollection, loadData: boolean): void;
        protected getDataAdapterType(): Type;
        fillColumns(): void;
        getDataAdapter(): StiDataAdapterService;
        private _parameters;
        get parameters(): StiDataParametersCollection;
        set parameters(value: StiDataParametersCollection);
        getDataTable(table?: DataTable): DataTable;
        getByName(columnName: string): any;
        GetData(columnName: string, index?: number): any;
        getData(columnName: string, index?: number): any;
        getDataAsync(columnName: string, index?: number): StiPromise<any>;
        getColumnIndex(columnName: string): number;
        private _rows;
        get rows(): StiRowsCollection;
        set rows(value: StiRowsCollection);
        columnsIndexs: Hashtable;
        calcColumns: Hashtable;
        detailRows: DataRow[];
        rowToLevel: Hashtable;
        synchronizeColumns(): void;
        checkColumnsIndexs(): void;
        toString(): string;
        getLevel(): number;
        getCategoryName(): string;
        createNew(): StiDataSource;
        private _isCloud;
        get isCloud(): boolean;
        private _dictionary;
        get dictionary(): StiDictionary;
        set dictionary(value: StiDictionary);
        private _dataTable;
        get dataTable(): Stimulsoft.System.Data.DataTable;
        set dataTable(value: Stimulsoft.System.Data.DataTable);
        get isConnected(): boolean;
        private _columns;
        get columns(): StiDataColumnsCollection;
        set columns(value: StiDataColumnsCollection);
        connectionOrder: number;
        disconnect(): void;
        connectOnStart: boolean;
        getByColumnName(columnName: string): any;
        private _alias;
        get alias(): string;
        set alias(value: string);
        private _key;
        get key(): string;
        set key(value: string);
        parentRelationList(activePreferred?: boolean): List<StiDataRelation>;
        childRelationList(activePreferred?: boolean): List<StiDataRelation>;
        constructor(name: string, alias: string, key?: string);
    }
}
declare namespace Stimulsoft.Report.Func {
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    import ResourceManager = Stimulsoft.System.ResourceManager;
    import DateTime = Stimulsoft.System.DateTime;
    enum Gender {
        Masculine = 0,
        Feminine = 1,
        Neutral = 2
    }
    class BaseCurrency {
        get gender(): Gender;
        get centsGender(): Gender;
    }
    class Currency extends BaseCurrency {
        get dollars(): string[];
        get cents(): string[];
        get dollarOne(): string;
        get dollarTwo(): string;
        get dollarFive(): string;
        get centOne(): string;
        get centTwo(): string;
        get centFive(): string;
    }
    class NumToWordHelper {
        static maxValue: number;
        private static addWord;
        static addWords(integerString: string, decimalString: string, mainCurrency: string, centCurrency: string, postCurrency: string): string;
        static determinateCurrencies(culture: CultureInfo, currencyISO: string, integerPart: number, decimalPart: number, REFmainCurrency: any, REFcentCurrency: any): void;
    }
    function NumToWordException(message: string, num: number): string;
    class Resource {
        private static resourceMan;
        private static resourceCulture;
        static get resourceManager(): ResourceManager;
        static get culture(): CultureInfo;
        static set culture(value: CultureInfo);
        static get eurBigSeparator(): string;
        static get eurCentGender(): string;
        static get eurCentPlural(): string;
        static get EURCentSingle(): string;
        static get EURGender(): string;
        static get EURPlural(): string;
        static get EURSingle(): string;
        static get GBPBigSeparator(): string;
        static get GBPCentGender(): string;
        static get GBPCentPlural(): string;
        static get GBPCentSingle(): string;
        static get GBPGender(): string;
        static get GBPPlural(): string;
        static get GBPSingle(): string;
        static get TooLongError(): string;
    }
    class Convert {
        static toRoman(value: number): string;
        static toABC(value: number): string;
        static toABCNumeric(value: number): string;
        static toABCRu(value: number): string;
        static toArabic(value: number | string, useEasternDigits: boolean): string;
    }
    class EngineHelper {
        static joinColumnContent(source: StiBusinessObject | StiDataSource, columnName: string, delimiter: string, distinct?: boolean): string;
        static toQueryString<T>(list: T[], quotationMark: string, dateTimeFormat: string): string;
    }
    class MonthToStr {
        private static months;
        private static defaultUpperCaseList;
        private static cultureIndexes;
        static monthName(dateTime: DateTime, cultureOrIsLocalized?: string | boolean, upperCase?: boolean): string;
        static addCulture(monthsNames: string[], cultureNames: string[], defaultUpperCase: boolean): void;
        static MonthToStr(): void;
    }
    class DayOfWeekToStr {
        private static days;
        private static defaultUpperCaseList;
        private static cultureIndexes;
        static dayOfWeek(date: DateTime, cultureOrLocalized?: string | boolean, upperCase?: boolean): string;
        static addCulture(monthsNames: string[], cultureNames: string[], defaultUpperCase: boolean): void;
        static DayOfWeekToStr(): void;
    }
}
declare namespace Stimulsoft.Report {
    let IStiAlias: System.Interface<IStiName>;
    interface IStiAlias {
        alias: string;
    }
}
declare namespace Stimulsoft.Report {
    let IStiIgnoryStyle: System.Interface<IStiIgnoryStyle>;
    interface IStiIgnoryStyle {
    }
}
declare namespace Stimulsoft.Report {
    let IStiInherited: System.Interface<IStiInherited>;
    interface IStiInherited {
        inherited: boolean;
    }
}
declare namespace Stimulsoft.Report {
    let IStiName: System.Interface<IStiName>;
    interface IStiName {
        name: string;
    }
}
declare namespace Stimulsoft.Report {
    let IStiStateSaveRestore: System.Interface<IStiStateSaveRestore>;
    interface IStiStateSaveRestore {
        saveState(stateName: string): any;
        restoreState(stateName: string): any;
        clearAllStates(): any;
    }
}
declare namespace Stimulsoft.Report {
    class StiCells {
        clear(): void;
        private getRow;
        private rows;
        gett(x: number, y: number): number;
        distX: number;
        distY: number;
        setCell(x: number, y: number, value: number): void;
        private report;
        constructor(report: StiReport);
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiBaseCondition extends StiFilter {
        implements(): any[];
        private _tag;
        get tag(): any;
        set tag(value: any);
        constructor(item?: StiFilterItem, column?: string, condition?: StiFilterCondition, value1?: string, value2?: string, dataType?: StiFilterDataType, expression?: string);
    }
}
declare namespace Stimulsoft.Report {
    import StiConditionsCollection = Stimulsoft.Report.Components.StiConditionsCollection;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiConditionsHelper {
        static getConditions(comps: StiComponentsCollection, REFglobalConditions?: any): StiConditionsCollection;
        static setConditions(comps: StiComponentsCollection, conditions: StiConditionsCollection, globalConditions: Hashtable): void;
        private static setConditionAllComponents;
    }
}
declare namespace Stimulsoft.Report {
    class StiDpiHelper {
        private static LOGPIXELSX;
        private static LOGPIXELSY;
        private static _deviceCapsDpi;
        private static _graphicsDpi;
        private static _graphicsRichTextDpi;
        static get deviceCapsDpi(): number;
        static get graphicsDpi(): number;
        static get graphicsRichTextDpi(): number;
        private static getDpi;
        private static getRegistryValue;
        static get deviceCapsScale(): number;
        static get graphicsScale(): number;
        static get graphicsRichTextScale(): number;
        static get needDeviceCapsScale(): boolean;
        static get needGraphicsScale(): boolean;
        static get needGraphicsRichTextScale(): boolean;
    }
}
declare namespace Stimulsoft.Report {
    class StiEditableItem {
        private _pageIndex;
        get pageIndex(): number;
        set pageIndex(value: number);
        private _position;
        get position(): number;
        set position(value: number);
        private _componentName;
        get componentName(): string;
        set componentName(value: string);
        private _textValue;
        get textValue(): string;
        set textValue(value: string);
        constructor(pageIndex: number, position: number, componentName: string, textValue: string);
    }
    class StiEditableItemsContainer {
        private _items;
        get items(): any[];
    }
}
declare namespace Stimulsoft.Report {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiFileImageCache {
        private static imageCache;
        static createNewCache(): string;
        static getImageCacheName(cache: string, cacheImageGuid: string): string;
        static saveImage(image: Image, path: string): void;
        static loadImage(path: string): Image;
        static exist(cacheGuid: string): boolean;
        static clear(): void;
        static remove(path: string): any;
    }
}
declare namespace Stimulsoft.Report {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImageCache {
        imageStore: Image[];
        imagePackedStore: number[][];
        imageMaskStore: number[][];
        imageIndex: number[];
        imageFormatStore: ImageFormat[];
        private imageHashTable;
        private _useImageComparer;
        private _useImageCompression;
        private _useImageTransparency;
        private _imageSaveFormat;
        private _imageQuality;
        private static crcSeed;
        private static crcTable;
        clear(): void;
        addImageIntRaw(image: Image, imageFormat: Stimulsoft.System.Drawing.Imaging.ImageFormat): number;
        addImageInt(image: Image, imageFormat?: ImageFormat): number;
        constructor(useImageComparer: boolean, useImageCompression?: boolean, imageFormat?: ImageFormat, imageQuality?: number, useImageTransparency?: boolean);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDatabaseCollection extends CollectionBase<StiDatabase> implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        indexOf(data: StiDatabase | string): number;
        remove(param: StiDatabase | string | any): void;
        getByName(name: string): StiDatabase;
        setByName(name: string, value: StiDatabase): void;
        clone(): StiDatabaseCollection;
        memberwiseClone(): StiDatabaseCollection;
        private dictionary;
        constructor(dictionary: StiDictionary);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    enum StiVariableInitBy {
        Value = 0,
        Expression = 1
    }
    enum StiVariableSortField {
        Key = 0,
        Label = 1
    }
    enum StiVariableSortDirection {
        None = 0,
        Asc = 1,
        Desc = 2
    }
    enum StiDateTimeType {
        Date = 0,
        DateAndTime = 1,
        Time = 2
    }
    enum StiItemsInitializationType {
        Items = 0,
        Columns = 1
    }
    enum StiTypeMode {
        Value = 0,
        NullableValue = 1,
        List = 2,
        Range = 3
    }
    enum StiSortOrder {
        Asc = 0,
        Desc = 1
    }
    enum StiAutoSynchronizeMode {
        None = 0,
        IfDictionaryEmpty = 1,
        Always = 2
    }
    enum StiRestrictionTypes {
        None = 0,
        DenyEdit = 1,
        DenyDelete = 2,
        DenyMove = 4,
        DenyShow = 8
    }
    enum StiDataType {
        BusinessObject = 0,
        DataSource = 1,
        DataRelation = 2,
        DataColumn = 3,
        Database = 4,
        Resource = 5,
        Variable = 6,
        Total = 7
    }
    enum StiTotalEvent {
        Never = 0,
        OnEachRecord = 1,
        OnGroupChanged = 2,
        OnPageChanged = 3,
        OnColumnChanged = 4,
        OnEachNewBand = 5,
        OnExpressionChanged = 6
    }
    enum StiResourceType {
        Image = 0,
        Csv = 1,
        Dbf = 2,
        Json = 3,
        Xml = 4,
        Xsd = 5,
        Excel = 6,
        Rtf = 7,
        Txt = 8,
        Report = 9,
        ReportSnapshot = 10,
        FontTtc = 11,
        FontTtf = 12,
        FontOtf = 13,
        FontEot = 14,
        FontWoff = 15,
        Pdf = 16,
        Word = 17,
        Map = 18,
        Gis = 19
    }
    enum StiPropertiesProcessingType {
        All = 0,
        Browsable = 1
    }
    enum StiFieldsProcessingType {
        All = 0,
        Browsable = 1
    }
    enum StiConnectionOrder {
        None = 0,
        Standard = 1,
        Sql = 2
    }
    enum StiSqlSourceType {
        Table = 0,
        StoredProcedure = 1
    }
    enum StiColumnsSynchronizationMode {
        KeepAbsentColumns = 0,
        RemoveAbsentColumns = 1
    }
    enum StiSelectionMode {
        FromVariable = 0,
        Nothing = 1,
        First = 2
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    import StiService = Stimulsoft.Base.Services.StiService;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiDataAdapterService extends StiService {
        get serviceCategory(): string;
        get serviceType(): Type;
        isObjectAdapter: boolean;
        get name(): string;
        getDatabaseSpecificName(name: string): string;
        getDataCategoryName(data: StiData): string;
        static getDataAdapter(dataSource: StiDataSource): StiDataAdapterService;
        static getDataAdapter2(data: StiData): StiDataAdapterService;
        create(dictionary: StiDictionary, addToDictionary?: boolean): StiDataSource;
        getDataSourceType(): Type;
        getDataTypes(): Type[];
        isAdapterDataType(type: Type): boolean;
        getColumnsFromDataAsync(data: StiData, dataSource: StiDataSource, connectionString: string): StiPromise<StiDataColumnsCollection>;
        getColumnsFromData(data: StiData, dataSource: StiDataSource, connectionString: string): StiDataColumnsCollection;
        getParametersFromData(data: StiData, dataSource: StiDataSource): StiDataParametersCollection;
        setDataSourceNames(data: StiData, dataSource: StiDataSource): void;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): StiPromise<void>;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDataStoreSource extends StiDataSource implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        getCategoryName(): string;
        get dataName(): string;
        set dataName(value: string);
        private _nameInSource;
        get nameInSource(): string;
        set nameInSource(value: string);
        constructor(nameInSource?: string, name?: string, alias?: string, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Type = Stimulsoft.System.Type;
    class StiDataTableSource extends StiDataStoreSource implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        getCategoryName(): string;
        getDataAdapterType(): Type;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiUndefinedDataSource extends StiDataTableSource {
        createNew(): StiDataSource;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiPromise = Stimulsoft.System.StiPromise;
    import List = Stimulsoft.System.Collections.List;
    class StiDataSourcesCollection extends CollectionBase<StiDataSource> implements IStiJsonReportObject, ICloneable, IComparer<any> {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private dictionary;
        private directionFactor;
        compare(x: any, y: any): number;
        private _cachedDataSources;
        get cachedDataSources(): Hashtable;
        fetchAllDataTransformations(): List<StiDataTransformation>;
        fetchAllVirtualDataSources(): List<StiVirtualSource>;
        add(dataSource: StiDataSource): void;
        contains(dataSource: StiDataSource | string): boolean;
        remove(dataSource: StiDataSource): void;
        getByName(name: string): StiDataSource;
        getByXmlRef(xmlRef: string): StiDataSource;
        setByName(name: string, value: StiDataSource): void;
        clone(): any;
        sort(order?: StiSortOrder, sortColumns?: boolean): void;
        clearParametersExpression(): void;
        connectAsync(loadData: boolean, datas?: StiDataCollection): StiPromise<void>;
        connect(loadData: boolean, datas?: StiDataCollection): void;
        disconnect(): void;
        constructor(dictionary: StiDictionary);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiDataRelationsCollection extends CollectionBase<StiDataRelation> implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiDataRelationsCollection;
        private dictionary;
        cachedDataRelations: Hashtable;
        add(relation: StiDataRelation): void;
        contains(relation: StiDataRelation | string): boolean;
        remove(relation: StiDataRelation): void;
        setByIndex(index: number, value: StiDataRelation): void;
        getByName(name: string): StiDataRelation;
        setByName(name: string, value: StiDataRelation): void;
        constructor(dictionary: StiDictionary);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiVariablesCollection extends CollectionBase<StiVariable> implements IComparer<StiVariable>, ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson, report?: StiReport): void;
        loadFromXml(xmlNode: XmlNode, report: StiReport): void;
        private directionFactor;
        compare(x: StiVariable, y: StiVariable): number;
        sort(order?: StiSortOrder): void;
        add(variable: StiVariable): void;
        addRange(variables: StiVariablesCollection): void;
        contains(name: string): boolean;
        containsCategory(name: string): boolean;
        indexOf(data: string | StiVariable): number;
        remove(data: string | StiVariable): void;
        getByName(name: string): StiVariable;
        setByName(name: string, value: StiVariable): void;
        clone(): any;
        moveCategoryTo(fromCategory: string, toCategory: string): void;
        getFirstCategoryIndex(category: string): number;
        getLastCategoryIndex(category: string): number;
        renameCategory(oldName: string, newName: string): void;
        removeCategory(category: string): void;
        getVariablesCount(category: string): number;
    }
}
declare namespace Stimulsoft.Report {
    class StiInheritedReportComparer {
        static compare(report: StiReport, masterReport: StiReport): void;
        private static compareComponents;
        private static getPositionForComponent;
        private static setParent;
        private static compareVariables;
        private static compareDataSources;
        private static compareRelations;
        private static compareDatabases;
        private static compareBusinessObjects;
        private static compareEvents;
    }
}
declare namespace Stimulsoft.Report {
    import Type = Stimulsoft.System.Type;
    class StiLogService {
        clearLogOnStart: boolean;
        writeLogString(s: string): void;
        static write1(message: string): void;
        static write(type: Type, e: any): void;
        private closeWriter;
        private openWriter;
        private first;
    }
}
declare namespace Stimulsoft.Report {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiMetaTag implements ICloneable, IStiJsonReportObject {
        private static implementsStiMetaTag;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(): any;
        name: string;
        tag: string;
        constructor(name: string, tag: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiMetaTagCollection extends CollectionBase<StiMetaTag> implements ICloneable, IStiJsonReportObject {
        private static implementsStiMetaTagCollection;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        add2(name: string, tag: string): void;
        add(metaTag: StiMetaTag): void;
        addRange(metaTags: StiMetaTag[]): void;
        addRange2(metaTags: StiMetaTagCollection): void;
        contains(metaTag: StiMetaTag): boolean;
        indexOf(metaTag: StiMetaTag): number;
        insert(index: number, metaTag: StiMetaTag): void;
        remove(metaTag: StiMetaTag): void;
        getByIndex(index: number): StiMetaTag;
        setByIndex(index: number, value: StiMetaTag): void;
        getByName(name: string): StiMetaTag;
        setByName(name: string, value: StiMetaTag): void;
        clone(): any;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiDisconnectedEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiDisconnectingEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiConnectedEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiConnectingEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IStiAppCell = Stimulsoft.Base.IStiAppCell;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiDisconnectedEvent = Stimulsoft.Report.Events.StiDisconnectedEvent;
    import StiDisconnectingEvent = Stimulsoft.Report.Events.StiDisconnectingEvent;
    import StiConnectedEvent = Stimulsoft.Report.Events.StiConnectedEvent;
    import StiConnectingEvent = Stimulsoft.Report.Events.StiConnectingEvent;
    import EventArgs = Stimulsoft.System.EventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiService = Stimulsoft.Base.Services.StiService;
    import Type = Stimulsoft.System.Type;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiPromise = Stimulsoft.System.StiPromise;
    import IStiAppConnection = Stimulsoft.Base.IStiAppConnection;
    enum Order {
        Name = 100,
        Alias = 200,
        ConnectionString = 300,
        FirstRowIsHeader = 350,
        PathSchema = 400,
        PathData = 500,
        XmlType = 600,
        PromptUserNameAndPassword = 700,
        SaveDataInReportResources = 800
    }
    class StiDatabase extends StiService implements IStiInherited, IStiAppConnection, IStiJsonReportObject, IStiName, IStiAlias, ICloneable, IStiAppCell {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _inherited;
        get inherited(): boolean;
        set inherited(value: boolean);
        getName(): string;
        getKey(): string;
        setKey(key: string): void;
        get serviceCategory(): string;
        get serviceType(): Type;
        protected onConnecting(e: EventArgs): void;
        invokeConnecting(): void;
        connectingEvent: StiConnectingEvent;
        protected onConnected(e: EventArgs): void;
        invokeConnected(): void;
        connectedEvent: StiConnectedEvent;
        protected onDisconnecting(e: EventArgs): void;
        invokeDisconnecting(): void;
        disconnectingEvent: StiDisconnectingEvent;
        protected onDisconnected(e: EventArgs): void;
        invokeDisconnected(): void;
        disconnectedEvent: StiDisconnectedEvent;
        get serviceName(): string;
        set serviceName(value: string);
        private _name;
        get name(): string;
        set name(value: string);
        private _alias;
        get alias(): string;
        set alias(value: string);
        private _key;
        get key(): string;
        set key(value: string);
        get connectionType(): StiConnectionType;
        applyDatabaseInformation(information: StiDatabaseInformation, report: StiReport, informationAll?: StiDatabaseInformation): void;
        getDatabaseInformationAsync(dictionary: StiDictionary): StiPromise<StiDatabaseInformation>;
        getDatabaseInformation(dictionary: StiDictionary): StiDatabaseInformation;
        getDataAdapterType(): Type;
        getDataAdapter(): StiDataAdapterService;
        toString(): string;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        regDataAsync(dictionary: StiDictionary, loadData: boolean): StiPromise<void>;
        createNew(): StiDatabase;
        constructor(name?: string, alias?: string, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiRelationDirection = Stimulsoft.Base.StiRelationDirection;
    import DataSet = Stimulsoft.System.Data.DataSet;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiAppCell = Stimulsoft.Base.IStiAppCell;
    class StiResource implements IStiName, IStiAlias, ICloneable, IStiAppCell, IStiInherited, IStiJsonReportObject {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        clone(): StiResource;
        getKey(): string;
        setKey(key: string): void;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get propName(): string;
        inherited: boolean;
        private _name;
        get name(): string;
        set name(value: string);
        alias: string;
        availableInTheViewer: boolean;
        private _content;
        get content(): number[];
        set content(value: number[]);
        private _packAndEncryptContent;
        get packAndEncryptContent(): string;
        set packAndEncryptContent(value: string);
        key: string;
        type: StiResourceType;
        dataSet: DataSet;
        relationDirection: StiRelationDirection;
        getResourceAsImage(): Image;
        toString(): string;
        getContentType(): string;
        getFileExt(): string;
        createFileDatabase(): StiFileDatabase;
        constructor(name?: string, alias?: string, inherited?: boolean, type?: StiResourceType, content?: number[], availableInTheViewer?: boolean);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import List = Stimulsoft.System.Collections.List;
    class StiDialogInfo implements IStiJsonReportObject {
        jsonLoadedBindingVariableName: string;
        xmlLoadedBindingVariable: XmlNode;
        saveToJsonObject(): StiJson;
        loadFromJsonObject(jObject: StiJson, report?: StiReport): void;
        private _dateTimeType;
        get dateTimeType(): StiDateTimeType;
        set dateTimeType(value: StiDateTimeType);
        sortDirection: StiVariableSortDirection;
        sortField: StiVariableSortField;
        private _itemsInitializationType;
        get itemsInitializationType(): StiItemsInitializationType;
        set itemsInitializationType(value: StiItemsInitializationType);
        private _keysColumn;
        get keysColumn(): string;
        set keysColumn(value: string);
        private _valuesColumn;
        get valuesColumn(): string;
        set valuesColumn(value: string);
        checkedColumn: string;
        private _bindingVariable;
        get bindingVariable(): StiVariable;
        set bindingVariable(value: StiVariable);
        private _bindingValuesColumn;
        get bindingValuesColumn(): string;
        set bindingValuesColumn(value: string);
        private _mask;
        get mask(): string;
        set mask(value: string);
        private _allowUserValues;
        get allowUserValues(): boolean;
        set allowUserValues(value: boolean);
        private _bindingValue;
        get bindingValue(): boolean;
        set bindingValue(value: boolean);
        private _keys;
        get keys(): string[];
        set keys(value: string[]);
        private _values;
        get values(): string[];
        set values(value: string[]);
        checkedStates: boolean[];
        valuesBindingList: List<any>[];
        isDefault(): boolean;
        static convert(value: any): string;
        getDialogInfoItems(type: Stimulsoft.System.Type): List<StiDialogInfoItem>;
        orderBy(items: List<StiDialogInfoItem>): List<StiDialogInfoItem>;
        setDialogInfoItems(items: StiDialogInfoItem[], type: Stimulsoft.System.Type): void;
        constructor();
    }
    class StiDialogInfoItem {
        get componentId(): StiComponentId;
        get propName(): string;
        private _keyObject;
        get keyObject(): any;
        set keyObject(value: any);
        private _keyObjectTo;
        get keyObjectTo(): any;
        set keyObjectTo(value: any);
        valueBinding: List<object>;
        private _value;
        get value(): string;
        set value(value: string);
        checked: boolean;
        toString(dateTimeType: StiDateTimeType): string;
    }
    class StiRangeDialogInfoItem extends StiDialogInfoItem {
    }
    class StiStringDialogInfoItem extends StiDialogInfoItem {
        get componentId(): StiComponentId;
        get key(): string;
        set key(value: string);
    }
    class StiGuidDialogInfoItem extends StiDialogInfoItem {
        get componentId(): StiComponentId;
        get key(): Stimulsoft.System.Guid;
        set key(value: Stimulsoft.System.Guid);
        constructor();
    }
    class StiCharDialogInfoItem extends StiDialogInfoItem {
        get componentId(): StiComponentId;
        get key(): Stimulsoft.System.Char;
        set key(value: Stimulsoft.System.Char);
        constructor();
    }
    class StiBoolDialogInfoItem extends StiDialogInfoItem {
        get componentId(): StiComponentId;
        get key(): boolean;
        set key(value: boolean);
        constructor();
    }
    class StiImageDialogInfoItem extends StiDialogInfoItem {
        get componentId(): StiComponentId;
        get key(): Stimulsoft.System.Drawing.Image;
        set key(value: Stimulsoft.System.Drawing.Image);
        constructor();
    }
    class StiDateTimeDialogInfoItem extends StiDialogInfoItem {
        get componentId(): StiComponentId;
        get key(): Stimulsoft.System.DateTime;
        set key(value: Stimulsoft.System.DateTime);
        constructor();
    }
    class StiTimeSpanDialogInfoItem extends StiDialogInfoItem {
        get componentId(): StiComponentId;
        get key(): Stimulsoft.System.TimeSpan;
        set key(value: Stimulsoft.System.TimeSpan);
        constructor();
    }
    class StiDoubleDialogInfoItem extends StiDialogInfoItem {
        get componentId(): StiComponentId;
        get key(): Stimulsoft.System.Double;
        set key(value: Stimulsoft.System.Double);
        constructor();
    }
    class StiDecimalDialogInfoItem extends StiDialogInfoItem {
        get componentId(): StiComponentId;
        get key(): Stimulsoft.System.Decimal;
        set key(value: Stimulsoft.System.Decimal);
        constructor();
    }
    class StiLongDialogInfoItem extends StiDialogInfoItem {
        get componentId(): StiComponentId;
        get key(): Stimulsoft.System.Long;
        set key(value: Stimulsoft.System.Long);
        constructor();
    }
    class StiExpressionDialogInfoItem extends StiDialogInfoItem {
        get componentId(): StiComponentId;
        get key(): string;
        set key(value: string);
        constructor();
    }
    class StiStringRangeDialogInfoItem extends StiRangeDialogInfoItem {
        get componentId(): StiComponentId;
        get from(): string;
        set from(value: string);
        get to(): string;
        set to(value: string);
        constructor();
    }
    class StiGuidRangeDialogInfoItem extends StiRangeDialogInfoItem {
        get componentId(): StiComponentId;
        get from(): Stimulsoft.System.Guid;
        set from(value: Stimulsoft.System.Guid);
        get to(): Stimulsoft.System.Guid;
        set to(value: Stimulsoft.System.Guid);
        constructor();
    }
    class StiByteArrayRangeDialogInfoItem extends StiRangeDialogInfoItem {
        get componentId(): StiComponentId;
        get from(): number[];
        set form(value: number[]);
        get to(): number[];
        set to(value: number[]);
    }
    class StiCharRangeDialogInfoItem extends StiRangeDialogInfoItem {
        get componentId(): StiComponentId;
        get from(): Stimulsoft.System.Char;
        set from(value: Stimulsoft.System.Char);
        get to(): Stimulsoft.System.Char;
        set to(value: Stimulsoft.System.Char);
        constructor();
    }
    class StiDateTimeRangeDialogInfoItem extends StiRangeDialogInfoItem {
        get componentId(): StiComponentId;
        get from(): Stimulsoft.System.DateTime;
        set from(value: Stimulsoft.System.DateTime);
        get to(): Stimulsoft.System.DateTime;
        set to(value: Stimulsoft.System.DateTime);
        constructor();
    }
    class StiTimeSpanRangeDialogInfoItem extends StiRangeDialogInfoItem {
        get componentId(): StiComponentId;
        get from(): Stimulsoft.System.TimeSpan;
        set from(value: Stimulsoft.System.TimeSpan);
        get to(): Stimulsoft.System.TimeSpan;
        set to(value: Stimulsoft.System.TimeSpan);
        constructor();
    }
    class StiDoubleRangeDialogInfoItem extends StiRangeDialogInfoItem {
        get componentId(): StiComponentId;
        get from(): Stimulsoft.System.Double;
        set from(value: Stimulsoft.System.Double);
        get to(): Stimulsoft.System.Double;
        set to(value: Stimulsoft.System.Double);
        constructor();
    }
    class StiDecimalRangeDialogInfoItem extends StiRangeDialogInfoItem {
        get componentId(): StiComponentId;
        get from(): Stimulsoft.System.Decimal;
        set from(value: Stimulsoft.System.Decimal);
        get to(): Stimulsoft.System.Decimal;
        set to(value: Stimulsoft.System.Decimal);
        constructor();
    }
    class StiLongRangeDialogInfoItem extends StiRangeDialogInfoItem {
        get componentId(): StiComponentId;
        get from(): Stimulsoft.System.Long;
        set from(value: Stimulsoft.System.Long);
        get to(): Stimulsoft.System.Long;
        set to(value: Stimulsoft.System.Long);
        constructor();
    }
    class StiExpressionRangeDialogInfoItem extends StiRangeDialogInfoItem {
        get componentId(): StiComponentId;
        get from(): string;
        set from(value: string);
        get to(): string;
        set to(value: string);
        constructor();
    }
}
declare namespace Stimulsoft.Report {
    import Range = Stimulsoft.Report.Range;
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    class RangeConverter {
        get getPropertiesSupported(): boolean;
        static rangeToString(range: Range): string;
        static stringToRange(str: string): Range;
        convertTo(context: any, culture: CultureInfo, value: any, destinationType: Stimulsoft.System.Type): any;
        canConvertFrom(context: any, sourceType: Stimulsoft.System.Type): boolean;
        canConvertTo(context: any, destinationType: Stimulsoft.System.Type): boolean;
        convertFrom(context: any, culture: CultureInfo, value: any): any;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiAppCell = Stimulsoft.Base.IStiAppCell;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import DateTime = Stimulsoft.System.DateTime;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiName = Stimulsoft.Report.IStiName;
    import StiExpression = Stimulsoft.Report.Expressions.StiExpression;
    import Type = Stimulsoft.System.Type;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiDialogInfo = Stimulsoft.Report.Dictionary.StiDialogInfo;
    import IStiAppVariable = Stimulsoft.Base.IStiAppVariable;
    import IStiAppAlias = Stimulsoft.Base.IStiAppAlias;
    class StiVariable extends StiExpression implements IStiName, IStiAlias, IStiInherited, ICloneable, IStiAppCell, IStiAppVariable, IStiAppAlias, IStiJsonReportObject {
        implements(): any[];
        private convertTypeToJsonString;
        private convertJsonStringToType;
        saveToJsonObject(): StiJson;
        loadFromJsonObject(jObject: StiJson, report?: StiReport): void;
        static loadFromXml(xmlNode: XmlNode, report: StiReport): StiVariable;
        static convertFromStringToDialogInfo(str: string, report: StiReport): StiDialogInfo;
        private static parseStringArray;
        private static parseBoolArray;
        getValue(): any;
        getName(): string;
        getKey(): string;
        setKey(key: string): void;
        getAlias(): string;
        private _inherited;
        get inherited(): boolean;
        set inherited(value: boolean);
        private _name;
        get name(): string;
        set name(value: string);
        get applyFormat(): boolean;
        private _dialogInfo;
        get dialogInfo(): StiDialogInfo;
        set dialogInfo(value: StiDialogInfo);
        private _alias;
        get alias(): string;
        set alias(value: string);
        private _type;
        get type(): Type;
        set type(value: Type);
        private _readOnly;
        get readOnly(): boolean;
        set readOnly(value: boolean);
        private _requestFromUser;
        get requestFromUser(): boolean;
        set requestFromUser(value: boolean);
        private _allowUseAsSqlParameter;
        get allowUseAsSqlParameter(): boolean;
        set allowUseAsSqlParameter(value: boolean);
        private _category;
        get category(): string;
        set category(value: string);
        private _description;
        get description(): string;
        set description(value: string);
        get isCategory(): boolean;
        get valueObject(): any;
        set valueObject(value: any);
        get initByExpressionFrom(): string;
        set initByExpressionFrom(value: string);
        get initByExpressionTo(): string;
        set initByExpressionTo(value: string);
        getValueProp(): string;
        setValueProp(value: string): void;
        get function(): boolean;
        set function(value: boolean);
        private _initBy;
        get initBy(): StiVariableInitBy;
        set initBy(value: StiVariableInitBy);
        private _selection;
        get selection(): StiSelectionMode;
        set selection(value: StiSelectionMode);
        private _key;
        get key(): string;
        set key(value: string);
        private getRangeValues;
        static getValue(str: string, type: Type): any;
        private setValue;
        getNativeValue(): string;
        static getDateTimeFromValue(value: string): DateTime;
        static getValueFromDateTime(value: Stimulsoft.System.DateTime): string;
        eval(report: StiReport): any;
        toString(): string;
        constructor(category?: string, name?: string, alias?: string, description?: string, typeT?: Type, value?: string, readOnly?: boolean, initBy?: StiVariableInitBy, requestFromUser?: boolean, dialogInfo?: StiDialogInfo, key?: string, allowUseAsSqlParameter?: boolean, selection?: StiSelectionMode);
    }
}
declare namespace Stimulsoft.Report {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    enum StiNamingRule {
        Simple = 0,
        Advanced = 1
    }
    class StiNameCreation {
        static get namingRule(): StiNamingRule;
        static set namingRule(value: StiNamingRule);
        private static removeSpacesFromName;
        static createSimpleName(report: StiReport, baseName: string): string;
        static createName(report: StiReport, baseName: string, addOne?: boolean, removeIncorrectSymbols?: boolean, forceAdvancedNamingRule?: boolean): string;
        static createResourceName(report: StiReport, baseName: string): string;
        static createConnectionName(report: StiReport, baseName: string): string;
        static createDataSourcesName(report: StiReport, baseName: string): string;
        static isTableDataSourcesExists(report: StiReport, name: string): boolean;
        static isResourceNameExists(report: StiReport, name: string): boolean;
        static isConnectionNameExists(report: StiReport, name: string): boolean;
        static createColumnName(dataSource: StiDataSource, baseName: string): string;
        static isColumnNameExists(dataSource: StiDataSource, name: string): boolean;
        static isValidName(report: StiReport, name: string): boolean;
        static exists(checkedObject: any, report: StiReport, name: string): boolean;
        static checkName(checkedObject: any, report: StiReport, name: string, messageBoxCaption: string, isValid?: boolean): boolean;
        private static getObjectWithName;
        static generateName1(report: StiReport, localizedName: string, name: string): string;
        static generateName2(report: StiReport, localizedName: string, type: Stimulsoft.System.Type): string;
        static generateName(component: StiComponent): string;
        static generateName4(relation: StiDataRelation): string;
        static generateName5(dataSource: StiDataSource): string;
    }
}
declare namespace Stimulsoft.Report.CodeDom {
    class StiCodeGenerator {
        private static keywordsHashtable;
        private static keywords;
        private static reservedWordsHashtable;
        private static reservedWords;
        static isReservedWordExist(value: string): boolean;
        static isKeywordExist(value: string): boolean;
        quoteSnippetString(value: string): string;
        static init(): void;
    }
}
declare namespace Stimulsoft.Report {
    class StiNameValidator {
        private static cache;
        static correctName(str: string, checkKeywords?: boolean, report?: StiReport): string;
        private static checkKeyword;
        static correctBusinessObjectName(str: string): string;
    }
}
declare namespace Stimulsoft.Report {
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    let IStiGlobalizationManager: System.Interface<IStiGlobalizationManager>;
    interface IStiGlobalizationManager {
        culture: CultureInfo;
        getString(name: string): string;
        getObject(name: string): any;
    }
}
declare namespace Stimulsoft.Report {
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    class StiNullGlobalizationManager implements IStiGlobalizationManager {
        private _culture;
        get culture(): CultureInfo;
        set culture(value: CultureInfo);
        getString(name: string): string;
        getObject(name: string): any;
        constructor();
    }
}
declare namespace Stimulsoft.Report {
    class StiNullValuesHelper {
        static isNull(report: StiReport, dataColumn: string): boolean;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    let IStiScaleBase: System.Interface<IStiScaleBase>;
    interface IStiScaleBase {
        prepare(gauge: IStiGauge): any;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    let IStiRangeBase: System.Interface<IStiRangeBase>;
    interface IStiRangeBase {
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    let IStiGaugeElement: System.Interface<IStiGaugeElement>;
    interface IStiGaugeElement {
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    let IStiCustomValueBase: System.Interface<IStiCustomValueBase>;
    interface IStiCustomValueBase {
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiDataStoreAdapterService extends StiDataAdapterService {
        setDataSourceNames(data: StiData, dataSource: StiDataSource): void;
        create(dictionary: StiDictionary, addToDictionary?: boolean): StiDataSource;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiDataLeader {
        private static fetchAll;
        static regData(database: StiDatabase, dictionary: StiDictionary, loadData: boolean): void;
        static regDataAsync(database: StiDatabase, dictionary: StiDictionary, loadData: boolean): StiPromise<void>;
        private static regDataAfter;
        private static regDataAfterAsync;
        static existsInCache(database: StiDatabase, dictionary: StiDictionary): boolean;
        static getColumnsFromData(adapter: StiDataAdapterService, data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        static getColumnsFromDataAsync(adapter: StiDataAdapterService, data: StiData, dataSource: StiDataSource): StiPromise<StiDataColumnsCollection>;
        static connectDataSourceToData(adapter: StiDataAdapterService, dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
        static connectDataSourceToDataAsync(adapter: StiDataAdapterService, dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): StiPromise<void>;
        static retrieveDataAsync(dataSource: StiSqlSource, schemaOnly?: boolean): StiPromise<void>;
        static connect(dataSource: StiDataSource, datas: StiDataCollection, loadData?: boolean): void;
        static connectAsync(dataSource: StiDataSource, datas: StiDataCollection, loadData?: boolean): StiPromise<void>;
        static connectAsync2(dataSource: StiDataSource, datas: StiDataCollection, loadData?: boolean): Promise<void>;
        static disconnect(dataSource: StiDataSource): void;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import StiPromise = Stimulsoft.System.StiPromise;
    type StiSqlAdapterResultType = {
        columns: string[];
        rows: {}[];
        types: string[];
    };
    class StiSqlAdapterService extends StiDataStoreAdapterService {
        parameters: Hashtable<string, {
            name: string;
            value: string | number;
        }>;
        get url(): string;
        get serviceName(): string;
        get name(): string;
        getDatabaseSpecificName(name: string): string;
        getDataCategoryName(data: StiData): string;
        getColumnsFromDataAsync(data: StiData, dataSource: StiDataSource, connectionString: string): StiPromise<StiDataColumnsCollection>;
        getParametersFromData(data: StiData, dataSource: StiDataSource): StiDataParametersCollection;
        getDataSourceType(): Stimulsoft.System.Type;
        applyParametersToSqlSourse(dictionary: StiDictionary, sqlSource: StiSqlSource): void;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): StiPromise<void>;
        static getStringCommand(command: any): string;
        callRemoteApi(command: any, timeout: number): StiPromise<string>;
        private static callTurn;
        process(report: StiReport, command: any): StiPromise<any>;
        testConnectionAsync(report: StiReport, connectionString: string): StiPromise<string>;
        createConnectionInDataStore(dictionary: StiDictionary, database: StiSqlDatabase): void;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): StiPromise<StiDataSchema>;
        retrieveDataAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString: string): StiPromise<DataTable>;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiMySqlAdapterService extends StiSqlAdapterService {
        get name(): string;
        getDatabaseSpecificName(name: string): string;
        getDataSourceType(): Stimulsoft.System.Type;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): StiPromise<StiDataSchema>;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    let IStiTextFormat: System.Interface<IStiTextFormat>;
    let ImplementsIStiTextFormat: any[];
    interface IStiTextFormat extends IAsIs {
        textFormat: StiFormatService;
    }
}
declare namespace Stimulsoft.Report.Styles {
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiStyle extends StiBaseStyle implements IStiJsonReportObject, IStiTextFormat {
        private static ImplementsStiStyle;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        private _horAlignment;
        get horAlignment(): StiTextHorAlignment;
        set horAlignment(value: StiTextHorAlignment);
        private _vertAlignment;
        get vertAlignment(): StiVertAlignment;
        set vertAlignment(value: StiVertAlignment);
        private _font;
        get font(): Font;
        set font(value: Font);
        private _border;
        get border(): StiBorder;
        set border(value: StiBorder);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _textBrush;
        get textBrush(): StiBrush;
        set textBrush(value: StiBrush);
        textFormat: Stimulsoft.Report.Components.TextFormats.StiFormatService;
        private _allowUseHorAlignment;
        get allowUseHorAlignment(): boolean;
        set allowUseHorAlignment(value: boolean);
        private _allowUseVertAlignment;
        get allowUseVertAlignment(): boolean;
        set allowUseVertAlignment(value: boolean);
        private _allowUseImage;
        get allowUseImage(): boolean;
        set allowUseImage(value: boolean);
        private _allowUseFont;
        get allowUseFont(): boolean;
        set allowUseFont(value: boolean);
        get allowUseBorder(): boolean;
        set allowUseBorder(value: boolean);
        private _allowUseBorderFormatting;
        get allowUseBorderFormatting(): boolean;
        set allowUseBorderFormatting(value: boolean);
        private _allowUseBorderSides;
        get allowUseBorderSides(): boolean;
        set allowUseBorderSides(value: boolean);
        private _allowUseBorderSidesFromLocation;
        get allowUseBorderSidesFromLocation(): boolean;
        set allowUseBorderSidesFromLocation(value: boolean);
        private _allowUseBrush;
        get allowUseBrush(): boolean;
        set allowUseBrush(value: boolean);
        private _allowUseTextBrush;
        get allowUseTextBrush(): boolean;
        set allowUseTextBrush(value: boolean);
        allowUseNegativeTextBrush: boolean;
        allowUseTextFormat: boolean;
        private _allowUseTextOptions;
        get allowUseTextOptions(): boolean;
        set allowUseTextOptions(value: boolean);
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements, componentStyle?: StiBaseStyle): void;
        setStyleToComponent(component: StiComponent): void;
        private _image;
        get image(): Image;
        set image(value: Image);
        negativeTextBrush: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    let IStiIndicatorRangeInfo: System.Interface<IStiIndicatorRangeInfo>;
    interface IStiIndicatorRangeInfo {
    }
}
declare namespace Stimulsoft.Report.Export {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiExportUtils {
        static convertDigitsToArabic(inputString: string, digitsType: StiArabicDigitsType): string;
        private static reportVersion;
        static getReportVersion(): string;
        static saveComponentToString(component: StiComponent, imageFormat?: ImageFormat, imageQuality?: number, imageResolution?: number): string;
        static trimEndWhiteSpace(inputString: string): string;
        static trimEndWhiteSpace2(inputString: string, removeControl: boolean): string;
        static splitString(inputString: string, removeControl: boolean): string[];
        static stringToUrl(input: string): string;
        private static wrongUrlSymbols;
        static additionalData: string;
        private static additionalData2;
        private static cachedAdditionalData2;
        static getAdditionalData2(opacity: number): Image;
        private static positivePatterns;
        private static negativePatterns;
        static getPositivePattern(patternIndex: number): string;
        static getNegativePattern(patternIndex: number): string;
        static makePdfDeflateStream(data: any): Stimulsoft.System.IO.MemoryStream;
        static toHex(num: number): string;
    }
}
declare namespace Stimulsoft.Report.Export {
    enum StiTiffCompressionScheme {
        Default = 20,
        LZW = 2,
        CCITT3 = 3,
        CCITT4 = 4,
        Rle = 5,
        None = 6
    }
    enum StiHtmlExportMode {
        Span = 1,
        Div = 2,
        Table = 3
    }
    enum StiHtmlExportQuality {
        High = 1,
        Low = 2
    }
    enum StiUserAccessPrivileges {
        None = 0,
        PrintDocument = 1,
        ModifyContents = 2,
        CopyTextAndGraphics = 4,
        AddOrModifyTextAnnotations = 8,
        All = 15
    }
    enum StiPdfEncryptionKeyLength {
        Bit40 = 1,
        Bit128 = 2,
        Bit128_r4 = 3,
        Bit256_r5 = 4,
        Bit256_r6 = 5
    }
    enum StiPdfImageCompressionMethod {
        Jpeg = 1,
        Flate = 2,
        Indexed = 3
    }
    enum StiPdfAutoPrintMode {
        None = 1,
        Dialog = 2,
        Silent = 3
    }
    enum StiTxtBorderType {
        Simple = 1,
        UnicodeSingle = 2,
        UnicodeDouble = 3
    }
    enum StiPcxPaletteType {
        Monochrome = 1,
        Color = 2
    }
    enum StiMonochromeDitheringType {
        None = 1,
        FloydSteinberg = 2,
        Ordered = 3
    }
    enum StiImageType {
        Bmp = 1,
        Gif = 2,
        Jpeg = 3,
        Pcx = 4,
        Png = 5,
        Tiff = 6,
        Emf = 7,
        Svg = 8,
        Svgz = 9
    }
    enum StiHtmlType {
        Html = 1,
        Html5 = 2,
        Mht = 3
    }
    enum StiHtmlChartType {
        Image = 1,
        Vector = 2,
        AnimatedVector = 3
    }
    enum StiExcelType {
        ExcelBinary = 1,
        ExcelXml = 2,
        Excel2007 = 3
    }
    enum StiDataType {
        Csv = 1,
        Dbf = 2,
        Dif = 3,
        Sylk = 4,
        Xml = 5,
        Json = 6
    }
    enum StiExportPosition {
        Pdf = 0,
        Xps = 1,
        Ppt2007 = 2,
        Html = 10,
        Html5 = 11,
        Mht = 12,
        Txt = 20,
        Rtf = 21,
        Word2007 = 22,
        Odt = 23,
        Excel = 30,
        ExcelXml = 31,
        Excel2007 = 32,
        Ods = 33,
        Data = 40,
        Dbf = 41,
        Xml = 42,
        Dif = 43,
        Sylk = 44,
        Image = 50,
        Bmp = 50,
        Gif = 51,
        Jpeg = 52,
        Pcx = 53,
        Png = 54,
        Tiff = 55,
        Emf = 60,
        Svg = 61,
        Svgz = 62
    }
    enum StiHtmlExportBookmarksMode {
        BookmarksOnly = 1,
        ReportOnly = 2,
        All = 3
    }
    enum StiDbfCodePages {
        Default = 0,
        USDOS = 437,
        MazoviaDOS = 620,
        GreekDOS = 737,
        InternationalDOS = 850,
        EasternEuropeanDOS = 852,
        IcelandicDOS = 861,
        NordicDOS = 865,
        RussianDOS = 866,
        KamenickyDOS = 895,
        TurkishDOS = 857,
        EasternEuropeanWindows = 1250,
        RussianWindows = 1251,
        WindowsANSI = 1252,
        GreekWindows = 1253,
        TurkishWindows = 1254,
        StandardMacintosh = 10000,
        GreekMacintosh = 10006,
        RussianMacintosh = 10007,
        EasternEuropeanMacintosh = 10029
    }
    enum StiExportDataType {
        String = 0,
        Int = 1,
        Long = 2,
        Float = 3,
        Double = 4,
        Date = 5,
        Bool = 6
    }
    enum StiImageFormat {
        Color = 1,
        Grayscale = 2,
        Monochrome = 3
    }
    enum StiRtfExportMode {
        Table = 4,
        Frame = 1,
        WinWord = 2,
        TabbedText = 3
    }
    enum StiDataExportMode {
        Data = 1,
        Headers = 2,
        DataAndHeaders = 3,
        Footers = 4,
        HeadersFooters = 6,
        DataAndHeadersFooters = 7,
        AllBands = 15
    }
    enum StiWord2007RestrictEditing {
        No = 1,
        ExceptEditableFields = 2,
        Yes = 3
    }
    enum StiExcel2007RestrictEditing {
        No = 1,
        ExceptEditableFields = 2,
        Yes = 3
    }
    enum StiPdfAllowEditable {
        No = 1,
        Yes = 2
    }
    enum StiImageResolutionMode {
        Exactly = 1,
        NoMoreThan = 2,
        Auto = 3
    }
    enum StiPdfComplianceMode {
        None = 0,
        A1 = 1,
        A2 = 2,
        A3 = 3
    }
    enum StiExcelSheetViewMode {
        Normal = 1,
        PageLayout = 2,
        PageBreakPreview = 3
    }
    enum StiPdfZUGFeRDComplianceMode {
        None = 0,
        V1 = 1,
        V2 = 2,
        V2_1 = 3
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiReportCacheProcessingEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiPrintedEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiPrintingEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiExportedEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiExportEventHandler: EventHandler;
    class StiExportEventArgs extends EventArgs {
        exportFormat: StiExportFormat;
        constructor(format: StiExportFormat);
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiRefreshingEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Styles {
    enum StiStyleConditionType {
        ComponentType = 1,
        Placement = 2,
        PlacementNestedLevel = 4,
        ComponentName = 8,
        Location = 16
    }
    enum StiStyleComponentPlacement {
        None = 0,
        ReportTitle = 1,
        ReportSummary = 2,
        PageHeader = 4,
        PageFooter = 8,
        GroupHeader = 16,
        GroupFooter = 32,
        Header = 64,
        Footer = 128,
        ColumnHeader = 256,
        ColumnFooter = 512,
        Data = 1024,
        DataEvenStyle = 2048,
        DataOddStyle = 4096,
        Table = 8192,
        Hierarchical = 16384,
        Child = 32768,
        Empty = 65536,
        Overlay = 131072,
        Panel = 262144,
        Page = 524288,
        AllExeptStyles = 1042431
    }
    enum StiStyleComponentType {
        Text = 1,
        Primitive = 2,
        Image = 4,
        CrossTab = 8,
        Chart = 16,
        CheckBox = 32
    }
    enum StiStyleLocation {
        None = 0,
        TopLeft = 1,
        TopCenter = 2,
        TopRight = 4,
        MiddleLeft = 8,
        MiddleCenter = 16,
        MiddleRight = 32,
        BottomLeft = 64,
        BottomCenter = 128,
        BottomRight = 256,
        Left = 512,
        Right = 1024,
        Top = 2048,
        Bottom = 4096,
        CenterHorizontal = 8192,
        CenterVertical = 16384
    }
    enum StiStyleConditionOperation {
        EqualTo = 0,
        NotEqualTo = 1,
        GreaterThan = 2,
        GreaterThanOrEqualTo = 3,
        LessThan = 4,
        LessThanOrEqualTo = 5,
        Containing = 6,
        NotContaining = 7,
        BeginningWith = 8,
        EndingWith = 9
    }
    enum StiHeatmapFillMode {
        Lightness = 0,
        Darkness = 1
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiExportingEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Styles {
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import IStiCustomStyle = Stimulsoft.Report.Chart.IStiCustomStyle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiStylesCollection extends CollectionBase<StiBaseStyle> implements IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        load(param: string | number[] | XmlNode | any): void;
        loadFile(filePath: string): void;
        saveToJsonString(): string;
        add(style: StiBaseStyle): void;
        clear(): void;
        addRange(styles: StiBaseStyle[] | StiStylesCollection | any): void;
        contains(style: StiBaseStyle | string | any): boolean;
        insert(index: number, style: StiBaseStyle): void;
        remove(style: StiBaseStyle): void;
        setByIndex(index: number, style: StiBaseStyle): void;
        getByName(name: string): StiBaseStyle;
        setByName(name: string, value: StiBaseStyle): void;
        private updateHash;
        getCustomChartStyle(customStyleName: string): IStiCustomStyle;
        getCustomGaugeStyle(customStyleName: string): IStiGaugeStyle;
        private report;
        private hash;
        private needUpdateHash;
        private lastCount;
        constructor(report?: StiReport);
    }
}
declare namespace Stimulsoft.Report.Components.Table {
    enum StiTableStyle {
        StyleNone = 0,
        Style11 = 11,
        Style12 = 12,
        Style13 = 13,
        Style14 = 14,
        Style15 = 15,
        Style16 = 16,
        Style17 = 17,
        Style18 = 18,
        Style19 = 19,
        Style31 = 31,
        Style32 = 32,
        Style33 = 33,
        Style34 = 34,
        Style35 = 35,
        Style36 = 36,
        Style37 = 37,
        Style38 = 38,
        Style39 = 39,
        Style41 = 41,
        Style42 = 42,
        Style43 = 43,
        Style44 = 44,
        Style45 = 45,
        Style46 = 46,
        Style47 = 47,
        Style48 = 48,
        Style49 = 49,
        Style51 = 51,
        Style52 = 52,
        Style53 = 53,
        Style54 = 54,
        Style55 = 55,
        Style56 = 56,
        Style57 = 57,
        Style58 = 58,
        Style59 = 59
    }
    enum StiTablceCellType {
        Text = 0,
        Image = 1,
        CheckBox = 2,
        RichText = 3
    }
    enum StiTableAutoWidth {
        None = 0,
        Page = 1,
        Table = 2
    }
    enum StiTableAutoWidthType {
        None = 0,
        LastColumns = 1,
        FullTable = 2
    }
}
declare namespace Stimulsoft.Report.Components.Table {
    let IStiTableCell: System.Interface<IStiTableCell>;
    interface IStiTableCell {
        joinCells: number[];
        parentJoin: number;
        join: boolean;
        id: number;
        joinWidth: number;
        joinHeight: number;
        merged: boolean;
        changeTopPosition: boolean;
        changeLeftPosition: boolean;
        changeRightPosition: boolean;
        cellType: StiTablceCellType;
        cellDockStyle: StiDockStyle;
        column: number;
        fixedWidth: boolean;
        tableTag: any;
        parentJoinCell: StiComponent;
        getJoinComponentByGuid(id: number): StiComponent;
        getJoinComponentByIndex(index: number): StiComponent;
        containsGuid(id: number): boolean;
        setJoinSize(): any;
        getRealHeightAfterInsertRows(): number;
        getRealHeight(): number;
        getRealTop(): number;
        getRealWidth(): number;
        getRealLeft(): number;
    }
}
declare namespace Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    import Image = Stimulsoft.System.Drawing.Image;
    let StiGetImageDataEventHandler: EventHandler;
    class StiGetImageDataEventArgs extends EventArgs {
        value: Image;
        constructor(image?: Image);
    }
}
declare namespace Stimulsoft.Report.Helpers {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiExpressionHelper {
        static parseText(page: StiPage, text: string): string;
        static parseBool(page: StiPage, text: string): boolean;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiGetImageDataEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiGetImageURLEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Import {
    export class BitConverter {
        static toInt16(value: number[], startIndex: number): number;
        static toUInt16(value: number[], startIndex: number): number;
        static toInt32(value: number[], startIndex: number): number;
        static toUInt32(value: number[], startIndex: number): number;
        static toUInt64(value: number[], startIndex: number): number;
        static toChar(value: number[], startIndex: number): string;
    }
    class DirEntry {
        name: string;
        type: number;
        dIDLeft: number;
        dIDRight: number;
        dIDRoot: number;
        sIDFirstSector: number;
        size: number;
    }
    export class OleContainer {
        data: number[];
        dir: DirEntry[];
        private bigSectorSize;
        private shortSectorSize;
        private minimumStreamSize;
        private bSAT;
        private sSAT;
        private headerSize;
        private sIDFree;
        private sIDEoC;
        private sIDSAT;
        private sIDMSAT;
        private getUInt16;
        private getUInt32;
        private getBigSectorOffset;
        private getShortSectorOffset;
        private getBSatChain;
        private getSSatChain;
        private getBigStreamData;
        private getShortStreamData;
        getStreamData(streamNumber: number): number[];
        clear(): void;
        constructor(inData: number[]);
    }
    export class ObjectHeader {
        private getString;
        private signature;
        private headerSize;
        private objectType;
        private nameLen;
        private classLen;
        private nameOffset;
        private classOffset;
        private objectSizeWidth;
        private objectSizeHeight;
        private oleVersion;
        private format;
        private oleInfoLen;
        name: string;
        class: string;
        oleInfo: string;
        headerLen: number;
        constructor(data: number[]);
    }
    export class OleUnit {
        static oleContainerIdentifier: number;
        static oleLinkIdentifier: number;
        static olePresHeaderLength: number;
        static isOleContainer(data: number[]): boolean;
        static isOleHeader(data: number[]): boolean;
        static checkForOlePres(data: number[]): boolean;
    }
    export {};
}
declare namespace Stimulsoft.Report.Components {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImageHelper {
        static getImageFromObject(imageObject: any, width?: number, height?: number, stretch?: boolean, aspectRatio?: boolean): Image;
        static getImageBytesFromObject(imageObject: any): number[];
        private static getImageName;
        static isXml(data: number[]): boolean;
        static isSvg(data: number[]): boolean;
        static isIcon(data: number[]): boolean;
        static isWmf(data: number[]): boolean;
        static isEmf(data: number[]): boolean;
        static isBmp(data: number[]): boolean;
        static isJpeg(data: number[]): boolean;
        static isGif(data: number[]): boolean;
        static isPng(data: number[]): boolean;
        static isTiff(data: number[]): boolean;
        static isImage(data: any): boolean;
        static isImage2(data: number[]): boolean;
        static isImage3(str: string): boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiView extends StiComponent implements IStiHorAlignment, IStiVertAlignment, IStiBorder, IStiExportImage, IStiExportImageExtended, IStiBrush, IStiJsonReportObject {
        private static ImplementsStiView;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean): StiView;
        private _horAlignment;
        get horAlignment(): StiHorAlignment;
        set horAlignment(value: StiHorAlignment);
        private _vertAlignment;
        get vertAlignment(): StiVertAlignment;
        set vertAlignment(value: StiVertAlignment);
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        private _border;
        get border(): StiBorder;
        set border(value: StiBorder);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        getActualSize(): SizeD;
        getRealSize(): SizeD;
        setPage(value: StiPage): void;
        private _smoothing;
        get smoothing(): boolean;
        set smoothing(value: boolean);
        private _isCachedImage;
        get isCachedImage(): boolean;
        set isCachedImage(value: boolean);
        private _objectToDraw;
        get objectToDraw(): any;
        set objectToDraw(value: any);
        private _imageToDraw;
        get imageToDraw(): Image;
        set imageToDraw(value: Image);
        private _stretch;
        get stretch(): boolean;
        set stretch(value: boolean);
        private _multipleFactor;
        get multipleFactor(): number;
        set multipleFactor(value: number);
        private _aspectRatio;
        get aspectRatio(): boolean;
        set aspectRatio(value: boolean);
        getImageFromSource(): Image;
    }
}
declare namespace Stimulsoft.Report.Helpers {
    enum StiImageType {
        GdiImage = 0,
        SvgObject = 1
    }
    enum StiFontIconSet {
        Rating = 0,
        Quarter = 1,
        Square = 2,
        Star = 3,
        Latin = 4
    }
    enum StiFontIconGroup {
        WebApplicationIcons = 0,
        AccessibilityIcons = 1,
        HandIcons = 2,
        TransportationIcons = 3,
        GenderIcons = 4,
        FileTypeIcons = 5,
        SpinnerIcons = 6,
        FormControlIcons = 7,
        PaymentIcons = 8,
        ChartIcons = 9,
        CurrencyIcons = 10,
        TextEditorIcons = 11,
        DirectionalIcons = 12,
        VideoPlayerIcons = 13,
        BrandIcons = 14,
        MedicalIcons = 15,
        OtherIcons = 16
    }
    enum StiFontIcons {
        Latin5 = 0,
        Latin4 = 1,
        Latin3 = 2,
        Latin2 = 3,
        Latin1 = 4,
        QuarterFull = 5,
        QuarterThreeFourth = 6,
        QuarterHalf = 7,
        QuarterQuarter = 8,
        QuarterNone = 9,
        Rating4 = 10,
        Rating3 = 11,
        Rating2 = 12,
        Rating1 = 13,
        Rating0 = 14,
        Square0 = 15,
        Square1 = 16,
        Square2 = 17,
        Square3 = 18,
        Square4 = 19,
        StarFull = 20,
        StarThreeFourth = 21,
        StarHalf = 22,
        StarQuarter = 23,
        StarNone = 24,
        ArrowDown = 25,
        ArrowRight = 26,
        ArrowRightDown = 27,
        ArrowRightUp = 28,
        ArrowUp = 29,
        Check = 30,
        Circle = 31,
        CircleCheck = 32,
        CircleCross = 33,
        CircleExclamation = 34,
        Cross = 35,
        Rhomb = 36,
        Exclamation = 37,
        Flag = 38,
        Minus = 39,
        Triangle = 40,
        TriangleDown = 41,
        TriangleUp = 42,
        Home = 43,
        Cart = 44,
        Phone = 45,
        Mobile = 46,
        Mug = 47,
        Airplane = 48,
        Man = 49,
        Woman = 50,
        UserTie = 51,
        Truck = 52,
        Earth = 53,
        ManWoman = 54,
        Appleinc = 55,
        Windows8 = 56,
        Glass = 57,
        Music = 58,
        Search = 59,
        EnvelopeO = 60,
        Heart = 61,
        Star = 62,
        StarO = 63,
        User = 64,
        Film = 65,
        ThLarge = 66,
        Th = 67,
        ThList = 68,
        Times = 69,
        SearchPlus = 70,
        SearchMinus = 71,
        PowerOff = 72,
        Signal = 73,
        Cog = 74,
        TrashO = 75,
        FileO = 76,
        ClockO = 77,
        Road = 78,
        Download = 79,
        ArrowCircleODown = 80,
        ArrowCircleOUp = 81,
        Inbox = 82,
        PlayCircleO = 83,
        Repeat = 84,
        Refresh = 85,
        ListAlt = 86,
        Lock = 87,
        FAFlag = 88,
        Headphones = 89,
        VolumeOff = 90,
        VolumeDown = 91,
        VolumeUp = 92,
        Qrcode = 93,
        Barcode = 94,
        Tag = 95,
        Tags = 96,
        Book = 97,
        Bookmark = 98,
        Print = 99,
        Camera = 100,
        Font = 101,
        Bold = 102,
        Italic = 103,
        TextHeight = 104,
        TextWidth = 105,
        AlignLeft = 106,
        AlignCenter = 107,
        AlignRight = 108,
        AlignJustify = 109,
        List = 110,
        Outdent = 111,
        Indent = 112,
        VideoCamera = 113,
        PictureO = 114,
        Pencil = 115,
        MapMarker = 116,
        Adjust = 117,
        Tint = 118,
        PencilSquareO = 119,
        ShareSquareO = 120,
        CheckSquareO = 121,
        Arrows = 122,
        StepBackward = 123,
        FastBackward = 124,
        Backward = 125,
        Play = 126,
        Pause = 127,
        Stop = 128,
        Forward = 129,
        FastForward = 130,
        StepForward = 131,
        Eject = 132,
        ChevronLeft = 133,
        ChevronRight = 134,
        PlusCircle = 135,
        MinusCircle = 136,
        TimesCircle = 137,
        CheckCircle = 138,
        QuestionCircle = 139,
        InfoCircle = 140,
        Crosshairs = 141,
        TimesCircleO = 142,
        CheckCircleO = 143,
        Ban = 144,
        FAArrowLeft = 145,
        FAArrowRight = 146,
        FAArrowUp = 147,
        FAArrowDown = 148,
        Share = 149,
        Expand = 150,
        Compress = 151,
        FAPlus = 152,
        FAMinus = 153,
        Asterisk = 154,
        ExclamationCircle = 155,
        Gift = 156,
        Leaf = 157,
        Fire = 158,
        Eye = 159,
        EyeSlash = 160,
        ExclamationTriangle = 161,
        Plane = 162,
        Calendar = 163,
        Random = 164,
        Comment = 165,
        Magnet = 166,
        ChevronUp = 167,
        ChevronDown = 168,
        Retweet = 169,
        ShoppingCart = 170,
        Folder = 171,
        FolderOpen = 172,
        ArrowsV = 173,
        ArrowsH = 174,
        BarChart = 175,
        TwitterSquare = 176,
        FacebookSquare = 177,
        CameraRetro = 178,
        Key = 179,
        Cogs = 180,
        Comments = 181,
        ThumbsOUp = 182,
        ThumbsODown = 183,
        HeartO = 184,
        SignOut = 185,
        LinkedinSquare = 186,
        ThumbTack = 187,
        ExternalLink = 188,
        SignIn = 189,
        Trophy = 190,
        GithubSquare = 191,
        Upload = 192,
        LemonO = 193,
        SquareO = 194,
        BookmarkO = 195,
        PhoneSquare = 196,
        Twitter = 197,
        Facebook = 198,
        Github = 199,
        Unlock = 200,
        CreditCard = 201,
        Rss = 202,
        HddO = 203,
        Bullhorn = 204,
        Bell = 205,
        Certificate = 206,
        HandORight = 207,
        HandOLeft = 208,
        HandOUp = 209,
        HandODown = 210,
        ArrowCircleLeft = 211,
        ArrowCircleRight = 212,
        ArrowCircleUp = 213,
        ArrowCircleDown = 214,
        Globe = 215,
        Wrench = 216,
        Tasks = 217,
        Filter = 218,
        Briefcase = 219,
        ArrowsAlt = 220,
        Users = 221,
        Link = 222,
        Cloud = 223,
        Flask = 224,
        Scissors = 225,
        FilesO = 226,
        Paperclip = 227,
        FloppyO = 228,
        Square = 229,
        Bars = 230,
        ListUl = 231,
        ListOl = 232,
        Strikethrough = 233,
        Underline = 234,
        Table = 235,
        Magic = 236,
        Pinterest = 237,
        PinterestSquare = 238,
        GooglePlusSquare = 239,
        GooglePlus = 240,
        Money = 241,
        CaretDown = 242,
        CaretUp = 243,
        CaretLeft = 244,
        CaretRight = 245,
        Columns = 246,
        Sort = 247,
        SortDesc = 248,
        SortAsc = 249,
        Envelope = 250,
        Linkedin = 251,
        Undo = 252,
        Gavel = 253,
        Tachometer = 254,
        CommentO = 255,
        CommentsO = 256,
        Bolt = 257,
        Sitemap = 258,
        Umbrella = 259,
        Clipboard = 260,
        LightbulbO = 261,
        Exchange = 262,
        CloudDownload = 263,
        CloudUpload = 264,
        UserMd = 265,
        Stethoscope = 266,
        Suitcase = 267,
        BellO = 268,
        Coffee = 269,
        Cutlery = 270,
        FileTextO = 271,
        BuildingO = 272,
        HospitalO = 273,
        Ambulance = 274,
        Medkit = 275,
        FighterJet = 276,
        Beer = 277,
        HSquare = 278,
        PlusSquare = 279,
        AngleDoubleLeft = 280,
        AngleDoubleRight = 281,
        AngleDoubleUp = 282,
        AngleDoubleDown = 283,
        AngleLeft = 284,
        AngleRight = 285,
        AngleUp = 286,
        AngleDown = 287,
        Desktop = 288,
        Laptop = 289,
        Tablet = 290,
        CircleO = 291,
        QuoteLeft = 292,
        QuoteRight = 293,
        Spinner = 294,
        Reply = 295,
        GithubAlt = 296,
        FolderO = 297,
        FolderOpenO = 298,
        SmileO = 299,
        FrownO = 300,
        MehO = 301,
        Gamepad = 302,
        KeyboardO = 303,
        FlagO = 304,
        FlagCheckered = 305,
        Terminal = 306,
        Code = 307,
        ReplyAll = 308,
        StarHalfO = 309,
        LocationArrow = 310,
        Crop = 311,
        CodeFork = 312,
        ChainBroken = 313,
        Question = 314,
        Info = 315,
        Superscript = 316,
        Subscript = 317,
        Eraser = 318,
        PuzzlePiece = 319,
        Microphone = 320,
        MicrophoneSlash = 321,
        Shield = 322,
        CalendarO = 323,
        FireExtinguisher = 324,
        Rocket = 325,
        Maxcdn = 326,
        ChevronCircleLeft = 327,
        ChevronCircleRight = 328,
        ChevronCircleUp = 329,
        ChevronCircleDown = 330,
        Html5 = 331,
        Css3 = 332,
        Anchor = 333,
        UnlockAlt = 334,
        Bullseye = 335,
        EllipsisH = 336,
        EllipsisV = 337,
        RssSquare = 338,
        PlayCircle = 339,
        Ticket = 340,
        MinusSquare = 341,
        InusSquareO = 342,
        LevelUp = 343,
        LevelDown = 344,
        CheckSquare = 345,
        PencilSquare = 346,
        ExternalLinkSquare = 347,
        ShareSquare = 348,
        Compass = 349,
        CaretSquareODown = 350,
        CaretSquareOUp = 351,
        CaretSquareORight = 352,
        Eur = 353,
        Gbp = 354,
        Usd = 355,
        Inr = 356,
        Jpy = 357,
        Rub = 358,
        Krw = 359,
        Btc = 360,
        File = 361,
        FileText = 362,
        SortAlphaAsc = 363,
        SortAlphaDesc = 364,
        SortAmountAsc = 365,
        SortAmountDesc = 366,
        SortNumericAsc = 367,
        SortNumericDesc = 368,
        ThumbsUp = 369,
        ThumbsDown = 370,
        YoutubeSquare = 371,
        Youtube = 372,
        Xing = 373,
        XingSquare = 374,
        YoutubePlay = 375,
        Dropbox = 376,
        StackOverflow = 377,
        Instagram = 378,
        Flickr = 379,
        Adn = 380,
        Bitbucket = 381,
        BitbucketSquare = 382,
        Tumblr = 383,
        TumblrSquare = 384,
        LongArrowDown = 385,
        LongArrowUp = 386,
        LongArrowLeft = 387,
        LongArrowRight = 388,
        Apple = 389,
        Windows = 390,
        Android = 391,
        Linux = 392,
        Dribbble = 393,
        Skype = 394,
        Foursquare = 395,
        Trello = 396,
        Female = 397,
        Male = 398,
        Gratipay = 399,
        SunO = 400,
        MoonO = 401,
        Archive = 402,
        Bug = 403,
        Vk = 404,
        Weibo = 405,
        Renren = 406,
        Pagelines = 407,
        StackExchange = 408,
        ArrowCircleORight = 409,
        ArrowCircleOLeft = 410,
        CaretSquareOLeft = 411,
        DotCircleO = 412,
        Wheelchair = 413,
        VimeoSquare = 414,
        Try = 415,
        PlusSquareO = 416,
        SpaceShuttle = 417,
        Slack = 418,
        EnvelopeSquare = 419,
        Wordpress = 420,
        Openid = 421,
        University = 422,
        GraduationCap = 423,
        Yahoo = 424,
        Google = 425,
        Reddit = 426,
        RedditSquare = 427,
        StumbleuponCircle = 428,
        Stumbleupon = 429,
        Delicious = 430,
        Digg = 431,
        PiedPiper = 432,
        PiedPiperAlt = 433,
        Drupal = 434,
        Joomla = 435,
        Language = 436,
        Fax = 437,
        Building = 438,
        Child = 439,
        Paw = 440,
        Spoon = 441,
        Cube = 442,
        Cubes = 443,
        Behance = 444,
        BehanceSquare = 445,
        Steam = 446,
        SteamSquare = 447,
        Recycle = 448,
        Car = 449,
        Taxi = 450,
        Tree = 451,
        Spotify = 452,
        Deviantart = 453,
        Soundcloud = 454,
        Database = 455,
        FilePdfO = 456,
        FileWordO = 457,
        FileExcelO = 458,
        FilePowerpointO = 459,
        FileImageO = 460,
        FileArchiveO = 461,
        FileAudioO = 462,
        FileVideoO = 463,
        FileCodeO = 464,
        Vine = 465,
        Codepen = 466,
        Jsfiddle = 467,
        LifeRing = 468,
        CircleONotch = 469,
        Rebel = 470,
        Empire = 471,
        GitSquare = 472,
        Git = 473,
        HackerNews = 474,
        TencentWeibo = 475,
        Qq = 476,
        Weixin = 477,
        PaperPlane = 478,
        PaperPlaneO = 479,
        History = 480,
        CircleThin = 481,
        Header = 482,
        Paragraph = 483,
        Sliders = 484,
        ShareAlt = 485,
        ShareAltSquare = 486,
        Bomb = 487,
        FutbolO = 488,
        Tty = 489,
        Binoculars = 490,
        Plug = 491,
        Slideshare = 492,
        Twitch = 493,
        Yelp = 494,
        NewspaperO = 495,
        Wifi = 496,
        Calculator = 497,
        Paypal = 498,
        GoogleWallet = 499,
        CcVisa = 500,
        CcMastercard = 501,
        CcDiscover = 502,
        CcAmex = 503,
        CcPaypal = 504,
        CcStripe = 505,
        BellSlash = 506,
        BellSlashO = 507,
        Trash = 508,
        Copyright = 509,
        At = 510,
        Eyedropper = 511,
        PaintBrush = 512,
        BirthdayCake = 513,
        AreaChart = 514,
        PieChart = 515,
        LineChart = 516,
        Lastfm = 517,
        LastfmSquare = 518,
        ToggleOff = 519,
        ToggleOn = 520,
        Bicycle = 521,
        Bus = 522,
        Ioxhost = 523,
        Angellist = 524,
        Cc = 525,
        Ils = 526,
        Meanpath = 527,
        Buysellads = 528,
        Connectdevelop = 529,
        Dashcube = 530,
        Forumbee = 531,
        Leanpub = 532,
        Sellsy = 533,
        Shirtsinbulk = 534,
        Simplybuilt = 535,
        Skyatlas = 536,
        CartPlus = 537,
        CartArrowDown = 538,
        Diamond = 539,
        Ship = 540,
        UserSecret = 541,
        Motorcycle = 542,
        StreetView = 543,
        Heartbeat = 544,
        Venus = 545,
        Mars = 546,
        Mercury = 547,
        Transgender = 548,
        TransgenderAlt = 549,
        VenusDouble = 550,
        MarsDouble = 551,
        VenusMars = 552,
        MarsStroke = 553,
        MarsStrokeV = 554,
        MarsStrokeH = 555,
        Neuter = 556,
        Genderless = 557,
        FacebookOfficial = 558,
        PinterestP = 559,
        Whatsapp = 560,
        Server = 561,
        UserPlus = 562,
        UserTimes = 563,
        Bed = 564,
        Viacoin = 565,
        Train = 566,
        Subway = 567,
        Medium = 568,
        YCombinator = 569,
        OptinMonster = 570,
        Opencart = 571,
        Expeditedssl = 572,
        BatteryFull = 573,
        BatteryThreeQuarters = 574,
        BatteryHalf = 575,
        BatteryQuarter = 576,
        BatteryEmpty = 577,
        MousePointer = 578,
        ICursor = 579,
        ObjectGroup = 580,
        ObjectUngroup = 581,
        StickyNote = 582,
        StickyNoteO = 583,
        CcJcb = 584,
        CcDinersClub = 585,
        Clone = 586,
        BalanceScale = 587,
        HourglassO = 588,
        HourglassStart = 589,
        HourglassHalf = 590,
        HourglassEnd = 591,
        Hourglass = 592,
        HandRockO = 593,
        HandPaperO = 594,
        HandScissorsO = 595,
        HandLizardO = 596,
        HandSpockO = 597,
        HandPointerO = 598,
        HandPeaceO = 599,
        Trademark = 600,
        Registered = 601,
        CreativeCommons = 602,
        Gg = 603,
        GgCircle = 604,
        Tripadvisor = 605,
        Odnoklassniki = 606,
        OdnoklassnikiSquare = 607,
        GetPocket = 608,
        WikipediaW = 609,
        Safari = 610,
        Chrome = 611,
        Firefox = 612,
        Opera = 613,
        InternetExplorer = 614,
        Television = 615,
        Contao = 616,
        Px500 = 617,
        Amazon = 618,
        CalendarPlusO = 619,
        CalendarMinusO = 620,
        CalendarTimesO = 621,
        CalendarCheckO = 622,
        Industry = 623,
        MapPin = 624,
        MapSigns = 625,
        MapO = 626,
        Map = 627,
        Commenting = 628,
        CommentingO = 629,
        Houzz = 630,
        Vimeo = 631,
        BlackTie = 632,
        Fonticons = 633
    }
}
declare namespace Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetImageDataEventArgs = Stimulsoft.Report.Events.StiGetImageDataEventArgs;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import StiGetImageDataEvent = Stimulsoft.Report.Events.StiGetImageDataEvent;
    import StiGetImageURLEvent = Stimulsoft.Report.Events.StiGetImageURLEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiBreakable = Stimulsoft.Report.Components.IStiBreakable;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiImage extends StiView implements IStiBreakable, IStiJsonReportObject {
        private static ImplementsStiImage;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        protected getImageFromFile(): Image;
        protected getImageFromUrl(): Image;
        protected getImageFromDataColumn(): Image;
        protected getImageFromIcon(): Image;
        getImageFromSource(): Image;
        private static propertyCanBreak;
        get canBreak(): boolean;
        set canBreak(value: boolean);
        break(dividedComponent: StiComponent, devideFactor: number, REFdivideLine: any): boolean;
        private _imageURLValue;
        get imageURLValue(): any;
        set imageURLValue(value: any);
        invokeEvents(): void;
        private static eventGetImageURL;
        protected onGetImageURL(e: StiValueEventArgs): void;
        invokeGetImageURL(sender: any, e: StiValueEventArgs): void;
        get getImageURLEvent(): StiGetImageURLEvent;
        set getImageURLEvent(value: StiGetImageURLEvent);
        private static eventGetImageData;
        protected onGetImageData(e: StiGetImageDataEventArgs): void;
        invokeGetImageData(sender: any, e: StiGetImageDataEventArgs): void;
        defaultClientRectangle: RectangleD;
        get getImageDataEvent(): StiGetImageDataEvent;
        set getImageDataEvent(value: StiGetImageDataEvent);
        private static propertyProcessingDuplicates;
        get processingDuplicates(): StiImageProcessingDuplicatesType;
        set processingDuplicates(value: StiImageProcessingDuplicatesType);
        private _imageRotation;
        get imageRotation(): StiImageRotation;
        set imageRotation(value: StiImageRotation);
        private _image;
        get image(): Image;
        set image(value: Image);
        private static propertyMargins;
        get margins(): StiMargins;
        set margins(value: StiMargins);
        private _file;
        get file(): string;
        set file(value: string);
        private _dataColumn;
        get dataColumn(): string;
        set dataColumn(value: string);
        private _imageURL;
        get imageURL(): string;
        set imageURL(value: string);
        private _imageData;
        get imageData(): string;
        set imageData(value: string);
        icon: StiFontIcons;
        iconColor: Color;
        convertImageMargins(rect: RectangleD, convert: boolean): RectangleD;
    }
}
declare namespace Stimulsoft.Report.Components.Table {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiTableCellImage extends StiImage implements IStiTableCell, IStiTableComponent, IStiJsonReportObject {
        private static ImplementsStiTableCellImage;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private loadJoinCellsFromXml;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        clone(cloneProperties: boolean): StiTableCellImage;
        get locked(): boolean;
        get linked(): boolean;
        get canShrink(): boolean;
        set canShrink(value: boolean);
        get canGrow(): boolean;
        set canGrow(value: boolean);
        private _cellDockStyle;
        get cellDockStyle(): StiDockStyle;
        set cellDockStyle(value: StiDockStyle);
        private _parentJoinCell;
        get parentJoinCell(): StiComponent;
        set parentJoinCell(value: StiComponent);
        _joinCells: number[];
        get joinCells(): number[];
        set joinCells(value: number[]);
        _parentJoin: number;
        get parentJoin(): number;
        set parentJoin(value: number);
        _join: boolean;
        get join(): boolean;
        set join(value: boolean);
        private _id;
        get id(): number;
        set id(value: number);
        private _joinWidth;
        get joinWidth(): number;
        set joinWidth(value: number);
        private _joinHeight;
        get joinHeight(): number;
        set joinHeight(value: number);
        get merged(): boolean;
        get changeTopPosition(): boolean;
        get changeLeftPosition(): boolean;
        get changeRightPosition(): boolean;
        private _tableTag;
        get tableTag(): any;
        set tableTag(value: any);
        private _cellType;
        get cellType(): StiTablceCellType;
        set cellType(value: StiTablceCellType);
        private _fixedWidth;
        get fixedWidth(): boolean;
        set fixedWidth(value: boolean);
        private _column;
        get column(): number;
        set column(value: number);
        getJoinComponentByGuid(id: number): StiComponent;
        getJoinComponentByIndex(index: number): StiComponent;
        containsGuid(id: number): boolean;
        private createJoin;
        private deleteJoin;
        private getNewClientRectangle;
        setJoinSize(): void;
        getRealHeightAfterInsertRows(): number;
        getRealHeight(): number;
        getRealTop(): number;
        getRealWidth(): number;
        getRealLeft(): number;
        createNew(): StiComponent;
    }
}
declare namespace Stimulsoft.Report.Components.Table {
    class StiColumnSize {
        private _widths;
        private _fixedColumn;
        setFixedColumn(indexCol: number, width: number): void;
        add(indexCol: number, width: number): void;
        addLastNotFixed(width: number): void;
        subtract(indexCol: number, width: number): void;
        setWidth(indexCol: number, width: number): void;
        getFixed(index: number): boolean;
        get length(): number;
        getCountNotFixedColumn(): number;
        getWidth(indexCol: number): number;
        normalize(): void;
        constructor(size: number);
    }
}
declare namespace Stimulsoft.Report.Components.Table {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTable extends StiDataBand implements IStiTableComponent, IStiJsonReportObject {
        private static ImplementsStiTable;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        clone(cloneProperties: boolean, cloneComponents: boolean): StiTable;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        get canGrow(): boolean;
        set canGrow(value: boolean);
        get localizedName(): string;
        get localizedCategory(): string;
        isConverted: boolean;
        private _dockableTable;
        get dockableTable(): boolean;
        set dockableTable(value: boolean);
        private _autoWidth;
        get autoWidth(): StiTableAutoWidth;
        set autoWidth(value: StiTableAutoWidth);
        private _autoWidthType;
        get autoWidthType(): StiTableAutoWidthType;
        set autoWidthType(value: StiTableAutoWidthType);
        private _rowCount;
        get rowCount(): number;
        set rowCount(value: number);
        private _columnCount;
        get columnCount(): number;
        set columnCount(value: number);
        private _footerRowsCount;
        get footerRowsCount(): number;
        set footerRowsCount(value: number);
        private _headerRowsCount;
        get headerRowsCount(): number;
        set headerRowsCount(value: number);
        get defaultHeightCell(): number;
        private _headerPrintOn;
        get headerPrintOn(): StiPrintOnType;
        set headerPrintOn(value: StiPrintOnType);
        private _headerCanGrow;
        get headerCanGrow(): boolean;
        set headerCanGrow(value: boolean);
        private _headerCanShrink;
        get headerCanShrink(): boolean;
        set headerCanShrink(value: boolean);
        private _headerCanBreak;
        get headerCanBreak(): boolean;
        set headerCanBreak(value: boolean);
        private _headerPrintAtBottom;
        get headerPrintAtBottom(): boolean;
        set headerPrintAtBottom(value: boolean);
        private _headerPrintIfEmpty;
        get headerPrintIfEmpty(): boolean;
        set headerPrintIfEmpty(value: boolean);
        private _headerPrintOnAllPages;
        get headerPrintOnAllPages(): boolean;
        set headerPrintOnAllPages(value: boolean);
        private _headerPrintOnEvenOddPages;
        get headerPrintOnEvenOddPages(): StiPrintOnEvenOddPagesType;
        set headerPrintOnEvenOddPages(value: StiPrintOnEvenOddPagesType);
        private _footerPrintOn;
        get footerPrintOn(): StiPrintOnType;
        set footerPrintOn(value: StiPrintOnType);
        private _footerCanGrow;
        get footerCanGrow(): boolean;
        set footerCanGrow(value: boolean);
        private _footerCanShrink;
        get footerCanShrink(): boolean;
        set footerCanShrink(value: boolean);
        private _footerCanBreak;
        get footerCanBreak(): boolean;
        set footerCanBreak(value: boolean);
        private _footerPrintAtBottom;
        get footerPrintAtBottom(): boolean;
        set footerPrintAtBottom(value: boolean);
        private _footerPrintIfEmpty;
        get footerPrintIfEmpty(): boolean;
        set footerPrintIfEmpty(value: boolean);
        private _footerPrintOnAllPages;
        get footerPrintOnAllPages(): boolean;
        set footerPrintOnAllPages(value: boolean);
        private _footerPrintOnEvenOddPages;
        get footerPrintOnEvenOddPages(): StiPrintOnEvenOddPagesType;
        set footerPrintOnEvenOddPages(value: StiPrintOnEvenOddPagesType);
        private _numberID;
        get numberID(): number;
        set numberID(value: number);
        get columns(): number;
        get columnWidth(): number;
        get columnGaps(): number;
        get minRowsInColumn(): number;
        get minHeight(): number;
        set minHeight(value: number);
        get maxHeight(): number;
        set maxHeight(value: number);
        get minSize(): SizeD;
        set minSize(value: SizeD);
        get rightToLeft(): boolean;
        set rightToLeft(value: boolean);
        get width(): number;
        set width(value: number);
        get height(): number;
        set height(value: number);
        defaultClientRectangle: RectangleD;
        get dockable(): boolean;
        set dockable(value: boolean);
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        changeGrowToHeightAtCell(cell: StiComponent): void;
        private _tableStyle;
        get tableStyle(): StiTableStyle;
        set tableStyle(value: StiTableStyle);
        private refreshTableStyle;
        applyStyleNone(): void;
        private applyStyleNoneForCell;
        private applyStyle1;
        private applyStyle3;
        private applyStyle4;
        private applyStyle5;
        private changeRowCount;
        private changeColumnCount;
        createJoin(REFsumWidth: any, REFsumHeight: any, REFjoinWidth: any, REFjoinHeight: any): number[];
        private getCountSelectedCells;
        private getCountJoinSelectedCells;
        private findLeftSelectedElement;
        private findRightSelectedElement;
        changeTableCellContentInImage(cell: StiTableCell | StiTableCellCheckBox | StiTableCellRichText): void;
        changeTableCellContentInText(cell: StiTableCellImage | StiTableCellCheckBox | StiTableCellRichText): void;
        changeTableCellContentInCheckBox(cell: StiTableCellImage | StiTableCell | StiTableCellRichText): void;
        changeTableCellContentInRichText(cell: StiTableCell | StiTableCellImage | StiTableCellCheckBox): void;
        getColumnForCell(cell: IStiTableCell): number;
        private setCellID;
        createCell(): void;
        private setStyleForCell;
        private addNewRows;
        private deleteLastRows;
        private addTableNewColumns;
        private deleteTableColumns;
        insertColumnToLeft(numberColumn: number): void;
        insertColumnToRight(numberColumn: number): void;
        insertRowAbove(numberRow: number): void;
        insertRowBelow(numberRow: number): void;
        deleteRows(firstRow: number, lastRow: number): StiComponent[];
        deleteColumns(firstColumn: number, lastColumn: number): StiComponent[];
        distributeRows(): void;
        distributeColumns(): void;
        autoSizeCells(): void;
        private resizeWidthCellsAfterChanges;
        private resizeHeightCellsAfterChanges;
        private resizeWidthCell;
        private resizeHeightCell;
        startRenderTableBand(REFnewTableComponents: any): StiDataBand;
        private startRenderTable;
        private reverseCells;
        private setFilter;
        private setInteraction;
        private getParentJoin;
        private isEqualRows;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import List = Stimulsoft.System.Collections.List;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTableOfContents extends StiDataBand implements IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        clone(cloneProperties: boolean): StiBand;
        get priority(): number;
        defaultClientRectangle: RectangleD;
        get toolboxPosition(): number;
        get localizedName(): string;
        helpUrl: () => string;
        get countData(): number;
        set countData(value: number);
        get canBreak(): boolean;
        set canBreak(value: boolean);
        get canGrow(): boolean;
        set canGrow(value: boolean);
        get canShrink(): boolean;
        set canShrink(value: boolean);
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        getHeaderText(): string;
        createNew: () => StiTableOfContents;
        getStylesList(): List<Stimulsoft.Report.Styles.StiStyle>;
        get isFirstInReport(): boolean;
        styles: Styles.StiStylesCollection;
        indent: number;
        reportPointer: string;
        margins: StiMargins;
        shouldSerializeMargins(): boolean;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiBookmark {
        add(name: string): void;
        private _bookmarks;
        get bookmarks(): StiBookmarksCollection;
        set bookmarks(value: StiBookmarksCollection);
        private _text;
        get text(): string;
        set text(value: string);
        private _bookmarkText;
        get bookmarkText(): string;
        set bookmarkText(value: string);
        private _parentComponent;
        get parentComponent(): object;
        set parentComponent(value: object);
        private _componentGuid;
        get componentGuid(): string;
        set componentGuid(value: string);
        private _isManualBookmark;
        get isManualBookmark(): boolean;
        set isManualBookmark(value: boolean);
        private _pageIndex;
        get pageIndex(): number;
        set pageIndex(value: number);
        constructor(text?: string, parentComponent?: any);
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import Size = Stimulsoft.System.Drawing.Size;
    import ContentAlignment = Stimulsoft.System.Drawing.ContentAlignment;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiCondition extends StiBaseCondition implements IStiJsonReportObject, IStiGetFonts {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(): StiCondition;
        memberwiseClone(): StiCondition;
        getFonts(): Font[];
        private _enabled;
        get enabled(): boolean;
        set enabled(value: boolean);
        private _textColor;
        get textColor(): Color;
        set textColor(value: Color);
        private _backColor;
        get backColor(): Color;
        set backColor(value: Color);
        private _font;
        get font(): Font;
        set font(value: Font);
        private _canAssignExpression;
        get canAssignExpression(): boolean;
        set canAssignExpression(value: boolean);
        private _breakIfTrue;
        get breakIfTrue(): boolean;
        set breakIfTrue(value: boolean);
        private _assignExpression;
        get assignExpression(): string;
        set assignExpression(value: string);
        private _style;
        get style(): string;
        set style(value: string);
        private _borderSides;
        get borderSides(): StiConditionBorderSides;
        set borderSides(value: StiConditionBorderSides);
        private _permissions;
        get permissions(): StiConditionPermissions;
        set permissions(value: StiConditionPermissions);
        icon: number[];
        iconAlignment: ContentAlignment;
        iconSize: Size;
        equals(obj: any): boolean;
        constructor(item?: StiFilterItem, column?: string, condition?: StiFilterCondition, value1?: string, value2?: string, dataType?: StiFilterDataType, expression?: string, textColor?: Color, backColor?: Color, font?: Font, enabled?: boolean, canAssignExpression?: boolean, assignExpression?: string, style?: string, borderSides?: StiConditionBorderSides, permissions?: StiConditionPermissions, icon?: number[], iconAlignment?: ContentAlignment, iconSize?: Size);
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiMultiCondition extends StiCondition implements IStiFilter, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadfromXmlDoc(xmlDoc: XmlNode): void;
        clone(): StiMultiCondition;
        private _filterMode;
        get filterMode(): StiFilterMode;
        set filterMode(value: StiFilterMode);
        private _filters;
        get filters(): StiFiltersCollection;
        set filters(value: StiFiltersCollection);
        get filterMethodHandler(): Function;
        set filterMethodHandler(value: Function);
        get filterOn(): boolean;
        get condition(): StiFilterCondition;
        set condition(value: StiFilterCondition);
        get dataType(): StiFilterDataType;
        set dataType(value: StiFilterDataType);
        get column(): string;
        set column(value: string);
        get item(): StiFilterItem;
        set item(value: StiFilterItem);
        get value1(): string;
        set value1(value: string);
        get value2(): string;
        set value2(value: string);
        get expression(): string;
        set expression(value: string);
        equals(obj: any): boolean;
        constructor(textColor?: Color, backColor?: Color, font?: Font, enabled?: boolean, filterMode?: StiFilterMode, filters?: StiFilter[], canAssignExpression?: boolean, assignExpression?: string, style?: string, borderSides?: StiConditionBorderSides);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    let IStiEnumerator: System.Interface<IStiEnumerator>;
    interface IStiEnumerator {
        first(): any;
        prior(): any;
        next(): any;
        last(): any;
        position: number;
        count: number;
        isEof: boolean;
        isBof: boolean;
        isEmpty: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiDataHelper {
        static setData(component: StiComponent, reinit: boolean, masterComponent?: StiComponent): void;
        static needGroupSort(band: StiDataBand): boolean;
        static getFilterEventHandler(component: StiComponent, dataSource: any): any;
        static getFilterExpression(filter: StiFilter, fullColumnName: string, report: StiReport): string;
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiPagesCollection extends CollectionBase<StiPage> implements IStiStateSaveRestore, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        add(page: StiPage): void;
        addV2Internal(page: StiPage): void;
        remove(page: StiPage): any;
        remove(startIndex: number, endCount: number): any;
        getPageWithoutCache(pageIndex: number): StiPage;
        getByName(name: string): StiPage;
        setByName(name: string, page: StiPage): void;
        getComponentByName(componentName: string): StiComponent;
        private static setParent;
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        clearAllStates(): void;
        canUseCacheMode: boolean;
        report: StiReport;
        cacheMode: boolean;
        get containsDashboards(): boolean;
        private quickCachedPages;
        notCachedPages: StiPage[];
        isNotSavedPage(page: StiPage): boolean;
        markPageAsNotSaved(page: StiPage): void;
        getPage(page: StiPage): StiPage;
        savePage(page: StiPage): void;
        constructor(report: StiReport, originalPages?: StiPagesCollection);
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiConditions: System.Interface<IStiConditions>;
    interface IStiConditions {
        conditions: StiConditionsCollection;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import Type = Stimulsoft.System.Type;
    class StiFunctions {
        static removeFunction(functionName: string): void;
        static getFunctionsList(functionName: string): StiFunction[];
        static getFunctionsGrouppedInCategories(): Hashtable;
        static getFunctions(categoryOrIsCompile: string | boolean): StiFunction[];
        static getFunctionsEx(report: StiReport, functionName: string, isCompile: boolean): StiFunction[];
        static getCategories(): string[];
        static getAssebliesOfFunctions(): string[];
        static addFunction(category: string, groupFunctionName: string, functionName: string, description: string, typeOfFunction: string, returnType: Type, returnDescription?: string, argumentTypes?: Type[], argumentNames?: string[], argumentDescriptions?: string[], jsFunction?: Function): StiFunction;
        static StiFunctions(): void;
    }
}
declare namespace Stimulsoft.Report.Engine {
    enum StiTokenType {
        Empty = 0,
        Delimiter = 1,
        Variable = 2,
        SystemVariable = 3,
        DataSourceField = 4,
        BusinessObjectField = 5,
        Number = 6,
        Function = 7,
        Method = 8,
        Property = 9,
        Component = 10,
        Cast = 11,
        String = 12,
        Dot = 13,
        Comma = 14,
        Colon = 15,
        SemiColon = 16,
        Shl = 17,
        Shr = 18,
        Assign = 19,
        Equal = 20,
        NotEqual = 21,
        LeftEqual = 22,
        Left = 23,
        RightEqual = 24,
        Right = 25,
        Not = 26,
        Or = 27,
        And = 28,
        Xor = 29,
        DoubleOr = 30,
        DoubleAnd = 31,
        Question = 32,
        Plus = 33,
        Minus = 34,
        Mult = 35,
        Div = 36,
        Percent = 37,
        LParenthesis = 38,
        RParenthesis = 39,
        LBracket = 40,
        RBracket = 41,
        Identifier = 42,
        Unknown = 43
    }
    enum StiAsmCommandType {
        PushValue = 2000,
        PushVariable = 2001,
        PushSystemVariable = 2002,
        PushDataSourceField = 2003,
        PushBusinessObjectField = 2004,
        PushFunction = 2005,
        PushMethod = 2006,
        PushProperty = 2007,
        PushComponent = 2008,
        PushArrayElement = 2009,
        CopyToVariable = 2010,
        Add = 2020,
        Sub = 2021,
        Mult = 2022,
        Div = 2023,
        Mod = 2024,
        Power = 2025,
        Neg = 2026,
        Cast = 2027,
        Not = 2028,
        CompareLeft = 2029,
        CompareLeftEqual = 2030,
        CompareRight = 2031,
        CompareRightEqual = 2032,
        CompareEqual = 2033,
        CompareNotEqual = 2034,
        Shl = 2035,
        Shr = 2036,
        And = 2037,
        And2 = 2038,
        Or = 2039,
        Or2 = 2040,
        Xor = 2041,
        Jump = 2042,
        JumpTrue = 2043,
        JumpFalse = 2044
    }
    enum StiSystemVariableType {
        Column = 0,
        Line = 1,
        LineThrough = 2,
        LineABC = 3,
        LineRoman = 4,
        GroupLine = 5,
        PageNumber = 6,
        PageNumberThrough = 7,
        PageNofM = 8,
        PageNofMThrough = 9,
        TotalPageCount = 10,
        TotalPageCountThrough = 11,
        IsFirstPage = 12,
        IsFirstPageThrough = 13,
        IsLastPage = 14,
        IsLastPageThrough = 15,
        PageCopyNumber = 16,
        ReportAlias = 17,
        ReportAuthor = 18,
        ReportChanged = 19,
        ReportCreated = 20,
        ReportDescription = 21,
        ReportName = 22,
        Time = 23,
        Today = 24,
        ConditionValue = 25,
        ConditionValue2 = 26,
        ConditionTag = 27,
        Sender = 28,
        DateTimeNow = 29,
        DateTimeToday = 30
    }
    enum StiPropertyType {
        Year = 0,
        Month = 1,
        Day = 2,
        Hour = 3,
        Minute = 4,
        Second = 5,
        Date = 6,
        Length = 7,
        From = 8,
        To = 9,
        FromDate = 10,
        ToDate = 11,
        FromTime = 12,
        ToTime = 13,
        SelectedLine = 14,
        Name = 15,
        TagValue = 16,
        Days = 17,
        Hours = 18,
        Milliseconds = 19,
        Minutes = 20,
        Seconds = 21,
        Ticks = 22,
        TotalDays = 23,
        TotalHours = 24,
        TotalMinutes = 25,
        TotalSeconds = 26,
        TotalMilliseconds = 27,
        Count = 28,
        BusinessObjectValue = 29,
        Position = 30,
        Line = 31,
        Rows = 32
    }
    enum StiFunctionType {
        NameSpace = 0,
        Count = 1,
        CountDistinct = 2,
        Avg = 3,
        AvgD = 4,
        AvgDate = 5,
        AvgI = 6,
        AvgTime = 7,
        Max = 8,
        MaxD = 9,
        MaxDate = 10,
        MaxI = 11,
        MaxStr = 12,
        MaxTime = 13,
        Median = 14,
        MedianD = 15,
        MedianI = 16,
        Min = 17,
        MinD = 18,
        MinDate = 19,
        MinI = 20,
        MinStr = 21,
        MinTime = 22,
        Mode = 23,
        ModeD = 24,
        ModeI = 25,
        Sum = 26,
        SumD = 27,
        SumDistinct = 28,
        SumI = 29,
        SumTime = 30,
        First = 31,
        Last = 32,
        rCount = 33,
        rCountDistinct = 34,
        rAvg = 35,
        rAvgD = 36,
        rAvgDate = 37,
        rAvgI = 38,
        rAvgTime = 39,
        rMax = 40,
        rMaxD = 41,
        rMaxDate = 42,
        rMaxI = 43,
        rMaxStr = 44,
        rMaxTime = 45,
        rMedian = 46,
        rMedianD = 47,
        rMedianI = 48,
        rMin = 49,
        rMinD = 50,
        rMinDate = 51,
        rMinI = 52,
        rMinStr = 53,
        rMinTime = 54,
        rMode = 55,
        rModeD = 56,
        rModeI = 57,
        rSum = 58,
        rSumD = 59,
        rSumDistinct = 60,
        rSumI = 61,
        rSumTime = 62,
        rFirst = 63,
        rLast = 64,
        iCount = 65,
        iCountDistinct = 66,
        iAvg = 67,
        iAvgD = 68,
        iAvgDate = 69,
        iAvgI = 70,
        iAvgTime = 71,
        iMax = 72,
        iMaxD = 73,
        iMaxDate = 74,
        iMaxI = 75,
        iMaxStr = 76,
        iMaxTime = 77,
        iMedian = 78,
        iMedianD = 79,
        iMedianI = 80,
        iMin = 81,
        iMinD = 82,
        iMinDate = 83,
        iMinI = 84,
        iMinStr = 85,
        iMinTime = 86,
        iMode = 87,
        iModeD = 88,
        iModeI = 89,
        iSum = 90,
        iSumD = 91,
        iSumDistinct = 92,
        iSumI = 93,
        iSumTime = 94,
        iFirst = 95,
        iLast = 96,
        riCount = 97,
        riCountDistinct = 98,
        riAvg = 99,
        riAvgD = 100,
        riAvgDate = 101,
        riAvgI = 102,
        riAvgTime = 103,
        riMax = 104,
        riMaxD = 105,
        riMaxDate = 106,
        riMaxI = 107,
        riMaxStr = 108,
        riMaxTime = 109,
        riMedian = 110,
        riMedianD = 111,
        riMedianI = 112,
        riMin = 113,
        riMinD = 114,
        riMinDate = 115,
        riMinI = 116,
        riMinStr = 117,
        riMinTime = 118,
        riMode = 119,
        riModeD = 120,
        riModeI = 121,
        riSum = 122,
        riSumD = 123,
        riSumDistinct = 124,
        riSumI = 125,
        riSumTime = 126,
        riFirst = 127,
        riLast = 128,
        cCount = 129,
        cCountDistinct = 130,
        cAvg = 131,
        cAvgD = 132,
        cAvgDate = 133,
        cAvgI = 134,
        cAvgTime = 135,
        cMax = 136,
        cMaxD = 137,
        cMaxDate = 138,
        cMaxI = 139,
        cMaxStr = 140,
        cMaxTime = 141,
        cMedian = 142,
        cMedianD = 143,
        cMedianI = 144,
        cMin = 145,
        cMinD = 146,
        cMinDate = 147,
        cMinI = 148,
        cMinStr = 149,
        cMinTime = 150,
        cMode = 151,
        cModeD = 152,
        cModeI = 153,
        cSum = 154,
        cSumD = 155,
        cSumDistinct = 156,
        cSumI = 157,
        cSumTime = 158,
        cFirst = 159,
        cLast = 160,
        crCount = 161,
        crCountDistinct = 162,
        crAvg = 163,
        crAvgD = 164,
        crAvgDate = 165,
        crAvgI = 166,
        crAvgTime = 167,
        crMax = 168,
        crMaxD = 169,
        crMaxDate = 170,
        crMaxI = 171,
        crMaxStr = 172,
        crMaxTime = 173,
        crMedian = 174,
        crMedianD = 175,
        crMedianI = 176,
        crMin = 177,
        crMinD = 178,
        crMinDate = 179,
        crMinI = 180,
        crMinStr = 181,
        crMinTime = 182,
        crMode = 183,
        crModeD = 184,
        crModeI = 185,
        crSum = 186,
        crSumD = 187,
        crSumDistinct = 188,
        crSumI = 189,
        crSumTime = 190,
        crFirst = 191,
        crLast = 192,
        ciCount = 193,
        ciCountDistinct = 194,
        ciAvg = 195,
        ciAvgD = 196,
        ciAvgDate = 197,
        ciAvgI = 198,
        ciAvgTime = 199,
        ciMax = 200,
        ciMaxD = 201,
        ciMaxDate = 202,
        ciMaxI = 203,
        ciMaxStr = 204,
        ciMaxTime = 205,
        ciMedian = 206,
        ciMedianD = 207,
        ciMedianI = 208,
        ciMin = 209,
        ciMinD = 210,
        ciMinDate = 211,
        ciMinI = 212,
        ciMinStr = 213,
        ciMinTime = 214,
        ciMode = 215,
        ciModeD = 216,
        ciModeI = 217,
        ciSum = 218,
        ciSumD = 219,
        ciSumDistinct = 220,
        ciSumI = 221,
        ciSumTime = 222,
        ciFirst = 223,
        ciLast = 224,
        criCount = 225,
        criCountDistinct = 226,
        criAvg = 227,
        criAvgD = 228,
        criAvgDate = 229,
        criAvgI = 230,
        criAvgTime = 231,
        criMax = 232,
        criMaxD = 233,
        criMaxDate = 234,
        criMaxI = 235,
        criMaxStr = 236,
        criMaxTime = 237,
        criMedian = 238,
        criMedianD = 239,
        criMedianI = 240,
        criMin = 241,
        criMinD = 242,
        criMinDate = 243,
        criMinI = 244,
        criMinStr = 245,
        criMinTime = 246,
        criMode = 247,
        criModeD = 248,
        criModeI = 249,
        criSum = 250,
        criSumD = 251,
        criSumDistinct = 252,
        criSumI = 253,
        criSumTime = 254,
        criFirst = 255,
        criLast = 256,
        pCount = 257,
        pCountDistinct = 258,
        pAvg = 259,
        pAvgD = 260,
        pAvgDate = 261,
        pAvgI = 262,
        pAvgTime = 263,
        pMax = 264,
        pMaxD = 265,
        pMaxDate = 266,
        pMaxI = 267,
        pMaxStr = 268,
        pMaxTime = 269,
        pMedian = 270,
        pMedianD = 271,
        pMedianI = 272,
        pMin = 273,
        pMinD = 274,
        pMinDate = 275,
        pMinI = 276,
        pMinStr = 277,
        pMinTime = 278,
        pMode = 279,
        pModeD = 280,
        pModeI = 281,
        pSum = 282,
        pSumD = 283,
        pSumDistinct = 284,
        pSumI = 285,
        pSumTime = 286,
        pFirst = 287,
        pLast = 288,
        prCount = 289,
        prCountDistinct = 290,
        prAvg = 291,
        prAvgD = 292,
        prAvgDate = 293,
        prAvgI = 294,
        prAvgTime = 295,
        prMax = 296,
        prMaxD = 297,
        prMaxDate = 298,
        prMaxI = 299,
        prMaxStr = 300,
        prMaxTime = 301,
        prMedian = 302,
        prMedianD = 303,
        prMedianI = 304,
        prMin = 305,
        prMinD = 306,
        prMinDate = 307,
        prMinI = 308,
        prMinStr = 309,
        prMinTime = 310,
        prMode = 311,
        prModeD = 312,
        prModeI = 313,
        prSum = 314,
        prSumD = 315,
        prSumDistinct = 316,
        prSumI = 317,
        prSumTime = 318,
        prFirst = 319,
        prLast = 320,
        piCount = 321,
        piCountDistinct = 322,
        piAvg = 323,
        piAvgD = 324,
        piAvgDate = 325,
        piAvgI = 326,
        piAvgTime = 327,
        piMax = 328,
        piMaxD = 329,
        piMaxDate = 330,
        piMaxI = 331,
        piMaxStr = 332,
        piMaxTime = 333,
        piMedian = 334,
        piMedianD = 335,
        piMedianI = 336,
        piMin = 337,
        piMinD = 338,
        piMinDate = 339,
        piMinI = 340,
        piMinStr = 341,
        piMinTime = 342,
        piMode = 343,
        piModeD = 344,
        piModeI = 345,
        piSum = 346,
        piSumD = 347,
        piSumDistinct = 348,
        piSumI = 349,
        piSumTime = 350,
        piFirst = 351,
        piLast = 352,
        priCount = 353,
        priCountDistinct = 354,
        priAvg = 355,
        priAvgD = 356,
        priAvgDate = 357,
        priAvgI = 358,
        priAvgTime = 359,
        priMax = 360,
        priMaxD = 361,
        priMaxDate = 362,
        priMaxI = 363,
        priMaxStr = 364,
        priMaxTime = 365,
        priMedian = 366,
        priMedianD = 367,
        priMedianI = 368,
        priMin = 369,
        priMinD = 370,
        priMinDate = 371,
        priMinI = 372,
        priMinStr = 373,
        priMinTime = 374,
        priMode = 375,
        priModeD = 376,
        priModeI = 377,
        priSum = 378,
        priSumD = 379,
        priSumDistinct = 380,
        priSumI = 381,
        priSumTime = 382,
        priFirst = 383,
        priLast = 384,
        CountAllLevels = 385,
        CountAllLevelsOnlyChilds = 386,
        CountOnlyChilds = 387,
        Rank = 388,
        Abs = 389,
        Acos = 390,
        Asin = 391,
        Atan = 392,
        Ceiling = 393,
        Cos = 394,
        Div = 395,
        Exp = 396,
        Floor = 397,
        Log = 398,
        Maximum = 399,
        Minimum = 400,
        Round = 401,
        Sign = 402,
        Sin = 403,
        Sqrt = 404,
        Tan = 405,
        Truncate = 406,
        DateDiff = 407,
        DateSerial = 408,
        Day = 409,
        DayOfWeek = 410,
        DayOfYear = 411,
        DaysInMonth = 412,
        DaysInYear = 413,
        Hour = 414,
        Minute = 415,
        Month = 416,
        Second = 417,
        TimeSerial = 418,
        Year = 419,
        MonthName = 420,
        WeekOfYear = 421,
        WeekOfMonth = 422,
        DateToStr = 423,
        DateToStrPl = 424,
        DateToStrRu = 425,
        DateToStrUa = 426,
        DateToStrPt = 427,
        DateToStrPtBr = 428,
        Insert = 429,
        Length = 430,
        Remove = 431,
        Replace = 432,
        Roman = 433,
        Substring = 434,
        ToCurrencyWords = 435,
        ToCurrencyWordsAr = 436,
        ToCurrencyWordsEnGb = 437,
        ToCurrencyWordsEnIn = 438,
        ToCurrencyWordsEs = 439,
        ToCurrencyWordsFr = 440,
        ToCurrencyWordsNl = 441,
        ToCurrencyWordsPl = 442,
        ToCurrencyWordsPt = 443,
        ToCurrencyWordsPtBr = 444,
        ToCurrencyWordsRu = 445,
        ToCurrencyWordsThai = 446,
        ToCurrencyWordsTr = 447,
        ToCurrencyWordsUa = 448,
        ToCurrencyWordsZh = 449,
        ToLowerCase = 450,
        ToProperCase = 451,
        ToUpperCase = 452,
        ToWords = 453,
        ToWordsAr = 454,
        ToWordsEs = 455,
        ToWordsEnIn = 456,
        ToWordsFa = 457,
        ToWordsPl = 458,
        ToWordsPt = 459,
        ToWordsRu = 460,
        ToWordsTr = 461,
        ToWordsUa = 462,
        Trim = 463,
        TryParseDecimal = 464,
        TryParseDouble = 465,
        TryParseLong = 466,
        Arabic = 467,
        Persian = 468,
        ToOrdinal = 469,
        Left = 470,
        Mid = 471,
        Right = 472,
        StrToDateTime = 473,
        StrToNullableDateTime = 474,
        IsNull = 475,
        Next = 476,
        NextIsNull = 477,
        Previous = 478,
        PreviousIsNull = 479,
        IIF = 480,
        Choose = 481,
        Switch = 482,
        ToString = 483,
        Format = 484,
        SystemConvertToBoolean = 485,
        SystemConvertToByte = 486,
        SystemConvertToChar = 487,
        SystemConvertToDateTime = 488,
        SystemConvertToDecimal = 489,
        SystemConvertToDouble = 490,
        SystemConvertToInt16 = 491,
        SystemConvertToInt32 = 492,
        SystemConvertToInt64 = 493,
        SystemConvertToSByte = 494,
        SystemConvertToSingle = 495,
        SystemConvertToString = 496,
        SystemConvertToUInt16 = 497,
        SystemConvertToUInt32 = 498,
        SystemConvertToUInt64 = 499,
        MathRound = 500,
        MathPow = 501,
        AddAnchor = 502,
        GetAnchorPageNumber = 503,
        GetAnchorPageNumberThrough = 504,
        ConvertRtf = 505,
        GetLabel = 506,
        GetParam = 507,
        ParseInt = 508,
        ParseDouble = 509,
        ParseDecimal = 510,
        ParseDateTime = 511,
        ParseTimeSpan = 512,
        StringIsNullOrEmpty = 513,
        StringIsNullOrWhiteSpace = 514,
        EngineHelperJoinColumnContent = 515,
        EngineHelperToQueryString = 516,
        m_Substring = 1000,
        m_ToString = 1001,
        m_ToLower = 1002,
        m_ToUpper = 1003,
        m_IndexOf = 1004,
        m_StartsWith = 1005,
        m_EndsWith = 1006,
        m_Replace = 1007,
        m_Parse = 1008,
        m_Contains = 1009,
        m_GetData = 1010,
        m_ToQueryString = 1011,
        m_AddYears = 1012,
        m_AddMonths = 1013,
        m_AddDays = 1014,
        m_AddHours = 1015,
        m_AddMinutes = 1016,
        m_AddSeconds = 1017,
        m_AddMilliseconds = 1018,
        m_ToShortDateString = 1019,
        m_ToShortTimeString = 1020,
        m_ToLongDateString = 1021,
        m_ToLongTimeString = 1022,
        m_GetCurrentConditionValue = 1023,
        m_Add = 1024,
        m_Subtract = 1025,
        m_MethodNameSpace = 1026,
        op_Add = 2020,
        op_Sub = 2021,
        op_Mult = 2022,
        op_Div = 2023,
        op_Mod = 2024,
        op_Power = 2025,
        op_Neg = 2026,
        op_Cast = 2027,
        op_Not = 2028,
        op_CompareLeft = 2029,
        op_CompareLeftEqual = 2030,
        op_CompareRight = 2031,
        op_CompareRightEqual = 2032,
        op_CompareEqual = 2033,
        op_CompareNotEqual = 2034,
        op_Shl = 2035,
        op_Shr = 2036,
        op_And = 2037,
        op_And2 = 2038,
        op_Or = 2039,
        op_Or2 = 2040,
        op_Xor = 2041,
        UserFunction = 3000
    }
    enum StiMethodType {
        Substring = 1000,
        ToString = 1001,
        ToLower = 1002,
        ToUpper = 1003,
        IndexOf = 1004,
        StartsWith = 1005,
        EndsWith = 1006,
        Replace = 1007,
        Parse = 1008,
        Contains = 1009,
        GetData = 1010,
        ToQueryString = 1011,
        AddYears = 1012,
        AddMonths = 1013,
        AddDays = 1014,
        AddHours = 1015,
        AddMinutes = 1016,
        AddSeconds = 1017,
        AddMilliseconds = 1018,
        ToShortDateString = 1019,
        ToShortTimeString = 1020,
        ToLongDateString = 1021,
        ToLongTimeString = 1022,
        GetCurrentConditionValue = 1023,
        Add = 1024,
        Subtract = 1025,
        MethodNameSpace = 1026
    }
    enum StiParameterNumber {
        Param1 = 1,
        Param2 = 2,
        Param3 = 4,
        Param4 = 8
    }
}
declare namespace Stimulsoft.Report.Engine.StiParser {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import Type = Stimulsoft.System.Type;
    class StiParserMethodInfo {
        name: StiFunctionType;
        number: number;
        arguments: Type[];
        returnType: Type;
        constructor(name: StiFunctionType, numberr: number, argumentss: Type[], returnType?: Type);
    }
    class StiParser_Properties {
        protected get_category(par: any): number;
        protected report: StiReport;
        protected expressionPosition: number;
        private static _typesList;
        static get typesList(): Hashtable;
        private static _systemVariablesList;
        static get systemVariablesList(): Hashtable;
        private static _propertiesList;
        static get propertiesList(): Hashtable;
        private static _functionsList;
        static get functionsList(): Hashtable;
        private static _methodsList;
        static get methodsList(): Hashtable;
        private static _parametersList;
        static get parametersList(): Hashtable;
        private _componentsList;
        get componentsList(): Hashtable;
        private static _methodsHash;
        static get methodsHash(): Hashtable;
        private static _constantsList;
        static get constantsList(): Hashtable;
        protected static namespaceObj: any;
        private static _namespacesList;
        static get namespacesList(): Hashtable;
        private lockUserFunctionsList;
        private _userFunctionsList;
        get userFunctionsList(): Hashtable;
    }
}
declare namespace Stimulsoft.Report.Engine.StiParser {
    import Type = Stimulsoft.System.Type;
    enum ParserErrorCode {
        SyntaxError = 0,
        IntegralConstantIsTooLarge = 1,
        ExpressionIsEmpty = 2,
        DivisionByZero = 3,
        UnexpectedEndOfExpression = 4,
        NameDoesNotExistInCurrentContext = 5,
        UnprocessedLexemesRemain = 6,
        LeftParenthesisExpected = 7,
        RightParenthesisExpected = 8,
        FieldMethodOrPropertyNotFound = 9,
        OperatorCannotBeAppliedToOperands = 10,
        FunctionNotFound = 11,
        NoOverloadForMethodTakesNArguments = 12,
        FunctionHasInvalidArgument = 13,
        FunctionNotYetImplemented = 14,
        MethodHasInvalidArgument = 15,
        ItemDoesNotContainDefinition = 16,
        NoMatchingOverloadedMethod = 17,
        TheTypeOrNamespaceNotExistInTheNamespace = 18
    }
    class StiParserException {
        message: string;
        baseMessage: string;
        position: number;
        length: number;
        toString(): string;
        constructor(message: string);
    }
    class StiParser_Check extends StiParser_Properties {
        private static errorsList;
        protected throwError(code: ParserErrorCode, token?: StiToken, message1?: string, message2?: string, message3?: string, message4?: string): void;
        checkTypes(asmList: StiAsmCommand[]): void;
        private getMethodResultType;
        private getPropertyType;
        private getArrayElementType;
        protected get_systemVariable(name: any): any;
        static isImplicitlyCastableTo(from: Type, to: Type): boolean;
        protected getTypeName(value: any): string;
        report: StiReport;
        protected checkParserMethodInfo(type: StiFunctionType, args: any[]): number;
        getParserMethodInfo(type: StiFunctionType, args: Type[]): StiParserMethodInfo;
    }
}
declare namespace Stimulsoft.Report.Engine.StiParser {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiParser_Lexer extends StiParser_Check {
        protected position: number;
        protected useAliases: boolean;
        protected inputExpression: string;
        protected hashAliases: Hashtable;
        protected tokenPos: number;
        protected tokensList: StiToken[];
        protected component: StiComponent;
        protected runtimeConstants: Hashtable;
        protected runtimeConstantsHash: Hashtable;
        private getNextLexem;
        private static isWhiteSpace;
        private buildAliases;
        private buildBusinessObject;
        private static isValidName;
        private static getCorrectedAlias;
        private static replaceBackslash;
        private scanNumber;
        private postProcessTokensList;
        protected createRuntimeConstantsHash(): void;
        private getDataRelationByName;
        private getDataColumnByName;
        protected makeTokensList(): void;
    }
}
declare namespace Stimulsoft.Report.Engine.StiParser {
    class StiParser_AsmOperations extends StiParser_Lexer {
        protected op_Add(par1: any, par2: any): any;
        protected op_Sub(par1: any, par2: any): any;
        protected op_Mult(par1: any, par2: any): any;
        protected op_Div(par1: any, par2: any): any;
        protected op_Mod(par1: any, par2: any): any;
        protected op_Pow(par1: any, par2: any): any;
        protected op_Neg(par1: any): any;
        protected op_Not(par1: any): any;
        protected op_Cast(par1: any, par2: any): any;
        private toIntegerCheckChar;
        protected op_CompareLeft(par1: any, par2: any): any;
        protected op_CompareLeftEqual(par1: any, par2: any): any;
        protected op_CompareRight(par1: any, par2: any): any;
        protected op_CompareRightEqual(par1: any, par2: any): any;
        protected op_CompareEqual(par1: any, par2: any): any;
        protected op_CompareNotEqual(par1: any, par2: any): any;
        protected op_Shl(par1: any, par2: any): any;
        protected op_Shr(par1: any, par2: any): any;
        protected op_And(par1: any, par2: any): any;
        protected op_Or(par1: any, par2: any): any;
        protected op_Xor(par1: any, par2: any): any;
        protected op_And2(par1: any, par2: any): any;
        protected op_Or2(par1: any, par2: any): any;
    }
}
declare namespace Stimulsoft.Report.Engine.StiParser {
    class StiParser_AsmProperties extends StiParser_AsmOperations {
        protected call_property(name: any, argsList: any[]): any;
    }
}
declare namespace Stimulsoft.Report.Engine.StiParser {
    class StiParser_AsmMethods extends StiParser_AsmProperties {
        protected call_method(name: any, argsList: any[]): any;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import DateTime = Stimulsoft.System.DateTime;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import CalendarWeekRule = Stimulsoft.System.Globalization.CalendarWeekRule;
    import DayOfWeek = Stimulsoft.System.DayOfWeek;
    class StiFunctionsDate {
        private static isCreated;
        static create(): void;
        static dateDiff(date1: DateTime, date2: DateTime): TimeSpan;
        static year(date: DateTime): number;
        static month(date: DateTime): number;
        static hour(date: DateTime): number;
        static minute(date: DateTime): number;
        static second(date: DateTime): number;
        static day(date: DateTime): number;
        static dayOfWeek(date: DateTime, loc?: boolean | string, upperCase?: boolean): string;
        static monthName(date: DateTime, loc?: boolean | string, upperCase?: boolean): string;
        static dayOfYear(date: DateTime): number;
        static dateSerial(year: number, month: number, day: number): DateTime;
        static timeSerial(hours: number, minutes: number, seconds: number): TimeSpan;
        static daysInMonth(yearOrDate: number | DateTime, month: number): number;
        static daysInYear(yearOrDate: number | DateTime): number;
        static weekOfYear(date: DateTime, firstDayOfWeek?: DayOfWeek, calendarWeekRule?: CalendarWeekRule): number;
        static weekOfMonth(date: DateTime, firstDayOfWeek?: DayOfWeek, calendarWeekRule?: CalendarWeekRule): number;
    }
}
declare namespace Stimulsoft.Report.Engine.StiParser {
    class StiParser_AsmFunctions extends StiParser_AsmMethods {
        protected call_func(name: any, argsList: any[]): any;
    }
}
declare namespace Stimulsoft.Report.Engine.StiParser {
    class StiParser_Parser extends StiParser_AsmFunctions {
        protected currentToken: StiToken;
        protected asmList: StiAsmCommand[];
        protected eval_exp(): void;
        private eval_exp0;
        private eval_exp01;
        private eval_exp1;
        private eval_exp10;
        private eval_exp11;
        private eval_exp12;
        private eval_exp14;
        private eval_exp15;
        private eval_exp16;
        private eval_exp17;
        private eval_exp18;
        private eval_exp2;
        private eval_exp3;
        private eval_exp4;
        private eval_exp5;
        private eval_exp6;
        private eval_exp62;
        private eval_exp7;
        private atom;
        private get_args_count;
        private get_args;
        private get_token;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiParser = Stimulsoft.Report.Engine.StiParser.StiParser;
    class StiParserParameters {
        storeToPrint: boolean;
        executeIfStoreToPrint: boolean;
        returnAsmList: boolean;
        checkSyntaxMode: boolean;
        syntaxCaseSensitive: boolean;
        parser: StiParser;
        conversionStore: Hashtable;
        globalizedNameExt: string;
        ignoreGlobalizedName: boolean;
        constants: Hashtable;
        useAliases: boolean;
    }
}
declare namespace Stimulsoft.Report.Engine.StiParser {
    import StiParserParameters = Stimulsoft.Report.Engine.StiParserParameters;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiText = Stimulsoft.Report.Components.StiText;
    import StiVariable = Stimulsoft.Report.Dictionary.StiVariable;
    class StiParserData {
        data: any;
        asmList: StiAsmCommand[];
        asmList2: StiAsmCommand[];
        conditionAsmList: StiAsmCommand[];
        parser: StiParser;
        constructor(data: any, asmList: StiAsmCommand[], parser: StiParser, conditionAsmList?: StiAsmCommand[]);
    }
    class StiFilterParserData {
        component: StiComponent;
        expression: string;
        constructor(component: StiComponent, expression: string);
    }
    class StiToken {
        type: StiTokenType;
        value: string;
        valueObject: any;
        position: number;
        length: number;
        constructor(type?: StiTokenType, position?: number, length?: number);
        toString(): string;
    }
    class StiAsmCommand {
        type: StiAsmCommandType;
        parameter1: any;
        parameter2: any;
        position: number;
        length: number;
        constructor(type: StiAsmCommandType, parameter1?: any, parameter2?: any);
        toString(): string;
    }
    class StiParserGetDataFieldValueEventArgs {
        dataSourceName: string;
        dataColumnName: string;
        processed: boolean;
        value: any;
        asmCommand: StiAsmCommand;
        constructor(dataSourceName: string, dataColumnName: string);
    }
    class StiParser extends StiParser_Parser {
        private sender;
        executeAsm(objectAsmList: any): any;
        private getVariableValue;
        private call_arrayElement;
        protected get_systemVariable(name: any): any;
        static parseTextValue2(inputExpression: string, component: StiComponent, sender?: any, parameters?: StiParserParameters): any;
        static parseTextValue(inputExpression: string, component: StiComponent, sender?: any, REFstoreToPrint?: any, executeIfStoreToPrint?: boolean, returnAsmList?: boolean, parser?: StiParser): any;
        private parseToAsm;
        private static checkForStoreToPrint;
        static checkExpression(inputExpression: string, component: StiComponent, useAliases?: boolean): StiParserException;
        static checkForDataBandsUsedInPageTotals(stiText: StiText, report?: StiReport): void;
        static prepareReportVariables(report: StiReport): void;
        static prepareVariableValue(varr: StiVariable, report: StiReport, textBox?: StiText, fillItems?: boolean): any;
        private static getExpressionValue;
    }
}
declare namespace Stimulsoft.Report.CrossTab {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiCrossCell extends StiCrossField implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        paint(g: Stimulsoft.System.Drawing.Graphics): void;
        protected onGetCrossValue(e: StiGetCrossValueEventArgs): void;
        invokeGetCrossValue(e: StiGetCrossValueEventArgs): void;
        getCrossValueEvent: StiGetCrossValueEvent;
        private val;
        get value(): string;
        set value(value: string);
        getValue(): string;
        setValue(value: string): void;
    }
}
declare namespace Stimulsoft.Report.CrossTab {
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiSortType = Stimulsoft.Report.CrossTab.Core.StiSortType;
    import StiSortDirection = Stimulsoft.Report.CrossTab.Core.StiSortDirection;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiCrossHeader extends StiCrossCell implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        protected onGetDisplayCrossValue(e: StiGetCrossValueEventArgs): void;
        invokeGetDisplayCrossValue(e: StiGetCrossValueEventArgs): void;
        getDisplayCrossValueEvent: StiGetDisplayCrossValueEvent;
        setValue(value: string): void;
        private _displayValue;
        get displayValue(): string;
        set displayValue(value: string);
        get total(): StiCrossTotal;
        set total(value: StiCrossTotal);
        get isTotalVisible(): boolean;
        private _headerLevel;
        get headerLevel(): number;
        set headerLevel(value: number);
        private _headerValue;
        get headerValue(): string;
        set headerValue(value: string);
        private _totalGuid;
        get totalGuid(): string;
        set totalGuid(value: string);
        private _showTotal;
        get showTotal(): boolean;
        set showTotal(value: boolean);
        private _sortDirection;
        get sortDirection(): StiSortDirection;
        set sortDirection(value: StiSortDirection);
        private _sortType;
        get sortType(): StiSortType;
        set sortType(value: StiSortType);
        private _printOnAllPages;
        get printOnAllPages(): boolean;
        set printOnAllPages(value: boolean);
        topN: StiDataTopN;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiGetDataUrlEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetDataUrlEventArgs = Stimulsoft.Report.Events.StiGetDataUrlEventArgs;
    import StiGetDataUrlEvent = Stimulsoft.Report.Events.StiGetDataUrlEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiEditable = Stimulsoft.Report.Components.IStiEditable;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiRichText extends StiSimpleText implements IStiEditable, IStiBorder, IStiGlobalizationProvider, IStiBackColor, IStiJsonReportObject, IStiGetFonts {
        private static implementsStiRichText;
        implements(): any[];
        static notSupportedText: string;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        protected static propertyCanBreak: string;
        get canBreak(): boolean;
        set canBreak(value: boolean);
        clone(cloneProperties: boolean): StiRichText;
        private static eventGetDataUrl;
        protected onGetDataUrl(e: StiGetDataUrlEventArgs): void;
        invokeGetDataUrl(sender: StiComponent, e: StiGetDataUrlEventArgs): void;
        get getDataUrlEvent(): StiGetDataUrlEvent;
        set getDataUrlEvent(value: StiGetDataUrlEvent);
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        private _border;
        get border(): StiBorder;
        set border(value: StiBorder);
        getFonts(): Font[];
        private _margins;
        get margins(): StiMargins;
        set margins(value: StiMargins);
        private _defaultFont;
        get defaultFont(): Font;
        set defaultFont(value: Font);
        private _defaultColor;
        get defaultColor(): Color;
        set defaultColor(value: Color);
        private _wordWrap;
        get wordWrap(): boolean;
        set wordWrap(value: boolean);
        private _detectUrls;
        get detectUrls(): boolean;
        set detectUrls(value: boolean);
        private _backColor;
        get backColor(): Color;
        set backColor(value: Color);
        private _dataColumn;
        get dataColumn(): string;
        set dataColumn(value: string);
        private _wysiwyg;
        get wysiwyg(): boolean;
        set wysiwyg(value: boolean);
        private _rightToLeft;
        get rightToLeft(): boolean;
        set rightToLeft(value: boolean);
        private _dataUrl;
        get dataUrl(): string;
        set dataUrl(value: string);
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiEnumAngle: System.Interface<IStiEnumAngle>;
    interface IStiEnumAngle {
        angle: StiAngle;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    let IStiHorAlignment: System.Interface<IStiHorAlignment>;
    let ImplementsIStiHorAlignment: any[];
    interface IStiHorAlignment {
        horAlignment: StiHorAlignment;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    let IStiVertAlignment: System.Interface<IStiVertAlignment>;
    let ImplementsIStiVertAlignment: any[];
    interface IStiVertAlignment {
        vertAlignment: StiVertAlignment;
    }
}
declare namespace Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiForeColor: System.Interface<IStiForeColor>;
    let ImplementsIStiForeColor: any[];
    interface IStiForeColor {
        foreColor: Color;
    }
}
declare namespace Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiBackColor: System.Interface<IStiBackColor>;
    let ImplementsIStiBackColor: any[];
    interface IStiBackColor {
        backColor: Color;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IAsIs = Stimulsoft.System.IAsIs;
    import Image = Stimulsoft.System.Drawing.Image;
    let IStiExportImage: System.Interface<IStiExportImage>;
    interface IStiExportImage extends IAsIs {
        getImage(REFzoom: any, format?: StiExportFormat): Image;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiExportImageExtended: System.Interface<IStiExportImageExtended>;
    interface IStiExportImageExtended extends IStiExportImage {
        isExportAsImage(format: StiExportFormat): boolean;
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import StiAngle = Stimulsoft.Report.Components.StiAngle;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import IStiBackColor = Stimulsoft.Report.Components.IStiBackColor;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiExportImage = Stimulsoft.Report.Components.IStiExportImage;
    import IStiExportImageExtended = Stimulsoft.Report.Components.IStiExportImageExtended;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    import IStiVertAlignment = Stimulsoft.Report.Components.IStiVertAlignment;
    import IStiBorder = Stimulsoft.Report.Components.IStiBorder;
    import IStiEnumAngle = Stimulsoft.Report.Components.IStiEnumAngle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiBarCode extends StiComponent implements IStiBarCode, IStiBackColor, IStiForeColor, IStiExportImage, IStiExportImageExtended, IStiVertAlignment, IStiHorAlignment, IStiEnumAngle, IStiBorder, IStiJsonReportObject, IStiGetFonts {
        private static implementsStiBarCode;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        get helpUrl(): string;
        get localizedCategory(): string;
        get localizedName(): string;
        isExportAsImage(format: StiExportFormat): boolean;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        private _angle;
        get angle(): StiAngle;
        set angle(value: StiAngle);
        private _border;
        get border(): StiBorder;
        set border(value: StiBorder);
        private _foreColor;
        get foreColor(): Color;
        set foreColor(value: Color);
        private _backColor;
        get backColor(): Color;
        set backColor(value: Color);
        private _autoScale;
        get autoScale(): boolean;
        set autoScale(value: boolean);
        private _showLabelText;
        get showLabelText(): boolean;
        set showLabelText(value: boolean);
        private _showQuietZones;
        get showQuietZones(): boolean;
        set showQuietZones(value: boolean);
        private _barCodeType;
        get barCodeType(): StiBarCodeTypeService;
        set barCodeType(value: StiBarCodeTypeService);
        getBarCodeString(): string;
        private _font;
        get font(): Font;
        set font(value: Font);
        private _horAlignment;
        get horAlignment(): StiHorAlignment;
        set horAlignment(value: StiHorAlignment);
        private _vertAlignment;
        get vertAlignment(): StiVertAlignment;
        set vertAlignment(value: StiVertAlignment);
        getFonts(): Font[];
        private _codeValue;
        get codeValue(): string;
        set codeValue(value: string);
        private _code;
        get code(): string;
        set code(value: string);
        invokeEvents(): void;
        private static eventGetBarCode;
        onGetBarCode(e: StiValueEventArgs): void;
        invokeGetBarCode(sender: StiComponent, e: StiValueEventArgs): void;
        get getBarCodeEvent(): Stimulsoft.Report.Events.StiGetBarCodeEvent;
        set getBarCodeEvent(value: Stimulsoft.Report.Events.StiGetBarCodeEvent);
        createNew(): StiComponent;
        defaultClientRectangle: RectangleD;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiGetCheckedEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetExcelValueEventArgs = Stimulsoft.Report.Events.StiGetExcelValueEventArgs;
    import StiGetExcelValueEvent = Stimulsoft.Report.Events.StiGetExcelValueEvent;
    import StiGetCheckedEvent = Stimulsoft.Report.Events.StiGetCheckedEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiEditable = Stimulsoft.Report.Components.IStiEditable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    class StiCheckBox extends StiComponent implements IStiBorder, IStiTextBrush, IStiBrush, IStiBreakable, IStiEditable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _border;
        get border(): StiBorder;
        set border(value: StiBorder);
        private _textBrush;
        get textBrush(): StiBrush;
        set textBrush(value: StiBrush);
        private _editable;
        get editable(): boolean;
        set editable(value: boolean);
        clone(cloneProperties: boolean): StiCheckBox;
        private _canBreak;
        get canBreak(): boolean;
        set canBreak(value: boolean);
        break(dividedComponent: StiComponent, devideFactor: number, REFdivideLine: any): boolean;
        invokeEvents(): void;
        private static eventGetChecked;
        protected onGetChecked(e: StiValueEventArgs): void;
        invokeGetChecked(sender: StiComponent, e: StiValueEventArgs): void;
        get getCheckedEvent(): StiGetCheckedEvent;
        set getCheckedEvent(value: StiGetCheckedEvent);
        private static eventGetExcelValue;
        protected onGetExcelValue(e: StiGetExcelValueEventArgs): void;
        invokeGetExcelValue(sender: StiComponent, e: StiGetExcelValueEventArgs): void;
        get getExcelValueEvent(): StiGetExcelValueEvent;
        set getExcelValueEvent(value: StiGetExcelValueEvent);
        private _checkedValue;
        get checkedValue(): any;
        set checkedValue(value: any);
        private _contourColor;
        get contourColor(): Color;
        set contourColor(value: Color);
        private _size;
        get size(): number;
        set size(value: number);
        private _checkStyle;
        get checkStyle(): StiCheckStyle;
        set checkStyle(value: StiCheckStyle);
        private _values;
        get values(): string;
        set values(value: string);
        private _checkStyleForTrue;
        get checkStyleForTrue(): StiCheckStyle;
        set checkStyleForTrue(value: StiCheckStyle);
        private _checkStyleForFalse;
        get checkStyleForFalse(): StiCheckStyle;
        set checkStyleForFalse(value: StiCheckStyle);
        private _checked;
        get checked(): string;
        set checked(value: string);
        private _excelDataValue;
        get excelDataValue(): string;
        set excelDataValue(value: string);
        private _excelValue;
        get excelValue(): string;
        set excelValue(value: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import List = Stimulsoft.System.Collections.List;
    class StiDataSourceHelper {
        static getDatabaseFromDataSource(dataSource: StiDataSource): StiDatabase;
        static getDataSourcesFromDatabase(report: StiReport, database: StiDatabase): List<StiDataSource>;
        static getUsedDataSourcesNamesList(report: StiReport): string[];
        static getUsedDataSourcesNames(report: StiReport): Hashtable;
        static checkExpression(expression: string, component: StiComponent, datasourcesNames: Hashtable): void;
        private static addDataSourceName;
        private static addDataSourceColumn;
        private static addRelation;
        private static addSort;
        static getDataSourcesUsedInRequestFromUsersVariables(report: StiReport): Hashtable;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import EventArgs = Stimulsoft.System.EventArgs;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiRenderProvider {
        static renderAsync(report: StiReport, state: StiRenderState): Promise<void>;
        static render(report: StiReport, state: StiRenderState): void;
        static StiRenderProviderV2_AddAnchor_Rendering(sender: any, e: EventArgs): void;
        static connectToDataAsync(report: StiReport): Promise<void>;
        static connectToData(report: StiReport): void;
        private static disconnectFromData;
        private static isDialogsOnStartExist;
        private static renderFormsOnStart;
        private static renderFormsOnEnd;
        private static checkDialogsInPreview;
        static clearPagesWhichLessThenFromPageAndGreaterThenToPage(report: StiReport, state: StiRenderState): void;
        private static initCacheMode;
        private static removeAllPagesLessThenFromPageAndGreaterThenToPage;
        private static finishAllPagesInNotCachedPagesArray;
        static processPageToCache(report: StiReport, page: StiPage, final: boolean): void;
        static isFirstPage(report: StiReport, page: StiPage): boolean;
        static isLastPage(report: StiReport, page: StiPage): boolean;
        private static renderFirstPassAsync;
        private static renderFirstPass;
        static clearPagesForFirstPass(report: StiReport): void;
        private static getNumberOfPass;
        private static madeCollate;
        private static madeMirrorMargins;
        private static initReport;
        private static clearTotals;
        static prepareSubReportsAndDrillDownPages(report: StiReport): Hashtable;
        private static renderReportAsync;
        private static renderReport;
        static renderTable(report: StiReport): void;
        private static finishProgressForm;
    }
}
declare namespace Stimulsoft.Report.Engine {
    class StiRenderState {
        latestProgressValue: number;
        private _fromPage;
        get fromPage(): number;
        private _toPage;
        get toPage(): number;
        private _showProgress;
        get showProgress(): boolean;
        set showProgress(value: boolean);
        private _isSubReportMode;
        get isSubReportMode(): boolean;
        set isSubReportMode(value: boolean);
        private _destroyPagesWhichNotInRange;
        get destroyPagesWhichNotInRange(): boolean;
        private _renderOnlyPagesFromRange;
        get renderOnlyPagesFromRange(): boolean;
        constructor(fromPage?: number, toPage?: number, showProgress?: boolean, destroyPagesWhichNotInRange?: boolean, renderOnlyPagesFromRange?: boolean);
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiBookmark = Stimulsoft.Report.Components.StiBookmark;
    class StiBookmarksHelper {
        static getBookmark(bookmark: StiBookmark, name: string): StiBookmark;
        static prepareBookmark(bookmark: StiBookmark): void;
        static createBookmark(text: string, componentGuid?: string): StiBookmark;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiBusinessObjectData {
        private _category;
        get category(): string;
        set category(value: string);
        private _name;
        get name(): string;
        set name(value: string);
        private _alias;
        get alias(): string;
        set alias(value: string);
        private _businessObjectValue;
        get businessObjectValue(): any;
        set businessObjectValue(value: any);
        constructor(category: string, name: string, alias: string, value: any);
    }
}
declare namespace Stimulsoft.Report.Export {
    import IAsIs = Stimulsoft.System.IAsIs;
    class StiExportSettings implements IAsIs {
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        getExportFormat(): StiExportFormat;
    }
}
declare namespace Stimulsoft.Report.Export {
    class StiPageRangeExportSettings extends StiExportSettings {
        pageRange: StiPagesRange;
    }
}
declare namespace Stimulsoft.Report.Export {
    import StiTiffCompressionScheme = Stimulsoft.Report.Export.StiTiffCompressionScheme;
    import StiPageRangeExportSettings = Stimulsoft.Report.Export.StiPageRangeExportSettings;
    import StiExportFormat = Stimulsoft.Report.StiExportFormat;
    import StiImageFormat = Stimulsoft.Report.Export.StiImageFormat;
    import StiMonochromeDitheringType = Stimulsoft.Report.Export.StiMonochromeDitheringType;
    import StiImageType = Stimulsoft.Report.Export.StiImageType;
    class StiImageExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        imageType: StiImageType;
        imageZoom: number;
        imageResolution: number;
        cutEdges: boolean;
        imageFormat: StiImageFormat;
        multipleFiles: boolean;
        ditheringType: StiMonochromeDitheringType;
        tiffCompressionScheme: StiTiffCompressionScheme;
        constructor(imageType?: StiImageType);
    }
}
declare namespace Stimulsoft.Report.Export {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    class StiExportService implements IStiExportService {
        get exportFormat(): StiExportFormat;
        isStopped: boolean;
        multipleFiles: boolean;
        renderedPagesCount: number;
        currentPassNumber: number;
        maximumPassNumber: number;
        exportServiceId: string;
        invokeExporting(page: StiPage, pages: StiPagesCollection, currentPass: number, maximumPass: number): void;
        invokeExporting2(value: number, maximum: number, currentPass: number, maximumPass: number): void;
    }
}
declare namespace Stimulsoft.Report.Export {
    class StiImageExportService extends StiExportService {
        get defaultExtension(): string;
        get exportFormat(): StiExportFormat;
        get groupCategory(): string;
        exportNameInMenu: string;
        position: StiExportPosition;
        getFilter(): string;
        exportTo(report: StiReport, refString: {
            ref: string;
        }, settings: StiExportSettings): void;
        imageSettings: StiImageExportSettings;
        report: StiReport;
        private fileName;
        private sendEMail;
        exportImage(report: StiReport, refString: {
            ref: string;
        }, settings: StiImageExportSettings): void;
        private getSettings;
        private exportImage1;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiExportAssembly {
        static get isAssemblyLoaded(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiPromise = Stimulsoft.System.StiPromise;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import List = Stimulsoft.System.Collections.List;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import Type = Stimulsoft.System.Type;
    import IStiQueryObject = Stimulsoft.Data.Engine.IStiQueryObject;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import StiDataRequestOption = Stimulsoft.Data.Engine.StiDataRequestOption;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiDataTransformation extends StiDataStoreSource implements IStiQueryObject, IStiJsonReportObject {
        private static ImplementsStiDataTransformation;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        retrieveUsedDataNames(group: string): List<string>;
        getDataSources(dataNames: List<string>): List<IStiAppDataSource>;
        getKey(): string;
        isDataSource: true;
        getDataTable2(allowConnectToData: boolean): Promise<DataTable>;
        getDataAdapterType(): Type;
        sorts: List<StiDataSortRule>;
        filters: List<StiDataFilterRule>;
        actions: List<StiDataActionRule>;
        retrieveDataTableAsync(option: StiDataRequestOption): StiPromise<DataTable>;
        connectToDataAsync(): StiPromise<void>;
        getMeters(group?: string): List<IStiMeter>;
        getMeter(column: StiDataTransformationColumn): IStiMeter;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiFileDatabase extends StiDatabase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        createDataSources(dictionary: StiDictionary): void;
        static parsePathExpression(dictionary: StiDictionary, path: string): string;
        pathData: string;
        constructor(name?: string, pathData?: string, key?: string);
    }
}
declare namespace Stimulsoft.Report.Helpers {
    import IStiApp = Stimulsoft.Base.IStiApp;
    class StiDataResourceHelper {
        static saveSnapshotAsync(app: IStiApp): Promise<void>;
        private static getRelationInformation;
        private static saveRelationSnapshot;
        private static replaceDatabase;
        private static databaseFromRecource;
        private static getListResourceSnapshot;
        private static dataSetToResourceXml;
        private static getNewResourceName;
    }
}
declare namespace Stimulsoft.Report {
    import Image = Stimulsoft.System.Drawing.Image;
    import StiRefreshingEvent = Stimulsoft.Report.Events.StiRefreshingEvent;
    import StiMetaTagCollection = Stimulsoft.Report.Dictionary.StiMetaTagCollection;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiAppCell = Stimulsoft.Base.IStiAppCell;
    import IStiApp = Stimulsoft.Base.IStiApp;
    import StiExportSettings = Stimulsoft.Report.Export.StiExportSettings;
    import StiExportService = Stimulsoft.Report.Export.StiExportService;
    import StiExportEventArgs = Stimulsoft.Report.Events.StiExportEventArgs;
    import StiPrintedEvent = Stimulsoft.Report.Events.StiPrintedEvent;
    import StiPrintingEvent = Stimulsoft.Report.Events.StiPrintingEvent;
    import StiExportedEvent = Stimulsoft.Report.Events.StiExportedEvent;
    import StiEndRenderEvent = Stimulsoft.Report.Events.StiEndRenderEvent;
    import StiRenderingEvent = Stimulsoft.Report.Events.StiRenderingEvent;
    import StiBeginRenderEvent = Stimulsoft.Report.Events.StiBeginRenderEvent;
    import StiExportingEvent = Stimulsoft.Report.Events.StiExportingEvent;
    import StiReportCacheProcessingEvent = Stimulsoft.Report.Events.StiReportCacheProcessingEvent;
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiGetSubReportEventArgs = Stimulsoft.Report.Events.StiGetSubReportEventArgs;
    import StiHtmlExportMode = Stimulsoft.Report.Export.StiHtmlExportMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiDialogInfo = Stimulsoft.Report.Dictionary.StiDialogInfo;
    import StiDataCollection = Stimulsoft.Report.Dictionary.StiDataCollection;
    import StiDataSourcesCollection = Stimulsoft.Report.Dictionary.StiDataSourcesCollection;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    import IStiUnitConvert = Stimulsoft.Report.Components.IStiUnitConvert;
    import StiEngine = Stimulsoft.Report.Engine.StiEngine;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiBookmark = Stimulsoft.Report.Components.StiBookmark;
    import StiStylesCollection = Stimulsoft.Report.Styles.StiStylesCollection;
    import StiAggregateFunctionService = Stimulsoft.Report.Dictionary.StiAggregateFunctionService;
    import Type = Stimulsoft.System.Type;
    import DateTime = Stimulsoft.System.DateTime;
    import StiBusinessObjectData = Stimulsoft.Report.Dictionary.StiBusinessObjectData;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiMasterComponent = Stimulsoft.Report.Components.IStiMasterComponent;
    import IStiReport = Stimulsoft.Base.IStiReport;
    import List = Stimulsoft.System.Collections.List;
    import IStiReportPage = Stimulsoft.Base.IStiReportPage;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import JsonRelationDirection = Stimulsoft.System.Data.JsonRelationDirection;
    import StiClone = Stimulsoft.Report.Components.StiClone;
    class StiJsonLoaderHelper {
        masterComponents: IStiMasterComponent[];
        clones: StiClone[];
        dialogInfo: StiDialogInfo[];
        barcodeTypes: Stimulsoft.Report.BarCodes.StiBarCodeTypeService[];
        textFormatTypes: string[];
        refNames: string[];
        clean(): void;
    }
    class StiReport implements IStiUnitConvert, IStiReport, IStiApp, IStiAppCell, IStiGetFonts {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        jsonLoaderHelper: StiJsonLoaderHelper;
        private static assignSignature;
        private saveToJsonInternal;
        saveSnapshot(): Promise<string>;
        private loadFromJsonInternal;
        private loadFromXmlInternal;
        private isPackedFile;
        load(param: string | number[] | XmlNode | any): void;
        loadFile(filePath: string): void;
        loadPacked(param: string | number[] | any): void;
        loadPackedFile(filePath: string): void;
        loadEncryptedReport(param: string | number[] | any, key: string): void;
        loadEncryptedReportFile(filePath: string, key: string): void;
        loadDocument(param: string | number[] | any): void;
        loadDocumentFile(filePath: string): void;
        loadPackedDocument(param: string | number[] | any): void;
        loadPackedDocumentFile(filePath: string): void;
        loadEncryptedDocument(param: string | number[] | any, key: string): void;
        loadEncryptedDocumentFile(filePath: string, key: string): void;
        saveEncryptedReportToByteArray(key: string): number[];
        saveEncryptedReportToString(key: string): string;
        saveEncryptedReportFile(path: string, key: string): void;
        savePackedFile(path: string): void;
        savePackedToString(): string;
        savePackedToByteArray(): number[];
        saveToJsonString(): string;
        saveFile(path: string): void;
        saveDocumentToJsonString(): string;
        saveDocumentFile(path: string): void;
        saveEncryptedDocumentToByteArray(key: string): number[];
        saveEncryptedDocumentToString(key: string): string;
        saveEncryptedDocumentFile(path: string, key: string): void;
        savePackedDocumentFile(path: string): void;
        savePackedDocumentToString(): string;
        savePackedDocumentToByteArray(): number[];
        getDictionary(): IStiAppDictionary;
        getKey(): string;
        setKey(key: string): void;
        fetchPages(): List<IStiReportPage>;
        getFonts(): Font[];
        private _pageNumber;
        get pageNumber(): number;
        set pageNumber(value: number);
        get pageNumberThrough(): number;
        _totalPageCountValue: number;
        get totalPageCount(): number;
        set totalPageCount(value: number);
        get totalPageCountThrough(): number;
        get pageNofM(): string;
        get pageNofMThrough(): string;
        private _pageNofMLocalizationString;
        get pageNofMLocalizationString(): string;
        set pageNofMLocalizationString(value: string);
        private _line;
        get line(): number;
        set line(value: number);
        private _groupLine;
        get groupLine(): number;
        set groupLine(value: number);
        get lineRoman(): string;
        get lineABC(): string;
        private _column;
        get column(): number;
        set column(value: number);
        private _lineThrough;
        get lineThrough(): number;
        set lineThrough(value: number);
        get date(): DateTime;
        get today(): DateTime;
        get time(): DateTime;
        private _cacheAllData;
        get cacheAllData(): boolean;
        set cacheAllData(value: boolean);
        private _retrieveOnlyUsedData;
        get retrieveOnlyUsedData(): boolean;
        set retrieveOnlyUsedData(value: boolean);
        private _reportCacheMode;
        get reportCacheMode(): StiReportCacheMode;
        set reportCacheMode(value: StiReportCacheMode);
        convertNulls: boolean;
        get isFirstPage(): boolean;
        get isLastPage(): boolean;
        get isFirstPageThrough(): boolean;
        get isLastPageThrough(): boolean;
        get isFirstPass(): boolean;
        get isSecondPass(): boolean;
        private _currentPage;
        get currentPage(): number;
        set currentPage(value: number);
        private _currentPrintPage;
        get currentPrintPage(): number;
        set currentPrintPage(value: number);
        private _pageCopyNumber;
        get pageCopyNumber(): number;
        set pageCopyNumber(value: number);
        private _businessObjectsStore;
        get businessObjectsStore(): StiBusinessObjectData[];
        private _variables;
        get variables(): Hashtable;
        set variables(value: Hashtable);
        getVariable(name: string, onlyVariable?: boolean): any;
        setVariable(name: string, value: any, onlyVariable?: boolean): void;
        private _aggregateFunctions;
        get aggregateFunctions(): StiAggregateFunctionService[];
        set aggregateFunctions(value: StiAggregateFunctionService[]);
        private _dictionary;
        get dictionary(): Stimulsoft.Report.Dictionary.StiDictionary;
        set dictionary(value: Stimulsoft.Report.Dictionary.StiDictionary);
        get dataSources(): StiDataSourcesCollection;
        get dataStore(): StiDataCollection;
        regData(name: string, alias: string, data: any, jsonRelationDirection?: JsonRelationDirection): void;
        regBusinessObject2(category: string, name: string, alias: string, value: any): void;
        regBusinessObject(businessObjects: StiBusinessObjectData[]): void;
        private storeBusinessObjectWithCheckExistingData;
        private _script;
        get script(): string;
        set script(value: string);
        scriptNew(): void;
        private prepareVariablesFromURL;
        private static getPrepareVariablesArgs;
        private static setPrepareVariablesArgs;
        onPrepareVariables: Function;
        invokePrepareVariablesAsync(): Promise<unknown>;
        onBeginProcessData: Function;
        invokeBeginProcessData(args: any, callback: Function): void;
        onEndProcessData: Function;
        invokeEndProcessData(args: any): void;
        events: Hashtable;
        invokeRefreshPreview(): void;
        invokeRefreshViewer(): void;
        invokeClick(sender: any, e: EventArgs): void;
        invokeDoubleClick(sender: any, e: EventArgs): void;
        invokeGotoComp(e: StiGotoCompEventArgs): void;
        invokePaint(sender: any, e: EventArgs): void;
        onBeginRender: Function;
        private static eventBeginRender;
        invokeBeginRender(): void;
        private beginRenderEventScript;
        get beginRenderEvent(): StiBeginRenderEvent;
        set beginRenderEvent(value: StiBeginRenderEvent);
        onRendering: Function;
        invokeRendering(): void;
        onEndRender: Function;
        renderingEvent: StiRenderingEvent;
        private static eventEndRender;
        invokeEndRender(): void;
        private endRenderEventScript;
        get endRenderEvent(): StiEndRenderEvent;
        set endRenderEvent(value: StiEndRenderEvent);
        invokeStatusChanged(): void;
        protected onExporting(e: StiExportEventArgs): void;
        exportingEvent: StiExportingEvent;
        invokeExporting(exportFormat: StiExportFormat): void;
        protected onExported(e: StiExportEventArgs): void;
        exportedEvent: StiExportedEvent;
        invokeExported(exportFormat: StiExportFormat): void;
        protected onPrinting(e: EventArgs): void;
        printingEvent: StiPrintingEvent;
        invokePrinting(): void;
        protected onPrinted(e: EventArgs): void;
        printedEvent: StiPrintedEvent;
        invokePrinted(): void;
        protected onRefreshing(e: EventArgs): void;
        refreshingEvent: StiRefreshingEvent;
        invokeRefreshing(): void;
        onGetSubReport: Function;
        invokeGetSubReport(args: StiGetSubReportEventArgs): void;
        invokeReportCacheProcessing(): void;
        reportCacheProcessingEvent: StiReportCacheProcessingEvent;
        get unit(): StiUnit;
        set unit(value: StiUnit);
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        static changeType(value: any, conversionType: Type, convertNulls?: boolean): any;
        applyStyleCollection(collectionName: string): void;
        applyStyles(): void;
        updateInheritedReport(masterReport?: StiReport): void;
        private _masterReport;
        get masterReport(): string;
        set masterReport(value: string);
        setInheritedMode(inherited: boolean): void;
        getCurrentPage(): StiPage;
        static getReportVersion(): string;
        private updateReportVersion;
        writeToReportRenderingMessages(str: string): void;
        getComponentByName(componentName: string): StiComponent;
        toString2(obj: any): string;
        checkExcelValue(sender: any, value: any): any;
        toString3(sender: any, obj: any, allowExcelCheck?: boolean): string;
        private generateReportGuid;
        addAnchor(value: any, component?: any): void;
        getAnchorPageNumber(value: any): number;
        getAnchorPageNumberThrough(value: any): number;
        private getAnchor;
        getComponents(): StiComponentsCollection;
        getRenderedComponents(): StiComponentsCollection;
        getComponentsCount(): number;
        renameStyle(oldStylename: string, newStyleName: string): void;
        localizeReport(cultureName: string): void;
        private anchors;
        subReportsMasterReport: StiReport;
        subReportsResetPageNumber: boolean;
        subReportsPrintOnPreviousPage: boolean;
        indexName: number;
        containsTables: boolean;
        cachedTotals: Hashtable;
        cachedTotalsLocked: boolean;
        preparedExportImages: Hashtable<StiComponent, Image>;
        modifiedVariables: Hashtable;
        private _metaTags;
        get metaTags(): StiMetaTagCollection;
        set metaTags(value: StiMetaTagCollection);
        private _reportVersion;
        get reportVersion(): string;
        set reportVersion(value: string);
        private _engine;
        get engine(): StiEngine;
        set engine(value: StiEngine);
        private _reportRenderingMessages;
        get reportRenderingMessages(): string[];
        set reportRenderingMessages(value: string[]);
        private _interactionCollapsingStates;
        get interactionCollapsingStates(): any;
        set interactionCollapsingStates(value: any);
        private _subReports;
        get subReports(): StiReportsCollection;
        set subReports(value: StiReportsCollection);
        key: string;
        private _reportGuid;
        get reportGuid(): string;
        set reportGuid(value: string);
        private _imageCachePath;
        get imageCachePath(): string;
        set imageCachePath(value: string);
        private _parentReport;
        get parentReport(): StiReport;
        set parentReport(value: StiReport);
        private _globalizationManager;
        get globalizationManager(): IStiGlobalizationManager;
        set globalizationManager(value: IStiGlobalizationManager);
        private _pages;
        get pages(): StiPagesCollection;
        private _renderedPages;
        get renderedPages(): StiPagesCollection;
        set renderedPages(value: StiPagesCollection);
        private _info;
        get info(): Stimulsoft.Report.Design.StiDesignerInfo;
        set info(value: Stimulsoft.Report.Design.StiDesignerInfo);
        private pointerValue;
        get pointer(): StiBookmark;
        set pointer(value: StiBookmark);
        bookmarkValue: StiBookmark;
        get bookmark(): StiBookmark;
        set bookmark(value: StiBookmark);
        private _manualBookmark;
        get manualBookmark(): StiBookmark;
        set manualBookmark(value: StiBookmark);
        private _totals;
        get totals(): Hashtable;
        set totals(value: Hashtable);
        private _cells;
        get cells(): StiCells;
        private _password;
        get password(): string;
        set password(value: string);
        private _dataBandsUsedInPageTotals;
        get dataBandsUsedInPageTotals(): string[];
        set dataBandsUsedInPageTotals(value: string[]);
        private _listOfUsedData;
        get listOfUsedData(): string[];
        set listOfUsedData(value: string[]);
        renderedWith: StiRenderedWith;
        private _reportPass;
        get reportPass(): StiReportPass;
        set reportPass(value: StiReportPass);
        private _isRendered;
        get isRendered(): boolean;
        set isRendered(value: boolean);
        private _isRendering;
        get isRendering(): boolean;
        set isRendering(value: boolean);
        private _isModified;
        get isModified(): boolean;
        set isModified(value: boolean);
        private _isStopped;
        get isStopped(): boolean;
        set isStopped(value: boolean);
        private _isExporting;
        get isExporting(): boolean;
        set isExporting(value: boolean);
        private _isSerializing;
        get isSerializing(): boolean;
        set isSerializing(value: boolean);
        private _isPageDesigner;
        get isPageDesigner(): boolean;
        set isPageDesigner(value: boolean);
        private isPrintingValue;
        get isPrinting(): boolean;
        set isPrinting(value: boolean);
        get containsDashboard(): boolean;
        get containsOnlyDashboard(): boolean;
        get isDesigning(): boolean;
        private _isPreviewDialogs;
        get isPreviewDialogs(): boolean;
        set isPreviewDialogs(value: boolean);
        isReportRenderingAfterSubmit: boolean;
        private _isDocument;
        get isDocument(): boolean;
        set isDocument(value: boolean);
        private _isInteractionRendering;
        get isInteractionRendering(): boolean;
        set isInteractionRendering(value: boolean);
        private _reportName;
        get reportName(): string;
        set reportName(value: string);
        private _reportAlias;
        get reportAlias(): string;
        set reportAlias(value: string);
        private _reportAuthor;
        get reportAuthor(): string;
        set reportAuthor(value: string);
        private _reportDescription;
        get reportDescription(): string;
        set reportDescription(value: string);
        reportImage: string;
        reportIcon: string;
        private _reportCreated;
        get reportCreated(): DateTime;
        set reportCreated(value: DateTime);
        private _reportChanged;
        get reportChanged(): DateTime;
        set reportChanged(value: DateTime);
        private _styles;
        get styles(): StiStylesCollection;
        private _numberOfPass;
        get numberOfPass(): StiNumberOfPass;
        set numberOfPass(value: StiNumberOfPass);
        private _calculationMode;
        get calculationMode(): StiCalculationMode;
        private _reportUnit;
        get reportUnit(): StiReportUnitType;
        set reportUnit(value: StiReportUnitType);
        private _stopBeforePage;
        get stopBeforePage(): number;
        set stopBeforePage(value: number);
        private _previewSettings;
        get previewSettings(): number;
        set previewSettings(value: number);
        private _dashboardViewerSettings;
        get dashboardViewerSettings(): number;
        set dashboardViewerSettings(value: number);
        private _collate;
        get collate(): number;
        set collate(value: number);
        private _globalizationStrings;
        get globalizationStrings(): StiGlobalizationContainerCollection;
        private _autoLocalizeReportOnRun;
        get autoLocalizeReportOnRun(): boolean;
        set autoLocalizeReportOnRun(value: boolean);
        scriptLanguage: StiReportLanguageType;
        private _requestParameters;
        get requestParameters(): boolean;
        set requestParameters(value: boolean);
        private _cacheTotals;
        get cacheTotals(): boolean;
        set cacheTotals(value: boolean);
        private _culture;
        get culture(): string;
        set culture(value: string);
        private _refreshTime;
        get refreshTime(): number;
        set refreshTime(value: number);
        private _compiledReport;
        get compiledReport(): StiReport;
        set compiledReport(value: StiReport);
        resetAggregateFunctions(): void;
        getLabel(variableName: string): string;
        getParam(paramName: string): any;
        licenseKey: string;
        constructor();
        renderAsync(onRender?: Function, fromPage?: number, toPage?: number): void;
        renderAsync2(fromPage?: number, toPage?: number): Promise<void>;
        render(showProgress?: boolean, fromPage?: number, toPage?: number): void;
        processAutoLocalizeReportOnRun(): void;
        private storedCulture;
        private renderReportAsync;
        private renderReport;
        print(pagesRange?: StiPagesRange, exportMode?: StiHtmlExportMode): void;
        printToPdf(pagesRange?: StiPagesRange, element?: HTMLElement): void;
        private _reportFile;
        get reportFile(): string;
        set reportFile(value: string);
        exportDocumentAsync(onExport: Function, exportFormat: StiExportFormat, exportService?: StiExportService, settings?: StiExportSettings): void;
        exportDocumentAsync2(exportFormat: StiExportFormat, exportService?: StiExportService, settings?: StiExportSettings): Promise<string | number[]>;
        exportDocument(exportFormat: StiExportFormat, exportService?: StiExportService, settings?: StiExportSettings, onExport?: Function): string | number[];
        static createNewReport(): StiReport;
        static createNewDashboard(): StiReport;
    }
}
declare namespace StiOptions {
    import StiParserType = Stimulsoft.Report.StiParserType;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiColumnsSynchronizationMode = Stimulsoft.Report.Dictionary.StiColumnsSynchronizationMode;
    import StiWord2007RestrictEditing = Stimulsoft.Report.Export.StiWord2007RestrictEditing;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import PaperSizeCollection = Stimulsoft.System.Drawing.Printing.PrinterSettings.PaperSizeCollection;
    import StiTextQuality = Stimulsoft.Report.Components.StiTextQuality;
    import StiNamingRule = Stimulsoft.Report.StiNamingRule;
    import StiAutoSynchronizeMode = Stimulsoft.Report.Dictionary.StiAutoSynchronizeMode;
    import StiPropertiesProcessingType = Stimulsoft.Report.Dictionary.StiPropertiesProcessingType;
    import StiFieldsProcessingType = Stimulsoft.Report.Dictionary.StiFieldsProcessingType;
    import StiExcel2007RestrictEditing = Stimulsoft.Report.Export.StiExcel2007RestrictEditing;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiArabicDigitsType = Stimulsoft.Report.StiArabicDigitsType;
    import StiPdfAutoPrintMode = Stimulsoft.Report.Export.StiPdfAutoPrintMode;
    import IStiIndicatorRangeInfo = Stimulsoft.Report.Components.Gauge.IStiIndicatorRangeInfo;
    import IStiCustomValueBase = Stimulsoft.Report.Components.Gauge.IStiCustomValueBase;
    import IStiGaugeElement = Stimulsoft.Report.Components.Gauge.IStiGaugeElement;
    import IStiRangeBase = Stimulsoft.Report.Components.Gauge.IStiRangeBase;
    import IStiScaleBase = Stimulsoft.Report.Components.Gauge.IStiScaleBase;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import List = Stimulsoft.System.Collections.List;
    class CrossTab2 {
        styleColors: Color[];
    }
    class Designer {
        static useComponentPlacementOptimization: boolean;
        static autoCorrectDataSourceName: boolean;
        static autoCorrectDataRelationName: boolean;
        static autoCorrectDataColumnName: boolean;
        static autoCorrectComponentName: boolean;
        static autoCorrectReportName: boolean;
        static autoLargeHeight: boolean;
        static sortDictionaryByAliases: boolean;
        static runWizardAfterLoad: boolean;
        static runSpecificWizardAfterLoad: string;
        static Editors: {
            allowConnectToDataInGallery: boolean;
        };
        private static _styles;
        static get styles(): Stimulsoft.Report.Styles.StiStylesCollection;
        static CrossTab: CrossTab2;
    }
    class Image {
        absolutePathOfImages: string;
        useImageCloning: boolean;
    }
    class Watemark {
        allowExpression: boolean;
    }
    class CrossTab {
        defaultWidth: number;
        defaultHeight: number;
    }
    class Globalization {
        allowUseText: boolean;
        allowUseTag: boolean;
        allowUseToolTip: boolean;
        allowUseHyperlink: boolean;
        allowUseVariableAlias: boolean;
    }
    class Engine {
        static Image: Image;
        static Watermark: Watemark;
        static printIfDetailEmptyDefaultValue: boolean;
        static baseReportType: typeof Stimulsoft.Report.StiReport;
        static fullTrust: boolean;
        static allowUseResetMethodInBusinessObject: boolean;
        static allowResetValuesAtComponent: boolean;
        static defaultTextQualityMode: StiTextQuality;
        static forceGenerationLocalizedName: boolean;
        static useAdvancedPrintOnEngine: boolean;
        static forceGenerationNonLocalizedName: boolean;
        static forceNewPageForExtraColumns: boolean;
        static useRoundForToCurrencyWordsFunctions: boolean;
        static forceNewPageInSubReports: boolean;
        static useTemplateForPagePrintEvents: boolean;
        static namingRule: StiNamingRule;
        static useCheckSizeForContinuedContainers: boolean;
        static emulateData: boolean;
        static allowCacheForGetActualSize: boolean;
        static allowBreakContainerOptimization: boolean;
        static removeBottomBorderOfSplitContainer: boolean;
        static checkDockToContainerIfComponentDisabled: boolean;
        static usePrintOnAllPagesPropertyOfHeadersInSubreports: boolean;
        static useParentStylesOldMode: boolean;
        static useCollateOldMode: boolean;
        static dpiAware: boolean;
        static dockPageFooterToBottom: boolean;
        static defaultValueOfAllowApplyStyleProperty: boolean;
        static allowFixPieChartMarkerAlignment: boolean;
        static applyStylesInAutoSeries: boolean;
        static allowInvokeProcessChartEventForTemplateOfChart: boolean;
        static allowInteractionInChartWithComponents: boolean;
        static dontSaveDataSourceBeforeChartRendering: boolean;
        static measureTrailingSpaces: boolean;
        static renderExternalSubReportsWithHelpOfUnlimitedHeightPages: boolean;
        static escapeQueryParameters: boolean;
        static optimizeDetailDataFiltering: boolean;
        static CrossTab: CrossTab;
        static printIfDetailEmptyNesting: boolean;
        static allowForceCanBreakForCrossTabPrintOnAllPages: boolean;
        static Globalization: Globalization;
        static reportResources: any;
        static filterDataInDataSourceBeforeSorting: boolean;
        static allowConvertingInFormatting: boolean;
        static negativeColor: Color;
        static barcodeQRCodeAllowUnicodeBOM: boolean;
        static retrieveSchemaNamePostgreSql: string;
        static hideExceptions: boolean;
        static fixPageNumberInEvents: boolean;
        static dashboardTextElementExpressionParser: StiParserType;
        static useSyncRenderMode: boolean;
        static loadDataOnce: boolean;
        static useNewHtmlEngine: boolean;
    }
    class Print {
        static customPaperSizes: PaperSizeCollection;
        static allowUsePaperSizesFromPrinterSettings: boolean;
    }
    class BusinessObjects {
        static allowUseDataColumn: boolean;
        static allowUseFields: boolean;
        static allowUseProperties: boolean;
        static propertiesProcessingType: StiPropertiesProcessingType;
        static fieldsProcessingType: StiFieldsProcessingType;
        columnsSynchronizationMode: StiColumnsSynchronizationMode;
    }
    class Dictionary {
        static BusinessObjects: BusinessObjects;
        static showOnlyAliasForDatabase: boolean;
        static showOnlyAliasForData: boolean;
        static showOnlyAliasForDataColumn: boolean;
        static showOnlyAliasForDataRelation: boolean;
        static hideRelationExceptions: boolean;
        static autoSynchronize: StiAutoSynchronizeMode;
        static useAdvancedDataSearch: boolean;
        static showOnlyAliasForComponents: boolean;
        static showOnlyAliasForDataSource: boolean;
        static allowRestConnections: boolean;
        static allowConnectToFirstTableForEmptyDataSource: boolean;
        static useNullableDateTime: boolean;
        static useNullableTimeSpan: boolean;
        static columnsSynchronizationMode: StiColumnsSynchronizationMode;
        static showOnlyAliasForResource: boolean;
    }
    class Dashboards {
        private _dashboardStyles;
        get dashboardStyles(): List<Stimulsoft.Report.Dashboard.Styles.StiDashboardStyle>;
        private _controlStyles;
        get controlStyles(): List<Stimulsoft.Report.Dashboard.Styles.StiControlElementStyle>;
        private _indicatorStyles;
        get indicatorStyles(): List<Stimulsoft.Report.Dashboard.Styles.StiIndicatorElementStyle>;
        private _pivotStyles;
        get pivotStyles(): List<Stimulsoft.Report.Dashboard.Styles.StiPivotElementStyle>;
        private _progressStyles;
        get progressStyles(): List<Stimulsoft.Report.Dashboard.Styles.StiProgressElementStyle>;
        private _tableStyles;
        get tableStyles(): List<Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle>;
    }
    class Services {
        private static _components;
        static get components(): List<Stimulsoft.System.Type>;
        private static _databases;
        static get databases(): List<Stimulsoft.Report.Dictionary.StiDatabase>;
        private static _dataAdapters;
        static get dataAdapters(): List<Stimulsoft.Report.Dictionary.StiDataAdapterService>;
        private static _dataSource;
        static get dataSource(): List<Stimulsoft.Report.Dictionary.StiDataSource>;
        private static _formats;
        static get formats(): List<Stimulsoft.Report.Components.TextFormats.StiFormatService>;
        private static _styles;
        static get styles(): List<Stimulsoft.Report.Styles.StiBaseStyle>;
        private static _chartAreas;
        static get chartAreas(): List<Stimulsoft.Report.Chart.IStiArea>;
        private static _chartSeries;
        static get chartSeries(): List<Stimulsoft.Report.Chart.IStiSeries>;
        private static _chartTrendLines;
        static get chartTrendLines(): List<Stimulsoft.Report.Chart.IStiTrendLine>;
        private static _chartSerieLabels;
        static get chartSerieLabels(): List<Stimulsoft.Report.Chart.IStiSeriesLabels>;
        private static _chartStyles;
        static get chartStyles(): List<Stimulsoft.Report.Chart.IStiChartStyle>;
        private static _shapes;
        static get shapes(): List<Stimulsoft.Report.Components.StiShapeTypeService>;
        private static _barCodes;
        static get barCodes(): List<Stimulsoft.Report.BarCodes.StiBarCodeTypeService>;
        private static _indicatorRanges;
        static get indicatorRanges(): List<IStiIndicatorRangeInfo>;
        private static _customValues;
        static get customValues(): List<IStiCustomValueBase>;
        private static _gaugeElements;
        static get gaugeElements(): List<IStiGaugeElement>;
        private static _ranges;
        static get ranges(): List<IStiRangeBase>;
        private static _gaugeScales;
        static get gaugeScales(): List<IStiScaleBase>;
        private static _gaugeStyles;
        static get gaugeStyles(): List<IStiGaugeStyle>;
        private static _mapStyles;
        static get mapStyles(): List<Stimulsoft.Report.Maps.StiMapStyleFX>;
        static Dashboards: Dashboards;
    }
    class ExportWord {
        divideSegmentPages: boolean;
        allowImageComparer: boolean;
        removeEmptySpaceAtBottom: boolean;
        spaceBetweenCharacters: number;
        lineHeightExactly: boolean;
        lineHeightExactlyForPHFMode: boolean;
        forceLineHeight: boolean;
        rightMarginCorrection: number;
        bottomMarginCorrection: number;
        renderRichTextAsImage: boolean;
        renderHtmlTagsAsImage: boolean;
        allowCorrectFontSize11Problem: boolean;
        normalStyleDefaultFontSize: number;
        lineSpacing: number;
        divideBigCells: boolean;
        restrictEditing: StiWord2007RestrictEditing;
    }
    class ExportWriter {
        removeEmptySpaceAtBottom: boolean;
        allowImageComparer: boolean;
        divideSegmentPages: boolean;
    }
    class ExportCalc {
        removeEmptySpaceAtBottom: boolean;
        allowImageComparer: boolean;
        divideSegmentPages: boolean;
        divideBigCells: boolean;
        maximumSheetHeight: number;
    }
    class ExportHtml {
        convertDigitsToArabic: boolean;
        arabicDigitsType: Stimulsoft.Report.StiArabicDigitsType;
        allowImageComparer: boolean;
        forceWysiwygWordwrap: boolean;
        replaceSpecialCharacters: boolean;
        preserveWhiteSpaces: boolean;
        useImageResolution: boolean;
        useWordWrapBreakWordMode: boolean;
        useStrictTableCellSize: boolean;
        useStrictTableCellSizeV2: boolean;
        forceIE6Compatibility: boolean;
        allowStrippedImages: boolean;
        removeEmptySpaceAtBottom: boolean;
        useExtendedStyle: boolean;
        printLayoutOptimization: boolean;
        useComponentStyleName: boolean;
        exportComponentsFromPageMargins: boolean;
    }
    class ExportExcel {
        AllowExportDateTime: boolean;
        ColumnsRightToLeft: boolean;
        ShowGridLines: boolean;
        MaximumSheetHeight: number;
        RemoveEmptySpaceAtBottom: boolean;
        DivideBigCells: boolean;
        UseImageResolution: boolean;
        TrimTrailingSpaces: boolean;
        AllowExportFootersInDataOnlyMode: boolean;
        AllowImageComparer: boolean;
        AllowFreezePanes: boolean;
        RenderHtmlTagsAsImage: boolean;
        RestrictEditing: StiExcel2007RestrictEditing;
        FitToOnePageWide: boolean;
    }
    class ExportPowerPoint {
        AllowImageComparer: boolean;
        StoreImagesAsPng: boolean;
    }
    class ExportPdf {
        divideSegmentPages: boolean;
        convertDigitsToArabic: boolean;
        arabicDigitsType: StiArabicDigitsType;
        reduceFontFileSize: boolean;
        useEditableFieldName: boolean;
        useEditableFieldAlias: boolean;
        useEditableFieldTag: boolean;
        allowImageComparer: boolean;
        allowImageTransparency: boolean;
        allowInheritedPageResources: boolean;
        allowExtGState: boolean;
        private _creatorString;
        get creatorString(): string;
        set creatorString(value: string);
        keywordsString: string;
        defaultCoordinatesPrecision: number;
        defaultAutoPrintMode: StiPdfAutoPrintMode;
        useProperCaseFontNamesFromHtml: boolean;
        useAlternativeFontNames: boolean;
        private static _alternativeFontNames;
        get alternativeFontNames(): Hashtable;
        set alternativeFontNames(value: Hashtable);
    }
    class ExportText {
        useFullTextBoxWidth: boolean;
        useFullVerticalBorder: boolean;
        useFullHorizontalBorder: boolean;
        checkBoxTextForTrue: string;
        checkBoxTextForFalse: string;
        trimTrailingSpaces: boolean;
        removeLastNewLineMarker: boolean;
    }
    class CheckBoxReplacementForExcelValue_ {
        Font: Font;
        HorAlignment: StiTextHorAlignment;
        VertAlignment: StiVertAlignment;
    }
    class Export {
        static Word: ExportWord;
        static OpenDocumentWriter: ExportWriter;
        static OpenDocumentCalc: ExportCalc;
        static Html: ExportHtml;
        static Excel: ExportExcel;
        static PowerPoint: ExportPowerPoint;
        static Pdf: ExportPdf;
        static Text: ExportText;
        static CheckBoxReplacementForExcelValue: CheckBoxReplacementForExcelValue_;
        static optimizeDataOnlyMode: boolean;
        static checkBoxTextForTrue: string;
        static checkBoxTextForFalse: string;
    }
    class WebServer {
        static url: string;
        static timeout: number;
        static encryptData: boolean;
        static passQueryParametersToReport: boolean;
    }
}
declare namespace Stimulsoft.Report {
    class StiOptionsFontHelperAttribute {
        private _index;
        get index(): number;
        constructor(index: number);
    }
}
declare namespace Stimulsoft.Report {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiReportsCollection extends CollectionBase<StiReport> {
        add(report: StiReport, resetPageNumber?: boolean, printOnPreviousPage?: boolean): void;
        private owner;
        constructor(owner: StiReport);
    }
}
declare namespace Stimulsoft.Report {
    import PaperKind = Stimulsoft.System.Drawing.Printing.PaperKind;
    import StiPageOrientation = Stimulsoft.Report.Components.StiPageOrientation;
    import StiMargins = Stimulsoft.Report.Components.StiMargins;
    import StiResizeReportOptions = Stimulsoft.Report.StiResizeReportOptions;
    class StiResizeReportHelper {
        private static setPageParameters;
        static resizeReportAsync(report: StiReport, orientation: StiPageOrientation, paperSize: PaperKind, margins: StiMargins, pageWidth: number, pageHeight: number, options: StiResizeReportOptions, indexOfRenderedPage?: number): Promise<void>;
    }
}
declare namespace Stimulsoft.Report {
    import StiSimpleText = Stimulsoft.Report.Components.StiSimpleText;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiRuntimeVariables {
        clone(): StiRuntimeVariables;
        page: StiPage;
        textBox: StiSimpleText;
        line: number;
        column: number;
        lineThrough: number;
        dataSourcesPosition: Hashtable;
        private _pageIndex;
        get pageIndex(): number;
        set pageIndex(value: number);
        private _currentPrintPage;
        get currentPrintPage(): number;
        set currentPrintPage(value: number);
        setVariables(report: StiReport): void;
        constructor(report: StiReport);
    }
}
declare namespace Stimulsoft.Report {
    class StiStatesManager {
        private static ValueBoolFalse;
        private static ValueBoolTrue;
        private states;
        push(stateName: string, obj: any, property: string, value: any): void;
        pushBool(stateName: string, obj: any, property: string, value: boolean): void;
        pushInt(stateName: string, obj: any, property: string, value: number): void;
        pushInt64(stateName: string, obj: any, property: string, value: number): void;
        pushFloat(stateName: string, obj: any, property: string, value: number): void;
        pushDouble(stateName: string, obj: any, property: string, value: number): void;
        pushDecimal(stateName: string, obj: any, property: string, value: number): void;
        pushRange(stateName: string, obj: any, property: string, value: Range): void;
        pop(stateName: string, obj: any, property: string): any;
        popBool(stateName: string, obj: any, property: string): boolean;
        popInt(stateName: string, obj: any, property: string): number;
        popInt64(stateName: string, obj: any, property: string): number;
        popDouble(stateName: string, obj: any, property: string): number;
        popFloat(stateName: string, obj: any, property: string): number;
        popDecimal(stateName: string, obj: any, property: string): number;
        popRange(stateName: string, obj: any, property: string): Range;
        isExist(stateName: string, obj: any): boolean;
        clearState(stateName: string): void;
        clear(): void;
    }
}
declare namespace Stimulsoft.Report {
    class StiSystemVariableLocHelper {
        static getPageNofM(report: StiReport): string;
        static getPageNofMThrough(report: StiReport): string;
        static getPageNofMIdent(report: StiReport): string;
        private static getIdent;
        private static locs;
    }
}
declare namespace Stimulsoft.Report {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiText = Stimulsoft.Report.Components.StiText;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiFitTextInfo {
        hashText: Hashtable;
        hashComponent: Hashtable;
        private hashFontString;
        getFontString(font: Font): string;
        getFontSizeObject(textBox: StiText, rect: RectangleD, text: string, REFfontSize: {
            ref: number;
        }, REFhashSt: {
            ref: string;
        }): any;
        clear(): void;
    }
    class StiViewerFitTextHelper {
        private static hashes;
        private static _enabled;
        static get enabled(): boolean;
        static set enabled(value: boolean);
        static addReport(report: StiReport): void;
        static removeReport(report: StiReport): void;
        static clearReportInfo(report: StiReport): void;
        static getReportInfo(report: StiReport): StiFitTextInfo;
        static clear(): void;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IAsIs = Stimulsoft.System.IAsIs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionSortDirection = Stimulsoft.Report.Components.StiInteractionSortDirection;
    import StiDrillDownMode = Stimulsoft.Report.Components.StiDrillDownMode;
    class StiInteraction implements ICloneable, IStiJsonReportObject, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadInteractionFromJsonObject(jObject: StiJson): StiInteraction;
        static loadInteractionFromXml(xmlNode: XmlNode): Stimulsoft.Report.Components.StiInteraction;
        loadFromXml(xmlNode: XmlNode): void;
        getReport(): any;
        clone(): StiInteraction;
        isDefault(): boolean;
        private _sortingEnabled;
        get sortingEnabled(): boolean;
        set sortingEnabled(value: boolean);
        private _sortingColumn;
        get sortingColumn(): string;
        set sortingColumn(value: string);
        private _sortingIndex;
        get sortingIndex(): number;
        set sortingIndex(value: number);
        private _sortingDirection;
        get sortingDirection(): StiInteractionSortDirection;
        set sortingDirection(value: StiInteractionSortDirection);
        private _drillDownEnabled;
        get drillDownEnabled(): boolean;
        set drillDownEnabled(value: boolean);
        private _drillDownReport;
        get drillDownReport(): string;
        set drillDownReport(value: string);
        private _drillDownMode;
        get drillDownMode(): StiDrillDownMode;
        set drillDownMode(value: StiDrillDownMode);
        private _drillDownParameter1;
        get drillDownParameter1(): StiDrillDownParameter;
        set drillDownParameter1(value: StiDrillDownParameter);
        private _drillDownParameter2;
        get drillDownParameter2(): StiDrillDownParameter;
        set drillDownParameter2(value: StiDrillDownParameter);
        private _drillDownParameter3;
        get drillDownParameter3(): StiDrillDownParameter;
        set drillDownParameter3(value: StiDrillDownParameter);
        private _drillDownParameter4;
        get drillDownParameter4(): StiDrillDownParameter;
        set drillDownParameter4(value: StiDrillDownParameter);
        private _drillDownParameter5;
        get drillDownParameter5(): StiDrillDownParameter;
        set drillDownParameter5(value: StiDrillDownParameter);
        private _drillDownParameter6;
        get drillDownParameter6(): StiDrillDownParameter;
        set drillDownParameter6(value: StiDrillDownParameter);
        private _drillDownParameter7;
        get drillDownParameter7(): StiDrillDownParameter;
        set drillDownParameter7(value: StiDrillDownParameter);
        private _drillDownParameter8;
        get drillDownParameter8(): StiDrillDownParameter;
        set drillDownParameter8(value: StiDrillDownParameter);
        private _drillDownParameter9;
        get drillDownParameter9(): StiDrillDownParameter;
        set drillDownParameter9(value: StiDrillDownParameter);
        private _drillDownParameter10;
        get drillDownParameter10(): StiDrillDownParameter;
        set drillDownParameter10(value: StiDrillDownParameter);
        get drillDownPage(): StiPage;
        set drillDownPage(value: StiPage);
        private _drillDownPageGuid;
        get drillDownPageGuid(): string;
        set drillDownPageGuid(value: string);
        get bookmark(): string;
        set bookmark(value: string);
        get hyperlink(): string;
        set hyperlink(value: string);
        get tag(): string;
        set tag(value: string);
        get toolTip(): string;
        set toolTip(value: string);
        getSortDataBandName(): string;
        getSortColumns(): string[];
        getSortColumnsString(): string;
        parentComponent: StiComponent;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiBandInteraction extends StiInteraction implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        isDefault(): boolean;
        collapsingEnabled: boolean;
        selectionEnabled: boolean;
        collapseGroupFooter: boolean;
        get collapsed(): string;
        set collapsed(value: string);
        selectedLine: number;
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiGroupFooterBand extends StiDynamicBand implements IStiKeepGroupFooterTogether, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean, cloneComponents: boolean): StiGroupFooterBand;
        private _keepGroupFooterTogether;
        get keepGroupFooterTogether(): boolean;
        set keepGroupFooterTogether(value: boolean);
        private _groupFooterBandInfo;
        get groupFooterBandInfo(): StiGroupFooterBandInfo;
        get line(): number;
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        protected getComponentType(): StiComponentType;
        get priority(): number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiPageBreak: System.Interface<IStiPageBreak>;
    interface IStiPageBreak {
        newColumnBefore: boolean;
        newColumnAfter: boolean;
        newPageBefore: boolean;
        newPageAfter: boolean;
        breakIfLessThan: number;
        skipFirst: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IAsIs = Stimulsoft.System.IAsIs;
    let IStiMasterComponent: System.Interface<IStiMasterComponent>;
    interface IStiMasterComponent extends IAsIs {
        masterComponent: StiComponent;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiPrintOnAllPages: System.Interface<IStiPrintOnAllPages>;
    interface IStiPrintOnAllPages {
        printOnAllPages: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHeaderBand extends StiDynamicBand implements IStiPrintIfEmpty, IStiPrintOnAllPages, IStiPrintOnEvenOddPages, IStiKeepHeaderTogether, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean, cloneComponents: boolean): StiHeaderBand;
        private _keepHeaderTogether;
        get keepHeaderTogether(): boolean;
        set keepHeaderTogether(value: boolean);
        private _startNewPage;
        get startNewPage(): boolean;
        set startNewPage(value: boolean);
        get startNewPageIfLessThan(): number;
        set startNewPageIfLessThan(value: number);
        private _printIfEmpty;
        get printIfEmpty(): boolean;
        set printIfEmpty(value: boolean);
        private _printOnAllPages;
        get printOnAllPages(): boolean;
        set printOnAllPages(value: boolean);
        private _printOnEvenOddPages;
        get printOnEvenOddPages(): StiPrintOnEvenOddPagesType;
        set printOnEvenOddPages(value: StiPrintOnEvenOddPagesType);
        private _headerBandInfo;
        get headerBandInfo(): StiHeaderBandInfo;
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get priority(): number;
        protected getComponentType(): StiComponentType;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import EventArgs = Stimulsoft.System.EventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiFooterBand extends StiDynamicBand implements IStiPrintOnAllPages, IStiPrintIfEmpty, IStiKeepFooterTogether, IStiPrintOnEvenOddPages, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _keepFooterTogether;
        get keepFooterTogether(): boolean;
        set keepFooterTogether(value: boolean);
        clone(cloneProperties: boolean, cloneComponents: boolean): StiFooterBand;
        private _startNewPage;
        get startNewPage(): boolean;
        set startNewPage(value: boolean);
        get startNewPageIfLessThan(): number;
        set startNewPageIfLessThan(value: number);
        private _printIfEmpty;
        get printIfEmpty(): boolean;
        set printIfEmpty(value: boolean);
        private _printOnEvenOddPages;
        get printOnEvenOddPages(): StiPrintOnEvenOddPagesType;
        set printOnEvenOddPages(value: StiPrintOnEvenOddPagesType);
        private _printOnAllPages;
        get printOnAllPages(): boolean;
        set printOnAllPages(value: boolean);
        private _footerBandInfo;
        get footerBandInfo(): StiFooterBandInfo;
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get priority(): number;
        protected getComponentType(): StiComponentType;
        private static eventMoveFooterToBottom;
        protected onMoveFooterToBottom(e: EventArgs): void;
        invokeMoveFooterToBottom(): void;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiGroupHeaderBand = Stimulsoft.Report.Components.StiGroupHeaderBand;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiFooterBand = Stimulsoft.Report.Components.StiFooterBand;
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiDataBandBuilder extends StiBandBuilder {
        getGroupHeaders(masterDataBand: StiDataBand): StiComponentsCollection;
        getGroupFooters(masterDataBand: StiDataBand): StiComponentsCollection;
        groupsComparison(masterDataBand: StiDataBand): void;
        findHeaders(masterDataBand: StiDataBand): void;
        findHierarchicalHeaders(masterDataBand: StiDataBand): void;
        findFooters(masterDataBand: StiDataBand): void;
        findHierarchicalFooters(masterDataBand: StiDataBand): void;
        findEmptyBands(masterDataBand: StiDataBand): void;
        findGroupHeaders(masterDataBand: StiDataBand): void;
        findGroupFooters(masterDataBand: StiDataBand): void;
        findDetailDataBands(masterDataBand: StiDataBand): void;
        private isParentOrCurrentBO;
        findSubReports(masterDataBand: StiDataBand): void;
        findDetails(masterDataBand: StiDataBand): void;
        resetHeaders(masterDataBand: StiDataBand): void;
        resetHierarchicalHeaders(masterDataBand: StiDataBand): void;
        resetFooters(masterDataBand: StiDataBand): void;
        resetHierarchicalFooters(masterDataBand: StiDataBand): void;
        resetEmptyBands(masterDataBand: StiDataBand): void;
        resetGroupHeaders(masterDataBand: StiDataBand): void;
        resetGroupFooters(masterDataBand: StiDataBand): void;
        resetDetailDataBands(masterDataBand: StiDataBand): void;
        resetDetails(masterDataBand: StiDataBand): void;
        addKeepLevelAtLatestDataBandAsync(masterDataBand: StiDataBand): Promise<void>;
        addKeepLevelAtLatestDataBand(masterDataBand: StiDataBand): void;
        addKeepLevelAsync(masterDataBand: StiDataBand): Promise<void>;
        addKeepLevel(masterDataBand: StiDataBand): void;
        removeKeepLevelAsync(masterDataBand: StiDataBand): Promise<void>;
        removeKeepLevel(masterDataBand: StiDataBand): void;
        removeKeepGroupHeadersAsync(masterDataBand: StiDataBand): Promise<void>;
        removeKeepGroupHeaders(masterDataBand: StiDataBand): void;
        removeKeepHeadersAsync(masterDataBand: StiDataBand, keepHeaders: boolean[]): Promise<void>;
        removeKeepHeaders(masterDataBand: StiDataBand, keepHeaders: boolean[]): void;
        allowKeepDetails(masterDataBand: StiDataBand): boolean;
        addKeepDetailsAsync(masterDataBand: StiDataBand): Promise<void>;
        addKeepDetails(masterDataBand: StiDataBand): void;
        removeKeepDetailsAsync(masterDataBand: StiDataBand): Promise<void>;
        removeKeepDetails(masterDataBand: StiDataBand): void;
        removeKeepDetailsRowAsync(masterDataBand: StiDataBand): Promise<void>;
        removeKeepDetailsRow(masterDataBand: StiDataBand): void;
        startBands(masterDataBand: StiDataBand, bands: StiComponentsCollection): void;
        startBand(masterDataBand: StiDataBand, band: StiBand): void;
        endBands(masterDataBand: StiDataBand): void;
        getGroupHeaderResult(masterDataBand: StiDataBand, groupHeaderBand: StiGroupHeaderBand): boolean;
        getGroupFooterResult(masterDataBand: StiDataBand, groupHeaderBand: StiGroupHeaderBand): boolean;
        linkGroupHeadersAndGroupFooters(masterDataBand: StiDataBand): void;
        resetLinkGroupHeadersAndGroupFooters(masterDataBand: StiDataBand): void;
        static prepareGroupResults(masterDataBand: StiDataBand): void;
        renderGroupHeadersAsync(masterDataBand: StiDataBand): Promise<void>;
        renderGroupHeaders(masterDataBand: StiDataBand): void;
        renderGroupFootersAsync(masterDataBand: StiDataBand): Promise<void>;
        renderGroupFooters(masterDataBand: StiDataBand): void;
        static setDetails(masterDataBand: StiDataBand): void;
        renderDetailDataBandsAsync(masterDataBand: StiDataBand): Promise<void>;
        renderDetailDataBands(masterDataBand: StiDataBand): void;
        private getParentDataBand;
        private isAllow;
        allowDetailDataBands(masterDataBand: StiDataBand): boolean;
        isDenyDetailsOnFirstPage(masterDataBand: StiDataBand): boolean;
        static isDetailDataSourcesEmpty(masterDataBand: StiDataBand): boolean;
        static isPrintIfDetailEmpty(masterDataBand: StiDataBand): boolean;
        renderHeadersAsync(masterDataBand: StiDataBand, keepHeaders: boolean[]): Promise<void>;
        renderHeaders(masterDataBand: StiDataBand, keepHeaders: boolean[]): void;
        renderHierarchicalHeadersAsync(masterDataBand: StiDataBand, allowIndent: boolean, level: number): Promise<void>;
        renderHierarchicalHeaders(masterDataBand: StiDataBand, allowIndent: boolean, level: number): void;
        addFooterMarkerAsync(masterDataBand: StiDataBand, footerMaster: StiFooterBand): Promise<void>;
        addFooterMarker(masterDataBand: StiDataBand, footerMaster: StiFooterBand): void;
        renderMarkerFootersOnAllPagesAsync(masterDataBand: StiDataBand): Promise<void>;
        renderMarkerFootersOnAllPages(masterDataBand: StiDataBand): void;
        renderFootersOnLastPageAsync(masterDataBand: StiDataBand): Promise<void>;
        renderFootersOnLastPage(masterDataBand: StiDataBand): void;
        renderFootersOnAllPagesAsync(masterDataBand: StiDataBand): Promise<void>;
        renderFootersOnAllPages(masterDataBand: StiDataBand): void;
        renderHierarchicalFootersAsync(masterDataBand: StiDataBand, allowIndent: boolean, level: number): Promise<void>;
        renderHierarchicalFooters(masterDataBand: StiDataBand, allowIndent: boolean, level: number): void;
        renderReportTitlesAsync(masterDataBand: StiDataBand): Promise<void>;
        renderReportTitles(masterDataBand: StiDataBand): void;
        renderReportSummariesAsync(masterDataBand: StiDataBand): Promise<void>;
        renderReportSummaries(masterDataBand: StiDataBand): void;
        checkKeepReportSummaryTogether(masterDataBand: StiDataBand): boolean;
        block(masterDataBand: StiDataBand): void;
        unBlock(masterDataBand: StiDataBand): void;
        checkHierarchicalHeadersAsync(masterDataBand: StiDataBand): Promise<void>;
        checkHierarchicalHeaders(masterDataBand: StiDataBand): void;
        checkHierarchicalFootersAsync(masterDataBand: StiDataBand): Promise<void>;
        checkHierarchicalFooters(masterDataBand: StiDataBand): void;
        renderBandAsync(masterDataBand: StiDataBand, band: StiBand, ignorePageBreaks?: boolean, allowRenderingEvents?: boolean): Promise<void>;
        renderBand(masterDataBand: StiDataBand, band: StiBand, ignorePageBreaks?: boolean, allowRenderingEvents?: boolean): void;
        renderColumnsAsync(masterDataBand: StiDataBand): Promise<void>;
        renderColumns(masterDataBand: StiDataBand): void;
        registerEmptyBands(masterDataBand: StiDataBand): void;
        static isCollapsed(masterDataBand: StiContainer, isRendering: boolean): boolean;
        setReportVariables(masterComp: StiComponent): void;
        prepare(masterComp: StiComponent): void;
        unPrepare(masterComp: StiComponent): void;
        private static invokeCollapsedEvent;
        renderAsync(masterComp: StiComponent): Promise<StiComponent>;
        render(masterComp: StiComponent): StiComponent;
        renderMasterAsync(masterDataBand: StiDataBand): Promise<void>;
        renderMaster(masterDataBand: StiDataBand): void;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiAggregateFunctionService {
        get serviceName(): string;
        init(): void;
        reset(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        isFirstInit: boolean;
        get recureParam(): boolean;
        private _runningTotal;
        get runningTotal(): boolean;
        set runningTotal(value: boolean);
        constructor(runningTotal?: boolean);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiSumFunctionService extends StiAggregateFunctionService {
        private summary;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiSumTimeFunctionService extends StiAggregateFunctionService {
        private sumValue;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiAvgFunctionService extends StiAggregateFunctionService {
        private summary;
        private count;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiAvgDateFunctionService extends StiAggregateFunctionService {
        private avgValue;
        private count;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiAvgTimeFunctionService extends StiAggregateFunctionService {
        private avgValue;
        private count;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiMaxFunctionService extends StiAggregateFunctionService {
        private maximum;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiMinFunctionService extends StiAggregateFunctionService {
        private minimum;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiMedianFunctionService extends StiAggregateFunctionService {
        private values;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiModeFunctionService extends StiAggregateFunctionService {
        private values;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiFirstFunctionService extends StiAggregateFunctionService {
        private value;
        private first;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiLastFunctionService extends StiAggregateFunctionService {
        private value;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiCountFunctionService extends StiAggregateFunctionService {
        private counter;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiCountDistinctFunctionService extends StiAggregateFunctionService {
        private counter;
        private values;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiMinDateFunctionService extends StiAggregateFunctionService {
        private valueProcessed;
        private minimum;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiMinTimeFunctionService extends StiAggregateFunctionService {
        private valueProcessed;
        private minimum;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiMinStrFunctionService extends StiAggregateFunctionService {
        private values;
        static ascComparison(str1: string, str2: string): number;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiMaxDateFunctionService extends StiAggregateFunctionService {
        private valueProcessed;
        private maximum;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiMaxTimeFunctionService extends StiAggregateFunctionService {
        private valueProcessed;
        private maximum;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiMaxStrFunctionService extends StiAggregateFunctionService {
        private values;
        static ascComparison(str1: string, str2: string): number;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiSumDistinctFunctionService extends StiAggregateFunctionService {
        private summary;
        private values;
        get serviceName(): string;
        init(): void;
        calcItem(value: any, valueToSum?: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiSumNullableFunctionService extends StiAggregateFunctionService {
        private summary;
        private hasValues;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiRankOrder = Stimulsoft.Report.StiRankOrder;
    class StiRankFunctionService extends StiAggregateFunctionService {
        private hash;
        private sortOrder;
        private dense;
        get serviceName(): string;
        init(): void;
        calcItem(value: any): void;
        getValue(): any;
        setValue(value: any): void;
        get recureParam(): boolean;
        constructor(runningTotal: boolean, dense?: boolean, sortOrder?: StiRankOrder);
    }
}
declare namespace Stimulsoft.Report {
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import DateTime = Stimulsoft.System.DateTime;
    class Totals {
        static getMethod(report: StiReport, name: string): any;
        private static calculate;
        private static calculate1;
        private static calcItem;
        private static calculateByCondition;
        private static compareValue;
        private static calculateNullable;
        private static calculateRunning;
        static sum(data: any, report: StiReport, name: string): number;
        static sumNullable(data: any, report: StiReport, name: string): number;
        static sumDistinct(data: any, report: StiReport, name: string, name2?: string): number;
        static cSum(data: any, report: StiReport, name: string): number;
        static cSumRunning(data: any, report: StiReport, name: string): number;
        static sumAllLevels(data: any, report: StiReport, name: string): number;
        static sumAllLevelsByCondition(data: any, report: StiReport, name: string, filterCondition: StiFilterCondition, value1: number, value2: number): number;
        static sumAllLevelsOnlyChilds(data: any, report: StiReport, name: string): number;
        static sumOnlyChilds(data: any, report: StiReport, name: string): number;
        static sumTime(data: any, report: StiReport, name: string): TimeSpan;
        static cSumTime(data: any, report: StiReport, name: string): TimeSpan;
        static sumTimeAllLevels(data: any, report: StiReport, name: string): TimeSpan;
        static sumTimeAllLevelsOnlyChilds(data: any, report: StiReport, name: string): TimeSpan;
        static sumTimeOnlyChilds(data: any, report: StiReport, name: string): TimeSpan;
        static avg(data: any, report: StiReport, name: string): number;
        static cAvg(data: any, report: StiReport, name: string): number;
        static cAvgRunning(data: any, report: StiReport, name: string): number;
        static avgAllLevels(data: any, report: StiReport, name: string): number;
        static avgAllLevelsOnlyChilds(data: any, report: StiReport, name: string): number;
        static avgOnlyChilds(data: any, report: StiReport, name: string): number;
        static avgDate(data: any, report: StiReport, name: string): DateTime;
        static cAvgDate(data: any, report: StiReport, name: string): DateTime;
        static avgDateAllLevels(data: any, report: StiReport, name: string): DateTime;
        static avgDateAllLevelsOnlyChilds(data: any, report: StiReport, name: string): DateTime;
        static avgDateOnlyChilds(data: any, report: StiReport, name: string): DateTime;
        static avgTime(data: any, report: StiReport, name: string): TimeSpan;
        static cAvgTime(data: any, report: StiReport, name: string): TimeSpan;
        static avgTimeAllLevels(data: any, report: StiReport, name: string): TimeSpan;
        static avgTimeAllLevelsOnlyChilds(data: any, report: StiReport, name: string): TimeSpan;
        static avgTimeOnlyChilds(data: any, report: StiReport, name: string): TimeSpan;
        static max(data: any, report: StiReport, name: string): number;
        static cMax(data: any, report: StiReport, name: string): number;
        static cMaxRunning(data: any, report: StiReport, name: string): number;
        static maxAllLevels(data: any, report: StiReport, name: string): number;
        static maxAllLevelsOnlyChilds(data: any, report: StiReport, name: string): number;
        static maxOnlyChilds(data: any, report: StiReport, name: string): number;
        static min(data: any, report: StiReport, name: string): number;
        static cMin(data: any, report: StiReport, name: string): number;
        static cMinRunning(data: any, report: StiReport, name: string): number;
        static minAllLevels(data: any, report: StiReport, name: string): number;
        static minAllLevelsOnlyChilds(data: any, report: StiReport, name: string): number;
        static minOnlyChilds(data: any, report: StiReport, name: string): number;
        static median(data: any, report: StiReport, name: string): number;
        static cMedian(data: any, report: StiReport, name: string): number;
        static cMedianRunning(data: any, report: StiReport, name: string): number;
        static medianAllLevels(data: any, report: StiReport, name: string): number;
        static medianAllLevelsOnlyChilds(data: any, report: StiReport, name: string): number;
        static medianOnlyChilds(data: any, report: StiReport, name: string): number;
        static mode(data: any, report: StiReport, name: string): number;
        static cMode(data: any, report: StiReport, name: string): number;
        static cModeRunning(data: any, report: StiReport, name: string): number;
        static modeAllLevels(data: any, report: StiReport, name: string): number;
        static modeAllLevelsOnlyChilds(data: any, report: StiReport, name: string): number;
        static modeOnlyChilds(data: any, report: StiReport, name: string): number;
        static first(data: any, report: StiReport, name: string): any;
        static cFirst(data: any, report: StiReport, name: string): any;
        static cFirstRunning(data: any, report: StiReport, name: string): any;
        static firstAllLevels(data: any, report: StiReport, name: string): any;
        static firstAllLevelsOnlyChilds(data: any, report: StiReport, name: string): any;
        static firstOnlyChilds(data: any, report: StiReport, name: string): any;
        static last(data: any, report: StiReport, name: string): any;
        static cLast(data: any, report: StiReport, name: string): any;
        static cLastRunning(data: any, report: StiReport, name: string): any;
        static lastAllLevels(data: any, report: StiReport, name: string): any;
        static lastAllLevelsOnlyChilds(data: any, report: StiReport, name: string): any;
        static lastOnlyChilds(data: any, report: StiReport, name: string): any;
        static count(data: any, report?: StiReport, name?: string): number;
        static cCount(data: any, report?: StiReport, name?: string): number;
        static cCountRunning(data: any, report?: StiReport, name?: string): number;
        static countAllLevels(data: any): number;
        static countAllLevelsOnlyChilds(data: any): number;
        static countOnlyChilds(data: any): number;
        static countDistinct(data: any, report: StiReport, name: string): number;
        static cCountDistinct(data: any, report: StiReport, name: string): number;
        static cCountDistinctRunning(data: any, report: StiReport, name: string): number;
        static countDistinctAllLevels(data: any, report: StiReport, name: string): number;
        static countDistinctAllLevelsOnlyChilds(data: any, report: StiReport, name: string): number;
        static countDistinctOnlyChilds(data: any, report: StiReport, name: string): number;
        static minDate(data: any, report: StiReport, name: string): DateTime;
        static cMinDate(data: any, report: StiReport, name: string): DateTime;
        static minDateAllLevels(data: any, report: StiReport, name: string): DateTime;
        static minDateAllLevelsOnlyChilds(data: any, report: StiReport, name: string): DateTime;
        static minDateOnlyChilds(data: any, report: StiReport, name: string): DateTime;
        static minTime(data: any, report: StiReport, name: string): TimeSpan;
        static cMinTime(data: any, report: StiReport, name: string): TimeSpan;
        static minTimeAllLevels(data: any, report: StiReport, name: string): TimeSpan;
        static minTimeAllLevelsOnlyChilds(data: any, report: StiReport, name: string): TimeSpan;
        static minTimeOnlyChilds(data: any, report: StiReport, name: string): TimeSpan;
        static minStr(data: any, report: StiReport, name: string): string;
        static cMinStr(data: any, report: StiReport, name: string): string;
        static minStrAllLevels(data: any, report: StiReport, name: string): string;
        static minStrAllLevelsOnlyChilds(data: any, report: StiReport, name: string): string;
        static minStrOnlyChilds(data: any, report: StiReport, name: string): string;
        static maxDate(data: any, report: StiReport, name: string): DateTime;
        static cMaxDate(data: any, report: StiReport, name: string): DateTime;
        static maxDateAllLevels(data: any, report: StiReport, name: string): DateTime;
        static maxDateAllLevelsOnlyChilds(data: any, report: StiReport, name: string): DateTime;
        static maxDateOnlyChilds(data: any, report: StiReport, name: string): DateTime;
        static maxTime(data: any, report: StiReport, name: string): TimeSpan;
        static cMaxTime(data: any, report: StiReport, name: string): TimeSpan;
        static maxTimeAllLevels(data: any, report: StiReport, name: string): TimeSpan;
        static maxTimeAllLevelsOnlyChilds(data: any, report: StiReport, name: string): TimeSpan;
        static maxTimeOnlyChilds(data: any, report: StiReport, name: string): TimeSpan;
        static maxStr(data: any, report: StiReport, name: string): string;
        static cMaxStr(data: any, report: StiReport, name: string): string;
        static maxStrAllLevels(data: any, report: StiReport, name: string): string;
        static maxStrAllLevelsOnlyChilds(data: any, report: StiReport, name: string): string;
        static maxStrOnlyChilds(data: any, report: StiReport, name: string): string;
        static rank(data: any, report: StiReport, name: string, dense?: boolean, sortOrder?: StiRankOrder): number;
        private static saveState;
        private static restoreState;
        private static storeCachedValue;
        private static getCachedValue;
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    enum CodeSet {
        None = 0,
        A = 1,
        B = 2,
        C = 3
    }
    enum ControlCodes {
        FNC1 = 129,
        FNC2 = 130,
        FNC3 = 131,
        FNC4 = 132,
        CodeA = 133,
        CodeB = 134,
        CodeC = 135,
        Shift = 136
    }
    enum BarcodeCommands {
        FNC1 = 102,
        FNC2 = 97,
        FNC3 = 96,
        FNC4A = 101,
        FNC4B = 100,
        CodeA = 101,
        CodeB = 100,
        CodeC = 99,
        Shift = 98,
        StartA = 103,
        StartB = 104,
        StartC = 105,
        Stop = 106
    }
    enum StiCheckSum {
        Yes = 0,
        No = 1
    }
    enum StiPlesseyCheckSum {
        None = 0,
        Modulo10 = 1,
        Modulo11 = 2
    }
    enum StiDataMatrixSize {
        Automatic = -1,
        s10x10 = 0,
        s12x12 = 1,
        s8x18 = 2,
        s14x14 = 3,
        s8x32 = 4,
        s16x16 = 5,
        s12x26 = 6,
        s18x18 = 7,
        s20x20 = 8,
        s12x36 = 9,
        s22x22 = 10,
        s16x36 = 11,
        s24x24 = 12,
        s26x26 = 13,
        s16x48 = 14,
        s32x32 = 15,
        s36x36 = 16,
        s40x40 = 17,
        s44x44 = 18,
        s48x48 = 19,
        s52x52 = 20,
        s64x64 = 21,
        s72x72 = 22,
        s80x80 = 23,
        s88x88 = 24,
        s96x96 = 25,
        s104x104 = 26,
        s120x120 = 27,
        s132x132 = 28,
        s144x144 = 29
    }
    enum StiDataMatrixEncodingType {
        Ascii = 0,
        C40 = 1,
        Text = 2,
        X12 = 3,
        Edifact = 4,
        Binary = 5
    }
    enum StiPdf417EncodingMode {
        Text = 0,
        Numeric = 1,
        Byte = 2
    }
    enum StiPdf417ErrorsCorrectionLevel {
        Automatic = -1,
        Level0 = 0,
        Level1 = 1,
        Level2 = 2,
        Level3 = 3,
        Level4 = 4,
        Level5 = 5,
        Level6 = 6,
        Level7 = 7,
        Level8 = 8
    }
    enum StiEanSupplementType {
        None = 0,
        TwoDigit = 1,
        FiveDigit = 2
    }
    enum StiCode11CheckSum {
        None = 0,
        OneDigit = 1,
        TwoDigits = 2,
        Auto = 3
    }
    enum StiQRCodeSize {
        Automatic = 0,
        v1 = 1,
        v2 = 2,
        v3 = 3,
        v4 = 4,
        v5 = 5,
        v6 = 6,
        v7 = 7,
        v8 = 8,
        v9 = 9,
        v10 = 10,
        v11 = 11,
        v12 = 12,
        v13 = 13,
        v14 = 14,
        v15 = 15,
        v16 = 16,
        v17 = 17,
        v18 = 18,
        v19 = 19,
        v20 = 20,
        v21 = 21,
        v22 = 22,
        v23 = 23,
        v24 = 24,
        v25 = 25,
        v26 = 26,
        v27 = 27,
        v28 = 28,
        v29 = 29,
        v30 = 30,
        v31 = 31,
        v32 = 32,
        v33 = 33,
        v34 = 34,
        v35 = 35,
        v36 = 36,
        v37 = 37,
        v38 = 38,
        v39 = 39,
        v40 = 40
    }
    enum StiQRCodeErrorCorrectionLevel {
        Level1 = 0,
        Level2 = 1,
        Level3 = 2,
        Level4 = 3
    }
    enum StiQRCodeECIMode {
        Cp437 = 2,
        ISO_8859_1 = 3,
        ISO_8859_2 = 4,
        ISO_8859_3 = 5,
        ISO_8859_4 = 6,
        ISO_8859_5 = 7,
        ISO_8859_6 = 8,
        ISO_8859_7 = 9,
        ISO_8859_8 = 10,
        ISO_8859_9 = 11,
        ISO_8859_11 = 13,
        ISO_8859_13 = 15,
        ISO_8859_15 = 17,
        Shift_JIS = 20,
        Windows_1250 = 21,
        Windows_1251 = 22,
        Windows_1252 = 23,
        Windows_1256 = 24,
        UTF_8 = 26
    }
    enum StiMaxicodeMode {
        Mode2 = 2,
        Mode3 = 3,
        Mode4 = 4,
        Mode5 = 5,
        Mode6 = 6
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import IStiBackColor = Stimulsoft.Report.Components.IStiBackColor;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    let IStiBarCode: System.Interface<IStiBarCode>;
    interface IStiBarCode extends IStiBackColor, IStiForeColor {
        getBarCodeString(): string;
        autoScale: boolean;
        showLabelText: boolean;
        barCodeType: StiBarCodeTypeService;
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiService = Stimulsoft.Base.Services.StiService;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import Image = Stimulsoft.System.Drawing.Image;
    import IStiBarCodePainter = Stimulsoft.Report.Painters.IStiBarCodePainter;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    interface DrawBaseLinesDelegate {
        (cobtext: any, brush: StiBrush, barCode: StiBarCodeTypeService): any;
    }
    enum BarcodeCommandCode {
        Fnc1 = 256,
        Fnc2 = 512,
        Fnc3 = 768,
        Fnc4 = 1024
    }
    class StiBarCodeTypeService extends StiService {
        getNetTypeName(): string;
        static loadFromJsonObjectInternal(jObject: StiJson): StiBarCodeTypeService;
        static loadFromXmlInternal(xmlNode: XmlNode): StiBarCodeTypeService;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        get componentId(): StiComponentId;
        loadFromXmlObject(xmlNode: XmlNode): void;
        visiblePropertiesCount: number;
        private _visibleProperties;
        get visibleProperties(): boolean[];
        set visibleProperties(value: boolean[]);
        get defaultCodeValue(): string;
        private _customPainter;
        get customPainter(): IStiBarCodePainter;
        set customPainter(value: IStiBarCodePainter);
        private _mainWidth;
        get mainWidth(): number;
        private _mainHeight;
        get mainHeight(): number;
        private _barCodeData;
        get barCodeData(): StiBarCodeData;
        get module(): number;
        set module(value: number);
        get height(): number;
        set height(value: number);
        protected get textAlignment(): StringAlignment;
        protected get textSpacing(): boolean;
        protected rectWindow: RectangleD;
        get labelFontHeight(): number;
        protected defaultLabelFontHeight: number;
        protected checkCodeSymbols(inputCode: string, tolerantSymbols: string): string;
        getCode(barCode: IStiBarCode): string;
        getCombinedCode(): string;
        static unpackTilde(input: number[], processTilde: boolean): number[];
        protected getSymbolWidth(symbol: string): number;
        protected isSymbolLong(symbol: string): boolean;
        protected isSymbolSpace(symbol: string): boolean;
        protected isSymbolPostDescend(symbol: string): boolean;
        protected getSymbolsStringWidth(symbolsString: string): number;
        protected drawBars(context: any, sym: string, foreBrush: StiBrush): void;
        protected drawBarCode(context: any, rect: RectangleD, barCode: StiBarCode): void;
        protected drawBarCode1(context: any, rect: RectangleD, barCode: StiBarCode, drawMethod: DrawBaseLinesDelegate): void;
        protected calculateSizeFull(spaceLeft: number, spaceRight: number, spaceTop: number, spaceBottom: number, lineHeightShort: number, lineHeightLong: number, TextPosition: number, TextHeight: number, mainHeight: number, lineHeightForCut: number, wideToNarrowRatio: number, zoom: number, code: string, textString: string, barsArray: string, rect: RectangleD, barCode: StiBarCode): void;
        protected calculateSize2(spaceLeft: number, spaceRight: number, spaceTop: number, spaceBottom: number, lineHeightShort: number, lineHeightLong: number, textPosition: number, textHeight: number, mainHeight: number, wideToNarrowRatio: number, zoom: number, barsArray: string, rect: RectangleD, barCode: StiBarCode): void;
        protected draw2DBarCode(context: any, rect: RectangleD, barCode: StiBarCode, zoom: number): void;
        protected drawMaxicode(context: any, rect: RectangleD, barCode: StiBarCode, zoom: number): void;
        protected drawBarCodeError(context: any, rect: RectangleD, barCode: StiBarCode): void;
        protected drawBarCodeError2(context: any, rect: RectangleD, barCode: StiBarCode, message: string): void;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        protected translateRect(context: any, rect: RectangleD, barCode: StiBarCode): void;
        protected rollbackTransform(context: any): void;
        protected baseDrawString(context: any, st: string, font: Font, brush: StiBrush, x: number, y: number): void;
        protected baseTransform(context: any, x: number, y: number, angle: number, dx: number, dy: number): void;
        protected baseRollbackTransform(context: any): void;
        baseFillRectangle(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        protected baseFillRectangle2D(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        protected baseFillPolygon(context: any, brush: StiBrush, points: PointD[]): void;
        protected baseFillEllipse(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        protected baseDrawRectangle(context: any, penColor: Color, penSize: number, x: number, y: number, width: number, height: number): void;
        protected baseDrawImage(context: any, image: Image, report: StiReport, x: number, y: number, width: number, height: number): void;
        protected baseDrawString2(context: any, st: string, font: Font, brush: StiBrush, rect: RectangleD, sf: StringFormat): void;
        protected baseMeasureString3(context: any, st: string, font: Font): SizeD;
        createNew(): StiBarCodeTypeService;
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiAustraliaPost4StateBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        get componentId(): StiComponentId;
        loadFromXmlObject(xmlNode: XmlNode): void;
        get serviceName(): string;
        protected australiaPost4StateSymbolsC: string;
        protected australiaPost4StateSymbolsN: string;
        private australiaPost4StateStartCode;
        private australiaPost4StateStopCode;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        protected australiaPost4StateSpaceLeft: number;
        protected australiaPost4StateSpaceRight: number;
        protected australiaPost4StateSpaceTop: number;
        protected australiaPost4StateSpaceBottom: number;
        protected australiaPost4StateLineHeightLong: number;
        protected australiaPost4StateLineHeightShort: number;
        protected australiaPost4StateTextPosition: number;
        protected australiaPost4StateTextHeight: number;
        protected australiaPost4StateMainHeight: number;
        protected australiaPost4StateLineHeightForCut: number;
        protected get textAlignment(): StringAlignment;
        private mult;
        private gen;
        private rSInitialise;
        private rSEncode;
        private charTo4State;
        private stateToBar;
        private makeBarsArray;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    class StiBarCodeData {
        spaceLeft: number;
        spaceRight: number;
        spaceTop: number;
        spaceBottom: number;
        lineHeightShort: number;
        lineHeightLong: number;
        lineWidth: number;
        textPosition: number;
        textHeight: number;
        mainHeight: number;
        mainWidth: number;
        wideToNarrowRatio: number;
        code: string;
        textString: string;
        barsArray: string;
        fullZoomY: number;
        spaceBeforeAdd: number;
        spaceTextTop: number;
        textPositionTop: number;
        textPositionBottom: number;
        eanBarsArray: EanBarInfo[];
        offsetY: number;
        matrixGrid: number[];
        matrixWidth: number;
        matrixHeight: number;
        matrixRatioY: number;
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiCodabarBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get serviceName(): string;
        private codabarSymbols;
        private codabarTable;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _ratio;
        get ratio(): number;
        set ratio(value: number);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        codabarSpaceLeft: number;
        codabarSpaceRight: number;
        codabarSpaceTop: number;
        codabarSpaceBottom: number;
        codabarLineHeightShort: number;
        codabarLineHeightLong: number;
        codabarTextPosition: number;
        codabarTextHeight: number;
        codabarMainHeight: number;
        codabarLineHeightForCut: number;
        codeToBar(inputCode: string): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, ratio?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiCode11BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get serviceName(): string;
        code11Symbols: string;
        code11StartStopSymbolIndex: number;
        code11Table: string[];
        code11SpaceLeft: number;
        code11SpaceRight: number;
        code11SpaceTop: number;
        code11SpaceBottom: number;
        code11LineHeightShort: number;
        code11LineHeightLong: number;
        code11TextPosition: number;
        code11TextHeight: number;
        code11MainHeight: number;
        code11LineHeightForCut: number;
        defaultCode11Module: number;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _checksum;
        get checksum(): StiCode11CheckSum;
        set checksum(value: StiCode11CheckSum);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, checksum?: StiCode11CheckSum);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiCode128BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        protected code128Table: string[];
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        protected code128SpaceLeft: number;
        protected code128SpaceRight: number;
        protected code128SpaceTop: number;
        protected code128SpaceBottom: number;
        protected code128LineHeightShort: number;
        protected code128LineHeightLong: number;
        protected code128TextPosition: number;
        protected code128TextHeight: number;
        protected code128MainHeight: number;
        protected code128LineHeightForCut: number;
        protected defaultCodeSetAB: CodeSet;
        protected codeToBar(inputCode: string): string;
        protected encodeAuto(inputText: string, encodeAsEan: boolean): string;
        private isDigit;
        private getSet;
        constructor(module?: number, height?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode128AutoBarCodeType extends StiCode128BarCodeType {
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode128aBarCodeType extends StiCode128BarCodeType {
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode128bBarCodeType extends StiCode128BarCodeType {
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode128cBarCodeType extends StiCode128BarCodeType {
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiCode39BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get serviceName(): string;
        code39Symbols: string;
        code39StartStopSymbolIndex: number;
        code39Table: string[];
        get defaultCodeValue(): string;
        private _checkSum;
        get checkSum(): StiCheckSum;
        set checkSum(value: StiCheckSum);
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _ratio;
        get ratio(): number;
        set ratio(value: number);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        code39SpaceLeft: number;
        code39SpaceRight: number;
        code39SpaceTop: number;
        code39SpaceBottom: number;
        code39LineHeightShort: number;
        code39LineHeightLong: number;
        code39TextPosition: number;
        code39TextHeight: number;
        code39MainHeight: number;
        code39LineHeightForCut: number;
        codeToBar(inputCode: string): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, ratio?: number, checkSum?: StiCheckSum);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode39ExtBarCodeType extends StiCode39BarCodeType {
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        protected code39ExtTable: string[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, ratio?: number, checkSum?: StiCheckSum);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiCode93BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get serviceName(): string;
        private code93Symbols;
        code93Table: string[];
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _ratio;
        get ratio(): number;
        set ratio(value: number);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        code93SpaceLeft: number;
        code93SpaceRight: number;
        code93SpaceTop: number;
        code93SpaceBottom: number;
        code93LineHeightShort: number;
        code93LineHeightLong: number;
        code93TextPosition: number;
        code93TextHeight: number;
        code93MainHeight: number;
        code93LineHeightForCut: number;
        codeToBar(inputCode: string): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, ratio?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode93ExtBarCodeType extends StiCode93BarCodeType {
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        private code93ExtSymbols;
        private code93ExtTable;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, ratio?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDataMatrix {
        get matrix(): number[];
        get width(): number;
        get height(): number;
        get errorMessage(): string;
        private gridWidth;
        private gridHeight;
        private grid;
        private _errorMessage;
        private ecc200List;
        private _processTilde;
        private dataMatrixPlacementbit;
        private dataMatrixPlacementBlock;
        private dataMatrixPlacementCornerA;
        private dataMatrixPlacementCornerB;
        private dataMatrixPlacementCornerC;
        private dataMatrixPlacementCornerD;
        private dataMatrixPlacement;
        private makeEcc200Blocks;
        private dataMatrixEncode;
        private encodeB;
        private encodeA;
        private encodeE;
        private encodeCTX;
        private static isDigit;
        private static convertStringToBytes;
        private makeGrid;
        constructor(message: string, globalEncoding: StiDataMatrixEncodingType, useRectangularSymbols: boolean, matrixSize: StiDataMatrixSize, processTilde: boolean);
    }
    class StiDataMatrixBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _encodingType;
        get encodingType(): StiDataMatrixEncodingType;
        set encodingType(value: StiDataMatrixEncodingType);
        private _matrixSize;
        get matrixSize(): StiDataMatrixSize;
        set matrixSize(value: StiDataMatrixSize);
        private _useRectangularSymbols;
        get useRectangularSymbols(): boolean;
        set useRectangularSymbols(value: boolean);
        private _processTilde;
        get processTilde(): boolean;
        set processTilde(value: boolean);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, encodingType?: StiDataMatrixEncodingType, useRectangularSymbols?: boolean, matrixSize?: StiDataMatrixSize, processTilde?: boolean);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDutchKIXBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get serviceName(): string;
        dutchKIXSymbols: string;
        private dutchKIXCodes;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        dutchKIXSpaceLeft: number;
        dutchKIXSpaceRight: number;
        dutchKIXSpaceTop: number;
        dutchKIXSpaceBottom: number;
        dutchKIXLineHeightLong: number;
        dutchKIXLineHeightShort: number;
        dutchKIXTextPosition: number;
        dutchKIXTextHeight: number;
        dutchKIXMainHeight: number;
        dutchKIXLineHeightForCut: number;
        get textAlignment(): StringAlignment;
        private charTo4State;
        private stateToBar;
        private makeBarsArray;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEAN128AutoBarCodeType extends StiCode128BarCodeType {
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEAN128aBarCodeType extends StiCode128BarCodeType {
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEAN128bBarCodeType extends StiCode128BarCodeType {
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEAN128cBarCodeType extends StiCode128BarCodeType {
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class EanBarInfo {
        symbolType: Ean13Symbol;
        symbolText: string;
        textAtTop: boolean;
        makeLonger: boolean;
        constructor(symbolType: Ean13Symbol, symbolText: string, textAtTop: boolean, makeLonger?: boolean);
    }
    enum Ean13Symbol {
        ComboA0 = 0,
        ComboA1 = 1,
        ComboA2 = 2,
        ComboA3 = 3,
        ComboA4 = 4,
        ComboA5 = 5,
        ComboA6 = 6,
        ComboA7 = 7,
        ComboA8 = 8,
        ComboA9 = 9,
        ComboB0 = 10,
        ComboB1 = 11,
        ComboB2 = 12,
        ComboB3 = 13,
        ComboB4 = 14,
        ComboB5 = 15,
        ComboB6 = 16,
        ComboB7 = 17,
        ComboB8 = 18,
        ComboB9 = 19,
        ComboC0 = 20,
        ComboC1 = 21,
        ComboC2 = 22,
        ComboC3 = 23,
        ComboC4 = 24,
        ComboC5 = 25,
        ComboC6 = 26,
        ComboC7 = 27,
        ComboC8 = 28,
        ComboC9 = 29,
        GuardLeft = 30,
        GuardCenter = 31,
        GuardRight = 32,
        GuardSpecial = 33,
        GuardAddLeft = 34,
        GuardAddDelineator = 35,
        SpaceLeft = 36,
        SpaceRight = 37,
        SpaceBeforeAdd = 38
    }
    class StiEAN13BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        get visibleProperties(): boolean[];
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _supplementType;
        get supplementType(): StiEanSupplementType;
        set supplementType(value: StiEanSupplementType);
        private _supplementCode;
        get supplementCode(): string;
        set supplementCode(value: string);
        private _showQuietZoneIndicator;
        get showQuietZoneIndicator(): boolean;
        set showQuietZoneIndicator(value: boolean);
        get labelFontHeight(): number;
        protected get eanSpaceLeft(): number;
        protected get eanSpaceRight(): number;
        protected get eanSpaceTop(): number;
        protected get eanSpaceBottom(): number;
        protected get eanSpaceBeforeAdd(): number;
        protected get eanSpaceTextTop(): number;
        protected get eanLineHeightShort(): number;
        protected get eanLineHeightLong(): number;
        protected get eanTextPositionTop(): number;
        protected get eanTextPositionBottom(): number;
        protected get eanTextHeight(): number;
        protected get eanMainHeight(): number;
        protected get eanLineHeightForCut(): number;
        protected get eanWideToNarrowRatio(): number;
        protected symComboSet: string[];
        protected symParitySetAdd2: string[];
        protected symParitySetAdd5: string[];
        protected ean13SymData: string[];
        protected calculateSizeEan(offsetY: number, zoom: number, barsArray: EanBarInfo[], rect: RectangleD, barCode: StiBarCode): void;
        protected drawEanBars(context: any, barsArray: EanBarInfo[], barCode: StiBarCode): void;
        protected makeEan13Bars(REFcode: any, isLast: boolean): EanBarInfo[];
        protected makeEanAdd2Bars(code: string, baseArray: EanBarInfo[], isLast: boolean): EanBarInfo[];
        protected makeEanAdd5Bars(code: string, baseArray: EanBarInfo[], isLast: boolean): EanBarInfo[];
        protected makeLonger(symString: string): string;
        protected getSymbolWidth(symbol: string): number;
        protected isSymbolSpace(symbol: string): boolean;
        draw(context: number, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEAN8BarCodeType extends StiEAN13BarCodeType {
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        get eanSpaceLeft(): number;
        get eanSpaceRight(): number;
        get eanLineHeightShort(): number;
        get eanMainHeight(): number;
        makeEan8Bars(code: string, isLast: boolean): EanBarInfo[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiFIMBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get serviceName(): string;
        fIMSymbols: string;
        fIMTable: string[];
        defaultFIMModule: number;
        get defaultCodeValue(): string;
        get visibleProperties(): boolean[];
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _addClearZone;
        get addClearZone(): boolean;
        set addClearZone(value: boolean);
        get labelFontHeight(): number;
        get fIMSpaceLeft(): number;
        get fIMSpaceRight(): number;
        fIMSpaceTop: number;
        fIMSpaceBottom: number;
        fIMLineHeightShort: number;
        fIMLineHeightLong: number;
        fIMTextPosition: number;
        fIMTextHeight: number;
        fIMMainHeight: number;
        fIMLineHeightForCut: number;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, addClearZone?: boolean);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiGS1ApplicationIdentifierItem {
        AICode: string;
        AILength: number;
        NumericMin: number;
        NumericMax: number;
        CharacterMin: number;
        CharacterMax: number;
        NeedFNC1: boolean;
        DataTitle: string;
        DataContent: string;
        constructor(AICode: string, AILength: number, NumericMin: number, NumericMax: number, CharacterMin: number, CharacterMax: number, NeedFNC1: boolean, DataTitle: string, DataContent: string);
    }
    export class StiGS1_128BarCodeType extends StiCode128BarCodeType {
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        protected get textSpacing(): boolean;
        static GS1ApplicationIdentifiers: StiGS1ApplicationIdentifierItem[];
        private static AICodeToItem;
        static getApplicationIdentifierItemByCode(code: string): StiGS1ApplicationIdentifierItem;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
    export {};
}
declare namespace Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiITF14BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _ratio;
        get ratio(): number;
        set ratio(value: number);
        private _printVerticalBars;
        get printVerticalBars(): boolean;
        set printVerticalBars(value: boolean);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        protected symTableSet: string[];
        private itf14BearerBarWidth;
        private itf14SpaceLeft;
        private itf14SpaceRight;
        private itf14SpaceTop;
        private itf14SpaceBottom;
        private itf14LineHeightShort;
        private itf14LineHeightLong;
        private itf14TextHeight;
        private itf14MainHeight;
        private itf14TextPosition;
        private itf14LineHeightForCut;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, ratio?: number, printVerticalBars?: boolean);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiInterleaved2of5BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _ratio;
        get ratio(): number;
        set ratio(value: number);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        protected symTableSet: string[];
        private interleaved2of5SpaceLeft;
        private interleaved2of5SpaceRight;
        private interleaved2of5SpaceTop;
        private interleaved2of5SpaceBottom;
        private interleaved2of5LineHeightShort;
        private interleaved2of5LineHeightLong;
        private interleaved2of5TextHeight;
        private interleaved2of5MainHeight;
        private interleaved2of5TextPosition;
        private interleaved2of5LineHeightForCut;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        StiInterleaved2of5BarCodeType(module?: number, height?: number, ratio?: number): void;
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiIsbn13BarCodeType extends StiEAN13BarCodeType {
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        isbnOffsetY: number;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiIsbn10BarCodeType extends StiIsbn13BarCodeType {
        get componentId(): StiComponentId;
        get visibleProperties(): boolean[];
        get serviceName(): string;
        get defaultCodeValue(): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiJan13BarCodeType extends StiEAN13BarCodeType {
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiJan8BarCodeType extends StiEAN8BarCodeType {
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiMaxicodeMode = Stimulsoft.Report.BarCodes.StiMaxicodeMode;
    class StiMaxicodeBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        get module(): number;
        set module(value: number);
        get height(): number;
        set innerHeight(value: number);
        private _mode;
        get mode(): StiMaxicodeMode;
        set mode(value: StiMaxicodeMode);
        private _processTilde;
        get processTilde(): boolean;
        set processTilde(value: boolean);
        private _structuredAppendPosition;
        get structuredAppendPosition(): number;
        set structuredAppendPosition(value: number);
        private _structuredAppendTotal;
        get structuredAppendTotal(): number;
        set structuredAppendTotal(value: number);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(mode?: StiMaxicodeMode, structuredAppendPosition?: number, structuredAppendTotal?: number, processTilde?: boolean);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiPlesseyBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get serviceName(): string;
        plesseySymbols: string;
        private plesseyTable;
        private plesseyStartCode;
        private plesseyStopCode;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _checkSum1;
        get checkSum1(): StiPlesseyCheckSum;
        set checkSum1(value: StiPlesseyCheckSum);
        private _checkSum2;
        get checkSum2(): StiPlesseyCheckSum;
        set checkSum2(value: StiPlesseyCheckSum);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        plesseySpaceLeft: number;
        plesseySpaceRight: number;
        plesseySpaceTop: number;
        plesseySpaceBottom: number;
        plesseyLineHeightShort: number;
        plesseyLineHeightLong: number;
        plesseyTextPosition: number;
        plesseyTextHeight: number;
        plesseyMainHeight: number;
        plesseyLineHeightForCut: number;
        private codeToBar;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, checkSum1?: StiPlesseyCheckSum, checkSum2?: StiPlesseyCheckSum);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiMsiBarCodeType extends StiPlesseyBarCodeType {
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        get visibleProperties(): boolean[];
        private msiTable;
        private msiStartCode;
        private msiStopCode;
        protected codeToBarMsi(inputCode: string): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, checkSum1?: StiPlesseyCheckSum, checkSum2?: StiPlesseyCheckSum);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiPdf417BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _encodingMode;
        get encodingMode(): StiPdf417EncodingMode;
        set encodingMode(value: StiPdf417EncodingMode);
        private _errorsCorrectionLevel;
        get errorsCorrectionLevel(): StiPdf417ErrorsCorrectionLevel;
        set errorsCorrectionLevel(value: StiPdf417ErrorsCorrectionLevel);
        private _dataColumns;
        get dataColumns(): number;
        set dataColumns(value: number);
        private _dataRows;
        get dataRows(): number;
        set dataRows(value: number);
        private _autoDataColumns;
        get autoDataColumns(): boolean;
        set autoDataColumns(value: boolean);
        private _autoDataRows;
        get autoDataRows(): boolean;
        set autoDataRows(value: boolean);
        private _aspectRatio;
        get aspectRatio(): number;
        set aspectRatio(value: number);
        private _ratioY;
        get ratioY(): number;
        set ratioY(value: number);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, encodingMode?: StiPdf417EncodingMode, errorsCorrectionLevel?: StiPdf417ErrorsCorrectionLevel, dataColumns?: number, dataRows?: number, autoDataColumns?: boolean, autoDataRows?: boolean, aspectRatio?: number, ratioY?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiPharmacodeBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get serviceName(): string;
        pharmacodeSymbols: string;
        defaultPharmacodeModule: number;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        pharmacodeSpaceLeft: number;
        pharmacodeSpaceRight: number;
        pharmacodeSpaceTop: number;
        pharmacodeSpaceBottom: number;
        pharmacodeLineHeightShort: number;
        pharmacodeLineHeightLong: number;
        pharmacodeTextPosition: number;
        pharmacodeTextHeight: number;
        pharmacodeMainHeight: number;
        pharmacodeLineHeightForCut: number;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiPostnetBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get serviceName(): string;
        postnetSymbols: string;
        private postnetTable;
        private postnetStartCode;
        private postnetStopCode;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _space;
        get space(): number;
        set space(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        postnetSpaceLeft: number;
        postnetSpaceRight: number;
        postnetSpaceTop: number;
        postnetSpaceBottom: number;
        postnetLineHeightLong: number;
        postnetLineHeightShort: number;
        postnetTextPosition: number;
        postnetTextHeight: number;
        postnetMainHeight: number;
        postnetLineHeightForCut: number;
        private codeToBar;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, space?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Image = Stimulsoft.System.Drawing.Image;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiQRCodeBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _errorCorrectionLevel;
        get errorCorrectionLevel(): StiQRCodeErrorCorrectionLevel;
        set errorCorrectionLevel(value: StiQRCodeErrorCorrectionLevel);
        private _matrixSize;
        get matrixSize(): StiQRCodeSize;
        set matrixSize(value: StiQRCodeSize);
        private _image;
        get image(): Image;
        set image(value: Image);
        private _imageMultipleFactor;
        get imageMultipleFactor(): number;
        set imageMultipleFactor(value: number);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, errorCorrectionLevel?: StiQRCodeErrorCorrectionLevel, matrixSize?: StiQRCodeSize, image?: Image, imageMultipleFactor?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiRoyalMail4StateBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get serviceName(): string;
        royalMail4StateSymbols: string;
        private royalMail4StateStartCode;
        private royalMail4StateStopCode;
        private royalMail4StateCodes;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _checkSum;
        get checkSum(): StiCheckSum;
        set checkSum(value: StiCheckSum);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        royalMail4StateSpaceLeft: number;
        royalMail4StateSpaceRight: number;
        royalMail4StateSpaceTop: number;
        royalMail4StateSpaceBottom: number;
        royalMail4StateLineHeightLong: number;
        royalMail4StateLineHeightShort: number;
        royalMail4StateTextPosition: number;
        royalMail4StateTextHeight: number;
        royalMail4StateMainHeight: number;
        royalMail4StateLineHeightForCut: number;
        get textAlignment(): StringAlignment;
        private charTo4State;
        private stateToBar;
        private makeBarsArray;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, checkSum?: StiCheckSum);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiSSCC18BarCodeType extends StiCode128cBarCodeType implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        private _companyPrefix;
        get companyPrefix(): string;
        set companyPrefix(value: string);
        private _serialNumber;
        get serialNumber(): string;
        set serialNumber(value: string);
        private _extensionDigit;
        get extensionDigit(): string;
        set extensionDigit(value: string);
        get textSpacing(): boolean;
        get visibleProperties(): boolean[];
        getCombinedCode(): string;
        private getCheckDigit;
        private checkContens;
        draw(context: any, barCode: StiBarCode, rect: Rectangle, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStandard2of5BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        private _module;
        get module(): number;
        set module(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _ratio;
        get ratio(): number;
        set ratio(value: number);
        get labelFontHeight(): number;
        get visibleProperties(): boolean[];
        protected symTableSet: string[];
        private standard2of5SpaceLeft;
        private standard2of5SpaceRight;
        private standard2of5SpaceTop;
        private standard2of5SpaceBottom;
        private standard2of5LineHeightShort;
        private standard2of5LineHeightLong;
        private standard2of5TextHeight;
        private standard2of5MainHeight;
        private standard2of5TextPosition;
        private standard2of5LineHeightForCut;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, ratio?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiUpcABarCodeType extends StiEAN13BarCodeType {
        get componentId(): StiComponentId;
        get serviceName(): string;
        get eanSpaceLeft(): number;
        get eanSpaceRight(): number;
        get defaultCodeValue(): string;
        get visibleProperties(): boolean[];
        get showQuietZoneIndicator(): boolean;
        set showQuietZoneIndicator(value: boolean);
        makeUpcABars(code: string, isLast: boolean): EanBarInfo[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    class StiUpcEBarCodeType extends StiEAN13BarCodeType {
        get componentId(): StiComponentId;
        get serviceName(): string;
        protected symParitySet: string[];
        protected get eanSpaceLeft(): number;
        protected get eanSpaceRight(): number;
        get defaultCodeValue(): string;
        get visibleProperties(): boolean[];
        get showQuietZoneIndicator(): boolean;
        set showQuietZoneIndicator(value: boolean);
        protected makeUpcEBars(code: string, isLast: boolean): EanBarInfo[];
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiUpcSup2BarCodeType extends StiEAN13BarCodeType {
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiUpcSup5BarCodeType extends StiEAN13BarCodeType {
        get componentId(): StiComponentId;
        get serviceName(): string;
        get defaultCodeValue(): string;
        get visibleProperties(): boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    class ArrayHelper {
        static copy(sourceArray: any[], sourceIndex: number, destinationArray: any[], destinationIndex: number, length: number): void;
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    class BitVector {
        private sizeInBits;
        private array;
        constructor();
        at(index: number): number;
        size(): number;
        sizeInBytes(): number;
        appendBit(bit: number): void;
        appendBits(value: number, numBits: number): void;
        appendBitVector(bits: BitVector): void;
        xor(other: BitVector): void;
        toString(): string;
        getArray(): number[];
        private appendByte;
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    class BlockPair {
        private dataBytes;
        private errorCorrectionBytes;
        constructor(data: ByteArray, errorCorrection: ByteArray);
        getDataBytes(): ByteArray;
        getErrorCorrectionBytes(): ByteArray;
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    class ByteArray {
        private static INITIAL_SIZE;
        private _bytes;
        private _size;
        constructor(size?: number, byteArray?: number[]);
        at(index: number): number;
        set(index: number, value: number): void;
        size(): number;
        isEmpty(): boolean;
        appendByte(value: number): void;
        reserve(capacity: number): void;
        set1(source: number[], offset: number, count: number): void;
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    class ByteMatrix {
        private _bytes;
        private _width;
        private _height;
        getValueString(): string;
        constructor(width: number, height: number);
        getHeight(): number;
        getWidth(): number;
        get(x: number, y: number): Stimulsoft.System.SByte;
        getArray(): Stimulsoft.System.SByte[][];
        set(x: number, y: number, value: Stimulsoft.System.SByte): void;
        set2(x: number, y: number, value: number): void;
        clear(value: Stimulsoft.System.SByte): void;
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class CharacterSetECI {
        private static lockNAME_TO_ECI;
        private static _name_to_eci;
        static get NAME_TO_ECI(): Hashtable;
        static set NAME_TO_ECI(value: Hashtable);
        private static Initialize;
        private _encodingName;
        private _value;
        constructor(value: number, encodingName: string);
        getEncodingName(): string;
        getValue(): number;
        private static addCharacterSet;
        static getCharacterSetECIByName(name: string): CharacterSetECI;
        static GetEncodingByNumber(number: number, defaultEncoding: string): string;
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    class ErrorCorrectionLevel {
        static L: ErrorCorrectionLevel;
        static M: ErrorCorrectionLevel;
        static Q: ErrorCorrectionLevel;
        static H: ErrorCorrectionLevel;
        private _ordinal;
        private _bits;
        private _name;
        constructor(ordinal: number, bits: number, name: string);
        ordinal(): number;
        getBits(): number;
        getName(): string;
        toString(): string;
        static forBits(bits: number): ErrorCorrectionLevel;
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    class FormatInformation {
        private FORMAT_INFO_MASK_QR;
        private static FORMAT_INFO_DECODE_LOOKUP;
        private static BITS_SET_IN_HALF_BYTE;
        private errorCorrectionLevel;
        private dataMask;
        constructor(formatInfo: number);
        static numBitsDiffering(a: number, b: number): number;
        static decodeFormatInformation(maskedFormatInfo1: number, maskedFormatInfo2: number): FormatInformation;
        private static doDecodeFormatInformation;
        getErrorCorrectionLevel(): ErrorCorrectionLevel;
        getDataMask(): number;
        equals(o: any): boolean;
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    class GF256 {
        static QR_CODE_FIELD: GF256;
        static DATA_MATRIX_FIELD: GF256;
        private _expTable;
        private _logTable;
        private _zero;
        private _one;
        constructor(primitive: number);
        getZero(): GF256Poly;
        getOne(): GF256Poly;
        buildMonomial(degree: number, coefficient: number): GF256Poly;
        static addOrSubtract(a: number, b: number): number;
        exp(a: number): number;
        log(a: number): number;
        inverse(a: number): number;
        multiply(a: number, b: number): number;
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    class GF256Poly {
        _field: GF256;
        _coefficients: number[];
        constructor(field: GF256, coefficients: number[]);
        getCoefficients(): number[];
        getDegree(): number;
        isZero(): boolean;
        getCoefficient(degree: number): number;
        evaluateAt(a: number): number;
        addOrSubtract(other: GF256Poly): GF256Poly;
        multiply(other: GF256Poly): GF256Poly;
        multiply1(scalar: number): GF256Poly;
        multiplyByMonomial(degree: number, coefficient: number): GF256Poly;
        divide(other: GF256Poly): GF256Poly[];
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    class MaskUtil {
        static applyMaskPenaltyRule1(matrix: ByteMatrix): number;
        static applyMaskPenaltyRule2(matrix: ByteMatrix): number;
        static applyMaskPenaltyRule3(matrix: ByteMatrix): number;
        static applyMaskPenaltyRule4(matrix: ByteMatrix): number;
        static getDataMaskBit(maskPattern: number, x: number, y: number): boolean;
        private static ApplyMaskPenaltyRule1Internal;
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    class MatrixUtil {
        private static POSITION_DETECTION_PATTERN;
        private static HORIZONTAL_SEPARATION_PATTERN;
        private static VERTICAL_SEPARATION_PATTERN;
        private static POSITION_ADJUSTMENT_PATTERN;
        private static POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE;
        private static TYPE_INFO_COORDINATES;
        private static VERSION_INFO_POLY;
        private static TYPE_INFO_POLY;
        private static TYPE_INFO_MASK_PATTERN;
        static ClearMatrix(matrix: ByteMatrix): void;
        static BuildMatrix(dataBits: BitVector, ecLevel: ErrorCorrectionLevel, version: number, maskPattern: number, matrix: ByteMatrix): void;
        static EmbedBasicPatterns(version: number, matrix: ByteMatrix): void;
        static EmbedTypeInfo(ecLevel: ErrorCorrectionLevel, maskPattern: number, matrix: ByteMatrix): void;
        static MaybeEmbedVersionInfo(version: number, matrix: ByteMatrix): void;
        static EmbedDataBits(dataBits: BitVector, maskPattern: number, matrix: ByteMatrix): void;
        static FindMSBSet(value: number): number;
        static CalculateBCHCode(value: number, poly: number): number;
        static MakeTypeInfoBits(ecLevel: ErrorCorrectionLevel, maskPattern: number, bits: BitVector): void;
        static MakeVersionInfoBits(version: number, bits: BitVector): void;
        private static IsEmpty;
        private static IsValidValue;
        private static EmbedTimingPatterns;
        private static EmbedDarkDotAtLeftBottomCorner;
        private static EmbedHorizontalSeparationPattern;
        private static EmbedVerticalSeparationPattern;
        private static EmbedPositionAdjustmentPattern;
        private static EmbedPositionDetectionPattern;
        private static EmbedPositionDetectionPatternsAndSeparators;
        private static MaybeEmbedPositionAdjustmentPatterns;
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    class Mode {
        static TERMINATOR: Mode;
        static NUMERIC: Mode;
        static ALPHANUMERIC: Mode;
        static STRUCTURED_APPEND: Mode;
        static BYTE: Mode;
        static ECI: Mode;
        static KANJI: Mode;
        static FNC1_FIRST_POSITION: Mode;
        static FNC1_SECOND_POSITION: Mode;
        private characterCountBitsForVersions;
        private bits;
        private name;
        constructor(characterCountBitsForVersions: number[], bits: number, name: string);
        static ForBits(bits: number): Mode;
        GetCharacterCountBits(version: Version): number;
        GetBits(): number;
        GetName(): string;
        ToString(): string;
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    class QREncoder {
        private static ALPHANUMERIC_TABLE;
        private static defaultECIByteModeEncoding;
        private static BYTE_MODE_UTF8;
        private static QUESTION_MARK_CHAR;
        private static CalculateMaskPenalty;
        static Encode(content: string, ecLevel: ErrorCorrectionLevel, qrCode: StiQRCode): void;
        private static GetEncodingName;
        private static GetAlphanumericCode;
        static ChooseMode(content: string): Mode;
        static ChooseMode1(content: string, encoding: string): Mode;
        private static ChooseMaskPattern;
        private static InitQRCode;
        private static TerminateBits;
        private static GetNumDataBytesAndNumECBytesForBlockID;
        private static InterleaveWithECBytes;
        private static GenerateECBytes;
        private static AppendModeInfo;
        private static AppendLengthInfo;
        private static AppendBytes;
        private static AppendNumericBytes;
        private static AppendAlphanumericBytes;
        private static Append8BitBytes;
        private static AppendKanjiBytes;
        private static AppendECI;
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    class ReedSolomonEncoder {
        private field;
        private cachedGenerators;
        constructor(field: GF256);
        private BuildGenerator;
        Encode(toEncode: number[], ecBytes: number): void;
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    class StiQRCode {
        static NUM_MASK_PATTERNS: number;
        private _mode;
        private _ecLevel;
        private _version;
        private _matrixWidth;
        private _maskPattern;
        private _numTotalBytes;
        private _numDataBytes;
        private _numECBytes;
        private _numRSBlocks;
        private _matrix;
        GetMode(): Mode;
        GetECLevel(): ErrorCorrectionLevel;
        GetVersion(): number;
        GetMatrixWidth(): number;
        GetMaskPattern(): number;
        GetNumTotalBytes(): number;
        GetNumDataBytes(): number;
        GetNumECBytes(): number;
        GetNumRSBlocks(): number;
        GetMatrix(): ByteMatrix;
        At(x: number, y: number): number;
        IsValid(): boolean;
        SetMode(value: Mode): void;
        SetECLevel(value: ErrorCorrectionLevel): void;
        SetVersion(value: number): void;
        SetMatrixWidth(value: number): void;
        SetMaskPattern(value: number): void;
        SetNumTotalBytes(value: number): void;
        SetNumDataBytes(value: number): void;
        SetNumECBytes(value: number): void;
        SetNumRSBlocks(value: number): void;
        SetMatrix(value: ByteMatrix): void;
        static IsValidMaskPattern(maskPattern: number): boolean;
        constructor();
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    class ECB {
        private _count;
        private _dataCodewords;
        constructor(count: number, dataCodewords: number);
        getCount(): number;
        getDataCodewords(): number;
    }
    class ECBlocks {
        private ecCodewordsPerBlock;
        private ecBlocks;
        constructor(ecCodewordsPerBlock: number, ecBlocks1: ECB, ecBlocks2?: ECB);
        getECCodewordsPerBlock(): number;
        getNumBlocks(): number;
        getTotalECCodewords(): number;
        getECBlocks(): ECB[];
    }
    class Version {
        private static VERSION_DECODE_INFO;
        private static BuildVersions;
        private static VERSIONS;
        private _versionNumber;
        private _alignmentPatternCenters;
        private _ecBlocks;
        private _totalCodewords;
        constructor(versionNumber: number, alignmentPatternCenters: number[], ecBlocks1: ECBlocks, ecBlocks2: ECBlocks, ecBlocks3: ECBlocks, ecBlocks4: ECBlocks);
        getVersionNumber(): number;
        getAlignmentPatternCenters(): number[];
        getTotalCodewords(): number;
        getDimensionForVersion(): number;
        getECBlocksForLevel(ecLevel: ErrorCorrectionLevel): ECBlocks;
        static getProvisionalVersionForDimension(dimension: number): Version;
        static getVersionForNumber(versionNumber: number): Version;
        static decodeVersionInformation(versionBits: number): Version;
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiTrendLinePropertyOrder {
        lineColor: number;
        lineStyle: number;
        lineWidth: number;
        showShadow: number;
    }
    class StiSeriesLabelsPropertyOrder {
        allowApplyStyle: number;
        angle: number;
        antialiasing: number;
        autoRotate: number;
        conditions: number;
        drawBorder: number;
        borderColor: number;
        brush: number;
        font: number;
        format: number;
        labelColor: number;
        legendValueType: number;
        lineColor: number;
        lineColorNegative: number;
        lineLength: number;
        markerAlignment: number;
        markerSize: number;
        markerVisible: number;
        preventIntersection: number;
        showInPercent: number;
        showNulls: number;
        showValue: number;
        showZeros: number;
        step: number;
        textAfter: number;
        textBefore: number;
        useSeriesColor: number;
        valueType: number;
        valueTypeSeparator: number;
        visible: number;
        width: number;
        wordWrap: number;
    }
    class StiSeriesPropertyOrder {
        allowSeries: number;
        allowSeriesElements: number;
        drillDownEnabled: number;
        drillDownPage: number;
        drillDownReport: number;
        hyperlinkDataColumn: number;
        tagDataColumn: number;
        toolTipDataColumn: number;
        weightDataColumn: number;
        hyperlink: number;
        tag: number;
        toolTip: number;
        weight: number;
        listOfHyperlinks: number;
        listOfTags: number;
        listOfToolTips: number;
        listOfWeights: number;
        valueValueDataColumn: number;
        valueValue: number;
        valueListOfValues: number;
        valueValueDataColumnEnd: number;
        valueValueEnd: number;
        valueListOfValuesEnd: number;
        valueValueDataColumnOpen: number;
        valueValueOpen: number;
        valueListOfValuesOpen: number;
        valueValueDataColumnClose: number;
        valueValueClose: number;
        valueListOfValuesClose: number;
        valueValueDataColumnHigh: number;
        valueValueHigh: number;
        valueListOfValuesHigh: number;
        valueValueDataColumnLow: number;
        valueValueLow: number;
        valueListOfValuesLow: number;
        argumentArgumentDataColumn: number;
        argumentArgument: number;
        argumentListOfArguments: number;
        weightWeightDataColumn: number;
        weightWeight: number;
        weightListOfWeights: number;
        appearanceAllowApplyBorderColor: number;
        appearanceAllowApplyBrush: number;
        appearanceAllowApplyBrushNegative: number;
        appearanceAllowApplyColorNegative: number;
        appearanceDiameter: number;
        appearanceBorderColor: number;
        appearanceBrush: number;
        appearanceBrushNegative: number;
        appearanceLighting: number;
        appearanceShowShadow: number;
        appearanceTopmostLine: number;
        appearanceFunnelSliceMode: number;
        dataConditions: number;
        dataFilters: number;
        dataFilterMode: number;
        dataTopN: number;
        dataFormat: number;
        dataSortBy: number;
        dataSortDirection: number;
        dataAutoSeriesKeyDataColumn: number;
        dataAutoSeriesColorDataColumn: number;
        dataAutoSeriesTitleDataColumn: number;
    }
    enum StiChartTitleDock {
        Top = 0,
        Right = 90,
        Bottom = 180,
        Left = 270
    }
    enum StiLegendDirection {
        LeftToRight = 0,
        RightToLeft = 1,
        TopToBottom = 2,
        BottomToTop = 3
    }
    enum StiDirection {
        LeftToRight = 0,
        RightToLeft = 1,
        TopToBottom = 2,
        BottomToTop = 3
    }
    enum StiLegendHorAlignment {
        LeftOutside = 0,
        Left = 1,
        Center = 2,
        Right = 3,
        RightOutside = 4
    }
    enum StiLegendVertAlignment {
        TopOutside = 0,
        Top = 1,
        Center = 2,
        Bottom = 3,
        BottomOutside = 4
    }
    enum StiMarkerAlignment {
        Left = 0,
        Center = 1,
        Right = 2
    }
    enum StiChartAreaPosition {
        ClusteredColumn = 0,
        StackedColumn = 1,
        FullStackedColumn = 2,
        Pareto = 3,
        Waterfall = 4,
        Histogram = 5,
        ClusteredBar = 10,
        StackedBar = 11,
        FullStackedBar = 12,
        Pie = 20,
        Doughnut = 21,
        Line = 30,
        SteppedLine = 31,
        StackedLine = 32,
        FullStackedLine = 33,
        Spline = 40,
        StackedSpline = 41,
        FullStackedSpline = 42,
        Area = 50,
        SteppedArea = 51,
        StackedArea = 52,
        FullStackedArea = 53,
        SplineArea = 60,
        StackedSplineArea = 61,
        FullStackedSplineArea = 62,
        Gantt = 70,
        Scatter = 80,
        Bubble = 81,
        RadarPoint = 82,
        RadarLine = 83,
        RadarArea = 84,
        Range = 90,
        SteppedRange = 91,
        RangeBar = 92,
        SplineRange = 93,
        Funnel = 100,
        Candlestick = 110,
        Stock = 120,
        BoxAndWhisker = 121,
        Treemap = 130,
        Pictorial = 131,
        Sunburst = 140
    }
    enum StiChartSeriesOrientation {
        Horizontal = 0,
        Vertical = 1
    }
    enum StiArrowStyle {
        None = 0,
        Triangle = 1,
        Lines = 2,
        Circle = 3,
        Arc = 4,
        ArcAndCircle = 5
    }
    enum StiLabelsPlacement {
        None = 0,
        OneLine = 1,
        TwoLines = 2,
        AutoRotation = 3
    }
    enum StiXAxisDock {
        Top = 0,
        Bottom = 1
    }
    enum StiYAxisDock {
        Left = 0,
        Right = 1
    }
    enum StiTitlePosition {
        Inside = 0,
        Outside = 1
    }
    enum StiSeriesLabelsPosition {
        None = 0,
        InsideEndAxis = 1,
        InsideBaseAxis = 2,
        CenterAxis = 3,
        OutsideEndAxis = 4,
        OutsideBaseAxis = 5,
        OutsideAxis = 6,
        Left = 7,
        Value = 8,
        Right = 9,
        InsideEndPie = 10,
        CenterPie = 11,
        OutsidePie = 12,
        TwoColumnsPie = 13,
        CenterFunnel = 14,
        OutsideRightFunnel = 15,
        OutsideLeftFunnel = 16,
        CenterTreemap = 17
    }
    enum StiSeriesLabelsType {
        Axis = 1,
        Pie = 2,
        Doughnut = 4,
        Radar = 8,
        Funnel = 10,
        Treemap = 12,
        All = 15
    }
    enum StiSeriesLabelsValueType {
        Value = 0,
        SeriesTitle = 1,
        Argument = 2,
        Tag = 3,
        Weight = 4,
        ValueArgument = 5,
        ArgumentValue = 6,
        SeriesTitleValue = 7,
        SeriesTitleArgument = 8
    }
    enum StiMarkerType {
        Rectangle = 0,
        Triangle = 1,
        Circle = 2,
        HalfCircle = 3,
        Star5 = 4,
        Star6 = 5,
        Star7 = 6,
        Star8 = 7,
        Hexagon = 8
    }
    enum StiSeriesSortType {
        Value = 0,
        Argument = 1,
        None = 2
    }
    enum StiSeriesSortDirection {
        Ascending = 0,
        Descending = 1
    }
    enum StiSeriesXAxis {
        BottomXAxis = 0,
        TopXAxis = 1
    }
    enum StiSeriesYAxis {
        LeftYAxis = 0,
        RightYAxis = 1
    }
    enum StiShowSeriesLabels {
        None = 0,
        FromChart = 1,
        FromSeries = 2
    }
    enum StiShowYAxis {
        Left = 0,
        Center = 1,
        Both = 2
    }
    enum StiShowXAxis {
        Bottom = 0,
        Center = 1,
        Both = 2
    }
    enum StiRadarStyle {
        Polygon = 0,
        Circle = 1
    }
    enum StiTimeDateStep {
        None = 0,
        Second = 1,
        Minute = 2,
        Hour = 3,
        Day = 4,
        Month = 5,
        Year = 6
    }
    enum StiTopNMode {
        None = 0,
        Top = 1,
        Bottom = 2
    }
    enum StiChartStyleId {
        StiStyle01 = 0,
        StiStyle02 = 1,
        StiStyle03 = 2,
        StiStyle04 = 3,
        StiStyle05 = 4,
        StiStyle06 = 5,
        StiStyle07 = 6,
        StiStyle08 = 7,
        StiStyle09 = 8,
        StiStyle10 = 9,
        StiStyle11 = 10,
        StiStyle12 = 11,
        StiStyle13 = 12,
        StiStyle14 = 13,
        StiStyle15 = 14,
        StiStyle16 = 15,
        StiStyle17 = 16,
        StiStyle18 = 17,
        StiStyle19 = 18,
        StiStyle20 = 19,
        StiStyle21 = 20,
        StiStyle22 = 21,
        StiStyle23 = 22,
        StiStyle24 = 23,
        StiStyle25 = 24,
        StiStyle26 = 25,
        StiStyle27 = 26,
        StiStyle28 = 27,
        StiStyle29 = 28,
        StiStyle30 = 29,
        StiStyle31 = 30,
        StiStyle32 = 31,
        StiStyle33 = 32,
        StiStyle34 = 33
    }
    enum StiStrips_StiOrientation {
        Horizontal = 0,
        Vertical = 1,
        HorizontalRight = 2
    }
    enum StiConstantLines_StiOrientation {
        Horizontal = 0,
        Vertical = 1,
        HorizontalRight = 2
    }
    enum StiConstantLines_StiTextPosition {
        LeftTop = 0,
        LeftBottom = 1,
        CenterTop = 2,
        CenterBottom = 3,
        RightTop = 4,
        RightBottom = 5
    }
    enum StiTrendLine_StiTextPosition {
        LeftTop = 0,
        LeftBottom = 1,
        RightTop = 2,
        RightBottom = 3
    }
    enum StiExtendedStyleBool {
        FromStyle = 0,
        True = 1,
        False = 2
    }
    enum StiChartConditionalField {
        Value = 0,
        Argument = 1,
        Series = 2
    }
    enum StiShowEmptyCellsAs {
        Gap = 0,
        ConnectPointsWithLine = 1
    }
    enum StiChartEditorType {
        Simple = 0,
        Advanced = 1
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiChartAssembly {
        static get isAssemblyLoaded(): boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiApplyStyle: System.Interface<IStiApplyStyle>;
    interface IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiApplyStyleSeries: System.Interface<IStiApplyStyleSeries>;
    interface IStiApplyStyleSeries {
        applyStyle(style: IStiChartStyle, color: Color): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    let IStiCellGeom: System.Interface<IStiCellGeom>;
    interface IStiCellGeom {
        drawGeom(context: StiContext): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    let IStiChartCoreXF: System.Interface<IStiChartCoreXF>;
    interface IStiChartCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
        render(context: StiContext, rect: RectangleD, useMargins: boolean): IStiCellGeom;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiText = Stimulsoft.Report.Components.StiText;
    let IStiChartInfo: System.Interface<IStiChartInfo>;
    interface IStiChartInfo {
        interactiveComps: StiText[];
        storedForProcessAtEndChart: IStiChart;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiGeomInteraction: System.Interface<IStiGeomInteraction>;
    interface IStiGeomInteraction {
        invokeClick(options: any): any;
        invokeMouseEnter(options: any): any;
        invokeMouseLeave(options: any): any;
        invokeMouseDown(options: any): any;
        invokeMouseUp(options: any): any;
        invokeDrag(options: any): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiSeriesElement: System.Interface<IStiSeriesElement>;
    interface IStiSeriesElement {
        elementIndex: string;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    let IStiSeriesInteraction: System.Interface<IStiSeriesInteraction>;
    interface IStiSeriesInteraction extends ICloneable, IStiJsonReportObject {
        drillDownEnabled: boolean;
        allowSeries: boolean;
        allowSeriesElements: boolean;
        loadFromXml(xmlNode: XmlNode): any;
        drillDownPageGuid: string;
        drillDownPage: StiPage;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiArea: System.Interface<IStiArea>;
    interface IStiArea extends ICloneable, IStiJsonReportObject, IAsIs {
        core: IStiAreaCoreXF;
        chart: IStiChart;
        allowApplyStyle: boolean;
        colorEach: boolean;
        showShadow: boolean;
        borderColor: Color;
        brush: StiBrush;
        isDefaultSeriesTypeFullStackedColumnSeries: boolean;
        isDefaultSeriesTypeFullStackedBarSeries: boolean;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    let IStiAreaCoreXF: System.Interface<IStiAreaCoreXF>;
    interface IStiAreaCoreXF extends IStiApplyStyle, IAsIs {
        isAcceptableSeries(seriesType: Stimulsoft.System.Type): boolean;
        isAcceptableSeriesLabels(seriesLabelsType: Stimulsoft.System.Type): boolean;
        render(context: StiContext, rect: RectangleD): IStiCellGeom;
        checkInLabelsTypes(typeForCheck: Stimulsoft.System.Type): boolean;
        seriesOrientation: StiChartSeriesOrientation;
        getSeries(): IStiSeries[];
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiAxisArea: System.Interface<IStiAxisArea>;
    interface IStiAxisArea extends IStiArea {
        axisCore: IStiAxisAreaCoreXF;
        interlacingHor: IStiInterlacingHor;
        interlacingVert: IStiInterlacingVert;
        gridLinesHor: IStiGridLinesHor;
        gridLinesHorRight: IStiGridLinesHor;
        gridLinesVert: IStiGridLinesVert;
        yAxis: IStiYAxis;
        yRightAxis: IStiYAxis;
        xAxis: IStiXAxis;
        xTopAxis: IStiXAxis;
        reverseHor: boolean;
        reverseVert: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiAxisAreaCoreXF: System.Interface<IStiAxisAreaCoreXF>;
    interface IStiAxisAreaCoreXF extends IStiAreaCoreXF {
        switchOff(): any;
        getDividerX(): number;
        getDividerTopX(): number;
        getDividerY(): number;
        getDividerRightY(): number;
        valuesCount: number;
        scrollRangeX: number;
        scrollRangeY: number;
        scrollDpiX: number;
        scrollDpiY: number;
        getArgumentLabel(line: IStiStripLineXF, series: IStiSeries): string;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiRoundValuesArea: System.Interface<IStiRoundValuesArea>;
    interface IStiRoundValuesArea {
        roundValues: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiBoxAndWhiskerArea: System.Interface<IStiBoxAndWhiskerArea>;
    interface IStiBoxAndWhiskerArea extends IStiAxisArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiBubbleArea: System.Interface<IStiBubbleArea>;
    interface IStiBubbleArea extends IStiScatterArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiCandlestickArea: System.Interface<IStiCandlestickArea>;
    interface IStiCandlestickArea extends IStiClusteredColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiClusteredBarArea: System.Interface<IStiClusteredBarArea>;
    interface IStiClusteredBarArea extends IStiClusteredColumnArea, IStiRoundValuesArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiAreaArea: System.Interface<IStiAreaArea>;
    interface IStiAreaArea extends IStiClusteredColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiClusteredColumnArea: System.Interface<IStiClusteredColumnArea>;
    interface IStiClusteredColumnArea extends IStiAxisArea, IStiRoundValuesArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiLineArea: System.Interface<IStiLineArea>;
    interface IStiLineArea extends IStiClusteredColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiParetoArea: System.Interface<IStiParetoArea>;
    interface IStiParetoArea extends IStiClusteredColumnArea, IStiRoundValuesArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiSplineArea: System.Interface<IStiSplineArea>;
    interface IStiSplineArea extends IStiClusteredColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiSplineAreaArea: System.Interface<IStiSplineAreaArea>;
    interface IStiSplineAreaArea extends IStiClusteredColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiSteppedAreaArea: System.Interface<IStiSteppedAreaArea>;
    interface IStiSteppedAreaArea extends IStiClusteredColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiSteppedLineArea: System.Interface<IStiSteppedLineArea>;
    interface IStiSteppedLineArea extends IStiClusteredColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiWaterfallArea: System.Interface<IStiWaterfallArea>;
    interface IStiWaterfallArea extends IStiAxisArea, IStiRoundValuesArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiDoughnutArea: System.Interface<IStiDoughnutArea>;
    interface IStiDoughnutArea extends IStiPieArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiFullStackedBarArea: System.Interface<IStiFullStackedBarArea>;
    interface IStiFullStackedBarArea extends IStiStackedBarArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiFullStackedAreaArea: System.Interface<IStiFullStackedAreaArea>;
    interface IStiFullStackedAreaArea extends IStiFullStackedColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiFullStackedColumnArea: System.Interface<IStiFullStackedColumnArea>;
    interface IStiFullStackedColumnArea extends IStiStackedColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiFullStackedLineArea: System.Interface<IStiFullStackedLineArea>;
    interface IStiFullStackedLineArea extends IStiFullStackedColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiFullStackedSplineArea: System.Interface<IStiFullStackedSplineArea>;
    interface IStiFullStackedSplineArea extends IStiFullStackedColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiFullStackedSplineAreaArea: System.Interface<IStiFullStackedSplineAreaArea>;
    interface IStiFullStackedSplineAreaArea extends IStiFullStackedColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiFunnelArea: System.Interface<IStiFunnelArea>;
    interface IStiFunnelArea extends IStiArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiGanttArea: System.Interface<IStiGanttArea>;
    interface IStiGanttArea extends IStiClusteredBarArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiPictorialArea: System.Interface<IStiPictorialArea>;
    interface IStiPictorialArea extends IStiArea, IStiRoundValuesArea {
        actual: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiPieArea: System.Interface<IStiPieArea>;
    interface IStiPieArea extends IStiArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiRadarArea: System.Interface<IStiRadarArea>;
    interface IStiRadarArea extends IStiArea {
        radarStyle: StiRadarStyle;
        xAxis: IStiXRadarAxis;
        yAxis: IStiYRadarAxis;
        interlacingHor: IStiInterlacingHor;
        interlacingVert: IStiInterlacingVert;
        gridLinesHor: IStiRadarGridLinesHor;
        gridLinesVert: IStiRadarGridLinesVert;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiRadarAreaArea: System.Interface<IStiRadarAreaArea>;
    interface IStiRadarAreaArea extends IStiRadarArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiRadarLineArea: System.Interface<IStiRadarLineArea>;
    interface IStiRadarLineArea extends IStiRadarArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiRadarPointArea: System.Interface<IStiRadarPointArea>;
    interface IStiRadarPointArea extends IStiRadarArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiRangeArea: System.Interface<IStiRangeArea>;
    interface IStiRangeArea extends IStiClusteredColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiRangeBarArea: System.Interface<IStiRangeBarArea>;
    interface IStiRangeBarArea extends IStiClusteredColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiSplineRangeArea: System.Interface<IStiSplineRangeArea>;
    interface IStiSplineRangeArea extends IStiClusteredColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiSteppedRangeArea: System.Interface<IStiSteppedRangeArea>;
    interface IStiSteppedRangeArea extends IStiClusteredColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiScatterArea: System.Interface<IStiScatterArea>;
    interface IStiScatterArea extends IStiClusteredColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiStackedBarArea: System.Interface<IStiStackedBarArea>;
    interface IStiStackedBarArea extends IStiClusteredBarArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiStackedAreaArea: System.Interface<IStiStackedAreaArea>;
    interface IStiStackedAreaArea extends IStiStackedColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiStackedColumnArea: System.Interface<IStiStackedColumnArea>;
    interface IStiStackedColumnArea extends IStiAxisArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiStackedLineArea: System.Interface<IStiStackedLineArea>;
    interface IStiStackedLineArea extends IStiStackedColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiStackedSplineArea: System.Interface<IStiStackedSplineArea>;
    interface IStiStackedSplineArea extends IStiStackedColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiStackedSplineAreaArea: System.Interface<IStiStackedSplineAreaArea>;
    interface IStiStackedSplineAreaArea extends IStiStackedColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiStockArea: System.Interface<IStiStockArea>;
    interface IStiStockArea extends IStiClusteredColumnArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiSunburstArea: System.Interface<IStiSunburstArea>;
    interface IStiSunburstArea extends IStiArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiTreemapArea: System.Interface<IStiTreemapArea>;
    interface IStiTreemapArea extends IStiArea {
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IAsIs = Stimulsoft.System.IAsIs;
    let IStiAxis: System.Interface<IStiAxis>;
    interface IStiAxis extends ICloneable, IStiJsonReportObject, IAsIs {
        logarithmicScale: boolean;
        core: IStiAxisCoreXF;
        allowApplyStyle: boolean;
        startFromZero: boolean;
        step: number;
        interaction: IStiAxisInteraction;
        labels: IStiAxisLabels;
        range: IStiAxisRange;
        title: IStiAxisTitle;
        ticks: IStiAxisTicks;
        arrowStyle: StiArrowStyle;
        lineStyle: StiPenStyle;
        lineColor: Color;
        lineWidth: number;
        visible: boolean;
        area: IStiAxisArea;
        info: IStiAxisInfoXF;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    let IStiAxisCoreXF: System.Interface<IStiAxisCoreXF>;
    interface IStiAxisCoreXF extends IStiApplyStyle {
        arrowHeight: number;
        arrowWidth: number;
        ticksMaxLength: number;
        renderView(context: StiContext, rect: RectangleD): IStiCellGeom;
        render(context: StiContext, rect: RectangleD): IStiCellGeom;
        applyStyle(style: IStiChartStyle): any;
        getStartFromZero(): boolean;
        calculateStripPositions(topPosition: number, bottomPosition: number): any;
        getFontGeom(context: StiContext): StiFontGeom;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        isMouseOverDecreaseButton: boolean;
        isMouseOverIncreaseButton: boolean;
        isMouseOverTrackBar: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiAxisDateTimeStep: System.Interface<IStiAxisDateTimeStep>;
    interface IStiAxisDateTimeStep extends ICloneable, IStiJsonReportObject {
        step: StiTimeDateStep;
        numberOfValues: number;
        interpolation: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    let IStiAxisInfoXF: System.Interface<IStiAxisInfoXF>;
    interface IStiAxisInfoXF extends ICloneable {
        minimum: number;
        maximum: number;
        stripLines: IStiStripLinesXF;
        stripPositions: number[];
        dpi: number;
        ticksCollection: IStiStripPositionXF[];
        labelsCollection: IStiStripPositionXF[];
        step: number;
        range: number;
        clone(): IStiAxisInfoXF;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiAxisInteraction: System.Interface<IStiAxisInteraction>;
    interface IStiAxisInteraction extends ICloneable, IStiJsonReportObject {
        showScrollBar: boolean;
        rangeScrollEnabled: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiAxisLabels: System.Interface<IStiAxisLabels>;
    interface IStiAxisLabels extends ICloneable, IStiJsonReportObject {
        core: IStiAxisLabelsCoreXF;
        allowApplyStyle: boolean;
        format: string;
        angle: number;
        width: number;
        textBefore: string;
        textAfter: string;
        font: Font;
        antialiasing: boolean;
        placement: StiLabelsPlacement;
        color: Color;
        textAlignment: StiHorAlignment;
        step: number;
        calculatedStep: number;
        wordWrap: boolean;
        formatService: StiFormatService;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiAxisLabelsCoreXF: System.Interface<IStiAxisLabelsCoreXF>;
    interface IStiAxisLabelsCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiAxisRange: System.Interface<IStiAxisRange>;
    interface IStiAxisRange extends ICloneable, IStiJsonReportObject {
        minimum: number;
        maximum: number;
        auto: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiAxisTicks: System.Interface<IStiAxisTicks>;
    interface IStiAxisTicks extends ICloneable, IStiJsonReportObject {
        lengthUnderLabels: number;
        length: number;
        minorLength: number;
        minorCount: number;
        step: number;
        minorVisible: boolean;
        visible: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiAxisTitle: System.Interface<IStiAxisTitle>;
    interface IStiAxisTitle extends ICloneable, IStiJsonReportObject {
        core: IStiAxisTitleCoreXF;
        allowApplyStyle: boolean;
        font: Font;
        text: string;
        color: Color;
        antialiasing: boolean;
        alignment: StringAlignment;
        direction: StiDirection;
        position: StiTitlePosition;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiAxisTitleCoreXF: System.Interface<IStiAxisTitleCoreXF>;
    interface IStiAxisTitleCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    let IStiXAxis: System.Interface<IStiXAxis>;
    interface IStiXAxis extends IStiAxis {
        showEdgeValues: boolean;
        showXAxis: StiShowXAxis;
        dateTimeStep: IStiAxisDateTimeStep;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiXBottomAxis: System.Interface<IStiXBottomAxis>;
    interface IStiXBottomAxis extends IStiXAxis {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiXTopAxis: System.Interface<IStiXTopAxis>;
    interface IStiXTopAxis extends IStiXAxis {
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    let IStiYAxis: System.Interface<IStiYAxis>;
    interface IStiYAxis extends IStiAxis {
        showYAxis: StiShowYAxis;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiYLeftAxis: System.Interface<IStiYLeftAxis>;
    interface IStiYLeftAxis extends IStiYAxis {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiYRightAxis: System.Interface<IStiYRightAxis>;
    interface IStiYRightAxis extends IStiYAxis {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiStripLineXF: System.Interface<IStiStripLineXF>;
    interface IStiStripLineXF {
        valueObject: any;
        value: number;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    let IStiStripLinesXF: System.Interface<IStiStripLinesXF>;
    interface IStiStripLinesXF extends ICollection<IStiStripLineXF> {
        add2(valueObject: any, value: number): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiStripPositionXF: System.Interface<IStiStripPositionXF>;
    interface IStiStripPositionXF {
        stripLine: IStiStripLineXF;
        position: number;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiChartTitle: System.Interface<IStiChartTitle>;
    interface IStiChartTitle extends ICloneable, IStiJsonReportObject {
        core: IStiChartTitleCoreXF;
        allowApplyStyle: boolean;
        font: Font;
        text: string;
        brush: StiBrush;
        antialiasing: boolean;
        alignment: StringAlignment;
        dock: StiChartTitleDock;
        spacing: number;
        visible: boolean;
        chart: IStiChart;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    let IStiChartTitleCoreXF: System.Interface<IStiChartTitleCoreXF>;
    interface IStiChartTitleCoreXF extends IStiApplyStyle {
        render(context: StiContext, chartTitle: IStiChartTitle, rect: RectangleD): IStiCellGeom;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiChartCondition: System.Interface<IStiChartCondition>;
    interface IStiChartCondition extends IStiChartFilter {
        color: Color;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    let IStiChartConditionsCollection: System.Interface<IStiChartConditionsCollection>;
    interface IStiChartConditionsCollection extends ICollection<IStiChartCondition> {
        add(condition: IStiChartCondition): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiConstantLines: System.Interface<IStiConstantLines>;
    interface IStiConstantLines extends ICloneable, IStiJsonReportObject {
        core: IStiConstantLinesCoreXF;
        allowApplyStyle: boolean;
        antialiasing: boolean;
        position: StiConstantLines_StiTextPosition;
        font: Font;
        text: string;
        titleVisible: boolean;
        orientation: StiConstantLines_StiOrientation;
        lineWidth: number;
        lineStyle: StiPenStyle;
        lineColor: Color;
        showInLegend: boolean;
        showBehind: boolean;
        axisValue: string;
        visible: boolean;
        chart: IStiChart;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    let IStiConstantLinesCollection: System.Interface<IStiConstantLinesCollection>;
    interface IStiConstantLinesCollection extends ICollection<IStiConstantLines>, IStiApplyStyle {
        add(value: IStiConstantLines): any;
        insert(index: number, value: IStiConstantLines): any;
        getByIndex(index: number): IStiConstantLines;
        applyStyle(style: IStiChartStyle): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    let IStiConstantLinesCoreXF: System.Interface<IStiConstantLinesCoreXF>;
    interface IStiConstantLinesCoreXF extends IStiApplyStyle {
        render(context: StiContext, geom: IStiCellGeom, rect: RectangleD): any;
        applyStyle(style: IStiChartStyle): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    import StiFilterItem = Stimulsoft.Report.Components.StiFilterItem;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    let IStiChartFilter: System.Interface<IStiChartFilter>;
    interface IStiChartFilter extends IStiJsonReportObject, ICloneable {
        clone(): any;
        condition: StiFilterCondition;
        dataType: StiFilterDataType;
        item: StiFilterItem;
        value: string;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    let IStiChartFiltersCollection: System.Interface<IStiChartFiltersCollection>;
    interface IStiChartFiltersCollection extends ICollection<IStiChartFilter> {
        add(value: IStiChartFilter): any;
        getByIndex(index: number): IStiChartFilter;
        insert(index: number, value: IStiChartFilter): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiGridLines: System.Interface<IStiGridLines>;
    interface IStiGridLines extends ICloneable, IStiJsonReportObject {
        core: IStiGridLinesCoreXF;
        allowApplyStyle: boolean;
        color: Color;
        minorColor: Color;
        style: StiPenStyle;
        minorStyle: StiPenStyle;
        visible: boolean;
        minorVisible: boolean;
        minorCount: number;
        area: IStiArea;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiGridLinesCoreXF: System.Interface<IStiGridLinesCoreXF>;
    interface IStiGridLinesCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiGridLinesHor: System.Interface<IStiGridLinesHor>;
    interface IStiGridLinesHor extends IStiGridLines {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiGridLinesVert: System.Interface<IStiGridLinesVert>;
    interface IStiGridLinesVert extends IStiGridLines {
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiRadarGridLines: System.Interface<IStiRadarGridLines>;
    interface IStiRadarGridLines extends ICloneable, IStiJsonReportObject {
        core: IStiRadarGridLinesCoreXF;
        allowApplyStyle: boolean;
        color: Color;
        style: StiPenStyle;
        visible: boolean;
        area: IStiArea;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiRadarGridLinesCoreXF: System.Interface<IStiRadarGridLinesCoreXF>;
    interface IStiRadarGridLinesCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiRadarGridLinesHor: System.Interface<IStiRadarGridLinesHor>;
    interface IStiRadarGridLinesHor extends IStiRadarGridLines {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiRadarGridLinesVert: System.Interface<IStiRadarGridLinesVert>;
    interface IStiRadarGridLinesVert extends IStiRadarGridLines {
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiInterlacing: System.Interface<IStiInterlacing>;
    interface IStiInterlacing extends ICloneable, IStiJsonReportObject, IAsIs {
        core: IStiInterlacingCoreXF;
        allowApplyStyle: boolean;
        interlacedBrush: StiBrush;
        visible: boolean;
        area: IStiArea;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiInterlacingCoreXF: System.Interface<IStiInterlacingCoreXF>;
    interface IStiInterlacingCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiInterlacingHor: System.Interface<IStiInterlacingHor>;
    interface IStiInterlacingHor extends IStiInterlacing {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiInterlacingVert: System.Interface<IStiInterlacingVert>;
    interface IStiInterlacingVert extends IStiInterlacing {
    }
}
declare namespace Stimulsoft.Report.Chart {
    import SizeD = Stimulsoft.System.Drawing.Size;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiLegend: System.Interface<IStiLegend>;
    interface IStiLegend extends ICloneable, IStiJsonReportObject {
        core: IStiLegendCoreXF;
        allowApplyStyle: boolean;
        chart: IStiChart;
        hideSeriesWithEmptyTitle: boolean;
        showShadow: boolean;
        borderColor: Color;
        brush: StiBrush;
        titleColor: Color;
        labelsColor: Color;
        direction: StiLegendDirection;
        horAlignment: StiLegendHorAlignment;
        vertAlignment: StiLegendVertAlignment;
        titleFont: Font;
        font: Font;
        visible: boolean;
        markerVisible: boolean;
        markerBorder: boolean;
        markerSize: SizeD;
        markerAlignment: StiMarkerAlignment;
        columns: number;
        horSpacing: number;
        vertSpacing: number;
        size: SizeD;
        title: string;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    let IStiLegendCoreXF: System.Interface<IStiLegendCoreXF>;
    interface IStiLegendCoreXF extends IStiApplyStyle {
        render(context: StiContext, rect: RectangleD): IStiCellGeom;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    let IStiLegendMarker: System.Interface<IStiLegendMarker>;
    interface IStiLegendMarker {
        draw(context: StiContext, series: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiLineMarker: System.Interface<IStiLineMarker>;
    interface IStiLineMarker extends IStiMarker {
        step: number;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiMarker: System.Interface<IStiMarker>;
    interface IStiMarker extends IStiFontIconsSeries, ICloneable, IStiJsonReportObject, IAsIs {
        core: IStiMarkerCoreXF;
        showInLegend: boolean;
        visible: boolean;
        brush: StiBrush;
        borderColor: Color;
        size: number;
        angle: number;
        type: StiMarkerType;
        icon: StiFontIcons;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    let IStiMarkerCoreXF: System.Interface<IStiMarkerCoreXF>;
    interface IStiMarkerCoreXF {
        draw(context: StiContext, marker: IStiMarker, position: PointD, zoom: number, showShadow: boolean, isMouseOver: boolean, isTooltipMode: boolean, isAnimation: boolean, toolTip: string, tag: any, interaction: StiInteractionDataGeom): any;
        drawLine(context: StiContext, x1: number, y1: number, x2: number, y2: number, scale: number, brushMarker: StiBrush, penMarker: StiPenGeom, markerType: StiMarkerType, markerStep: number, markerSize: number, angle: number): any;
        drawLines(context: StiContext, points: PointD[], scale: number, brushMarker: any, penMarker: StiPenGeom, markerType: StiMarkerType, markerStep: number, markerSize: number, angle: number): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiRadarAxis: System.Interface<IStiRadarAxis>;
    interface IStiRadarAxis extends ICloneable, IStiJsonReportObject {
        core: IStiRadarAxisCoreXF;
        allowApplyStyle: boolean;
        area: IStiRadarArea;
        visible: boolean;
        range: IStiAxisRange;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiRadarAxisCoreXF: System.Interface<IStiRadarAxisCoreXF>;
    interface IStiRadarAxisCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiRadarAxisLabels: System.Interface<IStiRadarAxisLabels>;
    interface IStiRadarAxisLabels extends ICloneable, IStiJsonReportObject {
        core: IStiRadarAxisLabelsCoreXF;
        rotationLabels: boolean;
        allowApplyStyle: boolean;
        drawBorder: boolean;
        textBefore: string;
        textAfter: string;
        format: string;
        font: Font;
        antialiasing: boolean;
        color: Color;
        borderColor: Color;
        brush: StiBrush;
        width: number;
        wordWrap: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiRadarAxisLabelsCoreXF: System.Interface<IStiRadarAxisLabelsCoreXF>;
    interface IStiRadarAxisLabelsCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiXRadarAxis: System.Interface<IStiXRadarAxis>;
    interface IStiXRadarAxis extends IStiRadarAxis {
        xCore: IStiXRadarAxisCoreXF;
        labels: IStiRadarAxisLabels;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    let IStiXRadarAxisCoreXF: System.Interface<IStiXRadarAxisCoreXF>;
    interface IStiXRadarAxisCoreXF {
        renderLabel(context: StiContext, series: IStiSeries, point: PointD, argument: any, angle: number, colorIndex: number, colorCount: number): IStiCellGeom;
        getLabelRect(context: StiContext, point: PointD, text: string, angle: number): RectangleD;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiYRadarAxis: System.Interface<IStiYRadarAxis>;
    interface IStiYRadarAxis extends IStiRadarAxis {
        yCore: IStiYRadarAxisCoreXF;
        labels: IStiAxisLabels;
        ticks: IStiAxisTicks;
        lineStyle: StiPenStyle;
        lineColor: Color;
        lineWidth: number;
        info: IStiAxisInfoXF;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    let IStiYRadarAxisCoreXF: System.Interface<IStiYRadarAxisCoreXF>;
    interface IStiYRadarAxisCoreXF {
        render(context: StiContext, rect: RectangleD): IStiCellGeom;
        ticksMaxLength: number;
        getFontGeom(context: StiContext): StiFontGeom;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        calculateStripPositions(topPosition: number, bottomPosition: number): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiAllowApplyBorderColor: System.Interface<IStiAllowApplyBorderColor>;
    interface IStiAllowApplyBorderColor {
        allowApplyBorderColor: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiAllowApplyBrush: System.Interface<IStiAllowApplyBrush>;
    interface IStiAllowApplyBrush {
        allowApplyBrush: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiAllowApplyBrushNegative: System.Interface<IStiAllowApplyBrushNegative>;
    interface IStiAllowApplyBrushNegative {
        allowApplyBrushNegative: boolean;
        brushNegative: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiAllowApplyColorNegative: System.Interface<IStiAllowApplyColorNegative>;
    interface IStiAllowApplyColorNegative {
        allowApplyColorNegative: boolean;
        lineColorNegative: Color;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    let IStiFontIconsSeries: System.Interface<IStiFontIconsSeries>;
    interface IStiFontIconsSeries {
        icon: StiFontIcons;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import IStiTrendLinesCollection = Stimulsoft.Report.Chart.IStiTrendLinesCollection;
    let IStiSeries: System.Interface<IStiSeries>;
    interface IStiSeries extends ICloneable, IStiJsonReportObject, IAsIs {
        core: IStiSeriesCoreXF;
        allowApplyStyle: boolean;
        format: string;
        coreTitle: string;
        titleValue: string;
        sortBy: StiSeriesSortType;
        sortDirection: StiSeriesSortDirection;
        showInLegend: boolean;
        showSeriesLabels: StiShowSeriesLabels;
        showShadow: boolean;
        filters: IStiChartFiltersCollection;
        topN: IStiSeriesTopN;
        conditions: IStiChartConditionsCollection;
        yAxis: StiSeriesYAxis;
        seriesLabels: IStiSeriesLabels;
        chart: IStiChart;
        valuesStart: number[];
        values: number[];
        arguments: any[];
        originalArguments: any[];
        toolTips: string[];
        tags: any[];
        hyperlinks: string[];
        interaction: IStiSeriesInteraction;
        argumentDataColumn: string;
        argument: string;
        title: string;
        filterMode: StiFilterMode;
        trendLines: IStiTrendLinesCollection;
        trendLine: IStiTrendLine;
        isTotalLabel: boolean;
        drillDownEnabled: boolean;
        isDashboard: boolean;
        legendColor: Color;
        processSeriesColors(pointIndex: number, seriesColor: Color): Color;
        processSeriesBrushes(pointIndex: number, seriesBrush: StiBrush): StiBrush;
        processSeriesMarkerType(pointIndex: number, markerType: StiMarkerType): StiMarkerType;
        processSeriesMarkerAngle(pointIndex: number, markerAngle: number): number;
        processSeriesMarkerVisible(pointIndex: number): boolean;
        getDefaultAreaType(): Stimulsoft.System.Type;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    import List = Stimulsoft.System.Collections.List;
    let IStiSeriesCollection: System.Interface<IStiSeriesCollection>;
    interface IStiSeriesCollection extends ICollection<IStiSeries>, IStiApplyStyle {
        add(value: IStiSeries): any;
        getByIndex(index: number): IStiSeries;
        insert(index: number, value: IStiSeries): any;
        indexOf(value: IStiSeries): number;
        toList(): List<IStiSeries>;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiSeriesCoreXF: System.Interface<IStiSeriesCoreXF>;
    interface IStiSeriesCoreXF {
        renderSeries(context: StiContext, rect: RectangleD, geom: IStiCellGeom, seriesArray: IStiSeries[]): any;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        getSeriesLabels(): IStiAxisSeriesLabels;
        setIsMouseOverSeriesElement(seriesIndex: number, value: boolean): any;
        isDateTimeValues: boolean;
        applyStyle(style: IStiChartStyle, color: Color): any;
        getTag(tagIndex: number): string;
        getIsMouseOverSeriesElement(seriesIndex: number): boolean;
        interaction: IStiSeriesInteraction;
        seriesColors: Color[];
        isDateTimeArguments: boolean;
        isMouseOver: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiShowNullsSeries: System.Interface<IStiShowNullsSeries>;
    interface IStiShowNullsSeries {
        showNulls: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiShowZerosSeries: System.Interface<IStiShowZerosSeries>;
    interface IStiShowZerosSeries {
        showZeros: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiBoxAndWhiskerSeries: System.Interface<IStiBoxAndWhiskerSeries>;
    interface IStiBoxAndWhiskerSeries extends IStiSeries, IStiAllowApplyBrush {
        brush: StiBrush;
        showMeanMarkers: boolean;
        showInnerPoints: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiBubbleSeries: System.Interface<IStiBubbleSeries>;
    interface IStiBubbleSeries extends IStiScatterSeries {
        weights: number[];
        borderColor: Color;
        brush: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiClusteredBarSeries: System.Interface<IStiClusteredBarSeries>;
    interface IStiClusteredBarSeries extends IStiClusteredColumnSeries {
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiAreaSeries: System.Interface<IStiAreaSeries>;
    interface IStiAreaSeries extends IStiLineSeries, IStiAllowApplyBrushNegative {
        topmostLine: boolean;
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiBaseLineSeries: System.Interface<IStiBaseLineSeries>;
    interface IStiBaseLineSeries extends IStiSeries, IStiAllowApplyColorNegative, IStiShowNullsSeries, IStiShowZerosSeries {
        marker: IStiMarker;
        lineMarker: IStiLineMarker;
        lineColor: Color;
        lineStyle: StiPenStyle;
        lighting: boolean;
        lineWidth: number;
        labelsOffset: number;
        lineColorNegative: Color;
        showNullsAs: StiShowEmptyCellsAs;
        showZerosAs: StiShowEmptyCellsAs;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiClusteredColumnSeries: System.Interface<IStiClusteredColumnSeries>;
    interface IStiClusteredColumnSeries extends IStiSeries, IStiFontIconsSeries, IStiAllowApplyBrushNegative, IStiShowZerosSeries {
        width: number;
        borderColor: Color;
        brush: StiBrush;
        brushNegative: StiBrush;
        showZeros: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiHistogramSeries: System.Interface<IStiHistogramSeries>;
    interface IStiHistogramSeries extends IStiClusteredColumnSeries {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiLineSeries: System.Interface<IStiLineSeries>;
    interface IStiLineSeries extends IStiBaseLineSeries {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiParetoSeries: System.Interface<IStiParetoSeries>;
    interface IStiParetoSeries extends IStiClusteredColumnSeries, IStiBaseLineSeries {
        allowApplyLineColor: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiSplineAreaSeries: System.Interface<IStiSplineAreaSeries>;
    interface IStiSplineAreaSeries extends IStiSplineSeries, IStiAllowApplyBrushNegative {
        topmostLine: boolean;
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiSplineSeries: System.Interface<IStiSplineSeries>;
    interface IStiSplineSeries extends IStiBaseLineSeries, IStiAllowApplyColorNegative {
        tension: number;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiSteppedAreaSeries: System.Interface<IStiSteppedAreaSeries>;
    interface IStiSteppedAreaSeries extends IStiSteppedLineSeries, IStiAllowApplyBrushNegative {
        topmostLine: boolean;
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiSteppedLineSeries: System.Interface<IStiSteppedLineSeries>;
    interface IStiSteppedLineSeries extends IStiBaseLineSeries, IStiAllowApplyColorNegative {
        pointAtCenter: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiWaterfallSeries: System.Interface<IStiWaterfallSeries>;
    interface IStiWaterfallSeries extends IStiClusteredColumnSeries {
        connectorLine: IStiWaterfallConnectorLine;
        total: IStiWaterfallTotal;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiDoughnutSeries: System.Interface<IStiDoughnutSeries>;
    interface IStiDoughnutSeries extends IStiPieSeries {
        width: number;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiCandlestickSeries: System.Interface<IStiCandlestickSeries>;
    interface IStiCandlestickSeries extends IStiSeries, IStiFinancialSeries {
        borderColor: Color;
        borderColorNegative: Color;
        borderWidth: number;
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiFinancialSeries: System.Interface<IStiFinancialSeries>;
    interface IStiFinancialSeries {
        valuesOpen: number[];
        valuesClose: number[];
        valuesHigh: number[];
        valuesLow: number[];
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiStockSeries: System.Interface<IStiStockSeries>;
    interface IStiStockSeries extends IStiSeries, IStiFinancialSeries, IStiAllowApplyColorNegative {
        lineColor: Color;
        lineStyle: StiPenStyle;
        lineWidth: number;
        lineColorNegative: Color;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiFullStackedBarSeries: System.Interface<IStiFullStackedBarSeries>;
    interface IStiFullStackedBarSeries extends IStiStackedBarSeries {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiFullStackedAreaSeries: System.Interface<IStiFullStackedAreaSeries>;
    interface IStiFullStackedAreaSeries extends IStiStackedAreaSeries {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiFullStackedColumnSeries: System.Interface<IStiFullStackedColumnSeries>;
    interface IStiFullStackedColumnSeries extends IStiStackedColumnSeries {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiFullStackedLineSeries: System.Interface<IStiFullStackedLineSeries>;
    interface IStiFullStackedLineSeries extends IStiStackedLineSeries {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiFullStackedSplineAreaSeries: System.Interface<IStiFullStackedSplineAreaSeries>;
    interface IStiFullStackedSplineAreaSeries extends IStiStackedSplineAreaSeries {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiFullStackedSplineSeries: System.Interface<IStiFullStackedSplineSeries>;
    interface IStiFullStackedSplineSeries extends IStiStackedSplineSeries {
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiFunnelSeries: System.Interface<IStiFunnelSeries>;
    interface IStiFunnelSeries extends IStiSeries, IStiFontIconsSeries, IStiShowZerosSeries {
        showZeros: boolean;
        allowApplyBrush: boolean;
        allowApplyBorderColor: boolean;
        borderColor: Color;
        brush: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiFunnelWeightedSlicesSeries: System.Interface<IStiFunnelWeightedSlicesSeries>;
    interface IStiFunnelWeightedSlicesSeries extends IStiFunnelSeries {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiGanttSeries: System.Interface<IStiGanttSeries>;
    interface IStiGanttSeries extends IStiClusteredBarSeries, IStiRangeSeries {
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiPictorialSeries: System.Interface<IStiPictorialSeries>;
    interface IStiPictorialSeries extends IStiSeries, IStiFontIconsSeries {
        brush: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiPieSeries: System.Interface<IStiPieSeries>;
    interface IStiPieSeries extends IStiSeries, IStiFontIconsSeries, IStiAllowApplyBorderColor, IStiAllowApplyBrush, IStiShowZerosSeries {
        startAngle: number;
        borderColor: Color;
        brush: StiBrush;
        lighting: boolean;
        diameter: number;
        distance: number;
        cutPieListValues: number[];
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiRadarAreaSeries: System.Interface<IStiRadarAreaSeries>;
    interface IStiRadarAreaSeries extends IStiRadarLineSeries {
        brush: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiRadarLineSeries: System.Interface<IStiRadarLineSeries>;
    interface IStiRadarLineSeries extends IStiRadarSeries {
        lineColor: Color;
        lineStyle: StiPenStyle;
        lighting: boolean;
        lineWidth: number;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiRadarPointSeries: System.Interface<IStiRadarPointSeries>;
    interface IStiRadarPointSeries extends IStiRadarSeries {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiRadarSeries: System.Interface<IStiRadarSeries>;
    interface IStiRadarSeries extends IStiSeries, IStiShowNullsSeries {
        marker: IStiMarker;
        showNulls: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiLineRangeSeries: System.Interface<IStiLineRangeSeries>;
    interface IStiLineRangeSeries extends IStiLineSeries, IStiRangeSeries, IStiAllowApplyBrushNegative {
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiRangeBarSeries: System.Interface<IStiRangeBarSeries>;
    interface IStiRangeBarSeries extends IStiClusteredColumnSeries, IStiRangeSeries {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiRangeSeries: System.Interface<IStiRangeSeries>;
    interface IStiRangeSeries {
        valuesEnd: number[];
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiSplineRangeSeries: System.Interface<IStiSplineRangeSeries>;
    interface IStiSplineRangeSeries extends IStiSplineSeries, IStiRangeSeries {
        brush: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiSteppedRangeSeries: System.Interface<IStiSteppedRangeSeries>;
    interface IStiSteppedRangeSeries extends IStiSteppedLineSeries, IStiRangeSeries, IStiAllowApplyBrushNegative {
        brush: StiBrush;
        brushNegative: StiBrush;
        allowApplyBrushNegative: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiScatterLineSeries: System.Interface<IStiScatterLineSeries>;
    interface IStiScatterLineSeries extends IStiScatterSeries {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiScatterSeries: System.Interface<IStiScatterSeries>;
    interface IStiScatterSeries extends IStiBaseLineSeries {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiScatterSplineSeries: System.Interface<IStiScatterSplineSeries>;
    interface IStiScatterSplineSeries extends IStiScatterLineSeries {
        tension: number;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiStackedBarSeries: System.Interface<IStiStackedBarSeries>;
    interface IStiStackedBarSeries extends IStiSeries, IStiFontIconsSeries, IStiAllowApplyBrushNegative, IStiShowZerosSeries {
        width: number;
        borderColor: Color;
        brush: StiBrush;
        showZeros: boolean;
        brushNegative: StiBrush;
        allowApplyBrushNegative: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiStackedAreaSeries: System.Interface<IStiStackedAreaSeries>;
    interface IStiStackedAreaSeries extends IStiStackedLineSeries, IStiAllowApplyBrushNegative {
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiStackedBaseLineSeries: System.Interface<IStiStackedBaseLineSeries>;
    interface IStiStackedBaseLineSeries extends IStiSeries, IStiShowNullsSeries {
        marker: IStiMarker;
        lineMarker: IStiLineMarker;
        lighting: boolean;
        lineColor: Color;
        lineWidth: number;
        lineStyle: StiPenStyle;
        showNulls: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiStackedColumnSeries: System.Interface<IStiStackedColumnSeries>;
    interface IStiStackedColumnSeries extends IStiSeries, IStiFontIconsSeries, IStiAllowApplyBrushNegative, IStiShowZerosSeries {
        width: number;
        borderColor: Color;
        brush: StiBrush;
        showZeros: boolean;
        brushNegative: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiStackedLineSeries: System.Interface<IStiStackedLineSeries>;
    interface IStiStackedLineSeries extends IStiStackedBaseLineSeries {
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiStackedSplineAreaSeries: System.Interface<IStiStackedSplineAreaSeries>;
    interface IStiStackedSplineAreaSeries extends IStiStackedSplineSeries, IStiAllowApplyBrushNegative {
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiStackedSplineSeries: System.Interface<IStiStackedSplineSeries>;
    interface IStiStackedSplineSeries extends IStiStackedBaseLineSeries, IStiAllowApplyColorNegative {
        tension: number;
        lineColorNegative: Color;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiSunburstSeries: System.Interface<IStiSunburstSeries>;
    interface IStiSunburstSeries extends IStiSeries {
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiTreemapSeries: System.Interface<IStiTreemapSeries>;
    interface IStiTreemapSeries extends IStiSeries, IStiFontIconsSeries {
        borderColor: Color;
        brush: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiNoneLabels: System.Interface<IStiNoneLabels>;
    interface IStiNoneLabels extends IStiSeriesLabels {
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiSeriesLabels: System.Interface<IStiSeriesLabels>;
    interface IStiSeriesLabels extends ICloneable, IStiJsonReportObject, IAsIs {
        allowApplyStyle: boolean;
        showZeros: boolean;
        showNulls: boolean;
        markerVisible: boolean;
        step: number;
        valueTypeSeparator: string;
        textBefore: string;
        textAfter: string;
        angle: number;
        format: string;
        antialiasing: boolean;
        visible: boolean;
        drawBorder: boolean;
        useSeriesColor: boolean;
        markerAlignment: StiMarkerAlignment;
        valueType: StiSeriesLabelsValueType;
        legendValueType: StiSeriesLabelsValueType;
        markerSize: SizeD;
        labelColor: Color;
        borderColor: Color;
        brush: StiBrush;
        font: Font;
        chart: IStiChart;
        core: IStiSeriesLabelsCoreXF;
        preventIntersection: boolean;
        wordWrap: boolean;
        width: number;
        formatService: StiFormatService;
        createNew(): IStiSeriesLabels;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    let IStiSeriesLabelsCoreXF: System.Interface<IStiSeriesLabelsCoreXF>;
    interface IStiSeriesLabelsCoreXF extends IStiApplyStyle {
        recalcValue(value: number, signs: number): number;
        getLabelColor(series: IStiSeries, colorIndex: number, colorCount: number): Color;
        getLabelText(series: IStiSeries, value: number, argument: string, tag: string, seriesName: string, useLegendValueType: boolean): string;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiAxisSeriesLabels: System.Interface<IStiAxisSeriesLabels>;
    interface IStiAxisSeriesLabels extends IStiSeriesLabels {
        showInPercent: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiCenterAxisLabels: System.Interface<IStiCenterAxisLabels>;
    interface IStiCenterAxisLabels extends IStiAxisSeriesLabels {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiInsideBaseAxisLabels: System.Interface<IStiInsideBaseAxisLabels>;
    interface IStiInsideBaseAxisLabels extends IStiAxisSeriesLabels {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiInsideEndAxisLabels: System.Interface<IStiInsideEndAxisLabels>;
    interface IStiInsideEndAxisLabels extends IStiCenterAxisLabels {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiLeftAxisLabels: System.Interface<IStiLeftAxisLabels>;
    interface IStiLeftAxisLabels extends IStiCenterAxisLabels {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiOutsideAxisLabels: System.Interface<IStiOutsideAxisLabels>;
    interface IStiOutsideAxisLabels extends IStiAxisSeriesLabels {
        lineLength: number;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiOutsideBaseAxisLabels: System.Interface<IStiOutsideBaseAxisLabels>;
    interface IStiOutsideBaseAxisLabels extends IStiCenterAxisLabels {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiOutsideEndAxisLabels: System.Interface<IStiOutsideEndAxisLabels>;
    interface IStiOutsideEndAxisLabels extends IStiCenterAxisLabels {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiRightAxisLabels: System.Interface<IStiRightAxisLabels>;
    interface IStiRightAxisLabels extends IStiCenterAxisLabels {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiValueAxisLabels: System.Interface<IStiValueAxisLabels>;
    interface IStiValueAxisLabels extends IStiCenterAxisLabels {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiCenterFunnelLabels: System.Interface<IStiCenterFunnelLabels>;
    interface IStiCenterFunnelLabels extends IStiFunnelSeriesLabels {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiFunnelSeriesLabels: System.Interface<IStiFunnelSeriesLabels>;
    interface IStiFunnelSeriesLabels extends IStiSeriesLabels {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiOutsideLeftFunnelLabels: System.Interface<IStiOutsideLeftFunnelLabels>;
    interface IStiOutsideLeftFunnelLabels extends IStiCenterFunnelLabels {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiOutsideRightFunnelLabels: System.Interface<IStiOutsideRightFunnelLabels>;
    interface IStiOutsideRightFunnelLabels extends IStiCenterFunnelLabels {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiCenterPieLabels: System.Interface<IStiCenterPieLabels>;
    interface IStiCenterPieLabels extends IStiPieSeriesLabels {
        autoRotate: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiInsideEndPieLabels: System.Interface<IStiInsideEndPieLabels>;
    interface IStiInsideEndPieLabels extends IStiCenterPieLabels {
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiOutsidePieLabels: System.Interface<IStiOutsidePieLabels>;
    interface IStiOutsidePieLabels extends IStiCenterPieLabels {
        showValue: boolean;
        lineLength: number;
        lineColor: Color;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiPieSeriesLabels: System.Interface<IStiPieSeriesLabels>;
    interface IStiPieSeriesLabels extends IStiSeriesLabels {
        showInPercent: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiTwoColumnsPieLabels: System.Interface<IStiTwoColumnsPieLabels>;
    interface IStiTwoColumnsPieLabels extends IStiOutsidePieLabels {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiRadarSeriesLabels: System.Interface<IStiRadarSeriesLabels>;
    interface IStiRadarSeriesLabels extends IStiSeriesLabels {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiTangentRadarLabels: System.Interface<IStiTangentRadarLabels>;
    interface IStiTangentRadarLabels extends IStiRadarSeriesLabels {
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiStrips: System.Interface<IStiStrips>;
    interface IStiStrips extends ICloneable, IStiJsonReportObject {
        core: IStiStripsCoreXF;
        allowApplyStyle: boolean;
        showBehind: boolean;
        stripBrush: StiBrush;
        antialiasing: boolean;
        font: Font;
        text: string;
        titleVisible: boolean;
        titleColor: Color;
        orientation: StiStrips_StiOrientation;
        showInLegend: boolean;
        maxValue: string;
        minValue: string;
        visible: boolean;
        chart: IStiChart;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    let IStiStripsCollection: System.Interface<IStiStripsCollection>;
    interface IStiStripsCollection extends ICollection<IStiStrips>, IStiApplyStyle {
        add(value: IStiStrips): any;
        insert(index: number, value: IStiStrips): any;
        getByIndex(index: number): IStiStrips;
        applyStyle(style: IStiChartStyle): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    let IStiStripsCoreXF: System.Interface<IStiStripsCoreXF>;
    interface IStiStripsCoreXF extends IStiApplyStyle {
        render(context: StiContext, geom: IStiCellGeom, rect: RectangleD): any;
        applyStyle(style: IStiChartStyle): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiCustomStyle: System.Interface<IStiCustomStyle>;
    interface IStiCustomStyle extends IStiChartStyle {
        customCore: IStiCustomStyleCoreXF;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiChartStyle = Stimulsoft.Report.Styles.StiChartStyle;
    let IStiCustomStyleCoreXF: System.Interface<IStiCustomStyleCoreXF>;
    interface IStiCustomStyleCoreXF extends IStiStyleCoreXF {
        reportStyle: StiChartStyle;
        reportStyleName: string;
        reportChartStyle: Stimulsoft.Report.Styles.StiChartStyle;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    let IStiStyleCoreXF: System.Interface<IStiStyleCoreXF>;
    interface IStiStyleCoreXF {
        chart: IStiChart;
        chartBrush: StiBrush;
        chartAreaBrush: StiBrush;
        chartAreaBorderColor: Color;
        seriesShowShadow: boolean;
        seriesShowBorder: boolean;
        seriesLighting: boolean;
        seriesLabelsFont: Font;
        seriesLabelsColor: Color;
        seriesLabelsLineColor: Color;
        seriesLabelsBrush: StiBrush;
        seriesLabelsBorderColor: Color;
        axisLineColor: Color;
        axisLabelsColor: Color;
        axisTitleColor: Color;
        gridLinesHorColor: Color;
        gridLinesVertColor: Color;
        interlacingHorBrush: StiBrush;
        interlacingVertBrush: StiBrush;
        legendBrush: StiBrush;
        legendLabelsColor: Color;
        legendBorderColor: Color;
        legendTitleColor: Color;
        legendShowShadow: boolean;
        legendFont: Font;
        getAreaBrush(color: Color): StiBrush;
        getColumnBrush(color: Color): StiBrush;
        getColumnBorder(color: Color): Color;
        getColors(seriesCount: number, seriesColors: Color[]): Color[];
        getColorByIndex(index: number, count: number, seriesColor: Color[]): Color;
        getColorBySeries(series: IStiSeries, seriesColor: Color[]): Color;
        basicStyleColor: Color;
        markerVisible: boolean;
        styleColors: Color[];
        trendLineColor: Color;
        fillColumn(context: StiContext, rect: RectangleD, brush: StiBrush, interaction: StiInteractionDataGeom): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiChartTable: System.Interface<IStiChartTable>;
    interface IStiChartTable extends ICloneable, IStiJsonReportObject {
        core: IStiChartTableCoreXF;
        chart: IStiChart;
        allowApplyStyle: boolean;
        font: Font;
        markerVisible: boolean;
        gridLineColor: Color;
        textColor: Color;
        gridLinesHor: boolean;
        gridLinesVert: boolean;
        gridOutline: boolean;
        visible: boolean;
        format: string;
        header: IStiChartTableHeader;
        dataCells: IStiChartTableDataCells;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    let IStiChartTableCoreXF: System.Interface<IStiChartTableCoreXF>;
    interface IStiChartTableCoreXF extends IStiApplyStyle {
        showTable(): boolean;
        getWidthCellLegend(context: StiContext): number;
        getHeightTable(context: StiContext, widthTable: number): number;
        render(context: StiContext, rect: RectangleD): IStiCellGeom;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiChartTableDataCells: System.Interface<IStiChartTableDataCells>;
    interface IStiChartTableDataCells extends ICloneable, IStiJsonReportObject {
        font: Font;
        textColor: Color;
        shrinkFontToFit: boolean;
        shrinkFontToFitMinimumSize: number;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiChartTableHeader: System.Interface<IStiChartTableHeader>;
    interface IStiChartTableHeader extends ICloneable, IStiJsonReportObject {
        textAfter: string;
        brush: StiBrush;
        font: Font;
        textColor: Color;
        wordWrap: boolean;
        format: string;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiSeriesTopN: System.Interface<IStiSeriesTopN>;
    interface IStiSeriesTopN extends ICloneable, IStiJsonReportObject {
        mode: StiTopNMode;
        count: number;
        showOthers: boolean;
        othersText: string;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Font = Stimulsoft.System.Drawing.Font;
    let IStiTrendLine: System.Interface<IStiTrendLine>;
    interface IStiTrendLine extends ICloneable, IStiJsonReportObject, IAsIs {
        core: IStiTrendLineCoreXF;
        lineWidth: number;
        lineStyle: StiPenStyle;
        lineColor: Color;
        font: Font;
        showShadow: boolean;
        titleVisible: boolean;
        text: string;
        position: StiTrendLine_StiTextPosition;
        serviceEnabled: boolean;
        allowApplyStyle: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    let IStiTrendLineCoreXF: System.Interface<IStiTrendLineCoreXF>;
    interface IStiTrendLineCoreXF {
        renderTrendLine(geom: IStiCellGeom, points: PointD[], posY: number): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiTrendLineExponential: System.Interface<IStiTrendLineExponential>;
    interface IStiTrendLineExponential extends IStiTrendLine {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiTrendLineLinear: System.Interface<IStiTrendLineLinear>;
    interface IStiTrendLineLinear extends IStiTrendLine {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiTrendLineLogarithmic: System.Interface<IStiTrendLineLogarithmic>;
    interface IStiTrendLineLogarithmic extends IStiTrendLine {
    }
}
declare namespace Stimulsoft.Report.Chart {
    let IStiTrendLineNone: System.Interface<IStiTrendLineNone>;
    interface IStiTrendLineNone extends IStiTrendLine {
    }
}
declare namespace Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    let IStiTrendLinesCollection: System.Interface<IStiTrendLinesCollection>;
    interface IStiTrendLinesCollection extends ICollection<IStiTrendLine> {
        add(value: IStiTrendLine): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    let IStiWaterfallConnectorLine: System.Interface<IStiWaterfallConnectorLine>;
    interface IStiWaterfallConnectorLine extends ICloneable, IStiJsonReportObject {
        lineColor: Color;
        lineStyle: StiPenStyle;
        lineWidth: number;
        visible: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiWaterfallTotal: System.Interface<IStiWaterfallTotal>;
    interface IStiWaterfallTotal extends ICloneable, IStiJsonReportObject {
        text: string;
        visible: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare namespace Stimulsoft.Report.CodeDom {
    import StiRichText = Stimulsoft.Report.Components.StiRichText;
    class StiCodeDomExpressionHelper {
        private static parseRtf;
        static readString(codeGenerator: StiCodeGenerator, REFpos: any, REFlexem: any, script: string, REFal: {
            ref: string[];
        }, isRichText: boolean, fullRtf: boolean): void;
        private static readChar;
        static getLexemSimple(codeGenerator: StiCodeGenerator, script: string, richText: StiRichText): string[];
        static getLexem(script: string): string[];
        private static replaceBackslash;
    }
}
declare namespace Stimulsoft.Report.Components {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiBookmarksCollection extends CollectionBase<StiBookmark> {
        indexOf(param: StiBookmark | string | any): number;
        getByName(name: string): StiBookmark;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCrossHeaderInteraction extends StiInteraction implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        isDefault(): boolean;
        private _collapsingEnabled;
        get collapsingEnabled(): boolean;
        set collapsingEnabled(value: boolean);
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiExpression = Stimulsoft.Report.Expressions.StiExpression;
    class StiDrillDownParameter implements IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        isDefault(): boolean;
        private _name;
        get name(): string;
        set name(value: string);
        private _expression;
        get expression(): StiExpression;
        set expression(value: StiExpression);
        private _interaction;
        set interaction(value: StiInteraction);
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiFilterHelper {
        static convertStringToCondition(condition: string): StiFilterCondition;
        static convertConditionToString(condition: StiFilterCondition): string;
        static convertStringToDataType(dataType: string): StiFilterDataType;
        static convertDataTypeToString(dataType: StiFilterDataType): string;
        static setFilter(comp: StiComponent): void;
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiFiltersCollection extends CollectionBase<StiFilter> implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiFiltersCollection;
    }
}
declare namespace Stimulsoft.Report.Components {
    import Size = Stimulsoft.System.Drawing.Size;
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Font = Stimulsoft.System.Drawing.Font;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiOutlineTextMetric {
        otmAscent: number;
        otmDescent: number;
        otmExternalLeading: number;
        otmsStrikeoutSize: number;
        otmsStrikeoutPosition: number;
        otmsUnderscoreSize: number;
        otmsUnderscorePosition: number;
        BaseFont: Font;
        Widths: number[];
        GetWidth(sym: number): number;
        constructor();
    }
    export class StiHtmlTextRender {
        private static outlineTextMetricsCache;
        static GetOutlineTextMetricsCached(fontName: string, fontStyle: FontStyle): StiOutlineTextMetric;
        static drawString(g: Graphics, rect: Rectangle, text: string, textBox: StiText): void;
        static measureString(textBox: StiText): Size;
        static breakText(rect: Rectangle, text: string, textBox: StiText): string[];
        static drawTextForOutput(textBox: StiText, outRunsList: any, outFontsList: any): void;
    }
    export {};
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiParameter implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        isDefault(): boolean;
        private _name;
        get name(): string;
        set name(value: string);
        private _expression;
        get expression(): string;
        set expression(value: string);
        constructor();
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiParametersCollection extends CollectionBase<StiParameter> implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiParametersCollection;
        indexOf2(name: string): number;
        insertRange(index: number, parameters: StiParametersCollection): void;
        remove2(parameter: StiParameter): void;
        getByName(name: string): StiParameter;
        setByName(name: string, value: any): void;
        copyTo(array: any[], index: number): void;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiRestrictionsHelper {
        static isAllowChange(comp: StiComponent): boolean;
        static isAllowDelete2(restrictions: StiRestrictions): boolean;
        static isAllowDelete(comp: StiComponent): boolean;
        static isAllowMove(comp: StiComponent): boolean;
        static isAllowSelect(comp: StiComponent): boolean;
        static isAllowResize(comp: StiComponent): boolean;
        static isAllowChangePosition(comp: StiComponent): boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiSortHelper {
        static getColumnIndexInSorting(sorts: string[], columnName: string): number;
        static getColumnSortDirection(sorts: string[], columnName: string): StiInteractionSortDirection;
        static changeColumnSortDirection(sorts: string[], columnName: string): string[];
        static isColumnExistInSorting(sorts: string[], columnName: string): boolean;
        static addColumnToSorting(sorts: string[], columnName: string, isAscending: boolean): string[];
    }
}
declare namespace Stimulsoft.Report.Components {
    import Font = Stimulsoft.System.Drawing.Font;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiStandardTextRenderer {
        static measureString(maxWidth: number, font: Font, textBox: StiText): SizeD;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiColumnFooterBand extends StiFooterBand implements IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get priority(): number;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiColumnHeaderBand extends StiHeaderBand {
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStaticBand extends StiBand implements IStiBreakable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        protected getComponentType(): StiComponentType;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOverlayBand extends StiStaticBand implements IStiVertAlignment, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _vertAlignment;
        get vertAlignment(): StiVertAlignment;
        set vertAlignment(value: StiVertAlignment);
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        protected getComponentType(): StiComponentType;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get priority(): number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiPageFooterBand extends StiStaticBand implements IStiPrintOnEvenOddPages, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _printOnEvenOddPages;
        get printOnEvenOddPages(): StiPrintOnEvenOddPagesType;
        set printOnEvenOddPages(value: StiPrintOnEvenOddPagesType);
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get priority(): number;
        canContainIn(component: StiComponent): boolean;
        protected getComponentType(): StiComponentType;
        getDisplayRectangle(): RectangleD;
        setDisplayRectangle(value: RectangleD): void;
        createNew(): StiComponent;
        getMaster(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPageHeaderBand extends StiStaticBand implements IStiBreakable, IStiPrintOnEvenOddPages, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get priority(): number;
        canContainIn(component: StiComponent): boolean;
        protected getComponentType(): StiComponentType;
        private _printOnEvenOddPages;
        get printOnEvenOddPages(): StiPrintOnEvenOddPagesType;
        set printOnEvenOddPages(value: StiPrintOnEvenOddPagesType);
        get printOnFirstPage(): boolean;
        set printOnFirstPage(value: boolean);
        getMaster(): StiComponent;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiReportSummaryBand extends StiDynamicBand implements IStiPrintIfEmpty, IStiKeepReportSummaryTogether, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _keepReportSummaryTogether;
        get keepReportSummaryTogether(): boolean;
        set keepReportSummaryTogether(value: boolean);
        private _printIfEmpty;
        get printIfEmpty(): boolean;
        set printIfEmpty(value: boolean);
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        canContainIn(component: StiComponent): boolean;
        get priority(): number;
        protected getComponentType(): StiComponentType;
        createNew(): StiComponent;
        getMaster(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiReportTitleBand extends StiStaticBand implements IStiBreakable, IStiPrintIfEmpty, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _printIfEmpty;
        get printIfEmpty(): boolean;
        set printIfEmpty(value: boolean);
        get headerStartColor(): Color;
        get headerEndColor(): Color;
        protected getComponentType(): StiComponentType;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get priority(): number;
        canContainIn(component: StiComponent): boolean;
        createNew(): StiComponent;
        getMaster(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import EventArgs = Stimulsoft.System.EventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiClone extends StiContainer implements IStiClone {
        private static ImplementsStiClone;
        implements(): any[];
        jsonContainerValueTemp: string;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        get canShrink(): boolean;
        set canShrink(value: boolean);
        get canGrow(): boolean;
        set canGrow(value: boolean);
        private _container;
        get container(): StiContainer;
        set container(value: StiContainer);
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        get toolboxPosition(): number;
        get toolboxCategory(): StiToolboxCategory;
        get componentType(): StiComponentType;
        canContainIn(component: StiComponent): boolean;
        private _components2;
        get components(): StiComponentsCollection;
        set components(value: StiComponentsCollection);
        onBeforePrint(e: EventArgs): void;
        onAfterPrint(e: EventArgs): void;
        constructor(rect?: RectangleD, isSuper?: boolean);
        protected construct(rect?: RectangleD): void;
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiColorScaleCondition extends StiBaseCondition implements IStiIndicatorCondition, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        createIndicator(component: StiText): StiIndicator;
        reset(): void;
        private _scaleType;
        get scaleType(): StiColorScaleType;
        set scaleType(value: StiColorScaleType);
        private _minimumColor;
        get minimumColor(): Color;
        set minimumColor(value: Color);
        private _midColor;
        get midColor(): Color;
        set midColor(value: Color);
        private _maximumColor;
        get maximumColor(): Color;
        set maximumColor(value: Color);
        private _minimumType;
        get minimumType(): StiMinimumType;
        set minimumType(value: StiMinimumType);
        private _minimumValue;
        get minimumValue(): number;
        set minimumValue(value: number);
        private _midType;
        get midType(): StiMidType;
        set midType(value: StiMidType);
        private _midValue;
        get midValue(): number;
        set midValue(value: number);
        private _maximumType;
        get maximumType(): StiMaximumType;
        set maximumType(value: StiMaximumType);
        private _maximumValue;
        get maximumValue(): number;
        set maximumValue(value: number);
        equals(obj: any): boolean;
        private minimum;
        private maximum;
        constructor(column?: string, scaleType?: StiColorScaleType, minimumColor?: Color, midColor?: Color, maximumColor?: Color, minimumType?: StiMinimumType, minimumValue?: number, midType?: StiMidType, midValue?: number, maximumType?: StiMaximumType, maximumValue?: number);
    }
}
declare namespace Stimulsoft.Report.Components {
    import Font = Stimulsoft.System.Drawing.Font;
    class StiConditionHelper extends StiFilter {
        implements(): any[];
        static apply(comp: any, styleName: string): void;
        private static applyParentStyle;
        static applyFont(component: any, font: Font, perms: StiConditionPermissions): void;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrushType = Stimulsoft.Report.Components.StiBrushType;
    class StiDataBarCondition extends StiBaseCondition implements IStiDataBarIndicator, IStiIndicatorCondition, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        createIndicator(component: StiText): StiIndicator;
        reset(): void;
        private _brushType;
        get brushType(): StiBrushType;
        set brushType(value: StiBrushType);
        private _positiveColor;
        get positiveColor(): Color;
        set positiveColor(value: Color);
        private _negativeColor;
        get negativeColor(): Color;
        set negativeColor(value: Color);
        private _positiveBorderColor;
        get positiveBorderColor(): Color;
        set positiveBorderColor(value: Color);
        private _negativeBorderColor;
        get negativeBorderColor(): Color;
        set negativeBorderColor(value: Color);
        private _showBorder;
        get showBorder(): boolean;
        set showBorder(value: boolean);
        private _direction;
        get direction(): StiDataBarDirection;
        set direction(value: StiDataBarDirection);
        private _minimumType;
        get minimumType(): StiMinimumType;
        set minimumType(value: StiMinimumType);
        private _minimumValue;
        get minimumValue(): number;
        set minimumValue(value: number);
        private _maximumType;
        get maximumType(): StiMaximumType;
        set maximumType(value: StiMaximumType);
        private _maximumValue;
        get maximumValue(): number;
        set maximumValue(value: number);
        equals(obj: any): boolean;
        private minimum;
        private maximum;
        constructor(column?: string, brushType?: StiBrushType, positiveColor?: Color, negativeColor?: Color, showBorder?: boolean, positiveBorderColor?: Color, negativeBorderColor?: Color, direction?: StiDataBarDirection, minimumType?: StiMinimumType, minimumValue?: number, maximumType?: StiMaximumType, maximumValue?: number);
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import ContentAlignment = Stimulsoft.System.Drawing.ContentAlignment;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiIconSetCondition extends StiBaseCondition implements IStiIndicatorCondition, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        createIndicator(component: StiText): StiIndicator;
        private inRange;
        reset(): void;
        private _iconSet;
        get iconSet(): StiIconSet;
        set iconSet(value: StiIconSet);
        private _contentAlignment;
        get contentAlignment(): ContentAlignment;
        set contentAlignment(value: ContentAlignment);
        private _iconSetItem1;
        get iconSetItem1(): StiIconSetItem;
        set iconSetItem1(value: StiIconSetItem);
        private _iconSetItem2;
        get iconSetItem2(): StiIconSetItem;
        set iconSetItem2(value: StiIconSetItem);
        private _iconSetItem3;
        get iconSetItem3(): StiIconSetItem;
        set iconSetItem3(value: StiIconSetItem);
        private _iconSetItem4;
        get iconSetItem4(): StiIconSetItem;
        set iconSetItem4(value: StiIconSetItem);
        private _iconSetItem5;
        get iconSetItem5(): StiIconSetItem;
        set iconSetItem5(value: StiIconSetItem);
        equals(obj: any): boolean;
        private minimum;
        private maximum;
        constructor(column?: string, iconSet?: StiIconSet, contentAlignment?: ContentAlignment, item1?: StiIconSetItem, item2?: StiIconSetItem, item3?: StiIconSetItem, item4?: StiIconSetItem, item5?: StiIconSetItem);
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiIconSetItem implements IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _icon;
        get icon(): StiIcon;
        set icon(value: StiIcon);
        private _operation;
        get operation(): StiIconSetOperation;
        set operation(value: StiIconSetOperation);
        private _valueType;
        get valueType(): StiIconSetValueType;
        set valueType(value: StiIconSetValueType);
        private _value;
        get value(): number;
        set value(value: number);
        constructor(icon?: StiIcon, operation?: StiIconSetOperation, valueType?: StiIconSetValueType, value?: number);
    }
}
declare namespace Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiMultiConditionContainer {
        private _filters;
        get filters(): StiFiltersCollection;
        set filters(value: StiFiltersCollection);
        private _filterMode;
        get filterMode(): StiFilterMode;
        set filterMode(value: StiFilterMode);
        private _enabled;
        get enabled(): boolean;
        set enabled(value: boolean);
        private _textColor;
        get textColor(): Color;
        set textColor(value: Color);
        private _backColor;
        get backColor(): Color;
        set backColor(value: Color);
        private _font;
        get font(): Font;
        set font(value: Font);
        private _canAssignExpression;
        get canAssignExpression(): boolean;
        set canAssignExpression(value: boolean);
        private _assignExpression;
        get assignExpression(): string;
        set assignExpression(value: string);
        private _style;
        get style(): string;
        set style(value: string);
        private _borderSides;
        get borderSides(): StiConditionBorderSides;
        set borderSides(value: StiConditionBorderSides);
        private _permissions;
        get permissions(): StiConditionPermissions;
        set permissions(value: StiConditionPermissions);
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCrossDataBand extends StiDataBand implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        get componentId(): StiComponentId;
        get growToHeight(): boolean;
        set growToHeight(value: boolean);
        get resetPageNumber(): boolean;
        set resetPageNumber(value: boolean);
        get startNewPage(): boolean;
        set startNewPage(value: boolean);
        get startNewPageIfLessThan(): number;
        set startNewPageIfLessThan(value: number);
        restoreState(stateName: string): void;
        get keepHeaderTogether(): boolean;
        set keepHeaderTogether(value: boolean);
        get keepFooterTogether(): boolean;
        set keepFooterTogether(value: boolean);
        get keepChildTogether(): boolean;
        set keepChildTogether(value: boolean);
        get keepGroupTogether(): boolean;
        set keepGroupTogether(value: boolean);
        get printAtBottom(): boolean;
        set printAtBottom(value: boolean);
        get printOnAllPages(): boolean;
        set printOnAllPages(value: boolean);
        setColumnModeToParent(): void;
        getColumnModeFromParent(): void;
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        get localizedCategory(): string;
        get localizedName(): string;
        get isCross(): boolean;
        isRightToLeft: boolean;
        getDockStyle(): StiDockStyle;
        get minWidth(): number;
        set minWidth(value: number);
        get maxWidth(): number;
        set maxWidth(value: number);
        defaultClientRectangle: RectangleD;
        get selectRectangle(): RectangleD;
        set selectRectangle(value: RectangleD);
        get displayRectangle(): RectangleD;
        set displayRectangle(value: RectangleD);
        columnCurrent: number;
        get headerSize(): number;
        createNew(): StiComponent;
        private _columnMode;
        get columnMode(): boolean;
        set columnMode(value: boolean);
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCrossFooterBand extends StiFooterBand implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        get componentId(): StiComponentId;
        get helpUrl(): string;
        get growToHeight(): boolean;
        set growToHeight(value: boolean);
        get resetPageNumber(): boolean;
        set resetPageNumber(value: boolean);
        get startNewPage(): boolean;
        set startNewPage(value: boolean);
        get startNewPageIfLessThan(): number;
        set startNewPageIfLessThan(value: number);
        get printAtBottom(): boolean;
        set printAtBottom(value: boolean);
        get printOnAllPages(): boolean;
        set printOnAllPages(value: boolean);
        get localizedCategory(): string;
        get localizedName(): string;
        get isCross(): boolean;
        getDockStyle(): StiDockStyle;
        setDockStyle(value: StiDockStyle): void;
        get minWidth(): number;
        set minWidth(value: number);
        get maxWidth(): number;
        set maxWidth(value: number);
        defaultClientRectangle: RectangleD;
        get selectRectangle(): RectangleD;
        set selectRectangle(value: RectangleD);
        get displayRectangle(): RectangleD;
        set displayRectangle(value: RectangleD);
        get headerSize(): number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCrossGroupFooterBand extends StiGroupFooterBand implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        get componentId(): StiComponentId;
        get helpUrl(): string;
        get growToHeight(): boolean;
        set growToHeight(value: boolean);
        get resetPageNumber(): boolean;
        set resetPageNumber(value: boolean);
        get printAtBottom(): boolean;
        set printAtBottom(value: boolean);
        get localizedCategory(): string;
        get localizedName(): string;
        get isCross(): boolean;
        getDockStyle(): StiDockStyle;
        setDockStyle(value: StiDockStyle): void;
        get minWidth(): number;
        set minWidth(value: number);
        get maxWidth(): number;
        set maxWidth(value: number);
        defaultClientRectangle: RectangleD;
        get selectRectangle(): RectangleD;
        set selectRectangle(value: RectangleD);
        get displayRectangle(): RectangleD;
        set displayRectangle(value: RectangleD);
        get headerSize(): number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCrossGroupHeaderBand extends StiGroupHeaderBand implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        get componentId(): StiComponentId;
        get helpUrl(): string;
        get growToHeight(): boolean;
        set growToHeight(value: boolean);
        get resetPageNumber(): boolean;
        set resetPageNumber(value: boolean);
        get startNewPage(): boolean;
        set startNewPage(value: boolean);
        get printOnAllPages(): boolean;
        set printOnAllPages(value: boolean);
        get printAtBottom(): boolean;
        set printAtBottom(value: boolean);
        get localizedCategory(): string;
        get localizedName(): string;
        get isCross(): boolean;
        getDockStyle(): StiDockStyle;
        setDockStyle(value: StiDockStyle): void;
        get minWidth(): number;
        set minWidth(value: number);
        get maxWidth(): number;
        set maxWidth(value: number);
        defaultClientRectangle: RectangleD;
        get selectRectangle(): RectangleD;
        set selectRectangle(value: RectangleD);
        get displayRectangle(): RectangleD;
        set displayRectangle(value: RectangleD);
        get headerSize(): number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCrossHeaderBand extends StiHeaderBand implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        get componentId(): StiComponentId;
        get helpUrl(): string;
        get growToHeight(): boolean;
        set growToHeight(value: boolean);
        get resetPageNumber(): boolean;
        set resetPageNumber(value: boolean);
        get startNewPage(): boolean;
        set startNewPage(value: boolean);
        get startNewPageIfLessThan(): number;
        set startNewPageIfLessThan(value: number);
        get printAtBottom(): boolean;
        set printAtBottom(value: boolean);
        get printOnAllPages(): boolean;
        set printOnAllPages(value: boolean);
        get localizedCategory(): string;
        get localizedName(): string;
        get isCross(): boolean;
        getDockStyle(): StiDockStyle;
        setDockStyle(value: StiDockStyle): void;
        get minWidth(): number;
        set minWidth(value: number);
        get maxWidth(): number;
        set maxWidth(value: number);
        defaultClientRectangle: RectangleD;
        get selectRectangle(): RectangleD;
        set selectRectangle(value: RectangleD);
        get displayRectangle(): RectangleD;
        set displayRectangle(value: RectangleD);
        get headerSize(): number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiIndicator implements IStiJsonReportObject, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromJsonObjectInternal(jObject: StiJson): StiIndicator;
        static loadFromXml(text: string): StiIndicator;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrushType = Stimulsoft.Report.Components.StiBrushType;
    class StiDataBarIndicator extends StiIndicator implements IStiDataBarIndicator, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _brushType;
        get brushType(): StiBrushType;
        set brushType(value: StiBrushType);
        private _positiveColor;
        get positiveColor(): Color;
        set positiveColor(value: Color);
        private _negativeColor;
        get negativeColor(): Color;
        set negativeColor(value: Color);
        private _positiveBorderColor;
        get positiveBorderColor(): Color;
        set positiveBorderColor(value: Color);
        private _negativeBorderColor;
        get negativeBorderColor(): Color;
        set negativeBorderColor(value: Color);
        private _showBorder;
        get showBorder(): boolean;
        set showBorder(value: boolean);
        private _value;
        get value(): number;
        set value(value: number);
        private _minimum;
        get minimum(): number;
        set minimum(value: number);
        private _maximum;
        get maximum(): number;
        set maximum(value: number);
        private _direction;
        get direction(): StiDataBarDirection;
        set direction(value: StiDataBarDirection);
        constructor(brushType?: StiBrushType, positiveColor?: Color, negativeColor?: Color, showBorder?: boolean, positiveBorderColor?: Color, negativeBorderColor?: Color, direction?: StiDataBarDirection, value?: number, minimum?: number, maximum?: number);
    }
}
declare namespace Stimulsoft.Report.Components {
    import Image = Stimulsoft.System.Drawing.Image;
    import StiIcon = Stimulsoft.Report.Components.StiIcon;
    class StiIconSetHelper {
        static getIconSet(iconSet: StiIconSet): StiIcon[];
        static getIcons(iconSet: StiIconSet): Image[];
        static getIcon2(icon: StiIcon): Image;
        static getIcon(indicator: StiIconSetIndicator): Image;
        private static _icons;
        private static get icons();
    }
}
declare namespace Stimulsoft.Report.Components {
    import Size = Stimulsoft.System.Drawing.Size;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import ContentAlignment = Stimulsoft.System.Drawing.ContentAlignment;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiIconSetIndicator extends StiIndicator implements IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _icon;
        get icon(): StiIcon;
        set icon(value: StiIcon);
        private _alignment;
        get alignment(): ContentAlignment;
        set alignment(value: ContentAlignment);
        customIcon: number[];
        customIconSize: Size;
        constructor(icon?: StiIcon, alignment?: ContentAlignment, customIcon?: number[], customIconSize?: Size);
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiAnchor: System.Interface<IStiAnchor>;
    interface IStiAnchor {
        anchor: StiAnchorMode;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiAutoWidth: System.Interface<IStiAutoWidth>;
    interface IStiAutoWidth {
        autoWidth: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiBorderColor: System.Interface<IStiBorderColor>;
    interface IStiBorderColor {
        borderColor: Color;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiCanGrow: System.Interface<IStiCanGrow>;
    interface IStiCanGrow {
        canGrow: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiCanShrink: System.Interface<IStiCanShrink>;
    interface IStiCanShrink {
        canShrink: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiClone: System.Interface<IStiClone>;
    interface IStiClone {
        container: StiContainer;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IAsIs = Stimulsoft.System.IAsIs;
    import ICloneable = Stimulsoft.System.ICloneable;
    let IStiComponent: System.Interface<IStiComponent>;
    interface IStiComponent extends ICloneable, IStiGrowToHeight, IStiPrintOn, IStiName, IAsIs {
        report: StiReport;
        parent: StiContainer;
        growToHeight: boolean;
        printOn: StiPrintOnType;
        printable: boolean;
        enabled: boolean;
        dockStyle: StiDockStyle;
        name: string;
        isDesigning: boolean;
        guid: string;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiComponentGuid: System.Interface<IStiComponentGuid>;
    interface IStiComponentGuid {
        guid: string;
        newGuid(): any;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiCrossTabField: System.Interface<IStiCrossTabField>;
    interface IStiCrossTabField {
    }
}
declare namespace Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrushType = Stimulsoft.Report.Components.StiBrushType;
    let IStiDataBarIndicator: System.Interface<IStiDataBarIndicator>;
    interface IStiDataBarIndicator {
        brushType: StiBrushType;
        positiveColor: Color;
        negativeColor: Color;
        positiveBorderColor: Color;
        negativeBorderColor: Color;
        showBorder: boolean;
        direction: StiDataBarDirection;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiGroup: System.Interface<IStiGroup>;
    interface IStiGroup {
        sortDirection: StiGroupSortDirection;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiGrowToHeight: System.Interface<IStiGrowToHeight>;
    interface IStiGrowToHeight {
        growToHeight: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiIgnoreBorderWhenExport: System.Interface<IStiIgnoreBorderWhenExport>;
    interface IStiIgnoreBorderWhenExport {
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiIndicatorCondition: System.Interface<IStiIndicatorCondition>;
    interface IStiIndicatorCondition {
        createIndicator(component: StiText): StiIndicator;
        reset(): any;
    }
}
declare namespace Stimulsoft.Report.Components {
    interface IStiInteractionClass {
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiKeepChildTogether: System.Interface<IStiKeepChildTogether>;
    interface IStiKeepChildTogether {
        keepChildTogether: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiKeepDetailsTogether: System.Interface<IStiKeepDetailsTogether>;
    interface IStiKeepDetailsTogether {
        keepDetailsTogether: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiKeepFooterTogether: System.Interface<IStiKeepFooterTogether>;
    interface IStiKeepFooterTogether {
        keepFooterTogether: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiKeepGroupFooterTogether: System.Interface<IStiKeepGroupFooterTogether>;
    interface IStiKeepGroupFooterTogether {
        keepGroupFooterTogether: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiKeepGroupTogether: System.Interface<IStiKeepGroupTogether>;
    interface IStiKeepGroupTogether {
        keepGroupTogether: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiKeepHeaderTogether: System.Interface<IStiKeepHeaderTogether>;
    interface IStiKeepHeaderTogether {
        keepHeaderTogether: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiKeepReportSummaryTogether: System.Interface<IStiKeepReportSummaryTogether>;
    interface IStiKeepReportSummaryTogether {
        keepReportSummaryTogether: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiOddEvenStyles: System.Interface<IStiOddEvenStyles>;
    interface IStiOddEvenStyles {
        evenStyle: string;
        oddStyle: string;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiPrintAtBottom: System.Interface<IStiPrintAtBottom>;
    interface IStiPrintAtBottom {
        printAtBottom: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiPrintIfDetailEmpty: System.Interface<IStiPrintIfDetailEmpty>;
    interface IStiPrintIfDetailEmpty {
        printIfDetailEmpty: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiPrintOn: System.Interface<IStiPrintOn>;
    interface IStiPrintOn {
        printOn: StiPrintOnType;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiPrintOnEvenOddPages: System.Interface<IStiPrintOnEvenOddPages>;
    interface IStiPrintOnEvenOddPages {
        printOnEvenOddPages: StiPrintOnEvenOddPagesType;
    }
}
declare namespace Stimulsoft.Report.Components {
    interface IStiSeriesParent {
        parent: StiComponent;
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiShape: System.Interface<IStiShape>;
    interface IStiShape {
    }
}
declare namespace Stimulsoft.Report.Components {
    let IStiShift: System.Interface<IStiShift>;
    interface IStiShift {
        shift: boolean;
        shiftMode: StiShiftMode;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    let IStiSimpleBorder: System.Interface<IStiSimpleBorder>;
    interface IStiSimpleBorder {
        border2: StiSimpleBorder;
    }
}
declare namespace Stimulsoft.Report.Components {
    import Font = Stimulsoft.System.Drawing.Font;
    let IStiTextFont: System.Interface<IStiTextFont>;
    interface IStiTextFont {
        getFont(): Font;
        setFontName(fontName: string): any;
        setFontSize(fontSize: number): any;
        growFontSize(): any;
        shrinkFontSize(): any;
        setFontBoldStyle(isBold: boolean): any;
        setFontItalicStyle(isItalic: boolean): any;
        setFontUnderlineStyle(isUnderline: boolean): any;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    let IStiTextHorAlignment: System.Interface<IStiTextHorAlignment>;
    let ImplementsIStiTextHorAlignment: any[];
    interface IStiTextHorAlignment {
        horAlignment: StiTextHorAlignment;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    let IStiTextOptions: System.Interface<IStiTextOptions>;
    interface IStiTextOptions {
        textOptions: StiTextOptions;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    let IStiUnitConvert: System.Interface<IStiUnitConvert>;
    interface IStiUnitConvert {
        convert(oldUnit: StiUnit, newUnit: StiUnit): any;
    }
}
declare namespace Stimulsoft.Report.Components {
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiMathFormula extends StiComponent implements IStiFont, IStiBorder, IStiBrush, IStiTextBrush, IStiHorAlignment, IStiVertAlignment {
        private static implementsStiMathFormula;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean): object;
        horAlignment: StiHorAlignment;
        vertAlignment: StiVertAlignment;
        brush: StiBrush;
        border: StiBorder;
        textBrush: StiBrush;
        private _font;
        get font(): Font;
        set font(value: Font);
        laTexExpression: string;
        get priority(): number;
        get localizedCategory(): string;
        defaultClientRectangle: RectangleD;
        get localizedName(): string;
        createNew(): StiComponent;
        getFormulaString(): string;
        protected construct(rect?: RectangleD): void;
    }
}
declare namespace Stimulsoft.Report.Components {
    enum StiShapeDirection {
        Up = 0,
        Down = 1,
        Left = 2,
        Right = 3
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiShapeTypeService extends StiService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromJsonObjectInternal(jObject: StiJson): StiShapeTypeService;
        static createFromJsonObject(jObject: StiJson): StiShapeTypeService;
        loadFromXml(xmlNode: XmlNode): void;
        static convertFromXml(xmlNode: XmlNode): StiShapeTypeService;
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiArrowShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        private _direction;
        get direction(): StiShapeDirection;
        set direction(value: StiShapeDirection);
        private _arrowWidth;
        get arrowWidth(): number;
        set arrowWidth(value: number);
        private _arrowHeight;
        get arrowHeight(): number;
        set arrowHeight(value: number);
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection, arrowWidth?: number, arrowHeight?: number);
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiBentArrowShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        private _direction;
        get direction(): StiShapeDirection;
        set direction(value: StiShapeDirection);
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection);
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiChevronShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        private _direction;
        get direction(): StiShapeDirection;
        set direction(value: StiShapeDirection);
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection);
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiComplexArrowShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        private _direction;
        get direction(): StiShapeDirection;
        set direction(value: StiShapeDirection);
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection);
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiDiagonalDownLineShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiDiagonalUpLineShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiDivisionShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiEqualShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiFlowchartCardShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiFlowchartCollateShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        private _direction;
        get direction(): StiShapeDirection;
        set direction(value: StiShapeDirection);
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection);
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiFlowchartDecisionShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiFlowchartManualInputShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiFlowchartOffPageConnectorShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        private _direction;
        get direction(): StiShapeDirection;
        set direction(value: StiShapeDirection);
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection);
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiFlowchartPreparationShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        private _direction;
        get direction(): StiShapeDirection;
        set direction(value: StiShapeDirection);
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection);
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiFlowchartSortShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiFrameShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiHorizontalLineShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiLeftAndRightLineShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiMinusShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiMultiplyShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiOctagonShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        private _autoSize;
        get autoSize(): boolean;
        set autoSize(value: boolean);
        private _bevel;
        get bevel(): number;
        set bevel(value: number);
        createNew(): StiShapeTypeService;
        constructor(autoSize?: boolean, bevel?: number);
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiOvalShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiParallelogramShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiPlusShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiRectangleShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiRegularPentagonShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiRoundedRectangleShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        private _round;
        get round(): number;
        set round(value: number);
        createNew(): StiShapeTypeService;
        constructor(round?: number);
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiSnipDiagonalSideCornerRectangleShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiSnipSameSideCornerRectangleShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiTopAndBottomLineShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiTrapezoidShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiTriangleShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): any;
        private _direction;
        get direction(): StiShapeDirection;
        set direction(value: StiShapeDirection);
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection);
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiVerticalLineShapeType extends StiShapeTypeService {
        get componentId(): StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiContourText extends StiText implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _contourColor;
        get contourColor(): Color;
        set contourColor(value: Color);
        private _size;
        get size(): number;
        set size(value: number);
        constructor(rect?: RectangleD, text?: string);
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPrimitive extends StiComponent {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        get canShrink(): boolean;
        set canShrink(value: boolean);
        get canGrow(): boolean;
        set canGrow(value: boolean);
        get shift(): boolean;
        set shift(value: boolean);
        get useParentStyles(): boolean;
        set useParentStyles(value: boolean);
        get dockStyle(): StiDockStyle;
        set dockStyle(value: StiDockStyle);
        get growToHeight(): boolean;
        set growToHeight(value: boolean);
        get localizedCategory(): string;
        get componentType(): StiComponentType;
        get priority(): number;
        get clientRectangle(): RectangleD;
        set clientRectangle(value: RectangleD);
        getDisplayRectangle(): RectangleD;
        setDisplayRectangle(value: RectangleD): void;
        setDirectDisplayRectangle(rect: RectangleD): void;
        constructor(rect?: RectangleD, isSuper?: boolean);
        protected construct(rect?: RectangleD | any): void;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLinePrimitive extends StiPrimitive implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get invalidateOnMouseOver(): boolean;
        defaultClientRectangle: RectangleD;
        private _style;
        get style(): StiPenStyle;
        set style(value: StiPenStyle);
        private _color;
        get color(): Color;
        set color(value: Color);
        private _size;
        get size(): number;
        set size(value: number);
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCrossLinePrimitive extends StiLinePrimitive {
        static nullGuid: string;
        onRemoveComponent(): void;
        canContainIn(component: StiComponent): boolean;
        get linked(): boolean;
        set linked(value: boolean);
        get left(): number;
        set left(value: number);
        get top(): number;
        set top(value: number);
        get height(): number;
        set height(value: number);
        storedStartPoint: StiStartPointPrimitive;
        getStartPoint(cont?: StiContainer): StiStartPointPrimitive;
        storedEndPoint: StiEndPointPrimitive;
        getEndPoint(cont?: StiContainer): StiEndPointPrimitive;
        isParentContainerSelected(point: StiPointPrimitive): boolean;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPointPrimitive extends StiPrimitive implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get isSelected(): boolean;
        set isSelected(value: boolean);
        private _referenceToGuid;
        get referenceToGuid(): string;
        set referenceToGuid(value: string);
        get width(): number;
        set width(value: number);
        get height(): number;
        set height(value: number);
        storedColumn: number;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEndPointPrimitive extends StiPointPrimitive {
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiCap = Stimulsoft.Base.Drawing.StiCap;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHorizontalLinePrimitive extends StiLinePrimitive implements IStiBorder, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties?: boolean): any;
        private _border;
        get border(): StiBorder;
        set border(value: StiBorder);
        private _startCap;
        get startCap(): StiCap;
        set startCap(value: StiCap);
        private _endCap;
        get endCap(): StiCap;
        set endCap(value: StiCap);
        get height(): number;
        set height(value: number);
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRectanglePrimitive extends StiCrossLinePrimitive implements IStiBorder, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _border;
        get border(): StiBorder;
        set border(value: StiBorder);
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        get width(): number;
        set width(value: number);
        private _topSide;
        get topSide(): boolean;
        set topSide(value: boolean);
        private _leftSide;
        get leftSide(): boolean;
        set leftSide(value: boolean);
        private _bottomSide;
        get bottomSide(): boolean;
        set bottomSide(value: boolean);
        private _rightSide;
        get rightSide(): boolean;
        set rightSide(value: boolean);
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRoundedRectanglePrimitive extends StiRectanglePrimitive implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _round;
        get round(): number;
        set round(value: number);
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Image = Stimulsoft.System.Drawing.Image;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import IStiBorderColor = Stimulsoft.Report.Components.IStiBorderColor;
    import IStiShape = Stimulsoft.Report.Components.IStiShape;
    class StiShape extends StiComponent implements IStiBrush, IStiBorderColor, IStiExportImageExtended, IStiExportImage, IStiShape, IStiJsonReportObject {
        private _implementsStiShape;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean): StiShape;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _borderColor;
        get borderColor(): Color;
        set borderColor(value: Color);
        defaultClientRectangle: RectangleD;
        private _style;
        get style(): StiPenStyle;
        set style(value: StiPenStyle);
        private _size;
        get size(): number;
        set size(value: number);
        private _shapeType;
        get shapeType(): StiShapeTypeService;
        set shapeType(value: StiShapeTypeService);
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStartPointPrimitive extends StiPointPrimitive {
        get componentId(): StiComponentId;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiTextInCells extends StiText {
        private static ImplementsTextInCells;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        protected static propertyCellWidth: string;
        get cellWidth(): number;
        set cellWidth(value: number);
        protected static propertyCellHeight: string;
        get cellHeight(): number;
        set cellHeight(value: number);
        protected static propertyHorSpacing: string;
        get horSpacing(): number;
        set horSpacing(value: number);
        protected static propertyVertSpacing: string;
        get vertSpacing(): number;
        set vertSpacing(value: number);
        get wordWrap(): boolean;
        set wordWrap(value: boolean);
        get rightToLeft(): boolean;
        set rightToLeft(value: boolean);
        protected static propertyContinuousText: string;
        get continuousText(): boolean;
        set continuousText(value: boolean);
        getActualSize(): SizeD;
        static splitByCells(masterTextInCells: StiTextInCells, renderedComponent: StiComponent, textString: string): StiContainer;
        static splitByCells2(masterTextInCells: StiTextInCells, renderedComponent: StiComponent, textString: string, measure: boolean): StiContainer;
        static replaceContainerWithContentCells(comp: StiComponent, cont: StiContainer): void;
        createNew(): StiComponent;
        constructor(rect?: RectangleD, text?: string);
    }
}
declare namespace Stimulsoft.Report.Components {
    class StiTextInCellsHelper {
        static trimEndWhiteSpace(inputString: string): string;
    }
}
declare namespace Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiCap = Stimulsoft.Base.Drawing.StiCap;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiVerticalLinePrimitive extends StiCrossLinePrimitive implements IStiBorder, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean): any;
        private _border;
        get border(): StiBorder;
        set border(value: StiBorder);
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        private _startCap;
        get startCap(): StiCap;
        set startCap(value: StiCap);
        private _endCap;
        get endCap(): StiCap;
        set endCap(value: StiCap);
        get width(): number;
        set width(value: number);
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Components.Table {
    let IStiTableComponent: System.Interface<IStiTableComponent>;
    interface IStiTableComponent {
    }
}
declare namespace Stimulsoft.Report.Components.Table {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiTableCell extends StiText implements IStiTableCell, IStiTableComponent, IStiJsonReportObject {
        private static ImplementsStiTableCell;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private loadJoinCellsFromXml;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        clone(cloneProperties: boolean): StiTableCell;
        get locked(): boolean;
        get linked(): boolean;
        get canGrow(): boolean;
        set canGrow(value: boolean);
        get autoWidth(): boolean;
        private _cellDockStyle;
        get cellDockStyle(): StiDockStyle;
        set cellDockStyle(value: StiDockStyle);
        private _parentJoinCell;
        get parentJoinCell(): StiComponent;
        set parentJoinCell(value: StiComponent);
        _joinCells: number[];
        get joinCells(): number[];
        set joinCells(value: number[]);
        _parentJoin: number;
        get parentJoin(): number;
        set parentJoin(value: number);
        _join: boolean;
        get join(): boolean;
        set join(value: boolean);
        private _id;
        get id(): number;
        set id(value: number);
        private _joinWidth;
        get joinWidth(): number;
        set joinWidth(value: number);
        private _joinHeight;
        get joinHeight(): number;
        set joinHeight(value: number);
        get merged(): boolean;
        get changeTopPosition(): boolean;
        get changeLeftPosition(): boolean;
        get changeRightPosition(): boolean;
        private _tableTag;
        get tableTag(): any;
        set tableTag(value: any);
        private _cellType;
        get cellType(): StiTablceCellType;
        set cellType(value: StiTablceCellType);
        private _fixedWidth;
        get fixedWidth(): boolean;
        set fixedWidth(value: boolean);
        private _column;
        get column(): number;
        set column(value: number);
        getJoinComponentByGuid(id: number): StiComponent;
        getJoinComponentByIndex(index: number): StiComponent;
        containsGuid(id: number): boolean;
        private createJoin;
        private deleteJoin;
        private getNewClientRectangle;
        setJoinSize(): void;
        getRealHeightAfterInsertRows(): number;
        getRealHeight(): number;
        getRealTop(): number;
        getRealWidth(): number;
        getRealLeft(): number;
        createNew(): StiComponent;
    }
}
declare namespace Stimulsoft.Report.Components.Table {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiTableCellCheckBox extends StiCheckBox implements IStiTableCell, IStiTableComponent, IStiJsonReportObject {
        private static ImplementsStiTableCellCheckBox;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private loadJoinCellsFromXml;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        clone(cloneProperties: boolean): StiTableCellCheckBox;
        get locked(): boolean;
        get linked(): boolean;
        get canShrink(): boolean;
        set canShrink(value: boolean);
        get canGrow(): boolean;
        set canGrow(value: boolean);
        private _cellDockStyle;
        get cellDockStyle(): StiDockStyle;
        set cellDockStyle(value: StiDockStyle);
        private _parentJoinCell;
        get parentJoinCell(): StiComponent;
        set parentJoinCell(value: StiComponent);
        _joinCells: number[];
        get joinCells(): number[];
        set joinCells(value: number[]);
        _parentJoin: number;
        get parentJoin(): number;
        set parentJoin(value: number);
        _join: boolean;
        get join(): boolean;
        set join(value: boolean);
        private _id;
        get id(): number;
        set id(value: number);
        private _joinWidth;
        get joinWidth(): number;
        set joinWidth(value: number);
        private _joinHeight;
        get joinHeight(): number;
        set joinHeight(value: number);
        get merged(): boolean;
        get changeTopPosition(): boolean;
        get changeLeftPosition(): boolean;
        get changeRightPosition(): boolean;
        private _tableTag;
        get tableTag(): any;
        set tableTag(value: any);
        private _cellType;
        get cellType(): StiTablceCellType;
        set cellType(value: StiTablceCellType);
        private _fixedWidth;
        get fixedWidth(): boolean;
        set fixedWidth(value: boolean);
        private _column;
        get column(): number;
        set column(value: number);
        getJoinComponentByGuid(id: number): StiComponent;
        getJoinComponentByIndex(index: number): StiComponent;
        containsGuid(id: number): boolean;
        private createJoin;
        private deleteJoin;
        private getNewClientRectangle;
        setJoinSize(): void;
        getRealHeightAfterInsertRows(): number;
        getRealHeight(): number;
        getRealTop(): number;
        getRealWidth(): number;
        getRealLeft(): number;
        createNew(): StiComponent;
    }
}
declare namespace Stimulsoft.Report.Components.Table {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiTableCellRichText extends StiRichText implements IStiTableCell, IStiTableComponent, IStiJsonReportObject {
        private static ImplementsStiTableCellRichText;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private loadJoinCellsFromXml;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        clone(cloneProperties: boolean): StiTableCellRichText;
        get locked(): boolean;
        get linked(): boolean;
        get canShrink(): boolean;
        set canShrink(value: boolean);
        get canGrow(): boolean;
        set canGrow(value: boolean);
        private _cellDockStyle;
        get cellDockStyle(): StiDockStyle;
        set cellDockStyle(value: StiDockStyle);
        private _parentJoinCell;
        get parentJoinCell(): StiComponent;
        set parentJoinCell(value: StiComponent);
        _joinCells: number[];
        get joinCells(): number[];
        set joinCells(value: number[]);
        _parentJoin: number;
        get parentJoin(): number;
        set parentJoin(value: number);
        _join: boolean;
        get join(): boolean;
        set join(value: boolean);
        private _id;
        get id(): number;
        set id(value: number);
        private _joinWidth;
        get joinWidth(): number;
        set joinWidth(value: number);
        private _joinHeight;
        get joinHeight(): number;
        set joinHeight(value: number);
        get merged(): boolean;
        get changeTopPosition(): boolean;
        get changeLeftPosition(): boolean;
        get changeRightPosition(): boolean;
        private _tableTag;
        get tableTag(): any;
        set tableTag(value: any);
        private _cellType;
        get cellType(): StiTablceCellType;
        set cellType(value: StiTablceCellType);
        private _fixedWidth;
        get fixedWidth(): boolean;
        set fixedWidth(value: boolean);
        private _column;
        get column(): number;
        set column(value: number);
        getJoinComponentByGuid(id: number): StiComponent;
        getJoinComponentByIndex(index: number): StiComponent;
        containsGuid(id: number): boolean;
        private createJoin;
        private deleteJoin;
        private getNewClientRectangle;
        setJoinSize(): void;
        getRealHeightAfterInsertRows(): number;
        getRealHeight(): number;
        getRealTop(): number;
        getRealWidth(): number;
        getRealLeft(): number;
        createNew(): StiComponent;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Components.TextFormats {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiBooleanFormatService extends StiFormatService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        private bits;
        get falseValue(): string;
        set falseValue(value: string);
        get trueValue(): string;
        set trueValue(value: string);
        get falseDisplay(): string;
        set falseDisplay(value: string);
        get trueDisplay(): string;
        set trueDisplay(value: string);
        get nullDisplay(): string;
        set nullDisplay(value: string);
        get sample(): any;
        equals(obj: any): boolean;
        format(arg: any): string;
        format2(stringFormat: string, arg: any): string;
        createNew(): StiFormatService;
        constructor(falseValue?: string, trueValue?: string, falseDisplay?: string, trueDisplay?: string, nullDisplay?: string);
    }
}
declare namespace Stimulsoft.Report.Components.TextFormats {
    class StiNegativeColorChecker {
        static isNegativeInRed(format: StiFormatService): boolean;
    }
}
declare namespace Stimulsoft.Report.CrossTab {
    enum StiCrossHorAlignment {
        Left = 0,
        Center = 1,
        Right = 2,
        None = 3,
        Width = 4
    }
}
declare namespace Stimulsoft.Report.CrossTab {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiEnumeratorType = Stimulsoft.Report.CrossTab.Core.StiEnumeratorType;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiCrossColumn extends StiCrossHeader implements IStiJsonReportObject {
        private static ImplementsStiCrossColumn;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        get localizedName(): string;
        private _enumeratorType;
        get enumeratorType(): StiEnumeratorType;
        set enumeratorType(value: StiEnumeratorType);
        private _enumeratorSeparator;
        get enumeratorSeparator(): string;
        set enumeratorSeparator(value: string);
        createNew(): StiComponent;
    }
}
declare namespace Stimulsoft.Report.CrossTab {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiCrossTotal extends StiCrossField {
        private static ImplementsStiCrossTotal;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        get cellText(): string;
        get componentId(): StiComponentId;
        createNew(): StiComponent;
        constructor();
    }
}
declare namespace Stimulsoft.Report.CrossTab {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCrossColumnTotal extends StiCrossTotal {
        get componentId(): StiComponentId;
        get localizedName(): string;
        createNew(): StiComponent;
        constructor();
    }
}
declare namespace Stimulsoft.Report.CrossTab {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiEnumeratorType = Stimulsoft.Report.CrossTab.Core.StiEnumeratorType;
    class StiCrossRow extends StiCrossHeader implements IStiJsonReportObject {
        private static ImplementsStiCrossRow;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        get localizedName(): string;
        private _enumeratorType;
        get enumeratorType(): StiEnumeratorType;
        set enumeratorType(value: StiEnumeratorType);
        private _enumeratorSeparator;
        get enumeratorSeparator(): string;
        set enumeratorSeparator(value: string);
        getCrossRowTitle(): StiCrossTitle;
        getCrossRowTotal(): StiCrossRowTotal;
        createNew(): StiComponent;
    }
}
declare namespace Stimulsoft.Report.CrossTab {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCrossRowTotal extends StiCrossTotal {
        get componentId(): StiComponentId;
        get localizedName(): string;
        createNew(): StiComponent;
        constructor();
    }
}
declare namespace Stimulsoft.Report.CrossTab {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiSummaryType = Stimulsoft.Report.CrossTab.Core.StiSummaryType;
    import StiSummaryValues = Stimulsoft.Report.CrossTab.Core.StiSummaryValues;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCrossSummary extends StiCrossCell implements IStiJsonReportObject {
        private static ImplementsStiCrossSummary;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        clone(cloneProperties: boolean): StiCrossSummary;
        protected get defaultHorAlignment(): StiTextHorAlignment;
        private _aspectRatio;
        get aspectRatio(): boolean;
        set aspectRatio(value: boolean);
        private _stretch;
        get stretch(): boolean;
        set stretch(value: boolean);
        private _imageHorAlignment;
        get imageHorAlignment(): StiHorAlignment;
        set imageHorAlignment(value: StiHorAlignment);
        private _imageVertAlignment;
        get imageVertAlignment(): StiVertAlignment;
        set imageVertAlignment(value: StiVertAlignment);
        private _crossColumnValue;
        get crossColumnValue(): string;
        set crossColumnValue(value: string);
        private _crossRowValue;
        get crossRowValue(): string;
        set crossRowValue(value: string);
        private _indexOfSelectValue;
        get indexOfSelectValue(): number;
        set indexOfSelectValue(value: number);
        get cellText(): string;
        private _summary;
        get summary(): StiSummaryType;
        set summary(value: StiSummaryType);
        private _summaryValues;
        get summaryValues(): StiSummaryValues;
        set summaryValues(value: StiSummaryValues);
        private _useStyleOfSummaryInRowTotal;
        get useStyleOfSummaryInRowTotal(): boolean;
        set useStyleOfSummaryInRowTotal(value: boolean);
        private _useStyleOfSummaryInColumnTotal;
        get useStyleOfSummaryInColumnTotal(): boolean;
        set useStyleOfSummaryInColumnTotal(value: boolean);
        get localizedName(): string;
        private _showPercents;
        get showPercents(): boolean;
        set showPercents(value: boolean);
        createNew(): StiComponent;
        constructor();
    }
}
declare namespace Stimulsoft.Report.CrossTab {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCrossSummaryHeader extends StiCrossField {
        get cellText(): string;
        get localizedName(): string;
        get componentId(): StiComponentId;
        createNew(): StiComponent;
    }
}
declare namespace Stimulsoft.Report.CrossTab.Core {
    import Point = Stimulsoft.System.Drawing.Point;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiGrid {
        private get gridSize();
        report: StiReport;
        fields: Hashtable<StiCrossField, Point>;
        designTime: boolean;
        widths: number[];
        heights: number[];
        coordX: number[];
        coordY: number[];
        cells: StiCell[][];
        get rowCount(): number;
        set rowCount(value: number);
        get colCount(): number;
        set colCount(value: number);
        maxWidth: number;
        maxHeight: number;
        setTextOfCell(x: number, y: number, value: string): void;
        private align;
        private getCellTotalWidth;
        private getCellTotalHeight;
        doAutoSize(): void;
        private getFieldWidth;
        private getFieldHeight;
        setCell(cellX: number, cellY: number, cellWidth: number, cellHeight: number, text: any, value: any, field: StiCrossField, isNumeric: boolean, hyperlink: any, toolTip: any, tag: any, drillDownParameters: any, level?: number, parentGuid?: string, guid?: string, type?: StiCellType): StiCell;
        private cellExists;
        setCellField(cellX: number, cellY: number, field: StiCrossField): void;
        init(colCount: number, rowCount: number): void;
    }
}
declare namespace Stimulsoft.Report.CrossTab.Core {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiCross extends StiGrid {
        crossTab: StiCrossTab;
        private strNull;
        static emptyField: string;
        emptyField: string;
        private oneCellSize;
        private oneCellWidth;
        private oneCellHeight;
        private summaryDirection;
        private colsHeaderHeight;
        private rowsHeaderWidth;
        private widthCorrection;
        private heightCorrection;
        private colsWidth;
        private rowsHeight;
        private columnsCell;
        private rowsCell;
        private invokeEvents2;
        private invokeEvents;
        private addRowTotal;
        private addColTotal;
        private sortRows;
        private sortCols;
        private createRowTotals;
        private createRowTotals2;
        private createColTotals;
        private createColTotals2;
        private getDataFromDataRow;
        private getValueFromDataRow;
        private allowTotal;
        private getRow;
        private getColumn;
        private calculateTopN;
        private processTopNRows;
        private fillOtherRows;
        private processTopNColumns;
        private fillOtherColumns;
        private getSumFiledIndex;
        private calculateDataTable;
        private calculateDataRow;
        private copyRows;
        private copyCols;
        private convertToDecimal;
        private isAllowConvertToDecimal;
        private getSummary2;
        private getSummaryResult;
        private copySummaries;
        private copySummary;
        private getSummary;
        private isHideZeros;
        private isDateTime;
        private static convertValueToString;
        private setCellValue;
        private static checkNegativeColor;
        private getColumnTotalCell;
        private getRowTotalCell;
        private getRowsArray;
        private getRowsArray2;
        private getColsArray;
        private getColsArray2;
        private getRowsHeaderWidth;
        private getRowsHeaderWidth2;
        private getColsHeaderHeight;
        private getColsHeaderHeight2;
        private getRowsHeight;
        private getColsWidth;
        private enumerateRows;
        private enumerateColumns;
        private checkSeparators;
        create(table: DataTable, report: StiReport, direction: StiSummaryDirection, emptyValue: string): void;
        clear(): boolean;
        getCorrectedColumnsHeaderHeight(): number;
        private get isSummaryPresent();
        private get isRowTitlePresent();
        private get isTopLinePresent();
        get isTopCrossTitleVisible(): boolean;
        get isLeftCrossTitleVisible(): boolean;
        get isCrossTitleEnabled(): boolean;
        get isCrossTitlePrintOnAllPages(): boolean;
        private get isShowSummarySubHeaders();
        private get isSummarySubHeadersPresent();
        private get isLeftTopLinePresent();
        private get isRightTopLinePresent();
        get isRowsEmpty(): boolean;
        get isColsEmpty(): boolean;
        get isSummariesEmpty(): boolean;
        rows: StiRowCollection;
        cols: StiColumnCollection;
        colTitleFields: StiComponentsCollection;
        rowTitleFields: StiComponentsCollection;
        private _rowFields;
        get rowFields(): StiComponentsCollection;
        set rowFields(value: StiComponentsCollection);
        private _colFields;
        get colFields(): StiComponentsCollection;
        set colFields(value: StiComponentsCollection);
        private _sumFields;
        get sumFields(): StiComponentsCollection;
        set sumFields(value: StiComponentsCollection);
        private _sumHeaderFields;
        get sumHeaderFields(): StiComponentsCollection;
        set sumHeaderFields(value: StiComponentsCollection);
        summaryContainer: StiSummaryContainer;
        leftCrossTitle: StiCrossTitle;
        rightCrossTitle: StiCrossTitle;
        summaryCrossTitle: StiCrossTitle;
    }
}
declare namespace Stimulsoft.Report.CrossTab.Core {
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiCell {
        clone(): StiCell;
        size: SizeD;
        isChangeWidthForRightToLeft: boolean;
        isNumeric: boolean;
        isNegativeColor: boolean;
        isImage: boolean;
        field: StiCrossField;
        private _text;
        get text(): string;
        set text(value: string);
        hyperlinkValue: any;
        toolTipValue: any;
        tagValue: any;
        parentCell: StiCell;
        value: any;
        width: number;
        height: number;
        summaryIndex: number;
        level: number;
        parentGuid: string;
        guid: string;
        isCrossSummary: boolean;
        keepMergedCellsTogether: boolean;
        cellType: StiCellType;
        private _drillDownParameters;
        get drillDownParameters(): any;
        set drillDownParameters(value: any);
        constructor();
    }
}
declare namespace Stimulsoft.Report.CrossTab {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiCrossTabHelper {
        static getCellRect(masterCrossTab: StiCrossTab, colIndex: number, rowIndex: number): RectangleD;
        static getCellsRect(masterCrossTab: StiCrossTab, startCol: number, startRow: number, endCol: number, endRow: number): SizeD;
        static renderCells(masterCrossTab: StiCrossTab, outContainer: StiContainer, startCol: number, startRow: number, endCol: number, endRow: number, rect: RectangleD): void;
        static createCrossForCrossTabDataSource(masterCrossTab: StiCrossTab): DataTable;
        static buildCrossForCrossTabDataSource(masterCrossTab: StiCrossTab, designTime: boolean): DataTable;
        static buildCross(masterCrossTab: StiCrossTab, designTime: boolean): void;
        static getEndCol(masterCrossTab: StiCrossTab, startCol: number, rect: RectangleD): number;
        static getEndRow(masterCrossTab: StiCrossTab, startRow: number, rect: RectangleD): number;
        static getPageSegmentsRequired(masterCrossTab: StiCrossTab): number;
        static checkMergedRowCells(masterCrossTab: StiCrossTab, startRow: number, endRow: number, startCol: number, endCol: number): number;
        static isColFieldsEmpty(masterCrossTab: StiCrossTab): boolean;
        static isRowFieldsEmpty(masterCrossTab: StiCrossTab): boolean;
        static createCross(masterCrossTab: StiCrossTab): void;
        static isCrossTabRendering: boolean;
        static makeRightToLeft(masterCrossTab: StiCrossTab): void;
        static calculateMaxAndMin(outContainer: StiContainer, REFmaxLeft: any, REFmaxRight: any, startIndex: number): void;
        static makeHorAlignmentByWidth(outContainer: StiContainer, startIndex: number): void;
        static clearCross(masterCrossTab: StiCrossTab): void;
    }
}
declare namespace Stimulsoft.Report.CrossTab {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    import StiCross = Stimulsoft.Report.CrossTab.Core.StiCross;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiCrossTabInfo extends StiComponentInfo {
        defaultWidth: number;
        defaultHeight: number;
        startRow: number;
        startCol: number;
        hidedCells: Hashtable;
        cross: StiCross;
        renderRect: RectangleD;
        finishRender: boolean;
    }
}
declare namespace Stimulsoft.Report.CrossTab {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCrossTabParams {
        private _startRow;
        get startRow(): number;
        set startRow(value: number);
        private _startColumn;
        get startColumn(): number;
        set startColumn(value: number);
        private _renderingIsFinished;
        get renderingIsFinished(): boolean;
        set renderingIsFinished(value: boolean);
        private _allowRendering;
        get allowRendering(): boolean;
        set allowRendering(value: boolean);
        private _destinationRectangle;
        get destinationRectangle(): RectangleD;
        set destinationRectangle(value: RectangleD);
        private _destinationContainer;
        get destinationContainer(): StiContainer;
        set destinationContainer(value: StiContainer);
        shiftX: number;
    }
}
declare namespace Stimulsoft.Report.CrossTab {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiCrossTitle extends StiCrossField implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        get localizedName(): string;
        private _printOnAllPages;
        get printOnAllPages(): boolean;
        set printOnAllPages(value: boolean);
        private _typeOfComponent;
        get typeOfComponent(): string;
        set typeOfComponent(value: string);
        get cellText(): string;
        createNew(): StiComponent;
        constructor();
    }
}
declare namespace Stimulsoft.Report.CrossTab.Core {
    class StiColumn {
        hyperlinkValue: any;
        tagValue: any;
        toolTipValue: any;
        drillDownParameters: any;
        isTotal: boolean;
        level: number;
        cols: StiColumnCollection;
        value: any;
        displayValue: any;
        othersText: string;
        parentCollection: StiColumnCollection;
        constructor(value: any, displayValue: any);
    }
}
declare namespace Stimulsoft.Report.CrossTab.Core {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiColumnCollection extends CollectionBase<StiColumn> {
        private directionFactor;
        private compare;
        private sortType;
        private items;
        add2(value: any, displayValue: any): void;
        add(col: StiColumn): void;
        sort(direction: StiSortDirection, sortType: StiSortType): void;
        clear(): void;
        getByValue(value: any): StiColumn;
    }
}
declare namespace Stimulsoft.Report.CrossTab.Core {
    class StiRow {
        hyperlinkValue: any;
        tagValue: any;
        toolTipValue: any;
        drillDownParameters: any;
        isTotal: boolean;
        level: number;
        rows: StiRowCollection;
        value: any;
        displayValue: any;
        othersText: string;
        parentCollection: StiRowCollection;
        constructor(value: any, displayValue: any);
    }
}
declare namespace Stimulsoft.Report.CrossTab.Core {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiRowCollection extends CollectionBase<StiRow> {
        private directionFactor;
        private compare;
        private sortType;
        private items;
        add2(value: any, displayValue: any): void;
        add(row: StiRow): void;
        clear(): void;
        sort(direction: StiSortDirection, sortType: StiSortType): void;
        getByValue(value: any): StiRow;
    }
}
declare namespace Stimulsoft.Report.CrossTab.Core {
    class StiSummary {
        sums: any[][];
        hyperlinkValues: any[];
        tagValues: any[];
        toolTipValues: any[];
        drillDownParameters: any[];
        constructor(level: number);
    }
}
declare namespace Stimulsoft.Report.CrossTab.Core {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiSummaryContainer {
        private level;
        private dataCol;
        getSummary(col: StiColumn, row: StiRow, create?: boolean): StiSummary;
        getDataCol(): Hashtable;
        constructor(level: number);
    }
}
declare namespace Stimulsoft.Report.CrossTab {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiGetCrossValueEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.CrossTab {
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiGetCrossValueEventArgs extends EventArgs {
        value: any;
    }
}
declare namespace Stimulsoft.Report.CrossTab {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiGetDisplayCrossValueEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.CrossTab {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiProcessCellEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.CrossTab {
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiCell = Stimulsoft.Report.CrossTab.Core.StiCell;
    class StiProcessCellEventArgs extends EventArgs {
        cell: StiCell;
        column: number;
        row: number;
        value: number;
        text: string;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    enum StiElementStyleIdent {
        Auto = 1,
        Blue = 2,
        Orange = 3,
        Green = 4,
        Turquoise = 5,
        SlateGray = 6,
        DarkBlue = 7,
        DarkGray = 8,
        DarkGreen = 9,
        DarkTurquoise = 10,
        Silver = 11,
        AliceBlue = 12,
        Custom = 13
    }
    enum StiItemSelectionMode {
        One = 0,
        Multi = 1
    }
    enum StiDateSelectionMode {
        Single = 0,
        Range = 1,
        AutoRange = 2
    }
    enum StiInitialDateRangeSelectionSource {
        Selection = 0,
        Variable = 1
    }
    enum StiInitialDateRangeSelection {
        DayTomorrow = 0,
        DayToday = 1,
        DayYesterday = 2,
        WeekNext = 3,
        WeekCurrent = 4,
        WeekPrevious = 5,
        MonthNext = 6,
        MonthCurrent = 7,
        MonthPrevious = 8,
        QuarterNext = 9,
        QuarterCurrent = 10,
        QuarterPrevious = 11,
        QuarterFirst = 12,
        QuarterSecond = 13,
        QuarterThird = 14,
        QuarterFourth = 15,
        YearNext = 16,
        YearCurrent = 17,
        YearPrevious = 18,
        Last7Days = 19,
        Last14Days = 20,
        Last30Days = 21,
        DateToWeek = 22,
        DateToMonth = 23,
        DateToQuarter = 24,
        DateToYear = 25
    }
    enum StiProgressElementMode {
        Pie = 0,
        Circle = 1,
        DataBars = 2
    }
    enum StiDateCondition {
        EqualTo = 0,
        NotEqualTo = 1,
        GreaterThan = 2,
        GreaterThanOrEqualTo = 3,
        LessThan = 4,
        LessThanOrEqualTo = 5
    }
    enum StiTableSizeMode {
        AutoSize = 0,
        Fit = 1
    }
    enum StiChartLabelsPosition {
        None = 0,
        Center = 1,
        InsideBase = 2,
        InsideEnd = 3,
        Left = 4,
        Outside = 5,
        OutsideBase = 6,
        OutsideEnd = 7,
        OutsideLeft = 8,
        OutsideRight = 9,
        Right = 10,
        TwoColumns = 11,
        Value = 12,
        Total = 13
    }
    enum StiInteractionIdent {
        Chart = 1,
        Gauge = 2,
        Image = 3,
        Indicator = 4,
        OnlineMap = 5,
        Page = 6,
        PivotTable = 7,
        Progress = 8,
        RegionMap = 9,
        Table = 10,
        TableColumn = 11,
        Text = 12
    }
    enum StiAvailableInteractionOnHover {
        ShowToolTip = 1,
        ShowHyperlink = 2,
        None = 0,
        All = 3
    }
    enum StiAvailableInteractionOnClick {
        ShowDashboard = 1,
        OpenHyperlink = 2,
        ApplyFilter = 4,
        DrillDown = 8,
        None = 0,
        All = 15
    }
    enum StiAvailableInteractionOnDataManipulation {
        AllowSorting = 1,
        AllowFiltering = 2,
        AllowDrillDown = 4,
        All = 7,
        None = 0
    }
    enum StiInteractionOnHover {
        None = 0,
        ShowToolTip = 1,
        ShowHyperlink = 2
    }
    enum StiInteractionOnClick {
        None = 0,
        ShowDashboard = 1,
        OpenHyperlink = 2,
        ApplyFilter = 3,
        DrillDown = 4
    }
    enum StiInteractionOpenHyperlinkDestination {
        NewTab = 0,
        CurrectTab = 1
    }
    enum StiElementMeterAction {
        None = 0,
        Rename = 1,
        Delete = 2,
        ClearAll = 3
    }
    enum StiOnlineMapLocationType {
        Auto = 0,
        AdminDivision1 = 1,
        AdminDivision2 = 2,
        CountryRegion = 3,
        Neighborhood = 4,
        PopulatedPlace = 5,
        Postcode1 = 6,
        Postcode2 = 7,
        Postcode3 = 8,
        Postcode4 = 9
    }
    enum StiOnlineMapLocationColorType {
        Single = 0,
        ColorEach = 1,
        Group = 2,
        Value = 3
    }
    enum StiOnlineMapValueViewMode {
        Bubble = 0,
        Value = 1,
        Icon = 2,
        Chart = 3
    }
    enum StiOnlineMapCulture {
        ar_SA = 0,
        eu = 1,
        bg = 2,
        bg_BG = 3,
        ca = 4,
        ku_Arab = 5,
        zh_CN = 6,
        zh_HK = 7,
        zh_Hans = 8,
        zh_TW = 9,
        zh_Hant = 10,
        cs = 11,
        cs_CZ = 12,
        da = 13,
        da_DK = 14,
        nl_BE = 15,
        nl = 16,
        nl_NL = 17,
        en_AU = 18,
        en_CA = 19,
        en_IN = 20,
        en_GB = 21,
        en_US = 22,
        fi = 23,
        fi_FI = 24,
        fr_BE = 25,
        fr_CA = 26,
        fr = 27,
        fr_FR = 28,
        fr_CH = 29,
        gl = 30,
        de = 31,
        de_DE = 32,
        el = 33,
        he = 34,
        he_IL = 35,
        hi = 36,
        hi_IN = 37,
        hu = 38,
        hu_HU = 39,
        is_IS = 40,
        it = 41,
        it_IT = 42,
        ja = 43,
        ja_JP = 44,
        ko = 45,
        Ko_KR = 46,
        ky_Cyrl = 47,
        lv = 48,
        lv_LV = 49,
        lt = 50,
        lt_LT = 51,
        nb = 52,
        nb_NO = 53,
        nn = 54,
        pl = 55,
        pl_PL = 56,
        pt_BR = 57,
        pt_P = 58,
        ru = 59,
        ru_RU = 60,
        es_MX = 61,
        es = 62,
        es_ES = 63,
        es_US = 64,
        sv = 65,
        sv_SE = 66,
        tt_Cyrl = 67,
        th = 68,
        th_TH = 69,
        tr = 70,
        tr_TR = 71,
        uk = 72,
        uk_UA = 73,
        ug_Arab = 74,
        ca_ES_valencia = 75,
        vi = 76,
        vi_VN = 77
    }
    enum StiIconAlignment {
        None = 0,
        Left = 1,
        Right = 2,
        Top = 3,
        Bottom = 4
    }
    enum StiIndicatorFieldCondition {
        Value = 0,
        Series = 1,
        Target = 2,
        Variation = 3
    }
    enum StiProgressFieldCondition {
        Value = 0,
        Series = 1,
        Target = 2,
        Percentage = 3
    }
    enum StiProgressConditionPermissions {
        None = 0,
        Font = 1,
        FontSize = 2,
        FontStyleBold = 4,
        FontStyleItalic = 8,
        FontStyleUnderline = 16,
        FontStyleStrikeout = 32,
        TextColor = 64,
        Color = 128,
        TrackColor = 256,
        All = 511
    }
    enum StiIndicatorConditionPermissions {
        None = 0,
        Font = 1,
        FontSize = 2,
        FontStyleBold = 4,
        FontStyleItalic = 8,
        FontStyleUnderline = 16,
        FontStyleStrikeout = 32,
        TextColor = 64,
        BackColor = 128,
        Borders = 256,
        Icon = 512,
        TargetIcon = 1024,
        All = 2047
    }
    enum StiTableConditionPermissions {
        None = 0,
        Font = 1,
        FontSize = 2,
        FontStyleBold = 4,
        FontStyleItalic = 8,
        FontStyleUnderline = 16,
        FontStyleStrikeout = 32,
        ForeColor = 64,
        BackColor = 128,
        All = 255
    }
    enum StiTargetMode {
        Percentage = 0,
        Variation = 1
    }
    enum StiChartTrendLineType {
        None = 0,
        Exponential = 1,
        Linear = 2,
        Logarithmic = 3
    }
    enum StiChartSeriesType {
        ClusteredColumn = 1,
        StackedColumn = 2,
        FullStackedColumn = 3,
        Pareto = 4,
        Histogram = 5,
        Line = 6,
        StackedLine = 7,
        FullStackedLine = 8,
        Spline = 9,
        StackedSpline = 10,
        FullStackedSpline = 11,
        SteppedLine = 12,
        Area = 13,
        StackedArea = 14,
        FullStackedArea = 15,
        SplineArea = 16,
        StackedSplineArea = 17,
        FullStackedSplineArea = 18,
        SteppedArea = 19,
        Range = 20,
        SplineRange = 21,
        SteppedRange = 22,
        RangeBar = 23,
        ClusteredBar = 24,
        StackedBar = 25,
        FullStackedBar = 26,
        Scatter = 27,
        ScatterLine = 28,
        ScatterSpline = 29,
        Pie = 30,
        RadarPoint = 31,
        RadarLine = 32,
        RadarArea = 33,
        Funnel = 34,
        FunnelWeightedSlices = 35,
        Candlestick = 36,
        Stock = 37,
        Treemap = 38,
        Gantt = 39,
        Doughnut = 40,
        Bubble = 41,
        Pictorial = 42,
        Sunburst = 43,
        Waterfall = 44,
        BoxAndWhisker = 45
    }
    enum StiEmptyCellsAs {
        Gap = 0,
        Zero = 1,
        ConnectPointsWithLine = 2
    }
    enum StiFontSizeMode {
        Auto = 0,
        Value = 1,
        Target = 2
    }
    enum StiLabelPlacement {
        Outside = 0,
        Inside = 1
    }
    enum StiItemOrientation {
        Vertical = 0,
        Horizontal = 1
    }
    enum StiDashboardContentAlignment {
        Left = 0,
        Center = 1,
        Right = 2,
        StretchXY = 3,
        StretchX = 4
    }
    enum StiIndicatorIconMode {
        Auto = 1,
        Custom = 2
    }
    enum StiIndicatorIconRangeMode {
        Percentage = 1,
        Value = 2
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    let IStiAllowUserColumnSelectionDashboardInteraction: System.Interface<IStiAllowUserColumnSelectionDashboardInteraction>;
    interface IStiAllowUserColumnSelectionDashboardInteraction {
        allowUserColumnSelection: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    let IStiAllowUserDrillDownDashboardInteraction: System.Interface<IStiAllowUserDrillDownDashboardInteraction>;
    interface IStiAllowUserDrillDownDashboardInteraction {
        allowUserDrillDown: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    let IStiAllowUserFilteringDashboardInteraction: System.Interface<IStiAllowUserFilteringDashboardInteraction>;
    interface IStiAllowUserFilteringDashboardInteraction {
        allowUserFiltering: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    let IStiAllowUserSortingDashboardInteraction: System.Interface<IStiAllowUserSortingDashboardInteraction>;
    interface IStiAllowUserSortingDashboardInteraction {
        allowUserSorting: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    let IStiAltProperties: System.Interface<IStiAltProperties>;
    let ImplementsIStiAltProperties: any[];
    interface IStiAltProperties {
        altTitleVisible: boolean;
        altClientRectangle: RectangleD;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    let IStiChartArea: System.Interface<IStiChartArea>;
    let ImplementsIStiChartArea: any[];
    interface IStiChartArea {
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiChartConstantLines: System.Interface<IStiChartConstantLines>;
    let ImplementsIStiChartConstantLines: any[];
    interface IStiChartConstantLines {
        text: string;
        lineStyle: StiPenStyle;
        lineColor: Color;
        axisValue: string;
        lineWidth: number;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IAsIs = Stimulsoft.System.IAsIs;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import IStiReportComponent = Stimulsoft.Base.IStiReportComponent;
    import IStiQueryObject = Stimulsoft.Data.Engine.IStiQueryObject;
    let IStiElement: System.Interface<IStiElement>;
    let ImplementsIStiElement: any[];
    interface IStiElement extends IStiReportComponent, IStiQueryObject, IAsIs {
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        getNestedPages(): List<StiPage>;
        key: string;
        report: StiReport;
        page: StiPage;
        name: string;
        zoom: number;
        isDefined: boolean;
        isDesigning: boolean;
        isEnabled: boolean;
        isQuerable: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    let IStiGroupElement: System.Interface<IStiGroupElement>;
    let ImplementsIStiGroupElement: any[];
    interface IStiGroupElement {
        group: string;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    let IStiDashboardElementStyle: System.Interface<IStiDashboardElementStyle>;
    let ImplementsIStiDashboardElementStyle: any[];
    interface IStiDashboardElementStyle {
        style: StiElementStyleIdent;
        customStyleName: string;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    let IStiConvertibleElement: System.Interface<IStiConvertibleElement>;
    let ImplementsIStiConvertibleElement: any[];
    interface IStiConvertibleElement {
        convertFrom(element: IStiElement): any;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiCrossFiltering = Stimulsoft.Data.Engine.IStiCrossFiltering;
    import StiMarkerType = Stimulsoft.Report.Chart.StiMarkerType;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiUserSorts = Stimulsoft.Data.Engine.IStiUserSorts;
    import IStiChartElementCondition = Stimulsoft.Report.Dashboard.IStiChartElementCondition;
    import IStiConvertibleElement = Stimulsoft.Report.Dashboard.IStiConvertibleElement;
    import IStiDataTransformationElement = Stimulsoft.Data.Engine.IStiDataTransformationElement;
    import IStiDataTopN = Stimulsoft.Data.Engine.IStiDataTopN;
    import IStiGroupElement = Stimulsoft.Report.Dashboard.IStiGroupElement;
    import IStiDashboardElementStyle = Stimulsoft.Report.Dashboard.IStiDashboardElementStyle;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiUserFilters = Stimulsoft.Data.Engine.IStiUserFilters;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiChartConditionalField = Stimulsoft.Report.Chart.StiChartConditionalField;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    let IStiChartElement: System.Interface<IStiChartElement>;
    let ImplementsIStiChartElement: any[];
    interface IStiChartElement extends IStiElement, IStiUserFilters, IStiUserSorts, IStiDashboardElementStyle, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiDataTopN, IStiDataTransformationElement, IStiGroupElement, IStiCrossFiltering, IStiDataFilters, IStiConvertibleElement {
        addValue(cell: IStiAppDataCell): any;
        getValue2(cell: IStiAppDataCell): IStiMeter;
        getValue(meter: IStiMeter): IStiMeter;
        getValueByIndex(index: number): IStiMeter;
        fetchAllValues(): List<IStiMeter>;
        insertValue(index: number, meter: IStiMeter): any;
        removeValue(index: number): any;
        removeAllValues(): any;
        createNewValue(): IStiMeter;
        addEndValue(cell: IStiAppDataCell): any;
        getEndValue2(cell: IStiAppDataCell): IStiMeter;
        getEndValue(meter: IStiMeter): IStiMeter;
        getEndValueByIndex(index: number): IStiMeter;
        insertEndValue(index: number, meter: IStiMeter): any;
        removeEndValue(index: number): any;
        removeAllEndValues(): any;
        createNewEndValue(): IStiMeter;
        addCloseValue(cell: IStiAppDataCell): any;
        getCloseValue2(cell: IStiAppDataCell): IStiMeter;
        getCloseValue(meter: IStiMeter): IStiMeter;
        getCloseValueByIndex(index: number): IStiMeter;
        insertCloseValue(index: number, meter: IStiMeter): any;
        removeCloseValue(index: number): any;
        removeAllCloseValues(): any;
        createNewCloseValue(): IStiMeter;
        addLowValue(cell: IStiAppDataCell): any;
        getLowValue2(cell: IStiAppDataCell): IStiMeter;
        getLowValue(meter: IStiMeter): IStiMeter;
        getLowValueByIndex(index: number): IStiMeter;
        insertLowValue(index: number, meter: IStiMeter): any;
        removeLowValue(index: number): any;
        removeAllLowValues(): any;
        createNewLowValue(): IStiMeter;
        addHighalue(cell: IStiAppDataCell): any;
        getHighValue2(cell: IStiAppDataCell): IStiMeter;
        getHighValue(meter: IStiMeter): IStiMeter;
        getHighValueByIndex(index: number): IStiMeter;
        insertHighValue(index: number, meter: IStiMeter): any;
        removeHighValue(index: number): any;
        removeAllHighValues(): any;
        createNewHighValue(): IStiMeter;
        addArgument(cell: IStiAppDataCell): any;
        getArgument2(cell: IStiAppDataCell): IStiMeter;
        getArgument(meter: IStiMeter): IStiMeter;
        getArgumentByIndex(index: number): IStiMeter;
        fetchAllArguments(): List<IStiMeter>;
        insertArgument(index: number, meter: IStiMeter): any;
        removeArgument(index: number): any;
        removeAllArguments(): any;
        createNewArgument(): any;
        addWeight(cell: IStiAppDataCell): any;
        getWeight2(cell: IStiAppDataCell): IStiMeter;
        getWeight(meter: IStiMeter): IStiMeter;
        getWeightByIndex(index: number): IStiMeter;
        insertWeight(index: number, meter: IStiMeter): any;
        removeWeight(index: number): any;
        removeAllWeights(): any;
        createNewWeight(): any;
        addSeries(cell: IStiAppDataCell): any;
        getSeries2(cell: IStiAppDataCell): IStiMeter;
        getSeries(meter: IStiMeter): IStiMeter;
        getSeries3(): IStiMeter;
        insertSeries(meter: IStiMeter): any;
        removeSeries(): any;
        createNewSeries(): any;
        fetchConstantLines(): List<IStiChartConstantLines>;
        addConstantLine(): any;
        removeConstantLine(index: number): any;
        moveConstantLine(fromIndex: number, toIndex: number): any;
        addTrendLines(keyValueMeter: string, type: StiChartTrendLineType, lineColor: Color, lineStyle: StiPenStyle, lineWidth: number): any;
        fetchTrendLines(): List<IStiChartTrendLine>;
        clearTrendLines(): any;
        addChartCondition(keyValueMeter: string, dataType: StiFilterDataType, condition: StiFilterCondition, value: string, color: Color, markerType: StiMarkerType, markerAngle: number, field: StiChartConditionalField, isExpression: boolean): any;
        fetchChartConditions(): List<IStiChartElementCondition>;
        clearChartConditions(): any;
        convertToBubble(): any;
        convertFromBubble(): any;
        checkBrowsableProperties(): any;
        getChartSeriesTypes(seriesTypeStr: string): List<string>;
        getChartSeries(): IStiSeries;
        isAxisAreaChart: boolean;
        isStackedChart: boolean;
        isLinesChart: boolean;
        isBubbleChart: boolean;
        isBarChart: boolean;
        isFinancial: boolean;
        isPieChart: boolean;
        isDoughnutChart: boolean;
        isFunnelChart: boolean;
        isTreemapChart: boolean;
        isParetoChart: boolean;
        isSunburstChart: boolean;
        isFullStackedChart: boolean;
        isWaterfallChart: boolean;
        argumentFormat: StiFormatService;
        valueFormat: StiFormatService;
        colorEach: boolean;
        icon: StiFontIcons;
        roundValues: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiMarkerType = Stimulsoft.Report.Chart.StiMarkerType;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    let IStiChartElementCondition: System.Interface<IStiChartElementCondition>;
    let ImplementsIStiChartElementCondition: any[];
    interface IStiChartElementCondition {
        keyValueMeter: string;
        dataType: StiFilterDataType;
        condition: StiFilterCondition;
        value: string;
        color: Color;
        markerType: StiMarkerType;
        markerAngle: number;
        isExpression: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    let IStiChartLabels: System.Interface<IStiChartLabels>;
    let ImplementsIStiChartLabels: any[];
    interface IStiChartLabels {
        position: StiChartLabelsPosition;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    interface IStiChartTrendLine {
        keyValueMeter: string;
        type: StiChartTrendLineType;
        lineStyle: StiPenStyle;
        lineColor: Color;
        lineWidth: number;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    let IStiItemElement: System.Interface<IStiItemElement>;
    let ImplementsIStiItemElement: any[];
    interface IStiItemElement {
        selectionMode: StiItemSelectionMode;
        showAllValue: boolean;
        showBlanks: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiConvertibleElement = Stimulsoft.Report.Dashboard.IStiConvertibleElement;
    import IStiAppCell = Stimulsoft.Base.IStiAppCell;
    let IStiFilterElement: System.Interface<IStiFilterElement>;
    let ImplementsIStiFilterElement: any[];
    interface IStiFilterElement extends IStiAppCell, IStiConvertibleElement {
        getParentKey(): string;
        setParentKey(key: string): any;
        applyDefaultFilters(): Promise<void>;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import IStiDashboardElementStyle = Stimulsoft.Report.Dashboard.IStiDashboardElementStyle;
    import IStiFilterElement = Stimulsoft.Report.Dashboard.IStiFilterElement;
    import IStiUserFilters = Stimulsoft.Data.Engine.IStiUserFilters;
    import IStiBackColor = Stimulsoft.Report.Components.IStiBackColor;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    let IStiControlElement: System.Interface<IStiControlElement>;
    let ImplementsIStiControlElement: any[];
    interface IStiControlElement extends IStiElement, IStiDashboardElementStyle, IStiUserFilters, IStiFilterElement, IStiFont, IStiForeColor, IStiBackColor, IStiTextFormat {
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiItemElement = Stimulsoft.Report.Dashboard.IStiItemElement;
    import IStiGroupElement = Stimulsoft.Report.Dashboard.IStiGroupElement;
    import IStiControlElement = Stimulsoft.Report.Dashboard.IStiControlElement;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    let IStiComboBoxElement: System.Interface<IStiComboBoxElement>;
    let ImplementsIStiComboBoxElement: any[];
    interface IStiComboBoxElement extends IStiControlElement, IStiItemElement, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiDataFilters {
        addKeyMeter2(cell: IStiAppDataCell): any;
        addKeyMeter(meter: IStiMeter): any;
        getKeyMeter(): IStiMeter;
        removeKeyMeter(): any;
        createNewKeyMeter(): any;
        addNameMeter2(cell: IStiAppDataCell): any;
        addNameMeter(meter: IStiMeter): any;
        getNameMeter(): IStiMeter;
        removeNameMeter(): any;
        createNewNameMeter(): any;
        createNextMeter(cell: IStiAppDataCell): any;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiBackColor = Stimulsoft.Report.Components.IStiBackColor;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    let IStiPanel: System.Interface<IStiPanel>;
    let ImplementsIStiPanel: any[];
    interface IStiPanel extends IStiElement, IStiBackColor {
        getElements(nested: boolean, group: string): List<IStiElement>;
        getMeters(nested?: boolean, group?: string): List<IStiMeter>;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import List = Stimulsoft.System.Collections.List;
    import IStiPanel = Stimulsoft.Report.Dashboard.IStiPanel;
    import IStiDashboardElementStyle = Stimulsoft.Report.Dashboard.IStiDashboardElementStyle;
    import IStiQueryObject = Stimulsoft.Data.Engine.IStiQueryObject;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDashboardViewMode = Stimulsoft.Report.Components.StiDashboardViewMode;
    let IStiDashboard: System.Interface<IStiDashboard>;
    let ImplementsIStiDashboard: any[];
    interface IStiDashboard extends IStiPanel, IStiQueryObject, IStiDashboardElementStyle {
        getUserFilters(element: IStiElement): List<StiDataFilterRule>;
        dashboardViewMode: StiDashboardViewMode;
        getUnplacedElements(): List<IStiElement>;
        switchDashboardViewMode(value: StiDashboardViewMode): any;
        removeMobileSurface(): any;
        deviceWidth: number;
        isMobileSurfacePresent: boolean;
        width: number;
        height: number;
        contentAlignment: StiDashboardContentAlignment;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    let IStiDashboardDrillDownParameter: System.Interface<IStiDashboardDrillDownParameter>;
    let ImplementsIStiDashboardDrillDownParameter: any[];
    interface IStiDashboardDrillDownParameter {
        name: string;
        expression: string;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IAsIs = Stimulsoft.System.IAsIs;
    import List = Stimulsoft.System.Collections.List;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiDefault = Stimulsoft.Base.Design.IStiDefault;
    let IStiDashboardInteraction: System.Interface<IStiDashboardInteraction>;
    let ImplementsIStiDashboardInteraction: (System.Interface<ICloneable> | System.Interface<IStiDefault>)[];
    interface IStiDashboardInteraction extends ICloneable, IStiDefault, IAsIs {
        ident: StiInteractionIdent;
        onHover: StiInteractionOnHover;
        onClick: StiInteractionOnClick;
        hyperlinkDestination: StiInteractionOpenHyperlinkDestination;
        toolTip: string;
        hyperlink: string;
        drillDownPageKey: string;
        getDrillDownParameters(): List<IStiDashboardDrillDownParameter>;
        setDrillDownParameters(drillDownParameters: any[]): any;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import StiInitialDateRangeSelectionSource = Stimulsoft.Report.Dashboard.StiInitialDateRangeSelectionSource;
    let IStiDatePickerElement: System.Interface<IStiDatePickerElement>;
    let ImplementsIStiDatePickerElement: any[];
    interface IStiDatePickerElement extends IStiControlElement, IStiDataFilters {
        addValueMeter2(cell: IStiAppDataCell): any;
        addValueMeter(meter: IStiMeter): any;
        getValueMeter(): IStiMeter;
        removeValueMeter(): any;
        createNewValueMeter(): any;
        condition: StiDateCondition;
        selectionMode: StiDateSelectionMode;
        initialRangeSelection: StiInitialDateRangeSelection;
        initialRangeSelectionSource: StiInitialDateRangeSelectionSource;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    let IStiElementInteraction: System.Interface<IStiElementInteraction>;
    interface IStiElementInteraction {
        dashboardInteraction: IStiDashboardInteraction;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    let IStiElementLayout: System.Interface<IStiElementLayout>;
    let ImplementsIStiElementLayout: any[];
    interface IStiElementLayout {
        layout: StiElementLayout;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    let IStiFixedHeightElement: System.Interface<IStiFixedHeightElement>;
    let ImplementsIStiFixedHeightElement: any[];
    interface IStiFixedHeightElement {
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiCrossFiltering = Stimulsoft.Data.Engine.IStiCrossFiltering;
    import IStiUserSorts = Stimulsoft.Data.Engine.IStiUserSorts;
    import IStiConvertibleElement = Stimulsoft.Report.Dashboard.IStiConvertibleElement;
    import StiGaugeType = Stimulsoft.Report.Gauge.StiGaugeType;
    import StiGaugeCalculationMode = Stimulsoft.Report.Gauge.StiGaugeCalculationMode;
    import StiGaugeRangeMode = Stimulsoft.Report.Gauge.StiGaugeRangeMode;
    import StiGaugeRangeType = Stimulsoft.Report.Gauge.StiGaugeRangeType;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    let IStiGaugeElement: System.Interface<IStiGaugeElement>;
    let ImplementsIStiGaugeElement: any[];
    interface IStiGaugeElement extends IStiElement, IStiUserSorts, IStiDashboardElementStyle, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiCrossFiltering, IStiDataFilters, IStiConvertibleElement {
        addValue2(cell: IStiAppDataCell): any;
        addValue(meter: IStiMeter): any;
        removeValue(): any;
        getValue(): IStiMeter;
        getValue2(meter: IStiMeter): IStiMeter;
        createNewValue(): any;
        addSeries2(cell: IStiAppDataCell): any;
        addSeries(meter: IStiMeter): any;
        removeSeries(): any;
        getSeries(): IStiMeter;
        getSeries2(meter: IStiMeter): IStiMeter;
        createNewSeries(): any;
        addTarget2(cell: IStiAppDataCell): any;
        addTarget(meter: IStiMeter): any;
        removeTarget(): any;
        getTarget(): IStiMeter;
        getTarget2(meter: IStiMeter): IStiMeter;
        createNewTarget(): any;
        rangeType: StiGaugeRangeType;
        rangeMode: StiGaugeRangeMode;
        getRanges(): List<IStiGaugeRange>;
        addRange(): IStiGaugeRange;
        removeRange(index: number): any;
        createdDefaultRanges(): any;
        calculationMode: StiGaugeCalculationMode;
        type: StiGaugeType;
        minimum: number;
        maximum: number;
        shortValue: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiLabelRotationMode = Stimulsoft.Report.Gauge.StiLabelRotationMode;
    let IStiGaugeLabels: System.Interface<IStiGaugeLabels>;
    let ImplementsIStiGaugeLabels: any[];
    interface IStiGaugeLabels {
        visible: boolean;
        placement: StiLabelPlacement;
        rotationMode: StiLabelRotationMode;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiGaugeRange: System.Interface<IStiGaugeRange>;
    let ImplementsIStiGaugeRange: any[];
    interface IStiGaugeRange {
        color: Color;
        start: number;
        end: number;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    interface IStiHtmlTextHelper {
        setFontName(textObj: any, text: string, fontName: string, defaultColor: Color): string;
        setFontSize(textObj: any, text: string, fontSize: number, defaultColor: Color): string;
        growFontSize(textObj: any, text: string, defaultColor: Color): string;
        shrinkFontSize(textObj: any, text: string, defaultColor: Color): string;
        setFontBoldStyle(textObj: any, text: string, isBold: boolean, defaultColor: Color): string;
        setFontItalicStyle(textObj: any, text: string, isItalic: boolean, defaultColor: Color): string;
        setFontUnderlineStyle(textObj: any, text: string, isUnderline: boolean, defaultColor: Color): string;
        setColor(textObj: any, text: string, color: Color, defaultColor: Color): string;
        setHorAlignment(textObj: any, text: string, alignment: StiTextHorAlignment, defaultColor: Color): string;
        getFont(textObj: any, text: string, defaultColor: Color): Font;
        getColor(textObj: any, text: string, defaultColor: Color): Color;
        getHorAlign(textObj: any, text: string, defaultColor: Color): StiTextHorAlignment;
        getSimpleText(htmlText: string, defaultColor: Color): string;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiCrossFiltering = Stimulsoft.Data.Engine.IStiCrossFiltering;
    import Color = Stimulsoft.System.Drawing.Color;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    let IStiImageElement: System.Interface<IStiImageElement>;
    let ImplementsIStiImageElement: any[];
    interface IStiImageElement extends IStiElement, IStiGroupElement, IStiCrossFiltering {
        image: Image;
        imageHyperlink: string;
        aspectRatio: boolean;
        icon: StiFontIcons;
        iconColor: Color;
        copyAllImageProperties(element: IStiImageElement): any;
        isImageHyperlinkDataColumnDefined(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiIndicatorIconRangeMode = Stimulsoft.Report.Dashboard.StiIndicatorIconRangeMode;
    import StiIndicatorIconMode = Stimulsoft.Report.Dashboard.StiIndicatorIconMode;
    import IStiCrossFiltering = Stimulsoft.Data.Engine.IStiCrossFiltering;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiUserSorts = Stimulsoft.Data.Engine.IStiUserSorts;
    import List = Stimulsoft.System.Collections.List;
    import StiIconAlignment = Stimulsoft.Report.Dashboard.StiIconAlignment;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import IStiDataTransformationElement = Stimulsoft.Data.Engine.IStiDataTransformationElement;
    import IStiDataTopN = Stimulsoft.Data.Engine.IStiDataTopN;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import StiFontIconSet = Stimulsoft.Report.Helpers.StiFontIconSet;
    import StiTargetMode = Stimulsoft.Report.Dashboard.StiTargetMode;
    let IStiIndicatorElement: System.Interface<IStiIndicatorElement>;
    let ImplementsIStiIndicatorElement: any[];
    interface IStiIndicatorElement extends IStiElement, IStiUserSorts, IStiDashboardElementStyle, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiDataTopN, IStiDataTransformationElement, IStiGroupElement, IStiCrossFiltering, IStiDataFilters {
        addValue2(cell: IStiAppDataCell): any;
        addValue(meter: IStiMeter): any;
        removeValue(): any;
        getValue(): IStiMeter;
        getValue2(meter: IStiMeter): IStiMeter;
        createNewValue(): any;
        addTarget2(cell: IStiAppDataCell): any;
        addTarget(meter: IStiMeter): any;
        removeTarget(): any;
        getTarget(): IStiMeter;
        getTarget2(meter: IStiMeter): IStiMeter;
        createNewTarget(): any;
        addSeries2(cell: IStiAppDataCell): any;
        addSeries(meter: IStiMeter): any;
        removeSeries(): any;
        getSeries(): IStiMeter;
        getSeries2(meter: IStiMeter): IStiMeter;
        createNewSeries(): any;
        addIndicatorCondition(field: StiIndicatorFieldCondition, condition: StiFilterCondition, value: string, icon: StiFontIcons, iconColor: Color, targetIcon: StiFontIcons, targetIconColor: Color, customIcon: number[], iconAlignment: StiIconAlignment, targetIconAlignment: StiIconAlignment, permissions: StiIndicatorConditionPermissions, font: Font, textColor: Color, backColor: Color): any;
        fetchIndicatorConditions(): List<IStiIndicatorElementCondition>;
        clearIndicatorConditions(): any;
        iconSet: StiFontIconSet;
        icon: StiFontIcons;
        iconAlignment: StiIconAlignment;
        glyphColor: Color;
        customIcon: number[];
        targetMode: StiTargetMode;
        fontSizeMode: StiFontSizeMode;
        font: Font;
        iconMode: StiIndicatorIconMode;
        iconRangeMode: StiIndicatorIconRangeMode;
        getIconRanges(): List<IStiIndicatorIconRange>;
        addRange(): IStiIndicatorIconRange;
        removeRange(index: number): any;
        createdDefaultRanges(): any;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    let IStiIndicatorElementCondition: System.Interface<IStiIndicatorElementCondition>;
    let ImplementsIStiIndicatorElementCondition: any[];
    interface IStiIndicatorElementCondition {
        field: StiIndicatorFieldCondition;
        condition: StiFilterCondition;
        value: string;
        iconAlignment: StiIconAlignment;
        targetIconAlignment: StiIconAlignment;
        iconColor: Color;
        icon: StiFontIcons;
        customIcon: number[];
        permissions: StiIndicatorConditionPermissions;
        font: Font;
        textColor: Color;
        backColor: Color;
        targetIconColor: Color;
        targetIcon: StiFontIcons;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    let IStiIndicatorIconRange: System.Interface<IStiIndicatorIconRange>;
    let ImplementsStiIndicatorIconRange: any[];
    interface IStiIndicatorIconRange {
        icon: StiFontIcons;
        startExpression: string;
        endExpression: string;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    let IStiInteractionLayout: System.Interface<IStiInteractionLayout>;
    interface IStiInteractionLayout {
        showFullScreenButton: boolean;
        showSaveButton: boolean;
        showViewDataButton: boolean;
        headerText: string;
        footerText: string;
        fileName: string;
        isDefaultLayout: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    let IStiListBoxElement: System.Interface<IStiListBoxElement>;
    let ImplementsIStiListBoxElement: any[];
    interface IStiListBoxElement extends IStiControlElement, IStiItemElement, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiDataFilters {
        addKeyMeter2(cell: IStiAppDataCell): any;
        addKeyMeter(meter: IStiMeter): any;
        getKeyMeter(): IStiMeter;
        removeKeyMeter(): any;
        createNewKeyMeter(): any;
        addNameMeter2(cell: IStiAppDataCell): any;
        addNameMeter(meter: IStiMeter): any;
        getNameMeter(): IStiMeter;
        removeNameMeter(): any;
        createNewNameMeter(): any;
        createNextMeter(cell: IStiAppDataCell): any;
        orientation: StiItemOrientation;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    let IStiMargin: System.Interface<IStiMargin>;
    let ImplementsIStiMargin: any[];
    interface IStiMargin {
        margin: StiMargin;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiNegativeSeriesColors: System.Interface<IStiNegativeSeriesColors>;
    let ImplementsIStiNegativeSeriesColors: any[];
    interface IStiNegativeSeriesColors {
        negativeSeriesColors: Color[];
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiCrossFiltering = Stimulsoft.Data.Engine.IStiCrossFiltering;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiOnlineMapElement: System.Interface<IStiOnlineMapElement>;
    let ImplementsIStiOnlineMapElement: any[];
    interface IStiOnlineMapElement extends IStiElement, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiCrossFiltering, IStiDataFilters {
        createNextMeter(cell: IStiAppDataCell): any;
        addLatitudeMeter2(cell: IStiAppDataCell): any;
        addLatitudeMeter(meter: IStiMeter): any;
        getLatitudeMeter(): IStiMeter;
        removeLatitudeMeter(): any;
        createNewLatitudeMeter(): any;
        addLongitudeMeter2(cell: IStiAppDataCell): any;
        addLongitudeMeter(meter: IStiMeter): any;
        getLongitudeMeter(): IStiMeter;
        removeLongitudeMeter(): any;
        createNewLongitudeMeter(): any;
        addLocationMeter2(cell: IStiAppDataCell): any;
        addLocationMeter(meter: IStiMeter): any;
        getLocationMeter(): IStiMeter;
        removeLocationMeter(): any;
        createNewLocationMeter(): any;
        addLocationColorMeter2(cell: IStiAppDataCell): any;
        addLocationColorMeter(meter: IStiMeter): any;
        getLocationColorMeter(): IStiMeter;
        removeLocationColorMeter(): any;
        createNewLocationColorMeter(): any;
        addLocationValueMeter2(cell: IStiAppDataCell): any;
        addLocationValueMeter(meter: IStiMeter): any;
        getLocationValueMeter(): IStiMeter;
        removeLocationValueMeter(): any;
        createNewLocationValueMeter(): any;
        addLocationArgumentMeter(cell: IStiAppDataCell): any;
        addLocationArgumentMeter2(meter: IStiMeter): any;
        getLocationArgumentMeter(): IStiMeter;
        removeLocationArgumentMeter(): any;
        createNewLocationArgumentMeter(): any;
        locationType: StiOnlineMapLocationType;
        culture: StiOnlineMapCulture;
        locationColor: Color;
        locationColorType: StiOnlineMapLocationColorType;
        valueViewMode: StiOnlineMapValueViewMode;
        icon: StiFontIcons;
        iconColor: Color;
        customIcon: number[];
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    let IStiPadding: System.Interface<IStiPadding>;
    let ImplementsIStiPadding: any[];
    interface IStiPadding {
        padding: StiPadding;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiParetoSeriesColors: System.Interface<IStiParetoSeriesColors>;
    let ImplementsIStiParetoSeriesColors: any[];
    interface IStiParetoSeriesColors {
        paretoSeriesColors: Color[];
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    let IStiPivotTableCreator: System.Interface<IStiPivotTableCreator>;
    let ImplementsIStiPivotTableCreator: any[];
    interface IStiPivotTableCreator {
        create(element: IStiPivotTableElement, dataTable: StiDataTable): any;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    let IStiPivotGridContainer: System.Interface<IStiPivotGridContainer>;
    let ImplementsIStiPivotGridContainer: any[];
    interface IStiPivotGridContainer {
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiConditionPermissions = Stimulsoft.Report.Components.StiConditionPermissions;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiCrossFiltering = Stimulsoft.Data.Engine.IStiCrossFiltering;
    import StiSummaryDirection = Stimulsoft.Report.CrossTab.Core.StiSummaryDirection;
    import IStiConvertibleElement = Stimulsoft.Report.Dashboard.IStiConvertibleElement;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import List = Stimulsoft.System.Collections.List;
    let IStiPivotTableElement: System.Interface<IStiPivotTableElement>;
    let ImplementsIStiPivotTableElement: any[];
    interface IStiPivotTableElement extends IStiElement, IStiDashboardElementStyle, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiCrossFiltering, IStiDataFilters, IStiConvertibleElement {
        createNewColumn(): any;
        getColumn2(cell: IStiAppDataCell): IStiMeter;
        getColumn(meter: IStiMeter): IStiMeter;
        getColumnByIndex(index: number): IStiMeter;
        insertColumn(index: number, meter: IStiMeter): any;
        removeColumn(index: number): any;
        removeAllColumns(): any;
        createNewRow(): any;
        getRow2(cell: IStiAppDataCell): IStiMeter;
        getRow(meter: IStiMeter): IStiMeter;
        getRowByIndex(index: number): IStiMeter;
        insertRow(index: number, meter: IStiMeter): any;
        removeRow(index: number): any;
        removeAllRows(): any;
        createNewSummary(): any;
        getSummary2(cell: IStiAppDataCell): IStiMeter;
        getSummary(meter: IStiMeter): IStiMeter;
        getSummaryByIndex(index: number): IStiMeter;
        insertSummary(index: number, meter: IStiMeter): any;
        removeSummary(index: number): any;
        removeAllSummaries(): any;
        createNextMeter(cell: IStiAppDataCell): any;
        pivotTableConditions: List<IStiPivotTableElementCondition>;
        summaryDirection: StiSummaryDirection;
        getAllMeters(): List<IStiMeter>;
        addPivotTableCondition(keyValueMeter: string, dataType: Report.Components.StiFilterDataType, condition: Report.Components.StiFilterCondition, value: string, font: Font, textColor: Color, backColor: Color, permissions: StiConditionPermissions, icon: StiFontIcons, iconAlignment: StiIconAlignment, customIcon: number[], iconColor: Color): any;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Size = Stimulsoft.System.Drawing.Size;
    import StiConditionPermissions = Stimulsoft.Report.Components.StiConditionPermissions;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiPivotTableElementCondition: System.Interface<IStiPivotTableElementCondition>;
    let ImplementsIStiPivotTableElementCondition: System.Interface<IStiJsonReportObject>[];
    interface IStiPivotTableElementCondition extends IStiJsonReportObject, ICloneable {
        keyValueMeter: string;
        dataType: StiFilterDataType;
        condition: StiFilterCondition;
        value: string;
        textColor: Color;
        backColor: Color;
        font: Font;
        permissions: StiConditionPermissions;
        customIcon: number[];
        icon: StiFontIcons;
        iconAlignment: StiIconAlignment;
        iconSize: Size;
        iconColor: Color;
        getIcon(): Promise<number[]>;
        getUniqueCode(): number;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiCrossFiltering = Stimulsoft.Data.Engine.IStiCrossFiltering;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiUserSorts = Stimulsoft.Data.Engine.IStiUserSorts;
    import IStiConvertibleElement = Stimulsoft.Report.Dashboard.IStiConvertibleElement;
    import IStiDataTransformationElement = Stimulsoft.Data.Engine.IStiDataTransformationElement;
    import IStiDataTopN = Stimulsoft.Data.Engine.IStiDataTopN;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import List = Stimulsoft.System.Collections.List;
    let IStiProgressElement: System.Interface<IStiProgressElement>;
    let ImplementsIStiProgressElement: any[];
    interface IStiProgressElement extends IStiElement, IStiUserSorts, IStiDashboardElementStyle, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiDataTopN, IStiDataTransformationElement, IStiGroupElement, IStiCrossFiltering, IStiDataFilters, IStiConvertibleElement {
        colorEach: boolean;
        addValue2(cell: IStiAppDataCell): any;
        addValue(meter: IStiMeter): any;
        removeValue(): any;
        getValue(): IStiMeter;
        getValue2(meter: IStiMeter): IStiMeter;
        createNewValue(): any;
        addTarget2(cell: IStiAppDataCell): any;
        addTarget(meter: IStiMeter): any;
        removeTarget(): any;
        getTarget(): IStiMeter;
        getTarget2(meter: IStiMeter): IStiMeter;
        createNewTarget(): any;
        addSeries2(cell: IStiAppDataCell): any;
        addSeries(meter: IStiMeter): any;
        removeSeries(): any;
        getSeries(): IStiMeter;
        getSeries2(meter: IStiMeter): IStiMeter;
        createNewSeries(): any;
        addProgressCondition(field: StiProgressFieldCondition, condition: StiFilterCondition, value: string, permissions: StiProgressConditionPermissions, font: Font, textColor: Color, color: Color, trackColor: Color): any;
        fetchProgressConditions(): List<IStiProgressElementCondition>;
        clearProgressConditions(): any;
        mode: StiProgressElementMode;
        font: Font;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import Font = Stimulsoft.System.Drawing.Font;
    let IStiProgressElementCondition: System.Interface<IStiProgressElementCondition>;
    let ImplementsIStiProgressElementCondition: any[];
    interface IStiProgressElementCondition {
        condition: StiFilterCondition;
        field: StiProgressFieldCondition;
        value: string;
        permissions: StiProgressConditionPermissions;
        textColor: Color;
        color: Color;
        trackColor: Color;
        font: Font;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiCrossFiltering = Stimulsoft.Data.Engine.IStiCrossFiltering;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import IStiUserFilters = Stimulsoft.Data.Engine.IStiUserFilters;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import StiMapSource = Stimulsoft.Report.Maps.StiMapSource;
    import StiMapType = Stimulsoft.Report.Maps.StiMapType;
    import StiMapData = Stimulsoft.Report.Maps.StiMapData;
    import StiDisplayNameType = Stimulsoft.Report.Maps.StiDisplayNameType;
    let IStiRegionMapElement: System.Interface<IStiRegionMapElement>;
    let ImplementsIStiRegionMapElement: any[];
    interface IStiRegionMapElement extends IStiElement, IStiDashboardElementStyle, IStiUserFilters, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiCrossFiltering, IStiDataFilters {
        mapIdent: string;
        dataFrom: StiMapSource;
        mapData: string;
        mapType: StiMapType;
        showValue: boolean;
        colorEach: boolean;
        showBubble: boolean;
        shortValue: boolean;
        showName: StiDisplayNameType;
        getMapData(): List<StiMapData>;
        createNextMeter(cell: IStiAppDataCell): any;
        addKeyMeter2(cell: IStiAppDataCell): any;
        addKeyMeter(meter: IStiMeter): any;
        getKeyMeter(): IStiMeter;
        removeKeyMeter(): any;
        createNewKeyMeter(): any;
        addNameMeter2(cell: IStiAppDataCell): any;
        addNameMeter(meter: IStiMeter): any;
        getNameMeter(): IStiMeter;
        removeNameMeter(): any;
        createNewNameMeter(): any;
        addValueMeter2(cell: IStiAppDataCell): any;
        addValueMeter(meter: IStiMeter): any;
        getValueMeter(): IStiMeter;
        removeValueMeter(): any;
        createNewValueMeter(): any;
        addGroupMeter2(cell: IStiAppDataCell): any;
        addGroupMeter(meter: IStiMeter): any;
        getGroupMeter(): IStiMeter;
        removeGroupMeter(): any;
        createNewGroupMeter(): any;
        addColorMeter2(cell: IStiAppDataCell): any;
        addColorMeter(meter: IStiMeter): any;
        getColorMeter(): IStiMeter;
        removeColorMeter(): any;
        createNewColorMeter(): any;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    let IStiSeriesColors: System.Interface<IStiSeriesColors>;
    let ImplementsIStiSeriesColors: any[];
    interface IStiSeriesColors {
        seriesColors: Color[];
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiShapeTypeService = Stimulsoft.Report.Components.StiShapeTypeService;
    let IStiShapeElement: System.Interface<IStiShapeElement>;
    let ImplementsIStiShapeElement: any[];
    interface IStiShapeElement extends IStiElement {
        shapeType: StiShapeTypeService;
        stroke: Color;
        fill: StiBrush;
        size: number;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    let IStiSkipOwnFilter: System.Interface<IStiSkipOwnFilter>;
    let ImplementsIStiSkipOwnFilter: any[];
    interface IStiSkipOwnFilter {
        allowSkipOwnFilter: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    let IStiTableColumnSize: System.Interface<IStiTitle>;
    let ImplementsIStiTableColumnSize: any[];
    interface IStiTableColumnSize {
        size: StiTableColumnSize;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    let IStiTableDashboardInteraction: System.Interface<IStiTableDashboardInteraction>;
    let ImplementsIStiTableDashboardInteraction: System.Interface<IStiDashboardInteraction>[];
    interface IStiTableDashboardInteraction extends IStiDashboardInteraction {
        allowUserSorting: boolean;
        allowUserFiltering: boolean;
        drillDownFiltered: boolean;
        fullRowSelect: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiCrossFiltering = Stimulsoft.Data.Engine.IStiCrossFiltering;
    import List = Stimulsoft.System.Collections.List;
    import IStiConvertibleElement = Stimulsoft.Report.Dashboard.IStiConvertibleElement;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiUserFilters = Stimulsoft.Data.Engine.IStiUserFilters;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import IStiUserSorts = Stimulsoft.Data.Engine.IStiUserSorts;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTableSizeMode = Stimulsoft.Report.Dashboard.StiTableSizeMode;
    let IStiTableElement: System.Interface<IStiTableElement>;
    let ImplementsIStiTableElement: any[];
    interface IStiTableElement extends IStiElement, IStiUserSorts, IStiUserFilters, IStiDashboardElementStyle, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiCrossFiltering, IStiDataFilters, IStiFont, IStiConvertibleElement {
        createMeters(tableElement: IStiTableElement): any;
        createMeters2(dataSource: StiDataSource): any;
        createMeter3(cell: IStiAppDataCell): any;
        removeMeter(index: number): any;
        removeAllMeters(): any;
        insertMeter(index: number, meter: IStiMeter): any;
        insertNewDimension(index: number): any;
        insertNewMeasure(index: number): any;
        getMeasure(cell: IStiAppDataCell): IStiMeter;
        getDimension(cell: IStiAppDataCell): IStiMeter;
        headerFont: Font;
        headerForeColor: Color;
        sizeMode: StiTableSizeMode;
        foreColor: Color;
        footerFont: Font;
        footerForeColor: Color;
        tableConditions: List<IStiTableElementCondition>;
        addTableCondition(keyDataFieldMeters: string[], keyDestinationMeters: string[], dataType: Report.Components.StiFilterDataType, condition: Report.Components.StiFilterCondition, value: string, permissions: StiTableConditionPermissions, font: Font, foreColor: Color, backColor: Color, isExpression: boolean): any;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    let IStiTableElementAutoSizer: System.Interface<IStiTableElementAutoSizer>;
    let ImplementsIStiTableElementAutoSizer: any[];
    interface IStiTableElementAutoSizer {
        autoMeasureToTable(tableElement: IStiTableElement): any;
        autoMeasureToColumn(tableElement: IStiTableElement): any;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    let IStiTableElementCondition: System.Interface<IStiTableElementCondition>;
    let ImplementsIStiTableElementCondition: any[];
    interface IStiTableElementCondition {
        keyDataFieldMeters: string[];
        keyDestinationMeters: string[];
        dataType: StiFilterDataType;
        condition: StiFilterCondition;
        value: string;
        permissions: StiTableConditionPermissions;
        font: Font;
        foreColor: Color;
        backColor: Color;
        isExpression: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiCrossFiltering = Stimulsoft.Data.Engine.IStiCrossFiltering;
    let IStiTextElement: System.Interface<IStiTextElement>;
    let ImplementsIStiTextElement: any[];
    interface IStiTextElement extends IStiElement, IStiGroupElement, IStiCrossFiltering {
        text: string;
        getSimpleText(): string;
        crossFiltering: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiBackColor = Stimulsoft.Report.Components.IStiBackColor;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    let IStiTitle: System.Interface<IStiTitle>;
    let ImplementsIStiTitle: any[];
    interface IStiTitle extends IStiFont, IStiHorAlignment, IStiForeColor, IStiBackColor {
        text: string;
        visible: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    let IStiTitleElement: System.Interface<IStiTitleElement>;
    let ImplementsIStiTitleElement: any[];
    interface IStiTitleElement {
        title: IStiTitle;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    let IStiTreeViewBoxElement: System.Interface<IStiTreeViewBoxElement>;
    let ImplementsIStiTreeViewBoxElement: any[];
    interface IStiTreeViewBoxElement extends IStiControlElement, IStiItemElement, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiDataFilters {
        getKeyMeter(cell: IStiAppDataCell): IStiMeter;
        getKeyMeterByIndex(index: number): IStiMeter;
        insertKeyMeter(index: number, meter: IStiMeter): any;
        removeKeyMeter(index: number): any;
        removeAllKeyMeters(): any;
        addKey(cell: IStiAppDataCell): any;
        addNewKeyMeter(): IStiMeter;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    let IStiTreeViewElement: System.Interface<IStiTreeViewElement>;
    let ImplementsIStiTreeViewElement: any[];
    interface IStiTreeViewElement extends IStiControlElement, IStiItemElement, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiDataFilters {
        getKeyMeter(cell: IStiAppDataCell): IStiMeter;
        getKeyMeterByIndex(index: number): IStiMeter;
        insertKeyMeter(index: number, meter: IStiMeter): any;
        removeKeyMeter(index: number): any;
        removeAllKeyMeters(): any;
        addKey(cell: IStiAppDataCell): any;
        addNewKeyMeter(): IStiMeter;
    }
}
import StiJson = Stimulsoft.Base.StiJson;
declare namespace Stimulsoft.Report.Dashboard {
    import List = Stimulsoft.System.Collections.List;
    let IStiUserViewStates: System.Interface<IStiUserViewStates>;
    let ImplementsIStiUserViewStates: any[];
    interface IStiUserViewStates {
        userViewStates: List<StiUserViewState>;
        selectedViewStateKey: string;
        switchSelectedViewState(newKey: string): any;
        saveToJsonForViewState(): StiJson;
        loadFromJsonForViewState(jObject: StiJson): any;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiOnlineMapLastImageCache {
        private static cache;
        private static getKey;
        static getLastImage(element: IStiOnlineMapElement): Image;
        static existsLastImage(element: IStiOnlineMapElement): boolean;
        static storeLastImage(element: IStiOnlineMapElement, image: Image): void;
        static clean(reportKey: string): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    class StiPivotToConvertedStateCache {
        private static cache;
        private static getIntKey;
        private static getKey;
        static isConverted(element: IStiPivotTableElement): boolean;
        static putTrue(element: IStiPivotTableElement): void;
        static putFalse(element: IStiPivotTableElement): void;
        private static put;
        static contains(element: IStiPivotTableElement): boolean;
        static clean(reportKey?: string): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiPivotTableElement = Stimulsoft.Report.Dashboard.IStiPivotTableElement;
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    class StiPivotTableToCrossTabCache {
        private static cache;
        private static getKey;
        static get(element: IStiPivotTableElement): StiCrossTab;
        static put(element: IStiPivotTableElement, crossTab: StiCrossTab): void;
        static contains(element: IStiPivotTableElement): boolean;
        static remove(element: IStiPivotTableElement): void;
        static clean(reportKey: string): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    class StiPivotToContainerCache {
        private static cache;
        static get(element: IStiPivotTableElement): IStiPivotGridContainer;
        static put(element: IStiPivotTableElement, container: IStiPivotGridContainer): void;
        static remove(element: IStiPivotTableElement): void;
        static contains(element: IStiPivotTableElement): boolean;
        static clean(reportKey: string): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiReport = Stimulsoft.Base.IStiReport;
    import StiParserGetDataFieldValueEventArgs = Stimulsoft.Report.Engine.StiParser.StiParserGetDataFieldValueEventArgs;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiReportComponent = Stimulsoft.Base.IStiReportComponent;
    class StiReportParser {
        private static cache;
        private static wrongCache;
        static parse(expression: string, component: IStiReportComponent, allowCache?: boolean, constants?: Hashtable, allowDataLoading?: boolean, onlyExpression?: boolean): string;
        static parse2(expression: string, report: IStiReport, allowCache?: boolean, constants?: Hashtable, allowDataLoading?: boolean, onlyExpression?: boolean): string;
        static parseAsync(expression: string, component: IStiReportComponent, allowCache?: boolean): Promise<string>;
        private static parseOrDefault;
        private static parseOrDefaultAsync;
        private static tryParse;
        private static tryParseAsync;
        static getDataFieldValueProcessorAsync(sender: any, e: StiParserGetDataFieldValueEventArgs): Promise<void>;
        private static getCacheKey;
        static addToCache(expression: string, result: string, component: IStiReportComponent): void;
        static addToWrongCache(expression: string, result: string, component: IStiReportComponent): void;
        static getFromCache(expression: string, component: IStiReportComponent): string;
        static getFromWrongCache(expression: string, component: IStiReportComponent): string;
        static cleanCache(reportKey: string): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    import Image = Stimulsoft.System.Drawing.Image;
    import IStiApp = Stimulsoft.Base.IStiApp;
    class StiDashboardImageHyperlinkCache {
        private static cache;
        static get(hyperlink: string, app: IStiApp): Image;
        private static getCacheKey;
        private static getFromCache;
        private static addToCache;
        static clean(appKey: string): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiApp = Stimulsoft.Base.IStiApp;
    class StiCacheCleaner {
        static clean(element?: IStiElement | IStiAppDictionary | IStiApp | string): void;
        static clean1(element: IStiElement): void;
        static clean2(dictionary: IStiAppDictionary): void;
        static clean3(app: IStiApp): void;
        static clean4(reportKey?: string): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    class StiDashboardAssembly {
        static get isAssemblyLoaded(): boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiDashboard = Stimulsoft.Report.Dashboard.IStiDashboard;
    class StiDashboardCreator {
        static createDashboard(report: StiReport): IStiDashboard;
        static createDashboardElement(typeComponent: string): StiComponent;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    class StiDashboardDesignAssembly {
        static getHtmlTextHelper(): IStiHtmlTextHelper;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiPromise = Stimulsoft.System.StiPromise;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import StiExportSettings = Stimulsoft.Report.Export.StiExportSettings;
    class StiDashboardExport {
        static exportAsync(report: StiReport, stream: MemoryStream, settings: StiExportSettings): StiPromise<void>;
    }
}
declare namespace Stimulsoft.Report.Dashboards {
    import IStiTableElementAutoSizer = Stimulsoft.Report.Dashboard.IStiTableElementAutoSizer;
    import IStiProgressVisualSvgHelper = Stimulsoft.Report.Dashboard.Visuals.IStiProgressVisualSvgHelper;
    import IStiIndicatorVisualSvgHelper = Stimulsoft.Report.Dashboard.Visuals.IStiIndicatorVisualSvgHelper;
    import IStiGaugeVisualSvgHelper = Stimulsoft.Report.Dashboard.Visuals.IStiGaugeVisualSvgHelper;
    class StiDashboardHelperCreator {
        static createTableElementAutoSizer(): IStiTableElementAutoSizer;
        static createProgressVisualSvgHelper(): IStiProgressVisualSvgHelper;
        static createIndicatorVisualSvgHelper(): IStiIndicatorVisualSvgHelper;
        static createGaugeVisualSvgHelper(): IStiGaugeVisualSvgHelper;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    class StiDataFilterCreator {
        static createEqualBasedOnValue(value: any, columnName: string, component: StiComponent): StiDataFilterRule;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiElementMeterAction = Stimulsoft.Report.StiElementMeterAction;
    class StiElementChangedArgs {
        action: StiElementMeterAction;
        oldName: string;
        newName: string;
        static createEmptyArgs(): StiElementChangedArgs;
        static createRenamingArgs(oldName: string, newName: string): StiElementChangedArgs;
        static createDeletingArgs(name: string): StiElementChangedArgs;
        static createClearingAllArgs(): StiElementChangedArgs;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    class StiElementChangedProcessor {
        static processElementChanging(element: any, args: StiElementChangedArgs): void;
        private static processElementRenaming;
        private static processElementClearing;
        private static processElementDeleting;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiDataRequestOption = Stimulsoft.Data.Engine.StiDataRequestOption;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiElementDataCache {
        private static worker;
        private static elements;
        private static cache;
        private static pivotCreator;
        static tryToGetOrCreate(element: IStiElement, option?: StiDataRequestOption): Promise<StiDataTable>;
        static getOrCreate(element: IStiElement, option?: StiDataRequestOption): Promise<StiDataTable>;
        static getOrCreatePivot(element: IStiPivotTableElement, creator: IStiPivotTableCreator, option?: StiDataRequestOption): Promise<IStiPivotGridContainer>;
        static getOrCreateWithProgress(element: IStiElement, option?: StiDataRequestOption): Promise<StiDataTable>;
        static getOrCreatePivotWithProgress(element: IStiPivotTableElement, creator: IStiPivotTableCreator, option?: StiDataRequestOption): Promise<IStiPivotGridContainer>;
        static get(element: IStiElement): StiDataTable;
        static create(element: IStiElement, option: StiDataRequestOption): Promise<StiDataTable>;
        static add(element: IStiElement, dataTable: StiDataTable): void;
        private static initWorker;
        static getKey(element: IStiElement): string;
        static cleanCache(reportKey: string): void;
        private static getUserFilters;
        private static getUserSorts;
        private static getDataFilters;
        private static getTransformActions;
        private static getTransformFilters;
        private static getTransformSorts;
        private static getDrillDownFilters;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiElementLayout implements IStiJsonReportObject, ICloneable {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        static createFromJsonObject(jObject: StiJson): StiElementLayout;
        static createFromXml(xmlNode: XmlNode): StiElementLayout;
        clone(): StiElementLayout;
        isDefault(): boolean;
        fullScreenButton: boolean;
        saveButton: boolean;
        StiElementLayout(): void;
        constructor(saveButton?: boolean, fullScreenButton?: boolean);
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    class StiGroupElementHelper {
        static getGroup(element: IStiElement): string;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Type = Stimulsoft.System.Type;
    class StiInvokeMethodsHelper {
        static invokeStaticMethod(assemblyName: string, className: string, methodName: string, parameters?: any[], parametersTypes?: Type[]): any;
        static setPropertyValue(obj: any, propertyName: string, value: any): void;
        static getPropertyValue(obj: any, propertyName: string): any;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiMargin implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode, defLeft?: number, defTop?: number, defRight?: number, defBotttom?: number): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        left: number;
        top: number;
        right: number;
        bottom: number;
        get isEmpty(): boolean;
        equals(obj: any): boolean;
        static empty: StiMargin;
        static create(all?: number): StiMargin;
        constructor(left: number, top: number, right: number, bottom: number);
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiPadding implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode, defLeft?: number, defTop?: number, defRight?: number, defBotttom?: number): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        left: number;
        top: number;
        right: number;
        bottom: number;
        get isEmpty(): boolean;
        equals(obj: any): boolean;
        static empty: StiPadding;
        static create(all?: number): StiPadding;
        constructor(left: number, top: number, right: number, bottom: number);
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    import List = Stimulsoft.System.Collections.List;
    class StiPredefinedColors {
        static sets: List<Color[]>;
        static negativeSets: List<Color[]>;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    class StiStringMeasureCache {
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiTableColumnSize implements IStiJsonReportObject, ICloneable {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        static createFromJsonObject(jObject: StiJson): StiTableColumnSize;
        static createFromXml(xmlNode: XmlNode): StiTableColumnSize;
        clone(): StiTableColumnSize;
        private _width;
        get width(): number;
        set width(value: number);
        private _minWidth;
        get minWidth(): number;
        set minWidth(value: number);
        private _maxWidth;
        get maxWidth(): number;
        set maxWidth(value: number);
        wordWrap: boolean;
        isDefault(): boolean;
        checkRules(): void;
        getUniqueCode(): number;
        constructor(width?: number, minWidth?: number, maxWidth?: number, wordWrap?: boolean);
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import List = Stimulsoft.System.Collections.List;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiChartSeriesType = Stimulsoft.Report.Dashboard.StiChartSeriesType;
    class StiUserViewState implements IStiJsonReportObject, ICloneable {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiUserViewState;
        saveToString(): string;
        toList(): List<StiUserViewState>;
        static loadFromJson(jObject: StiJson): StiUserViewState;
        static loadFromJson2(json: string): StiUserViewState;
        static loadFromXml(xmlNode: XmlNode): StiUserViewState;
        key: string;
        name: string;
        state: string;
        seriesType: StiChartSeriesType;
        constructor(key?: string, name?: string, state?: string, seriesType?: StiChartSeriesType);
    }
}
declare namespace Stimulsoft.Report.Dashboard.Export {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiPageOrientation = Stimulsoft.Report.Components.StiPageOrientation;
    import PaperKind = Stimulsoft.System.Drawing.Printing.PaperKind;
    let IStiDashboardExportSettings: System.Interface<IStiDashboardExportSettings>;
    interface IStiDashboardExportSettings extends IAsIs {
        renderBorders: boolean;
        renderSingleElement: boolean;
        renderSinglePage: boolean;
        orientation: StiPageOrientation;
        paperSize: PaperKind;
        openAfterExport: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Export {
    import StiDataType = Stimulsoft.Report.Export.StiDataType;
    let IStiDataDashboardExportSettings: System.Interface<IStiDataDashboardExportSettings>;
    interface IStiDataDashboardExportSettings extends IStiDashboardExportSettings {
        dataType: StiDataType;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Export {
    let IStiExcelDashboardExportSettings: System.Interface<IStiExcelDashboardExportSettings>;
    interface IStiExcelDashboardExportSettings extends IStiDashboardExportSettings {
        width: number;
        height: number;
        imageQuality: number;
        exportDataOnly: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Export {
    let IStiHtmlDashboardExportSettings: System.Interface<IStiHtmlDashboardExportSettings>;
    interface IStiHtmlDashboardExportSettings extends IStiDashboardExportSettings {
        imageQuality: number;
        scale: number;
        enableAnimation: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Export {
    import StiImageType = Stimulsoft.Report.Export.StiImageType;
    let IStiImageDashboardExportSettings: System.Interface<IStiImageDashboardExportSettings>;
    interface IStiImageDashboardExportSettings extends IStiDashboardExportSettings {
        imageType: StiImageType;
        scale: number;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Export {
    let IStiPdfDashboardExportSettings: System.Interface<IStiPdfDashboardExportSettings>;
    interface IStiPdfDashboardExportSettings extends IStiDashboardExportSettings {
        autoPrint: boolean;
        imageQuality: number;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    class StiBorderElementHelper {
        static getBorderContentRect(rect: RectangleD, element: IStiElement, skipMinimalSize?: boolean): RectangleD;
        static getBorderContentRect2(rect: RectangleD, border: StiSimpleBorder, scale: number, skipMinimalSize?: boolean): RectangleD;
        static getBorderContentRect3(rect: RectangleD, border: StiBorder, scale: number, skipMinimalSize?: boolean): RectangleD;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiCrossLinkedFilterHelper {
        static isCrossLinkedFilter(filterElement: IStiFilterElement): boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDashboardExpressionHelper {
        static getBackColor(component: any, defaultColor: Color): Color;
        static getForeColor(component: any, defaultColor: Color): Color;
        static getColor(component: any, defaultColor: Color, propertyName: string): Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiDashboardRecentHelper {
        private static dbsFiles;
        private static reportFiles;
        private static getSettingsPath;
        private static getNewSettingsPath;
        static save(): boolean;
        private static load;
        static add(report: StiReport, path: string, autoSave?: boolean): void;
        static add2(containsDashboards: boolean, path: string, autoSave?: boolean): void;
        static remove(path: string): void;
        static containsDbs(path: string): boolean;
        static containsFile(path: string): boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiElementScale {
        static factor(element: IStiElement | StiComponent): number;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiIndicatorElementMouseOverHelper {
        private static indicatorElement;
        private static mouseOverPoint;
        static setMouseOverPoint(indicator: IStiIndicatorElement, point: PointD): void;
        static getMouseOverPoint(indicator: IStiIndicatorElement, useZoom?: boolean): PointD;
        static resetMouseOverPoint(indicator: IStiIndicatorElement): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiMarginHelper {
        static applyMargin(element: IStiElement, rect: RectangleD, scale?: number): RectangleD;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPaddingHelper {
        static applyPadding(element: IStiElement, rect: RectangleD, scale: number): RectangleD;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiSortMenuHelper {
        static isAllowUserSorting(element: IStiElement): boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTableElementClickEventArgs extends EventArgs {
        dataTable: StiDataTable;
        columnKey: string;
        rect: RectangleD;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiTableElementClickRightHelper {
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiTableElementMouseOverHelper {
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiTablePartDrawer {
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiTableSizer {
    }
}
declare namespace Stimulsoft.Report.Maps {
    enum StiMapSource {
        Manual = 0,
        DataColumns = 1
    }
    enum StiDisplayNameType {
        None = 1,
        Full = 2,
        Short = 3
    }
    enum StiMapMode {
        Choropleth = 0,
        Online = 1
    }
    enum StiMapID {
        World = 1,
        Australia = 2,
        Austria = 3,
        Brazil = 4,
        Canada = 5,
        China = 6,
        ChinaWithHongKongAndMacau = 7,
        ChinaWithHongKongMacauAndTaiwan = 8,
        Taiwan = 9,
        EU = 10,
        Europe = 11,
        EuropeWithRussia = 12,
        France = 13,
        Germany = 14,
        Italy = 15,
        Netherlands = 16,
        Russia = 17,
        UK = 18,
        UKCountries = 19,
        USAAndCanada = 20,
        NorthAmerica = 21,
        SouthAmerica = 22,
        USA = 23,
        Albania = 24,
        Andorra = 25,
        Argentina = 26,
        ArgentinaFD = 27,
        Afghanistan = 28,
        Armenia = 29,
        Azerbaijan = 30,
        Belarus = 31,
        Belgium = 32,
        Bolivia = 33,
        BosniaAndHerzegovina = 34,
        Bulgaria = 35,
        Chile = 36,
        Colombia = 37,
        Croatia = 38,
        Cyprus = 39,
        CzechRepublic = 40,
        Denmark = 41,
        Ecuador = 42,
        Estonia = 43,
        FalklandIslands = 44,
        Finland = 45,
        Georgia = 46,
        Greece = 47,
        Guyana = 48,
        Hungary = 49,
        Iceland = 50,
        India = 51,
        Indonesia = 52,
        Ireland = 53,
        Israel = 54,
        Japan = 55,
        Kazakhstan = 56,
        Latvia = 57,
        Liechtenstein = 58,
        Lithuania = 59,
        Luxembourg = 60,
        Macedonia = 61,
        Malaysia = 62,
        Malta = 63,
        Mexico = 64,
        Moldova = 65,
        Monaco = 66,
        Montenegro = 67,
        NewZealand = 68,
        Norway = 69,
        Oceania = 70,
        Paraguay = 71,
        Peru = 72,
        Philippines = 73,
        Poland = 74,
        Portugal = 75,
        Romania = 76,
        SanMarino = 77,
        SaudiArabia = 78,
        Serbia = 79,
        Slovakia = 80,
        Slovenia = 81,
        SouthAfrica = 82,
        SouthKorea = 83,
        Spain = 84,
        Suriname = 85,
        Sweden = 86,
        Switzerland = 87,
        Thailand = 88,
        Turkey = 89,
        Ukraine = 90,
        Uruguay = 91,
        Vatican = 92,
        Venezuela = 93,
        Vietnam = 94,
        MiddleEast = 95,
        Oman = 96,
        Qatar = 97,
        Benelux = 98,
        Scandinavia = 99,
        FranceDepartments = 100,
        France18Regions = 101,
        CentralAfricanRepublic = 102,
        Asia = 103,
        SoutheastAsia = 104
    }
    enum StiMapStyleIdent {
        Style21 = 0,
        Style24 = 1,
        Style25 = 2,
        Style26 = 3,
        Style27 = 4,
        Style28 = 5,
        Style29 = 6,
        Style30 = 7,
        Style31 = 8,
        Style32 = 9,
        Style33 = 10,
        Style34 = 11
    }
    enum StiMapType {
        None = 0,
        Individual = 4,
        Group = 1,
        Heatmap = 2,
        HeatmapWithGroup = 3
    }
}
declare namespace Stimulsoft.Report.Styles {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMapStyle extends StiBaseStyle {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        get componentId(): StiComponentId;
        private defaultColors;
        heatmap: StiHeatmapStyleData;
        private shouldSerializeHeatmap;
        heatmapWithGroup: StiHeatmapWithGroupStyleData;
        private shouldSerializeHeatmapWithGroup;
        private _individualColor;
        get individualColor(): Color;
        set individualColor(value: Color);
        private _colors;
        get colors(): Color[];
        set colors(value: Color[]);
        private _defaultColor;
        get defaultColor(): Color;
        set defaultColor(value: Color);
        private _backColor;
        get backColor(): Color;
        set backColor(value: Color);
        private _foreColor;
        get foreColor(): Color;
        set foreColor(value: Color);
        private _borderSize;
        get borderSize(): number;
        set borderSize(value: number);
        private _borderColor;
        get borderColor(): Color;
        set borderColor(value: Color);
        private _labelShadowForeground;
        get labelShadowForeground(): Color;
        set labelShadowForeground(value: Color);
        private _labelForeground;
        get labelForeground(): Color;
        set labelForeground(value: Color);
        private _bubbleBackColor;
        get bubbleBackColor(): Color;
        set bubbleBackColor(value: Color);
        private _bubbleBorderColor;
        get bubbleBorderColor(): Color;
        set bubbleBorderColor(value: Color);
        private shouldSerializeBubbleBorderColor;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
declare namespace Stimulsoft.Report.Maps {
    import StiMapStyle = Stimulsoft.Report.Styles.StiMapStyle;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiMapStyleFX extends StiMapStyle {
        get localizeName(): string;
        allowDashboard: boolean;
        get styleId(): StiMapStyleIdent;
        styleIdent: StiElementStyleIdent;
    }
}
declare namespace Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap34StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get borderColor(): Color;
        set borderColor(value: Color);
        get individualColor(): Color;
        set individualColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        constructor();
    }
}
declare namespace Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap33StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get borderColor(): Color;
        set borderColor(value: Color);
        get individualColor(): Color;
        set individualColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        constructor();
    }
}
declare namespace Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap32StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get borderColor(): Color;
        set borderColor(value: Color);
        get individualColor(): Color;
        set individualColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        constructor();
    }
}
declare namespace Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap31StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get borderColor(): Color;
        set borderColor(value: Color);
        get individualColor(): Color;
        set individualColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        constructor();
    }
}
declare namespace Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap30StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get borderColor(): Color;
        set borderColor(value: Color);
        get individualColor(): Color;
        set individualColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        constructor();
    }
}
declare namespace Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap29StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get colors(): Color[];
        set colors(value: Color[]);
        get individualColor(): Color;
        set individualColor(value: Color);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        get borderColor(): Color;
        set borderColor(value: Color);
        constructor();
    }
}
declare namespace Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap28StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get colors(): Color[];
        set colors(value: Color[]);
        get individualColor(): Color;
        set individualColor(value: Color);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        get borderColor(): Color;
        set borderColor(value: Color);
        constructor();
    }
}
declare namespace Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap27StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get individualColor(): Color;
        set individualColor(value: Color);
        get borderColor(): Color;
        set borderColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        constructor();
    }
}
declare namespace Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap26StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get individualColor(): Color;
        set individualColor(value: Color);
        get borderColor(): Color;
        set borderColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        constructor();
    }
}
declare namespace Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap25StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get individualColor(): Color;
        set individualColor(value: Color);
        get borderColor(): Color;
        set borderColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        constructor();
    }
}
declare namespace Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap24StyleFX extends StiMapStyleFX {
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        get dashboardName(): string;
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get individualColor(): Color;
        set individualColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        get borderColor(): Color;
        set borderColor(value: Color);
        constructor();
    }
}
declare namespace Stimulsoft.Report.Styles {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDialogStyle extends StiBaseStyle implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        font: Font;
        private sshouldSerializeFont;
        foreColor: Color;
        private shouldSerializeForeColor;
        backColor: Color;
        private shouldSerializeBackColor;
        glyphColor: Color;
        private shouldSerializeGlyphColor;
        separatorColor: Color;
        private shouldSerializeSeparatorColor;
        selectedBackColor: Color;
        private shouldSerializeSelectedBackColor;
        selectedForeColor: Color;
        private shouldSerializeSelectedForeColor;
        selectedGlyphColor: Color;
        private shouldSerializeSelectedGlyphColor;
        hotBackColor: Color;
        private shouldSerializeHotBackColor;
        hotForeColor: Color;
        private shouldSerializeHotForeColor;
        hotGlyphColor: Color;
        private shouldSerializeHotGlyphColor;
        hotSelectedBackColor: Color;
        private shouldSerializeHotSelectedBackColor;
        hotSelectedForeColor: Color;
        private shouldSerializeHotSelectedForeColor;
        hotSelectedGlyphColor: Color;
        private shouldSerializeHotSelectedGlyphColor;
        allowUseFont: boolean;
        allowUseBackColor: boolean;
        allowUseForeColor: boolean;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements, componentStyle?: StiBaseStyle): void;
        setStyleToComponent(component: StiComponent): void;
    }
}
declare namespace Stimulsoft.Report {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTableStyle extends StiBaseStyle {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        backColor: Color;
        dataColor: Color;
        dataForeground: Color;
        selectedDataColor: Color;
        selectedDataForeground: Color;
        alternatingDataColor: Color;
        alternatingDataForeground: Color;
        headerColor: Color;
        headerForeground: Color;
        hotHeaderColor: Color;
        footerColor: Color;
        footerForeground: Color;
        gridColor: Color;
        private getColor;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
declare namespace Stimulsoft.Report.Styles {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiBrushType = Stimulsoft.Report.StiBrushType;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiChartStyle extends StiBaseStyle implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        border: StiBorder;
        brush: StiBrush;
        chartAreaBrush: StiBrush;
        chartAreaBorderColor: Color;
        chartAreaShowShadow: boolean;
        seriesLighting: boolean;
        seriesShowShadow: boolean;
        seriesShowBorder: boolean;
        seriesLabelsLineColor: Color;
        trendLineColor: Color;
        trendLineShowShadow: boolean;
        seriesLabelsBrush: StiBrush;
        seriesLabelsColor: Color;
        seriesLabelsBorderColor: Color;
        legendBrush: StiBrush;
        legendLabelsColor: Color;
        legendBorderColor: Color;
        legendTitleColor: Color;
        axisTitleColor: Color;
        axisLineColor: Color;
        axisLabelsColor: Color;
        markerVisible: boolean;
        interlacingHorBrush: StiBrush;
        interlacingVertBrush: StiBrush;
        gridLinesHorColor: Color;
        gridLinesVertColor: Color;
        brushType: StiBrushType;
        styleColors: Color[];
        basicStyleColor: Color;
        allowUseBorderFormatting: boolean;
        allowUseBorderSides: boolean;
        allowUseBrush: boolean;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements, componentStyle?: StiBaseStyle): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTableStyle = Stimulsoft.Report.StiTableStyle;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiMapStyleFX = Stimulsoft.Report.Maps.StiMapStyleFX;
    import StiDialogStyle = Stimulsoft.Report.Styles.StiDialogStyle;
    import StiCrossTabStyle = Stimulsoft.Report.Styles.StiCrossTabStyle;
    import StiMapStyle = Stimulsoft.Report.Styles.StiMapStyle;
    import StiMapStyleIdent = Stimulsoft.Report.Maps.StiMapStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiChartStyle = Stimulsoft.Report.Chart.IStiChartStyle;
    import FontFamily = Stimulsoft.System.Drawing.FontFamily;
    import StiChartStyle = Stimulsoft.Report.Styles.StiChartStyle;
    class StiDashboardStyleHelper {
        private static iconFontFamily;
        private static cloneColors;
        static getCopyChartStyle(chartStyle: IStiChartStyle, element: IStiChartElement): StiChartStyle;
        static getCopyTableStyle(tableStyle: StiTableElementStyle): StiTableStyle;
        static convertToReportGaugeStyle(element: IStiGaugeElement): StiGaugeStyle;
        static convertToReportPivotTableStyle(element: IStiPivotTableElement): StiCrossTabStyle;
        static convertToReportIndicatorStyle(element: IStiIndicatorElement): StiIndicatorStyle;
        static convertToReportProgressStyle(element: IStiProgressElement): StiProgressStyle;
        static convertToReportRegionMapStyle(element: IStiRegionMapElement): StiMapStyle;
        static convertToReportControlStyle(element: IStiControlElement): StiDialogStyle;
        static getDashboardBackColor(dashboard: IStiDashboard, isViewer: boolean): Color;
        static isDarkStyle(dashboard: IStiDashboard): boolean;
        static isDarkStyle3(element: IStiElement): boolean;
        static isDarkStyle2(ident: StiElementStyleIdent): boolean;
        static getFont(element: IStiControlElement): Font;
        static getForeColor(element: IStiElement, defaultColor?: Color): Color;
        static getStyleForeColor(element: IStiElement): Color;
        static getForeColor2(ident: StiElementStyleIdent): Color;
        static getNativeForeColor(element?: IStiElement): Color;
        static getSelectedForeColor(element: IStiControlElement): Color;
        static getSelectedBackColor(element: IStiControlElement): Color;
        static getGlyphColor2(element: IStiControlElement): Color;
        static getGlyphColor(element: IStiIndicatorElement): Color;
        static getSeparatorColor(element: IStiControlElement): Color;
        static getBackColor(element: IStiElement, defaultColor?: Color, allowOpacity?: boolean): Color;
        static getStyleBackColor(element: IStiElement): Color;
        static getStyleHotBackColor(element: IStiElement): Color;
        static getHotBackColor(element: IStiElement): Color;
        static getBackColor2(style: StiElementStyleIdent): Color;
        static getTitleForeColor(element: IStiElement): Color;
        static getGaugeStyle(element: IStiGaugeElement): IStiGaugeStyle;
        static getGaugeStyle2(style: StiElementStyleIdent): IStiGaugeStyle;
        static getChartStyle(element: IStiChartElement): IStiChartStyle;
        static getChartStyle2(style: StiElementStyleIdent): IStiChartStyle;
        static getMapStyleIdent(element: IStiRegionMapElement): StiMapStyleIdent;
        static getMapStyle(element: IStiRegionMapElement): StiMapStyleFX;
        static getMapStyle2(style: StiElementStyleIdent): StiMapStyleFX;
        static getControlStyle(element: IStiElement): StiControlElementStyle;
        static getIndicatorStyle(element: IStiIndicatorElement): StiIndicatorElementStyle;
        static getProgressStyle(element: IStiProgressElement): StiProgressElementStyle;
        static getTableStyle(element: IStiTableElement): StiTableElementStyle;
        static getTableStyle2(style: StiElementStyleIdent): StiTableElementStyle;
        static getPivotTableStyle(element: IStiPivotTableElement): StiPivotElementStyle;
        static getStyle(element: IStiElement): StiElementStyleIdent;
        static getIconFontFamily(): FontFamily;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    class StiElementStyle extends StiBaseStyle {
        ident: StiElementStyleIdent;
        drawBox(g: Graphics, rect: Rectangle, paintValue: boolean, paintImage: boolean): void;
        drawStyle(g: Graphics, rect: Rectangle, paintValue: boolean, paintImage: boolean): void;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiControlElementStyle extends StiElementStyle {
        get localizedName(): string;
        backColor: Color;
        foreColor: Color;
        glyphColor: Color;
        separatorColor: Color;
        selectedBackColor: Color;
        selectedForeColor: Color;
        selectedGlyphColor: Color;
        hotBackColor: Color;
        hotForeColor: Color;
        hotGlyphColor: Color;
        hotSelectedBackColor: Color;
        hotSelectedForeColor: Color;
        hotSelectedGlyphColor: Color;
        font: Font;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiAliceBlueControlElementStyle extends StiControlElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        backColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        separatorColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiBlueControlElementStyle extends StiControlElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import StiDialogStyle = Stimulsoft.Report.Styles.StiDialogStyle;
    class StiCustomControlElementStyle extends StiControlElementStyle {
        private styleName;
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        constructor(style: StiDialogStyle);
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkBlueControlElementStyle extends StiControlElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        separatorColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkGrayControlElementStyle extends StiControlElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        backColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        separatorColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkGreenControlElementStyle extends StiControlElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        backColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        separatorColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkTurquoiseControlElementStyle extends StiControlElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        backColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        separatorColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiGreenControlElementStyle extends StiControlElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        selectedBackColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiOrangeControlElementStyle extends StiControlElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        selectedBackColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSilverControlElementStyle extends StiControlElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        backColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        separatorColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSlateGrayControlElementStyle extends StiControlElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        backColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        separatorColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiTurquoiseControlElementStyle extends StiControlElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        selectedBackColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    class StiDashboardStyle extends StiElementStyle {
        get localizedName(): string;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
        get borderColor(): Color;
        drawStyleForGallery(g: Graphics, rect: Rectangle): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiAliceBlueDashboardStyle extends StiDashboardStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        get borderColor(): Color;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBlueDashboardStyle extends StiDashboardStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkBlueDashboardStyle extends StiDashboardStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
        titleBackColor: System.Drawing.Color;
        titleForeColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkGrayDashboardStyle extends StiDashboardStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleForeColor: Color;
        titleBackColor: Color;
        get borderColor(): Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkGreenDashboardStyle extends StiDashboardStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleForeColor: Color;
        titleBackColor: Color;
        get borderColor(): Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkTurquoiseDashboardStyle extends StiDashboardStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleForeColor: Color;
        titleBackColor: Color;
        get borderColor(): Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGreenDashboardStyle extends StiDashboardStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiOrangeDashboardStyle extends StiDashboardStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSilverDashboardStyle extends StiDashboardStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        get borderColor(): Color;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSlateGrayDashboardStyle extends StiDashboardStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTurquoiseDashboardStyle extends StiDashboardStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiIndicatorElementStyle extends StiElementStyle {
        get localizedName(): string;
        glyphColor: Color;
        backColor: Color;
        foreColor: Color;
        hotBackColor: Color;
        positiveColor: Color;
        negativeColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiAliceBlueIndicatorElementStyle extends StiIndicatorElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiBlueIndicatorElementStyle extends StiIndicatorElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCustomIndicatorElementStyle extends StiIndicatorElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: Color;
        foreColor: Color;
        constructor(style: StiIndicatorStyle);
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkBlueIndicatorElementStyle extends StiIndicatorElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkGrayIndicatorElementStyle extends StiIndicatorElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: Color;
        backColor: Color;
        positiveColor: Color;
        negativeColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkGreenIndicatorElementStyle extends StiIndicatorElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
        positiveColor: System.Drawing.Color;
        negativeColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkTurquoiseIndicatorElementStyle extends StiIndicatorElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: Color;
        backColor: Color;
        positiveColor: Color;
        negativeColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiGreenIndicatorElementStyle extends StiIndicatorElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiOrangeIndicatorElementStyle extends StiIndicatorElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSilverIndicatorElementStyle extends StiIndicatorElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSlateGrayIndicatorElementStyle extends StiIndicatorElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiTurquoiseIndicatorElementStyle extends StiIndicatorElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        glyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiPivotElementStyle extends StiElementStyle {
        get localizedName(): string;
        cellBackColor: Color;
        cellForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        columnHeaderBackColor: Color;
        columnHeaderForeColor: Color;
        rowHeaderBackColor: Color;
        rowHeaderForeColor: Color;
        hotColumnHeaderBackColor: Color;
        hotRowHeaderBackColor: Color;
        lineColor: Color;
        backColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiAliceBluePivotElementStyle extends StiPivotElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBluePivotElementStyle extends StiPivotElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        columnHeaderBackColor: Color;
        columnHeaderForeColor: Color;
        rowHeaderBackColor: Color;
        rowHeaderForeColor: Color;
        hotColumnHeaderBackColor: Color;
        hotRowHeaderBackColor: Color;
        cellForeColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiCrossTabStyle = Stimulsoft.Report.Styles.StiCrossTabStyle;
    class StiCustomPivotElementStyle extends StiPivotElementStyle {
        private name2;
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        columnHeaderBackColor: Color;
        columnHeaderForeColor: Color;
        rowHeaderBackColor: Color;
        rowHeaderForeColor: Color;
        hotColumnHeaderBackColor: Color;
        hotRowHeaderBackColor: Color;
        cellForeColor: Color;
        lineColor: Color;
        constructor(style: StiCrossTabStyle);
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkBluePivotElementStyle extends StiPivotElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkGrayPivotElementStyle extends StiPivotElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkGreenPivotElementStyle extends StiPivotElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkTurquoisePivotElementStyle extends StiPivotElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGreenPivotElementStyle extends StiPivotElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        columnHeaderBackColor: Color;
        rowHeaderBackColor: Color;
        hotColumnHeaderBackColor: Color;
        hotRowHeaderBackColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiOrangePivotElementStyle extends StiPivotElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        columnHeaderBackColor: Color;
        rowHeaderBackColor: Color;
        hotColumnHeaderBackColor: Color;
        hotRowHeaderBackColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSilverPivotElementStyle extends StiPivotElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSlateGrayPivotElementStyle extends StiPivotElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTurquoisePivotElementStyle extends StiPivotElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        columnHeaderBackColor: Color;
        rowHeaderBackColor: Color;
        hotColumnHeaderBackColor: Color;
        hotRowHeaderBackColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiProgressElementStyle extends StiElementStyle {
        get localizedName(): string;
        foreColor: Color;
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        backColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiAliceBlueProgressElementStyle extends StiProgressElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiBlueProgressElementStyle extends StiProgressElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCustomProgressElementStyle extends StiProgressElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        foreColor: Color;
        backColor: Color;
        constructor(style: StiProgressStyle);
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkBlueProgressElementStyle extends StiProgressElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkGrayProgressElementStyle extends StiProgressElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkGreenProgressElementStyle extends StiProgressElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkTurquoiseProgressElementStyle extends StiProgressElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiGreenProgressElementStyle extends StiProgressElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiOrangeProgressElementStyle extends StiProgressElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSilverProgressElementStyle extends StiProgressElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSlateGrayProgressElementStyle extends StiProgressElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiTurquoiseProgressElementStyle extends StiProgressElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTableElementStyle extends StiElementStyle {
        get localizedName(): string;
        cellBackColor: Color;
        cellForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        headerBackColor: Color;
        headerForeColor: Color;
        hotHeaderBackColor: Color;
        lineColor: Color;
        footerColor: Color;
        footerForeground: Color;
        backColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellWinLossNegative: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
        cellIndicatorNeutral: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiAliceBlueTableElementStyle extends StiTableElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        cellForeColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        headerBackColor: Color;
        headerForeColor: Color;
        footerColor: Color;
        footerForeground: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        hotHeaderBackColor: Color;
        lineColor: Color;
        backColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBlueTableElementStyle extends StiTableElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        headerBackColor: Color;
        headerForeColor: Color;
        footerColor: Color;
        footerForeground: Color;
        cellForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        hotHeaderBackColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiCustomTableElementStyle extends StiTableElementStyle {
        private name2;
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        constructor(style: StiTableStyle);
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkBlueTableElementStyle extends StiTableElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        headerBackColor: System.Drawing.Color;
        headerForeColor: System.Drawing.Color;
        footerColor: System.Drawing.Color;
        footerForeground: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        hotHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkGrayTableElementStyle extends StiTableElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        cellForeColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        headerBackColor: Color;
        headerForeColor: Color;
        footerColor: Color;
        footerForeground: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        hotHeaderBackColor: Color;
        lineColor: Color;
        backColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkGreenTableElementStyle extends StiTableElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        cellForeColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        headerBackColor: Color;
        headerForeColor: Color;
        footerColor: Color;
        footerForeground: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        hotHeaderBackColor: Color;
        lineColor: Color;
        backColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkTurquoiseTableElementStyle extends StiTableElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        cellForeColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        headerBackColor: Color;
        headerForeColor: Color;
        footerColor: Color;
        footerForeground: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        hotHeaderBackColor: Color;
        lineColor: Color;
        backColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGreenTableElementStyle extends StiTableElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        selectedCellBackColor: Color;
        headerBackColor: Color;
        hotHeaderBackColor: Color;
        footerColor: Color;
        footerForeground: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiOrangeTableElementStyle extends StiTableElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        selectedCellBackColor: Color;
        headerBackColor: Color;
        hotHeaderBackColor: Color;
        footerColor: Color;
        footerForeground: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSilverTableElementStyle extends StiTableElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        cellForeColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        headerBackColor: Color;
        headerForeColor: Color;
        footerColor: Color;
        footerForeground: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        hotHeaderBackColor: Color;
        lineColor: Color;
        backColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSlateGrayTableElementStyle extends StiTableElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        headerBackColor: System.Drawing.Color;
        headerForeColor: System.Drawing.Color;
        footerColor: System.Drawing.Color;
        footerForeground: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        hotHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTurquoiseTableElementStyle extends StiTableElementStyle {
        get componentId(): StiComponentId;
        get localizedName(): string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        selectedCellBackColor: Color;
        headerBackColor: Color;
        hotHeaderBackColor: Color;
        footerColor: Color;
        footerForeground: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Visuals {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    let IStiGaugeVisualSvgHelper: System.Interface<IStiGaugeVisualSvgHelper>;
    interface IStiGaugeVisualSvgHelper {
        writeGauge(writer: XmlTextWriter, svgData: StiSvgData, needAnimation: boolean, refNeedToScroll?: any, refContentHeight?: any): Promise<void>;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Visuals {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    let IStiIndicatorVisualSvgHelper: System.Interface<IStiIndicatorVisualSvgHelper>;
    interface IStiIndicatorVisualSvgHelper {
        writeIndicator(writer: XmlTextWriter, svgData: StiSvgData, refNeedToScroll?: any, refContentHeight?: any): Promise<void>;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Visuals {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    let IStiProgressVisualSvgHelper: System.Interface<IStiProgressVisualSvgHelper>;
    interface IStiProgressVisualSvgHelper {
        writeProgress(writer: XmlTextWriter, svgData: StiSvgData, refNeedToScroll?: any, refContentHeight?: any): Promise<void>;
    }
}
declare namespace Stimulsoft.Report.Units {
    class StiHundredthsOfInchUnit extends StiUnit {
        get rulerStep(): number;
        get factor(): number;
        get shortName(): string;
        get name(): string;
        convertToHInches(value: number): number;
        convertFromHInches(value: number): number;
    }
}
declare namespace Stimulsoft.Report.Units {
    class StiCentimetersUnit extends StiUnit {
        get rulerStep(): number;
        get factor(): number;
        get shortName(): string;
        get name(): string;
        convertToHInches(value: number): number;
        convertFromHInches(value: number): number;
    }
}
declare namespace Stimulsoft.Report.Units {
    class StiMillimetersUnit extends Stimulsoft.Report.Units.StiUnit {
        get rulerStep(): number;
        get factor(): number;
        get shortName(): string;
        get name(): string;
        convertToHInches(value: number): number;
        convertFromHInches(value: number): number;
    }
}
declare namespace Stimulsoft.Report.Design {
    import StiAction = Stimulsoft.Base.Drawing.StiAction;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiQuickInfoType = Stimulsoft.Report.Components.StiQuickInfoType;
    class StiDesignerInfo {
        clone(report: StiReport): StiDesignerInfo;
        private _forceDesigningMode;
        get forceDesigningMode(): boolean;
        set forceDesigningMode(value: boolean);
        private _quickInfoType;
        get quickInfoType(): StiQuickInfoType;
        set quickInfoType(value: StiQuickInfoType);
        private _generateLocalizedName;
        get generateLocalizedName(): boolean;
        set generateLocalizedName(value: boolean);
        private _showDimensionLines;
        get showDimensionLines(): boolean;
        set showDimensionLines(value: boolean);
        private _quickInfoOverlay;
        get quickInfoOverlay(): boolean;
        set quickInfoOverlay(value: boolean);
        private _isComponentsMoving;
        get isComponentsMoving(): boolean;
        set isComponentsMoving(value: boolean);
        private _currentAction;
        get currentAction(): StiAction;
        set currentAction(value: StiAction);
        private _isTableMode;
        get isTableMode(): boolean;
        set isTableMode(value: boolean);
        private _drawEventMarkers;
        get drawEventMarkers(): boolean;
        set drawEventMarkers(value: boolean);
        private _drawMarkersWhenMoving;
        get drawMarkersWhenMoving(): boolean;
        set drawMarkersWhenMoving(value: boolean);
        private _runDesignerAfterInsert;
        get runDesignerAfterInsert(): boolean;
        set runDesignerAfterInsert(value: boolean);
        private _useLastFormat;
        get useLastFormat(): boolean;
        set useLastFormat(value: boolean);
        private _autoSaveInterval;
        get autoSaveInterval(): number;
        set autoSaveInterval(value: number);
        private _enableAutoSaveMode;
        get enableAutoSaveMode(): boolean;
        set enableAutoSaveMode(value: boolean);
        private _showOrder;
        get showOrder(): boolean;
        set showOrder(value: boolean);
        private _alignToGrid;
        get alignToGrid(): boolean;
        set alignToGrid(value: boolean);
        private _autoSaveReportToReportClass;
        get autoSaveReportToReportClass(): boolean;
        set autoSaveReportToReportClass(value: boolean);
        private _showHeaders;
        get showHeaders(): boolean;
        set showHeaders(value: boolean);
        private _showGrid;
        get showGrid(): boolean;
        set showGrid(value: boolean);
        private _showInteractive;
        get showInteractive(): boolean;
        set showInteractive(value: boolean);
        private _zoom;
        get zoom(): number;
        set zoom(value: number);
        private _showRulers;
        get showRulers(): boolean;
        set showRulers(value: boolean);
        private _gridSizePoints;
        get gridSizePoints(): number;
        set gridSizePoints(value: number);
        private _gridSizePixels;
        get gridSizePixels(): number;
        set gridSizePixels(value: number);
        private _gridSizeCentimetres;
        get gridSizeCentimetres(): number;
        set gridSizeCentimetres(value: number);
        private _gridSizeHundredthsOfInch;
        get gridSizeHundredthsOfInch(): number;
        set gridSizeHundredthsOfInch(value: number);
        private _gridSizeInch;
        get gridSizeInch(): number;
        set gridSizeInch(value: number);
        private _gridSizeMillimeters;
        get gridSizeMillimeters(): number;
        set gridSizeMillimeters(value: number);
        get gridSize(): number;
        private _fillBands;
        get fillBands(): boolean;
        set fillBands(value: boolean);
        private _fillCrossBands;
        get fillCrossBands(): boolean;
        set fillCrossBands(value: boolean);
        private _fillContainer;
        get fillContainer(): boolean;
        set fillContainer(value: boolean);
        private _fillComponent;
        get fillComponent(): boolean;
        set fillComponent(value: boolean);
        private _useComponentColor;
        get useComponentColor(): boolean;
        set useComponentColor(value: boolean);
        private _gridMode;
        get gridMode(): StiGridMode;
        set gridMode(value: StiGridMode);
        private _report;
        get report(): StiReport;
        set report(value: StiReport);
        getFillColor(color: Color): Color;
        constructor(report?: StiReport);
    }
}
declare namespace Stimulsoft.Report.Design {
    class StiExpressionPacker {
        static packExpression(expressionStr: string, report: StiReport, useBraces: boolean): string;
        static unPackExpression(expressionStr: string, report: StiReport, useBraces: boolean): string;
        private static isValidName;
        static getCorrectedAlias(report: StiReport, alias: string): string;
        private static addWord;
        private static buildDictionary;
        private static buildBusinessObject;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiAliasAttribute {
        private _alias;
        get alias(): string;
        set alias(value: string);
        constructor(alias: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    class StiBusinessObjectSort implements IComparer<any> {
        private sortColumns;
        private rowToConditions;
        private conditions;
        private businessObject;
        compare(x: any, y: any): number;
        compareValues(value1: any, value2: any, ascendary?: boolean): number;
        clear(): void;
        constructor(sortColumns: string[], businessObject: StiBusinessObject, rowToConditions: Hashtable, conditions: any[][][]);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiBusinessObjectToDataSet {
        private dataSet;
        private relations;
        private uniques;
        private level;
        convertBusinessObjectToDataSet(name: string, obj: any): DataSet;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IStiAppCalcDataColumn = Stimulsoft.Base.IStiAppCalcDataColumn;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Type = Stimulsoft.System.Type;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCalcDataColumn extends StiDataColumn implements IStiJsonReportObject, IStiAppCalcDataColumn {
        private static ImplementsStiCalcDataColumn;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _value;
        get value(): string;
        set value(val: string);
        get expression(): string;
        set expression(value: string);
        constructor(name?: string, alias?: string, typeT?: Type, value?: string, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiData {
        private _viewData;
        get viewData(): any;
        set viewData(value: any);
        private _data;
        get data(): any;
        set data(value: any);
        private _name;
        get name(): string;
        set name(value: string);
        private _alias;
        get alias(): string;
        set alias(value: string);
        private _isReportData;
        get isReportData(): boolean;
        set isReportData(value: boolean);
        private _isBusinessObjectData;
        get isBusinessObjectData(): boolean;
        set isBusinessObjectData(value: boolean);
        OriginalConnectionState: any;
        toString(): string;
        constructor(name: string, data: any, viewData?: any);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiDataBuilder {
        static getColumnFromPath(path: string, dictionary: StiDictionary): StiDataColumn;
        static getColumnFromPath2(path: string, dataSource: StiDataSource): StiDataColumn;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import Type = Stimulsoft.System.Type;
    import JsonRelationDirection = Stimulsoft.System.Data.JsonRelationDirection;
    class StiDataCollection extends CollectionBase<StiData> {
        getByName(name: string): StiData;
        setByName(name: string, value: StiData): void;
        regData(name: string, alias: string, data: any, jsonRelationDirection?: JsonRelationDirection): void;
        private regDataDataTable;
        private regDataDataSet;
        private regDataDataTable2;
        private regDataDataSet2;
        regDataStiDataCollection(datas: StiDataCollection): void;
        clearReportDatabase(): void;
        contains(data: StiData | string): boolean;
        getData(typeData: Type): StiDataCollection;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiDataColumnExt {
        static getDataSourceByColumnKey(report: StiReport, columnKey: string): StiDataSource;
        static getColumnByKey(report: StiReport, columnKey: string): StiDataColumn;
        static isNumericType(column: StiDataColumn): boolean;
        static isDateType(column: StiDataColumn): boolean;
        static isIntegerType(column: StiDataColumn): boolean;
        static isArray(column: StiDataColumn): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import DataColumn = Stimulsoft.System.Data.DataColumn;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import Type = Stimulsoft.System.Type;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiDataColumnsCollection extends CollectionBase<StiDataColumn> implements IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private decodeTypeName;
        loadFromXml(node: XmlNode): void;
        static checkType(typeName: string, type: Type): Type;
        cachedDataColumns: Hashtable;
        private directionFactor;
        dataSource: StiDataSource;
        private businessObject;
        onInsert(value: any): void;
        add(column: StiDataColumn): any;
        add(name: string, typeT: Type): any;
        add(name: string, alias: string, type: Type): any;
        contains(column: StiDataColumn | string): boolean;
        insert(index: number, column: StiDataColumn): void;
        remove(column: StiDataColumn): void;
        getByName(name: string): StiDataColumn;
        setByName(name: string, value: StiDataColumn): void;
        sort(order: StiSortOrder): void;
        constructor(source?: StiBusinessObject | StiDataSource | StiDataColumn[] | DataColumn[]);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiExpression = Stimulsoft.Report.Expressions.StiExpression;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDataParameter extends StiExpression implements IStiName, IStiInherited, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        dataParametersCollection: StiDataParametersCollection;
        private _inherited;
        get inherited(): boolean;
        set inherited(value: boolean);
        private _name;
        get name(): string;
        set name(value: string);
        get applyFormat(): boolean;
        get expression(): string;
        set expression(value: string);
        getParameterValue(): any;
        private _parameterValue;
        get parameterValue(): any;
        set parameterValue(value: any);
        private _dataSource;
        get dataSource(): StiDataSource;
        set dataSource(value: StiDataSource);
        private _type;
        get type(): number;
        set type(value: number);
        private _size;
        get size(): number;
        set size(value: number);
        private _key;
        get key(): string;
        set key(value: string);
        toString(): string;
        isStringType(dataSource: StiDataSource): boolean;
        isNumberType(dataSource: StiDataSource): boolean;
        isDateType(dataSource: StiDataSource): boolean;
        isTimeType(dataSource: StiDataSource): boolean;
        isDateTimeType(dataSource: StiDataSource): boolean;
        constructor(name?: string, value?: string, type?: number, size?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDataParametersCollection extends CollectionBase<StiDataParameter> implements IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private dataSource;
        private cachedDataParameters;
        onInsert(index: number, value: any): void;
        contains(parameter: StiDataParameter | string): boolean;
        getByName(name: string): StiDataParameter;
        setByName(name: string, value: StiDataParameter): void;
        constructor(dataSource?: StiDataSource);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IStiAppCell = Stimulsoft.Base.IStiAppCell;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiAppDataRelation = Stimulsoft.Base.IStiAppDataRelation;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import List = Stimulsoft.System.Collections.List;
    class StiDataRelation implements IStiName, IStiAlias, IStiInherited, ICloneable, IStiAppCell, IStiAppDataRelation, IStiJsonReportObject {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private parseStringArray;
        private _inherited;
        get inherited(): boolean;
        set inherited(value: boolean);
        private _name;
        get name(): string;
        set name(value: string);
        getName(): string;
        getDictionary(): IStiAppDictionary;
        getParentDataSource(): IStiAppDataSource;
        getChildDataSource(): IStiAppDataSource;
        fetchParentColumns(): List<string>;
        fetchChildColumns(): List<string>;
        getActiveState(): boolean;
        getKey(): string;
        setKey(key: string): void;
        clone(): any;
        private _dictionary;
        get dictionary(): StiDictionary;
        set dictionary(value: StiDictionary);
        private _parentSource;
        get parentSource(): StiDataSource;
        set parentSource(value: StiDataSource);
        private _childSource;
        get childSource(): StiDataSource;
        set childSource(value: StiDataSource);
        private _parentColumns;
        get parentColumns(): string[];
        set parentColumns(value: string[]);
        private _childColumns;
        get childColumns(): string[];
        set childColumns(value: string[]);
        private _relationName;
        get relationName(): string;
        set relationName(value: string);
        private _nameInSource;
        get nameInSource(): string;
        set nameInSource(value: string);
        private _alias;
        get alias(): string;
        set alias(value: string);
        isCloud: boolean;
        active: boolean;
        private _key;
        get key(): string;
        set key(value: string);
        toString(): string;
        constructor(nameInSource?: string, name?: string, alias?: string, parentSource?: StiDataSource, childSource?: StiDataSource, parentColumns?: string[], childColumns?: string[], key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiDataRelationSetName {
        static setName(dataRelation: StiDataRelation, report: StiReport, dataSet: DataSet, name: string): void;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiDataRetrieval {
        dispose(): void;
        private buildTokens;
        private _usedColumns;
        get usedColumns(): Hashtable;
        private _usedRelations;
        get usedRelations(): Hashtable;
        private _usedDataSources;
        get usedDataSources(): Hashtable;
        retrieval(report: StiReport): void;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import DataRow = Stimulsoft.System.Data.DataRow;
    class StiDataRow {
        createDataRow(dataRow: StiDataRow): StiDataRow;
        private _row;
        get row(): DataRow;
        set row(value: DataRow);
        private dataSource;
        get dictionary(): StiDictionary;
        getByColumnName(columnName: string): any;
        getParentData(relation: string): StiDataRow;
        constructor(dataSource: StiDataSource, dataRow: DataRow);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import DataRow = Stimulsoft.System.Data.DataRow;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiDataSort implements IComparer<DataRow> {
        private sortColumns;
        private rowToConditions;
        private conditions;
        private hashValues;
        private dataSource;
        private textComp;
        private static nullObject;
        compare(x: DataRow, y: DataRow): number;
        private compareRows;
        compareValues(value1: any, value2: any, ascendary?: boolean): number;
        clear(): void;
        constructor(rowToConditions: Hashtable, conditions: any[][][], sortColumns: string[], dataSource: StiDataSource);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiService = Stimulsoft.Base.Services.StiService;
    import Type = Stimulsoft.System.Type;
    import StiDataTableSource = Stimulsoft.Report.Dictionary.StiDataTableSource;
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiDataTableSetNameService extends StiService {
        get serviceCategory(): string;
        get serviceType(): Type;
        setName(dataTableSource: StiDataTableSource, report: StiReport, dataSet: DataSet, name: string): void;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import List = Stimulsoft.System.Collections.List;
    class StiDatabaseInformation {
        tables: List<DataTable>;
        views: List<DataTable>;
        storedProcedures: List<DataTable>;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import IStiAppDataColumn = Stimulsoft.Base.IStiAppDataColumn;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiDatabaseCollection = Stimulsoft.Report.Dictionary.StiDatabaseCollection;
    import StiBusinessObjectsCollection = Stimulsoft.Report.Dictionary.StiBusinessObjectsCollection;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import DataSet = Stimulsoft.System.Data.DataSet;
    import StiDatabase = Stimulsoft.Report.Dictionary.StiDatabase;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPromise = Stimulsoft.System.StiPromise;
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import IStiAppDataRelation = Stimulsoft.Base.IStiAppDataRelation;
    import IStiAppVariable = Stimulsoft.Base.IStiAppVariable;
    import IStiApp = Stimulsoft.Base.IStiApp;
    import IStiAppConnection = Stimulsoft.Base.IStiAppConnection;
    class StiDictionary implements ICloneable, IStiAppDictionary, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiDictionary;
        fetchDataSources(): List<IStiAppDataSource>;
        fetchDataRelations(): List<IStiAppDataRelation>;
        fetchVariables(): List<IStiAppVariable>;
        getDataSourceByName(name: string): IStiAppDataSource;
        getColumnByName(name: string): IStiAppDataColumn;
        getVariableByName(name: string): IStiAppVariable;
        getVariableValueByName(name: string): any;
        getVariableValueInternal(name: string): any;
        isSystemVariable(name: string): boolean;
        getSystemVariableValue(name: string): any;
        getApp(): IStiApp;
        openConnections(connections: List<IStiAppConnection>): List<IStiAppConnection>;
        closeConnections(connections: List<IStiAppConnection>): void;
        reconnectListForRequestFromUserVariables: string[];
        private _cachedUserNamesAndPasswords;
        get cachedUserNamesAndPasswords(): Hashtable;
        set cachedUserNamesAndPasswords(value: Hashtable);
        private _useInternalData;
        get useInternalData(): boolean;
        set useInternalData(value: boolean);
        private _restrictions;
        get restrictions(): StiRestrictions;
        set restrictions(value: StiRestrictions);
        static get autoSynchronize(): StiAutoSynchronizeMode;
        static set autoSynchronize(value: StiAutoSynchronizeMode);
        static doAutoSynchronize(report: StiReport): void;
        private _cacheDataSet;
        get cacheDataSet(): DataSet;
        set cacheDataSet(value: DataSet);
        private _report;
        get report(): StiReport;
        set report(value: StiReport);
        private _dataStore;
        get dataStore(): StiDataCollection;
        set dataStore(value: StiDataCollection);
        private _variables;
        get variables(): StiVariablesCollection;
        set variables(value: StiVariablesCollection);
        private _resources;
        get resources(): StiResourcesCollection;
        set resources(value: StiResourcesCollection);
        private _dataSources;
        get dataSources(): StiDataSourcesCollection;
        set dataSources(value: StiDataSourcesCollection);
        private _databases;
        get databases(): StiDatabaseCollection;
        set databases(value: StiDatabaseCollection);
        private _businessObjects;
        get businessObjects(): StiBusinessObjectsCollection;
        set businessObjects(value: StiBusinessObjectsCollection);
        private _relations;
        get relations(): StiDataRelationsCollection;
        set relations(value: StiDataRelationsCollection);
        get isRequestFromUserVariablesPresent(): boolean;
        private equalsColumns;
        createDatabases(loadData: boolean): void;
        createDatabasesAsync(loadData: boolean): StiPromise<void>;
        removeUnusedData(): void;
        removeUnusedDataSourcesV2(): void;
        retrievalData(REFusedRelations: any, REFusedDataSources: any, REFusedColumns: any): void;
        getUnusedRelationsFromDataStore(): StiDataRelationsCollection;
        private synchronize2;
        synchronize(): void;
        synchronizeBusinessObjects(): void;
        synchronizeColumns(data: StiData, dataSource: StiDataSource): void;
        synchronizeColumnsAsync(data: StiData, dataSource: StiDataSource): StiPromise<void>;
        synchronizeColumns3(data: StiBusinessObjectData, source: StiBusinessObject): void;
        synchronizeColumns2(data: any, source: StiBusinessObject): void;
        clear(): void;
        private disposeCacheDataSet;
        renameDatabase(database: StiDatabase, newName: string): void;
        connectToDatabasesAsync(databases?: List<StiDatabase>, loadData?: boolean): StiPromise<void>;
        connectAsync(loadData?: boolean, dataSources?: StiDataSource[]): StiPromise<void>;
        connect(loadData?: boolean, dataSources?: StiDataSource[]): void;
        connectVirtualDataSourcesAsync(): StiPromise<void>;
        connectDataTransformationsAsync(): StiPromise<void>;
        connectCrossTabDataSources(): void;
        disconnect(): void;
        private disconnectingDatabases;
        private disconnectedDatabases;
        private disconnectingConnectionInDataStore;
        private checkRelation;
        private equalsRelationColumns;
        private getRelationName;
        regRelations2(virtualSources?: boolean): void;
        regRelation(relation: StiDataRelation, virtualSources: boolean): void;
        constructor(report?: StiReport);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import DataRow = Stimulsoft.System.Data.DataRow;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiGroupSummaryDataSort implements IComparer<DataRow> {
        private groupSummaries;
        private groupLines;
        private baseRowOrder;
        private groupHeaders;
        compare(row1: DataRow, row2: DataRow): number;
        private compareValues;
        clear(): void;
        constructor(groupSummaries: Hashtable<string, Hashtable<number, any>>, groupLines: Hashtable<string, Hashtable<number, any>>, groupHeaders: StiComponentsCollection, baseRowOrder: Hashtable<number, any>);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import StiHierarchicalBand = Stimulsoft.Report.Components.StiHierarchicalBand;
    class StiHierarchicalBusinessObjectSort implements IComparer<any> {
        compare(x: any, y: any): number;
        private getParentValue;
        process(): void;
        private createTree;
        private setLevelAndSort;
        private createRowList;
        private businessObject;
        private keyColumn;
        private masterKeyColumn;
        private parentValue;
        private sortColumns;
        constructor(businessObject: StiBusinessObject, band: StiHierarchicalBand, sortColumns: string[]);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiHierarchicalBand = Stimulsoft.Report.Components.StiHierarchicalBand;
    class StiHierarchicalDataSort implements IComparer<any> {
        private dataSource;
        private keyColumn;
        private masterKeyColumn;
        private parentValue;
        private sortColumns;
        compare(x: any, y: any): number;
        private getParentValue;
        process(rowToConditions: Hashtable): void;
        private createTree;
        private setLevelAndSort;
        private createRowList;
        constructor(dataSource: StiDataSource, band: StiHierarchicalBand, sortColumns: string[]);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiResourcesCollection extends CollectionBase<StiResource> implements IComparer<StiResource>, IStiJsonReportObject {
        implements(): any[];
        clone(): StiResourcesCollection;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson, report?: StiReport): void;
        loadFromXml(xmlNode: XmlNode): void;
        private directionFactor;
        compare(x: StiResource, y: StiResource): number;
        sort(order?: StiSortOrder): void;
        contains2(name: string): boolean;
        getByName(name: string): StiResource;
        getByAlias(alias: string): StiResource;
        setByName(name: string, value: StiResource): void;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiRestrictions {
        private restrictionsDataSource;
        private restrictionsDataRelation;
        private restrictionsDataColumn;
        private restrictionsDatabase;
        private restrictionsVariable;
        private restrictionsTotal;
        private restrictionsBusinessObject;
        clear(): void;
        private getHashtable;
        add(name: string, dataType: StiDataType, type: StiRestrictionTypes): void;
        isAllowEdit(name: string, dataType: StiDataType): boolean;
        isAllowDelete(name: string, dataType: StiDataType): boolean;
        isAllowShow(name: string, dataType: StiDataType): boolean;
        isAllowMove(name: string, dataType: StiDataType): boolean;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiRow {
        private dataSource;
        private rowIndex;
        getByName(columnName: string): any;
        constructor(dataSource: StiDataSource, rowIndex: number);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IEnumerator = Stimulsoft.System.Collections.IEnumerator;
    class StiRowsCollection implements IEnumerator {
        getEnumerator(): IEnumerator;
        get current(): any;
        moveNext(): boolean;
        reset(): void;
        getbyIndex(rowIndex: number): StiRow;
        get count(): number;
        private dataSource;
        constructor(dataSource: StiDataSource);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiStrFix {
        static Del_(str: string): string;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiSystemVariablesHelper {
        static getSystemVariableInfo(variable: string): string;
        static getSystemVariables(report: StiReport): string[];
        protected static systemVariablesV2: string[];
        static getSystemVariablesV2(): string[];
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiType {
        private _name;
        get name(): string;
        set name(value: string);
        private _type;
        get type(): Stimulsoft.System.Type;
        set type(value: Stimulsoft.System.Type);
        static getTypes(): StiTypesCollection;
        static getBaseTypes(): StiTypesCollection;
        static getTypeModeFromType(type: Stimulsoft.System.Type, REFtypeMode: any): System.Type;
        static getTypeFromTypeMode(type: Stimulsoft.System.Type, typeMode: StiTypeMode): Stimulsoft.System.Type;
        toString(): string;
        constructor(name: string, type: Stimulsoft.System.Type);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiTypesCollection extends CollectionBase<StiType> {
        getByName(name: string): StiType;
        setByName(name: string, value: StiType): void;
        get(type: Stimulsoft.System.Type): StiType;
        set(type: Stimulsoft.System.Type, value: StiType): void;
        regType(name: string, type: Stimulsoft.System.Type): void;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiUserNameAndPassword {
        private _userName;
        get userName(): string;
        private _password;
        get password(): string;
        constructor(userName: string, password: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiToken = Stimulsoft.Base.StiToken;
    import List = Stimulsoft.System.Collections.List;
    class StiVariableAsParameterHelper {
        static parameterExists(tokens: List<StiToken>, name: string): boolean;
        static fetchAll(query: string, parameters: List<StiDataParameter>, report: StiReport): List<StiVariable>;
        private static parameterExists2;
    }
}
declare namespace Stimulsoft.Report {
    import IStiAppVariable = Stimulsoft.Base.IStiAppVariable;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiVariableExpressionHelper {
        static getVariableSpecifiedAsExpression(element: IStiElement, expression: string): IStiAppVariable;
        static isVariableSpecifiedAsExpression(element: IStiElement, expression: string): boolean;
        static extractVariableName(exp: string): string;
        static getSimpleName(name: string): string;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiPromise = Stimulsoft.System.StiPromise;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    class StiCustomAdapterService extends StiSqlAdapterService {
        private processUserFunction;
        static registerCustomAdapterService(options: {
            name: string;
            process: (command: any, callback: (result: any) => void) => void;
        }): void;
        private _name;
        get name(): string;
        getDataSourceType(): Stimulsoft.System.Type;
        getDataAdapter(): StiSqlAdapterService;
        create(dictionary: StiDictionary, addToDictionary?: boolean): StiDataSource;
        callRemoteApi(command: any, timeout: number): StiPromise<string>;
        retrieveDataAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString: string): StiPromise<DataTable>;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): StiPromise<StiDataSchema>;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiDataTableAdapterService extends StiDataStoreAdapterService {
        get serviceName(): string;
        isObjectAdapter: boolean;
        getDataCategoryName(data: StiData): string;
        getColumnsFromDataAsync(data: StiData, dataSource: StiDataSource): StiPromise<StiDataColumnsCollection>;
        getColumnsFromData(data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        getParametersFromData(data: StiData, dataSource: StiDataSource): StiDataParametersCollection;
        setDataSourceNames(data: StiData, dataSource: StiDataSource): void;
        create(dictionary: StiDictionary, addToDictionary?: boolean): StiDataSource;
        getDataSourceType(): Type;
        getDataTypes(): Type[];
        getDataFromDataSource(dictionary: StiDictionary, dataSource: StiDataSource): StiData;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): StiPromise<void>;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiFileAdapterService extends StiDataStoreAdapterService {
        get serviceName(): string;
        getDataCategoryName(data: StiData): string;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiCsvAdapterService extends StiFileAdapterService {
        get name(): string;
        getColumnsFromData(data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        getParametersFromData(data: StiData, dataSource: StiDataSource): StiDataParametersCollection;
        setDataSourceNames(data: StiData, dataSource: StiDataSource): void;
        getDataSourceType(): Stimulsoft.System.Type;
        getDataTypes(): Stimulsoft.System.Type[];
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
        checkConvertNulls(dataSource: StiCsvSource): void;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiNoSqlAdapterService extends StiDataStoreAdapterService {
        getDataCategoryName(data: StiData): string;
        testConnection(connectionString: string): string;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiMongoDbAdapterService extends StiNoSqlAdapterService {
        get name(): string;
        getDataSourceType(): Stimulsoft.System.Type;
        getColumnsFromData(data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiBusinessObjectAdapterService extends StiDataTableAdapterService {
        get serviceName(): string;
        isObjectAdapter: boolean;
        getDataSourceType(): Type;
        getDataTypes(): Type[];
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiCrossTabAdapterService extends StiDataStoreAdapterService {
        get serviceName(): string;
        isObjectAdapter: boolean;
        getDataSourceType(): Type;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiDataTransformationAdapterService extends StiDataStoreAdapterService {
        get serviceName(): string;
        isObjectAdapter: boolean;
        edit(dictionary: StiDictionary, dataSource: StiDataSource): boolean;
        new(dictionary: StiDictionary, dataSource: StiDataSource): boolean;
        getDataTypes(): Type[];
        getColumnsFromData(data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        getParametersFromData(data: StiData, dataSource: StiDataSource): StiDataParametersCollection;
        getDataCategoryName(data: StiData): string;
        getDataSourceType(): Type;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiDataViewAdapterService extends StiDataStoreAdapterService {
        get serviceName(): string;
        isObjectAdapter: boolean;
        getDataSourceType(): Type;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiUserAdapterService extends StiDataStoreAdapterService {
        get serviceName(): string;
        isObjectAdapter: boolean;
        getDataSourceType(): Type;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiPromise = Stimulsoft.System.StiPromise;
    import Type = Stimulsoft.System.Type;
    class StiVirtualAdapterService extends StiDataStoreAdapterService {
        get serviceName(): string;
        isObjectAdapter: boolean;
        getDataTypes(): Type[];
        getColumnsFromDataAsync(data: StiData, dataSource: StiDataSource, connectionString: string): StiPromise<StiDataColumnsCollection>;
        getColumnsFromData(data: StiData, dataSource: StiDataSource, connectionString: string): StiDataColumnsCollection;
        getParametersFromData(data: StiData, dataSource: StiDataSource): StiDataParametersCollection;
        getDataCategoryName(data: StiData): string;
        getDataSourceType(): Type;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): StiPromise<void>;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiDataWorldConnector = Stimulsoft.Base.StiDataWorldConnector;
    import StiPromise = Stimulsoft.System.StiPromise;
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    class StiDataWorldAdapterService extends StiNoSqlAdapterService {
        getDataSourceType(): Stimulsoft.System.Type;
        createConnector(connectionString: string): StiDataWorldConnector;
        getColumnsFromData(data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        getParametersFromData(data: StiData, dataSource: StiDataSource): StiDataParametersCollection;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): StiPromise<void>;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
        testConnectionAsync(report: StiReport, connectionString: string): StiPromise<string>;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): StiPromise<StiDataSchema>;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiQuickBooksConnector = Stimulsoft.Base.StiQuickBooksConnector;
    import Type = Stimulsoft.System.Type;
    import StiSqlAdapterService = Stimulsoft.Report.Dictionary.StiSqlAdapterService;
    class StiQuickBooksAdapterService extends StiSqlAdapterService {
        getDataSourceType(): Type;
        createConnector(connectionString?: string): StiQuickBooksConnector;
        getColumnsFromData(data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        getParametersFromData(data: StiData, dataSource: StiDataSource): StiDataParametersCollection;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
        createConnectionInDataStore(dictionary: StiDictionary, database: StiSqlDatabase): void;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiODataAdapterService extends StiSqlAdapterService {
        get serviceName(): string;
        get name(): string;
        getDataSourceType(): Stimulsoft.System.Type;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiSqlSource, loadData: boolean): StiPromise<void>;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiSqlSource, loadData: boolean): void;
        testConnectionAsync(report: StiReport, connectionString: string): StiPromise<string>;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): StiPromise<StiDataSchema>;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiFirebirdAdapterService extends StiSqlAdapterService {
        get name(): string;
        getDatabaseSpecificName(name: string): string;
        getDataSourceType(): Stimulsoft.System.Type;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): StiPromise<StiDataSchema>;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiOdbcAdapterService extends StiSqlAdapterService {
        get name(): string;
        getDataSourceType(): Stimulsoft.System.Type;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiOracleAdapterService extends StiSqlAdapterService {
        get name(): string;
        getDataSourceType(): Stimulsoft.System.Type;
        getDatabaseSpecificName(name: string): string;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): StiPromise<StiDataSchema>;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiPostgreSQLAdapterService extends StiSqlAdapterService {
        get name(): string;
        getDatabaseSpecificName(name: string): string;
        getDataSourceType(): Stimulsoft.System.Type;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): StiPromise<StiDataSchema>;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiBusinessObjectCategory {
        private _category;
        get category(): string;
        set category(value: string);
        constructor(category: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiSqlSource extends StiDataTableSource implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _allowExpressions;
        get allowExpressions(): boolean;
        set allowExpressions(value: boolean);
        private _type;
        get type(): StiSqlSourceType;
        set type(value: StiSqlSourceType);
        private _commandTimeout;
        get commandTimeout(): number;
        set commandTimeout(value: number);
        private _reconnectOnEachRow;
        get reconnectOnEachRow(): boolean;
        set reconnectOnEachRow(value: boolean);
        private _sqlCommand;
        get sqlCommand(): string;
        set sqlCommand(value: string);
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        updateParameters(): void;
        retrieveDataAsync(schemaOnly?: boolean): StiPromise<void>;
        getFinalSqlCommand(): string;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCustomSource extends StiSqlSource {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        serviceName: string;
        static registerCustomSource(serviceName: string): void;
        getDataAdapter(): StiDataAdapterService;
        getDataAdapterType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiSqlSource = Stimulsoft.Report.Dictionary.StiSqlSource;
    class StiDataSourceParserHelper {
        static connectSqlSource(sqlSource: StiSqlSource): void;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiNoSqlSource extends StiSqlSource {
        get query(): string;
        set query(value: string);
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiAzureTableStorageSource extends StiNoSqlSource {
        createNew(): StiDataSource;
        get componentId(): StiComponentId;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiCosmosDbSource extends StiNoSqlSource {
        createNew(): StiDataSource;
        get componentId(): StiComponentId;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiFileDataSource extends StiDataStoreSource {
        get componentId(): StiComponentId;
        get path(): string;
        set path(value: string);
        codePage: number;
        constructor(path?: string, name?: string, alias?: string, codePage?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCsvSource extends StiFileDataSource implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        getDataAdapterType(): Stimulsoft.System.Type;
        separator: string;
        convertEmptyStringToNull: boolean;
        createNew(): StiDataSource;
        constructor(path?: string, name?: string, alias?: string, codePage?: number, separator?: string, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDBaseSource extends StiFileDataSource {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        constructor(path?: string, name?: string, alias?: string, codePage?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiBigQuerySource extends StiNoSqlSource {
        createNew(): StiDataSource;
        get componentId(): StiComponentId;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiFirebaseSource extends StiNoSqlSource {
        createNew(): StiDataSource;
        get componentId(): StiComponentId;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiGoogleSheetsSource extends StiDataStoreSource {
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiMongoDbSource extends StiNoSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiBusinessObjectSource extends StiDataTableSource {
        createNew(): StiDataSource;
        get componentId(): StiComponentId;
        constructor(nameInSource?: string, name?: string, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiUserSource extends StiDataStoreSource {
        createNew(): StiDataSource;
        get componentId(): StiComponentId;
        constructor(nameInSource?: string, name?: string, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiCrossTabDataSource extends StiDataStoreSource {
        createNew(): StiDataSource;
        get componentId(): StiComponentId;
        constructor(nameInSource?: string, name?: string, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiDataViewSource extends StiDataStoreSource {
        createNew(): StiDataSource;
        get componentId(): StiComponentId;
        constructor(nameInSource?: string, name?: string, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiPromise = Stimulsoft.System.StiPromise;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiFilter = Stimulsoft.Report.Components.IStiFilter;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import Type = Stimulsoft.System.Type;
    class StiVirtualSource extends StiDataStoreSource implements IStiFilter, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _filterMethodHandler;
        get filterMethodHandler(): Function;
        set filterMethodHandler(value: Function);
        private _filterOn;
        get filterOn(): boolean;
        set filterOn(value: boolean);
        private _filterMode;
        get filterMode(): StiFilterMode;
        set filterMode(value: StiFilterMode);
        private _filters;
        get filters(): Stimulsoft.Report.Components.StiFiltersCollection;
        set filters(value: Stimulsoft.Report.Components.StiFiltersCollection);
        protected getDataAdapterType(): Type;
        private _groupColumns;
        get groupColumns(): string[];
        set groupColumns(value: string[]);
        private _results;
        get results(): string[];
        set results(value: string[]);
        private _sort;
        get sort(): string[];
        set sort(value: string[]);
        connectToDataAsync(allowConnect?: boolean): StiPromise<void>;
        connectToDataAsync2(allowConnect?: boolean): Promise<void>;
        private connectToDataInternal;
        private compare;
        private initTotals;
        private addRow;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiDataWorldSource extends StiNoSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiODataSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    class StiQuickBooksSource extends StiSqlSource {
        getDataAdapterType(): Type;
        createNew(): StiDataSource;
        get componentId(): StiComponentId;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiDB2Source extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiDotConnectUniversalSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiFirebirdSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiInformixSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiMSAccessSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiMySqlSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiOdbcSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiOleDbSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiOracleSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiPostgreSQLSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiSQLiteSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiSqlCeSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiSybaseAdsSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiSybaseSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiTeradataSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiVistaDBSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiDataSource;
        getParameterTypesEnum(): any;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    enum StiDataTransformationMode {
        Dimension = 0,
        Measure = 1
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Type = Stimulsoft.System.Type;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiDataTransformationColumn extends StiDataColumn implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        expression: string;
        mode: StiDataTransformationMode;
        getDictionaryColumn(): StiDataColumn;
        constructor(name?: string, alias?: string, type?: Type, expression?: string, key?: string, mode?: StiDataTransformationMode);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import ICloneable = Stimulsoft.System.ICloneable;
    import IAsIs = Stimulsoft.System.IAsIs;
    class StiDataTransformationMeter implements IAsIs, ICloneable {
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        implements(): any[];
        clone(): StiDataTransformationMeter;
        getUniqueCode(): number;
        expression: string;
        label: string;
        constructor(expression: string, label: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    class StiDimensionTransformationMeter extends StiDataTransformationMeter implements IStiDimensionMeter {
        private static ImplementsStiDimensionTransformationMeter;
        implements(): any[];
        getUniqueCode(): number;
        key: string;
        constructor(expression: string, label: string, key: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IStiMeasureMeter = Stimulsoft.Base.Meters.IStiMeasureMeter;
    class StiMeasureTransformationMeter extends StiDataTransformationMeter implements IStiMeasureMeter {
        private static ImplementsStiMeasureTransformationMeter;
        implements(): any[];
        getUniqueCode(): number;
        key: string;
        constructor(expression: string, label: string, key: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiSqlDatabase extends StiDatabase implements IStiJsonReportObject {
        private static encryptedId;
        createNew(): StiDatabase;
        get serviceName(): string;
        set serviceName(value: string);
        get componentId(): StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get connectionType(): StiConnectionType;
        private _connectionString;
        get connectionString(): string;
        set connectionString(value: string);
        get connectionStringEncrypted(): string;
        set connectionStringEncrypted(value: string);
        private _promptUserNameAndPassword;
        get promptUserNameAndPassword(): boolean;
        set promptUserNameAndPassword(value: boolean);
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        applyDatabaseInformation(information: StiDatabaseInformation, report: StiReport, informationAll?: StiDatabaseInformation): void;
        protected applyDatabaseInformationTables(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation): void;
        protected applyDatabaseInformationViews(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation): void;
        protected applyDatabaseInformationProcedures(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation): void;
        protected applyDatabaseInformationSource(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation, dataTable: DataTable, type?: StiSqlSourceType): void;
        getDatabaseInformationAsync(dictionary: StiDictionary): StiPromise<StiDatabaseInformation>;
        private static getDatabaseInformationTables;
        private static getDatabaseInformationViews;
        private static getDatabaseInformationProcedures;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiCustomDatabase extends StiSqlDatabase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static registerCustomDatabase(options: {
            serviceName: string;
            sampleConnectionString: string;
            process: (command: any, callback: (result: any) => void) => void;
        }): void;
        createNew(): StiDatabase;
        private _serviceName;
        get serviceName(): string;
        set serviceName(value: string);
        createDataSource(nameInSource: string, name: string): StiCustomSource;
        getDataAdapter(): StiSqlAdapterService;
        getDataAdapterType(): Stimulsoft.System.Type;
        protected applyDatabaseInformationSource(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation, dataTable: DataTable, type?: StiSqlSourceType): void;
        private _sampleConnectionString;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiUndefinedDatabase extends StiDatabase {
        createNew(): StiDatabase;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    enum StiConnectionType {
        Sql = 0,
        NoSql = 1,
        Azure = 2,
        Google = 3,
        OnlineServices = 4,
        Other = 5,
        Rest = 6,
        Custom = 7
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiDataWorldConnector = Stimulsoft.Base.StiDataWorldConnector;
    class StiNoSqlDatabase extends StiDatabase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get connectionType(): StiConnectionType;
        connectionString: string;
        get connectionStringEncrypted(): string;
        set connectionStringEncrypted(value: string);
        promptUserNameAndPassword: boolean;
        get canEditConnectionString(): boolean;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        applyDatabaseInformation(information: StiDatabaseInformation, report: StiReport, informationAll?: StiDatabaseInformation): void;
        protected applyDatabaseInformationSource(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation, dataTable: DataTable, type?: StiSqlSourceType): void;
        getDatabaseInformation(): StiDatabaseInformation;
        protected getDatabaseInformationTables(dataSchema: StiDataSchema): DataTable[];
        createDataSource(nameInSource: string, name: string): StiNoSqlSource;
        getConnectionStringHelper(): string;
        createConnector(connectionString?: string): StiDataWorldConnector;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiAzureBlobStorageDatabase extends StiNoSqlDatabase {
        get connectionType(): StiConnectionType;
        get componentId(): StiComponentId;
        createNew(): StiDatabase;
        get serviceName(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiAzureSqlDatabase extends StiSqlDatabase {
        get connectionType(): StiConnectionType;
        createNew(): StiDatabase;
        getDataAdapterType(): Stimulsoft.System.Type;
        get serviceName(): string;
        getSampleConnectionString(): string;
        getConnectionStringHelper(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiAzureTableStorageDatabase extends StiNoSqlDatabase {
        get connectionType(): StiConnectionType;
        get componentId(): StiComponentId;
        createNew(): StiDatabase;
        get serviceName(): string;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiCosmosDbDatabase extends StiNoSqlDatabase {
        get componentId(): StiComponentId;
        get connectionType(): StiConnectionType;
        createNew(): StiDatabase;
        get serviceName(): string;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Helpers {
    import StiDataLoaderHelperData = Stimulsoft.Base.StiDataLoaderHelperData;
    class StiUniversalDataLoader {
        static loadMutiple(report: StiReport, path: string, filter: string, binary: boolean, headers: {
            key: string;
            value: string;
        }[]): StiDataLoaderHelperData[];
        static loadSingle(report: StiReport, path: string, binary: boolean, headers: {
            key: string;
            value: string;
        }[]): StiDataLoaderHelperData;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCsvDatabase extends StiFileDatabase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get serviceName(): string;
        createNew(): StiDatabase;
        get componentId(): StiComponentId;
        separator: string;
        codePage: number;
        private getDataSet;
        getDatabaseInformation(dictionary: StiDictionary): StiDatabaseInformation;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        constructor(name?: string, pathData?: string, codePage?: number, separator?: string, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDBaseDatabase extends StiFileDatabase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        createNew(): StiDatabase;
        get serviceName(): string;
        get componentId(): StiComponentId;
        codePage: number;
        constructor(name?: string, pathData?: string, codePage?: number, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiExcelDatabase extends StiFileDatabase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        createNew(): StiDatabase;
        get serviceName(): string;
        get componentId(): StiComponentId;
        private _firstRowIsHeader;
        get firstRowIsHeader(): boolean;
        set firstRowIsHeader(value: boolean);
        getDatabaseInformation(dictionary: StiDictionary): StiDatabaseInformation;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        private getDataSet;
        getDataSetPrivate(workbook: Stimulsoft.ExternalLibrary.XLSX.IWorkBook): DataSet;
        private getType1;
        constructor(name?: string, pathData?: string, key?: string, firstRowIsHeader?: boolean);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiGisDataType = Stimulsoft.Base.StiGisDataType;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiGisDatabase extends StiFileDatabase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        separator: string;
        dataType: StiGisDataType;
        createNew(): StiDatabase;
        get serviceName(): string;
        constructor(name?: string, pathData?: string, key?: string, dataType?: StiGisDataType);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiRelationDirection = Stimulsoft.Base.StiRelationDirection;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiPromise = Stimulsoft.System.StiPromise;
    import StiDatabase = Stimulsoft.Report.Dictionary.StiDatabase;
    class StiJsonDatabase extends StiFileDatabase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        createNew(): StiDatabase;
        get serviceName(): string;
        relationDirection: StiRelationDirection;
        private getDataSet;
        private getDataSetAsync;
        getDatabaseInformation(dictionary: StiDictionary): StiDatabaseInformation;
        getDatabaseInformationAsync(dictionary: StiDictionary): StiPromise<StiDatabaseInformation>;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        regDataAsync(dictionary: StiDictionary, loadData: boolean): StiPromise<void>;
        constructor(name?: string, pathData?: string, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiPromise = Stimulsoft.System.StiPromise;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiDatabase = Stimulsoft.Report.Dictionary.StiDatabase;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiXmlDatabase extends StiFileDatabase implements IStiJsonReportObject {
        private adonetErrorMessage;
        createNew(): StiDatabase;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get serviceName(): string;
        private _pathSchema;
        get pathSchema(): string;
        set pathSchema(value: string);
        private _xmlType;
        get xmlType(): StiXmlType;
        set xmlType(value: StiXmlType);
        private getDataSet;
        private getDataSetAsync;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        regDataAsync(dictionary: StiDictionary, loadData: boolean): StiPromise<void>;
        getDatabaseInformation(dictionary: StiDictionary): StiDatabaseInformation;
        getDatabaseInformationAsync(dictionary: StiDictionary): StiPromise<StiDatabaseInformation>;
        constructor(name?: string, pathSchema?: string, pathData?: string, key?: string, xmlType?: StiXmlType);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiBigQueryDatabase extends StiNoSqlDatabase {
        get connectionType(): StiConnectionType;
        get componentId(): StiComponentId;
        createNew(): StiDatabase;
        get serviceName(): string;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiFirebaseDatabase extends StiNoSqlDatabase {
        get connectionType(): StiConnectionType;
        get componentId(): StiComponentId;
        createNew(): StiDatabase;
        get serviceName(): string;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiGoogleSheetsDatabase extends StiDatabase {
        get componentId(): StiComponentId;
        clientId: string;
        clientSecret: string;
        spreadsheetId: string;
        firstRowIsHeader: boolean;
        createNew(): StiDatabase;
        get serviceName(): string;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, key?: string, clientId?: string, clientSecret?: string, spreadsheetId?: string, firstRowIsHeader?: boolean);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiMongoDbDatabase extends StiNoSqlDatabase {
        createNew(): StiDatabase;
        get componentId(): StiComponentId;
        createDataSource(nameInSource: string, name: string): StiNoSqlSource;
        get serviceName(): string;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import StiDataWorldConnector = Stimulsoft.Base.StiDataWorldConnector;
    class StiDataWorldDatabase extends StiNoSqlDatabase {
        get serviceName(): string;
        get connectionType(): StiConnectionType;
        get owner(): string;
        get token(): string;
        get database(): string;
        createNew(): StiDatabase;
        get componentId(): StiComponentId;
        getSampleConnectionString(): string;
        createConnector(connectionString?: string): StiDataWorldConnector;
        getDataAdapterType(): Stimulsoft.System.Type;
        createDataSource(nameInSource: string, name: string): StiNoSqlSource;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiODataDatabase extends StiSqlDatabase {
        createNew(): StiDatabase;
        get serviceName(): string;
        get componentId(): StiComponentId;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getConnectionStringHelper(): string;
        mapUserNameAndPassword(userName: string, password: string): string;
        get connectionType(): StiConnectionType;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    import StiSqlDatabase = Stimulsoft.Report.Dictionary.StiSqlDatabase;
    class StiQuickBooksDatabase extends StiSqlDatabase {
        get connectionType(): StiConnectionType;
        createNew(): StiDatabase;
        get serviceName(): string;
        getSampleConnectionString(): string;
        get componentId(): StiComponentId;
        getDataAdapterType(): Type;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiDB2Database extends StiSqlDatabase {
        get componentId(): StiComponentId;
        createNew(): StiDatabase;
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiDotConnectUniversalDatabase extends StiSqlDatabase {
        get componentId(): StiComponentId;
        createNew(): StiDatabase;
        get serviceName(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiFirebirdDatabase extends StiSqlDatabase {
        get componentId(): StiComponentId;
        get serviceName(): string;
        createNew(): StiDatabase;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiInformixDatabase extends StiSqlDatabase {
        get componentId(): StiComponentId;
        createNew(): StiDatabase;
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiMSAccessDatabase extends StiSqlDatabase {
        get componentId(): StiComponentId;
        createNew(): StiDatabase;
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiMySqlDatabase extends StiSqlDatabase {
        get componentId(): StiComponentId;
        createNew(): StiDatabase;
        get serviceName(): string;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiOdbcDatabase extends StiSqlDatabase {
        get componentId(): StiComponentId;
        createNew(): StiDatabase;
        get serviceName(): string;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiOleDbDatabase extends StiSqlDatabase {
        get componentId(): StiComponentId;
        createNew(): StiDatabase;
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiOracleDatabase extends StiSqlDatabase {
        get componentId(): StiComponentId;
        get serviceName(): string;
        createNew(): StiDatabase;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiPostgreSQLDatabase extends StiSqlDatabase {
        get componentId(): StiComponentId;
        get serviceName(): string;
        createNew(): StiDatabase;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiSQLiteDatabase extends StiSqlDatabase {
        get componentId(): StiComponentId;
        createNew(): StiDatabase;
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiSqlCeDatabase extends StiSqlDatabase {
        get componentId(): StiComponentId;
        createNew(): StiDatabase;
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiSybaseAdsDatabase extends StiSqlDatabase {
        get componentId(): StiComponentId;
        createNew(): StiDatabase;
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiSybaseDatabase extends StiSqlDatabase {
        get componentId(): StiComponentId;
        createNew(): StiDatabase;
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiTeradataDatabase extends StiSqlDatabase {
        get componentId(): StiComponentId;
        createNew(): StiDatabase;
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiVistaDBDatabase extends StiSqlDatabase {
        get componentId(): StiComponentId;
        createNew(): StiDatabase;
        get serviceName(): string;
        getSampleConnectionString(): string;
        getDataAdapterType(): Stimulsoft.System.Type;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import List = Stimulsoft.System.Collections.List;
    import IStiAppFunction = Stimulsoft.Base.IStiAppFunction;
    import IComparable = Stimulsoft.System.IComparable;
    import Type = Stimulsoft.System.Type;
    class StiFunction implements IComparable, IStiAppFunction {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        compareTo(obj: any): number;
        getKey(): string;
        setKey(key: string): void;
        getName(): string;
        invoke(args: List<any>): any;
        key: string;
        private _useFullPath;
        get useFullPath(): boolean;
        set useFullPath(value: boolean);
        private _category;
        get category(): string;
        set category(value: string);
        private _groupFunctionName;
        get groupFunctionName(): string;
        set groupFunctionName(value: string);
        private _functionName;
        get functionName(): string;
        set functionName(value: string);
        private _description;
        get description(): string;
        set description(value: string);
        private _typeOfFunction;
        get typeOfFunction(): string;
        set typeOfFunction(value: string);
        private _returnType;
        get returnType(): Type;
        set returnType(value: Type);
        private _returnDescription;
        get returnDescription(): string;
        set returnDescription(value: string);
        private _argumentTypes;
        get argumentTypes(): Type[];
        set argumentTypes(value: Type[]);
        private _argumentNames;
        get argumentNames(): string[];
        set argumentNames(value: string[]);
        private _argumentDescriptions;
        get argumentDescriptions(): string[];
        set argumentDescriptions(value: string[]);
        jsFunction: Function;
        toString(): string;
        getLongFunctionString(language: StiReportLanguageType): string;
        getFunctionString(language: StiReportLanguageType, addFunctionName?: boolean): string;
        convertTypeToString(typeT: Type, language: StiReportLanguageType): string;
        constructor(category: string, groupFunctionName: string, functionName: string, description: string, typeOfFunction: string, returnType: Type, returnDescription?: string, argumentTypes?: Type[], argumentNames?: string[], argumentDescriptions?: string[]);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiFunctionsMath {
        private static isCreated;
        static create(): void;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiFunctionsPrintState {
        private static isCreated;
        static create(): void;
        static isNull(dataSource: any, dataColumn: string): boolean;
        static next(dataSource: any, dataColumn: string): any;
        static nextIsNull(dataSource: any, dataColumn: string): any;
        static previous(dataSource: any, dataColumn: string): any;
        static previousIsNull(dataSource: any, dataColumn: string): any;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiFunctionsProgrammingShortcut {
        private static isCreated;
        static create(): void;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import DateTime = Stimulsoft.System.DateTime;
    class StiFunctionsStrings {
        private static isCreated;
        static create(): void;
        static toProperCase(str: string): string;
        static substring(str: any, startIndex: number, length: number): string;
        static left(str: any, length: number): string;
        static right(str: any, length: number): string;
        static mid(str: any, startIndex: number, length: number): string;
        static roman(value: number): string;
        static abc(value: number | string): string;
        static arabic(value: number | string): string;
        static persian(value: number | string): string;
        static toWords(value: number, upperCase?: boolean, femaleEs?: boolean): string;
        static dateToStr(value: DateTime, upperCase?: boolean): string;
        static toCurrencyWords(value: number, upperCase: boolean, showCents: boolean, dollars?: string, cents?: string): string;
        static toCurrencyWords2(value: number, upperCase?: boolean | string, showCents?: boolean | number | string, dollars?: string | boolean, cents?: string): string;
        static toOrdinal(value: number): string;
        static toWordsRu(value: number, upperCase?: boolean): string;
        static strToDateTime(value: string): DateTime;
        static strToNullableDateTime(value: string): DateTime;
        static dateToStrRu(value: DateTime, upperCase?: boolean): string;
        static toCurrencyWordsRu(value: number, uppercase?: boolean, currency?: string, cents?: boolean): string;
        static toCurrencyWordsThai(value: number): string;
        private static SP_STRtNumToMny;
        private static SP_XCGtNumToMny;
        private static reverseString;
        private static tC_0;
        private static tC_1;
        private static tC_2;
        private static tC_3;
        private static tC_4;
        private static tC_5;
        private static tC_6;
        private static tC_7;
        private static tC_8;
        private static tC_9;
        private static tC_01;
        private static tC_10;
        private static tC_20;
        private static tC_100;
        private static tC_1000;
        private static tC_10000;
        private static tC_100000;
        private static tC_1000000;
        private static tC_Baht;
        private static tC_Satang;
        private static tC_Complete;
        static toWordsUa(value: number, uppercase?: boolean, gender?: Stimulsoft.Report.Func.Gender): string;
        static dateToStrUa(value: DateTime, upperCase?: boolean): string;
        static toCurrencyWordsUa(value: number, uppercase?: boolean, currency?: string, cents?: boolean): string;
        static toWordsPt(value: number, upperCase: boolean): string;
        static toCurrencyWordsPt(value: number, upperCase: boolean, showCents: boolean): string;
        static toCurrencyWordsPtBr(value: number): string;
        static DateToStrPt(value: DateTime): string;
        static dateToStrPtBr(value: DateTime): string;
        static toCurrencyWordsFr(numberr: number, currencyISO: string, decimals: number): string;
        static toCurrencyWordsEs(numberr: number, currencyISO: string, decimals: number): string;
        static toWordsEs(value: number, upperCase: boolean): string;
        static toWordsEs2(value: number, upperCase: boolean, female: boolean): string;
        static toCurrencyWordsNl(numberr: number, currencyISO: string, decimals: number): string;
        static toCurrencyWordsEnGb(numberr: number, currencyISO: string, decimals: number): string;
        static toWordsPl(value: number, upperCase: boolean): string;
        static dateToStrPl(value: DateTime, upperCase: boolean): string;
        static toCurrencyWordsPl(value: number, currencyISO: string, showCents: boolean, upperCase: boolean): string;
        static toWordsEnIn(value: number, blankIfZero: boolean): string;
        static toCurrencyWordsEnIn(currencyBasicUnit: string, currencyFractionalUnit: string, value: number, decimalPlaces: number, blankIfZero?: boolean): string;
        static toWordsFa(value: number): string;
        static toWordsZh(value: number): string;
        static toCurrencyWordsZh(value: number): string;
        static toWordsTr(value: number): string;
        static toCurrencyWordsTr(value: number): string;
        static toCurrencyWordsTr2(value: number, currencyName: string, showZeroCents: boolean): string;
        static toWordsAr(value: number): string;
        static toCurrencyWordsAr(value: number, currencyBasicUnit: string, currencyFractionalUnit: string): string;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiFunctionsTotals {
        private static isCreated;
        static create(): void;
    }
}
declare namespace Stimulsoft.Report.Engine {
    let IStiReportProperty: System.Interface<IStiReportProperty>;
    interface IStiReportProperty {
        getReport(): any;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiBand = Stimulsoft.Report.Components.StiBand;
    class StiBandsOnAllPages {
        private bands;
        engine: StiEngine;
        private _denyRendering;
        get denyRendering(): boolean;
        set denyRendering(value: boolean);
        add(dataBand: StiDataBand, band: StiBand): void;
        remove(dataBand: StiDataBand): void;
        private allowRenderBand;
        renderAsync(): Promise<void>;
        render(): void;
        private renderBandAsync;
        private renderBand;
        isBandInBandsList(band: StiBand): boolean;
        constructor(engine: StiEngine);
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiBreakableHelper {
        engine: StiEngine;
        isCanBreak(container: StiContainer): boolean;
        isNeedBreak(container: StiContainer): boolean;
        breakAsync(originalContainer: StiContainer): Promise<StiContainer>;
        break(originalContainer: StiContainer): StiContainer;
        setCanBreak(container: StiContainer): void;
        processBreakableAsync(container: StiContainer): Promise<StiContainer>;
        processBreakable(container: StiContainer): StiContainer;
        constructor(engine: StiEngine);
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiColumnDirection = Stimulsoft.Report.Components.StiColumnDirection;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiColumnsContainer extends StiContainer {
        private countOfItems;
        columns: number;
        columnWidth: number;
        columnGaps: number;
        columnDirection: StiColumnDirection;
        rightToLeft: boolean;
        minRowsInColumn: number;
        private engine;
        addContainer(container: StiContainer): void;
        howMuchAdditionalSpaceNeeded(currentHeight: number, container: StiContainer): number;
        finishColumns(onlyCalc?: boolean): number;
        getCurrentColumn(): number;
        getLengthOfLastRow(): number;
        constructor(engine?: StiEngine);
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    class StiColumnsOnDataBand {
        engine: StiEngine;
        private _enabled;
        get enabled(): boolean;
        set enabled(value: boolean);
        renderColumnsAsync(dataBand: StiDataBand): Promise<StiColumnsContainer>;
        renderColumns(dataBand: StiDataBand): StiColumnsContainer;
        getColumns(): StiColumnsContainer;
        createColumns(dataBand: StiDataBand): StiColumnsContainer;
        constructor(engine: StiEngine);
    }
}
declare namespace Stimulsoft.Report.Engine {
    class StiColumnsOnPanel {
        engine: StiEngine;
        get count(): number;
        get rightToLeft(): boolean;
        get columnGaps(): number;
        private _currentColumn;
        get currentColumn(): number;
        set currentColumn(value: number);
        getColumnWidth(): number;
        constructor(engine: StiEngine);
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiEmptyBandsHelper {
        engine: StiEngine;
        private emptyBand;
        register(emptyBands: StiComponentsCollection): void;
        clear(): void;
        private createEmptyBandContainerAsync;
        private createEmptyBandContainer;
        renderAsync(containerForRender: StiContainer, selectedContainer: StiContainer): Promise<void>;
        render(containerForRender: StiContainer, selectedContainer: StiContainer): void;
        constructor(engine: StiEngine);
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiBookmark = Stimulsoft.Report.Components.StiBookmark;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiFooterBand = Stimulsoft.Report.Components.StiFooterBand;
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import IStiPageBreak = Stimulsoft.Report.Components.IStiPageBreak;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiSimpleText = Stimulsoft.Report.Components.StiSimpleText;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiEngine {
        firstPassPointer: StiBookmark;
        isDynamicBookmarksMode: boolean;
        isCrossBandsMode: boolean;
        isFirstDataBandOnPage: boolean;
        isLastDataBandOnPage: boolean;
        printOnAllPagesIgnoreList: Hashtable;
        private printOnAllPagesIgnoreList2;
        bandsOnAllPages: StiBandsOnAllPages;
        denyRenderMasterComponentsInContainer: boolean;
        printAtBottom: StiPrintAtBottom;
        footersOnAllPages: StiFootersOnAllPages;
        staticBands: StiStaticBandsHelper;
        threads: StiThreads;
        breakable: StiBreakableHelper;
        denyChangeThread: boolean;
        slaveEngines: Hashtable<string, StiEngine>;
        masterEngine: StiEngine;
        emptyBands: StiEmptyBandsHelper;
        pageNumbers: StiPageNumberHelper;
        columnsOnDataBand: StiColumnsOnDataBand;
        columnsOnPanel: StiColumnsOnPanel;
        freeSpace: number;
        crossFreeSpace: number;
        positionX: number;
        positionY: number;
        positionBottomY: number;
        containerForRender: StiContainer;
        page: StiPage;
        templatePage: StiPage;
        templateContainer: StiContainer;
        report: StiReport;
        masterReport: StiReport;
        ignoreUnlimitedHeightForNewPage: boolean;
        keepFirstDetailTogetherList: Hashtable;
        keepFirstDetailTogetherTablesList: Hashtable;
        specialContainerHeight: number;
        specialContainerHeight2: number;
        static specialContainerHeight2: number;
        startIndexPageForPageTotal: number;
        indexPageForPageTotal: number;
        private childsBandHash;
        silentMode: boolean;
        renderState: StiRenderState;
        indexOfLatestDataBand: StiIndex;
        generateNewPageBeforeBand: boolean;
        ignoreSkipFirst: boolean;
        generateNewColumnBeforeBand: boolean;
        pageBreakSkipFirstCollection: Hashtable;
        indexOfStartList: number;
        skipFirstPageBeforePrintEvent: boolean;
        firstCallNewPage: boolean;
        denyClearPrintOnAllPagesIgnoreList: boolean;
        duplilcatesLastValues: Hashtable;
        anchorsArguments: Hashtable;
        private needResetPageNumberForNewPage;
        private _parserConversionStore;
        get parserConversionStore(): Hashtable;
        set parserConversionStore(value: Hashtable);
        hashParentStyles: Hashtable;
        private _hashUseParentStyles;
        get hashUseParentStyles(): Hashtable;
        set hashUseParentStyles(value: Hashtable);
        lastInvokeTextProcessValueEventArgsValue: any;
        atLeastOneDatabandRenderedOnPage: boolean;
        lastFreeSpaceOnPageAfterNewList: number;
        bandsInProgress: StiBand[];
        allowEndOfPageProcessing: boolean;
        private flagRenderColumnsOnDataBandOnNewPage;
        private componentPlacementRemakeTable;
        hashCheckSize: Hashtable;
        hashDataSourceReferencesCounter: Hashtable;
        offsetNewColumnY: number;
        latestProgressValue: number;
        newListAsync(skipStaticBands?: boolean): Promise<void>;
        newList(skipStaticBands?: boolean): void;
        newColumnAsync(ignoreKeepContainers?: boolean): Promise<void>;
        newColumn(ignoreKeepContainers?: boolean): void;
        newPageTime: number;
        newPageAsync(ignoreKeepContainers?: boolean): Promise<void>;
        newPageAsync2(ignoreKeepContainers?: boolean): Promise<void>;
        newPage(ignoreKeepContainers?: boolean): void;
        private newContainerAsync;
        private newContainer;
        newDestinationAsync(ignoreKeepContainers?: boolean): Promise<void>;
        newDestination(ignoreKeepContainers?: boolean): void;
        addFooterMarker(footerMaster: StiFooterBand): void;
        addKeepLevelAtLatestDataBand(): void;
        addLevel(): void;
        removeLevel(): void;
        private getChildBands;
        clearPageBreakSkipFirst(): void;
        canGenerateNewContainer(pageBreak: IStiPageBreak): boolean;
        removeBandFromPageBreakSkipList(pageBreak: IStiPageBreak): void;
        processPageAfterRendering(page: StiPage, final: boolean): void;
        processLastPageAfterRendering(): void;
        private processRendering;
        private reprocessRuntimeVariables;
        finalClearAsync(): Promise<void>;
        finalClear(): void;
        private isPrintAtBottomOrFooterOnAllPages;
        private changeEngineParamsByKeep;
        private setNewColumnParameters;
        setNewPageParameters(): void;
        private processNewContainerBeforeAsync;
        private processNewContainerBefore;
        private processNewContainerAfter;
        private processNewContainerInDetailBandsAsync;
        private processNewContainerInDetailBands;
        private searchStartOfKeepContainer;
        private moveKeepComponentsOnNextContainerAsync;
        private moveKeepComponentsOnNextContainer;
        private correctPrintOnAllPagesIgnoreListBeforeNewList;
        private isNeedToPrintOddEven;
        private isNeedToSkip;
        renderFootersOnAllPages(outContainer: StiContainer, startIndex?: number, REFmarkerContainer?: any): void;
        renderEmptyBandsAsync(containerForRender: StiContainer, selectedContainer: StiContainer): Promise<void>;
        renderEmptyBands(containerForRender: StiContainer, selectedContainer: StiContainer): void;
        renderPrintAtBottom(container: StiContainer, startIndex: number, markerContainer: StiContainer): void;
        finishContainer(containerForRender: StiContainer): void;
        finishResetPageNumberContainer(containerForRender: StiContainer, isFinal: boolean): void;
        finishColumns(containerForRender: StiContainer): void;
        addContainerToDestination(container: StiContainer): void;
        invokePageAfterPrint(): void;
        addPageToRenderedPages(page: StiPage): void;
        private checkFreeSpace1Async;
        private checkFreeSpace1;
        private checkFreeSpace2Async;
        private checkFreeSpace2;
        private storeLatestDataBand;
        private setReportVariables;
        checkForDuplicate(textName: string, value: string, tag: string): boolean;
        resetProcessingDuplicates1(componentName: string): void;
        resetProcessingDuplicates2(component: StiSimpleText): void;
        getSumTagsOnPage(page: StiPage, componentName: string): number;
        getComponentByNameFromRenderedPage(page: StiPage, componentName: string): StiComponent;
        renderBandAsync(band: StiBand, ignorePageBreaks?: boolean, allowRenderingEvents?: boolean): Promise<StiComponentsCollection>;
        renderBand(band: StiBand, ignorePageBreaks?: boolean, allowRenderingEvents?: boolean): StiComponentsCollection;
        private internalRenderBandAsync;
        private internalRenderBand;
        private checkContainerOnTable;
        renderContainerAsync(container: StiContainer, isPrintAtBottom?: boolean, isFooterOnAllPages?: boolean): Promise<StiContainer>;
        renderContainer(container: StiContainer, isPrintAtBottom?: boolean, isFooterOnAllPages?: boolean): StiContainer;
        private internalRenderColumnsContainer;
        private internalRenderContainerToColumnsAsync;
        private internalRenderContainerToColumns;
        private internalRenderContainerAsync;
        private internalRenderContainer;
        constructor(report: StiReport);
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiFooterMarkerContainer extends StiContainer {
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiFootersOnAllPages {
        private bands;
        engine: StiEngine;
        add(container: StiContainer): void;
        canProcess(band: StiBand): boolean;
        render(outContainer: StiContainer, startIndex: number, REFmarkerContainer: any): void;
        constructor(engine: StiEngine);
    }
}
declare namespace Stimulsoft.Report.Engine {
    class StiIndex {
        index: number;
        indexInColumnContainer: number;
        constructor(index: number, indexInColumnContainer?: number);
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiLevelContainer extends StiContainer {
    }
}
declare namespace Stimulsoft.Report.Engine {
    class StiLevelEndContainer extends StiLevelContainer {
        constructor();
    }
}
declare namespace Stimulsoft.Report.Engine {
    class StiLevelStartContainer extends StiLevelContainer {
        constructor();
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiNewPageContainer extends StiContainer {
        constructor();
    }
}
declare namespace Stimulsoft.Report.Engine {
    import IStiOddEvenStyles = Stimulsoft.Report.Components.IStiOddEvenStyles;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    class StiOddEvenStylesHelper {
        static applyOddEvenStyles(report: StiReport, styles: IStiOddEvenStyles, cont: StiContainer): StiBaseStyle;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiSubReport = Stimulsoft.Report.Components.StiSubReport;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiPageHelper {
        static createListOfDataBands(page: StiPage, dataBandsOnPage: StiDataBand[], dataBandsInContainers: StiDataBand[], subReportsOnPage: StiSubReport[], crossTabsOnPage: StiCrossTab[]): void;
        static getReportTitles(page: StiPage): Stimulsoft.Report.Components.StiReportTitleBand[];
        static getReportSummaries(page: StiPage): Stimulsoft.Report.Components.StiReportSummaryBand[];
        static renderSimpleComponentsAsync(page: StiPage, outContainer: StiContainer): Promise<void>;
        static renderSimpleComponents(page: StiPage, outContainer: StiContainer): void;
        private static checkContainerForBandsAndOtherContainers;
        static prepareBookmark(page: StiPage): void;
        static preparePointer(page: StiPage): void;
        static renderPageAsync(page: StiPage): Promise<void>;
        static renderPage(page: StiPage): void;
        static renderOverlaysAsync(masterPage: StiPage, renderedPage: StiPage): Promise<void>;
        static renderOverlays(masterPage: StiPage, renderedPage: StiPage): void;
        static getPageFromTemplateAsync(templatePage: StiPage): Promise<StiPage>;
        static getPageFromTemplate(templatePage: StiPage): StiPage;
    }
}
declare namespace Stimulsoft.Report.Engine {
    class StiPageNumber {
        resetPageNumber: boolean;
        pageNumber: number;
        totalPageCount: number;
        pageNumberThrough: number;
        totalPageCountThrough: number;
        segmentPerWidth: number;
        segmentPerHeight: number;
        get step(): number;
        fixedPosition: boolean;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiPageNumberCollection extends CollectionBase<StiPageNumber> {
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiPageNumberHelper {
        private engine;
        private finished;
        private _clearPageNumbersOnFinish;
        get clearPageNumbersOnFinish(): boolean;
        set clearPageNumbersOnFinish(value: boolean);
        private _pageNumbers;
        get pageNumbers(): StiPageNumberCollection;
        set pageNumbers(value: StiPageNumberCollection);
        resetPageNumber(pageIndex?: number): void;
        addPageNumber(pageIndex: number, segmentPerWidth: number, segmentPerHeight: number): void;
        getPageNumber(param1: StiPage | number | any): number;
        getTotalPageCount(param1: StiPage | number | any): number;
        getPageNumberThrough(param1: StiPage | number | any): number;
        getTotalPageCountThrough(pageIndex: number): number;
        private setSystemVariables;
        processPageNumbers(): void;
        clear(): void;
        clearNotFixed(): void;
        constructor(engine: StiEngine);
    }
}
declare namespace Stimulsoft.Report.Engine {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    enum TypeOfDuplicates {
        Text = 0,
        Image = 1
    }
    class StiMergeComparer implements IComparer<StiComponent> {
        compare(x: StiComponent, y: StiComponent): number;
    }
    class StiPostProcessDuplicatesHelper {
        private static isImageEqual;
        static postProcessDuplicates(comps: StiComponentsCollection, parentCont: Hashtable, typeOfDuplicates?: TypeOfDuplicates): void;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    import StiCrossLinePrimitive = Stimulsoft.Report.Components.StiCrossLinePrimitive;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiLinePrimitive = Stimulsoft.Report.Components.StiLinePrimitive;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiPostProcessProvider {
        private static nullGuid;
        static postProcessPages(pages: StiPagesCollection): void;
        private static removeAllPointPrimitives;
        static postProcessPrimitives(page: StiPagesCollection | Stimulsoft.Report.Components.StiPage): void;
        static postProcessPrimitivesInContainer(container: StiContainer): void;
        static postProcessPrimitivesInContainer2(container: StiContainer, pages: StiPagesCollection, REFstartPointsHash: any, REFendPointsHash: any, REFlines: any, REFendPoints: any): void;
        private static processOneEndPoint;
        private static processOnePrimitive;
        static addPrimitive(crossLine: StiCrossLinePrimitive, startPos: PointD, endPos: PointD, page: StiContainer): void;
        static copyStyles(dest: StiLinePrimitive, source: StiLinePrimitive): void;
        static postProcessPage(page: Stimulsoft.Report.Components.StiPage, isFirstPage: boolean, isLastPage: boolean, clearPage?: boolean): void;
        private static postProcessPrintOn;
        private static allowPrintOn;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiPrintAtBottom {
        private bands;
        engine: StiEngine;
        canProcess(band: StiBand): boolean;
        add(container: StiContainer): void;
        render(outContainer: StiContainer, startIndex: number, markerContainer: StiContainer): void;
        constructor(engine: StiEngine);
    }
}
declare namespace Stimulsoft.Report.Engine {
    class StiStaticBandsHelper {
        private denyReportBands;
        private denyPageBands;
        engine: StiEngine;
        private _reservedFreeSpace;
        get reservedFreeSpace(): number;
        private _reservedCrossFreeSpace;
        get reservedCrossFreeSpace(): number;
        private _reservedPositionX;
        get reservedPositionX(): number;
        private _reservedPositionY;
        get reservedPositionY(): number;
        private _reservedPositionBottomY;
        get reservedPositionBottomY(): number;
        renderAsync(): Promise<void>;
        render(): void;
        private renderTitleBeforeHeaderAsync;
        private renderTitleBeforeHeader;
        private renderHeaderBeforeTitleAsync;
        private renderHeaderBeforeTitle;
        private renderReportTitleBandsAsync;
        private renderReportTitleBands;
        private renderPageHeaderBandsAsync;
        private renderPageHeaderBands;
        private renderPageFooterBandsAsync;
        private renderPageFooterBands;
        private getPageHeaders;
        private getPageFooters;
        private getPageHeadersFromPage;
        private getPageFootersFromPage;
        constructor(engine: StiEngine);
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiThreads {
        isActive: boolean;
        currentPage: number;
        currentColumn: number;
        destinationName: string;
        newPageAsync(): Promise<void>;
        newPage(): void;
        selectThreadFromContainerAsync(container: StiContainer): Promise<void>;
        selectThreadFromContainer(container: StiContainer): void;
        createContainerEngineAsync(destinationName: string, report: StiReport, masterEngine: StiEngine, indexOfStartRenderedPages: number): Promise<StiEngine>;
        createContainerEngine(destinationName: string, report: StiReport, masterEngine: StiEngine, indexOfStartRenderedPages: number): StiEngine;
        getTemplateContainer(template?: StiContainer, name?: string): StiContainer;
        getDestinationContainer(): StiContainer;
        private getDestinationContainer2;
        engine: StiEngine;
        constructor(engine: StiEngine);
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiVariable = Stimulsoft.Report.Dictionary.StiVariable;
    class StiVariableHelper {
        private static reportToLabels;
        static fillItemsOfVariables(compiledReport: StiReport): boolean;
        static fillItemsOfVariable(variable: StiVariable, compiledReport: StiReport, REFmodified: {
            ref: boolean;
        }): boolean;
        private static getChecked;
        private static fillVariableList;
        private static isListType;
        private static isRangeType;
        static setDefaultValueForRequestFromUserVariables(compiledReport: StiReport, haveVars: boolean): void;
        static setDefaultValueForRequestFromUserVariablesAsync(compiledReport: StiReport, haveVars: boolean, allowParseQuery?: boolean): Promise<void>;
        static getDataSourcesWithRequestFromUserVariablesInCommand(report: StiReport): string[];
        private static checkExpressionForVariables;
        static setVariableValue(report: StiReport, variable: StiVariable, variableValue: any): void;
        static setVariableLabel(report: StiReport, variable: StiVariable, label: string): void;
        static getVariableLabel(report: StiReport, variableName: string): string;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiChartBuilder extends StiComponentBuilder {
        static renderAtEnd(masterChart: IStiChart): void;
        static renderChart(masterChart: IStiChart): StiComponent;
        prepare(masterComp: StiComponent): void;
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCloneBuilder extends StiContainerBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
        private isParentClonation;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiFooterBand = Stimulsoft.Report.Components.StiFooterBand;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    class StiFooterBandBuilder extends StiBandBuilder {
        static getMaster(masterFooterBand: StiFooterBand): StiDataBand;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiColumnFooterBandBuilder extends StiFooterBandBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiHeaderBand = Stimulsoft.Report.Components.StiHeaderBand;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    class StiHeaderBandBuilder extends StiBandBuilder {
        static getMaster(masterHeaderBand: StiHeaderBand): StiDataBand;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiColumnHeaderBandBuilder extends StiHeaderBandBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCrossLinePrimitiveBuilder extends StiComponentBuilder {
        prepare(masterComp: StiComponent): void;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    import StiCrossTabParams = Stimulsoft.Report.CrossTab.StiCrossTabParams;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiCrossHeader = Stimulsoft.Report.CrossTab.StiCrossHeader;
    class StiCrossTabBuilder extends StiContainerBuilder {
        static getCollapsingName(header: StiCrossHeader): string;
        static getCollapsingName2(componentName: string, level: number, value: string): string;
        static isCollapsed(masterHeader: StiCrossHeader): boolean;
        static isCollapsed2(masterHeader: StiCrossHeader, level: number, textValue: string): boolean;
        static setCollapsed(masterHeader: StiCrossHeader, isCollapsed: boolean): void;
        static makeHorAlignment(masterCrossTab: StiCrossTab, outContainer: StiContainer, startIndex: number, parentWidth: number, pageSegment: number): void;
        renderCrossTabOnPage(pars: StiCrossTabParams, master: StiCrossTab, destination: StiContainer, rect: Rectangle, endCol: any, endRow: any): void;
        makeHorAlignment(master: StiCrossTab, destination: StiContainer, startIndex: number, parentWidth: number, segmentPerWidth: number): void;
        finalizeCross(renderedComponent: StiContainer): void;
        private renderCrossTabSegment;
        private renderColHeaders;
        private allColFieldsPresentOnAllPages;
        private getEndColumn;
        private getEndRow;
        private renderRowHeaders;
        private renderCorner;
        renderCrossTabOnDataBand(pars: StiCrossTabParams, masterCrossTab: StiCrossTab, renderedComponent: StiContainer): StiComponent;
        renderCrossTabAsync(pars: StiCrossTabParams, masterCrossTab: StiCrossTab): Promise<StiComponent>;
        renderCrossTab(pars: StiCrossTabParams, masterCrossTab: StiCrossTab): StiComponent;
        renderCrossTabUnlimitedBreakable(pars: StiCrossTabParams, master: StiCrossTab, destination: StiContainer, rect: Rectangle): void;
        private getPageForCrossTab;
        private getActualHeaderRowCount;
        prepare(masterComp: StiComponent): void;
        unPrepare(masterComp: StiComponent): void;
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    import StiCrossTabParams = Stimulsoft.Report.CrossTab.StiCrossTabParams;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiCrossTabV2Builder extends StiContainerBuilder {
        renderCrossTabOnDataBand(pars: StiCrossTabParams, master: StiCrossTab, destination: StiContainer, rect: Rectangle): StiComponent;
        finalizeCross(renderedComponent: StiContainer): void;
        static makeHorAlignment(masterCrossTab: StiCrossTab, outContainer: StiContainer, startIndex: number, parentWidth: number, pageSegment: number): void;
        private getEndColumn;
        private getEndRow;
        private allColFieldsPresentOnAllPages;
        private renderColHeaders;
        private renderCrossTabSegment;
        private renderRowHeaders;
        private renderCorner;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiGaugeBuilder extends StiComponentBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiGroupFooterBand = Stimulsoft.Report.Components.StiGroupFooterBand;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiGroupFooterBandBuilder extends StiBandBuilder {
        static getMaster(masterFooterBand: StiGroupFooterBand): StiDataBand;
        setReportVariables(masterComp: StiComponent): void;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiHierarchicalBand = Stimulsoft.Report.Components.StiHierarchicalBand;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiHierarchicalBandBuilder extends StiDataBandBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
        private isCollapsed;
        static createIndention(masterHierarchical: StiHierarchicalBand, container: StiContainer, level: number): void;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiViewBuilder extends StiComponentBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiImageBuilder extends StiViewBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiMap = Stimulsoft.Report.Maps.StiMap;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiMapBuilder extends StiComponentBuilder {
        static renderMap(masterMap: StiMap): StiMap;
        prepare(masterComp: StiComponent): void;
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
        static tryToDecimal(value: any): number;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiPageBuilder extends StiContainerBuilder {
        prepare(masterComp: StiComponent): void;
        unPrepare(masterComp: StiComponent): void;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiPointPrimitiveBuilder extends StiComponentBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare namespace Stimulsoft.Report.Engine {
    class StiReportBuilder {
        static renderSingleReportAsync(masterReport: StiReport, renderState: StiRenderState): Promise<void>;
        static renderSingleReport(masterReport: StiReport, renderState: StiRenderState): void;
        static renderSubReportsAsync(ownerReport: StiReport, renderState: StiRenderState): Promise<void>;
        static renderSubReports(ownerReport: StiReport, renderState: StiRenderState): void;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiSimpleTextBuilder extends StiComponentBuilder {
        prepare(masterComp: StiComponent): void;
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiSparklineBuilder extends StiComponentBuilder {
        prepare(masterComp: StiComponent): void;
        internalRender(masterComp: StiComponent): StiComponent;
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        static getValuesFromValueDataColumn(sparkline: Stimulsoft.Report.Components.StiSparkline, maxRows?: number): number[];
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiSubReportBuilder extends StiContainerBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import List = Stimulsoft.System.Collections.List;
    import StiBookmarksCollection = Stimulsoft.Report.Components.StiBookmarksCollection;
    import StiTableOfContents = Stimulsoft.Report.Components.StiTableOfContents;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiTableOfContentsBuilder extends StiDataBandBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
        private static renderTextWithNoInformation;
        private static renderPanelWithBookmarks;
        private static renderPointers;
        static postProcessTableOfContents(report: StiReport): void;
        private static getPointers;
        private static getPointersForPostProcessing;
        static postProcessBookmarks2(comps: List<StiComponent>, masterComp: StiTableOfContents, resultComp: StiComponent): void;
        static postProcessBookmarks(comps: List<StiComponent>, baseName: string, panel: StiComponent, bookmarks: StiBookmarksCollection): void;
        private static getHyperlink;
        private static setOffSides;
        private static setOffSide2;
        private static getStyle;
        private static fullSize;
        private static indent;
        private static dotsString_;
        static get dotsString(): string;
    }
}
declare namespace Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiTextInCellsBuilder extends StiSimpleTextBuilder {
        internalRenderAsync(masterComp: StiComponent): Promise<StiComponent>;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiBandInfo extends StiComponentInfo {
        forceCanBreak: boolean;
        forceCanGrow: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiContainerInfo extends StiComponentInfo {
        dataBandPosition: number;
        dataSourceRow: Stimulsoft.System.Data.DataRow;
        businessObjectCurrent: any;
        isAutoRendered: boolean;
        ignoreResetPageNumber: boolean;
        isColumns: boolean;
        renderStep: number;
        setSegmentPerWidth: number;
        parentBand: StiBand;
    }
}
declare namespace Stimulsoft.Report.Components {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiDataBandInfo extends StiComponentInfo {
        groupHeaders: StiComponentsCollection;
        groupFooters: StiComponentsCollection;
        groupHeaderComponents: StiComponentsCollection;
        groupFooterComponents: StiComponentsCollection;
        detailDataBands: StiComponentsCollection;
        details: StiComponentsCollection;
        subReports: StiComponentsCollection;
        emptyBands: StiComponentsCollection;
        headers: StiComponentsCollection;
        hierarchicalHeaders: StiComponentsCollection;
        footersOnAllPages: StiComponentsCollection;
        footersOnLastPage: StiComponentsCollection;
        hierarchicalFooters: StiComponentsCollection;
        groupHeaderResults: boolean[];
        groupFooterResults: boolean[];
        groupHeaderCachedResults: boolean[][];
        groupFooterCachedResults: boolean[][];
        reportTitles: StiReportTitleBand[];
        reportSummaries: StiReportSummaryBand[];
        detailDataBandsFromSubReports: Hashtable;
        storedParentBookmark: StiBookmark;
        storedParentPointer: StiBookmark;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiFooterBandInfo extends StiComponentInfo {
        isTableFooter: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiGroupFooterBandInfo extends StiComponentInfo {
        printAtBottomComponent: StiComponent;
        groupHeader: StiGroupHeaderBand;
        isTableGroupFooter: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiGroupHeaderBandInfo extends StiComponentInfo {
        skipKeepGroups: boolean;
        groupFooter: StiGroupFooterBand;
        silentModeEnabled: boolean;
        oldSilentMode: boolean;
        isTableGroupHeader: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiHeaderBandInfo extends StiComponentInfo {
        isTableHeader: boolean;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiHierarchicalBandInfo extends StiComponentInfo {
        specifiedLevel: number;
        finalFooterCalculation: boolean;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiAfterSelectEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiCheckedChangedEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiClosedFormEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiClosingFormEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiEnterEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiFillDataEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiGetArgumentEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiGetBarCodeEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiGetDataUrlEventHandler: EventHandler;
    class StiGetDataUrlEventArgs extends EventArgs {
        value: string;
    }
}
declare namespace Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiGetDrillDownReportEventHandler: EventHandler;
    class StiGetDrillDownReportEventArgs extends EventArgs {
        report: StiReport;
        cancel: boolean;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiGetFilterEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiGetZipCodeEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiGotoCompEventHandler: EventHandler;
    class StiGotoCompEventArgs extends EventArgs {
        component: Stimulsoft.Report.Components.StiComponent;
        constructor(component: Stimulsoft.Report.Components.StiComponent);
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiLoadFormEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiMouseDownEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiMouseMoveEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiMouseUpEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiMoveFooterToBottomEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    let StiPaintEventHandler: EventHandler;
    class StiPaintEventArgs extends EventArgs implements ICloneable {
        clone(): any;
        context: any;
        get graphics(): Graphics;
        clipRectangle: RectangleD;
        drawChilds: boolean;
        cancel: boolean;
        drawBorderFormatting: boolean;
        drawTopmostBorderSides: boolean;
        constructor(context: any, clipRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiPositionChangedEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import StiExportService = Stimulsoft.Report.Export.StiExportService;
    import StiExportSettings = Stimulsoft.Report.Export.StiExportSettings;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let StiProcessExportEventHandler: EventHandler;
    class StiProcessExportEventArgs extends StiExportEventArgs {
        exportService: StiExportService;
        stream: MemoryStream;
        exportSettings: StiExportSettings;
        processed: boolean;
        constructor(format: StiExportFormat, exportService: StiExportService, stream: MemoryStream, settings: StiExportSettings);
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiSelectedIndexChangedEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiStateRestoreEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiStateSaveEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiValueChangedEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Export {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    let IStiExportService: System.Interface<IStiExportService>;
    interface IStiExportService {
        exportFormat: StiExportFormat;
        isStopped: boolean;
        multipleFiles: boolean;
        renderedPagesCount: number;
        currentPassNumber: number;
        maximumPassNumber: number;
        exportServiceId: string;
        invokeExporting(page: StiPage, pages: StiPagesCollection, currentPass: number, maximumPass: number): any;
        invokeExporting2(value: number, maximum: number, currentPass: number, maximumPass: number): any;
    }
}
declare namespace Stimulsoft.Report {
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    class StiPagesRange {
        static All: StiPagesRange;
        rangeType: StiRangeType;
        pageRanges: string;
        currentPage: number;
        equals(obj: any): boolean;
        getSelectedPages(originalPages: StiPagesCollection): StiPagesCollection;
        constructor(rangeType?: StiRangeType, pageRanges?: string, currentPage?: number);
    }
}
declare namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiOdsExportService: System.Interface<IStiOdsExportService>;
    interface IStiOdsExportService extends StiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
declare namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiOdtExportService: System.Interface<IStiOdtExportService>;
    interface IStiOdtExportService extends IStiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
declare namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiTxtExportService: System.Interface<IStiTxtExportService>;
    interface IStiTxtExportService extends IStiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
declare namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiCsvExportService: System.Interface<IStiCsvExportService>;
    interface IStiCsvExportService extends IStiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
declare namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiDataExportService: System.Interface<IStiDataExportService>;
    interface IStiDataExportService extends IStiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
declare namespace Stimulsoft.Report.Export {
    import Image = Stimulsoft.System.Drawing.Image;
    import ImageFormat = Stimulsoft.System.Drawing.Imaging.ImageFormat;
    class StiBarCodeSvgHelper {
        static getImage(svgData: StiSvgData, imageFormat?: ImageFormat): Image;
    }
}
declare namespace Stimulsoft.Report.Export {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiBrushSvgHelper {
        static hatchData: string[];
        static writeHatchBrush(writer: XmlTextWriter, brush: any): string;
        private static hexToByteString;
        static writeGlareBrush(writer: XmlTextWriter, brush: any, rect: RectangleD): string;
        static writeGradientBrush(writer: XmlTextWriter, brush: any, rect: RectangleD): string;
        static writeGlassBrush(writer: XmlTextWriter, brush: any, rect: RectangleD): string;
    }
}
declare namespace Stimulsoft.Report {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiCurveHelper {
        static cardinalSpline(pts: PointD[], closed: boolean): PointD[];
        private static calcCurveEnd;
        private static calcCurve;
    }
}
declare namespace Stimulsoft.Base.Context {
    import IAsIs = Stimulsoft.System.IAsIs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import Point = Stimulsoft.System.Drawing.Point;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiGeom implements IStiJsonReportObject, IAsIs {
        private static implementsStiGeom;
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        saveGeomListToJsonObject(geoms: StiSegmentGeom[], mode: StiJsonSaveMode): StiJson[];
        savePointDArrayToJsonObject(points: Point[]): StiJson[];
        saveBrushToJsonObject(brush: Color | StiBrush, mode: StiJsonSaveMode): string;
        saveRectToJsonObject(rect: Rectangle): StiJson;
        static savePointDToJsonObject(pos: Point): StiJson;
        static saveRectangleToJsonObject(rect: Rectangle): StiJson;
        static saveRectangleDToJsonObject(rect: Rectangle): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get type(): StiGeomType;
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiPushTranslateTransformGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        x: number;
        y: number;
        get type(): StiGeomType;
        constructor(x: number, y: number);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiPushRotateTransformGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        angle: number;
        get type(): StiGeomType;
        constructor(angle: number);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiAnimationGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        private _animation;
        get animation(): StiAnimation;
        interaction: StiInteractionDataGeom;
        constructor(animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiClusteredBarSeriesAnimationGeom extends StiAnimationGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        background: any;
        borderPen: StiPenGeom;
        columnRect: any;
        upMove: boolean;
        tag: any;
        value: number;
        toolTip: string;
        get type(): StiGeomType;
        constructor(background: any, borderPen: StiPenGeom, columnRect: any, value: number, toolTip: string, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiPopTransformGeom extends StiGeom implements IStiJsonReportObject {
        toolTip: string;
        get type(): StiGeomType;
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiBorderAnimationGeom extends StiAnimationGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        background: any;
        borderPen: StiPenGeom;
        rect: any;
        tag: any;
        toolTip: string;
        get type(): StiGeomType;
        constructor(background: any, borderPen: StiPenGeom, rect: any, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom, toolTip: string);
    }
}
declare namespace Stimulsoft.Base.Context {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiBorderGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        background: any;
        backgroundMouseOver: any;
        borderPen: StiPenGeom;
        rect: Rectangle;
        interaction: StiInteractionDataGeom;
        get type(): StiGeomType;
        constructor(background: any, backgroundMouseOver: any, borderPen: StiPenGeom, rect: Rectangle, interaction: StiInteractionDataGeom);
    }
}
declare namespace Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    class StiAnimation {
        constructor(duration: TimeSpan, beginTime: TimeSpan);
        duration: TimeSpan;
        beginTime: TimeSpan;
        get type(): StiAnimationType;
    }
}
declare namespace Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    class StiOpacityAnimation extends StiAnimation {
        constructor(duration: TimeSpan, beginTime: TimeSpan);
        get type(): StiAnimationType;
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiPushClipGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        clipRectangle: Rectangle;
        get type(): StiGeomType;
        constructor(clipRectangle: Rectangle);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiPopClipGeom extends StiGeom implements IStiJsonReportObject {
        toolTip: string;
        get type(): StiGeomType;
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiCurveGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        pen: StiPenGeom;
        tension: number;
        points: Point[];
        get type(): StiGeomType;
        constructor(pen: StiPenGeom, points: Point[], tension: number);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiEllipseGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        background: any;
        borderPen: StiPenGeom;
        rect: any;
        interaction: StiInteractionDataGeom;
        toolTip: string;
        get type(): StiGeomType;
        constructor(background: any, borderPen: StiPenGeom, rect: any, interaction: StiInteractionDataGeom, toolTip: string);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiShadowSides = Stimulsoft.Base.Drawing.StiShadowSides;
    class StiCachedShadowGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        rect: Rectangle;
        sides: StiShadowSides;
        isPrinting: boolean;
        get type(): StiGeomType;
        constructor(rect: Rectangle, sides: StiShadowSides, isPrinting: boolean);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiShadowGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        rect: Rectangle;
        radius: number;
        shadowContext: StiContext;
        get type(): StiGeomType;
        constructor(shadowContext: StiContext, rect: Rectangle, radius: number);
    }
}
declare namespace Stimulsoft.Base.Context {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiTextGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        text: string;
        font: StiFontGeom;
        isRounded: boolean;
        isRotatedText: boolean;
        brush: Color | StiBrush;
        location: Point | Rectangle;
        stringFormat: StiStringFormatGeom;
        angle: number;
        antialiasing: boolean;
        maximalWidth: number;
        rotationMode: Stimulsoft.Base.Drawing.StiRotationMode;
        toolTip: string;
        get type(): StiGeomType;
        constructor(text: string, font: StiFontGeom, brush: any, location: any, stringFormat: StiStringFormatGeom, angle: number, antialiasing: boolean, maximalWidth: number, rotationMode: Stimulsoft.Base.Drawing.StiRotationMode, isRotatedText: boolean, toolTip: string);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiPathGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        static getBoundsState: any;
        background: any;
        pen: StiPenGeom;
        rect: any;
        geoms: StiSegmentGeom[];
        interaction: StiInteractionDataGeom;
        toolTip: string;
        get type(): StiGeomType;
        constructor(background: any, pen: StiPenGeom, geoms: StiSegmentGeom[], rect: any, interaction: StiInteractionDataGeom, toolTip: string);
    }
}
declare namespace Stimulsoft.Base.Context {
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import StiGeomType = Stimulsoft.Base.Context.StiGeomType;
    class StiPushClipPathGeom extends StiGeom {
        geoms: StiSegmentGeom[];
        get type(): StiGeomType;
        constructor(geoms: StiSegmentGeom[]);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiSegmentGeom extends StiGeom implements IStiJsonReportObject {
        get type(): StiGeomType;
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiPieSegmentGeom extends StiSegmentGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        rect: Rectangle;
        startAngle: number;
        sweepAngle: number;
        animation: StiAnimation;
        constructor(rect: Rectangle, startAngle: number, sweepAngle: number, animation: StiAnimation);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiArcSegmentGeom extends StiSegmentGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        rect: Rectangle;
        startAngle: number;
        sweepAngle: number;
        constructor(rect: Rectangle, startAngle: number, sweepAngle: number);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiLineSegmentGeom extends StiSegmentGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        animation: StiAnimation;
        constructor(x1: number | Point, y1: number | Point, x2?: number, y2?: number, animation?: StiAnimation);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiLinesSegmentGeom extends StiSegmentGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        points: Point[];
        animation: StiAnimation;
        constructor(points: Point[], animation?: StiAnimation);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCurveSegmentGeom extends StiSegmentGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        tension: number;
        points: Point[];
        animation: StiAnimation;
        constructor(points: Point[], tension: number, animation?: StiAnimation);
    }
}
declare namespace Stimulsoft.Base.Context {
    class StiCloseFigureSegmentGeom extends StiSegmentGeom {
    }
}
declare namespace Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiColumnAnimation extends StiAnimation {
        constructor(valueFrom: number, rectFrom: Rectangle, duration: TimeSpan, beginTime: TimeSpan);
        valueFrom: number;
        rectFrom: Rectangle;
        get type(): StiAnimationType;
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiLabelAnimationGeom extends StiAnimationGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        text: string;
        font: StiFontGeom;
        textBrush: any;
        labelBrush: any;
        penBorder: StiPenGeom;
        rectangle: Rectangle;
        stringFormat: StiStringFormatGeom;
        angle: number;
        rotationMode: StiRotationMode;
        drawBorder: boolean;
        get type(): StiGeomType;
        constructor(text: string, font: StiFontGeom, textBrush: any, LabelBrush: any, penBorder: StiPenGeom, rect: Rectangle, sf: StiStringFormatGeom, rotationMode: StiRotationMode, angle: number, drawBorder: boolean, animation: StiAnimation);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiShadowAnimationGeom extends StiAnimationGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        rect: Rectangle;
        radiusX: number;
        radiusY: number;
        shadowWidth: number;
        get type(): StiGeomType;
        constructor(rect: Rectangle, radiusX: number, radiusY: number, shadowWidth: number, animation: StiAnimation);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiPathAnimationGeom extends StiAnimationGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        static getBoundsState: any;
        background: any;
        pen: StiPenGeom;
        rect: any;
        geoms: StiSegmentGeom[];
        tag: any;
        get type(): StiGeomType;
        constructor(background: any, pen: StiPenGeom, geoms: StiSegmentGeom[], rect: any, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCurveAnimationGeom extends StiAnimationGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        pen: StiPenGeom;
        points: Point[];
        tension: number;
        get type(): StiGeomType;
        constructor(pen: StiPenGeom, points: Point[], tension: number, animation: StiAnimation);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiClusteredColumnSeriesAnimationGeom extends StiAnimationGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        background: any;
        borderPen: StiPenGeom;
        columnRect: any;
        toolTip: string;
        tag: any;
        value: number;
        get type(): StiGeomType;
        constructor(background: any, borderPen: StiPenGeom, columnRect: any, value: number, toolTip: string, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiEllipseAnimationGeom extends StiAnimationGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        background: any;
        borderPen: StiPenGeom;
        rect: any;
        tag: any;
        toolTip: string;
        get type(): StiGeomType;
        constructor(background: any, borderPen: StiPenGeom, rect: any, toolTip: string, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiLinesAnimationGeom extends StiAnimationGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        pen: StiPenGeom;
        points: Point[];
        get type(): StiGeomType;
        constructor(pen: StiPenGeom, points: Point[], animation: StiAnimation);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiPathElementAnimationGeom extends StiAnimationGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        background: any;
        borderPen: StiPenGeom;
        rect: any;
        pathGeoms: StiSegmentGeom[];
        tag: any;
        toolTip: string;
        get type(): StiGeomType;
        constructor(background: any, borderPen: StiPenGeom, pathGeoms: StiSegmentGeom[], rect: any, toolTip: string, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
declare namespace Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiLabelAnimation extends StiAnimation {
        constructor(valueFrom: number, value: number, pointFrom: Point, point: Point, duration: TimeSpan, beginTime: TimeSpan);
        pointFrom: Point;
        point: Point;
        valueFrom: number;
        value: number;
        LabelRect: Rectangle;
        get type(): StiAnimationType;
    }
}
declare namespace Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiPointsAnimation extends StiAnimation {
        constructor(pointsFrom: Point[], duration: TimeSpan, beginTime: TimeSpan);
        pointsFrom: Point[];
        get type(): StiAnimationType;
    }
}
declare namespace Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiPieLabelAnimation extends StiAnimation {
        constructor(valueFrom: number, value: number, angleFrom: number, angle: number, clientRect: Rectangle, rectLabelFrom: Rectangle, rectLabel: Rectangle, duration: TimeSpan, beginTime: TimeSpan);
        valueFrom: number;
        value: number;
        rectLabelFrom: Rectangle;
        rectLabel: Rectangle;
        clientRect: Rectangle;
        angleFrom: number;
        angle: number;
        get type(): StiAnimationType;
    }
}
declare namespace Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiPieSegmentAnimation extends StiAnimation {
        constructor(rectFrom: Rectangle, startAngleFrom: number, sweepAngleFrom: number, duration: TimeSpan, beginTime: TimeSpan);
        rectFrom: Rectangle;
        startAngleFrom: number;
        sweepAngleFrom: number;
        get type(): StiAnimationType;
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiLineGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        pen: StiPenGeom;
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        get type(): StiGeomType;
        constructor(pen: StiPenGeom, x1: number, y1: number, x2: number, y2: number);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiLinesGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        pen: StiPenGeom;
        points: Point[];
        get type(): StiGeomType;
        constructor(pen: StiPenGeom, points: Point[]);
    }
}
declare namespace Stimulsoft.Base.Context {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiImageGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        rect: Rectangle;
        image: number[];
        get type(): StiGeomType;
        constructor(rect: Rectangle, image: number[]);
    }
}
declare namespace Stimulsoft.Base.Context {
    import Point = Stimulsoft.System.Drawing.Point;
    import StiInteractionData = Stimulsoft.Base.Context.StiInteractionData;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import IStiArea = Stimulsoft.Report.Chart.IStiArea;
    class StiSeriesInteractionData implements StiInteractionData {
        isElements: boolean;
        tag: any;
        tooltip: string;
        hyperlink: string;
        argument: any;
        originalArgument: any;
        value: number;
        series: IStiSeries;
        pointIndex: number;
        point: Point;
        fill(area: IStiArea, series: IStiSeries, pointIndex: number): void;
    }
}
declare namespace Stimulsoft.Base.Context {
    class StiInteractionData {
        value: number;
    }
}
declare namespace Stimulsoft.Base.Context {
    class StiIndicatorInteractionData extends StiInteractionData {
        target: number;
        seriesText: string;
    }
}
declare namespace Stimulsoft.Report.Export.Services.Helpers {
    import SolidBrush = Stimulsoft.System.Drawing.SolidBrush;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiContextSvgHelper {
        private static isAddStimulsoftIconFont;
        private static dx;
        private static dy;
        private static listTransformGeom;
        static writeGeoms(writer: XmlTextWriter, context: StiContext, needAnimation: boolean): void;
        static addAnimation(writer: XmlTextWriter, actions: string, begin: TimeSpan, duration: TimeSpan, numberr?: string): void;
        private static rectToCenterPoint;
        private static writeInteraction;
        private static getPathData;
        private static addArcPath;
        private static round;
        private static addPiePath;
        static correctRectLabel(rotationMode: StiRotationMode, textRect: Rectangle): Rectangle;
        private static convertArcToCubicBezier;
        static writeTooltip(writer: XmlTextWriter, tooltip: string): void;
        static getFillBrush(writer: XmlTextWriter, brush: Color | StiBrush | SolidBrush, rect: Rectangle): string;
        static writeFillBrush(writer: XmlTextWriter, brush: any, rect: Rectangle): string;
        static writeFillBrushMouserOver(writer: XmlTextWriter, brush: any, brushOver: any, rect: Rectangle): void;
        private static writeBorderStroke;
        private static convertSplineToCubicBezier;
        private static calculateCurveBezier;
        private static calculateCurveBezierEndPoints;
        private static writeBrush;
        private static checkPenGeom;
        private static p;
        static writeStimulsoftIconFont(): void;
    }
}
declare namespace Stimulsoft.Base.Context {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Size = Stimulsoft.System.Drawing.Size;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiShadowSides = Stimulsoft.Base.Drawing.StiShadowSides;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiContext {
        render(rect: Rectangle): void;
        getDefaultStringFormat(): StiStringFormatGeom;
        getGenericStringFormat(): StiStringFormatGeom;
        drawImage(image: number[], rect: Rectangle): void;
        drawString3(text: string, font: StiFontGeom, brush: any, rect: Rectangle, sf: StiStringFormatGeom, toolTip: string): StiTextGeom;
        drawString2(text: string, font: StiFontGeom, brush: any, rect: Rectangle, sf: StiStringFormatGeom): StiTextGeom;
        drawString(text: string, font: StiFontGeom, brush: any, rect: Rectangle, sf: StiStringFormatGeom): StiTextGeom;
        drawRotatedString2(text: string, font: StiFontGeom, brush: any, rect: Rectangle, sf: StiStringFormatGeom, angle: number, antialiasing: boolean): StiTextGeom;
        drawRotatedString3(text: string, font: StiFontGeom, brush: any, rect: Rectangle, sf: StiStringFormatGeom, angle: number, antialiasing: boolean): StiTextGeom;
        drawRotatedString4(text: string, font: StiFontGeom, brush: any, pos: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean): StiTextGeom;
        drawRotatedString5(text: string, font: StiFontGeom, brush: any, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean): StiTextGeom;
        drawRotatedString6(text: string, font: StiFontGeom, brush: any, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean, maximalWidth: number, isRotated?: boolean): StiTextGeom;
        drawRotatedString7(text: string, font: StiFontGeom, brush: any, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean, maximalWidth: number): StiTextGeom;
        drawRotatedString8(text: string, font: StiFontGeom, brush: any, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean): StiTextGeom;
        drawRotatedString9(text: string, font: StiFontGeom, brush: any, pos: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean, maximalWidth: number): StiTextGeom;
        measureString(text: string, font: StiFontGeom): Size;
        measureString2(text: string, font: StiFontGeom, width: number, sf: StiStringFormatGeom): Size;
        measureRotatedString(text: string, font: StiFontGeom, rect: Rectangle, sf: StiStringFormatGeom, angle: number): Rectangle;
        measureRotatedString2(text: string, font: StiFontGeom, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, maximalWidth?: number): Rectangle;
        measureRotatedString3(text: string, font: StiFontGeom, point: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, maximalWidth: number): Rectangle;
        measureRotatedString4(text: string, font: StiFontGeom, point: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number): Rectangle;
        drawShadow(sg: StiContext, rect: Rectangle, radius: number): void;
        drawCachedShadow(rect: Rectangle, sides: StiShadowSides, isPrinting: boolean): void;
        createShadowGraphics(): StiContext;
        pushTranslateTransform(x: number, y: number): void;
        pushRotateTransform(angle: number): void;
        popTransform(): void;
        pushClipPath(listGeoms: StiSegmentGeom[]): void;
        pushClip(clipRect: Rectangle): void;
        popClip(): void;
        drawAnimationColumn(brush: any, borderPen: StiPenGeom, rect: any, value: number, toolTip: string, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        drawAnimationBar(brush: any, borderPen: StiPenGeom, columnRect: any, value: number, toolTip: string, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        drawAnimationRectangle(brush: any, pen: StiPenGeom, rect: Rectangle, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom, tooltip: string): void;
        drawAnimationPathElement(brush: any, borderPen: StiPenGeom, path: StiSegmentGeom[], rect: any, toolTip: string, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        drawAnimationLabel(text: string, font: StiFontGeom, textBrush: any, labelBrush: any, penBorder: StiPenGeom, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, drawBorder: boolean, animation: StiAnimation): void;
        drawAnimationLines(pen: StiPenGeom, points: Point[], animation: StiAnimation): void;
        drawAnimationCurve(pen: StiPenGeom, points: Point[], tension: number, animation: StiAnimation): void;
        fillDrawAnimationPath(brush: any, pen: StiPenGeom, path: StiSegmentGeom[], rect: any, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        fillDrawAnimationEllipse(brush: any, pen: StiPenGeom, x: number, y: number, width: number, height: number, toolTip: string, tag: any, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        drawLine(pen: StiPenGeom, x1: number, y1: number, x2: number, y2: number): void;
        drawLines(pen: StiPenGeom, points: Point[]): void;
        drawRectangle(pen: StiPenGeom, rect: Rectangle): void;
        drawRectangle2(pen: StiPenGeom, x: number, y: number, width: number, height: number): void;
        drawEllipse(pen: StiPenGeom, x: number, y: number, width: number, height: number): void;
        drawEllipse2(pen: StiPenGeom, rect: Rectangle): void;
        fillEllipse(brush: any, x: number, y: number, width: number, height: number, interaction: StiInteractionDataGeom): void;
        fillEllipse2(brush: any, rect: Rectangle, interaction: StiInteractionDataGeom): void;
        fillEllipse3(brush: any, x: number, y: number, width: number, height: number, tooltip: string, interaction: StiInteractionDataGeom): void;
        drawPath(pen: StiPenGeom, path: StiSegmentGeom[], rect: any): void;
        fillPath(brush: any, path: StiSegmentGeom[], rect: any, interaction: StiInteractionDataGeom): void;
        fillPath2(brush: any, path: StiSegmentGeom[], rect: any, interaction: StiInteractionDataGeom, toolTip: string): void;
        drawCurve(pen: StiPenGeom, points: Point[], tension: number): void;
        fillRectangle(brush: any, rect: Rectangle, interaction: StiInteractionDataGeom): void;
        fillRectangle2(brush: any, x: number, y: number, width: number, height: number, interaction: StiInteractionDataGeom): void;
        fillRectangle3(brush: any, brushMouseOver: any, rect: Rectangle, interaction: StiInteractionDataGeom): void;
        pushSmoothingModeToAntiAlias(): void;
        popSmoothingMode(): void;
        pushTextRenderingHintToAntiAlias(): void;
        popTextRenderingHint(): void;
        getPathBounds(geoms: StiSegmentGeom[]): Rectangle;
        geoms: StiGeom[];
        private _contextPainter;
        get contextPainter(): StiContextPainter;
        private _options;
        get options(): StiContextOptions;
        drawShadowRect(rect: Rectangle, shadowWidth: number, animation: StiAnimation): void;
        drawShadowRect2(rect: Rectangle, radiusX: number, radiusY: number, shadowWidth: number, animation: StiAnimation): void;
        constructor(contextPainter: StiContextPainter, isGdi: boolean, isWpf: boolean, isPrinting: boolean, zoom: number);
    }
}
declare namespace Stimulsoft.Base.Context {
    import Size = Stimulsoft.System.Drawing.Size;
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    class StiContextPainter {
        private _svgRect;
        private svgObj;
        get svgRect(): any;
        getDefaultStringFormat(): StiStringFormatGeom;
        getGenericStringFormat(): StiStringFormatGeom;
        createShadowGraphics(isPrinting: boolean, zoom: number): StiContext;
        getPathBounds(geoms: StiSegmentGeom[]): Rectangle;
        measureString(text: string, font: StiFontGeom, width?: number, sf?: StiStringFormatGeom): Size;
        measureRotatedString1(text: string, font: StiFontGeom, rect: Rectangle, sf: StiStringFormatGeom, angle: number): Rectangle;
        measureRotatedString2(text: string, font: StiFontGeom, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, maximalWidth?: number): Rectangle;
        measureRotatedString3(text: string, font: StiFontGeom, point: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, maximalWidth: number): Rectangle;
        private getTextSize;
        measureRotatedString4(text: string, font: StiFontGeom, point: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number): Rectangle;
        private getStartPoint;
        render(rect: Rectangle, geoms: StiGeom[]): void;
    }
}
declare namespace Stimulsoft.Report.Export {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiChartSvgHelper {
        static getImage(svgData: StiSvgData): Image;
        static writeChart(writer: XmlTextWriter, svgData: StiSvgData, zoom: number, needAnimation: boolean): void;
        private static writeEmptyDataMessage;
        private static getEmptyDataImage;
        private static measureTextWidth;
    }
}
declare namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiGaugeGeom {
        get type(): StiGaugeGeomType;
        get animation(): StiAnimation;
        set animation(value: StiAnimation);
    }
}
declare namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiPieGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly startAngle: number;
        readonly sweepAngle: number;
        get type(): StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number, startAngle: number, sweepAngle: number);
    }
}
declare namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiEllipseGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        get type(): StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number);
    }
}
declare namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiGraphicsArcGeometryGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly startAngle: number;
        readonly sweepAngle: number;
        readonly startWidth: number;
        readonly endWidth: number;
        get type(): StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number, startAngle: number, sweepAngle: number, startWidth: number, endWidth: number);
    }
}
declare namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    class StiPopTranformGaugeGeom extends StiGaugeGeom {
        get type(): StiGaugeGeomType;
    }
}
declare namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiPushMatrixGaugeGeom extends StiGaugeGeom {
        readonly angle: number;
        readonly centerPoint: Point;
        get type(): StiGaugeGeomType;
        constructor(angle: number, centerPoint: Point);
    }
}
declare namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRadialRangeGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly centerPoint: Point;
        readonly startAngle: number;
        readonly sweepAngle: number;
        readonly radius1: number;
        readonly radius2: number;
        readonly radius3: number;
        readonly radius4: number;
        get type(): StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number, centerPoint: Point, startAngle: number, sweepAngle: number, radius1: number, radius2: number, radius3: number, radius4: number);
    }
}
declare namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRectangleGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        get type(): StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number);
    }
}
declare namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRoundedRectangleGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly leftTop: number;
        readonly rightTop: number;
        readonly rightBottom: number;
        readonly leftBottom: number;
        get type(): StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number, leftTop: number, rightTop: number, rightBottom: number, leftBottom: number);
    }
}
declare namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    class StiTextGaugeGeom extends StiGaugeGeom {
        readonly text: string;
        readonly font: Font;
        readonly foreground: StiBrush;
        readonly rect: Rectangle;
        readonly stringFormat: StringFormat;
        get type(): StiGaugeGeomType;
        constructor(text: string, font: Font, foreground: StiBrush, rect: Rectangle, sf: StringFormat);
    }
}
declare namespace Stimulsoft.Report.Painters {
    import StiGaugeGeom = Stimulsoft.Report.Gauge.GaugeGeoms.StiGaugeGeom;
    import StiGraphicsPathGaugeGeom = Stimulsoft.Report.Gauge.GaugeGeoms.StiGraphicsPathGaugeGeom;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import RectangleF = Stimulsoft.System.Drawing.Rectangle;
    import Font = Stimulsoft.System.Drawing.Font;
    import SizeF = Stimulsoft.System.Drawing.Size;
    import PointF = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import IStiGauge = Stimulsoft.Report.Components.Gauge.IStiGauge;
    class StiGaugeContextPainter {
        zoom: number;
        rect: RectangleF;
        gauge: IStiGauge;
        geoms: StiGaugeGeom[];
        static changeFontSize(font: Font, zoom: number): Font;
        measureString(text: string, font: Font): SizeF;
        addPieGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number, startAngle: number, sweepAngle: number): void;
        addEllipseGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number): void;
        addGraphicsArcGeometryGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number, startAngle: number, sweepAngle: number, startWidth: number, endWidth: number): void;
        addPopTranformGaugeGeom(): void;
        addPushMatrixGaugeGeom(angle: number, centerPoint: PointF): void;
        addRadialRangeGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number, centerPoint: PointF, startAngle: number, sweepAngle: number, radius1: number, radius2: number, radius3: number, radius4: number): void;
        addRectangleGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number): void;
        addRoundedRectangleGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number, leftTop: number, rightTop: number, rightBottom: number, leftBottom: number): void;
        addTextGaugeGeom(text: string, font: Font, foreground: StiBrush, rect: RectangleF, sf: StringFormat): void;
        addGraphicsPathGaugeGeom(geom: StiGraphicsPathGaugeGeom): void;
        render(): void;
        constructor(gauge: IStiGauge, rect: RectangleF, zoom: number);
    }
}
declare namespace Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    class StiScaleAnimation extends StiAnimation {
        constructor(startScaleX: number, endScaleX: number, startScaleY: number, endScaleY: number, centerX: number, centerY: number, duration: TimeSpan, beginTime: TimeSpan);
        startScaleX: number;
        startScaleY: number;
        endScaleX: number;
        endScaleY: number;
        centerX: number;
        centerY: number;
        get type(): StiAnimationType;
    }
}
declare namespace Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiRotationAnimation extends StiAnimation {
        constructor(startAngle: number, endAngle: number, centerPoint: Point, duration: TimeSpan, beginTime: TimeSpan);
        startAngle: number;
        endAngle: number;
        centerPoint: Point;
        get type(): StiAnimationType;
    }
}
declare namespace Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiTranslationAnimation extends StiAnimation {
        constructor(startPoint: Point, endPoint: Point, duration: TimeSpan, beginTime: TimeSpan);
        startPoint: Point;
        endPoint: Point;
        get type(): StiAnimationType;
    }
}
declare namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    class StiGraphicsPathArcGaugeGeom extends StiGaugeGeom {
        readonly x: number;
        readonly y: number;
        readonly width: number;
        readonly height: number;
        readonly startAngle: number;
        readonly sweepAngle: number;
        get type(): StiGaugeGeomType;
        constructor(x: number, y: number, width: number, height: number, startAngle: number, sweepAngle: number);
    }
}
declare namespace Stimulsoft.Report.Gauge {
    enum StiGaugeGeomType {
        GraphicsPath = 0,
        GraphicsPathArc = 1,
        GraphicsPathCloseFigure = 2,
        RoundedRectangle = 3,
        Rectangle = 4,
        Pie = 5,
        Ellipse = 6,
        GraphicsArcGeometry = 7,
        PushMatrix = 8,
        PopTranform = 9,
        GraphicsPathLines = 10,
        GraphicsPathLine = 11,
        Text = 12,
        RadialRange = 13
    }
}
declare namespace Stimulsoft.Report.Export {
    import Image = Stimulsoft.System.Drawing.Image;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    class StiGaugeSvgHelper {
        static getImage(svgData: StiSvgData): Image;
        private static readonly PiDiv180;
        private static readonly FourDivThree;
        private static addAnimation;
        static writeGauge(writer: XmlTextWriter, svgData: StiSvgData, zoom?: number, needAnimation?: boolean, isSampleForStyles?: boolean): void;
        private static getPathData;
        static getArcPath(rect: Rectangle, path_: string, startAngle: number, sweepAngle: number, isSetStartPoint: boolean): string;
        private static convertArcToCubicBezier;
        private static addArcPath;
        private static addPiePath;
        private static convertArcToCubicBezier2;
        private static convertArcToCubicBezier3;
        private static round;
        static writeText(writer: XmlTextWriter, text: string, font: Font, foreground: StiBrush, point: Point, size: number): void;
        private static calculateCurveBezier;
        private static calculateCurveBezierEndPoints;
        static writeFillBrush(writer: XmlTextWriter, brush: Color | StiBrush, rect: Rectangle): string;
        private static writeBorderStroke;
        private static rectToRectangle;
    }
}
declare namespace Stimulsoft.Report.Painters {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiMap = Stimulsoft.Report.Maps.StiMap;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiMapGdiPainter {
        useBackground: boolean;
        key: string;
        getImageAsync(map: StiMap, zoom: number, width?: number, height?: number): StiPromise<string>;
        paintOnlineMapAsync(rect: Rectangle, map: StiMap): StiPromise<string>;
        tryToDecimal(value: any): number;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Maps {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiPromise = Stimulsoft.System.StiPromise;
    import StiHtmlTextWriter = Stimulsoft.Report.Export.StiHtmlTextWriter;
    class StiMapHelper {
        private static globalReport;
        private static globalMap;
        static cache: {};
        static addToCahe(map: StiMap, width: number, height: number): string;
        static renderOnlineMap(writer: StiHtmlTextWriter): StiPromise<void>;
        static isWorld(id: StiMapID): boolean;
        static isAfrica(id: StiMapID): boolean;
        static isNorthAmerica(id: StiMapID): boolean;
        static isSouthAmerica(id: StiMapID): boolean;
        static isEU(id: StiMapID): boolean;
        static isOceania(id: StiMapID): boolean;
        static isAsia(id: StiMapID): boolean;
        static getStates(report: StiReport, id: StiMapID): string[];
        static getMapSample(): StiMap;
        static getColors(): Color[];
        static prepareIsoCode(text: string): string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapData {
        constructor(key: string);
        key: string;
        gss: string;
        private _value;
        get value(): string;
        set value(value1: string);
        private _group;
        get group(): string;
        set group(value: string);
        name: string;
        private _color;
        get color(): string;
        set color(value: string);
        getValue(): number;
        toString(): string;
        private invokeValueChanged;
    }
}
declare namespace Stimulsoft.Report.Maps {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    class StiMapSvg {
        key: string;
        data: string;
        englishName: string;
        iSOCode: string;
        rect: Rectangle;
        setMaxWidth: boolean;
        skipText: boolean;
        horAlignment: StiTextHorAlignment;
        vertAlignment: StiVertAlignment;
        rectIso: Rectangle;
        skipTextIso: boolean;
        horAlignmentIso: StiTextHorAlignment;
        vertAlignmentIso: StiVertAlignment;
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    import List = Stimulsoft.System.Collections.List;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiMapStyle = Stimulsoft.Report.Styles.StiMapStyle;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiExportImageExtended = Stimulsoft.Report.Components.IStiExportImageExtended;
    import IStiBorder = Stimulsoft.Report.Components.IStiBorder;
    import IStiBrush = Stimulsoft.Report.Components.IStiBrush;
    import IStiDataSource = Stimulsoft.Report.Components.IStiDataSource;
    import IStiBusinessObject = Stimulsoft.Report.Components.IStiBusinessObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiMap extends StiComponent implements IStiExportImageExtended, IStiBorder, IStiBrush, IStiDataSource, IStiBusinessObject, IStiJsonReportObject {
        private static implementsStiMap;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties?: boolean): StiMap;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        get isDataSourceEmpty(): boolean;
        get dataSource(): StiDataSource;
        private _dataSourceName;
        get dataSourceName(): string;
        set dataSourceName(value: string);
        get isBusinessObjectEmpty(): boolean;
        get businessObject(): StiBusinessObject;
        private _businessObjectGuid;
        get businessObjectGuid(): string;
        set businessObjectGuid(value: string);
        private _countData;
        get countData(): number;
        set countData(value: number);
        private _pushPins;
        get pushPins(): string;
        set pushPins(value: string);
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        isEofValue: boolean;
        get isEof(): boolean;
        set isEof(value: boolean);
        isBofValue: boolean;
        get isBof(): boolean;
        set isBof(value: boolean);
        get isEmpty(): boolean;
        positionValue: number;
        get position(): number;
        set position(value: number);
        get count(): number;
        private isCacheValues;
        private cachedCount;
        private cachedIsBusinessObjectEmpty;
        private cachedIsDataSourceEmpty;
        private cachedDataSource;
        private cachedBusinessObject;
        cacheValues(cache: boolean): void;
        private _border;
        get border(): StiBorder;
        set border(value: StiBorder);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        get componentId(): StiComponentId;
        get localizedCategory(): string;
        get localizedName(): string;
        defaultClientRectangle: RectangleD;
        private _mapStyle;
        get mapStyle(): StiMapStyleIdent;
        set mapStyle(value: StiMapStyleIdent);
        private _dataFrom;
        get dataFrom(): StiMapSource;
        set dataFrom(value: StiMapSource);
        private _colorEach;
        get colorEach(): boolean;
        set colorEach(value: boolean);
        private _stretch;
        get stretch(): boolean;
        set stretch(value: boolean);
        private _showValue;
        get showValue(): boolean;
        set showValue(value: boolean);
        private _shortValue;
        get shortValue(): boolean;
        set shortValue(value: boolean);
        private _displayNameType;
        get displayNameType(): StiDisplayNameType;
        set displayNameType(value: StiDisplayNameType);
        private _mapIdent;
        get mapIdent(): string;
        set mapIdent(value: string);
        private _mapType;
        get mapType(): StiMapType;
        set mapType(value: StiMapType);
        private isMapDataChanged;
        private _mapData;
        get mapData(): string;
        set mapData(value: string);
        private _keyDataColumn;
        get keyDataColumn(): string;
        set keyDataColumn(value: string);
        private _nameDataColumn;
        get nameDataColumn(): string;
        set nameDataColumn(value: string);
        private _valueDataColumn;
        get valueDataColumn(): string;
        set valueDataColumn(value: string);
        private _groupDataColumn;
        get groupDataColumn(): string;
        set groupDataColumn(value: string);
        private _colorDataColumn;
        get colorDataColumn(): string;
        set colorDataColumn(value: string);
        private _latitude;
        get latitude(): string;
        set latitude(value: string);
        private _longitude;
        get longitude(): string;
        set longitude(value: string);
        private _mapMode;
        get mapMode(): StiMapMode;
        set mapMode(value: StiMapMode);
        mapImage: string;
        dataTable: StiDataTable;
        showBubble: boolean;
        private _isHashDataEmpty;
        get isHashDataEmpty(): boolean;
        createNew(): StiComponent;
        private _hashData;
        static getDefaultMapData(report: StiReport, mapIdent: string): List<StiMapData>;
        getMapData(): List<StiMapData>;
        getCurrentStyleColors(): Color[];
        static getStyleColors(style: StiMapStyleIdent): Color[];
        getStyleBackground(): StiBrush;
        static getMapStyle2(map: StiMap): StiMapStyle;
        static getMapStyle(style: StiMapStyleIdent): StiMapStyle;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Maps.Helpers {
    class StiCustomMapFinder {
        private static lastReport;
        private static defaultMaps;
        private static customMaps;
        static clear(): void;
        static init(report: StiReport): void;
        static isCustom(mapIdent: string): boolean;
        static getContainer(report: StiReport, mapIdent: string): StiMapSvgContainer;
        static stiPopulateObject(json: any, object: any): void;
        static StiCustomMapFinder(): void;
    }
}
declare namespace Stimulsoft.Report.Export {
    import SolidBrush = Stimulsoft.System.Drawing.SolidBrush;
    import StiMap = Stimulsoft.Report.Maps.StiMap;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiMapSvgHelper {
        static getImage(svgData: StiSvgData, scale?: number): Image;
        static drawMap(xmlsWriter: XmlTextWriter, map: StiMap, x: number, y: number, width: number, height: number, animated: boolean): void;
        static render(map: StiMap, xmlsWriter: XmlTextWriter, animated: boolean, sScale: number): void;
        private static getPathText;
        private static getPathRect;
        private static getPathHorAlignment;
        private static getPathVertAlignment;
        private static getToolTipIdent;
        private static getToolTipValueText;
        private static getToolTipTotalText;
        private static normalizeDecimal;
        private static getBorderStroke;
        static getFillBrush(brush: SolidBrush): string;
        private static getBubbleSize;
    }
}
declare namespace Stimulsoft.Report.Export {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    class StiMathFormulaSvgHelper {
        static writeMathFormula(writer: XmlTextWriter, svgData: StiSvgData): void;
    }
}
declare namespace Stimulsoft.Report.Painters {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import List = Stimulsoft.System.Collections.List;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiColumnSparklinesCellPainter {
        static draw(context: StiContext, rect: RectangleD, array: List<any>, positiveColor: Color, negativeColor: Color): void;
    }
}
declare namespace Stimulsoft.Report.Painters {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import List = Stimulsoft.System.Collections.List;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLineSparklinesCellPainter {
        static draw(context: StiContext, rect: RectangleD, array: List<any>, sparklineColor: Color, showArea: boolean, showFirstLastMarker?: boolean, showHighLowMarker?: boolean): void;
        private static drawArea;
        private static drawLines;
        private static drawFirstLastMarkers;
        private static drawHighLowMarkers;
        private static drawMarker;
        private static simplifyPoints;
    }
}
declare namespace Stimulsoft.Report.Painters {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import List = Stimulsoft.System.Collections.List;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiWinLossSparklinesCellPainter {
        static draw(context: StiContext, rect: RectangleD, array: List<any>, positiveColor: Color, negativeColor: Color): void;
    }
}
declare namespace Stimulsoft.Report.Painters {
    import Type = Stimulsoft.System.Type;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiPainter {
        private static typePainter;
        static getPainter(componentType: Type): StiPainter;
        getImage(component: Stimulsoft.Report.Components.StiComponent, REFzoom: any, format: StiExportFormat): Image;
        paint(component: Stimulsoft.Report.Components.StiComponent, g: Stimulsoft.System.Drawing.Graphics): void;
    }
}
declare namespace Stimulsoft.Report.Painters {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiComponentPainter extends StiPainter {
        paintBorder(component: StiComponent, g: Graphics, rect: RectangleD, zoom: number, drawBorderFormatting: boolean, drawBorderSides: boolean): void;
    }
}
declare namespace Stimulsoft.Report.Painters {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Image = Stimulsoft.System.Drawing.Image;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiSparkline = Stimulsoft.Report.Components.StiSparkline;
    class StiSparklinePainter extends StiComponentPainter {
        getImage(component: Stimulsoft.Report.Components.StiComponent, REFzoom: any, format: StiExportFormat): Image;
        paint(component: Stimulsoft.Report.Components.StiComponent, g: Stimulsoft.System.Drawing.Graphics): void;
        paintBackground(sparkline: StiSparkline, g: Graphics, rect: Rectangle): void;
        static drawSparkline(g: Graphics, rect: Rectangle, sparkline: StiSparkline, zoom: number): void;
        static renderSparkline(context: StiContext, rect: Rectangle, sparkline: StiSparkline, zoom: number): void;
    }
}
declare namespace Stimulsoft.Report.Export {
    import Image = Stimulsoft.System.Drawing.Image;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    class StiSparklineSvgHelper {
        static getImage(svgData: StiSvgData): Image;
        static writeSparkline(writer: XmlTextWriter, svgData: StiSvgData): void;
    }
}
declare namespace Stimulsoft.Report.Export {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiSvgData {
        private _x;
        get x(): number;
        set x(value: number);
        private _y;
        get y(): number;
        set y(value: number);
        private _width;
        get width(): number;
        set width(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        private _right;
        get right(): number;
        private _bottom;
        get bottom(): number;
        component: StiComponent;
    }
}
declare namespace Stimulsoft.Report.Export {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import Pen = Stimulsoft.System.Drawing.Pen;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiSvgGeomWriter implements IStiExportGeomWriter {
        constructor(writer: XmlTextWriter);
        private writer;
        beginPath(): void;
        closeFigure(): void;
        endPath(): void;
        fillPath(brush: any): void;
        strokePath(pen: any): void;
        moveTo(point: PointD): void;
        drawLine(pointFrom: PointD, pointTo: PointD, pen: any): void;
        drawLineTo(pointTo: PointD, pen: any): void;
        drawRectangle(rect: RectangleD, pen: any): void;
        drawPolyline(points: PointD[], pen: Pen): void;
        drawPolylineTo(points: PointD[], pen: any): void;
        drawPolygon(points: PointD[], pen: any): void;
        fillPolygon(points: PointD[], brush: any): void;
        drawBezier(p1: PointD, p2: PointD, p3: PointD, p4: PointD, pen: any): void;
        drawBezierTo(p2: PointD, p3: PointD, p4: PointD, pen: any): void;
        drawArc2(rect: RectangleD, p1: PointD, p2: PointD, pen: Pen): void;
        setPixel(point: PointD, color: Color): void;
        drawImage(img: Image, rect: RectangleD): void;
        drawText(basePoint: PointD, text: string, charsOffset: number[], font: Font, textColor: Color, angle: number, textAlign: EmfTextAlignmentMode): void;
        drawString(st: string, font: Font, brush: any, rect: RectangleD, sf: StringFormat): void;
        saveState(): void;
        restoreState(): void;
        fillRectangle(rect: RectangleD, brush: any): void;
        fillRectangle2(rect: RectangleD, color: Color): void;
        rotateTransform(angle: number): void;
        translateTransform(x: number, y: number): void;
        endTransform(): void;
        measureString(st: string, font: Font): SizeD;
        drawEllipse(rect: RectangleD, pen: any): void;
        fillEllipse(rect: RectangleD, brush: any): void;
    }
}
declare namespace Stimulsoft.Report.Export {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiSvgHelper {
        private static correctFontSize;
        private static pdfCKT;
        static getLineStyleDash(penStyle: StiPenStyle, width: number): string;
        static toUnits(numberr: number): string;
        private static writeCoordinates;
        private static writeStrokeInfo;
        static writeFillInfo(writer: XmlTextWriter, color: Color): void;
        private static checkShape;
        private static writeDocument;
        static writeWatermark(writer: XmlTextWriter, xmlIndentation: number, page: StiPage, behind: boolean, pageWidth: number, pageHeight: number, imageResolution: number, zoom?: number): void;
        private static writeBorder1;
        private static writeBorder2;
        private static writeText2;
        private static writeText;
        static getStyleString(font: Font, textColor: Color): string;
        private static writeImage;
        static writeBarCode(writer: XmlTextWriter, svgData: StiSvgData): void;
        static writeShape(writer: XmlTextWriter, svgData: StiSvgData): void;
        static writeFillBrush(writer: XmlTextWriter, brush: Color | StiBrush, rect: RectangleD): string;
        private static writeBrush;
        private static writeRoundedRectanglePrimitive;
        private static getClipPathName;
        private static writeIndicator;
        private static writeIconSetIndicatorTypePainter;
        private static writeDataBarIndicator;
        static saveComponentToString(component: StiComponent, imageFormat?: ImageFormat, imageQuality?: number, imageResolution?: number, isDesigner?: boolean): string;
        static saveToString(report: StiReport, page: StiPage, compressed: boolean, standalone?: boolean, REFclipCounter?: any, imageFormat?: ImageFormat, imageQuality?: number, imageResolution?: number): string;
        static writeCheckBox(writer: XmlTextWriter, svgData: StiSvgData, checkedValue: any): void;
        private static getCheckBoxData;
        static writeTextInCells(writer: XmlTextWriter, svgData: StiSvgData): void;
    }
}
declare namespace Stimulsoft.Report.Export {
    let IStiHtml5ExportService: System.Interface<IStiHtml5ExportService>;
    interface IStiHtml5ExportService extends IStiExportService {
        exportTo(report: StiReport, writer: StiHtmlTextWriter, settings: StiExportSettings): any;
        exportToAsync(onExport: Function, report: StiReport, writer: StiHtmlTextWriter, settings: StiExportSettings): any;
        exportHtml(report: StiReport, htmlWriter: StiHtmlTextWriter, settings: StiHtmlExportSettings): any;
    }
}
declare namespace Stimulsoft.Report.Export {
    import StiSparkline = Stimulsoft.Report.Components.StiSparkline;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiText = Stimulsoft.Report.Components.StiText;
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import IStiComponent = Stimulsoft.Report.Components.IStiComponent;
    class StiHtmlExportService extends StiExportService {
        renderedPagesCount: number;
        currentPassNumber: number;
        maximumPassNumber: number;
        get exportFormat(): StiExportFormat;
        exportTo(report: StiReport, writer: StiHtmlTextWriter, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, writer: StiHtmlTextWriter, settings: StiExportSettings): void;
        exportToAsync2(report: StiReport, writer: StiHtmlTextWriter, settings: StiExportSettings): Promise<void>;
        private exportSettings;
        private reportTmp;
        private documentFileName;
        private sendEMail;
        multipleFiles: boolean;
        clearOnFinish: boolean;
        tableRender: StiHtmlTableRender;
        htmlWriter: StiHtmlTextWriter;
        private zip;
        report: StiReport;
        private fileName;
        private startPage;
        private imageNumber;
        zoom: number;
        imageFormat: ImageFormat;
        exportQuality: StiHtmlExportQuality;
        useStylesTable: boolean;
        private isFileStreamMode;
        private imageQuality;
        imageResolution: number;
        private compressToArchive;
        private useEmbeddedImages;
        openLinksTarget: string;
        chartType: StiHtmlChartType;
        private coordX;
        private coordY;
        private strSpanDiv;
        private hyperlinksToTag;
        private pointerToBookmark;
        private pointerToTag;
        chartData: Hashtable;
        hashBookmarkGuid: Hashtable;
        private hiToPt;
        renderStyles: boolean;
        styles: StiCellStyle[];
        insertInteractionParameters: boolean;
        htmlImageHost: StiHtmlImageHost;
        totalPageWidth: number;
        totalPageHeight: number;
        renderAsDocument: boolean;
        removeEmptySpaceAtBottom: boolean;
        pageHorAlignment: StiHorAlignment;
        static fontScale: Hashtable;
        static getFontScale(fontName: string, fontSize: number): number;
        private addCoord;
        private formatCoords;
        formatCoord(value: number): string;
        formatColor(color: Color): string;
        formatColorRgba(color: Color): string;
        private getBorderStyle;
        setCurrentCulture(): void;
        restoreCulture(): void;
        renderFont(cell: StiHtmlTableCell, font: Font): void;
        renderTextHorAlignment(cell: StiHtmlTableCell, textOptions: any, textHorAlignment: StiTextHorAlignment): void;
        renderVertAlignment(cell: StiHtmlTableCell, textVertAlignment: StiVertAlignment, textOptions?: any, allowHtml?: boolean): void;
        renderTextDirection(cell: StiHtmlTableCell, textOptions: StiTextOptions): void;
        renderBackColor(cell: StiHtmlTableCell, color: Color): void;
        renderTextColor(cell: StiHtmlTableCell, color: Color, forceAnyColor?: boolean): void;
        renderBorder(comp: StiComponent): void;
        private renderBorder2;
        renderBorder3(cell: StiHtmlTableCell, border: StiBorderSide, side: string, borderRadius?: number): void;
        private renderPosition;
        private getHeight;
        private getWidth;
        private renderImage;
        private renderImage2;
        private renderImage3;
        renderHyperlink(comp: StiComponent): boolean;
        private renderPage;
        private renderEndPage;
        private renderStartDoc;
        private fillBitmapBackground;
        private renderBookmarkScript;
        private renderChartScripts;
        private renderMapsScripts;
        private renderGaugeScripts;
        getGuid(comp: IStiComponent): string;
        private renderEndDoc;
        private renderBookmarkTree;
        private addBookmarkNode;
        prepareTextForHtml(text: string, processWhiteSpaces?: boolean): string;
        static convertTextWithHtmlTagsToHtmlText(stiText: StiText, text: string, zoom: number): string;
        private static getParagraphString;
        renderWatermarkText(sWriter: StiHtmlTextWriter, page: StiPage, topPos?: number): void;
        renderWatermarkImage(sWriter: StiHtmlTextWriter, page: StiPage, topPos?: number): void;
        static getImage(assemblyName: string, imageName: string, makeTransparent: boolean): Image;
        static getFile(assemblyName: string, fileName: string): Uint8Array;
        private assembleGuidUsedInBookmark;
        static prepareSvg(sWriter: StiHtmlTextWriter, width: number, height: number): void;
        prepareChartData(writer: StiHtmlTextWriter, chart: IStiChart, width: number, height: number): string;
        prepareSparklineData(writer: StiHtmlTextWriter, sparkline: StiSparkline, width: number, height: number): string;
        static getSparklineData(writer: StiHtmlTextWriter, sparkline: StiSparkline, width: number, height: number): string;
        prepareGaugeData(writer: StiHtmlTextWriter, gauge: any, width: number, height: number): string;
        prepareMapData(writer: StiHtmlTextWriter, map: any, width: number, height: number): string;
        getChartScript(): string;
        clear(): void;
        private isComponentHasInteraction;
        exportHtml(report: StiReport, writer: StiHtmlTextWriter, settings: StiHtmlExportSettings, pages?: StiPagesCollection): void;
        constructor();
    }
    class StiBookmarkTreeNode {
        parent: number;
        title: string;
        url: string;
        used: boolean;
    }
}
declare namespace Stimulsoft.Report.Export.Htmls.ChartScripts {
    class StiChartAnimation {
        private static animateSti;
        private static script;
        static getScriptString(): string;
    }
}
declare namespace Stimulsoft.Report.Export {
    class StiSvgExportService extends StiImageExportService {
        exportNameInMenu: string;
        getFilter(): string;
    }
}
declare namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiExcel2007ExportService: System.Interface<IStiExcel2007ExportService>;
    interface IStiExcel2007ExportService extends IStiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
declare namespace Stimulsoft.Report.Export {
    let IStiExcelXmlExportService: System.Interface<IStiExcelXmlExportService>;
    interface IStiExcelXmlExportService extends IStiExportService {
    }
}
declare namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiPpt2007ExportService: System.Interface<IStiPpt2007ExportService>;
    interface IStiPpt2007ExportService extends IStiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
declare namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiWord2007ExportService: System.Interface<IStiWord2007ExportService>;
    interface IStiWord2007ExportService extends IStiExportService {
        removeEmptySpaceAtBottom: boolean;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
declare namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let IStiPdfExportService: System.Interface<IStiPdfExportService>;
    interface IStiPdfExportService extends IStiExportService {
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): any;
    }
}
declare namespace Stimulsoft.Report.Export {
    class StiPdfEmbeddedFileData {
        name: string;
        description: string;
        data: number[] | Uint8Array | string;
        private mimeType;
        get MIMEType(): string;
        set MIMEType(value: string);
        constructor(name: string, description: string, data: number[] | Uint8Array | string, mimeType?: string);
    }
}
declare namespace Stimulsoft.Report.Export {
    class StiOdsExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        imageQuality: number;
        imageResolution: number;
    }
}
declare namespace Stimulsoft.Report.Export {
    class StiOdtExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        usePageHeadersAndFooters: boolean;
        imageQuality: number;
        imageResolution: number;
        removeEmptySpaceAtBottom: boolean;
    }
}
declare namespace Stimulsoft.Report.Export {
    import List = Stimulsoft.System.Collections.List;
    class StiPdfExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        imageQuality: number;
        imageResolution: number;
        imageResolutionMode: StiImageResolutionMode;
        embeddedFonts: boolean;
        standardPdfFonts: boolean;
        compressed: boolean;
        useUnicode: boolean;
        useDigitalSignature: boolean;
        getCertificateFromCryptoUI: boolean;
        exportRtfTextAsImage: boolean;
        passwordInputUser: string;
        passwordInputOwner: string;
        userAccessPrivileges: StiUserAccessPrivileges;
        keyLength: StiPdfEncryptionKeyLength;
        creatorString: string;
        keywordsString: string;
        imageCompressionMethod: StiPdfImageCompressionMethod;
        imageIndexedColorPaletteSize: number;
        imageFormat: StiImageFormat;
        ditheringType: StiMonochromeDitheringType;
        get pdfACompliance(): boolean;
        set pdfACompliance(value: boolean);
        pdfComplianceMode: StiPdfComplianceMode;
        autoPrintMode: StiPdfAutoPrintMode;
        allowEditable: StiPdfAllowEditable;
        embeddedFiles: List<StiPdfEmbeddedFileData>;
        ZUGFeRDComplianceMode: StiPdfZUGFeRDComplianceMode;
        ZUGFeRDConformanceLevel: string;
        ZUGFeRDInvoiceData: number[] | Uint8Array | string;
    }
}
declare namespace Stimulsoft.Report.Export {
    import Encoding = Stimulsoft.System.Text.Encoding;
    class StiTxtExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        encoding: Encoding;
        drawBorder: boolean;
        borderType: StiTxtBorderType;
        killSpaceLines: boolean;
        killSpaceGraphLines: boolean;
        putFeedPageCode: boolean;
        cutLongLines: boolean;
        zoomX: number;
        zoomY: number;
        useEscapeCodes: boolean;
        escapeCodesCollectionName: string;
    }
}
declare namespace Stimulsoft.Report.Export {
    import Encoding = Stimulsoft.System.Text.Encoding;
    class StiDataExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        dataType: StiDataType;
        dataExportMode: StiDataExportMode;
        encoding: Encoding;
        exportDataOnly: boolean;
        codePage: StiDbfCodePages;
        separator: string;
        skipColumnHeaders: boolean;
        useDefaultSystemEncoding: boolean;
        constructor(dataType?: StiDataType);
    }
}
declare namespace Stimulsoft.Report.Export {
    class StiCsvExportSettings extends StiDataExportSettings {
        constructor();
    }
}
declare namespace Stimulsoft.Report.Export {
    import Encoding = Stimulsoft.System.Text.Encoding;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    class StiHtmlExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        htmlType: StiHtmlType;
        imageQuality: number;
        imageResolution: number;
        imageFormat: ImageFormat;
        encoding: Encoding;
        zoom: number;
        exportMode: Export.StiHtmlExportMode;
        exportQuality: StiHtmlExportQuality;
        addPageBreaks: boolean;
        bookmarksTreeWidth: number;
        exportBookmarksMode: StiHtmlExportBookmarksMode;
        useStylesTable: boolean;
        removeEmptySpaceAtBottom: boolean;
        pageHorAlignment: StiHorAlignment;
        compressToArchive: boolean;
        useEmbeddedImages: boolean;
        continuousPages: boolean;
        chartType: StiHtmlChartType;
        openLinksTarget: string;
        useWatermarkMargins: boolean;
        constructor(htmlType?: StiHtmlType);
    }
}
declare namespace Stimulsoft.Report.Export {
    class StiHtml5ExportSettings extends StiHtmlExportSettings {
        constructor();
    }
}
declare namespace Stimulsoft.Report.Export {
    class StiSvgExportSettings extends StiImageExportSettings {
        constructor();
    }
}
declare namespace Stimulsoft.Report.Export {
    class StiExcelExportSettings extends StiPageRangeExportSettings {
        excelType: StiExcelType;
        useOnePageHeaderAndFooter: boolean;
        get exportDataOnly(): boolean;
        set exportDataOnly(value: boolean);
        dataExportMode: StiDataExportMode;
        exportPageBreaks: boolean;
        exportObjectFormatting: boolean;
        exportEachPageToSheet: boolean;
        imageQuality: number;
        imageResolution: number;
        companyString: string;
        lastModifiedString: string;
        restrictEditing: StiExcel2007RestrictEditing;
        getExportFormat(): StiExportFormat;
        constructor(excelType?: StiExcelType);
    }
}
declare namespace Stimulsoft.Report.Export {
    class StiExcel2007ExportSettings extends StiExcelExportSettings {
        constructor();
    }
}
declare namespace Stimulsoft.Report.Export {
    class StiPpt2007ExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        imageQuality: number;
        imageResolution: number;
    }
}
declare namespace Stimulsoft.Report.Export {
    class StiWord2007ExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        usePageHeadersAndFooters: boolean;
        imageQuality: number;
        imageResolution: number;
        removeEmptySpaceAtBottom: boolean;
        companyString: string;
        lastModifiedString: string;
        restrictEditing: StiWord2007RestrictEditing;
    }
}
declare namespace Stimulsoft.Report.Export {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import PointD = Stimulsoft.System.Drawing.Point;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Pen = Stimulsoft.System.Drawing.Pen;
    import Image = Stimulsoft.System.Drawing.Image;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    class StiBarCodeExportPainter implements Stimulsoft.Report.Painters.IStiBarCodePainter {
        private geomWriter;
        baseTransform(context: any, x: number, y: number, angle: number, dx: number, dy: number): void;
        baseRollbackTransform(context: any): void;
        baseFillRectangle(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        baseFillRectangle2D(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        baseFillPolygon(context: any, brush: StiBrush, points: PointD[]): void;
        baseFillEllipse(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        baseDrawRectangle(context: any, penColor: Color, penSize: number, x: number, y: number, width: number, height: number): void;
        baseDrawImage(context: any, image: Image, report: StiReport, x: number, y: number, width: number, height: number): void;
        baseDrawString(context: any, st: string, font: Font, brush: StiBrush, rect: RectangleD, sf: StringFormat): void;
        baseMeasureString(context: any, st: string, font: Font): SizeD;
        static createNew(geomWriter1: IStiExportGeomWriter): StiBarCodeExportPainter;
        constructor(geomWriter1: StiSvgGeomWriter);
    }
    interface IStiExportGeomWriter {
        beginPath(): any;
        closeFigure(): any;
        endPath(): any;
        fillPath(brush: any): any;
        strokePath(pen: any): any;
        moveTo(point: PointD): any;
        drawLine(pointFrom: PointD, pointTo: PointD, pen: any): any;
        drawLineTo(pointTo: PointD, pen: any): any;
        drawRectangle(rect: RectangleD, pen: any): any;
        fillRectangle(rect: RectangleD, brush: Color | any): any;
        drawPolyline(points: PointD[], pen: Pen): any;
        drawPolylineTo(points: PointD[], pen: any): any;
        drawPolygon(points: PointD[], pen: any): any;
        fillPolygon(points: PointD[], brush: any): any;
        fillEllipse(rect: RectangleD, brush: any): any;
        drawBezier(p1: PointD, p2: PointD, p3: PointD, p4: PointD, pen: any): any;
        drawBezierTo(p2: PointD, p3: PointD, p4: PointD, pen: any): any;
        drawArc2(rect: RectangleD, p1: PointD, p2: PointD, pen: Pen): any;
        setPixel(point: PointD, color: Color): any;
        drawImage(img: Image, rect: RectangleD): any;
        drawText(basePoint: PointD, text: string, charsOffset: number[], font: Font, textColor: Color, angle: number, textAlign: EmfTextAlignmentMode): any;
        drawString(st: string, font: Font, brush: any, rect: RectangleD, sf: StringFormat): any;
        saveState(): any;
        restoreState(): any;
        translateTransform(x: number, y: number): any;
        rotateTransform(angle: number): any;
        measureString(st: string, font: Font): SizeD;
    }
}
declare namespace Stimulsoft.Report.Export {
    import StringBuilder = Stimulsoft.System.Text.StringBuilder;
    class StiBidirectionalConvert {
        private arabicTableSize;
        private ligaturesTableSize;
        private static ligaturesTable;
        private static arabicTable;
        private static arabicTableArray;
        private stSeparator;
        private modePdf;
        convert(inputString: StringBuilder, useRightToLeft: boolean): StringBuilder;
        private convertArabic;
        private symbolIsDigitOrDelimiter;
        private static symbolIsArabicOrHebrew;
        static stringContainArabicOrHebrew(st: string): boolean;
        private symbolIsBidiMark;
        private symbolIsLTRMark;
        private symbolIsRTLMark;
        clear(): void;
        constructor(modePdf?: boolean);
    }
}
declare namespace Stimulsoft.Report.Export {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiExportImage = Stimulsoft.Report.Components.IStiExportImage;
    class StiCell {
        clone(): StiCell;
        forceExportAsImage(exportImage: any): boolean;
        private _exportFormat;
        get exportFormat(): StiExportFormat;
        set exportFormat(value: StiExportFormat);
        private _component;
        get component(): StiComponent;
        set component(value: StiComponent);
        _exportImage: IStiExportImage;
        get exportImage(): IStiExportImage;
        set exportImage(value: IStiExportImage);
        cellStyle: StiCellStyle;
        left: number;
        top: number;
        width: number;
        private _height;
        get height(): number;
        set height(value: number);
        text: string;
        constructor(exportFormat?: StiExportFormat);
    }
}
declare namespace Stimulsoft.Report.Export {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    class StiCellStyle {
        clone(): StiCellStyle;
        getHashCode(): number;
        equals(obj: any): boolean;
        static getStyleFromCache(color: Color, textColor: Color, font: Font, horAlignment: StiTextHorAlignment, vertAlignment: StiVertAlignment, border: StiBorderSide, borderL: StiBorderSide, borderR: StiBorderSide, borderB: StiBorderSide, textOptions: StiTextOptions, wordWrap: boolean, format: string, internalStyleName: string, lineSpacing: number, hashStyles: Hashtable, styles: StiCellStyle[], fontsCache: Hashtable, cellStyle: StiCellStyle, simplyAdd: boolean, overflow: boolean, borderRadius: number): StiCellStyle;
        border: StiBorderSide;
        borderL: StiBorderSide;
        borderR: StiBorderSide;
        borderB: StiBorderSide;
        absolutePosition: boolean;
        color: Color;
        font: Font;
        horAlignment: StiTextHorAlignment;
        vertAlignment: StiVertAlignment;
        textOptions: StiTextOptions;
        textColor: Color;
        wordWrap: boolean;
        format: string;
        overflow: boolean;
        borderRadius: number;
        lineSpacing: number;
        private _internalStyleName;
        get internalStyleName(): string;
        set internalStyleName(value: string);
        private _styleName;
        get styleName(): string;
        set styleName(value: string);
        constructor(color: Color, textColor: Color, font: Font, horAlignment: StiTextHorAlignment, vertAlignment: StiVertAlignment, border: StiBorderSide, borderL: StiBorderSide, borderR: StiBorderSide, borderB: StiBorderSide, textOptions: StiTextOptions, wordWrap: boolean, format: string, lineSpacing: number, styleName?: string, overflow?: boolean, borderRadius?: number);
    }
}
declare namespace Stimulsoft.Report.Export {
    import ImageFormat = Stimulsoft.System.Drawing.Imaging.ImageFormat;
    class StiExportImageHelper {
        static convertAllImages(renderedReport: StiReport, imageFormat: ImageFormat, flate?: boolean, format?: StiExportFormat): Promise<void>;
    }
}
declare namespace Stimulsoft.Report.Export {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiHtmlImageHost {
        htmlExport: StiHtmlExportService;
        isMhtExport: boolean;
        forcePng: boolean;
        getImageString(bmp: Image): string;
        constructor(htmlExport: StiHtmlExportService);
    }
}
declare namespace Stimulsoft.Report.Export {
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import TextWriter = Stimulsoft.System.IO.TextWriter;
    import StiMargins = Stimulsoft.Report.Components.StiMargins;
    enum StiHtmlUnitType {
        Pixel = 0,
        Point = 1
    }
    class StiHtmlUnit {
        private static hiToPt;
        value: number;
        unitType: StiHtmlUnitType;
        toString(): string;
        static toPixelString(value: number): string;
        static newUnit2(value: number, unitType: StiHtmlUnitType): StiHtmlUnit;
        static newUnit(value: number, usePoints?: boolean): StiHtmlUnit;
        static isNullOrZero(unit: StiHtmlUnit): boolean;
    }
    class StiHtmlSvg {
        text: string;
    }
    class StiHtmlHyperlink {
        text: string;
        toolTip: string;
        navigateUrl: string;
        attributes: Hashtable;
        style: Hashtable;
        imageUrl: string;
        cssClass: string;
        width: StiHtmlUnit;
        height: StiHtmlUnit;
        openLinksTarget: string;
        id: string;
        constructor();
    }
    class StiHtmlImage {
        toolTip: string;
        imageUrl: string;
        width: StiHtmlUnit;
        height: StiHtmlUnit;
        aspectRatio: boolean;
        multipleFactor: number;
        margins: StiMargins;
        horAlignment: number;
        vertAlignment: number;
        imageRotation: number;
        stretch: boolean;
        zoom: number;
        base64: string;
    }
    class StiHtmlTableCell {
        width: StiHtmlUnit;
        height: StiHtmlUnit;
        style: Hashtable;
        columnSpan: number;
        rowSpan: number;
        cssClass: string;
        text: string;
        toolTip: string;
        controls: any[];
        id: string;
        interaction: string;
        collapsed: string;
        sortDirection: string;
        dataBandSort: string;
        pageGuid: string;
        pageIndex: string;
        reportFile: string;
        componentIndex: string;
        editable: string;
        drillDownMode: string;
        constructor();
    }
    class StiHtmlTableRow {
        style: Hashtable;
        cells: StiHtmlTableCell[];
        height: StiHtmlUnit;
        constructor();
    }
    class StiHtmlTable {
        backImageUrl: string;
        backgroundRepeat: string;
        backgroundPosition: string;
        width: StiHtmlUnit;
        maxWidth: StiHtmlUnit;
        border: StiBorder;
        borderWidth: number;
        cellPadding: number;
        cellSpacing: number;
        rows: StiHtmlTableRow[];
        align: StiHorAlignment;
        position: string;
        static marginsKey: string;
        static pageBreakBeforeKey: string;
        static vertAlignKey: string;
        static horAlignKey: string;
        static wordwrapKey: string;
        private static wrongUrlSymbols;
        htmlExportSettings: StiHtmlExportSettings;
        static stringToUrl(input: string): string;
        renderControl(writer: StiHtmlTextWriter, addPageBreaks: boolean): void;
        private writeTableBegin;
        private writeTableEnd;
        constructor();
    }
    enum WriterMode {
        None = 0,
        BeginTag = 1,
        Attribute = 2,
        Data = 3
    }
    class StiHtmlTextWriter {
        private stream;
        private mode;
        indent: number;
        write(st: string): void;
        writeLine(st?: string): void;
        writeBeginTag(st: string): void;
        writeFullBeginTag(st: string): void;
        writeEndTag(st: string): void;
        writeFullEndTag(st: string): void;
        writeAttribute(attr: string, value: string): void;
        writeStyleAttribute(attr: string, value: string): void;
        flush(): void;
        getStream(): TextWriter;
        private closeTag;
        private checkIndent;
        constructor(baseStream: TextWriter);
    }
    class StiHtmlTableRender {
        private htmlExport;
        private htmlExportSettings;
        matrix: StiMatrix;
        renderStyle(style: StiCellStyle): void;
        renderStyleTable(cell: StiHtmlTableCell, style: StiCellStyle): void;
        renderStyles(useBookmarks: boolean, exportBookmarksOnly: boolean, cssStyles: Hashtable): void;
        renderStylesTable(useBookmarks: boolean, exportBookmarksOnly: boolean, cssStyles?: Hashtable): void;
        renderStylesTable2(useBookmarks: boolean, exportBookmarksOnly: boolean, addStyleTag: boolean, cssStyles?: Hashtable): void;
        private getWidth;
        private getHeight;
        renderTable(renderStyles: boolean, backGroundImageString: string, useBookmarks: boolean, exportBookmarksOnly: boolean, cssStyles: Hashtable, watermarkShowBehind?: boolean, border?: StiBorder): void;
        constructor(htmlExport: StiHtmlExportService, htmlExportSettings: StiHtmlExportSettings, pages: StiPagesCollection);
    }
}
declare namespace Stimulsoft.Report.Export {
    import List = Stimulsoft.System.Collections.List;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    import Image = Stimulsoft.System.Drawing.Image;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    enum StiTableLineInfo {
        Empty = 0,
        Unknown = 1,
        PageHeader = 2,
        PageFooter = 3,
        HeaderAP = 4,
        FooterAP = 5,
        HeaderD = 6,
        FooterD = 7,
        Data = 8,
        Trash = 9
    }
    class StiMatrix {
        cells: StiCell[][];
        cellsMap: StiCell[][];
        totalHeight: number;
        totalWidth: number;
        styles: StiCellStyle[];
        coordX: List<number>;
        coordY: List<number>;
        linePlacement: StiTableLineInfo[];
        parentBandName: string[];
        bordersX: StiBorderSide[][];
        bordersY: StiBorderSide[][];
        horizontalPageBreaks: number[];
        cellStyles: StiCellStyle[][];
        bookmarks: string[][];
        bookmarksTable: Hashtable;
        interactions: number[][][];
        private maxRowHeight;
        private _defaultLinePrimitiveWidth;
        private static staticRectanglePrimitive;
        private coordXCheck;
        private coordYCheck;
        private coordXNew;
        private coordYNew;
        private coordXPrim;
        private coordYPrim;
        imagesBaseRect: Hashtable;
        private leftCached;
        private topCached;
        private xcHash;
        private ycHash;
        private tagSplitCache;
        private stylesCache;
        private fontsCache;
        private createdCells;
        borderSides: StiBorderSide[];
        exportFormat: StiExportFormat;
        private isHtmlService;
        private isHtmlOrExcelXmlService;
        private isHtmlPngMode;
        report: StiReport;
        private pages;
        private addComponentWithInteractions;
        private replaceCheckboxes;
        private hyperlinksToTag;
        pointerToBookmark: Hashtable;
        private pointerToTag;
        private maxCoordY;
        private defaultLinePrimitiveWidth;
        private setBookmarkValue;
        private static sortForMatrix;
        private round;
        private addCoord;
        static htmlScaleX: number;
        static htmlScaleY: number;
        private addCoord2;
        prepareTable(): void;
        getRange(rect: RectangleD): Rectangle;
        getStyleFromComponent(component: StiComponent, x: number, y: number, id: string): StiCellStyle;
        private getStyle;
        private renderComponent;
        private getCellRectangle;
        private cutRectangleFromCellsMap;
        isComponentHasInteraction(component: StiComponent): boolean;
        scanComponentsPlacement(optimize: boolean, exportObjectFormatting?: boolean): void;
        private processIntersectedCells;
        splitTagWithCache(inputString: string): string[];
        static splitTag(inputString: string): string[];
        static getStringsFromTag(tag: string, startPosition: number): string[];
        private copyFieldsListToFields;
        fields: DataField[];
        dataArrayLength: number;
        private fieldsList;
        private sizeX;
        private sizeY;
        private htName;
        prepareDocument(service: StiExportService, mode: StiDataExportMode): void;
        checkStylesNames(): void;
        getRealImageData(cell: StiCell, baseImage: Image): Image;
        private checkComponentPlacement;
        private lastPage;
        private lastPageId;
        private lastComps;
        getBorderSideIndex(side: StiBorderSide): number;
        static GCCollect(): void;
        clear(): void;
        constructor(pages: StiPagesCollection, checkForExcel: boolean, service: StiExportService, styles?: StiCellStyle[], dataMode?: StiDataExportMode, hasDividedPages?: boolean);
    }
    class DataField {
        name: string;
        info: number[];
        formatString: string;
        dataArray: string[];
        readyName: boolean;
        readyType: boolean;
        constructor(size: number);
    }
}
declare namespace Stimulsoft.Report.Export {
    enum EmfTextAlignmentMode {
        TA_LEFT = 0,
        TA_RIGHT = 2,
        TA_CENTER = 6,
        TA_TOP = 0,
        TA_BOTTOM = 8,
        TA_BASELINE = 24,
        TA_NOUPDATECP = 0,
        TA_UPDATECP = 1,
        TA_RTLREADING = 256,
        TA_MASK = 287
    }
}
declare namespace Stimulsoft.Report.Export {
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    class StiSegmentPagesDivider {
        static divide(pages: StiPagesCollection, service?: StiExportService): StiPagesCollection;
    }
}
declare namespace Stimulsoft.Report.Func {
    class Ar {
        static MyAnd: string;
        static MyArry1: string[];
        static MyArry2: string[];
        static MyArry3: string[];
        static numToStr(numb: number, currency: string, subCurrency: string): string;
    }
}
declare namespace Stimulsoft.Report.Func {
    import DateTime = Stimulsoft.System.DateTime;
    class En {
        private static months;
        private static units;
        private static tens;
        private static addUnits;
        private static addTens;
        private static addRank;
        static decline(value: number, oneOrShowCents: string | boolean, twoOrDollars: string, cents?: string): string;
        static numToStr(value: number, uppercase?: boolean): string;
        static currToStr3(value: number, showCents: boolean): string;
        static currToStr(value: number, uppercase?: boolean, showCents?: boolean, dollars?: string, cents?: string): string;
        static dateToStr(date: DateTime, uppercase?: boolean): string;
    }
}
declare namespace Stimulsoft.Report.Func {
    class EnGb {
        static zeroWord: string;
        static lessWord: string;
        static triplets: string[][];
        static lessTwenty: string[];
        static tens: string[];
        static convertToWord(numberr: number, currencyISO: string, decimals: number): string;
        private static convertToWord2;
        private static calculateOver;
    }
}
declare namespace Stimulsoft.Report.Func {
    class EnIn {
        static numberToStr(value: number, blankIfZero?: boolean): string;
        static currencyToStr(currencyBasicUnit: string, currencyFractionalUnit: string, value: number, decimalPlaces: number, blankIfZero?: boolean): string;
        private static numberToWords;
        private static _wordsDictionary;
        private static get wordsDictionary();
    }
}
declare namespace Stimulsoft.Report.Func {
    class Es {
        static zeroWord: string;
        static lessWord: string;
        static triplets: string[][];
        static lessTwenty: string[];
        static tens: string[];
        static currencies: string[][];
        static convertToWord(numberr: number, currencyISO: string, decimals: number): string;
        private static determinateCurrenciesEurUsd;
        static numToStr(numberr: number, uppercase: boolean): string;
        static numToStr2(numberr: number, uppercase: boolean, female: boolean): string;
        private static convertToWord2;
    }
}
declare namespace Stimulsoft.Report.Func {
    class Fa {
        static convertToWord(numberr: number): string;
        private static changingNum;
    }
}
declare namespace Stimulsoft.Report.Func {
    class Fr {
        static zeroWord: string;
        static lessWord: string;
        static triplets: string[][];
        static lessTwentys: string[];
        static tens: string[];
        static convertToWord(numberr: number, currencyISO: string, decimals: number): string;
        private static convertToWord2;
        private static calculateOver;
    }
}
declare namespace Stimulsoft.Report.Func {
    class Nl {
        static zeroWord: string;
        static lessWord: string;
        static triplets: string[][];
        static lessTwenty: string[];
        static tens: string[];
        static convertToWord(numberr: number, currencyISO: string, decimals: number): string;
        private static convertToWord2;
        private static calculateOver;
    }
}
declare namespace Stimulsoft.Report.Func {
    import DateTime = Stimulsoft.System.DateTime;
    class Pl {
        private static units;
        private static tens;
        private static hundreds;
        private static thousends;
        private static million;
        private static billion;
        private static trillion;
        private static quadrillion;
        private static quintillion;
        private static zloty;
        private static grosz;
        private static dollar;
        private static cent;
        private static euro;
        private static months;
        static numToStr(value: number, uppercase: boolean): string;
        private static addUnits;
        private static addTens;
        private static addHundreds;
        private static addRank;
        private static decline2;
        private static decline;
        private static currToStr2;
        static currToStr(value: number, currencyISO: string, showCents: boolean, uppercase: boolean): string;
        static dateToStr(date: DateTime, uppercase: boolean): string;
    }
}
declare namespace Stimulsoft.Report.Func {
    import DateTime = Stimulsoft.System.DateTime;
    class Pt {
        private static units;
        private static tens;
        private static months;
        static numToStr(value: number, uppercase: boolean): string;
        private static addRank;
        private static addUnits;
        private static addTens;
        private static decline;
        private static decline2;
        static currToStr(value: number, uppercase: boolean, showCents: boolean): string;
        static dateToStr(value: DateTime): string;
    }
}
declare namespace Stimulsoft.Report.Func {
    class PtBr {
        private static unid;
        private static dezena;
        private static centena;
        static numToStr(value: number): string;
    }
}
declare namespace Stimulsoft.Report.Func {
    import DateTime = Stimulsoft.System.DateTime;
    class Ru {
        private static currencies;
        static registerCurrency(currency: Currency, currencyName: string): void;
        private static getCurrency;
        private static months;
        private static units;
        private static tens;
        private static hundreds;
        private static gendered;
        private static addUnits;
        private static addTens;
        private static addHundreds;
        private static addThousand;
        private static addRank;
        static numToStr(value: number, uppercase?: boolean, gender?: Gender): string;
        static currToStr(value: number, uppercase?: boolean, currency?: string, cents?: boolean): string;
        static decline2(value: number, one: string, two: string, five: string): string;
        static decline(value: number, currency: string, cents?: boolean): string;
        static dateToStr(date: DateTime, uppercase?: boolean): string;
    }
}
declare namespace Stimulsoft.Report.Func {
    class Tr {
        static Birler: string[];
        static Onlar: string[];
        static Binler: string[];
        static numToStr(value: number): string;
        static currToStr(value: number, currencyName?: string, showZeroCents?: boolean): string;
    }
}
declare namespace Stimulsoft.Report.Func {
    import DateTime = Stimulsoft.System.DateTime;
    class Ua {
        private static currencies;
        static registerCurrency(currency: Currency, currencyName: string): void;
        private static getCurrency;
        private static months;
        private static units;
        private static tens;
        private static hundreds;
        private static gendered;
        private static addUnits;
        private static addTens;
        private static addHundreds;
        private static addThousand;
        private static addRank;
        static numToStr(value: number, uppercase?: boolean, gender?: Gender): string;
        static currToStr(value: number, uppercase?: boolean, currency?: string, cents?: boolean): string;
        static decline2(value: number, one: string, two: string, five: string): string;
        static decline(value: number, currency: string, cents?: boolean): string;
        static dateToStr(date: DateTime, uppercase?: boolean): string;
    }
}
declare namespace Stimulsoft.Report.Func {
    class Zh {
        private static numChineseCharacter;
        static toWordsZh(num: number): string;
        static toCurrencyWordsZh(num: number): string;
        private static floatString;
        private static numberString;
        private static convert4;
        private static convertString;
        private static convert2;
        private static convert3;
    }
}
declare namespace Stimulsoft.Report {
    let IStiGlobalizationManagerList: System.Interface<IStiGlobalizationManagerList>;
    interface IStiGlobalizationManagerList {
        getTextGlobalizedNames(): string[];
        getImageGlobalizedNames(): string[];
    }
}
declare namespace Stimulsoft.Report {
    let IStiGlobalizationProvider: System.Interface<IStiGlobalizationProvider>;
    interface IStiGlobalizationProvider {
        setString(propertyName: string, value: string): any;
        getString(propertyName: string): string;
        getAllStrings(): string[];
    }
}
declare namespace Stimulsoft.Report {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiGlobalizationContainer implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        private _cultureName;
        get cultureName(): string;
        set cultureName(value: string);
        private _items;
        get items(): StiGlobalizationItemCollection;
        set items(value: StiGlobalizationItemCollection);
        getAllStringsForReport(report: StiReport): Hashtable;
        localizeReport(report: StiReport): void;
        fillItemsFromReport(report: StiReport): void;
        removeUnlocalizedItemsFromReport(report: StiReport): void;
        constructor(cultureName?: string);
    }
}
declare namespace Stimulsoft.Report {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiGlobalizationContainerCollection extends CollectionBase<StiGlobalizationContainer> implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        getByName(name: string): StiGlobalizationContainer;
        setByName(name: string, value: StiGlobalizationContainer): void;
        private report;
        skipException: boolean;
        private getShortName;
        localizeReport(cultureName: string): void;
        localizeReport2(info: CultureInfo): void;
        fillItemsFromReport(): void;
        removeUnlocalizedItemsFromReport(): void;
        removeComponent(comp: StiComponent): void;
        renameComponent(comp: StiComponent, oldName: string, newName: string): void;
        constructor(report: StiReport);
    }
}
declare namespace Stimulsoft.Report {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiGlobalizationItem implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        private _propertyName;
        get propertyName(): string;
        set propertyName(value: string);
        private _text;
        get text(): string;
        set text(value: string);
        toString(): string;
        constructor(propertyName?: string, text?: string);
    }
}
declare namespace Stimulsoft.Report {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    class StiGlobalizationItemCollection extends CollectionBase<StiGlobalizationItem> implements IComparer<StiGlobalizationItem> {
        compare(item1: StiGlobalizationItem, item2: StiGlobalizationItem): number;
        sort(): void;
    }
}
declare namespace Stimulsoft.Report {
    class StiAbbreviationNumberFormatHelper {
        static format(value: number): string;
        static format2(value: number, outPostfix: any): number;
        static format3(value: number, outPostfix: any, decimalDigits: any, totalNumberCapacity: number): number;
    }
}
declare namespace Stimulsoft.Report.Helpers {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiAppExpressionParser {
        static processExpressions(component: StiComponent, allowDataLoading?: boolean): void;
        static parseBoolExpression(component: StiComponent, propName: string, allowDataLoading?: boolean): boolean;
        static parseStringExpression(component: StiComponent, propName: string, allowDataLoading?: boolean): string;
        static parseColorExpression(component: StiComponent, propName: string, allowDataLoading?: boolean): Color;
        static parseBrushExpression(component: StiComponent, propName: string, allowDataLoading?: boolean): StiBrush;
        private static parseExpression;
    }
}
declare namespace Stimulsoft.Report.Helpers {
    import List = Stimulsoft.System.Collections.List;
    class StiFileDialogHelper {
        static dataExts: List<string>;
        static imageExts: List<string>;
        static reportExts: List<string>;
        static textExts: List<string>;
        static documentExts: List<string>;
        static fontExts: List<string>;
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Font = Stimulsoft.System.Drawing.Font;
    import GraphicsUnit = Stimulsoft.System.Drawing.GraphicsUnit;
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    class StiFontGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        static changeFontSize(font: Font, newFontSize: number): StiFontGeom;
        fontName: string;
        fontSize: number;
        fontStyle: FontStyle;
        unit: GraphicsUnit;
        get type(): StiGeomType;
        static create(font: Font): StiFontGeom;
        constructor(fontName: string, fontSize: number, style: FontStyle, unit: GraphicsUnit);
    }
}
declare namespace Stimulsoft.Report {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiFontIconGroup = Stimulsoft.Report.Helpers.StiFontIconGroup;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiFontIconSet = Stimulsoft.Report.Helpers.StiFontIconSet;
    import List = Stimulsoft.System.Collections.List;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import Size = Stimulsoft.System.Drawing.Size;
    class StiFontIconsHelper {
        static convertFontIconToImage(icon: StiFontIcons, color: Color, width: number, height: number, dy?: string): Image;
        static writeFontIconImage(writer: XmlTextWriter, color: Color, icon: StiFontIcons, width: number, height: number, dy?: string): void;
        static convertFontIconToImageAsync(icon: StiFontIcons, color: Color, width: number, height: number, dy?: string): Promise<Image>;
        static getContent(fontIcons: StiFontIcons): string;
        private static getNetContent;
        static getIsonSetContent(iconSet: StiFontIconSet): string;
        static getFontIcons(iconSet: StiFontIconSet): List<StiFontIcons>;
        static getFontIcons1(iconGroup: StiFontIconGroup): List<StiFontIcons>;
        static getIconFontSize(context: StiContext, size: Size, text: string): number;
        static drawFillIcons(context: StiContext, brush: object, rect: Rectangle, singleSize: Size, icon: StiFontIcons, toolTip: string, verticalDirection?: boolean): void;
        static drawDirectionIcons(context: StiContext, brush: object, rect: Rectangle, singleSize: Size, icon: StiFontIcons, toolTip: string, verticalDirection: boolean, roundValues?: boolean): void;
        private static getStringFormatGeom;
    }
}
declare namespace Stimulsoft.Report.Helpers {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImageTransparenceHelper {
        static getTransparentedImage(source: Image, transparency: number): Image;
    }
}
declare namespace Stimulsoft.Report.Helpers {
    import List = Stimulsoft.System.Collections.List;
    class StiIsoCountry {
        names: List<string>;
        ruNames: List<string>;
        frNames: List<string>;
        alpha2: string;
        alpha3: string;
        ru(...names: string[]): StiIsoCountry;
        fr(...names: string[]): StiIsoCountry;
        iso(alpha2: string, alpha3?: string): StiIsoCountry;
        constructor(...names: string[]);
    }
}
declare namespace Stimulsoft.Report.Helpers {
    import List = Stimulsoft.System.Collections.List;
    class StiIsoElementHelper {
        private static _countries;
        static get countries(): List<StiIsoCountry>;
        private static _usStates;
        static get usStates(): List<StiIsoCountry>;
        private static _canadaProvinces;
        static get canadaProvinces(): List<StiIsoCountry>;
        private static _brazilProvinces;
        static get brazilProvinces(): List<StiIsoCountry>;
        static getIsoAlpha2FromName(name: string, mapId?: string): string;
        static getIsoAlpha3FromName(name: string, mapId?: string): string;
        static getCountryFromName(name: string, mapId?: string): StiIsoCountry;
        private static getCountries;
        private static isEqual;
        static getCountryFromAlpha3(alpha3: string, mapId?: string): StiIsoCountry;
        static getCountryFromAlpha2(alpha2: string, mapId?: string): StiIsoCountry;
        private static initializeCountries;
        private static initializeUsStates;
        private static initializeCanadaProvinces;
        private static initializeBrazilProvinces;
    }
}
declare namespace Stimulsoft.Report.Maps.Helpers {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    class StiGssMapHelper {
        private static hash;
        static allowGss(ident: string): boolean;
        static get(id: string): Dictionary<string, string>;
        static init(id: string): void;
        static isGssValue(value: string): boolean;
        private static add;
        private static initUKCountries;
    }
}
declare namespace Stimulsoft.Report.Helpers {
    import List = Stimulsoft.System.Collections.List;
    import IStiMapKeyHelper = Stimulsoft.Base.Map.IStiMapKeyHelper;
    class StiMapKeyHelper implements IStiMapKeyHelper {
        getMapIdents(key: string): List<string>;
        private static getMapIdents2;
        getNameFromIsoAlpha2(alpha2: string, mapId?: string, report?: StiReport): string;
        getNameFromIsoAlpha3(alpha3: string, mapId?: string, report?: StiReport): string;
        normalizeName(name: string, mapId?: string, report?: StiReport): string;
        getIsoAlpha2FromName(name: string, mapId?: string, report?: StiReport): string;
        getIsoAlpha3FromName(name: string, mapId?: string, report?: StiReport): string;
        convertMapKeysToIsoAlpha2(mapKeys: List<string>, mapId: string, report?: StiReport): List<string>;
        getMapKeysFromNames(values: List<any>, mapId: string, report?: StiReport): List<string>;
        private getMapKeyFromName;
        static simplify(key: string): string;
    }
}
declare namespace Stimulsoft.Base.Maps.Geoms {
    class StiMapGeomsContainer {
        name: string;
        width: number;
        height: number;
        geoms: StiMapGeomsObject[];
    }
}
declare namespace Stimulsoft.Base.Maps.Geoms {
    class StiMapGeomsObject {
        name: string;
        geoms: StiMapGeom[];
    }
}
declare namespace Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiMapGeom {
        get geomType(): StiMapGeomType;
        getLastPoint(): Point;
    }
}
declare namespace Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiMoveToMapGeom extends StiMapGeom {
        get geomType(): StiMapGeomType;
        x: number;
        y: number;
        getLastPoint(): Point;
    }
}
declare namespace Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiLineMapGeom extends StiMapGeom {
        get geomType(): StiMapGeomType;
        x: number;
        y: number;
        getLastPoint(): Point;
    }
}
declare namespace Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiBezierMapGeom extends StiMapGeom {
        get geomType(): StiMapGeomType;
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        x3: number;
        y3: number;
        getLastPoint(): Point;
    }
}
declare namespace Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiBeziersMapGeom extends StiMapGeom {
        get geomType(): StiMapGeomType;
        array: number[];
        getLastPoint(): Point;
    }
}
declare namespace Stimulsoft.Base.Maps.Geoms {
    class StiCloseMapGeom extends StiMapGeom {
        get geomType(): StiMapGeomType;
    }
}
declare namespace Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    import List = Stimulsoft.System.Collections.List;
    class StiMapGeomCollection extends List<StiMapGeom> {
        getLastPoint(): Point;
    }
}
declare namespace Stimulsoft.Report.Maps {
    import StiMapGeom = Stimulsoft.Base.Maps.Geoms.StiMapGeom;
    import StiMapGeomsContainer = Stimulsoft.Base.Maps.Geoms.StiMapGeomsContainer;
    class StiMapLoader {
        private static hashMaps;
        static deleteAllCustomMaps(): void;
        static loadResource(report: StiReport, resourceName: string): StiMapSvgContainer;
        static getGeomsObject(report: StiReport, resourceName: string): StiMapGeomsContainer;
        private static createGeom;
        static parsePath(text: string): StiMapGeom[];
    }
}
declare namespace Stimulsoft.Report.Helpers {
    import StiMapSvg = Stimulsoft.Report.Maps.StiMapSvg;
    class StiMapResourceHelper {
        static getSvgBlockFromIsoAlpha2(alpha2: string, mapId?: string, report?: StiReport): StiMapSvg;
        static getSvgBlockFromName(name: string, mapId?: string, report?: StiReport): StiMapSvg;
        static getIsoAlpha2FromName(name: string, mapId?: string, report?: StiReport): string;
        static getIsoAlpha3FromName(name: string, mapId?: string, report?: StiReport): string;
        private static getResource;
        private static decodeAlpha;
    }
}
declare namespace Stimulsoft.Report.Helpers {
    import RegionInfo = Stimulsoft.System.Globalization.RegionInfo;
    class StiRegionInfoHelper {
        static getIsoAlpha2FromName(name: string): string;
        static getIsoAlpha3FromName(name: string): string;
        static getNameFromIsoAlpha2(alpha2: string): string;
        static getNameFromIsoAlpha3(alpha3: string): string;
        static getLocalizedNameFromIsoAlpha2(alpha2: string): string;
        static getLocalizedNameFromIsoAlpha3(alpha3: string): string;
        static getRegionInfoFromName(name: string): RegionInfo;
        private static getAllRegions;
    }
}
declare namespace Stimulsoft.Report.Helpers {
    import StiRelationDirection = Stimulsoft.Base.StiRelationDirection;
    import DataSet = Stimulsoft.System.Data.DataSet;
    import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
    class StiResourceArrayToDataSet {
        static get(resourceType: StiResourceType, array: number[], report?: StiReport, pathData?: string, tryParseDateTime?: boolean, relationDirection?: StiRelationDirection): DataSet;
    }
}
declare namespace Stimulsoft.Report.Helpers {
    import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
    class StiResourceTypeHelper {
        static getTypeFromExtension(extension: string): StiResourceType;
        static isImageType(ext: string): boolean;
        static isTextType(ext: string): boolean;
        private static isExtensionType;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    enum StiGaugeRangeMode {
        Percentage = 1,
        Value = 2
    }
    enum StiScaleMode {
        V1 = 1,
        V2 = 2
    }
    enum StiGaugeRangeType {
        None = 0,
        Color = 1
    }
    enum StiGaugeCalculationMode {
        Auto = 1,
        Custom = 2
    }
    enum StiGaugeType {
        FullCircular = 0,
        HalfCircular = 1,
        Linear = 2,
        HorizontalLinear = 3,
        Bullet = 4
    }
    enum StiPlacement {
        Outside = 0,
        Overlay = 1,
        Inside = 2
    }
    enum StiGaugeElemenType {
        LinearElement = 0,
        RadialElement = 1,
        All = 2
    }
    enum StiBarRangeListType {
        LinearBar = 0,
        RadialBar = 1
    }
    enum StiLinearRangeColorMode {
        Default = 0,
        MixedColor = 1
    }
    enum StiRadialScaleSkin {
        Default = 0,
        Empty = 1,
        RadialScaleQuarterCircleNW = 2,
        RadialScaleQuarterCircleNE = 3,
        RadialScaleQuarterCircleSW = 4,
        RadialScaleQuarterCircleSE = 5,
        RadialScaleHalfCircleN = 6,
        RadialScaleHalfCircleS = 7
    }
    enum StiMarkerSkin {
        Diamond = 0,
        Rectangle = 1,
        TriangleTop = 2,
        TriangleBottom = 3,
        PentagonTop = 4,
        PentagonBottom = 5,
        Ellipse = 6,
        RectangularCalloutTop = 7,
        RectangularCalloutBottom = 8,
        TriangleLeft = 9,
        TriangleRight = 10,
        PentagonLeft = 11,
        PentagonRight = 12,
        RectangularCalloutLeft = 13
    }
    enum StiStateSkin {
        Ellipse = 0,
        Rectangle = 1,
        Diamond = 2
    }
    enum StiLinearBarSkin {
        Default = 0,
        HorizontalThermometer = 1,
        VerticalThermometer = 2
    }
    enum StiNeedleSkin {
        DefaultNeedle = 0,
        SpeedometerNeedle = 1,
        SpeedometerNeedle2 = 2,
        SimpleNeedle = 3
    }
    enum StiTickMarkSkin {
        Rectangle = 0,
        Ellipse = 1,
        Diamond = 2,
        TriangleTop = 3,
        TriangleRight = 4,
        TriangleLeft = 5,
        TriangleBottom = 6
    }
    enum StiRadiusMode {
        Auto = 0,
        Width = 1,
        Height = 2
    }
    enum StiRadialPosition {
        TopLeft = 0,
        TopRight = 1,
        BottonLeft = 2,
        BottomRight = 3,
        TopCenter = 4,
        LeftCenter = 5,
        BottomCenter = 6,
        RightCenter = 7
    }
    enum StiLabelRotationMode {
        None = 0,
        Automatic = 1,
        SurroundIn = 2,
        SurroundOut = 3
    }
    enum StiGaugeStyleId {
        StiStyle25 = 0,
        StiStyle26 = 1,
        StiStyle27 = 2,
        StiStyle28 = 3,
        StiStyle29 = 4,
        StiStyle30 = 5
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import StiGaugeCalculationMode = Stimulsoft.Report.Gauge.StiGaugeCalculationMode;
    import StiScaleMode = Stimulsoft.Report.Gauge.StiScaleMode;
    import StiGaugeType = Stimulsoft.Report.Gauge.StiGaugeType;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    let IStiGauge: System.Interface<IStiGauge>;
    interface IStiGauge extends IStiComponent {
        scales: any;
        customStyleName: string;
        drawGauge(context: StiGaugeContextPainter): any;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): any;
        prepareInit(): any;
        minimum: number;
        maximum: number;
        mode: StiScaleMode;
        type: StiGaugeType;
        calculationMode: StiGaugeCalculationMode;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    let IStiGaugeStyle: System.Interface<IStiGaugeStyle>;
    interface IStiGaugeStyle extends ICloneable, IStiJsonReportObject {
        core: IStiGaugeStyleCoreXF;
        createNew(): IStiGaugeStyle;
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import IStiGauge = Stimulsoft.Report.Components.Gauge.IStiGauge;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    let IStiGaugeStyleCoreXF: System.Interface<IStiGaugeStyleCoreXF>;
    interface IStiGaugeStyleCoreXF {
        localizedName: string;
        brush: StiBrush;
        borderColor: Color;
        borderWidth: number;
        targetColor: Color;
        foreColor: Color;
        tickMarkMajorBrush: StiBrush;
        tickMarkMajorBorder: StiBrush;
        tickMarkMajorBorderWidth: number;
        tickMarkMinorBrush: StiBrush;
        tickMarkMinorBorder: StiBrush;
        tickMarkMinorBorderWidth: number;
        tickLabelMajorTextBrush: StiBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiBrush;
        tickLabelMinorFont: Font;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        linearBarBorderBrush: StiBrush;
        linearBarEmptyBrush: StiBrush;
        linearBarEmptyBorderBrush: StiBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiBrush;
        radialBarBorderBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
        radialBarEmptyBorderBrush: StiBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
        markerSkin: StiMarkerSkin;
        markerBrush: StiBrush;
        markerBorderBrush: StiBrush;
        markerBorderWidth: number;
        styleId: StiGaugeStyleId;
        gauge: IStiGauge;
    }
}
declare namespace Stimulsoft.Report.Maps {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiMapSvgContainer {
        isNotCorrect: boolean;
        isCustom: boolean;
        name: string;
        width: number;
        height: number;
        textScale: number;
        paths: StiMapSvg[];
        hashPaths: Hashtable<string, StiMapSvg>;
        icon: string;
        prepare(): void;
    }
}
declare namespace Stimulsoft.Report.Maps {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap21StyleFX extends StiMapStyleFX {
        get styleId(): StiMapStyleIdent;
        get localizeName(): string;
        get individualColor(): Color;
        set individualColor(value: Color);
        get colors(): Color[];
        set colors(value: Color[]);
        get defaultColor(): Color;
        set defaultColor(value: Color);
        get backColor(): Color;
        set backColor(value: Color);
        constructor();
    }
}
declare namespace Stimulsoft.Report.Painters {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Image = Stimulsoft.System.Drawing.Image;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    let IStiBarCodePainter: System.Interface<IStiBarCodePainter>;
    interface IStiBarCodePainter {
        baseTransform(context: any, x: number, y: number, angle: number, dx: number, dy: number): any;
        baseRollbackTransform(context: any): any;
        baseFillRectangle(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): any;
        baseFillRectangle2D(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): any;
        baseFillPolygon(context: any, brush: StiBrush, points: PointD[]): any;
        baseFillEllipse(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): any;
        baseDrawRectangle(context: any, penColor: Color, penSize: number, x: number, y: number, width: number, height: number): any;
        baseDrawImage(context: any, image: Image, report: StiReport, x: number, y: number, width: number, height: number): any;
        baseDrawString(context: any, st: string, font: Font, brush: StiBrush, rect: RectangleD, sf: StringFormat): any;
        baseMeasureString(context: any, st: string, font: Font): SizeD;
    }
}
declare namespace Stimulsoft.Report.Painters {
    let IStiPagePainter: System.Interface<IStiPagePainter>;
    interface IStiPagePainter {
    }
}
declare namespace Stimulsoft.Report.Painters {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import SolidBrush = Stimulsoft.System.Drawing.SolidBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import Brush = Stimulsoft.System.Drawing.Brush;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiMapStyle = Stimulsoft.Report.Styles.StiMapStyle;
    import List = Stimulsoft.System.Collections.List;
    import StiMapData = Stimulsoft.Report.Maps.StiMapData;
    import StiMap = Stimulsoft.Report.Maps.StiMap;
    class StiStyleColorsContainer {
        private stackColors;
        private index;
        private painter;
        getColor(index: number, count: number): Brush;
        getColor1(index: number, count: number): StiSolidBrush;
        getColors(seriesCount: number): Color[];
        init(map: StiMap, painter: StiGdiMapContextPainter): void;
    }
    class HeatmapInfo {
        private painter;
        private min;
        private max;
        private color;
        private zeroColor;
        private mode;
        getBrush(data: StiMapData): Brush;
        getBrush1(data: StiMapData): StiBrush;
        constructor(painter: StiGdiMapContextPainter, map: StiMap, mapData: StiMapData[]);
    }
    class HeatmapWithGroupInfo {
        private painter;
        private hash;
        private hashColors;
        private zeroColor;
        private mode;
        getBrush(data: StiMapData): Brush;
        getBrush1(data: StiMapData): Brush;
        constructor(painter: StiGdiMapContextPainter, map: StiMap, mapData: StiMapData[]);
    }
    class NoneInfo {
        constructor();
        private colors;
        private index;
        getBrush(): StiSolidBrush;
    }
    export class StiGdiMapContextPainter {
        individualStep: number;
        map: StiMap;
        defaultBrush: SolidBrush;
        defaultBrush1: StiSolidBrush;
        heatmapInfo: HeatmapInfo;
        heatmapWithGroupInfo: HeatmapWithGroupInfo;
        noneInfo: NoneInfo;
        hashGroup: any;
        colorsContainer: StiStyleColorsContainer;
        private _mapData;
        get mapData(): List<StiMapData>;
        set mapData(value: List<StiMapData>);
        private _mapStyle;
        get mapStyle(): StiMapStyle;
        set mapStyle(value: StiMapStyle);
        private _dataTable;
        get dataTable(): StiDataTable;
        set dataTable(value: StiDataTable);
        getValues(meter: IStiMeter): List<any>;
        prepareDataColumns(): void;
        getGeomBrush(data: StiMapData): Brush;
        updateHeatmapWithGroup(): void;
        updateGroupedData(): void;
        private fillGroupColors;
        parseHexColor(color: string): Brush;
        constructor(map: StiMap);
    }
    export {};
}
declare namespace Stimulsoft.Report.Painters {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiContainerPainter extends StiComponentPainter {
        paintComponents(container: StiContainer, g: Graphics): void;
        paint(component: StiComponent, g: Graphics): void;
    }
}
declare namespace Stimulsoft.Report.Painters {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiViewPainter extends StiComponentPainter {
        getImage(component: Stimulsoft.Report.Components.StiComponent, REFzoom: any, format: StiExportFormat): Image;
    }
}
declare namespace Stimulsoft.Report.Painters {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImagePainter extends StiViewPainter {
        getImage(component: Stimulsoft.Report.Components.StiComponent, REFzoom: any, format: StiExportFormat): Image;
    }
}
declare namespace Stimulsoft.Report.Painters {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    class StiPagePainter extends StiContainerPainter implements IStiPagePainter {
        implements(): any[];
        paint(comp: StiComponent, g: Graphics): void;
    }
}
declare namespace Stimulsoft.Report.Painters {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiText = Stimulsoft.Report.Components.StiText;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTextinCellsPainter {
        paintText(textComp: StiText, g: Graphics, rect: RectangleD): void;
        paintBackground(textComp: StiText, g: Graphics, rect: RectangleD): void;
        paintBorder(component: StiComponent, g: Graphics, rect: RectangleD, zoom: number, drawBorderFormatting: boolean, drawTopmostBorderSides: boolean): void;
    }
}
declare namespace Stimulsoft.Report.Painters {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiText = Stimulsoft.Report.Components.StiText;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTextPainter extends StiComponentPainter {
        paintText(textComp: StiText, g: Graphics, rect: RectangleD): void;
        paintBackground(text: StiText, g: Graphics, rect: RectangleD): void;
        paintBorder(component: StiComponent, g: Graphics, rect: RectangleD, zoom: number, drawBorderFormatting: boolean, drawTopmostBorderSides: boolean): void;
        paint(component: StiComponent, g: Graphics): void;
    }
}
declare namespace Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiPointAnimation extends StiAnimation {
        constructor(pointFrom: Point, duration: TimeSpan, beginTime: TimeSpan);
        pointFrom: Point;
        get type(): StiAnimationType;
    }
}
declare namespace Stimulsoft.Base.Context {
    class StiContextOptions {
        get isPrinting(): boolean;
        private _isWpf;
        get isWpf(): boolean;
        private _isGdi;
        get isGdi(): boolean;
        private _zoom;
        get zoom(): number;
        constructor(isGdi: boolean, isWpf: boolean, isPrinting: boolean, zoom: number);
    }
}
declare namespace Stimulsoft.Base.Context {
    enum StiGeomType {
        None = 0,
        Border = 1,
        CachedShadow = 2,
        Curve = 3,
        Ellipse = 4,
        Font = 5,
        Line = 6,
        Lines = 7,
        Path = 8,
        Pen = 9,
        PopSmothingMode = 10,
        PopTextRenderingHint = 11,
        PopTransform = 12,
        PopClip = 13,
        PushClip = 14,
        PushRotateTransform = 15,
        PushSmothingMode = 16,
        PushSmothingModeToAntiAlias = 17,
        PushTextRenderingHint = 18,
        PushTextRenderingHintToAntiAlias = 19,
        PushTranslateTransform = 20,
        Segment = 21,
        Shadow = 22,
        Text = 23,
        StringFormat = 24,
        AnimationBar = 25,
        AnimationBorder = 26,
        AnimationColumn = 27,
        AnimationEllipse = 28,
        AnimationPath = 29,
        AnimationPathElement = 30,
        AnimationLines = 31,
        AnimationCurve = 32,
        AnimationLabel = 33,
        AnimationShadow = 34,
        Image = 35,
        PushClipPath = 36
    }
    enum StiPenAlignment {
        Center = 0,
        Inset = 1,
        Outset = 2,
        Left = 3,
        Right = 4
    }
    enum StiPenLineCap {
        Flat = 0,
        Square = 1,
        Round = 2,
        Triangle = 3,
        NoAnchor = 4,
        SquareAnchor = 5,
        RoundAnchor = 6,
        DiamondAnchor = 7,
        ArrowAnchor = 8
    }
}
declare namespace Stimulsoft.Base.Context {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiPenGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        brush: Color | StiBrush;
        thickness: number;
        penStyle: Stimulsoft.Base.Drawing.StiPenStyle;
        alignment: StiPenAlignment;
        startCap: StiPenLineCap;
        endCap: StiPenLineCap;
        get type(): StiGeomType;
        constructor(brush: any, thickness?: number);
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiPopSmothingModeGeom extends StiGeom implements IStiJsonReportObject {
        get type(): StiGeomType;
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiPopTextRenderingHintGeom extends StiGeom implements IStiJsonReportObject {
        get type(): StiGeomType;
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiPushSmothingModeToAntiAliasGeom extends StiGeom implements IStiJsonReportObject {
        get type(): StiGeomType;
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiPushTextRenderingHintToAntiAliasGeom extends StiGeom implements IStiJsonReportObject {
        get type(): StiGeomType;
    }
}
declare namespace Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import HotkeyPrefix = Stimulsoft.System.Drawing.Text.HotkeyPrefix;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
    import StringFormatFlags = Stimulsoft.System.Drawing.StringFormatFlags;
    class StiStringFormatGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        isGeneric: boolean;
        alignment: StringAlignment;
        formatFlags: StringFormatFlags;
        hotkeyPrefix: HotkeyPrefix;
        lineAlignment: StringAlignment;
        trimming: StringTrimming;
        get type(): StiGeomType;
        constructor(sf: StringFormat);
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    let IStiGaugeMarker: System.Interface<IStiGaugeMarker>;
    interface IStiGaugeMarker {
        showValue: boolean;
        textBrush: StiBrush;
        font: Font;
        format: string;
    }
}
declare namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    class StiGraphicsPathCloseFigureGaugeGeom extends StiGaugeGeom {
        get type(): StiGaugeGeomType;
    }
}
declare namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiGraphicsPathGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly startPoint: Point;
        get type(): StiGaugeGeomType;
        private _geoms;
        get geoms(): StiGaugeGeom[];
        addGraphicsPathArcGaugeGeom(x: number, y: number, width: number, height: number, startAngle: number, sweepAngle: number): void;
        addGraphicsPathCloseFigureGaugeGeom(): void;
        addGraphicsPathLinesGaugeGeom(points: Point[]): void;
        addGraphicsPathLineGaugeGeom(p1: Point, p2: Point): void;
        constructor(rect: Rectangle, startPoint: Point, background: StiBrush, borderBrush: StiBrush, borderWidth: number);
    }
}
declare namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiGraphicsPathLineGaugeGeom extends StiGaugeGeom {
        readonly p1: Point;
        readonly p2: Point;
        get type(): StiGaugeGeomType;
        constructor(p1: Point, p2: Point);
    }
}
declare namespace Stimulsoft.Report.Gauge.GaugeGeoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiGraphicsPathLinesGaugeGeom extends StiGaugeGeom {
        readonly points: Point[];
        get type(): StiGaugeGeomType;
        constructor(points: Point[]);
    }
}
declare namespace Stimulsoft.Base.Context {
    class StiInteractionDataGeom {
        componentName: string;
        pageGuid: string;
        componentIndex: string;
        pageIndex: string;
        elementIndex: string;
        interactionToolTip: string;
        interactionHyperlink: string;
        interactionData: StiInteractionData;
    }
}
declare namespace Stimulsoft.Base.Maps.Geoms {
    enum StiMapGeomType {
        MoveTo = 0,
        Line = 1,
        Bezier = 2,
        Beziers = 3,
        Close = 4
    }
}
declare namespace Stimulsoft.Report.Resources {
    class StimulsoftFont {
        static getBase64Content(): string;
    }
}
declare namespace Stimulsoft.Report.Styles {
    let IStiBaseStyle: System.Interface<IStiBaseStyle>;
    interface IStiBaseStyle {
        name: string;
    }
}
declare namespace Stimulsoft.Report {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGaugeStyle extends StiBaseStyle {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        brush: StiBrush;
        borderColor: Color;
        targetColor: Color;
        borderWidth: number;
        foreColor: Color;
        tickMarkMajorBrush: StiBrush;
        tickMarkMajorBorder: StiBrush;
        tickMarkMajorBorderWidth: number;
        tickMarkMinorBrush: StiBrush;
        tickMarkMinorBorder: StiBrush;
        tickMarkMinorBorderWidth: number;
        tickLabelMajorTextBrush: StiBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiBrush;
        linearBarBrush: StiBrush;
        linearBarBorderBrush: StiBrush;
        linearBarEmptyBrush: StiBrush;
        linearBarEmptyBorderBrush: StiBrush;
        radialBarBrush: StiBrush;
        radialBarBorderBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
        radialBarEmptyBorderBrush: StiBrush;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleBorderWidth: number;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
declare namespace Stimulsoft.Report.Styles {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiHeatmapStyleData implements IStiJsonReportObject, ICloneable {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        color: Color;
        private shouldSerializeColor;
        zeroColor: Color;
        private shouldSerializeZeroColor;
        mode: StiHeatmapFillMode;
        private shouldSerializeMode;
        isDefault(): boolean;
        constructor(color?: Color, zeroColor?: Color, mode?: StiHeatmapFillMode);
    }
}
declare namespace Stimulsoft.Report.Styles {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiHeatmapWithGroupStyleData implements IStiJsonReportObject, ICloneable {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        private defaultColors;
        colors: Color[];
        private shouldSerializeColors;
        zeroColor: Color;
        private shouldSerializeZeroColor;
        mode: StiHeatmapFillMode;
        private shouldSerializeMode;
        isDefault(): boolean;
        constructor(colors?: Color[], zeroColor?: Color, mode?: StiHeatmapFillMode);
    }
}
declare namespace Stimulsoft.Report {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiIndicatorStyle extends StiBaseStyle {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        backColor: Color;
        glyphColor: Color;
        foreColor: Color;
        hotBackColor: Color;
        hotForeColor: Color;
        positiveColor: Color;
        negativeColor: Color;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
declare namespace Stimulsoft.Report {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    class StiProgressStyle extends StiBaseStyle {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        foreColor: Color;
        backColor: Color;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
declare namespace Stimulsoft.Report {
    import StiNestedFactor = Stimulsoft.Report.StiNestedFactor;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStylesCreator {
        private report;
        private _showReportTitles;
        get showReportTitles(): boolean;
        set showReportTitles(value: boolean);
        private _showReportSummaries;
        get showReportSummaries(): boolean;
        set showReportSummaries(value: boolean);
        private _showPageHeaders;
        get showPageHeaders(): boolean;
        set showPageHeaders(value: boolean);
        private _showPageFooters;
        get showPageFooters(): boolean;
        set showPageFooters(value: boolean);
        private _showGroupHeaders;
        get showGroupHeaders(): boolean;
        set showGroupHeaders(value: boolean);
        private _showGroupFooters;
        get showGroupFooters(): boolean;
        set showGroupFooters(value: boolean);
        private _showHeaders;
        get showHeaders(): boolean;
        set showHeaders(value: boolean);
        private _showDatas;
        get showDatas(): boolean;
        set showDatas(value: boolean);
        private _showFooters;
        get showFooters(): boolean;
        set showFooters(value: boolean);
        private _showBorders;
        get showBorders(): boolean;
        set showBorders(value: boolean);
        private get colorFactor();
        private _maxNestedLevel;
        get maxNestedLevel(): number;
        set maxNestedLevel(value: number);
        private _nestedFactor;
        get nestedFactor(): StiNestedFactor;
        set nestedFactor(value: StiNestedFactor);
        createStyles(collectionName: string, baseColor: Color): StiBaseStyle[];
        private createStyles1;
        private createStyles2;
        private createStyle;
        private getStyleName;
        constructor(report: StiReport);
    }
}
declare namespace Stimulsoft.Report.Styles {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBorderSides = Stimulsoft.Base.Drawing.StiBorderSides;
    class StiStylesHelper {
        static getBorderSidesFromLocation(component: StiComponent): StiBorderSides;
        static changeComponentStyleName(comp: StiComponent, oldName: string, newName: string): void;
        private static changeDataBandStyleName;
        private static changeElementStyleName;
        private static changeChartStyleName;
        private static changeGaugeStyleName;
    }
}
declare namespace Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionElement {
    }
}
declare namespace Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionComponentNameElement extends StiStyleConditionElement {
        private _operationComponentName;
        get operationComponentName(): StiStyleConditionOperation;
        set operationComponentName(value: StiStyleConditionOperation);
        private _componentName;
        get componentName(): string;
        set componentName(value: string);
        constructor(componentName: string, operationComponentName?: StiStyleConditionOperation);
    }
}
declare namespace Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionComponentTypeElement extends StiStyleConditionElement {
        private _componentType;
        get componentType(): StiStyleComponentType;
        set componentType(value: StiStyleComponentType);
        private _operationComponentType;
        get operationComponentType(): StiStyleConditionOperation;
        set operationComponentType(value: StiStyleConditionOperation);
        constructor(componentType: StiStyleComponentType, operationComponentType?: StiStyleConditionOperation);
    }
}
declare namespace Stimulsoft.Report.Styles.Conditions {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiStyleConditionElement = Stimulsoft.Report.Styles.Conditions.Elements.StiStyleConditionElement;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiStyleCondition implements ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiStyleCondition;
        private _type;
        get type(): StiStyleConditionType;
        set type(value: StiStyleConditionType);
        private _operationPlacement;
        get operationPlacement(): StiStyleConditionOperation;
        set operationPlacement(value: StiStyleConditionOperation);
        private _operationPlacementNestedLevel;
        get operationPlacementNestedLevel(): StiStyleConditionOperation;
        set operationPlacementNestedLevel(value: StiStyleConditionOperation);
        private _operationComponentType;
        get operationComponentType(): StiStyleConditionOperation;
        set operationComponentType(value: StiStyleConditionOperation);
        private _operationLocation;
        get operationLocation(): StiStyleConditionOperation;
        set operationLocation(value: StiStyleConditionOperation);
        private _operationComponentName;
        get operationComponentName(): StiStyleConditionOperation;
        set operationComponentName(value: StiStyleConditionOperation);
        private _placement;
        get placement(): StiStyleComponentPlacement;
        set placement(value: StiStyleComponentPlacement);
        private _placementNestedLevel;
        get placementNestedLevel(): number;
        set placementNestedLevel(value: number);
        private _componentType;
        get componentType(): StiStyleComponentType;
        set componentType(value: StiStyleComponentType);
        private _location;
        get location(): StiStyleLocation;
        set location(value: StiStyleLocation);
        private _componentName;
        get componentName(): string;
        set componentName(value: string);
        fromElements(elements: StiStyleConditionElement[]): void;
        constructor(type?: StiStyleConditionElement[] | StiStyleConditionType, operationPlacement?: StiStyleConditionOperation, operationPlacementNestedLevel?: StiStyleConditionOperation, operationComponentType?: StiStyleConditionOperation, operationLocation?: StiStyleConditionOperation, operationComponentName?: StiStyleConditionOperation, placement?: StiStyleComponentPlacement, placementNestedLevel?: number, componentType?: StiStyleComponentType, location?: StiStyleLocation, componentName?: string);
    }
}
declare namespace Stimulsoft.Report {
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    class StiStyleConditionHelper {
        static isAllowStyle(component: Stimulsoft.Report.Components.StiComponent, style: StiBaseStyle): boolean;
    }
}
declare namespace Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionLocationElement extends StiStyleConditionElement {
        private _operationLocation;
        get operationLocation(): StiStyleConditionOperation;
        set operationLocation(value: StiStyleConditionOperation);
        private _location;
        get location(): StiStyleLocation;
        set location(value: StiStyleLocation);
        constructor(location: StiStyleLocation, operationLocation?: StiStyleConditionOperation);
    }
}
declare namespace Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionPlacementElement extends StiStyleConditionElement {
        private _placement;
        get placement(): StiStyleComponentPlacement;
        set placement(value: StiStyleComponentPlacement);
        private _operationPlacement;
        get operationPlacement(): StiStyleConditionOperation;
        set operationPlacement(value: StiStyleConditionOperation);
        constructor(placement: StiStyleComponentPlacement, operationPlacement?: StiStyleConditionOperation);
    }
}
declare namespace Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionPlacementNestedLevelElement extends StiStyleConditionElement {
        private _placementNestedLevel;
        get placementNestedLevel(): number;
        set placementNestedLevel(value: number);
        private _operationPlacementNestedLevel;
        get operationPlacementNestedLevel(): StiStyleConditionOperation;
        set operationPlacementNestedLevel(value: StiStyleConditionOperation);
        constructor(placementNestedLevel: number, operationPlacementNestedLevel?: StiStyleConditionOperation);
    }
}
declare namespace Stimulsoft.Report.Units {
    class StiInchesUnit extends StiUnit {
        get rulerStep(): number;
        get factor(): number;
        get shortName(): string;
        get name(): string;
        convertToHInches(value: number): number;
        convertFromHInches(value: number): number;
    }
}
declare namespace Stimulsoft.Report.Viewer {
    enum StiPreviewSettings {
        All = 268435455,
        None = 0,
        Default = 268435455,
        PageViewMode = 1,
        VertScrollBar = 2,
        HorScrollBar = 4,
        StatusBar = 8,
        Print = 16,
        Open = 32,
        Save = 64,
        Parameters = 128,
        SendEMail = 256,
        PageNew = 512,
        PageDelete = 1024,
        PageDesign = 2048,
        PageSize = 4096,
        Resources = 8192,
        Editor = 65536,
        Find = 131072,
        Zoom = 262144,
        PageControl = 524288,
        Bookmarks = 1048576,
        Thumbs = 2097152,
        ContextMenu = 4194304,
        Close = 8388608,
        Toolbar = 16777216
    }
}
declare namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiOdsExportService extends StiExportService implements IStiOdsExportService {
        implements(): any[];
        get defaultExtension(): string;
        get exportFormat(): StiExportFormat;
        get groupCategory(): string;
        get position(): number;
        get exportNameInMenu(): string;
        multipleFiles: boolean;
        getFilter(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private report;
        private matrix;
        private imageCache;
        private cellStyleList;
        private dataStyleList;
        private sheetNameList;
        private matrixList;
        private firstPageIndexList;
        private minRowList;
        private maxRowList;
        private cellStyleTableList;
        private imageQuality;
        private imageResolution;
        private currentCulture;
        private xmlIndentation;
        private doubleToString;
        private getColumnName;
        private getColorString;
        private getCellStyleNumber;
        private getStringFromBorder;
        private getDataStyleNumber;
        private writeMimetype;
        private writeMeta;
        private writeManifest;
        private writeImage;
        private writeSettings;
        private writeStyles;
        private writeContent;
        private writeDateTimeFormatString;
        private writeTableFromMatrix;
        exportOds(report: StiReport, stream: MemoryStream, settings: StiOdsExportSettings): void;
    }
}
declare namespace Stimulsoft.Report.Export {
    import StiOdtExportSettings = Stimulsoft.Report.Export.StiOdtExportSettings;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiOdtExportService extends StiExportService implements IStiOdtExportService {
        implements(): any[];
        get defaultExtension(): string;
        get exportFormat(): StiExportFormat;
        get groupCategory(): string;
        get position(): number;
        get exportNameInMenu(): string;
        multipleFiles: boolean;
        getFilter(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private report;
        private _matrix;
        get matrix(): StiMatrix;
        private _removeEmptySpaceAtBottom;
        get removeEmptySpaceAtBottom(): boolean;
        private imageCache;
        private cellStyleList;
        private paragraphStyleList;
        private xmlIndentation;
        private imageQuality;
        private imageResolution;
        private usePageHeadersAndFooters;
        private doubleToString;
        private getColumnName;
        private getColorString;
        private getCellStyleNumber;
        private getStringFromBorder;
        private getParagraphStyleNumber;
        private writeMimetype;
        private writeMeta;
        private writeManifest;
        private writeImage;
        private writeSettings;
        private writeStyles;
        private writeContent;
        exportOdt(report: StiReport, stream: MemoryStream, settings: StiOdtExportSettings): void;
    }
}
declare namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiRtfExportService extends StiExportService {
        get defaultExtension(): string;
        get exportFormat(): StiExportFormat;
        get groupCategory(): string;
        get position(): number;
        get exportNameInMenu(): string;
        getFilter(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private report;
        private fileName;
        private sendEMail;
        multipleFiles: boolean;
        private getColorNumberInt;
        private getColorNumber;
        private getFontNumber2;
        private getFontNumber3;
        private getCharsetIndex;
        private colorList;
        private fontList;
        private styleList;
        private unicodeMapArray;
        private codePageToFont;
        private charsetCount;
        private fontToCodePages;
        private baseFontNumber;
        private usePageHeadersAndFooters;
        private imageResolution;
        private imageQuality;
        private imageFormat;
        private useStyles;
        private bookmarkList;
        private usedBookmarks;
    }
}
declare namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiTxtExportService extends StiExportService implements IStiTxtExportService {
        implements(): any[];
        get defaultExtension(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        get exportFormat(): StiExportFormat;
        get groupCategory(): string;
        get position(): number;
        get exportNameInMenu(): string;
        getFilter(): string;
        multipleFiles: boolean;
        private borderCodes;
        private firstEscapeCodeIndex;
        private ltrMark;
        private report;
        private needVerticalBorders;
        private needHorizontalBorders;
        private useFullTextBoxWidth;
        private useFullVerticalBorder;
        private useFullHorizontalBorder;
        private useEscapeCodes;
        private styleList;
        private escapeCodesList;
        private getBorderChar;
        private lineFill;
        private lineFillChar;
        private checkWordWrap;
        private checkGrow;
        private addCharsToLine;
        private getStyleNumber;
        private getEscapeNumber;
        private getEscapeNames;
        exportTxt(report: StiReport, stream: MemoryStream, settings: StiTxtExportSettings): void;
    }
}
declare namespace Stimulsoft.Report.Export {
    import StiExportService = Stimulsoft.Report.Export.StiExportService;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiCsvExportService extends StiExportService implements IStiCsvExportService {
        implements(): any[];
        get defaultExtension(): string;
        get exportFormat(): StiExportFormat;
        get groupCategory(): string;
        get position(): number;
        get exportNameInMenu(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private report;
        private fileName;
        private sendEMail;
        multipleFiles: boolean;
        get getFilter(): string;
        private writer;
        exportCsv(report: StiReport, stream: MemoryStream, settings: StiDataExportSettings): void;
    }
}
declare namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiDataExportService extends StiExportService implements IStiDataExportService {
        implements(): any[];
        get defaultExtension(): string;
        get exportFormat(): StiExportFormat;
        get groupCategory(): string;
        get position(): number;
        get exportNameInMenu(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private exportSettings;
        private report;
        private fileName;
        private sendEMail;
        multipleFiles: boolean;
        getFilter(): string;
        exportData(report: StiReport, stream: MemoryStream, settings: StiDataExportSettings): void;
    }
}
declare namespace Stimulsoft.Report.Export {
    class StiHtml5ExportService extends StiExportService implements IStiHtml5ExportService {
        implements(): any[];
        renderAsDocument: boolean;
        get defaultExtension(): string;
        get exportFormat(): StiExportFormat;
        get groupCategory(): string;
        get position(): number;
        get exportNameInMenu(): string;
        exportTo(report: StiReport, writer: StiHtmlTextWriter, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, writer: StiHtmlTextWriter, settings: StiExportSettings): void;
        private reporTmp;
        private documentFileName;
        private sendEMail;
        multipleFiles: boolean;
        getFilter(): string;
        report: StiReport;
        fileName: string;
        imageFormat: ImageFormat;
        htmlWriter: StiHtmlTextWriter;
        imageQuality: number;
        imageResolution: number;
        compressToArchive: boolean;
        private renderPage;
        private renderStartDoc;
        private renderEndDoc;
        exportHtml(report: StiReport, htmlWriter: StiHtmlTextWriter, settings: StiHtmlExportSettings): void;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Export {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiExcel2007ExportService extends StiExportService implements IStiExcel2007ExportService {
        implements(): any[];
        getDefaultExtension(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private report;
        private fileName;
        private sendEMail;
        matrix: StiMatrix;
        private fontList;
        private fillList;
        private borderList;
        private xfList;
        private sstList;
        private sstHash;
        private sstHashIsTags;
        private imageList;
        private formatList;
        private sstCount;
        private sheetNameList;
        private imageListOffset;
        private printAreasList;
        private matrixList;
        private firstPageIndexList;
        private hyperlinkList;
        private minRowList;
        private maxRowList;
        private useOnePageHeaderAndFooter;
        private dataExportMode;
        private exportObjectFormatting;
        private exportEachPageToSheet;
        private exportHorizontalPageBreaks;
        private imageResolution;
        private imageQuality;
        private imageCache;
        private restrictEditing;
        private reportCulture;
        private docCompanyString;
        private docLastModifiedString;
        private xmlIndentation;
        private wrongUrlSymbols;
        private getLineStyle;
        private refChars;
        private getRefString;
        private getRefAbsoluteString;
        private floatToString;
        private stringToUrl;
        private getFontNumber;
        private getFillNumber;
        private getBorderNumber;
        private getXFNumber;
        private getSSTNumber;
        private getFormatNumber;
        HiToTwips: number;
        private TwipsToColinfo;
        private convert;
        private compareExcellSheetNames;
        private prepareData;
        private writeContentTypes;
        private writeMainRels;
        private writeDocPropsApp;
        private writeDocPropsCore;
        private writeWorkbookRels;
        private writeWorkbook;
        private writeSheetRels;
        private writeSheet;
        static regexCheckInteger1: RegExp;
        static regexCheckFloat1: RegExp;
        private checkForNumber;
        private prepareMatrix;
        private getParentBandName;
        private convertAllowHtmlTagsToExcelString;
        private convertTextToExcelString;
        private writeDrawingRels;
        private writeDrawing;
        private writeStyles;
        private writeBorderData;
        private writeSST;
        private writeAdditionalData;
        private writeImage;
        exportExcel(report: StiReport, stream: MemoryStream, settings: StiExcelExportSettings): void;
    }
    class DataFont {
        Name: string;
        Bold: boolean;
        Italic: boolean;
        Underlined: boolean;
        Strikeout: boolean;
        Height: number;
        Color: Color;
        Charset: number;
        Family: number;
        constructor(Name: string, Bold: boolean, Italic: boolean, Underlined: boolean, Strikeout: boolean, Height: number, Color: Color, Charset: number, Family: number);
        equals(obj: DataFont): boolean;
    }
    class DataFill {
        Type: string;
        FgColor: Color;
        BgColor: Color;
        constructor(Type: string, FgColor: Color, BgColor: Color);
        equals(obj: DataFill): boolean;
    }
    class DataBorder {
        BorderLeft: StiBorderSide;
        BorderRight: StiBorderSide;
        BorderTop: StiBorderSide;
        BorderBottom: StiBorderSide;
        constructor(BorderLeft: StiBorderSide, BorderRight: StiBorderSide, BorderTop: StiBorderSide, BorderBottom: StiBorderSide);
        equals(obj: DataBorder): boolean;
        private eq;
    }
    class DataXF {
        FormatIndex: number;
        FontIndex: number;
        FillIndex: number;
        BorderIndex: number;
        XFId: number;
        HorAlign: StiTextHorAlignment;
        VertAlign: StiVertAlignment;
        TextRotationAngle: number;
        TextWrapped: boolean;
        RightToLeft: boolean;
        Editable: boolean;
        equalDataXF(xf: DataXF): boolean;
        constructor(FormatIndex: number, FontIndex: number, FillIndex: number, BorderIndex: number, XFId: number, HorAlign: StiTextHorAlignment, VertAlign: StiVertAlignment, TextRotationAngle: number, TextWrapped: boolean, RightToLeft: boolean, Editable: boolean);
    }
    class ExcelImageData {
        FirstRowIndex: number;
        FirstRowOffset: number;
        FirstColumnIndex: number;
        FirstColumnOffset: number;
        LastRowIndex: number;
        LastRowOffset: number;
        LastColumnIndex: number;
        LastColumnOffset: number;
        ImageIndex: number;
        Hyperlink: string;
        constructor(FirstRowIndex: number, FirstRowOffset: number, FirstColumnIndex: number, FirstColumnOffset: number, LastRowIndex: number, LastRowOffset: number, LastColumnIndex: number, LastColumnOffset: number, ImageIndex: number, Hyperlink: string);
    }
    class CellRangeAddress {
        FirstRow: number;
        LastRow: number;
        FirstColumn: number;
        LastColumn: number;
        constructor(FirstRow: number, LastRow: number, FirstColumn: number, LastColumn: number);
    }
    class HlinkData {
        Range: CellRangeAddress;
        Description: string;
        Bookmark: string;
        constructor(Range: CellRangeAddress, Description: string, Bookmark: string);
    }
}
declare namespace Stimulsoft.Report.Export {
    class StiExcelXmlExportService extends StiExportService implements IStiExcelXmlExportService {
        implements(): any[];
    }
}
declare namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiPpt2007ExportService extends StiExportService implements IStiPpt2007ExportService {
        implements(): any[];
        getDefaultExtension(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private report;
        private fileName;
        private sendEMail;
        private imageListOffset;
        private imageResolution;
        private imageQuality;
        private imageCache;
        private idCounter;
        private hyperlinkList;
        private xmlIndentation;
        private currentCulture;
        private newCulture;
        private getLineStyle;
        private stringToUrl;
        private wrongUrlSymbols;
        private HiToTwips;
        private convert;
        private convertTwipsToEmu;
        private convertToEmu;
        private writeColor;
        private writeContentTypes;
        private writeMainRels;
        private writeDocPropsApp;
        private writeDocPropsCore;
        private writeTableStyles;
        private writePresProps;
        private writeViewProps;
        private writeTheme;
        private writeSlideMasterRels;
        private writeSlideMaster;
        private writeSlideLayoutRels;
        private writeSlideLayout;
        private writePresentationRels;
        private writePresentation;
        private writeSlideRels;
        private writeSlide;
        private writeStiTextbox;
        private writeStiImage;
        private writeSpPr;
        private writeBorder;
        private writeLine;
        private capStyleToPptStyle;
        private writeWatermark;
        private writeHyperlinkInfo;
        private writeImage;
        exportPowerPoint(report: StiReport, stream: MemoryStream, settings: StiPpt2007ExportSettings): void;
    }
}
declare namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiWord2007ExportService extends StiExportService implements IStiWord2007ExportService {
        implements(): any[];
        get defaultExtension(): string;
        get exportFormat(): StiExportFormat;
        get groupCategory(): string;
        get position(): number;
        get exportNameInMenu(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private report;
        private fileName;
        private sendEMail;
        multipleFiles: boolean;
        getFilter(): string;
        private _matrix;
        get matrix(): StiMatrix;
        private _removeEmptySpaceAtBottom;
        get removeEmptySpaceAtBottom(): boolean;
        private fontList;
        private styleList;
        private imageCache;
        private bookmarkList;
        private hyperlinkList;
        private embedsList;
        private xmlIndentation;
        private imageQuality;
        private imageResolution;
        private lineSpace;
        private lineSpace2;
        private usePageHeadersAndFooters;
        private restrictEditing;
        private headersData;
        private headersRels;
        private footersData;
        private footersRels;
        private docCompanyString;
        private docLastModifiedString;
        private checkFontsToCorrectHeight;
        private getLineStyle;
        private getColorString;
        private getStyleNumber;
        private getStyleFromComponent;
        private stringToUrl;
        private wrongUrlSymbols;
        private static get hiToTwips();
        private convert;
        private convertHiToTwips;
        private convertTwipsToEmu;
        private convertStringToBookmark;
        private writeFromMatrix;
        private writeCellContent;
        private writeTableInfo;
        private writeHtmlTags;
        private writeParagraphBegin;
        private writeRunProperties;
        private renderBorder2TableGetValues;
        private getLineStyle2TableGetValues;
        private writeDocument;
        private comparePages;
        private writePageInfo;
        private writeBorders;
        private writeBorderData;
        private writeFootNotes;
        private writeEndNotes;
        private writeHeader;
        private writeFooter;
        private writeContentTypes;
        private writeMainRels;
        private writeDocPropsApp;
        private writeDocPropsCore;
        private writeSettings;
        private writeWebSettings;
        private writeFontTable;
        private writeDocumentRels;
        private writeHeaderFooterRels;
        private writeStyles;
        private writeImage;
        private writeAdditionalData;
        exportWord(report: StiReport, stream: MemoryStream, settings: StiWord2007ExportSettings): void;
    }
}
declare namespace Stimulsoft.Report.Export {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiHatchBrush = Stimulsoft.Base.Drawing.StiHatchBrush;
    import StiText = Stimulsoft.Report.Components.StiText;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiImage = Stimulsoft.Report.Components.StiImage;
    class StiPdfData {
        X: number;
        Y: number;
        Width: number;
        Height: number;
        Component: StiComponent;
        service: StiPdfExportService;
        get Right(): number;
        get Top(): number;
        constructor(service: StiPdfExportService);
    }
    class StiImageData {
        Width: number;
        Height: number;
        Name: string;
        ImageFormat: StiImageFormat;
    }
    class StiShadingData {
        X: number;
        Y: number;
        Width: number;
        Height: number;
        Page: number;
        Angle: number;
        FunctionIndex: number;
    }
    class StiShadingFunctionData {
        Color1: Color;
        Color2: Color;
        IsGlare: boolean;
    }
    class StiEditableObject {
        X: number;
        Y: number;
        Width: number;
        Height: number;
        Page: number;
        Text: string;
        Content: number[];
        Content2: number[];
        Multiline: boolean;
        Alignment: Stimulsoft.Base.Drawing.StiTextHorAlignment;
        FontNumber: number;
        FontSize: number;
        FontColor: Color;
        Component: StiComponent;
    }
    class StiLinkObject {
        X: number;
        Y: number;
        Width: number;
        Height: number;
        Page: number;
        DestPage: number;
        DestY: number;
        Link: string;
    }
    class StiPdfExportService extends StiExportService implements IStiPdfExportService {
        implements(): any[];
        get exportFormat(): StiExportFormat;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        report: StiReport;
        multipleFiles: boolean;
        private imageQuality;
        private imageResolutionMain;
        private imageResolutionMode;
        private sw;
        pageStream: MemoryStream;
        imageList: StiImageData[];
        private imageCache;
        private imageInterpolationTable;
        private imageCacheIndexToList;
        private imageInfoList;
        private imageInfoCounter;
        imagesCurrent: number;
        private fontsCounter;
        private bookmarksCounter;
        private linksCounter;
        private annotsCounter;
        annotsCurrent: number;
        private annots2Counter;
        private annots2Current;
        private unsignedSignaturesCounter;
        shadingCurrent: number;
        private tooltipsCounter;
        private colorTable;
        private alphaTable;
        pdfFont: PdfFonts;
        bidi: StiBidirectionalConvert;
        private standardPdfFonts;
        private embeddedFonts;
        useUnicodeMode: boolean;
        private reduceFontSize;
        private compressed;
        private compressedFonts;
        private encrypted;
        usePdfA: boolean;
        private pdfComplianceMode;
        private exportRtfTextAsImage;
        private autoPrint;
        private imageCompressionMethod;
        private imageFormat;
        private monochromeDitheringType;
        private allowEditable;
        private useTransparency;
        private embeddedFiles;
        private zugferdComplianceMode;
        private zugferdConformanceLevel;
        private fontGlyphsReduceNotNeed;
        private xref;
        private bookmarksTree;
        private bookmarksTreeTemp;
        linksArray: StiLinkObject[];
        private tagsArray;
        private tooltipsArray;
        annotsArray: StiEditableObject[];
        private annots2Array;
        private unsignedSignaturesArray;
        shadingArray: StiShadingData[];
        private hatchArray;
        private shadingFunctionArray;
        private haveBookmarks;
        private haveLinks;
        haveAnnots: boolean;
        private haveTooltips;
        CodePage1252part80AF: number[];
        private CodePage1252;
        hiToTwips: number;
        private precision_digits_font;
        pdfCKT: number;
        private IDValue;
        private IDValueString;
        private IDValueStringMeta;
        private currentDateTime;
        private currentDateTimeMeta;
        private producerName;
        private creatorName;
        private keywords;
        private currentObjectNumber;
        private currentGenerationNumber;
        private keyLength;
        private lastColorStrokeA;
        private lastColorNonStrokeA;
        private colorStack;
        info: StiPdfStructure;
        private haveDigitalSignature;
        private pdfSecurity;
        printScaling: boolean;
        private static regexEscape;
        stringReplace(st: string, oldValue: string, newValue: string): string;
        getHatchNumber(brush: StiHatchBrush): number;
        getShadingFunctionNumber(color1: Color, color2: Color, isGlare: boolean): number;
        private addXref;
        convertToString(value: number, precision?: number): string;
        static convertToEscapeSequence(value: string): string;
        static convertToEscapeSequencePlusTabs(value: string): string;
        setStrokeColor(tempColor: Color): void;
        setNonStrokeColor(tempColor: Color): void;
        private colorHash1;
        private colorHash2;
        private _gsTable;
        get gsTable(): string[][];
        pushColorToStack(): void;
        popColorFromStack(): void;
        fillRectBrush(brush: StiBrush, rect: Rectangle): void;
        private storeStringLine;
        private storeString;
        private convertToHexString;
        private storeMemoryStream2;
        private storeMemoryStream3;
        private storeMemoryStream4;
        storeWysiwygSymbols(text: StiText, pageNumber?: number): void;
        private renderStartDoc;
        private renderEndDoc;
        private renderPageHeader;
        private renderPageFooter;
        private renderFontTable;
        private renderImageTable;
        private renderBookmarksTable;
        private renderPatternTable;
        private writeHatchPattern;
        private writeShadingPattern;
        private writeShadingFunction;
        private renderLinkTable;
        private renderAnnotTable;
        private renderTooltipTable;
        private renderEncodeRecord;
        private renderExtGStateRecord;
        storeImageData(image: Image, imageResolution: number, isImageComponent: boolean, needSmoothing: boolean, maxQuality?: boolean): number;
        storeImageDataForGeom(image: StiImage): void;
        private writeImageInfo;
        writeImageInfo2(pp: StiPdfData, imageResolutionX: number, imageResolutionY: number): void;
        renderImage(pp: StiPdfData, imageResolution: number): void;
        private renderWatermark;
        storeShadingData1(brush: StiBrush, pageNumber: number): void;
        storeShadingData2(x: number, y: number, width: number, height: number, brush: StiBrush): number;
        storeHatchData(brush: StiBrush): void;
        private renderMetadata;
        private renderColorSpace;
        private renderAutoPrint;
        private renderEmbeddedFiles;
        private addBookmarkNode;
        private makeBookmarkFromTree;
        exportPdf(report: StiReport, stream: MemoryStream, settings: StiPdfExportSettings): void;
        private exportPdf1;
    }
}
declare namespace Stimulsoft.Report.Export {
    import Font = Stimulsoft.System.Drawing.Font;
    class PdfFontInfo {
        Widths: number[];
        CharPdfNames: string[];
        CH: number;
        XH: number;
        ASC: number;
        DESC: number;
        tmASC: number;
        tmDESC: number;
        tmExternal: number;
        MacAscend: number;
        MacDescend: number;
        MacLineGap: number;
        LLX: number;
        LLY: number;
        URX: number;
        URY: number;
        StemV: number;
        ItalicAngle: number;
        LineGap: number;
        NtmFlags: number;
        UnderscoreSize: number;
        UnderscorePosition: number;
        StrikeoutSize: number;
        StrikeoutPosition: number;
        UnicodeMap: number[];
        UnicodeMapBack: number[];
        GlyphList: number[];
        GlyphBackList: number[];
        GlyphRtfList: number[];
        SymsToPDF: number[];
        MappedSymbolsCount: number;
        NeedSyntItalic: boolean;
        NeedSyntBold: boolean;
        GlyphWidths: number[];
        ChildFontsMap: number[];
        UseUnicode: boolean;
    }
    class pfontInfo {
        Name: string;
        PdfName: string;
        Bold: boolean;
        Italic: boolean;
        Number: number;
        Font: Font;
        ParentFontNumber: number;
        ChildFontsMap: number[];
        UseUnicode: boolean;
    }
    class PdfFonts extends PdfFontInfo {
        getFontMetrics(font: Font, currentFontInfo: PdfFontInfo, glyphMap: number[], report: StiReport): void;
        static isFontStimulsoft(name: string): boolean;
        private standardFontQuantity;
        private standardFontNumWidths;
        private standardFontNumChars;
        firstMappedSymbol: number;
        factor: number;
        maxSymbols: number;
        forceUseUnicode: boolean;
        WIDTHS: number[];
        fonts: PdfFontInfo[];
        UnicodeMapsList: number[][];
        GlyphMapsList: number[][];
        standardPdfFonts: boolean;
        fontList: pfontInfo[];
        private fontsInfoStore;
        private family_Helvetica;
        private family_Courier;
        private family_Times_Roman;
        private family_Symbol;
        private family_ZapfDingbats;
        PdfFontName: string[];
        private _currentFont;
        get currentFont(): number;
        set currentFont(value: number);
        InitFontsData(report: StiReport): void;
        constructor();
        getFontNumber(incomingFont: Font): number;
        storeUnicodeSymbolsInMap(st: string): void;
        storeGlyphsInMap(sb: string): void;
        private TtfHeaderSize;
        getCharToGlyphTable(buff: Uint8Array, fontName: string): number[];
        reduceFontSize(buff: Uint8Array, fontName: string, remakeGlyphTable: boolean): Stimulsoft.System.IO.MemoryStream;
        private scanFontFile;
        private getCmapTable;
        private copyUint8Array;
        ARG_1_AND_2_ARE_WORDS: number;
        ARGS_ARE_XY_VALUES: number;
        ROUND_XY_TO_GRID: number;
        WE_HAVE_A_SCALE: number;
        MORE_COMPONENTS: number;
        WE_HAVE_AN_X_AND_Y_SCALE: number;
        WE_HAVE_A_TWO_BY_TWO: number;
        WE_HAVE_INSTRUCTIONS: number;
        USE_MY_METRICS: number;
        OVERLAP_COMPOUND: number;
        SCALED_COMPONENT_OFFSET: number;
        UNSCALED_COMPONENT_OFFSET: number;
        TablesNames: string[];
        private getTtfInfo;
        private GetUInt8;
        private GetUInt16;
        private GetUInt32;
        private GetInt16;
        private SetUInt16;
        private SetUInt32;
        clear(): void;
        getFontDataBuf(font: Font, report: StiReport): any;
        getFontDataFromGdi(font: Font, report: StiReport): any;
    }
    class FontsInfoStore {
        clear(): void;
    }
}
declare namespace Stimulsoft.Report.Export {
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Matrix = Stimulsoft.System.Drawing.Drawing2D.Matrix;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Pen = Stimulsoft.System.Drawing.Pen;
    import Image = Stimulsoft.System.Drawing.Image;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiPdfGeomWriter implements IStiExportGeomWriter {
        private penWidthDefault;
        private precision_digits;
        private hiToTwips;
        private pdfCKT;
        private lastPoint;
        private makepath;
        private pathClosed;
        private path;
        private pageStream;
        private pdfService;
        assembleData: boolean;
        pageNumber: number;
        matrixCache: Matrix[];
        private xmin;
        private xmax;
        private ymin;
        private ymax;
        private calculateMinMax;
        private convertToString;
        setPen(objPen: any, saveState?: boolean): boolean;
        setBrush(brush: Color | StiBrush, rect: Rectangle, saveState?: boolean): boolean;
        private outputLineString;
        private convertArcToBezierPoints;
        convertSplineToCubicBezier(points: Point[], tension: number): Point[];
        private calculateCurveBezier;
        private calculateCurveBezierEndPoints;
        getPointString(point: Point): string;
        getLineToString(pointTo: Point): string;
        getRectString4(x: number, y: number, width: number, height: number): string;
        getRectString(rect: Rectangle): string;
        getBezierString(p1: Point, p2: Point, p3: Point): string;
        getBezierString2(p1x: number, p1y: number, p2x: number, p2y: number, p3x: number, p3y: number): string;
        getPolylineString(points: Point[], close: boolean, drawTo: boolean): string;
        getEllipseString4(x: number, y: number, width: number, height: number): string;
        getEllipseString(rect: Rectangle): string;
        private getPenStyleDashString;
        beginPath(): void;
        closeFigure(): void;
        endPath(): void;
        fillPath(brush: any): void;
        strokePath(pen: any): void;
        moveTo(point: Point): void;
        drawLine(pointFrom: Point, pointTo: Point, pen: any): void;
        drawLineTo(pointTo: Point, pen: any): void;
        drawRectangle(rect: Rectangle, pen: any): void;
        fillRectangle(rect: Rectangle, brush: any): void;
        drawPolygon(points: Point[], pen: any): void;
        drawPolyline(points: Point[], pen: any, close?: boolean, drawTo?: boolean): void;
        drawPolylineTo(points: Point[], pen: any): void;
        fillPolygon(points: Point[], brush: any): void;
        drawBezier(p1: Point, p2: Point, p3: Point, p4: Point, pen: any): void;
        drawBezierTo(p2: Point, p3: Point, p4: Point, pen: any): void;
        drawSpline(points: Point[], tension: number, pen: any): void;
        drawArc(rect: Rectangle, startAngle: number, sweepAngle: number): void;
        drawEllipse(rect: Rectangle, pen: any): void;
        fillEllipse(rect: Rectangle, brush: any): void;
        drawPie(rect: Rectangle, startAngle: number, sweepAngle: number): void;
        drawString(st: string, font: Font, brush: StiBrush, rect: Rectangle, sf: StringFormat): void;
        saveState(): void;
        restoreState(): void;
        translateTransform(x: number, y: number): void;
        rotateTransform(angle: number): void;
        setClip(rect: Rectangle): void;
        drawArc2(rect: RectangleD, p1: PointD, p2: PointD, pen: Pen): void;
        drawText(basePoint: PointD, text: string, charsOffset: number[], font: Font, textColor: Color, angle: number, textAlign: EmfTextAlignmentMode): void;
        setPixel(point: PointD, color: Color): void;
        measureString(st: string, font: Font): SizeD;
        drawImage(img: Image, rect: RectangleD): void;
        constructor(stream: MemoryStream, service: StiPdfExportService, assembleData?: boolean);
    }
}
declare namespace Stimulsoft.Report.Export {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiPdfRenderChart {
        static renderChart(pp: StiPdfData, assemble: boolean, pageNumber: number): void;
        static renderSparkline(pp: StiPdfData, assemble: boolean, pageNumber: number): void;
        static renderContext(pp: StiPdfData, assemble: boolean, pageNumber: number, context: StiContext): void;
        private static getStartPoint;
        private static rectToRectangle;
        private static brushToStiBrush;
        private static checkPenGeom;
    }
}
declare namespace Stimulsoft.Report.Export {
    class StiPdfRenderIndicators {
        static renderIndicators(pp: StiPdfData): StiPdfData;
    }
}
declare namespace Stimulsoft.Report.Export {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiShape = Stimulsoft.Report.Components.StiShape;
    import StiCheckBox = Stimulsoft.Report.Components.StiCheckBox;
    class StiPdfRenderPrimitives {
        static renderBorder1(pp: StiPdfData): void;
        static renderBorder2(pp: StiPdfData): void;
        private static storeBorderSideData;
        static getPenStyleDashString(style: StiPenStyle, step: number, pp: StiPdfData): string;
        static checkShape(shape: StiShape): boolean;
        static renderShape(pp: StiPdfData, imageResolution: number): void;
        static renderRoundedRectanglePrimitive(pp: StiPdfData): void;
        static renderCheckbox(pp: StiPdfData, checkBoxValue: boolean, storeShading?: boolean): void;
        static getCheckBoxValue(checkbox: StiCheckBox): boolean;
    }
}
declare namespace Stimulsoft.Report.Export {
    class StiPdfRenderText {
        private static hiToTwips;
        private static precision_digits_font;
        private static fontCorrectValue;
        private static boldFontStrokeWidthValue;
        private static italicAngleTanValue;
        private static charCode07;
        static renderText(pp: StiPdfData): void;
        private static isWordWrapSymbol;
        private static getTabsSize;
        static renderTextFont(pp: StiPdfData): void;
        static renderText2(pp: StiPdfData, pageNumber?: number): void;
    }
}
declare namespace Stimulsoft.Report.Export {
    class StiPdfResources {
        static sRGBprofile: number[];
        static hatchData: string[];
        private static standardFontWidths;
        private static standardFontInfo;
        private static _standardFontCharsNames;
        static get standardFontCharsNames(): string[];
    }
}
declare namespace Stimulsoft.Report.Export {
    class StiPdfSecurity {
        static paddingString: number[];
        ownerValue: number[];
        userValue: number[];
        ownerExtendedValue: number[];
        userExtendedValue: number[];
        permsValue: number[];
        IDValue: number[];
        encryptionKey: number[];
        encryptionKeyLength: number;
        passwordOwner: string;
        passwordUser: string;
        securityFlags: number;
        keyLength: StiPdfEncryptionKeyLength;
        pdfService: StiPdfExportService;
        private padPassword;
        computingCryptoValues(userAccessPrivileges: StiUserAccessPrivileges, passwordInputOwner: string, passwordInputUser: string, keyLength: StiPdfEncryptionKeyLength, IDValue: number[]): boolean;
        private computingCryptoValues2;
        private computingCryptoValuesV4;
        private computingCryptoValuesV5;
        private encodeKeyDataV5;
        private decodeKeyDataV5;
        private getHashV5;
        private static calculate_hash_r5;
        private static calculate_hash_r6;
        encryptData(data: number[], currentObjectNumber: number, currentGenerationNumber: number): number[];
        private throwEncryptionError;
        renderEncodeRecord(sw: Stimulsoft.System.IO.MemoryStream): void;
        getBytesUInt32(uint: number): number[];
        getBytesUint16(uint: number): number[];
        private rc4;
        private computeHashMD5;
        constructor(service: StiPdfExportService);
    }
}
declare namespace Stimulsoft.Report.Export {
    class StiPdfObjInfo {
        ref: number;
        info: StiPdfStructure;
        get isUsed(): boolean;
        addRef(): void;
        toString(): string;
    }
    class StiPdfContentObjInfo extends StiPdfObjInfo {
        content: StiPdfObjInfo;
    }
    class StiPdfXObjectObjInfo extends StiPdfObjInfo {
        mask: StiPdfObjInfo;
    }
    class StiPdfFontObjInfo extends StiPdfObjInfo {
        descendantFont: StiPdfObjInfo;
        toUnicode: StiPdfObjInfo;
        cIDSet: StiPdfObjInfo;
        encoding: StiPdfObjInfo;
        fontDescriptor: StiPdfObjInfo;
        fontFile2: StiPdfObjInfo;
    }
    class StiPdfOutlinesObjInfo extends StiPdfObjInfo {
        items: StiPdfObjInfo[];
    }
    class StiPdfPatternsObjInfo extends StiPdfObjInfo {
        resources: StiPdfObjInfo;
        first: StiPdfObjInfo;
        hatchItems: StiPdfObjInfo[];
        shadingItems: StiPdfObjInfo[];
        shadingFunctionItems: StiPdfObjInfo[];
    }
    class StiPdfAnnotObjInfo extends StiPdfObjInfo {
        aP: StiPdfObjInfo;
        aA: StiPdfObjInfo[];
    }
    class StiPdfCheckBoxObjInfo {
        items: StiPdfAnnotObjInfo[];
    }
    class StiPdfAcroFormObjInfo extends StiPdfObjInfo {
        annots: StiPdfAnnotObjInfo[];
        checkBoxes: StiPdfCheckBoxObjInfo[];
        unsignedSignatures: StiPdfAnnotObjInfo[];
        signatures: StiPdfAnnotObjInfo[];
        tooltips: StiPdfAnnotObjInfo[];
        annotFontItems: StiPdfFontObjInfo[];
    }
    class StiPdfStructure {
        root: StiPdfObjInfo;
        info: StiPdfObjInfo;
        colorSpace: StiPdfObjInfo;
        pages: StiPdfObjInfo;
        structTreeRoot: StiPdfObjInfo;
        optionalContentGroup: StiPdfObjInfo;
        pageList: StiPdfContentObjInfo[];
        xObjectList: StiPdfXObjectObjInfo[];
        fontList: StiPdfFontObjInfo[];
        outlines: StiPdfOutlinesObjInfo;
        patterns: StiPdfPatternsObjInfo;
        linkList: StiPdfObjInfo[];
        encode: StiPdfObjInfo;
        extGState: StiPdfObjInfo;
        acroForm: StiPdfAcroFormObjInfo;
        metadata: StiPdfObjInfo;
        destOutputProfile: StiPdfObjInfo;
        outputIntents: StiPdfObjInfo;
        embeddedJS: StiPdfContentObjInfo;
        embeddedFilesList: StiPdfContentObjInfo[];
        private objectsCounter;
        private objects;
        addRef(info: StiPdfObjInfo): void;
        createObject(addRef?: boolean): StiPdfObjInfo;
        createContentObject(addRef?: boolean): StiPdfContentObjInfo;
        createXObject(addRef?: boolean, haveMask?: boolean): StiPdfXObjectObjInfo;
        createFontObject(addRef?: boolean, useUnicodeMode?: boolean, standardPdfFonts?: boolean, embeddedFonts?: boolean, annotFont?: boolean): StiPdfFontObjInfo;
        createOutlinesObject(addRef?: boolean): StiPdfOutlinesObjInfo;
        createPatternsObject(addRef?: boolean): StiPdfPatternsObjInfo;
        createAcroFormObject(addRef?: boolean): StiPdfAcroFormObjInfo;
        createAnnotObject(addRef?: boolean, createAP?: boolean, numberAA?: number): StiPdfAnnotObjInfo;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Events {
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiGetTitleEventArgs extends EventArgs {
        private valueObject;
        get value(): string;
        set value(value: string);
        private _index;
        get index(): number;
        set index(value: number);
        private _series;
        get series(): IStiSeries;
        set series(value: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Events {
    import EventArgs = Stimulsoft.System.EventArgs;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    class StiNewAutoSeriesEventArgs extends EventArgs {
        private _seriesIndex;
        get seriesIndex(): number;
        set seriesIndex(value: number);
        private _color;
        get color(): any;
        set color(value: any);
        private _series;
        get series(): IStiSeries;
        set series(value: IStiSeries);
        constructor(seriesIndex: number, series: IStiSeries, color: any);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import Color = Stimulsoft.System.Drawing.Color;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiChartHelper {
        static globalDurationElement: TimeSpan;
        static globalBeginTimeElement: TimeSpan;
        static fillSeriesData(series: StiSeries, items: StiDataItem[]): void;
        static getFilterData(report: StiReport, filter: StiChartFilter, filterMethodName: string): any;
        static getFilterResult(filter: StiChartFilter, itemArgument: any, itemValue: any, itemValueEnd: any, itemValueOpen: any, itemValueClose: any, itemValueLow: any, itemValueHigh: any, data: any): boolean;
        static convertStringToColor(colorStr: string): Color;
        static createChart(masterChart: StiChart, chartComp: StiChart): void;
        static getShorterListPoints(series: StiSeries): PointD[];
        private static checkParetoValues;
        private static checkValueNaN;
        private static checkArgumentsDateTimeStep;
        static checkWaterfallTotals(chart: IStiChart): void;
        private static createValuesTopN;
        private static getNextDate;
        private static getKey;
        private static sortArray;
        private static findIndex;
        private static getValueForDate;
        private static getTotalTimeSpans;
        private static isArgumentsDateTime;
        private static maximumDate;
        private static minimumDate;
        private static getAutoSeriesColorFromautoSeriesColorDataColumn;
        private static getAutoSeriesTitleFromAutoSeriesTitleDataColumn;
        private static getAutoSeriesKeysFromAutoSeriesKeyDataColumn;
        private static setTitle;
        private static setCutPieList;
        private static getArguments;
        private static getArgumentsFromArgumentExpression;
        private static getArgumentsFromArgumentDataColumn;
        private static getArgumentsFromListOfArguments;
        private static getValues;
        private static getValuesFromValueExpression;
        private static getValuesFromValueDataColumn;
        private static getValuesFromListOfValues;
        private static getValuesEnd;
        private static getValuesEndFromValueEndExpression;
        private static getValuesEndFromValueDataColumnEnd;
        private static getValuesEndFromListOfValuesEnd;
        private static getValuesOpen;
        private static getValuesOpenFromValuesOpenExpression;
        private static getValuesOpenFromValueDataColumnOpen;
        private static getValuesOpenFromListOfValuesOpen;
        private static getValuesClose;
        private static getValuesCloseFromValuesCloseExpression;
        private static getValuesCloseFromValueDataColumnClose;
        private static getValuesCloseFromListOfValuesClose;
        private static getValuesHigh;
        private static getValuesHighFromValuesHighExpression;
        private static getValuesHighFromValueDataColumnHigh;
        private static getValuesHighFromListOfValuesHigh;
        private static getValuesLow;
        private static getValuesLowFromValuesLowExpression;
        private static getValuesLowFromValueDataColumnLow;
        private static getValuesLowFromListOfValuesLow;
        private static getWeights;
        private static getWeightsWeightExpression;
        private static getWeightsFromWeightDataColumn;
        private static getWeightsFromListOfWeights;
        private static getHyperlinks;
        private static getHyperlinksFromHyperlinkExpression;
        private static getHyperlinksFromHyperlinkDataColumn;
        private static getHyperlinksFromListOfHyperlinks;
        private static getTags;
        private static getTagsFromTagExpression;
        private static getTagsFromTagDataColumn;
        private static getTagsFromListOfTags;
        private static getToolTips;
        private static getToolTipsFromToolTipExpression;
        private static getToolTipsFromToolTipDataColumn;
        private static getToolTipsFromListOfToolTips;
    }
}
declare namespace Stimulsoft.Report.Events {
    class StiProcessChartEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiArea extends StiService implements IStiJsonReportObject, IStiArea, ICloneable {
        private static implementsStiArea;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        static loadFromJsonObjectInternal(jObject: StiJson): IStiArea;
        static loadAreaFromXml(xmlNode: XmlNode, chart: Stimulsoft.Report.Components.StiChart): StiArea;
        get componentId(): StiComponentId;
        get propName(): string;
        clone(): StiArea;
        createNew(): StiArea;
        toString(): string;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        get serviceCategory(): string;
        get serviceType(): Stimulsoft.System.Type;
        get isDefaultSeriesTypeFullStackedColumnSeries(): boolean;
        get isDefaultSeriesTypeFullStackedBarSeries(): boolean;
        private _core;
        get core(): StiAreaCoreXF;
        set core(value: StiAreaCoreXF);
        private _chart;
        get chart(): IStiChart;
        set chart(value: IStiChart);
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        private _colorEach;
        get colorEach(): boolean;
        set colorEach(value: boolean);
        private _showShadow;
        get showShadow(): boolean;
        set showShadow(value: boolean);
        private _borderColor;
        get borderColor(): Color;
        set borderColor(value: Color);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarArea extends StiArea implements IStiJsonReportObject, IStiRadarArea, IStiArea, ICloneable {
        private static implementsStiRadarArea;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiRadarArea;
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        private _interlacingHor;
        get interlacingHor(): IStiInterlacingHor;
        set interlacingHor(value: IStiInterlacingHor);
        private _interlacingVert;
        get interlacingVert(): IStiInterlacingVert;
        set interlacingVert(value: IStiInterlacingVert);
        private _gridLinesHor;
        get gridLinesHor(): IStiRadarGridLinesHor;
        set gridLinesHor(value: IStiRadarGridLinesHor);
        private _gridLinesVert;
        get gridLinesVert(): IStiRadarGridLinesVert;
        set gridLinesVert(value: IStiRadarGridLinesVert);
        private _radarStyle;
        get radarStyle(): StiRadarStyle;
        set radarStyle(value: StiRadarStyle);
        private _xAxis;
        get xAxis(): IStiXRadarAxis;
        set xAxis(value: IStiXRadarAxis);
        private _yAxis;
        get yAxis(): IStiYRadarAxis;
        set yAxis(value: IStiYRadarAxis);
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiChartCoreXF implements ICloneable, IStiApplyStyle, IStiChartCoreXF {
        private static implementsStiChartCoreXF;
        implements(): any[];
        clone(): any;
        applyStyle(style: IStiChartStyle): void;
        render(context: StiContext, rect: RectangleD, useMargins: boolean): StiCellGeom;
        private setLegendRect;
        private _chart;
        get chart(): IStiChart;
        set chart(value: IStiChart);
        private _fullRectangle;
        get fullRectangle(): RectangleD;
        constructor(chart: IStiChart);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiChartTable implements IStiJsonReportObject, IStiChartTable, ICloneable {
        private static implementsStiChartTable;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get propName(): string;
        clone(): StiChartTable;
        get font(): Font;
        set font(value: Font);
        private _visible;
        get visible(): boolean;
        set visible(value: boolean);
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        private _markerVisible;
        get markerVisible(): boolean;
        set markerVisible(value: boolean);
        private _gridLineColor;
        get gridLineColor(): Color;
        set gridLineColor(value: Color);
        get textColor(): Color;
        set textColor(value: Color);
        private _gridLinesHor;
        get gridLinesHor(): boolean;
        set gridLinesHor(value: boolean);
        private _gridLinesVert;
        get gridLinesVert(): boolean;
        set gridLinesVert(value: boolean);
        private _gridOutline;
        get gridOutline(): boolean;
        set gridOutline(value: boolean);
        private _format;
        get format(): string;
        set format(value: string);
        private _header;
        get header(): IStiChartTableHeader;
        set header(value: IStiChartTableHeader);
        private _core;
        get core(): StiChartTableCoreXF;
        set core(value: StiChartTableCoreXF);
        private _dataCells;
        get dataCells(): StiChartTableDataCells;
        set dataCells(value: StiChartTableDataCells);
        private _chart;
        get chart(): IStiChart;
        set chart(value: IStiChart);
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiChartTitle implements IStiChartTitle, ICloneable, IStiJsonReportObject {
        private static implementsStiChartTitle;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get propName(): string;
        clone(): StiChartTitle;
        private _core;
        get core(): StiChartTitleCoreXF;
        set core(value: StiChartTitleCoreXF);
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        private _font;
        get font(): Font;
        set font(value: Font);
        private _text;
        get text(): string;
        set text(value: string);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _antialiasing;
        get antialiasing(): boolean;
        set antialiasing(value: boolean);
        private _alignment;
        get alignment(): StringAlignment;
        set alignment(value: StringAlignment);
        private _dock;
        get dock(): StiChartTitleDock;
        set dock(value: StiChartTitleDock);
        private _spacing;
        get spacing(): number;
        set spacing(value: number);
        private _visible;
        get visible(): boolean;
        set visible(value: boolean);
        private _chart;
        get chart(): IStiChart;
        set chart(value: IStiChart);
        constructor(font?: Font, text?: string, brush?: StiBrush, antialiasing?: boolean, alignment?: StringAlignment, dock?: StiChartTitleDock, spacing?: number, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiStripsCollection extends CollectionBase<IStiStrips> implements IStiJsonReportObject, IStiApplyStyle, IStiStripsCollection {
        private static implementsStiStripsCollection;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        applyStyle(style: IStiChartStyle): void;
        private getStripsTitle;
        add(value: IStiStrips): void;
        chart: StiChart;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiConstantLinesCollection extends CollectionBase<IStiConstantLines> implements IStiJsonReportObject, IStiApplyStyle, IStiConstantLinesCollection {
        private static implementsStiConstantLinesCollection;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        applyStyle(style: IStiChartStyle): void;
        private getConstantLineTitle;
        add(value: IStiConstantLines): void;
        chart: StiChart;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    class StiSeriesLabels extends StiService implements IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        private static implementsStiSeriesLabels;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        static loadFromJsonObjectInternal(jObject: StiJson, chart: StiChart): IStiSeriesLabels;
        static loadLabelsFromXml(xmlNode: XmlNode, chart: StiChart): StiSeriesLabels;
        get componentId(): StiComponentId;
        get propName(): string;
        clone(): StiSeriesLabels;
        get serviceName(): string;
        get serviceCategory(): string;
        get serviceType(): Stimulsoft.System.Type;
        private _preventIntersection;
        get preventIntersection(): boolean;
        set preventIntersection(value: boolean);
        private _core;
        get core(): StiSeriesLabelsCoreXF;
        set core(value: StiSeriesLabelsCoreXF);
        get axisCore(): StiAxisSeriesLabelsCoreXF;
        get pieCore(): StiPieSeriesLabelsCoreXF;
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        get conditions(): StiChartConditionsCollection;
        set conditions(value: StiChartConditionsCollection);
        get showOnZeroValues(): boolean;
        set showOnZeroValues(value: boolean);
        private _showZeros;
        get showZeros(): boolean;
        set showZeros(value: boolean);
        private _showNulls;
        get showNulls(): boolean;
        set showNulls(value: boolean);
        private _markerVisible;
        get markerVisible(): boolean;
        set markerVisible(value: boolean);
        private _markerSize;
        get markerSize(): SizeD;
        set markerSize(value: SizeD);
        private _markerAlignment;
        get markerAlignment(): StiMarkerAlignment;
        set markerAlignment(value: StiMarkerAlignment);
        private _step;
        get step(): number;
        set step(value: number);
        private _valueType;
        get valueType(): StiSeriesLabelsValueType;
        set valueType(value: StiSeriesLabelsValueType);
        private _valueTypeSeparator;
        get valueTypeSeparator(): string;
        set valueTypeSeparator(value: string);
        private _legendValueType;
        get legendValueType(): StiSeriesLabelsValueType;
        set legendValueType(value: StiSeriesLabelsValueType);
        private _textBefore;
        get textBefore(): string;
        set textBefore(value: string);
        private _textAfter;
        get textAfter(): string;
        set textAfter(value: string);
        private _angle;
        get angle(): number;
        set angle(value: number);
        private _format;
        get format(): string;
        set format(value: string);
        private _antialiasing;
        get antialiasing(): boolean;
        set antialiasing(value: boolean);
        private _visible;
        get visible(): boolean;
        set visible(value: boolean);
        private _drawBorder;
        get drawBorder(): boolean;
        set drawBorder(value: boolean);
        private _useSeriesColor;
        get useSeriesColor(): boolean;
        set useSeriesColor(value: boolean);
        private _labelColor;
        get labelColor(): Color;
        set labelColor(value: Color);
        private _borderColor;
        get borderColor(): Color;
        set borderColor(value: Color);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _font;
        get font(): Font;
        set font(value: Font);
        private _chart;
        get chart(): IStiChart;
        set chart(value: IStiChart);
        private _wordWrap;
        get wordWrap(): boolean;
        set wordWrap(value: boolean);
        private _width;
        get width(): number;
        set width(value: number);
        private _formatService;
        get formatService(): StiFormatService;
        set formatService(value: StiFormatService);
        toString(): string;
        createNew(): StiSeriesLabels;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisSeriesLabels extends StiSeriesLabels implements IStiJsonReportObject, IStiSeriesLabels, ICloneable, IStiAxisSeriesLabels {
        private static implementsStiAxisSeriesLabels;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _showInPercent;
        get showInPercent(): boolean;
        set showInPercent(value: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCenterAxisLabels extends StiAxisSeriesLabels implements IStiJsonReportObject, IStiSeriesLabels, IStiCenterAxisLabels, IStiAxisSeriesLabels, ICloneable {
        private static implementsStiCenterAxisLabels;
        implements(): any[];
        get componentId(): StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiAxis implements IStiAxis, IStiJsonReportObject {
        private static implementsStiAxis;
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxis;
        private _logarithmicScale;
        get logarithmicScale(): boolean;
        set logarithmicScale(value: boolean);
        private _core;
        get core(): StiAxisCoreXF;
        set core(value: StiAxisCoreXF);
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        private _startFromZero;
        get startFromZero(): boolean;
        set startFromZero(value: boolean);
        get step(): number;
        set step(value: number);
        private _interaction;
        get interaction(): IStiAxisInteraction;
        set interaction(value: IStiAxisInteraction);
        private _labels;
        get labels(): IStiAxisLabels;
        set labels(value: IStiAxisLabels);
        private _range;
        get range(): IStiAxisRange;
        set range(value: IStiAxisRange);
        private _title;
        get title(): IStiAxisTitle;
        set title(value: IStiAxisTitle);
        private _ticks;
        get ticks(): IStiAxisTicks;
        set ticks(value: IStiAxisTicks);
        private _arrowStyle;
        get arrowStyle(): StiArrowStyle;
        set arrowStyle(value: StiArrowStyle);
        private _lineStyle;
        get lineStyle(): StiPenStyle;
        set lineStyle(value: StiPenStyle);
        private _lineColor;
        get lineColor(): Color;
        set lineColor(value: Color);
        private _lineWidth;
        get lineWidth(): number;
        set lineWidth(value: number);
        private _visible;
        get visible(): boolean;
        set visible(value: boolean);
        get titleDirection(): StiLegendDirection;
        set titleDirection(value: StiLegendDirection);
        private _area;
        get area(): IStiAxisArea;
        set area(value: IStiAxisArea);
        private _info;
        get info(): StiAxisInfoXF;
        set info(value: StiAxisInfoXF);
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, allowApplyStyle?: boolean, logarithmicScale?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiYAxis extends StiAxis implements IStiJsonReportObject, IStiYAxis, ICloneable, IStiAxis {
        private static implementsStiYAxis;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get propName(): string;
        private _showYAxis;
        get showYAxis(): StiShowYAxis;
        set showYAxis(value: StiShowYAxis);
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, showYAxis?: StiShowYAxis, allowApplyStyle?: boolean, logarithmicScale?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiYRightAxis extends StiYAxis implements IStiJsonReportObject, IStiYAxis, ICloneable, IStiAxis, IStiYRightAxis {
        private static implementsStiYRightAxis;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        get componentId(): StiComponentId;
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, allowApplyStyle?: boolean, logarithmicScale?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiXAxis extends StiAxis implements IStiJsonReportObject, IStiAxis, IStiXAxis, ICloneable {
        private static implementsStiXAxis;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get propName(): string;
        private _showEdgeValues;
        get showEdgeValues(): boolean;
        set showEdgeValues(value: boolean);
        private _showXAxis;
        get showXAxis(): StiShowXAxis;
        set showXAxis(value: StiShowXAxis);
        private _dateTimeStep;
        get dateTimeStep(): IStiAxisDateTimeStep;
        set dateTimeStep(value: IStiAxisDateTimeStep);
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, showXAxis?: StiShowXAxis, showEdgeValues?: boolean, allowApplyStyle?: boolean, dateTimeStep?: IStiAxisDateTimeStep, logarithmicScale?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiXTopAxis extends StiXAxis implements IStiXTopAxis, ICloneable, IStiAxis, IStiXAxis, IStiJsonReportObject {
        private static implementsStiXTopAxis;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        get componentId(): StiComponentId;
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, showXAxis?: StiShowXAxis, showEdgeValues?: boolean, allowApplyStyle?: boolean, logarithmicScale?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiYLeftAxis extends StiYAxis implements IStiJsonReportObject, IStiYAxis, ICloneable, IStiAxis, IStiYLeftAxis {
        private static implementsStiYLeftAxis;
        implements(): any[];
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, showYAxis?: StiShowYAxis, allowApplyStyle?: boolean, logarithmicScale?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiAxisLabels implements IStiJsonReportObject, IStiAxisLabels, ICloneable {
        private static implementsStiAxisLabels;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxisLabels;
        private _core;
        get core(): StiAxisLabelsCoreXF;
        set core(value: StiAxisLabelsCoreXF);
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        private _format;
        get format(): string;
        set format(value: string);
        private _angle;
        get angle(): number;
        set angle(value: number);
        private _width;
        get width(): number;
        set width(value: number);
        private _textBefore;
        get textBefore(): string;
        set textBefore(value: string);
        private _textAfter;
        get textAfter(): string;
        set textAfter(value: string);
        private _font;
        get font(): Font;
        set font(value: Font);
        private _antialiasing;
        get antialiasing(): boolean;
        set antialiasing(value: boolean);
        private _placement;
        get placement(): StiLabelsPlacement;
        set placement(value: StiLabelsPlacement);
        private _color;
        get color(): Color;
        set color(value: Color);
        private _textAlignment;
        get textAlignment(): StiHorAlignment;
        set textAlignment(value: StiHorAlignment);
        private _step;
        get step(): number;
        set step(value: number);
        private _wordWrap;
        get wordWrap(): boolean;
        set wordWrap(value: boolean);
        calculatedStep: number;
        formatService: StiFormatService;
        constructor(format?: string, textBefore?: string, textAfter?: string, angle?: number, font?: Font, antialiasing?: boolean, placement?: StiLabelsPlacement, color?: Color, width?: number, textAlignment?: StiHorAlignment, step?: number, allowApplyStyle?: boolean, wordWrap?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisRange implements IStiJsonReportObject, ICloneable, IStiAxisRange {
        private static implementsStiAxisRange;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxisRange;
        private _minimum;
        get minimum(): number;
        set minimum(value: number);
        private _maximum;
        get maximum(): number;
        set maximum(value: number);
        private _auto;
        get auto(): boolean;
        set auto(value: boolean);
        constructor(auto?: boolean, minimum?: number, maximum?: number);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisTicks implements IStiJsonReportObject, IStiAxisTicks, ICloneable {
        private static implementsStiAxisTicks;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxisTicks;
        private _lengthUnderLabels;
        get lengthUnderLabels(): number;
        set lengthUnderLabels(value: number);
        private _length;
        get length(): number;
        set length(value: number);
        private _minorLength;
        get minorLength(): number;
        set minorLength(value: number);
        private _minorCount;
        get minorCount(): number;
        set minorCount(value: number);
        private _step;
        get step(): number;
        set step(value: number);
        private _minorVisible;
        get minorVisible(): boolean;
        set minorVisible(value: boolean);
        private _visible;
        get visible(): boolean;
        set visible(value: boolean);
        constructor(visible?: boolean, length?: number, minorVisible?: boolean, minorLength?: number, minorCount?: number, step?: number, lengthUnderLabels?: number);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisInteraction implements IStiJsonReportObject, IStiAxisInteraction, ICloneable {
        private static implementsStiAxisInteraction;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxisInteraction;
        private _showScrollBar;
        get showScrollBar(): boolean;
        set showScrollBar(value: boolean);
        private _rangeScrollEnabled;
        get rangeScrollEnabled(): boolean;
        set rangeScrollEnabled(value: boolean);
        constructor(showScrollBar?: boolean, rangeScrollEnabled?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiAxisDateTimeStep implements IStiAxisDateTimeStep, IStiJsonReportObject {
        private static implementsStiAxisDateTimeStep;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxisDateTimeStep;
        private _step;
        get step(): StiTimeDateStep;
        set step(value: StiTimeDateStep);
        private _numberOfValues;
        get numberOfValues(): number;
        set numberOfValues(value: number);
        private _interpolation;
        get interpolation(): boolean;
        set interpolation(value: boolean);
        constructor(step?: StiTimeDateStep, numberOfValues?: number, interpolation?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiXBottomAxis extends StiXAxis implements IStiJsonReportObject, IStiXAxis, ICloneable, IStiXBottomAxis, IStiAxis {
        private static implementsStiXBottomAxis;
        implements(): any[];
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, showXAxis?: StiShowXAxis, showEdgeValues?: boolean, allowApplyStyle?: boolean, dateTimeStep?: IStiAxisDateTimeStep, logarithmicScale?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGridLines implements IStiJsonReportObject, IStiGridLines, ICloneable {
        private static implementsStiGridLines;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        needSetAreaJsonPropertyInternal: boolean;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get propName(): string;
        clone(): StiGridLines;
        private _core;
        get core(): StiGridLinesCoreXF;
        set core(value: StiGridLinesCoreXF);
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        private _color;
        get color(): Color;
        set color(value: Color);
        private _minorColor;
        get minorColor(): Color;
        set minorColor(value: Color);
        private _style;
        get style(): StiPenStyle;
        set style(value: StiPenStyle);
        private _minorStyle;
        get minorStyle(): StiPenStyle;
        set minorStyle(value: StiPenStyle);
        private _visible;
        get visible(): boolean;
        set visible(value: boolean);
        private _minorVisible;
        get minorVisible(): boolean;
        set minorVisible(value: boolean);
        private _minorCount;
        get minorCount(): number;
        set minorCount(value: number);
        private _area;
        get area(): IStiArea;
        set area(value: IStiArea);
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, minorColor?: Color, minorStyle?: StiPenStyle, minorVisible?: boolean, minorCount?: number, allowApplyStyle?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGridLinesVert extends StiGridLines implements IStiJsonReportObject, IStiGridLines, ICloneable, IStiGridLinesVert {
        private static implementsStiGridLinesVert;
        implements(): any[];
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, minorColor?: Color, minorStyle?: StiPenStyle, minorVisible?: boolean, minorCount?: number, allowApplyStyle?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGridLinesHor extends StiGridLines implements IStiJsonReportObject, IStiGridLines, IStiGridLinesHor, ICloneable {
        private static implementsStiGridLinesHor;
        implements(): any[];
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, minorColor?: Color, minorStyle?: StiPenStyle, minorVisible?: boolean, minorCount?: number, allowApplyStyle?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiInterlacing implements IStiInterlacing, ICloneable, IStiJsonReportObject {
        private static implementsStiInterlacing;
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        needSetAreaJsonPropertyInternal: boolean;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get propName(): string;
        clone(): StiInterlacing;
        private _core;
        get core(): StiInterlacingCoreXF;
        set core(value: StiInterlacingCoreXF);
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        private _interlacedBrush;
        get interlacedBrush(): StiBrush;
        set interlacedBrush(value: StiBrush);
        private _visible;
        get visible(): boolean;
        set visible(value: boolean);
        private _area;
        get area(): IStiArea;
        set area(value: IStiArea);
        constructor(interlacedBrush?: StiBrush, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiInterlacingVert extends StiInterlacing implements IStiInterlacingVert {
        private static implementsStiInterlacingVert;
        implements(): any[];
        constructor(interlacedBrush?: StiBrush, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiInterlacingHor extends StiInterlacing implements IStiInterlacing, IStiInterlacingHor, IStiJsonReportObject, ICloneable {
        private static implementsStiInterlacingHor;
        implements(): any[];
        constructor(interlacedBrush?: StiBrush, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisArea extends StiArea implements IStiJsonReportObject, IStiAxisArea, IStiArea, ICloneable {
        private static implementsStiAxisArea;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxisArea;
        get axisCore(): StiAxisAreaCoreXF;
        private _interlacingHor;
        get interlacingHor(): IStiInterlacingHor;
        set interlacingHor(value: IStiInterlacingHor);
        private _interlacingVert;
        get interlacingVert(): IStiInterlacingVert;
        set interlacingVert(value: IStiInterlacingVert);
        private _gridLinesHor;
        get gridLinesHor(): IStiGridLinesHor;
        set gridLinesHor(value: IStiGridLinesHor);
        private _gridLinesHorRight;
        get gridLinesHorRight(): IStiGridLinesHor;
        set gridLinesHorRight(value: IStiGridLinesHor);
        private _gridLinesVert;
        get gridLinesVert(): IStiGridLinesVert;
        set gridLinesVert(value: IStiGridLinesVert);
        private _yAxis;
        get yAxis(): IStiYAxis;
        set yAxis(value: IStiYAxis);
        private _yRightAxis;
        get yRightAxis(): IStiYAxis;
        set yRightAxis(value: IStiYAxis);
        private _xAxis;
        get xAxis(): IStiXAxis;
        set xAxis(value: IStiXAxis);
        private _xTopAxis;
        get xTopAxis(): IStiXAxis;
        set xTopAxis(value: IStiXAxis);
        private _reverseHor;
        get reverseHor(): boolean;
        set reverseHor(value: boolean);
        private _reverseVert;
        get reverseVert(): boolean;
        set reverseVert(value: boolean);
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiClusteredColumnArea extends StiAxisArea implements IStiJsonReportObject, IStiClusteredColumnArea, IStiAxisArea, IStiRoundValuesArea, ICloneable, IStiArea {
        private static implementsStiClusteredColumnArea;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        roundValues: boolean;
        get componentId(): StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiSeriesCollection extends CollectionBase<IStiSeries> implements IStiJsonReportObject, IStiApplyStyle, IStiSeriesCollection {
        private static implementsStiSeriesCollection;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, chart: StiChart): void;
        applyStyle(style: IStiChartStyle): void;
        private getSeriesTitle;
        add(value: IStiSeries): void;
        insert(index: number, value: IStiSeries): void;
        remove(item: IStiSeries): void;
        removeAt(index: number): void;
        getByName(name: string): IStiSeries;
        setByName(name: string, value: IStiSeries): void;
        seriesAdded: Function;
        private invokeSeriesAdded;
        seriesRemoved: Function;
        private invokeSeriesRemoved;
        chart: StiChart;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiFilterItem = Stimulsoft.Report.Components.StiFilterItem;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    class StiChartFilter implements IStiJsonReportObject, IStiChartFilter, ICloneable {
        private static implementsStiChartFilter;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(): StiChartFilter;
        get index(): number;
        private _condition;
        get condition(): StiFilterCondition;
        set condition(value: StiFilterCondition);
        private _dataType;
        get dataType(): StiFilterDataType;
        set dataType(value: StiFilterDataType);
        private _item;
        get item(): StiFilterItem;
        set item(value: StiFilterItem);
        private _valueObj;
        get value(): string;
        set value(value: string);
        toString(): string;
        filters: StiChartFiltersCollection;
        constructor(item?: StiFilterItem, dataType?: StiFilterDataType, condition?: StiFilterCondition, value?: string);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    import StiFilterItem = Stimulsoft.Report.Components.StiFilterItem;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiChartCondition extends StiChartFilter implements IStiChartCondition, IStiChartFilter, IStiJsonReportObject {
        private static implementsStiChartCondition;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(): StiChartCondition;
        private _color;
        get color(): Color;
        set color(value: Color);
        private _markerType;
        get markerType(): StiMarkerType;
        set markerType(value: StiMarkerType);
        private _markerAngle;
        get markerAngle(): number;
        set markerAngle(value: number);
        conditions: StiChartConditionsCollection;
        constructor(color?: Color, item?: StiFilterItem, dataType?: StiFilterDataType, condition?: StiFilterCondition, value?: string, markerType?: StiMarkerType, markerAngle?: number);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiChartConditionsCollection extends CollectionBase<StiChartCondition> implements IStiJsonReportObject, ICloneable, IStiChartConditionsCollection {
        private static implementsStiChartConditionsCollection;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiChartConditionsCollection;
        add(condition: StiChartCondition): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiNewAutoSeriesEventArgs = Stimulsoft.Report.Events.StiNewAutoSeriesEventArgs;
    import StiGetTitleEventArgs = Stimulsoft.Report.Events.StiGetTitleEventArgs;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiSeries extends StiService implements IStiJsonReportObject, ICloneable, IStiSeries, IStiJsonReportObject {
        private static implementsStiSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get propName(): string;
        clone(): StiSeries;
        baseTransform(context: any, x: number, y: number, angle: number, dx: number, dy: number): void;
        get parent(): StiComponent;
        get serviceName(): string;
        get serviceCategory(): string;
        get serviceType(): Stimulsoft.System.Type;
        private _core;
        get core(): StiSeriesCoreXF;
        set core(value: StiSeriesCoreXF);
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        private _format;
        get format(): string;
        set format(value: string);
        private _sortBy;
        get sortBy(): StiSeriesSortType;
        set sortBy(value: StiSeriesSortType);
        private _sortDirection;
        get sortDirection(): StiSeriesSortDirection;
        set sortDirection(value: StiSeriesSortDirection);
        private _showInLegend;
        get showInLegend(): boolean;
        set showInLegend(value: boolean);
        get showLabels(): boolean;
        set showLabels(value: boolean);
        private _showSeriesLabels;
        get showSeriesLabels(): StiShowSeriesLabels;
        set showSeriesLabels(value: StiShowSeriesLabels);
        private _showShadow;
        get showShadow(): boolean;
        set showShadow(value: boolean);
        private _filterMode;
        get filterMode(): StiFilterMode;
        set filterMode(value: StiFilterMode);
        private _filters;
        get filters(): StiChartFiltersCollection;
        set filters(value: StiChartFiltersCollection);
        private _conditions;
        get conditions(): StiChartConditionsCollection;
        set conditions(value: StiChartConditionsCollection);
        private _topN;
        get topN(): IStiSeriesTopN;
        set topN(value: IStiSeriesTopN);
        private _yAxis;
        get yAxis(): StiSeriesYAxis;
        set yAxis(value: StiSeriesYAxis);
        private _seriesLabels;
        get seriesLabels(): IStiSeriesLabels;
        set seriesLabels(value: IStiSeriesLabels);
        get trendLine(): IStiTrendLine;
        set trendLine(value: IStiTrendLine);
        private _trendLines;
        get trendLines(): StiTrendLinesCollection;
        set trendLines(value: StiTrendLinesCollection);
        private _isTotalLabel;
        get isTotalLabel(): boolean;
        set isTotalLabel(value: boolean);
        private _chart;
        get chart(): IStiChart;
        set chart(value: IStiChart);
        private valuesOld;
        get valuesStart(): number[];
        set valuesStart(value: number[]);
        private _values;
        get values(): number[];
        set values(value: number[]);
        private _valueDataColumn;
        get valueDataColumn(): string;
        set valueDataColumn(value: string);
        get valuesString(): string;
        set valuesString(value: string);
        originalArguments: any[];
        private _arguments;
        get arguments(): any[];
        set arguments(value: any[]);
        protected getArguments(): any[];
        protected setArguments(value: any[]): void;
        private _argumentDataColumn;
        get argumentDataColumn(): string;
        set argumentDataColumn(value: string);
        get argumentsString(): string;
        set argumentsString(value: string);
        private _autoSeriesTitleDataColumn;
        get autoSeriesTitleDataColumn(): string;
        set autoSeriesTitleDataColumn(value: string);
        private _autoSeriesKeyDataColumn;
        get autoSeriesKeyDataColumn(): string;
        set autoSeriesKeyDataColumn(value: string);
        private _autoSeriesColorDataColumn;
        get autoSeriesColorDataColumn(): string;
        set autoSeriesColorDataColumn(value: string);
        private _toolTips;
        get toolTips(): string[];
        set toolTips(value: string[]);
        private _toolTipDataColumn;
        get toolTipDataColumn(): string;
        set toolTipDataColumn(value: string);
        get toolTipsString(): string;
        set toolTipsString(value: string);
        private _tags;
        get tags(): any[];
        set tags(value: any[]);
        private _tagDataColumn;
        get tagDataColumn(): string;
        set tagDataColumn(value: string);
        get tagString(): string;
        set tagString(value: string);
        private _hyperlinks;
        get hyperlinks(): string[];
        set hyperlinks(value: string[]);
        private _hyperlinkDataColumn;
        get hyperlinkDataColumn(): string;
        set hyperlinkDataColumn(value: string);
        get hyperlinkString(): string;
        set hyperlinkString(value: string);
        private _drillDownEnabled;
        get drillDownEnabled(): boolean;
        set drillDownEnabled(value: boolean);
        private _drillDownReport;
        get drillDownReport(): string;
        set drillDownReport(value: string);
        get drillDownPage(): StiPage;
        set drillDownPage(value: StiPage);
        private _drillDownPageGuid;
        get drillDownPageGuid(): string;
        set drillDownPageGuid(value: string);
        private _allowSeries;
        get allowSeries(): boolean;
        set allowSeries(value: boolean);
        private _allowSeriesElements;
        get allowSeriesElements(): boolean;
        set allowSeriesElements(value: boolean);
        get coreTitle(): string;
        set coreTitle(value: string);
        isDashboard: boolean;
        legendColor: Color;
        private _interaction;
        get interaction(): IStiSeriesInteraction;
        set interaction(value: IStiSeriesInteraction);
        processSeriesColors(pointIndex: number, seriesColor: Color): Color;
        processSeriesMarkerType(pointIndex: number, markerType: StiMarkerType): StiMarkerType;
        processSeriesMarkerAngle(pointIndex: number, markerAngle: number): number;
        processSeriesMarkerVisible(pointIndex: number): boolean;
        processSeriesBrushes(pointIndex: number, seriesBrush: StiBrush): StiBrush;
        private getConditionResult;
        toString(): string;
        static tryParseValue(value: string, culture: string, refResult: {
            ref: number;
        }): boolean;
        static getNullableValuesFromString(series: StiSeries, list: string): number[];
        static getValuesFromString(list: string): number[];
        static getStringsFromString(list: string): string[];
        static getArgumentsFromString(list: string): any[];
        protected getOffsetForValues(): number;
        createNew(): StiSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        newAutoSeries: Function;
        invokeNewAutoSeries(e: StiNewAutoSeriesEventArgs): void;
        getValue: Function;
        protected onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValues: Function;
        protected onGetListOfValues(e: StiGetValueEventArgs): void;
        invokeGetListOfValues(sender: StiComponent, e: StiGetValueEventArgs, series: StiSeries): void;
        getArgument: Function;
        protected onGetArgument(e: StiValueEventArgs): void;
        invokeGetArgument(sender: StiComponent, e: StiValueEventArgs): void;
        getListOfArguments: Function;
        protected onGetListOfArguments(e: StiGetValueEventArgs): void;
        invokeGetListOfArguments(sender: StiComponent, e: StiGetValueEventArgs): void;
        getTitle: Function;
        protected onGetTitle(e: StiGetTitleEventArgs): void;
        invokeGetTitle(sender: StiComponent, e: StiGetTitleEventArgs): void;
        getToolTip: Function;
        protected onGetToolTip(e: StiValueEventArgs): void;
        invokeGetToolTip(sender: any, e: StiValueEventArgs): void;
        getListOfToolTips: Function;
        protected onGetListOfToolTips(e: StiGetValueEventArgs): void;
        invokeGetListOfToolTips(sender: StiComponent, e: StiGetValueEventArgs): void;
        getTag: Function;
        protected onGetTag(e: StiValueEventArgs): void;
        invokeGetTag(sender: any, e: StiValueEventArgs): void;
        getListOfTags: Function;
        protected onGetListOfTags(e: StiGetValueEventArgs): void;
        invokeGetListOfTags(sender: StiComponent, e: StiGetValueEventArgs): void;
        getHyperlink: Function;
        protected onGetHyperlink(e: StiValueEventArgs): void;
        invokeGetHyperlink(sender: any, e: StiValueEventArgs): void;
        getListOfHyperlinks: Function;
        protected onGetListOfHyperlinks(e: StiGetValueEventArgs): void;
        invokeGetListOfHyperlinks(sender: StiComponent, e: StiGetValueEventArgs): void;
        private valueObj;
        get value(): string;
        set value(value: string);
        private _listOfValues;
        get listOfValues(): string;
        set listOfValues(value: string);
        private _argument;
        get argument(): string;
        set argument(value: string);
        private _listOfArguments;
        get listOfArguments(): string;
        set listOfArguments(value: string);
        private _titleValue;
        get titleValue(): string;
        set titleValue(value: string);
        private _title;
        get title(): string;
        set title(value: string);
        private _toolTip;
        get toolTip(): string;
        set toolTip(value: string);
        private _listOfToolTips;
        get listOfToolTips(): string;
        set listOfToolTips(value: string);
        private _tag;
        get tag(): string;
        set tag(value: string);
        private _listOfTags;
        get listOfTags(): string;
        set listOfTags(value: string);
        private _hyperlink;
        get hyperlink(): string;
        set hyperlink(value: string);
        private _listOfHyperlinks;
        get listOfHyperlinks(): string;
        set listOfHyperlinks(value: string);
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    import StiText = Stimulsoft.Report.Components.StiText;
    class StiChartInfo extends StiComponentInfo implements IStiChartInfo {
        private static implementsStiChartInfo;
        implements(): any[];
        storedForProcessAtEndChart: StiChart;
        interactiveComps: StiText[];
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiChartStyle extends StiBaseStyle implements IStiJsonReportObject, IStiChartStyle, ICloneable {
        private static implementsStiChartStyle;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromXml(xmlNode: XmlNode): StiChartStyle;
        static loadFromJsonObjectInternal(jObject: StiJson): StiChartStyle;
        get serviceName(): string;
        get serviceCategory(): string;
        get serviceType(): Stimulsoft.System.Type;
        isOffice2015Style: boolean;
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        private _core;
        get core(): StiStyleCoreXF;
        set core(value: StiStyleCoreXF);
        toString(): string;
        compareChartStyle(style: StiChartStyle): boolean;
        createNew(): StiChartStyle;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle25 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle29 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiLegend implements IStiJsonReportObject, ICloneable, IStiLegend {
        private static implementsStiLegend;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get propName(): string;
        clone(): StiLegend;
        private _core;
        get core(): StiLegendCoreXF;
        set core(value: StiLegendCoreXF);
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        private _chart;
        get chart(): IStiChart;
        set chart(value: IStiChart);
        private _hideSeriesWithEmptyTitle;
        get hideSeriesWithEmptyTitle(): boolean;
        set hideSeriesWithEmptyTitle(value: boolean);
        private _showShadow;
        get showShadow(): boolean;
        set showShadow(value: boolean);
        private _borderColor;
        get borderColor(): Color;
        set borderColor(value: Color);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _titleColor;
        get titleColor(): Color;
        set titleColor(value: Color);
        private _labelsColor;
        get labelsColor(): Color;
        set labelsColor(value: Color);
        private _direction;
        get direction(): StiLegendDirection;
        set direction(value: StiLegendDirection);
        private _horAlignment;
        get horAlignment(): StiLegendHorAlignment;
        set horAlignment(value: StiLegendHorAlignment);
        private _vertAlignment;
        get vertAlignment(): StiLegendVertAlignment;
        set vertAlignment(value: StiLegendVertAlignment);
        private _titleFont;
        get titleFont(): Font;
        set titleFont(value: Font);
        private _font;
        get font(): Font;
        set font(value: Font);
        private _visible;
        get visible(): boolean;
        set visible(value: boolean);
        private _markerVisible;
        get markerVisible(): boolean;
        set markerVisible(value: boolean);
        private _markerBorder;
        get markerBorder(): boolean;
        set markerBorder(value: boolean);
        private _markerSize;
        get markerSize(): SizeD;
        set markerSize(value: SizeD);
        private _markerAlignment;
        get markerAlignment(): StiMarkerAlignment;
        set markerAlignment(value: StiMarkerAlignment);
        private _columns;
        get columns(): number;
        set columns(value: number);
        private _horSpacing;
        get horSpacing(): number;
        set horSpacing(value: number);
        private _vertSpacing;
        get vertSpacing(): number;
        set vertSpacing(value: number);
        private _size;
        get size(): SizeD;
        set size(value: SizeD);
        private _title;
        get title(): string;
        set title(value: string);
        constructor();
    }
}
declare namespace Stimulsoft.Report.Components {
    import Font = Stimulsoft.System.Drawing.Font;
    import StiChartEditorType = Stimulsoft.Report.Chart.StiChartEditorType;
    import IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiProcessChartEvent = Stimulsoft.Report.Events.StiProcessChartEvent;
    import EventArgs = Stimulsoft.System.EventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiChartConditionsCollection = Stimulsoft.Report.Chart.StiChartConditionsCollection;
    import IStiArea = Stimulsoft.Report.Chart.IStiArea;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import IStiChartTable = Stimulsoft.Report.Chart.IStiChartTable;
    import IStiChartTitle = Stimulsoft.Report.Chart.IStiChartTitle;
    import IStiLegend = Stimulsoft.Report.Chart.IStiLegend;
    import IStiSeriesLabels = Stimulsoft.Report.Chart.IStiSeriesLabels;
    import StiChartCoreXF = Stimulsoft.Report.Chart.StiChartCoreXF;
    import StiChartInfo = Stimulsoft.Report.Chart.StiChartInfo;
    import StiConstantLinesCollection = Stimulsoft.Report.Chart.StiConstantLinesCollection;
    import IStiChartStyle = Stimulsoft.Report.Chart.IStiChartStyle;
    import StiStripsCollection = Stimulsoft.Report.Chart.StiStripsCollection;
    import StiSeriesCollection = Stimulsoft.Report.Chart.StiSeriesCollection;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiImageRotation = Stimulsoft.Report.Components.StiImageRotation;
    import StiComponentType = Stimulsoft.Report.Components.StiComponentType;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiFiltersCollection = Stimulsoft.Report.Components.StiFiltersCollection;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiChart extends StiComponent implements IStiBorder, IStiBusinessObject, IStiBrush, IStiDataSource, IStiDataRelation, IStiMasterComponent, IStiSort, IStiFilter, IStiExportImage, IStiExportImageExtended, IStiIgnoryStyle, IStiGlobalizationProvider, IStiChart, IStiJsonReportObject, IStiGetFonts {
        private static implementsStiChart;
        implements(): any[];
        jsonMasterComponentTemp: string;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        convertToHInches(value: number): number;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        clone(): StiChart;
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        private _filterMethodHandler;
        get filterMethodHandler(): Function;
        set filterMethodHandler(value: Function);
        private _filterMode;
        get filterMode(): StiFilterMode;
        set filterMode(value: StiFilterMode);
        private _filters;
        get filters(): StiFiltersCollection;
        set filters(value: StiFiltersCollection);
        get filter(): string;
        set filter(value: string);
        private _filterOn;
        get filterOn(): boolean;
        set filterOn(value: boolean);
        private _border;
        get border(): StiBorder;
        set border(value: StiBorder);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _sort;
        get sort(): string[];
        set sort(value: string[]);
        get dataSource(): StiDataSource;
        private _dataSourceName;
        get dataSourceName(): string;
        set dataSourceName(value: string);
        get isDataSourceEmpty(): boolean;
        get isBusinessObjectEmpty(): boolean;
        get businessObject(): StiBusinessObject;
        private _businessObjectGuid;
        get businessObjectGuid(): string;
        set businessObjectGuid(value: string);
        private _masterComponent;
        get masterComponent(): StiComponent;
        set masterComponent(value: StiComponent);
        private _countData;
        get countData(): number;
        set countData(value: number);
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        isEofValue: boolean;
        get isEof(): boolean;
        set isEof(value: boolean);
        isBofValue: boolean;
        get isBof(): boolean;
        set isBof(value: boolean);
        get isEmpty(): boolean;
        positionValue: number;
        get position(): number;
        set position(value: number);
        get count(): number;
        private isCacheValues;
        private cachedCount;
        private cachedIsBusinessObjectEmpty;
        private cachedIsDataSourceEmpty;
        private cachedDataSource;
        private cachedBusinessObject;
        cacheValues(cache: boolean): void;
        get dataRelation(): StiDataRelation;
        private _dataRelationName;
        get dataRelationName(): string;
        set dataRelationName(value: string);
        private _processAtEnd;
        get processAtEnd(): boolean;
        set processAtEnd(value: boolean);
        getFonts(): Font[];
        get priority(): number;
        get localizedCategory(): string;
        defaultClientRectangle: RectangleD;
        get componentType(): StiComponentType;
        get localizedName(): string;
        invokeEvents(): void;
        protected onProcessChart(e: EventArgs): void;
        invokeProcessChart(sender: any, e: EventArgs): void;
        processChartEvent: StiProcessChartEvent;
        private series_SeriesAdded;
        private series_SeriesRemoved;
        private _seriesLabelsConditions;
        get seriesLabelsConditions(): StiChartConditionsCollection;
        set seriesLabelsConditions(value: StiChartConditionsCollection);
        get chartType(): IStiArea;
        set chartType(value: IStiArea);
        private _isDashboard;
        get isDashboard(): boolean;
        set isDashboard(value: boolean);
        createNew(): StiComponent;
        applyStyle(): void;
        simplifyValues(): void;
        private _core;
        get core(): StiChartCoreXF;
        set core(value: StiChartCoreXF);
        private _rotation;
        get rotation(): StiImageRotation;
        set rotation(value: StiImageRotation);
        private _editorType;
        get editorType(): StiChartEditorType;
        set editorType(value: StiChartEditorType);
        private _series;
        get series(): StiSeriesCollection;
        set series(value: StiSeriesCollection);
        private _area;
        get area(): IStiArea;
        set area(value: IStiArea);
        private _table;
        get table(): IStiChartTable;
        set table(value: IStiChartTable);
        private _style;
        get style(): IStiChartStyle;
        set style(value: IStiChartStyle);
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        private _customStyleName;
        get customStyleName(): string;
        set customStyleName(value: string);
        private _horSpacing;
        get horSpacing(): number;
        set horSpacing(value: number);
        private _vertSpacing;
        get vertSpacing(): number;
        set vertSpacing(value: number);
        private _seriesLabels;
        get seriesLabels(): IStiSeriesLabels;
        set seriesLabels(value: IStiSeriesLabels);
        get labels(): IStiSeriesLabels;
        set labels(value: IStiSeriesLabels);
        private _legend;
        get legend(): IStiLegend;
        set legend(value: IStiLegend);
        private _title;
        get title(): IStiChartTitle;
        set title(value: IStiChartTitle);
        private _strips;
        get strips(): StiStripsCollection;
        set strips(value: StiStripsCollection);
        private _constantLines;
        get constantLines(): StiConstantLinesCollection;
        set constantLines(value: StiConstantLinesCollection);
        private _isAnimation;
        get isAnimation(): boolean;
        set isAnimation(value: boolean);
        private _chartInfo;
        get chartInfo(): StiChartInfo;
        constructor(rect?: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiChartOptions {
        private static _oldChartPercentMode;
        static get oldChartPercentMode(): boolean;
        static set oldChartPercentMode(value: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import PointD = Stimulsoft.System.Drawing.Point;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
    class StiInteractionOptions {
        private _updateContext;
        get updateContext(): boolean;
        set updateContext(value: boolean);
        private _recallEvent;
        get recallEvent(): boolean;
        set recallEvent(value: boolean);
        private _recallTime;
        get recallTime(): TimeSpan;
        set recallTime(value: TimeSpan);
        private _isRecalled;
        get isRecalled(): boolean;
        set isRecalled(value: boolean);
        private _mousePoint;
        get mousePoint(): PointD;
        set mousePoint(value: PointD);
        private _dragEnabled;
        get dragEnabled(): boolean;
        set dragEnabled(value: boolean);
        private _dragDelta;
        get dragDelta(): SizeD;
        set dragDelta(value: SizeD);
        private _interactionToolTip;
        get interactionToolTip(): string;
        set interactionToolTip(value: string);
        private _interactionHyperlink;
        get interactionHyperlink(): string;
        set interactionHyperlink(value: string);
        private _seriesInteractionData;
        get seriesInteractionData(): StiSeriesInteractionData;
        set seriesInteractionData(value: StiSeriesInteractionData);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiPointHelper {
        private static getPointClassify;
        static isPointInTriangle(p: PointD, a: PointD, b: PointD, c: PointD): boolean;
        static isPointInPolygon(p: PointD, points: PointD[]): boolean;
        static getLineOffsetRectangle(point1: PointD, point2: PointD, offset: number): PointD[];
        static isLineContainsPoint(startPoint: PointD, endPoint: PointD, offset: number, point: PointD): boolean;
        static optimizePoints(points: PointD[]): PointD[];
    }
}
declare namespace Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSimplifyHelper {
        private static getSquareDistance;
        private static getSquareSegmentDistance;
        private static simplifyRadialDistance;
        private static simplifyDouglasPeucker;
        static simplify(points: PointD[], tolerance: number, highestQuality: boolean): PointD[];
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAreaCoreXF implements ICloneable, IStiApplyStyle, IStiAreaCoreXF, IAsIs {
        private static implementsStiAreaCoreXF;
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        clone(): StiAreaCoreXF;
        applyStyle(style: IStiChartStyle): void;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        protected prepareInfo(rect: RectangleD): void;
        checkInLabelsTypes(typeForCheck: Stimulsoft.System.Type): boolean;
        getSeries(): IStiSeries[];
        isAcceptableSeries(seriesType: Stimulsoft.System.Type): boolean;
        isAcceptableSeriesLabels(seriesLabelsType: Stimulsoft.System.Type): boolean;
        private _area;
        get area(): IStiArea;
        set area(value: IStiArea);
        get localizedName(): string;
        get seriesOrientation(): StiChartSeriesOrientation;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiShowEmptyCellsAs = Stimulsoft.Report.Chart.StiShowEmptyCellsAs;
    class StiBaseLineSeries extends StiSeries implements IStiJsonReportObject, IStiBaseLineSeries, ICloneable, IStiSeries, IStiAllowApplyColorNegative, IStiShowNullsSeries, IStiShowZerosSeries {
        private static implementsStiBaseLineSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiBaseLineSeries;
        private _showNulls;
        get showNulls(): boolean;
        set showNulls(value: boolean);
        private _showZeros;
        get showZeros(): boolean;
        set showZeros(value: boolean);
        get showMarker(): boolean;
        set showMarker(value: boolean);
        get markerColor(): Color;
        set markerColor(value: Color);
        get markerSize(): number;
        set markerSize(value: number);
        get markerType(): StiMarkerType;
        set markerType(value: StiMarkerType);
        private _marker;
        get marker(): IStiMarker;
        set marker(value: IStiMarker);
        private _lineMarker;
        get lineMarker(): IStiLineMarker;
        set lineMarker(value: IStiLineMarker);
        private _lineColor;
        get lineColor(): Color;
        set lineColor(value: Color);
        getLineColor(): Color;
        setLineColor(value: Color): void;
        private _lineStyle;
        get lineStyle(): StiPenStyle;
        set lineStyle(value: StiPenStyle);
        private _lighting;
        get lighting(): boolean;
        set lighting(value: boolean);
        private _lineWidth;
        get lineWidth(): number;
        set lineWidth(value: number);
        private _labelsOffset;
        get labelsOffset(): number;
        set labelsOffset(value: number);
        private _lineColorNegative;
        get lineColorNegative(): Color;
        set lineColorNegative(value: Color);
        private _allowApplyColorNegative;
        get allowApplyColorNegative(): boolean;
        set allowApplyColorNegative(value: boolean);
        showNullsAs: StiShowEmptyCellsAs;
        showZerosAs: StiShowEmptyCellsAs;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiScatterSeries extends StiBaseLineSeries implements IStiJsonReportObject, IStiBaseLineSeries, IStiSeries, ICloneable, IStiScatterSeries, IStiAllowApplyColorNegative {
        private static implementsStiScatterSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        get componentId(): StiComponentId;
        clone(): StiScatterSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        getLineColor(): Color;
        setLineColor(value: Color): void;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiScatterLineSeries extends StiScatterSeries implements IStiScatterLineSeries, IStiBaseLineSeries, IStiScatterSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        private static implementsStiScatterLineSeries;
        implements(): any[];
        get componentId(): StiComponentId;
        clone(): StiScatterLineSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisAreaCoreXF extends StiAreaCoreXF implements IStiAxisAreaCoreXF {
        private static implementsStiAxisAreaCoreXF;
        implements(): any[];
        applyStyle(style: IStiChartStyle): void;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        private calculateScrollValuesX;
        private calculateScrollValuesY;
        protected prepareInfo(rect: RectangleD): void;
        private renderSeries;
        isAutoRangeXAxis(axis: IStiAxis): boolean;
        isAutoRangeYAxis(axis: IStiAxis): boolean;
        calculateMinimumAndMaximumXAxis(axis: IStiAxis): void;
        calculateMinimumAndMaximumYAxis(axis: IStiAxis): void;
        getArgumentLabel(line: StiStripLineXF, series: IStiSeries): string;
        switchOff(): void;
        private swap;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        protected createStripLinesXAxis(axis: IStiAxis): void;
        protected checkShowEdgeValues(axis: IStiAxis): void;
        protected createStripLinesYAxis(axis: IStiAxis, isDateTimeValues: boolean): void;
        protected checkStripLinesAndMaximumMinimumXAxis(axis: IStiAxis): void;
        protected checkStripLinesAndMaximumMinimumYAxis(axis: IStiAxis): void;
        private calculateStepX;
        private calculateStepY;
        private checkStartFromZeroYAxis;
        calculatePositions(axis: IStiAxis, REFcollection: any, step: number, calculationForTicks: boolean): void;
        private calculateDivider;
        private static rotateStripLines;
        getDividerX(): number;
        getDividerTopX(): number;
        getDividerY(): number;
        getDividerRightY(): number;
        valuesCount: number;
        get scrollDistanceX(): number;
        get scrollDistanceY(): number;
        private _scrollRangeX;
        get scrollRangeX(): number;
        private _scrollRangeY;
        get scrollRangeY(): number;
        private _scrollViewX;
        get scrollViewX(): number;
        private _scrollViewY;
        get scrollViewY(): number;
        private _blockScrollValueX;
        get blockScrollValueX(): boolean;
        set blockScrollValueX(value: boolean);
        private _blockScrollValueY;
        get blockScrollValueY(): boolean;
        set blockScrollValueY(value: boolean);
        private _scrollValueX;
        get scrollValueX(): number;
        set scrollValueX(value: number);
        private _scrollValueY;
        get scrollValueY(): number;
        set scrollValueY(value: number);
        private _scrollDpiX;
        get scrollDpiX(): number;
        private _scrollDpiY;
        get scrollDpiY(): number;
        private _scrollDragStartValue;
        get scrollDragStartValue(): number;
        set scrollDragStartValue(value: number);
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiClusteredColumnAreaCoreXF extends StiAxisAreaCoreXF {
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiArea = Stimulsoft.Report.Chart.IStiArea;
    class StiBoxAndWhiskerAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiScatterAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        private isArgumentDateTime;
        private isXAxisAutoRange;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        protected checkStripLinesAndMaximumMinimumXAxis(axis: IStiAxis): void;
        protected createStripLinesXAxis(axis: IStiAxis): void;
        protected createStripLinesYAxis(axis: IStiAxis, isDateTimeValues: boolean): void;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiArea = Stimulsoft.Report.Chart.IStiArea;
    class StiBubbleAreaCoreXF extends StiScatterAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiCandlestickAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        protected createStripLinesXAxis(axis: IStiAxis): void;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiClusteredBarAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get seriesOrientation(): StiChartSeriesOrientation;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiAreaAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiHistogramAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiLineAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiParetoAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiSplineAreaAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiSplineAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiSteppedAreaAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiSteppedLineAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiWaterfallAreaCoreXF extends StiAxisAreaCoreXF {
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieAreaCoreXF extends StiAreaCoreXF {
        valuesCount: number;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesCollection: IStiSeries[]): void;
        protected prepareInfo(rect: RectangleD): void;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDoughnutAreaCoreXF extends StiPieAreaCoreXF {
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStackedBarAreaCoreXF extends StiClusteredBarAreaCoreXF {
        private prepareSeriesRange;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        get localizedName(): string;
        get seriesOrientation(): StiChartSeriesOrientation;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiFullStackedBarAreaCoreXF extends StiStackedBarAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStackedColumnAreaCoreXF extends StiAxisAreaCoreXF {
        private prepareSeriesRange;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiFullStackedColumnAreaCoreXF extends StiStackedColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiFullStackedAreaAreaCoreXF extends StiFullStackedColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiFullStackedLineAreaCoreXF extends StiFullStackedColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiFullStackedSplineAreaAreaCoreXF extends StiFullStackedColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiFullStackedSplineAreaCoreXF extends StiFullStackedColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiFunnelAreaCoreXF extends StiAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesCollection: IStiSeries[]): void;
        protected prepareInfo(rect: RectangleD): void;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiGanttAreaCoreXF extends StiClusteredBarAreaCoreXF {
        protected createStripLinesXAxis(axis: IStiAxis): void;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        get localizedName(): string;
        get seriesOrientation(): StiChartSeriesOrientation;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPictorialAreaCoreXF extends StiAreaCoreXF {
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiRadarAreaCoreXF extends StiAreaCoreXF {
        applyStyle(style: IStiChartStyle): void;
        valuesCount: number;
        points: PointD[];
        arguments: any[];
        centerPoint: PointD;
        render(context: StiContext, areaRect: RectangleD): StiCellGeom;
        private static centerArea;
        measureLabels(context: StiContext, rect: RectangleD): RectangleD;
        renderArguments(context: StiContext, geom: StiRadarAreaGeom, series: IStiSeries): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesCollection: IStiSeries[]): void;
        protected prepareInfo(rect: RectangleD): void;
        protected createStripLinesAxis(axis: IStiYRadarAxis, minimum: number, maximum: number): void;
        private calculateStep;
        calculatePositions(axis: IStiYRadarAxis, REFcollection: any, step: number): void;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiRadarAreaAreaCoreXF extends StiRadarAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiRadarLineAreaCoreXF extends StiRadarAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiRadarPointAreaCoreXF extends StiRadarAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiRangeAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiRangeBarAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        protected createStripLinesXAxis(axis: IStiAxis): void;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiSplineRangeAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiSteppedRangeAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStackedAreaAreaCoreXF extends StiStackedColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStackedLineAreaCoreXF extends StiStackedColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStackedSplineAreaAreaCoreXF extends StiStackedColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStackedSplineAreaCoreXF extends StiStackedColumnAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStockAreaCoreXF extends StiCandlestickAreaCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiSunburstAreaCoreXF extends StiAreaCoreXF {
        render(context: StiContext, rect: Rectangle): StiCellGeom;
        protected prepareInfo(rect: Rectangle): void;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTreemapAreaCoreXF extends StiAreaCoreXF {
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderSeries(context: StiContext, boxes: RectangleD[], boxRoot: RectangleD, geom: StiAreaGeom, seriesCollection: IStiSeries[]): void;
        private cutArea;
        squarify(data: number[], currentrow: number[], container: RectangleD, stack: RectangleD[]): RectangleD[];
        private improvesRatio;
        private calculateRatio;
        normalizeDataForArea(data: number[], area: number): number[];
        private getCoordinates;
        prepareInfo(rect: RectangleD): void;
        get localizedName(): string;
        get position(): number;
        constructor(area: IStiArea);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisCoreXF implements ICloneable, IStiApplyStyle, IStiAxisCoreXF, IAsIs {
        private static implementsStiAxisCoreXF;
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        clone(): StiAxisCoreXF;
        private _isMouseOverDecreaseButton;
        get isMouseOverDecreaseButton(): boolean;
        set isMouseOverDecreaseButton(value: boolean);
        private _isMouseOverIncreaseButton;
        get isMouseOverIncreaseButton(): boolean;
        set isMouseOverIncreaseButton(value: boolean);
        private _isMouseOverTrackBar;
        get isMouseOverTrackBar(): boolean;
        set isMouseOverTrackBar(value: boolean);
        applyStyle(style: IStiChartStyle): void;
        getStartFromZero(): boolean;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderView(context: StiContext, rect: RectangleD): StiCellGeom;
        calculateStripPositions(topPosition: number, bottomPosition: number): void;
        getTicksMaxLength(context: StiContext): number;
        getArrowHeight(context: StiContext): number;
        getLabelsSpaceAxis(context: StiContext): number;
        getLabelsTwoLinesDestination(context: StiContext): number;
        getFontGeom(context: StiContext): StiFontGeom;
        getTextAlignment(): StiHorAlignment;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        protected getAxisTitleSize(context: StiContext): SizeD;
        protected getAngleTitle(): number;
        protected getCorrectionFontSize(axisRect: Rectangle, titleRect: Rectangle, currentFontSize: number): number;
        protected checkUseMaxWidth(axisRect: Rectangle, titleRect: Rectangle, RefMaxWidth: any): boolean;
        static defaultScrollBarSize: number;
        static defaultScrollBarSmallFactor: number;
        static defaultScrollBarFirstRecallTime: number;
        static defaultScrollBarOtherRecallTime: number;
        get ticksMaxLength(): number;
        get arrowWidth(): number;
        get arrowHeight(): number;
        private _axis;
        get axis(): IStiAxis;
        set axis(value: IStiAxis);
        get info(): StiAxisInfoXF;
        set info(value: StiAxisInfoXF);
        constructor(axis: IStiAxis);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisInfoXF implements ICloneable, IStiAxisInfoXF {
        private static implementsStiAxisInfoXF;
        implements(): any[];
        clone(): StiAxisInfoXF;
        dpi: number;
        step: number;
        get range(): number;
        stripLines: StiStripLinesXF;
        stripPositions: number[];
        ticksCollection: StiStripPositionXF[];
        labelsCollection: StiStripPositionXF[];
        minimum: number;
        _maximum: number;
        get maximum(): number;
        set maximum(value: number);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiAxisLabelInfoXF {
        clientRectangle: RectangleD;
        textPoint: PointD;
        angle: number;
        rotationMode: StiRotationMode;
        text: string;
        stripLine: StiStripLineXF;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisLabelsCoreXF implements IStiApplyStyle, ICloneable, IStiAxisLabelsCoreXF {
        private static implementsStiAxisLabelsCoreXF;
        implements(): any[];
        clone(): StiAxisLabelsCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private _labels;
        get labels(): IStiAxisLabels;
        set labels(value: IStiAxisLabels);
        constructor(labels: IStiAxisLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisTitleCoreXF implements IStiApplyStyle, ICloneable, IStiAxisTitleCoreXF {
        private static implementsStiAxisTitleCoreXF;
        implements(): any[];
        clone(): StiAxisTitleCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private _title;
        get title(): IStiAxisTitle;
        set title(value: IStiAxisTitle);
        constructor(title: IStiAxisTitle);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiXAxisCoreXF extends StiAxisCoreXF {
        getStartFromZero(): boolean;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderView(context: StiContext, rect: RectangleD): StiCellGeom;
        renderScrollBar(context: StiContext, axisRect: RectangleD, axisGeom: StiXAxisViewGeom): void;
        renderCenter(context: StiContext, rect: RectangleD): StiCellGeom;
        renderCenterView(context: StiContext, rect: RectangleD): StiCellGeom;
        getLabelText(line: StiStripLineXF, series: IStiSeries): string;
        getLabelText2(objectValue: any, value: number, series: IStiSeries): string;
        private get isLabelsAngleByWidth();
        private checkAutoAngleLabels;
        private measureStripLines;
        getCenterAxisRect(context: StiContext, rect: RectangleD, includeAxisArrow: boolean, includeLabelsHeight: boolean, isDrawing: boolean): RectangleD;
        getAxisRect(context: StiContext, rect: RectangleD, includeAxisArrow: boolean, includeLabelsWidth: boolean, isDrawing: boolean, includeScrollBar: boolean): RectangleD;
        private renderLabels;
        private renderTitle;
        private isArgumentDateTime1;
        private isArgumentDateTime2;
        get dock(): StiXAxisDock;
        get isTopSide(): boolean;
        get isBottomSide(): boolean;
        constructor(axis: IStiAxis);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiXBottomAxisCoreXF extends StiXAxisCoreXF {
        get dock(): StiXAxisDock;
        constructor(axis: IStiAxis);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiXTopAxisCoreXF extends StiXAxisCoreXF {
        get dock(): StiXAxisDock;
        constructor(axis: IStiAxis);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiYAxisCoreXF extends StiAxisCoreXF {
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderView(context: StiContext, rect: RectangleD): StiCellGeom;
        renderScrollBar(context: StiContext, axisRect: RectangleD, axisGeom: StiYAxisViewGeom): void;
        renderCenter(context: StiContext, rect: RectangleD): StiCellGeom;
        renderCenterView(context: StiContext, rect: RectangleD): StiCellGeom;
        setTotalNumberCapacity(): void;
        getLabelText(line: StiStripLineXF, series: IStiSeries): string;
        private measureStripLines;
        getCenterAxisRect(context: StiContext, rect: RectangleD, includeAxisArrow: boolean, includeLabelsHeight: boolean, isDrawing: boolean): RectangleD;
        getAxisRect(context: StiContext, rect: RectangleD, includeAxisArrow: boolean, includeLabelsHeight: boolean, isDrawing: boolean, includeScrollBar: boolean): RectangleD;
        private renderLabels;
        private renderTitle;
        get dock(): StiYAxisDock;
        get isLeftSide(): boolean;
        get isRightSide(): boolean;
        constructor(axis: IStiAxis);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiYLeftAxisCoreXF extends StiYAxisCoreXF {
        get dock(): StiYAxisDock;
        constructor(axis: IStiAxis);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiYRightAxisCoreXF extends StiYAxisCoreXF {
        get dock(): StiYAxisDock;
        getStartFromZero(): boolean;
        constructor(axis: IStiAxis);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStripLineCalculatorXF {
        private static getInterval1;
        static getInterval(minValue: number, maxValue: number, num: number): number;
        static getStripLines(minValue: number, maxValue: number, step: number, asDateTimeValue: boolean): StiStripLinesXF;
        private static getCountAfterComma;
        static getStripLinesLogScale(minValue: number, maxValue: number): StiStripLinesXF;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStripLineXF implements ICloneable, IStiStripLineXF {
        private static implementsStiStripLineXF;
        implements(): any[];
        clone(): StiStripLineXF;
        private _valueObject;
        get valueObject(): any;
        set valueObject(value: any);
        private valueObj;
        get value(): number;
        set value(value: number);
        constructor(valueObject: any, value: number);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiStripLinesXF extends CollectionBase<StiStripLineXF> implements ICloneable, IStiStripLinesXF {
        private static implementsStiStripLinesXF;
        implements(): any[];
        clone(): StiStripLinesXF;
        add2(valueObject: any, value: number): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStripPositionXF implements IStiStripPositionXF {
        private static implementsStiStripPositionXF;
        implements(): any[];
        position: number;
        stripLine: StiStripLineXF;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import ICloneable = Stimulsoft.System.ICloneable;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiChartTitleCoreXF implements ICloneable, IStiApplyStyle, IStiChartTitleCoreXF {
        private static implementsStiChartTitleCoreXF;
        implements(): any[];
        clone(): StiChartTitleCoreXF;
        applyStyle(style: IStiChartStyle): void;
        render(context: StiContext, chartTitle: IStiChartTitle, rect: RectangleD): StiCellGeom;
        private _chartTitle;
        get chartTitle(): IStiChartTitle;
        set chartTitle(value: IStiChartTitle);
        constructor(chartTitle: IStiChartTitle);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiConstantLinesCoreXF implements IStiApplyStyle, ICloneable, IStiConstantLinesCoreXF {
        private static implementsStiConstantLinesCoreXF;
        implements(): any[];
        clone(): any;
        applyStyle(style: IStiChartStyle): void;
        renderXConstantLines(geom: StiAxisAreaGeom, rect: RectangleD): void;
        renderYConstantLines(geom: StiAxisAreaGeom, rect: RectangleD): void;
        render(context: StiContext, geom: StiAxisAreaGeom, rect: RectangleD): void;
        private _constantLines;
        get constantLines(): IStiConstantLines;
        set constantLines(value: IStiConstantLines);
        constructor(constantLines: IStiConstantLines);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiGridLinesCoreXF implements IStiApplyStyle, ICloneable, IStiGridLinesCoreXF {
        private static implementsStiGridLinesCoreXF;
        implements(): any[];
        clone(): StiGridLinesCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private _gridLines;
        get gridLines(): IStiGridLines;
        set gridLines(value: IStiGridLines);
        constructor(gridLines: IStiGridLines);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarGridLinesCoreXF implements IStiApplyStyle, ICloneable, IStiRadarGridLinesCoreXF {
        private static implementsStiRadarGridLinesCoreXF;
        implements(): any[];
        clone(): StiRadarGridLinesCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private _gridLines;
        get gridLines(): IStiRadarGridLines;
        set gridLines(value: IStiRadarGridLines);
        constructor(gridLines: IStiRadarGridLines);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiInterlacingCoreXF implements IStiApplyStyle, ICloneable, IStiInterlacingCoreXF {
        private static implementsStiInterlacingCoreXF;
        implements(): any[];
        clone(): StiInterlacingCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private _interlacing;
        get interlacing(): IStiInterlacing;
        set interlacing(value: IStiInterlacing);
        constructor(interlacing: IStiInterlacing);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import RectangleF = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiLegendCoreXF implements ICloneable, IStiApplyStyle, IStiLegendCoreXF {
        private static implementsStiLegendCoreXF;
        implements(): any[];
        applyStyle(style: IStiChartStyle): void;
        clone(): StiLegendCoreXF;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        getMatrixIndexItem(countColumns: number, countRows: number, countItems: number): number[][];
        getArgumentText(series: IStiSeries, index: number): string;
        getLegendItemColumn(seriesItems: StiLegendItemCoreXF[], seriesItem: StiLegendItemCoreXF): number;
        getTitleSize(context: StiContext): SizeD;
        getItemSize1(context: StiContext, seriesItems: StiLegendItemCoreXF[], seriesIndex: number): SizeD;
        getItemSize2(context: StiContext, seriesItems: StiLegendItemCoreXF[], seriesItem: StiLegendItemCoreXF): SizeD;
        getItemRealSize(context: StiContext, seriesItem: StiLegendItemCoreXF): SizeD;
        getItemsSize(context: StiContext, seriesItems: StiLegendItemCoreXF[]): SizeD;
        getItemsAutoSize(context: StiContext, seriesItems: StiLegendItemCoreXF[], rect: RectangleF, countColumns: any, countRows: any): SizeD;
        getSeriesSize(context: StiContext, rect: RectangleF, countColumns: any, countRows: any): SizeD;
        getLegendSize(context: StiContext, rect: RectangleF, countColumns: any, countRows: any): SizeD;
        getLegendItems(REFcount: any): StiLegendItemCoreXF[];
        private _legend;
        get legend(): IStiLegend;
        set legend(value: IStiLegend);
        constructor(legend: IStiLegend);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiLegendItemCoreXF {
        private _text;
        get text(): string;
        private _series;
        get series(): IStiSeries;
        private _index;
        get index(): number;
        private _colorIndex;
        get colorIndex(): number;
        constructor(text: string, series: IStiSeries, index: number, colorIndex: number);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiMarkerCoreXF implements ICloneable, IStiMarkerCoreXF {
        private static implementsStiMarkerCoreXF;
        implements(): any[];
        clone(): StiMarkerCoreXF;
        drawMarkers(context: StiContext, points: PointD[], showShadow: boolean): void;
        static getMarkerRect(position: PointD, markerSize: number, zoom: number): RectangleD;
        draw(context: StiContext, marker: IStiMarker, position: PointD, zoom: number, showShadow: boolean, isMouseOver: boolean, isTooltipMode: boolean, isAnimation: boolean, toolTip: string, tag: any, interaction: StiInteractionDataGeom): void;
        drawLine(context: StiContext, x1: number, y1: number, x2: number, y2: number, scale: number, brushMarker: StiBrush, penMarker: StiPenGeom, markerType: StiMarkerType, markerStep: number, markerSize: number, angle: number): void;
        drawLines(context: StiContext, points: PointD[], scale: number, brushMarker: any, penMarker: StiPenGeom, markerType: StiMarkerType, markerStep: number, markerSize: number, angle: number): void;
        drawPoint(context: StiContext, x: number, y: number, scale: number, brush: any, pen: StiPenGeom, markerType: StiMarkerType, icon: StiFontIcons, markerSize: number, angle: number, isMouseOver: boolean, isAnimation: boolean, toolTip: string, tag: any, interaction: StiInteractionDataGeom): void;
        private drawPolygon;
        marker: IStiMarker;
        constructor(marker: IStiMarker);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarAxisCoreXF implements ICloneable, IStiApplyStyle, IStiRadarAxisCoreXF {
        private static implementsStiRadarAxisCoreXF;
        implements(): any[];
        clone(): StiRadarAxisCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private _axis;
        get axis(): IStiRadarAxis;
        set axis(value: IStiRadarAxis);
        constructor(axis: IStiRadarAxis);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarAxisLabelsCoreXF implements IStiApplyStyle, ICloneable, IStiRadarAxisLabelsCoreXF {
        private static implementsStiRadarAxisLabelsCoreXF;
        implements(): any[];
        clone(): StiRadarAxisLabelsCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private _labels;
        get labels(): IStiRadarAxisLabels;
        set labels(value: IStiRadarAxisLabels);
        constructor(labels: IStiRadarAxisLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiXRadarAxisCoreXF extends StiRadarAxisCoreXF implements IStiXRadarAxisCoreXF {
        private static implementsStiXRadarAxisCoreXF;
        implements(): any[];
        applyStyle(style: IStiChartStyle): void;
        renderLabel(context: StiContext, series: IStiSeries, point: PointD, argument: any, angle: number, colorIndex: number, colorCount: number): StiXRadarAxisLabelGeom;
        getLabelText(value: any): string;
        getLabelRect(context: StiContext, point: PointD, text: string, angle: number): RectangleD;
        get xAxis(): IStiXRadarAxis;
        constructor(axis: IStiRadarAxis);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiYRadarAxisCoreXF extends StiRadarAxisCoreXF implements IStiYRadarAxisCoreXF {
        private static implementsStiYRadarAxisCoreXF;
        implements(): any[];
        applyStyle(style: IStiChartStyle): void;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        private measureStripLines;
        private renderLabels;
        calculateStripPositions(topPosition: number, bottomPosition: number): void;
        getAxisRect(context: StiContext, rect: RectangleD): RectangleD;
        getTicksMaxLength(context: StiContext): number;
        getLabelsSpaceAxis(context: StiContext): number;
        getLabelsTwoLinesDestination(context: StiContext): number;
        getTextAlignment(): StiHorAlignment;
        setTotalNumberCapacity(): void;
        getLabelText(line: StiStripLineXF): string;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        getFontGeom(context: StiContext): StiFontGeom;
        get yAxis(): IStiYRadarAxis;
        get info(): StiAxisInfoXF;
        set info(value: StiAxisInfoXF);
        get ticksMaxLength(): number;
        constructor(axis: IStiRadarAxis);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSeriesCoreXF implements ICloneable, IStiApplyStyleSeries, IStiSeriesCoreXF, IAsIs {
        private static implementsStiSeriesCoreXF;
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        clone(): StiSeriesCoreXF;
        applyStyle(style: IStiChartStyle, color: Color): void;
        checkLabelsRect(labels: IStiSeriesLabels, geom: StiAreaGeom, labelsRect: RectangleD): RectangleD;
        checkLabelsRect2(labels: IStiSeriesLabels, rect: RectangleD, labelsRect: RectangleD): RectangleD;
        private GetDrawRectangle;
        private rotatePoint;
        checkIntersectionLabels(geom: StiAreaGeom): void;
        private getLabelRectangle;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        getSeriesLabels(): IStiAxisSeriesLabels;
        getTag(tagIndex: number): string;
        private static falseObject;
        private static trueObject;
        private isMouseOverSeriesElementHashtable;
        getIsMouseOverSeriesElement(seriesIndex: number): boolean;
        setIsMouseOverSeriesElement(seriesIndex: number, value: boolean): void;
        private _isMouseOver;
        get isMouseOver(): boolean;
        set isMouseOver(value: boolean);
        get localizedName(): string;
        seriesColors: Color[];
        private _isDateTimeValues;
        get isDateTimeValues(): boolean;
        set isDateTimeValues(value: boolean);
        private _isDateTimeArguments;
        get isDateTimeArguments(): boolean;
        set isDateTimeArguments(value: boolean);
        private _series;
        get series(): IStiSeries;
        set series(value: IStiSeries);
        get interaction(): IStiSeriesInteraction;
        set interaction(value: IStiSeriesInteraction);
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBoxAndWhiskerSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: Rectangle, geom: StiAreaGeom, series: IStiSeries[]): void;
        private getFirstValues;
        private getSecondValues;
        private getThirdQuartile;
        private getFirstQuartile;
        private getMedian;
        private getMedianIndices;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
    class StiBaseLineSeriesCoreXF extends StiSeriesCoreXF implements IStiApplyStyleSeries {
        private static implementsStiBaseLineSeriesCoreXF;
        implements(): any[];
        applyStyle(style: IStiChartStyle, color: Color): void;
        protected clipLinePoints(context: StiContext, geom: StiAreaGeom, points: PointD[], REFstartIndex: any, REFendIndex: any): PointD[];
        renderMarkers(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        getInteractions(context: StiContext, geom: StiAreaGeom, points: PointD[]): StiSeriesInteractionData[];
        renderLines(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private getPointsZeroConnect;
        private getPointsNullConnect;
        private getPointConnect;
        private getPointValue2;
        private getPointValue;
        private getPointValue1;
        private isTopmostLine;
        correctPoint(point: PointD, rect: RectangleD, correctY: number): PointD;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiScatterSeriesCoreXF extends StiBaseLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderLines(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBubbleSeriesCoreXF extends StiScatterSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderLines(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        renderBubbles(context: StiContext, geom: StiAreaGeom, series: IStiBubbleSeries, points: PointD[], weights: number[]): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiClusteredColumnSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        protected correctPoint(point: PointD, rect: RectangleD): PointD;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiClusteredBarSeriesCoreXF extends StiClusteredColumnSeriesCoreXF implements IStiApplyStyleSeries {
        private static implementsStiClusteredBarSeriesCoreXF;
        implements(): any[];
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private getBarRect;
        protected correctPoint(point: PointD, rect: RectangleD): PointD;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiLineSeriesCoreXF extends StiBaseLineSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiAreaSeriesCoreXF extends StiLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiHistogramSeriesCoreXF extends StiClusteredColumnSeriesCoreXF {
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiParetoSeriesCoreXF extends StiClusteredColumnSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        private getParetoValues;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        renderColumns(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private renderLinePareto;
        renderLines(geom: StiAreaGeom, points: PointD[], series: IStiSeries): void;
        private getPointValue;
        protected correctPoint(point: PointD, rect: RectangleD): PointD;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiSplineSeriesCoreXF extends StiBaseLineSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSplineAreaSeriesCoreXF extends StiSplineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiSteppedLineSeriesCoreXF extends StiBaseLineSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSteppedAreaSeriesCoreXF extends StiSteppedLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import PointF = Stimulsoft.System.Drawing.Point;
    class StiWaterfallSeriesCoreXF extends StiClusteredColumnSeriesCoreXF {
        renderSeries(context: StiContext, rect: Rectangle, geom: StiAreaGeom, series: IStiSeries[]): void;
        private getSumSeriesWidth;
        private getDividerYSeries;
        private renderColumns;
        protected getPointEnd(currentSeries: IStiClusteredColumnSeries, value: number, seriesLeftPos: number, seriesWidth: number, posY: number): PointF;
        protected getColumnRect(context: StiContext, currentSeries: IStiClusteredColumnSeries, value: number, seriesLeftPos: number, seriesWidth: number, REFposY: any): Rectangle;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        private correctBrush;
        private renderPieElement;
        private renderPieElementShadow;
        private measurePieElement;
        private measurePieElementCore;
        isNotNullValues(seriesArray: IStiSeries[]): boolean;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        private checkIntersectionTwoColumnsLabels;
        private checkLabelPosition;
        protected getGradPerValue(series: IStiSeries[]): number;
        getPercentPerValue(series: IStiSeries[]): number;
        getPointCenter(rect: RectangleD): PointD;
        getRadius(context: StiContext, rect: RectangleD): number;
        getPoint(centerPie: PointD, radius: number, angle: number): PointD;
        protected getArgumentText(series: IStiSeries, index: number): string;
        getPieDistance(pieIndex: number): number;
        getPieDistance2(series: IStiPieSeries, pieIndex: number): number;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDoughnutSeriesCoreXF extends StiPieSeriesCoreXF {
        private renderDoughnutElement;
        isNotNullValues(seriesArray: IStiSeries[]): boolean;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        private checkNonZerovalue;
        protected getGradPerValue(series: IStiSeries[]): number;
        getPercentPerValue(series: IStiSeries[]): number;
        protected getArgumentText(series: IStiSeries, index: number): string;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCandlestickSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStockSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedBarSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private calculateTotalWidth;
        private correctRect;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiFullStackedBarSeriesCoreXF extends StiStackedBarSeriesCoreXF {
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiStackedBaseLineSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        clipLinePoints(context: StiContext, geom: StiAreaGeom, startPoints: PointD[], endPoints: PointD[], REFnewStartPoints: any, REFnewEndPoints: any, REFstartIndex: any, REFendIndex: any): void;
        renderMarkers(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, startPoints: PointD[], endPoints: PointD[]): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private calculateTotalHeight;
        private correctPoint;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        get isFullStacked(): boolean;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiStackedLineSeriesCoreXF extends StiStackedBaseLineSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedAreaSeriesCoreXF extends StiStackedLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, startPoints: PointD[], endPoints: PointD[]): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiFullStackedAreaSeriesCoreXF extends StiStackedAreaSeriesCoreXF {
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedColumnSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private calculateTotalHeight;
        private correctRect;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiFullStackedColumnSeriesCoreXF extends StiStackedColumnSeriesCoreXF {
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiFullStackedLineSeriesCoreXF extends StiStackedLineSeriesCoreXF {
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiStackedSplineSeriesCoreXF extends StiStackedBaseLineSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedSplineAreaSeriesCoreXF extends StiStackedSplineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, startPoints: PointD[], endPoints: PointD[]): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiFullStackedSplineAreaSeriesCoreXF extends StiStackedSplineAreaSeriesCoreXF {
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiFullStackedSplineSeriesCoreXF extends StiStackedSplineSeriesCoreXF {
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiFunnelSeriesCoreXF extends StiSeriesCoreXF {
        private labels;
        applyStyle(style: IStiChartStyle, color: Color): void;
        isNotNullValues(seriesArray: IStiSeries[]): boolean;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        private checkNonZerovalue;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getCurrentValue(funnelSeries: IStiFunnelSeries, index: number, values: number[]): number;
        getNextCurrentValue(funnelSeries: IStiFunnelSeries, index: number, values: number[]): number;
        getAllValues(funnelSeries: IStiFunnelSeries[]): number[];
        getAllTrueValues(funnelSeries: IStiFunnelSeries[]): number[];
        private getValues;
        private getArgumentText;
        private renderFunnelEmpty;
        private renderFunnelElement;
        private getSingleValueHeight;
        private getSingleValueWidth;
        private measureFunnelElementCore;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiFunnelWeightedSlicesSeriesCoreXF extends StiSeriesCoreXF {
        private labels;
        applyStyle(style: IStiChartStyle, color: Color): void;
        isNotNullValues(seriesArray: IStiSeries[]): boolean;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        private checkNonZerovalue;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getAllValues(funnelSeries: IStiFunnelSeries[]): number[];
        getAllTrueValues(funnelSeries: IStiFunnelSeries[]): number[];
        private getValues;
        private getArgumentText;
        private renderFunnelEmpty;
        private getPathFunnelEmpty;
        private renderFunnelElement;
        private getSumValues;
        private getSumLastValues;
        private measureFunnelElementCore;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiGanttSeriesCoreXF extends StiClusteredBarSeriesCoreXF {
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class DataPictorial {
        value: number;
        series: StiPictorialSeries;
        index: number;
        constructor(value: number, series: StiPictorialSeries, index: number);
    }
    class StiPictorialSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        get localizedName(): string;
        private singleSizeConst;
        getSingleSize(context: StiContext): SizeD;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        roundPictirialValue(currentFactorValue: number, deltaValue: number): number;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRadarSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        renderAreas(context: StiContext, series: IStiRadarSeries, points: PointD[], geom: StiAreaGeom): void;
        renderLines(context: StiContext, series: IStiRadarSeries, points: PointD[], geom: StiAreaGeom): void;
        renderPoints(context: StiContext, series: IStiRadarSeries, points: PointD[], geom: StiAreaGeom): void;
        private getArgument;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarAreaSeriesCoreXF extends StiRadarSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        get localizedName(): string;
        renderLines(context: StiContext, series: IStiRadarSeries, points: PointD[], geom: StiAreaGeom): void;
        renderAreas(context: StiContext, series: IStiRadarSeries, points: PointD[], geom: StiAreaGeom): void;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarLineSeriesCoreXF extends StiRadarSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        get localizedName(): string;
        renderLines(context: StiContext, series: IStiRadarSeries, points: PointD[], geom: StiAreaGeom): void;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarPointSeriesCoreXF extends StiRadarSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRangeBarSeriesCoreXF extends StiClusteredColumnSeriesCoreXF {
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRangeSeriesCoreXF extends StiLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private renderLines2;
        private renderMarkers2;
        private getYPoint;
        private renderAreas2;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSplineRangeSeriesCoreXF extends StiSplineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private renderLines2;
        private renderMarkers2;
        private getYPoint;
        private renderAreas2;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSteppedRangeSeriesCoreXF extends StiSteppedLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private renderAreas2;
        private renderLines2;
        private renderMarkers2;
        private getYPoint;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiScatterLineSeriesCoreXF extends StiScatterSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiScatterSplineSeriesCoreXF extends StiScatterSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, pointsInfo: StiSeriesPointsInfo): void;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import PointF = Stimulsoft.System.Drawing.Point;
    class StiSunburstSeriesCoreXF extends StiSeriesCoreXF {
        renderSeries(context: StiContext, rect: Rectangle, geom: StiAreaGeom, seriesCollection: IStiSeries[]): void;
        private renderComputeSeries;
        private renderLevelSeries;
        private renderLevelSeriesLebels;
        private renderSunburstElement;
        protected getPoint(centerPie: PointF, radius: number, angle: number): PointF;
        private getDataTable;
        private getCountRow;
        private getGradPerValue;
        protected getRadius(context: StiContext, rect: Rectangle): number;
        protected getPointCenter(rect: Rectangle): PointF;
        private getSumColumn;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTreemapSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        getArgumentText(series: IStiSeries, index: number): string;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Color;
        get localizedName(): string;
        constructor(series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSeriesLabelsCoreXF implements ICloneable, IStiApplyStyle, IStiSeriesLabelsCoreXF, IAsIs {
        private static implementsStiSeriesLabelsCoreXF;
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        clone(): StiSeriesLabelsCoreXF;
        applyStyle(style: IStiChartStyle): void;
        get position(): number;
        get seriesLabelsType(): StiSeriesLabelsType;
        private _seriesLabels;
        get seriesLabels(): IStiSeriesLabels;
        set seriesLabels(value: IStiSeriesLabels);
        get localizedName(): string;
        processSeriesColors(pointIndex: number, brush: StiBrush, series: IStiSeries): StiBrush;
        getSeriesLabelColor(series: IStiSeries, colorIndex: number, colorCount: number): Color;
        getBorderColor(series: IStiSeries, colorIndex: number, colorCount: number): Color;
        getLabelColor(series: IStiSeries, colorIndex: number, colorCount: number): Color;
        recalcValue(value: number, signs: number): number;
        getLabelText(series: IStiSeries, value: number, argument: string, tag: string, seriesName: string, useLegendValueType?: boolean): string;
        getLabelText2(series: IStiSeries, value: number, argument: string, tag: string, seriesName: string, weight: number, useLegendValueType: boolean): string;
        private getArgument;
        private getFormatted;
        getFormattedValue(series: IStiSeries, value: number): string;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiNoneLabelsCoreXF extends StiSeriesLabelsCoreXF {
        get seriesLabelsType(): StiSeriesLabelsType;
        get position(): number;
        get localizedName(): string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiAxisSeriesLabelsCoreXF extends StiSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, endPoint: PointD, startPoint: PointD, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, animation?: StiAnimation): StiSeriesLabelsGeom;
        renderLabel2(series: IStiSeries, context: StiContext, endPoint: PointD, startPoint: PointD, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, weight: number, colorIndex: number, colorCount: number, rect: RectangleD, animation?: StiAnimation): StiSeriesLabelsGeom;
        recalcValue(value: number, signs: number): number;
        get seriesLabelsType(): StiSeriesLabelsType;
        currentIndex: number;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterAxisLabelsCoreXF extends StiAxisSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, endPoint: PointD, startPoint: PointD, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, animation?: StiAnimation): StiSeriesLabelsGeom;
        renderLabel2(series: IStiSeries, context: StiContext, endPoint: PointD, startPoint: PointD, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, weight: number, colorIndex: number, colorCount: number, rect: RectangleD, animation?: StiAnimation): StiSeriesLabelsGeom;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        get position(): number;
        get localizedName(): string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiInsideBaseAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        get localizedName(): string;
        get position(): number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiInsideEndAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        get position(): number;
        get localizedName(): string;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiLeftAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        get localizedName(): string;
        get position(): number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiOutsideAxisLabelsCoreXF extends StiAxisSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, endPoint: PointD, startPoint: PointD, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD): StiSeriesLabelsGeom;
        get position(): number;
        get localizedName(): string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiOutsideBaseAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        get localizedName(): string;
        get position(): number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiOutsideEndAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        get localizedName(): string;
        get position(): number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiRightAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        get localizedName(): string;
        get position(): number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiValueAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        get localizedName(): string;
        get position(): number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiFunnelSeriesLabelsCoreXF extends StiSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, valueNext: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, singleValueHeight: number, singleValueWidth: number, centerAxis: number, REFmeasureRect: any): StiSeriesLabelsGeom;
        get seriesLabelsType(): StiSeriesLabelsType;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCenterFunnelLabelsCoreXF extends StiFunnelSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, valueNext: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, singleValueHeight: number, singleValueWidth: number, centerAxis: number, REFmeasureRect: any): StiSeriesLabelsGeom;
        private getSumLastValues;
        get seriesLabelsType(): StiSeriesLabelsType;
        get position(): number;
        get localizedName(): string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsideLeftFunnelLabelsCoreXF extends StiFunnelSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, valueNext: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, singleValueHeight: number, singleValueWidth: number, centerAxis: number, REFmeasureRect: any): StiSeriesLabelsGeom;
        get seriesLabelsType(): StiSeriesLabelsType;
        get position(): number;
        get localizedName(): string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsideRightFunnelLabelsCoreXF extends StiFunnelSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, valueNext: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, singleValueHeight: number, singleValueWidth: number, centerAxis: number, REFmeasureRect: any): StiSeriesLabelsGeom;
        get seriesLabelsType(): StiSeriesLabelsType;
        get position(): number;
        get localizedName(): string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiPieSeriesLabelsCoreXF extends StiSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, centerPie: PointD, radius: number, radius2: number, pieAngle: number, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, measure: boolean, colorIndex: number, colorCount: number, percentPerValue: number, REFmeasureRect: any, drawValue: boolean, deltaY: number): StiSeriesLabelsGeom;
        recalcValue(value: number, signs: number): number;
        get seriesLabelsType(): StiSeriesLabelsType;
        percentPerValue: number;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiCenterPieLabelsCoreXF extends StiPieSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, centerPie: PointD, radius: number, radius2: number, pieAngle: number, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, measure: boolean, colorIndex: number, colorCount: number, percentPerValue: number, REFmeasureRect: any, drawValue: boolean, deltaY: number): StiSeriesLabelsGeom;
        getLabelPoint(centerPie: PointD, radius: number, angleRad: number): PointD;
        getLabelRect(context: StiContext, labelPoint: PointD, labelText: string, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        get seriesLabelsType(): StiSeriesLabelsType;
        get position(): number;
        get localizedName(): string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiInsideEndPieLabelsCoreXF extends StiCenterPieLabelsCoreXF {
        get localizedName(): string;
        get position(): number;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiOutsidePieLabelsCoreXF extends StiCenterPieLabelsCoreXF {
        applyStyle(style: IStiChartStyle): void;
        get position(): number;
        get localizedName(): string;
        getLineColor(series: IStiSeries, colorIndex: number, colorCount: number): Color;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTwoColumnsPieLabelsCoreXF extends StiOutsidePieLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, centerPie: PointD, radius: number, radius2: number, pieAngle: number, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, measure: boolean, colorIndex: number, colorCount: number, percentPerValue: number, REFmeasureRect: any, drawValue: boolean, deltaY: number): StiSeriesLabelsGeom;
        get seriesLabelsType(): StiSeriesLabelsType;
        get position(): number;
        get localizedName(): string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterTreemapLabelsCoreXF extends StiSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, animation?: StiAnimation): StiSeriesLabelsGeom;
        getLabelRect(context: StiContext, rect: RectangleD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        get position(): number;
        get localizedName(): string;
        get seriesLabelsType(): StiSeriesLabelsType;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStripsCoreXF implements IStiApplyStyle, ICloneable, IStiStripsCoreXF {
        private static implementsStiStripsCoreXF;
        implements(): any[];
        clone(): any;
        applyStyle(style: IStiChartStyle): void;
        renderXStrips(context: StiContext, geom: StiAxisAreaGeom, rect: RectangleD): void;
        private calculateXValue;
        renderYStrips(context: StiContext, geom: StiAxisAreaGeom, rect: RectangleD): void;
        private calculateYValue;
        render(context: StiContext, geom: StiAxisAreaGeom, rect: RectangleD): void;
        private _strips;
        get strips(): IStiStrips;
        set strips(value: IStiStrips);
        constructor(strips: IStiStrips);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    class StiStyleCoreXF implements IStiStyleCoreXF {
        private static implementsStiStyleCoreXF;
        implements(): any[];
        get localizedName(): string;
        get styleId(): StiChartStyleId;
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get chartAreaBorderColor(): Color;
        private _chart;
        get chart(): IStiChart;
        set chart(value: IStiChart);
        get chartAreaShowShadow(): boolean;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsLineColor(): Color;
        get seriesLabelsFont(): Font;
        get trendLineColor(): Color;
        get trendLineShowShadow(): boolean;
        get legendBrush(): StiBrush;
        get legendLabelsColor(): Color;
        get legendBorderColor(): Color;
        get legendTitleColor(): Color;
        get legendShowShadow(): boolean;
        get legendFont(): Font;
        get axisTitleColor(): Color;
        get axisLineColor(): Color;
        get axisLabelsColor(): Color;
        get interlacingHorBrush(): StiBrush;
        get interlacingVertBrush(): StiBrush;
        get gridLinesHorColor(): Color;
        get gridLinesVertColor(): Color;
        get seriesLighting(): boolean;
        get seriesShowShadow(): boolean;
        get seriesShowBorder(): boolean;
        private _markerVisible;
        get markerVisible(): boolean;
        set markerVisible(value: boolean);
        get firstStyleColor(): Color;
        get lastStyleColor(): Color;
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        fillColumn(context: StiContext, rect: RectangleD, brush: StiBrush, interaction: StiInteractionDataGeom): void;
        getAreaBrush(color: Color): StiBrush;
        getColumnBrush(color: Color): StiBrush;
        getColumnBorder(color: Color): Color;
        getColors(seriesCount: number, seriesColors: Color[]): Color[];
        getColorByIndex(index: number, count: number, seriesColors: Color[]): Color;
        getColorBySeries(series: IStiSeries, seriesColors: Color[]): Color;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF01 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCustomStyleCoreXF extends StiStyleCoreXF01 {
        private _base;
        get localizedName(): string;
        reportChartStyle: Stimulsoft.Report.Styles.StiChartStyle;
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get chartAreaBorderColor(): Color;
        get chartAreaShowShadow(): boolean;
        get seriesLighting(): boolean;
        get seriesShowShadow(): boolean;
        get seriesShowBorder(): boolean;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsLineColor(): Color;
        get trendLineColor(): Color;
        get trendLineShowShadow(): boolean;
        get legendBrush(): StiBrush;
        get legendLabelsColor(): Color;
        get legendBorderColor(): Color;
        get legendTitleColor(): Color;
        get markerVisible(): boolean;
        set markerVisible(value: boolean);
        get axisTitleColor(): Color;
        get axisLineColor(): Color;
        get axisLabelsColor(): Color;
        get interlacingHorBrush(): StiBrush;
        get interlacingVertBrush(): StiBrush;
        get gridLinesHorColor(): Color;
        get gridLinesVertColor(): Color;
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        private _reportStyleName;
        get reportStyleName(): string;
        set reportStyleName(value: string);
        get reportStyle(): Stimulsoft.Report.Styles.StiChartStyle;
        private _customStyle;
        get customStyle(): StiCustomStyle;
        getColumnBrush(color: Color): StiBrush;
        constructor(customStyle: StiCustomStyle);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF02 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get basicStyleColor(): Color;
        get styleColors(): Color[];
        get styleId(): StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF03 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF04 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get basicStyleColor(): Color;
        get styleColors(): Color[];
        get styleId(): StiChartStyleId;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF05 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF06 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF07 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF08 extends StiStyleCoreXF03 {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF09 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF10 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF11 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF12 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF13 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF14 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF15 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF16 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF17 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    class StiStyleCoreXF18 extends StiStyleCoreXF {
        get localizedName(): string;
        fillColumn(context: StiContext, rect: RectangleD, brush: StiBrush, interaction: StiInteractionDataGeom): void;
        getColumnBrush(color: Color): StiBrush;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF19 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get interlacingHorBrush(): StiBrush;
        get interlacingVertBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get chartBrush(): StiBrush;
        get styleId(): StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF20 extends StiStyleCoreXF {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get axisLineColor(): Color;
        get chartAreaBorderColor(): Color;
        get styleId(): StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF21 extends StiStyleCoreXF {
        get localizedName(): string;
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get chartAreaBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get legendBrush(): StiBrush;
        get legendLabelsColor(): Color;
        get axisTitleColor(): Color;
        get axisLineColor(): Color;
        get axisLabelsColor(): Color;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
        getColumnBorder(color: Color): Color;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF22 extends StiStyleCoreXF {
        get localizedName(): string;
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get chartAreaBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get legendBrush(): StiBrush;
        get legendLabelsColor(): Color;
        get axisTitleColor(): Color;
        get axisLineColor(): Color;
        get axisLabelsColor(): Color;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get styleId(): StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
        getColumnBorder(color: Color): Color;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF23 extends StiStyleCoreXF22 {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get styleId(): StiChartStyleId;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStyleCoreXF24 extends StiStyleCoreXF22 {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get styleId(): StiChartStyleId;
        get chartAreaBorderColor(): Color;
        get legendBorderColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStyleCoreXF25 extends StiStyleCoreXF22 {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get styleId(): StiChartStyleId;
        get chartAreaBorderColor(): Color;
        get legendShowShadow(): boolean;
        get legendBorderColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsFont(): Font;
        get seriesLighting(): boolean;
        get seriesShowShadow(): boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStyleCoreXF26 extends StiStyleCoreXF22 {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get chartAreaBorderColor(): Color;
        get chartAreaBrush(): StiBrush;
        get legendShowShadow(): boolean;
        get legendBorderColor(): Color;
        get seriesLabelsColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsFont(): Font;
        get seriesLighting(): boolean;
        get seriesShowShadow(): boolean;
        get markerVisible(): boolean;
        set markerVisible(value: boolean);
        get styleId(): StiChartStyleId;
        getColumnBorder(color: Color): Color;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStyleCoreXF27 extends StiStyleCoreXF22 {
        get localizedName(): string;
        protected _styleColor: Color[];
        get styleColors(): Color[];
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get chartAreaBorderColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsFont(): Font;
        get legendBrush(): StiBrush;
        get legendLabelsColor(): Color;
        get legendBorderColor(): Color;
        get legendTitleColor(): Color;
        get legendShowShadow(): boolean;
        get legendFont(): Font;
        get seriesLighting(): boolean;
        getColumnBorder(color: Color): Color;
        get styleId(): StiChartStyleId;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStyleCoreXF28 extends StiStyleCoreXF26 {
        get localizedName(): string;
        protected _styleColor: Color[];
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get chartAreaBorderColor(): Color;
        get axisTitleColor(): Color;
        get axisLineColor(): Color;
        get axisLabelsColor(): Color;
        get legendBrush(): StiBrush;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get legendBorderColor(): Color;
        get legendTitleColor(): Color;
        get legendShowShadow(): boolean;
        get legendFont(): Font;
        get styleId(): StiChartStyleId;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStyleCoreXF29 extends StiStyleCoreXF26 {
        get localizedName(): string;
        _styleColor: Color[];
        get styleColors(): Color[];
        get styleId(): StiChartStyleId;
        get chartAreaBorderColor(): Color;
        get legendShowShadow(): boolean;
        get legendBorderColor(): Color;
        get seriesLabelsColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiStyleCoreXF30 extends StiStyleCoreXF22 {
        get localizedName(): string;
        _styleColor: Color[];
        get styleColors(): Color[];
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get chartAreaBorderColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsFont(): Font;
        get legendBrush(): StiBrush;
        get legendLabelsColor(): Color;
        get legendTitleColor(): Color;
        get legendShowShadow(): boolean;
        get legendBorderColor(): Color;
        get legendFont(): Font;
        get seriesLighting(): boolean;
        getColumnBorder(color: Color): Color;
        get styleId(): StiChartStyleId;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiStyleCoreXF31 extends StiStyleCoreXF22 {
        get localizedName(): string;
        _styleColor: Color[];
        get styleColors(): Color[];
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get chartAreaBorderColor(): Color;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsFont(): Font;
        get legendBrush(): StiBrush;
        get legendLabelsColor(): Color;
        get legendTitleColor(): Color;
        get legendShowShadow(): boolean;
        get legendBorderColor(): Color;
        get legendFont(): Font;
        get seriesLighting(): boolean;
        getColumnBorder(color: Color): Color;
        get styleId(): StiChartStyleId;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiStyleCoreXF32 extends StiStyleCoreXF22 {
        get localizedName(): string;
        _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get legendBrush(): StiBrush;
        get legendLabelsColor(): Color;
        get legendBorderColor(): Color;
        get legendTitleColor(): Color;
        get legendShowShadow(): boolean;
        get legendFont(): Font;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsLineColor(): Color;
        get seriesLabelsFont(): Font;
        get axisTitleColor(): Color;
        get axisLineColor(): Color;
        get axisLabelsColor(): Color;
        get gridLinesHorColor(): Color;
        get gridLinesVertColor(): Color;
        get seriesLighting(): boolean;
        get styleId(): StiChartStyleId;
        getColumnBorder(color: Color): Color;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiStyleCoreXF33 extends StiStyleCoreXF {
        get localizedName(): string;
        _styleColor: Color[];
        get styleColors(): Color[];
        get basicStyleColor(): Color;
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get legendBrush(): StiBrush;
        get legendLabelsColor(): Color;
        get legendBorderColor(): Color;
        get legendTitleColor(): Color;
        get legendShowShadow(): boolean;
        get legendFont(): Font;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsLineColor(): Color;
        get seriesLabelsFont(): Font;
        get axisTitleColor(): Color;
        get axisLineColor(): Color;
        get axisLabelsColor(): Color;
        get gridLinesHorColor(): Color;
        get gridLinesVertColor(): Color;
        get seriesLighting(): boolean;
        get styleId(): StiChartStyleId;
        getColumnBorder(color: Color): Color;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiStyleCoreXF34 extends StiStyleCoreXF22 {
        get localizedName(): string;
        _styleColor: Color[];
        get styleColors(): Color[];
        get chartBrush(): StiBrush;
        get chartAreaBrush(): StiBrush;
        get chartAreaBorderColor(): Color;
        get legendBrush(): StiBrush;
        get legendLabelsColor(): Color;
        get legendBorderColor(): Color;
        get legendTitleColor(): Color;
        get legendShowShadow(): boolean;
        get legendFont(): Font;
        get seriesLabelsBorderColor(): Color;
        get seriesLabelsBrush(): StiBrush;
        get seriesLabelsColor(): Color;
        get seriesLabelsFont(): Font;
        get seriesLighting(): boolean;
        get styleId(): StiChartStyleId;
        getColumnBorder(color: Color): Color;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiChartTableCoreXF implements ICloneable, IStiApplyStyle, IStiChartTableCoreXF {
        private static implementsStiChartTableCoreXF;
        implements(): any[];
        applyStyle(style: IStiChartStyle): void;
        clone(): StiChartTableCoreXF;
        private _chartTable;
        get chartTable(): IStiChartTable;
        set chartTable(value: IStiChartTable);
        showTable(): boolean;
        getHeightTable(context: StiContext, widthTable: number): number;
        getHeightHeaderTable(context: StiContext, widthTable: number): number;
        getWidthCellLegend(context: StiContext): number;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        private getMaxCountValues;
        private getArguments;
        getLabelText(objectValue: any, series: IStiSeries): string;
        private getTableValues;
        constructor(table: IStiChartTable);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTrendLineCoreXF implements ICloneable, IStiTrendLineCoreXF {
        private static implementsStiTrendLineCoreXF;
        implements(): any[];
        clone(): StiTrendLineCoreXF;
        get localizedName(): string;
        private _trendLine;
        get trendLine(): IStiTrendLine;
        set trendLine(value: IStiTrendLine);
        renderTrendLine(geom: StiAreaGeom, points: PointD[], posY: number): void;
        sum(values: number[]): number;
        sumSqr(values: number[]): number;
        sumProductions(valuesX: number[], valuesY: number[]): number;
        sumProductionsXLogY(valuesX: number[], valuesY: number[]): number;
        sumLn(values: number[]): number;
        constructor(trendLine: IStiTrendLine);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTrendLineExponentialCoreXF extends StiTrendLineCoreXF {
        get localizedName(): string;
        renderTrendLine(geom: StiAreaGeom, points: PointD[], posY: number): void;
        constructor(trendLine: IStiTrendLine);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTrendLineLinearCoreXF extends StiTrendLineCoreXF {
        get localizedName(): string;
        renderTrendLine(geom: StiAreaGeom, points: PointD[], posY: number): void;
        constructor(trendLine: IStiTrendLine);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTrendLineLogarithmicCoreXF extends StiTrendLineCoreXF {
        get localizedName(): string;
        renderTrendLine(geom: StiAreaGeom, points: PointD[], posY: number): void;
        constructor(trendLine: IStiTrendLine);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiTrendLineNoneCoreXF extends StiTrendLineCoreXF {
        get localizedName(): string;
        constructor(trendLine: IStiTrendLine);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiGeom = Stimulsoft.Base.Context.StiGeom;
    import StiGeomType = Stimulsoft.Base.Context.StiGeomType;
    class StiCellGeom extends StiGeom implements IStiGeomInteraction, IStiCellGeom {
        private static implementsStiCellGeom;
        implements(): any[];
        invokeClick(options: StiInteractionOptions): void;
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeMouseDown(options: StiInteractionOptions): void;
        invokeMouseUp(options: StiInteractionOptions): void;
        invokeDrag(options: StiInteractionOptions): void;
        get invisible(): boolean;
        get type(): StiGeomType;
        private _childGeoms;
        get childGeoms(): StiCellGeom[];
        private _clientRectangle;
        get clientRectangle(): RectangleD;
        set clientRectangle(value: RectangleD);
        dispose(): void;
        contains(x: number, y: number): boolean;
        getGeomAt(parent: StiCellGeom, x: number, y: number): StiCellGeom;
        getSeriesGeoms(): StiCellGeom[];
        getSeriesElementGeoms(): StiCellGeom[];
        getRect(geom: StiGeom): RectangleD;
        createChildGeoms(): void;
        draw(context: StiContext): void;
        drawGeom(context: StiContext): void;
        drawChildGeoms(context: StiContext): void;
        protected allowChildDrawing(cellGeom: StiCellGeom): boolean;
        constructor(clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiChartGeom extends StiCellGeom {
        draw(context: StiContext): void;
        constructor(clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiNullableDrawing {
        static drawLines(context: StiContext, penGeom: StiPenGeom, points: PointD[], isAnimation?: boolean): void;
        static drawCurve(context: StiContext, penGeom: StiPenGeom, points: PointD[], tension: number, isAnimation?: boolean): void;
        static getPointsList(points: PointD[]): PointD[][];
        static getNullablePointsList(points: PointD[]): PointD[][];
        static getPointsList2(points1: PointD[], points2: PointD[], REFlist1: any, REFlist2: any): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAreaGeom extends StiCellGeom {
        private _area;
        get area(): IStiArea;
        draw(context: StiContext): void;
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisAreaGeom extends StiAreaGeom {
        private _view;
        get view(): StiAxisAreaViewGeom;
        private minWidth;
        private drawInterlacingHor;
        private drawInterlacingVer;
        private drawGridLinesHor;
        private drawGridLinesVer;
        protected allowChildDrawing(cellGeom: StiCellGeom): boolean;
        isChildVisibleInView(cellGeom: StiCellGeom): boolean;
        draw(context: StiContext): void;
        constructor(view: StiAxisAreaViewGeom, area: IStiArea, clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisAreaViewGeom extends StiAreaGeom {
        drawGeom(context: StiContext): void;
        drawChildGeoms(context: StiContext): void;
        private drawBorder;
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieAreaGeom extends StiAreaGeom {
        draw(context: StiContext): void;
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDoughnutAreaGeom extends StiPieAreaGeom {
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPictorialAreaGeom extends StiAreaGeom {
        draw(context: StiContext): void;
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRadarAreaGeom extends StiAreaGeom {
        private _valuesCount;
        get valuesCount(): number;
        private drawHor;
        private drawVert;
        private drawBackground;
        draw(context: StiContext): void;
        constructor(area: IStiArea, clientRectangle: RectangleD, valuesCount: number);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiSunburstAreaGeom extends StiPieAreaGeom {
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTreemapAreaGeom extends StiAreaGeom {
        draw(context: StiContext): void;
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisLabelGeom extends StiCellGeom {
        private _rotationMode;
        get rotationMode(): StiRotationMode;
        private _textPoint;
        get textPoint(): PointD;
        private _angle;
        get angle(): number;
        private _axis;
        get axis(): IStiAxis;
        private _text;
        get text(): string;
        private _stripLine;
        get stripLine(): StiStripLineXF;
        draw(context: StiContext): void;
        constructor(axis: IStiAxis, clientRectangle: RectangleD, textPoint: PointD, text: string, stripLine: StiStripLineXF, angle: number, rotationMode: StiRotationMode);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisTitleGeom extends StiCellGeom {
        private _axis;
        get axis(): IStiAxis;
        private _angle;
        get angle(): number;
        private _font;
        get font(): StiFontGeom;
        draw(context: StiContext): void;
        constructor(axis: IStiAxis, clientRectangle: RectangleD, angle: number, stringAlignment: StringAlignment, font: StiFontGeom);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiXAxisGeom extends StiCellGeom {
        private _axis;
        get axis(): IStiXAxis;
        private _isCenterAxis;
        get isCenterAxis(): boolean;
        private _view;
        get view(): StiXAxisViewGeom;
        set view(value: StiXAxisViewGeom);
        drawArrow(context: StiContext, rect: RectangleD): void;
        private drawAxisLine;
        private drawMinorTicks;
        private drawTicks;
        private isArgumentDateTime;
        private drawAxis;
        private getViewclipRect;
        allowChildDrawing(cellGeom: StiCellGeom): boolean;
        draw(context: StiContext): void;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD, isCenterAxis: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiXAxisViewGeom extends StiXAxisGeom {
        drawChildGeoms(context: StiContext): void;
        draw(context: StiContext): void;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD, isCenterAxis: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiYAxisGeom extends StiCellGeom {
        private _axis;
        get axis(): IStiYAxis;
        private _isCenterAxis;
        get isCenterAxis(): boolean;
        private _view;
        get view(): StiYAxisViewGeom;
        set view(value: StiYAxisViewGeom);
        drawArrow(context: StiContext, rect: RectangleD): void;
        private drawAxisLine;
        private drawMinorTicks;
        private drawTicks;
        private drawAxis;
        private getViewclipRect;
        allowChildDrawing(cellGeom: StiCellGeom): boolean;
        draw(context: StiContext): void;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD, isCenterAxis: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiYAxisViewGeom extends StiYAxisGeom {
        drawChildGeoms(context: StiContext): void;
        draw(context: StiContext): void;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD, isCenterAxis: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDownButtonGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeMouseDown(options: StiInteractionOptions): void;
        private moveDown;
        private _axis;
        get axis(): IStiYAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHorzScrollBarGeom extends StiCellGeom {
        invokeMouseDown(options: StiInteractionOptions): void;
        draw(context: StiContext): void;
        private _axis;
        get axis(): IStiXAxis;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHorzTrackBarGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeMouseDown(options: StiInteractionOptions): void;
        invokeDrag(options: StiInteractionOptions): void;
        draw(context: StiContext): void;
        private _axis;
        get axis(): IStiXAxis;
        private _scrollBar;
        get scrollBar(): StiHorzScrollBarGeom;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD, scrollBar: StiHorzScrollBarGeom);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLeftButtonGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeMouseDown(options: StiInteractionOptions): void;
        private moveLeft;
        private _axis;
        get axis(): IStiXAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRightButtonGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeMouseDown(options: StiInteractionOptions): void;
        private moveRight;
        private _axis;
        get axis(): IStiXAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiUpButtonGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeMouseDown(options: StiInteractionOptions): void;
        private moveUp;
        private _axis;
        get axis(): IStiYAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiVertScrollBarGeom extends StiCellGeom {
        invokeMouseDown(options: StiInteractionOptions): void;
        draw(context: StiContext): void;
        private _axis;
        get axis(): IStiYAxis;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiVertTrackBarGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeMouseDown(options: StiInteractionOptions): void;
        invokeDrag(options: StiInteractionOptions): void;
        draw(context: StiContext): void;
        private _axis;
        get axis(): IStiYAxis;
        private _scrollBar;
        get scrollBar(): StiVertScrollBarGeom;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD, scrollBar: StiVertScrollBarGeom);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiChartTitleGeom extends StiCellGeom {
        private _title;
        get title(): IStiChartTitle;
        draw(context: StiContext): void;
        constructor(title: IStiChartTitle, clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiConstantLinesVerticalGeom extends StiCellGeom {
        private _line;
        get line(): IStiConstantLines;
        private _point;
        get point(): PointD;
        private _mode;
        get mode(): StiRotationMode;
        draw(context: StiContext): void;
        constructor(line: IStiConstantLines, clientRectangle: RectangleD, point: PointD, mode: StiRotationMode);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiConstantLinesYGeom extends StiCellGeom {
        private _line;
        get line(): IStiConstantLines;
        private _point;
        get point(): PointD;
        private _mode;
        get mode(): StiRotationMode;
        draw(context: StiContext): void;
        constructor(line: IStiConstantLines, clientRectangle: RectangleD, point: PointD, mode: StiRotationMode);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendGeom extends StiCellGeom {
        private _legend;
        get legend(): IStiLegend;
        private _seriesItems;
        get seriesItems(): StiLegendItemCoreXF[];
        private _legendTitleGeom;
        get legendTitleGeom(): StiLegendTitleGeom;
        set legendTitleGeom(value: StiLegendTitleGeom);
        dispose(): void;
        draw(context: StiContext): void;
        constructor(legend: IStiLegend, clientRectangle: RectangleD, seriesItems: StiLegendItemCoreXF[]);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendItemGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeClick(options: StiInteractionOptions): void;
        get allowMouseOver(): boolean;
        private get isColorEach();
        get isMouseOver(): boolean;
        set isMouseOver(value: boolean);
        private _legend;
        get legend(): IStiLegend;
        private _item;
        get item(): StiLegendItemCoreXF;
        private _colorIndex;
        get colorIndex(): number;
        private _legendItemsCount;
        get legendItemsCount(): number;
        private legendItemIndex;
        draw(context: StiContext): void;
        constructor(legend: IStiLegend, item: StiLegendItemCoreXF, clientRectangle: RectangleD, colorIndex: number, legendItemsCount: number, legendItemIndex: number);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendTitleGeom extends StiCellGeom {
        private _legend;
        get legend(): IStiLegend;
        draw(context: StiContext): void;
        constructor(legend: IStiLegend, clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendAreaMarker implements IStiLegendMarker {
        private static implementsStiLegendAreaMarker;
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendCandelstickMarker implements IStiLegendMarker {
        private static implementsStiLegendCandelstickMarker;
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendColumnMarker implements IStiLegendMarker {
        private static implementsStiLegendColumnMarker;
        implements(): any[];
        draw(context: StiContext, series: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendDoughnutMarker implements IStiLegendMarker {
        private static implementsStiLegendDoughnutMarker;
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiLegendFontIconMarker implements IStiLegendMarker {
        draw(context: StiContext, series: IStiSeries, rect: Rectangle, colorIndex: number, colorCount: number, index: number): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendFunnelMarker implements IStiLegendMarker {
        private static implementsStiLegendFunnelMarker;
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendLineMarker implements IStiLegendMarker {
        private static implementsStiLegendLineMarker;
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiLegendMarkerHelper {
        static getSteppedMarkerPath(rect: RectangleD): StiSegmentGeom[];
        static getAreaMarkerPath(rect: RectangleD): StiSegmentGeom[];
        static getAreaMarkerLinePoints(rect: RectangleD): PointD[];
        static getSplineAreaMarkerPath(rect: RectangleD): StiSegmentGeom[];
        static getSplineAreaMarkerLinePoints(rect: RectangleD): PointD[];
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendPictorialMarker implements IStiLegendMarker {
        private static implementsStiLegendPictorialMarker;
        implements(): any[];
        draw(context: StiContext, series: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendPieMarker implements IStiLegendMarker {
        private static implementsStiLegendPieMarker;
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendRangeMarker implements IStiLegendMarker {
        private static implementsStiLegendRangeMarker;
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendSplineAreaMarker implements IStiLegendMarker {
        private static implementsStiLegendSplineAreaMarker;
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendSplineRangeMarker implements IStiLegendMarker {
        private static implementsStiLegendSplineRangeMarker;
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendStackedAreaMarker implements IStiLegendMarker {
        private static implementsStiLegendStackedAreaMarker;
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendStackedSplineAreaMarker implements IStiLegendMarker {
        private static implementsStiLegendStackedSplineAreaMarker;
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendSteppedAreaMarker implements IStiLegendMarker {
        private static implementsStiLegendSteppedAreaMarker;
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendSteppedRangeMarker implements IStiLegendMarker {
        private static implementsStiSteppedRangeSeries;
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendStockMarker implements IStiLegendMarker {
        private static implementsStiLegendStockMarker;
        implements(): any[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number, index: number): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiMarkerLegendFactory {
        static createMarker(series: IStiSeries): IStiLegendMarker;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import IStiSeriesElement = Stimulsoft.Report.Chart.IStiSeriesElement;
    import StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
    class StiMarkerGeom extends StiCellGeom implements IStiSeriesElement {
        private static implementsStiMarkerGeom;
        implements(): any[];
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeClick(options: StiInteractionOptions): void;
        private getValueIndex;
        getHyperlink(): string;
        private getHyperlink2;
        getToolTip(): string;
        private getToolTip2;
        get allowMouseOver(): boolean;
        get isMouseOver(): boolean;
        set isMouseOver(value: boolean);
        private _interaction;
        get interaction(): StiSeriesInteractionData;
        set interaction(value: StiSeriesInteractionData);
        private _index;
        get index(): number;
        private _point;
        get point(): PointD;
        private _marker;
        get marker(): IStiMarker;
        private _value;
        get value(): number;
        private _showShadow;
        get showShadow(): boolean;
        private _series;
        get series(): IStiSeries;
        private _elementIndex;
        get elementIndex(): string;
        set elementIndex(value: string);
        private _isTooltipMode;
        get isTooltipMode(): boolean;
        contains(x: number, y: number): boolean;
        getMouseOverRect(): RectangleD;
        draw(context: StiContext): void;
        constructor(series: IStiSeries, index: number, value: number, point: PointD, marker: IStiMarker, showShadow: boolean, zoom: number, isTooltipMode: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRadarAxisGeom extends StiCellGeom {
        private _axis;
        get axis(): IStiYRadarAxis;
        private drawAxisLine;
        private drawMinorTicks;
        private drawTicks;
        private drawAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiYRadarAxis, clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiXRadarAxisLabelGeom extends StiCellGeom {
        private _borderColor;
        get borderColor(): Color;
        private _labelBrush;
        get labelBrush(): StiBrush;
        private _text;
        get text(): string;
        private _angle;
        get angle(): number;
        private _point;
        get point(): PointD;
        private _labelRect;
        get labelRect(): RectangleD;
        private _axis;
        get axis(): IStiXRadarAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiXRadarAxis, text: string, labelBrush: StiBrush, borderColor: Color, angle: number, clientRectangle: RectangleD, labelRect: RectangleD, point: PointD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiYRadarAxisLabelGeom extends StiCellGeom {
        private _rotationMode;
        get rotationMode(): StiRotationMode;
        private _textPoint;
        get textPoint(): PointD;
        private _angle;
        get angle(): number;
        private _axis;
        get axis(): IStiYRadarAxis;
        private _text;
        get text(): string;
        private _stripLine;
        get stripLine(): StiStripLineXF;
        draw(context: StiContext): void;
        constructor(axis: IStiYRadarAxis, clientRectangle: RectangleD, textPoint: PointD, text: string, stripLine: StiStripLineXF, angle: number, rotationMode: StiRotationMode);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMouseOverHelper {
        static getMouseOverColor(): Color;
        static getLineMouseOverColor(): Color;
        static mouseOverLineDistance: number;
        static mouseOverSplineDistance: number;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    import IStiSeriesElement = Stimulsoft.Report.Chart.IStiSeriesElement;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
    class StiSeriesElementGeom extends StiCellGeom implements IStiSeriesElement {
        private static implementsStiSeriesElementGeom;
        implements(): any[];
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeClick(options: StiInteractionOptions): void;
        protected getValueIndex(): number;
        getHyperlink(): string;
        private getHyperlink2;
        getToolTip(): string;
        private getToolTip2;
        get allowMouseOver(): boolean;
        get isMouseOver(): boolean;
        set isMouseOver(value: boolean);
        _seriesBrush: StiBrush;
        get seriesBrush(): StiBrush;
        private _value;
        get value(): number;
        private _index;
        get index(): number;
        private _series;
        get series(): IStiSeries;
        private _interaction;
        get interaction(): StiSeriesInteractionData;
        set interaction(value: StiSeriesInteractionData);
        private _areaGeom;
        get areaGeom(): StiAreaGeom;
        set areaGeom(value: StiAreaGeom);
        private _elementIndex;
        get elementIndex(): string;
        set elementIndex(value: string);
        draw(context: StiContext): void;
        getInteractionData(): StiInteractionDataGeom;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiSeries, clientRectangle: RectangleD, brush: StiBrush);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
    class StiSeriesGeom extends StiCellGeom {
        private _series;
        get series(): IStiSeries;
        private _interactions;
        get interactions(): StiSeriesInteractionData[];
        set interactions(value: StiSeriesInteractionData[]);
        private _areaGeom;
        get areaGeom(): StiAreaGeom;
        set areaGeom(value: StiAreaGeom);
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, series: IStiSeries, clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBoxAndWhiskerSeriesElementGeom extends StiCellGeom {
        brush: StiBrush;
        borderColor: Color;
        beginTime: TimeSpan;
        areaGeom: StiAreaGeom;
        mean: number;
        maximum: number;
        minimum: number;
        median: number;
        firstQuartile: number;
        thirdQuartile: number;
        positionX: number;
        values: number[];
        series: IStiSeries;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, series: IStiSeries, positionX: number, minimum: number, maximim: number, firstQuartile: number, thirdQuartile: number, median: number, values: number[], mean: number, clientRectangle: Rectangle, brush: StiBrush, borderColor: Color, beginTime: TimeSpan);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiBubbleSeriesElementGeom extends StiSeriesElementGeom {
        _seriesBrush: StiBrush;
        get seriesBrush(): StiBrush;
        private _seriesBorderColor;
        get seriesBorderColor(): Color;
        private _beginTime;
        get beginTime(): TimeSpan;
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, clientRectangle: RectangleD, beginTime: TimeSpan);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiClusteredBarSeriesElementGeom extends StiSeriesElementGeom {
        _seriesBrush: StiBrush;
        get seriesBrush(): StiBrush;
        private _seriesBorderColor;
        get seriesBorderColor(): Color;
        private _beginTime;
        get beginTime(): TimeSpan;
        private _valueStart;
        get valueStart(): number;
        private _columnRectStart;
        get columnRectStart(): RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, valueStart: number, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, columnRectStart: RectangleD, columnRect: RectangleD, beginTime: TimeSpan);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiBaseLineSeriesGeom extends StiSeriesGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        get allowMouseOver(): boolean;
        get isMouseOver(): boolean;
        set isMouseOver(value: boolean);
        private _points;
        get points(): PointD[];
        static getClientRectangle(points: PointD[], lineWidth: number): RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiLineSeriesGeom extends StiBaseLineSeriesGeom {
        pointsZeroConnect: PointD[];
        pointsNullConnect: PointD[];
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        private getPointCross;
        private drawLine;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries, pointsZeroConnect?: PointD[], pointsNullConnect?: PointD[]);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiAreaSeriesGeom extends StiLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiClusteredColumnSeriesElementGeom extends StiSeriesElementGeom {
        _seriesBrush: StiBrush;
        get seriesBrush(): StiBrush;
        private _seriesBorderColor;
        get seriesBorderColor(): Color;
        private _beginTime;
        get beginTime(): TimeSpan;
        private _animation;
        get animation(): StiAnimation;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, columnRect: RectangleD, animation: StiAnimation);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSplineSeriesGeom extends StiBaseLineSeriesGeom {
        pointsZeroConnect: PointD[];
        pointsNullConnect: PointD[];
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries, pointsZeroConnect?: PointD[], pointsNullConnect?: PointD[]);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSplineAreaSeriesGeom extends StiSplineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSteppedLineSeriesGeom extends StiBaseLineSeriesGeom {
        getConvertedPoints(points: PointD[]): PointD[];
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        private intersectionAxis;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSteppedAreaSeriesGeom extends StiSteppedLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import PointF = Stimulsoft.System.Drawing.Point;
    import StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiWaterfallLineGeom extends StiCellGeom {
        pen: StiPenGeom;
        pointStart: PointF;
        pointEnd: PointF;
        animation: boolean;
        draw(context: StiContext): void;
        constructor(pointStart: PointF, pointEnd: PointF, pen: StiPenGeom, clientRectangle: Rectangle, animation: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiDoughnutEmptySeriesElementGeom extends StiCellGeom {
        draw(context: StiContext): void;
        constructor(clientRectangle: Rectangle);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDoughnutSeriesElementGeom extends StiSeriesElementGeom {
        private _path;
        get path(): StiSegmentGeom[];
        private _pathLight;
        get pathLight(): StiSegmentGeom[];
        private _pathDark;
        get pathDark(): StiSegmentGeom[];
        private _borderColor;
        get borderColor(): Color;
        private _brush;
        get brush(): StiBrush;
        private _brushLight;
        get brushLight(): StiBrush;
        private _brushDark;
        get brushDark(): StiBrush;
        private _startAngle;
        get startAngle(): number;
        private _endAngle;
        get endAngle(): number;
        private _radiusFrom;
        get radiusFrom(): number;
        private _radiusTo;
        get radiusTo(): number;
        private _beginTime;
        get beginTime(): TimeSpan;
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiDoughnutSeries, clientRectangle: RectangleD, path: StiSegmentGeom[], pathLight: StiSegmentGeom[], pathDark: StiSegmentGeom[], borderColor: Color, brush: StiBrush, brushLight: StiBrush, brushDark: StiBrush, startAngle: number, endAngle: number, radiusFrom: number, radiusTo: number, beginTime: TimeSpan);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
    class StiFinancialSeriesElementGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeClick(options: StiInteractionOptions): void;
        private getValueIndex;
        private getHyperlink;
        private getToolTip;
        get allowMouseOver(): boolean;
        get isMouseOver(): boolean;
        set isMouseOver(value: boolean);
        private _series;
        get series(): IStiSeries;
        private _interaction;
        get interaction(): StiSeriesInteractionData;
        set interaction(value: StiSeriesInteractionData);
        private _open;
        get open(): number;
        private _close;
        get close(): number;
        private _high;
        get high(): number;
        private _low;
        get low(): number;
        private _positionX;
        get positionX(): number;
        private _areaGeom;
        get areaGeom(): StiAreaGeom;
        private _index;
        get index(): number;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, series: IStiSeries, clientRectangle: RectangleD, open: number, close: number, high: number, low: number, positionX: number, index: number);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCandlestickSeriesElementGeom extends StiFinancialSeriesElementGeom {
        private _brush;
        get brush(): StiBrush;
        private _borderColor;
        get borderColor(): Color;
        private _beginTime;
        get beginTime(): TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, series: IStiSeries, clientRectangle: RectangleD, bodyStart: number, bodyEnd: number, high: number, low: number, positionX: number, index: number, brush: StiBrush, borderColor: Color, beginTime: TimeSpan);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStockSeriesElementGeom extends StiFinancialSeriesElementGeom {
        private _color;
        get color(): Color;
        private _beginTime;
        get beginTime(): TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, series: IStiSeries, clientRectangle: RectangleD, open: number, close: number, high: number, low: number, positionX: number, index: number, color: Color, beginTime: TimeSpan);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import List = Stimulsoft.System.Collections.List;
    class StiFunnelEmptySeriesElementGeom extends StiCellGeom {
        path: List<StiSegmentGeom>;
        draw(context: StiContext): void;
        constructor(clientRectangle: Rectangle, path: List<StiSegmentGeom>);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiFunnelSeriesElementGeom extends StiSeriesElementGeom {
        private _path;
        get path(): StiSegmentGeom[];
        private _borderColor;
        get borderColor(): Color;
        private _brush;
        get brush(): StiBrush;
        private _beginTime;
        get beginTime(): TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiSeries, clientRectangle: RectangleD, brush: StiBrush, borderColor: Color, path: StiSegmentGeom[], beginTime: TimeSpan);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiGanttSeriesElementGeom extends StiSeriesElementGeom {
        private _beginTime;
        get beginTime(): TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiSeries, clientRectangle: RectangleD, beginTime: TimeSpan, brush: StiBrush);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiPictorialSeriesElementGeom extends StiSeriesElementGeom {
        private _icon;
        get icon(): StiFontIcons;
        set icon(value: StiFontIcons);
        private _drawRectangles;
        get drawRectangles(): RectangleD[];
        set drawRectangles(value: RectangleD[]);
        private _clipRectangles;
        get clipRectangles(): RectangleD[];
        set clipRectangles(value: RectangleD[]);
        _seriesBrush: StiBrush;
        get seriesBrush(): StiBrush;
        set seriesBrush(value: StiBrush);
        private _animation;
        get animation(): StiAnimation;
        set animation(value: StiAnimation);
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, series: IStiSeries, icon: StiFontIcons, drawRectangles: RectangleD[], clipRectangles: RectangleD[], clientRectangle: RectangleD, animation: StiAnimation);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiPieEmptySeriesElementGeom extends StiCellGeom {
        draw(context: StiContext): void;
        constructor(clientRectangle: Rectangle);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiPieSeriesElementGeom extends StiSeriesElementGeom {
        private _path;
        get path(): StiSegmentGeom[];
        private _pathLight;
        get pathLight(): StiSegmentGeom[];
        private _borderColor;
        get borderColor(): Color;
        private _brush;
        get brush(): StiBrush;
        private _startAngle;
        get startAngle(): number;
        set startAngle(value: number);
        private _endAngle;
        get endAngle(): number;
        set endAngle(value: number);
        private _radius;
        get radius(): number;
        set radius(value: number);
        private _beginTime;
        get beginTime(): TimeSpan;
        private _animation;
        get animation(): StiAnimation;
        set animation(value: StiAnimation);
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiPieSeries, clientRectangle: RectangleD, path: StiSegmentGeom[], pathLight: StiSegmentGeom[], borderColor: Color, brush: StiBrush, startAngle: number, endAngle: number, radius: number, animation: StiAnimation);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieSeriesFullElementGeom extends StiSeriesElementGeom {
        private _brush;
        get brush(): StiBrush;
        private _borderColor;
        get borderColor(): Color;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiPieSeries, clientRectangle: RectangleD, brush: StiBrush, borderColor: Color);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieSeriesShadowElementGeom extends StiCellGeom {
        get invisible(): boolean;
        private _series;
        get series(): IStiPieSeries;
        private _shadowContext;
        get shadowContext(): StiContext;
        private _radius;
        get radius(): number;
        private _duration;
        get duration(): TimeSpan;
        private _beginTime;
        get beginTime(): TimeSpan;
        private _isAnimation;
        get isAnimation(): boolean;
        draw(context: StiContext): void;
        constructor(series: IStiPieSeries, clientRectangle: RectangleD, radius: number, shadowContext: StiContext, duration: TimeSpan, beginTime: TimeSpan);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiRadarAreaSeriesGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        get allowMouseOver(): boolean;
        get isMouseOver(): boolean;
        set isMouseOver(value: boolean);
        private _series;
        get series(): IStiSeries;
        private _points;
        get points(): PointD[];
        private _centerPoint;
        get centerPoint(): PointD;
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(series: IStiSeries, points: PointD[], centerPoint: PointD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRadarPointSeriesElementGeom extends StiSeriesElementGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeClick(options: StiInteractionOptions): void;
        protected getValueIndex(): number;
        private getHyperlink3;
        private getToolTip3;
        private _point;
        get point(): PointD;
        contains(x: number, y: number): boolean;
        getMouseOverRect(): RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, brush: StiBrush, series: IStiRadarSeries, point: PointD, zoom: number);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRangeBarElementGeom extends StiSeriesElementGeom {
        private _beginTime;
        get beginTime(): TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiSeries, brush: StiBrush, clientRectangle: RectangleD, beginTime: TimeSpan);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiRangeSeriesGeom extends StiLineSeriesGeom {
        private _pointsEnd;
        get pointsEnd(): PointD[];
        set pointsEnd(value: PointD[]);
        draw(context: StiContext): void;
        private isPointsEqual;
        private getBrush;
        private fillPath;
        private intersection;
        private getPointCross2;
        constructor(areaGeom: StiAreaGeom, points: PointD[], pointsEnd: PointD[], series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSplineRangeSeriesGeom extends StiSplineSeriesGeom {
        private _pointsEnd;
        get pointsEnd(): PointD[];
        set pointsEnd(value: PointD[]);
        draw(context: StiContext): void;
        private fillPath;
        constructor(areaGeom: StiAreaGeom, points: PointD[], pointsEnd: PointD[], series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSteppedRangeSeriesGeom extends StiSteppedLineSeriesGeom {
        private _pointsEnd;
        get pointsEnd(): PointD[];
        set pointsEnd(value: PointD[]);
        draw(context: StiContext): void;
        private getBrush;
        private fillPath;
        private intersection;
        constructor(areaGeom: StiAreaGeom, points: PointD[], pointsEnd: PointD[], series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiScatterSplineSeriesGeom extends StiBaseLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedBarSeriesElementGeom extends StiSeriesElementGeom {
        _seriesBrush: StiBrush;
        get seriesBrush(): StiBrush;
        private _seriesBorderColor;
        get seriesBorderColor(): Color;
        private _beginTime;
        get beginTime(): TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, clientRectangle: RectangleD, beginTime: TimeSpan);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedBarSeriesShadowElementGeom extends StiCellGeom {
        get invisible(): boolean;
        private _series;
        get series(): IStiSeries;
        private _isLeftShadow;
        get isLeftShadow(): boolean;
        private _isRightShadow;
        get isRightShadow(): boolean;
        draw(context: StiContext): void;
        constructor(series: IStiSeries, clientRectangle: RectangleD, isLeftShadow: boolean, isRightShadow: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedAreaSeriesGeom extends StiSeriesGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        get allowMouseOver(): boolean;
        get isMouseOver(): boolean;
        set isMouseOver(value: boolean);
        private _startPoints;
        get startPoints(): PointD[];
        private _endPoints;
        get endPoints(): PointD[];
        contains(x: number, y: number): boolean;
        static getClientRectangle(startPoints: PointD[], endPoints: PointD[]): RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, startPoints: PointD[], endPoints: PointD[], series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedBaseLineSeriesGeom extends StiSeriesGeom {
        private _points;
        get points(): PointD[];
        static getClientRectangle(points: PointD[]): RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedColumnSeriesElementGeom extends StiSeriesElementGeom {
        _seriesBrush: StiBrush;
        get seriesBrush(): StiBrush;
        private _seriesBorderColor;
        get seriesBorderColor(): Color;
        private _beginTime;
        get beginTime(): TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, clientRectangle: RectangleD, beginTime: TimeSpan);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedColumnSeriesShadowElementGeom extends StiCellGeom {
        get invisible(): boolean;
        private _series;
        get series(): IStiSeries;
        private _isTopShadow;
        get isTopShadow(): boolean;
        private _isBottomShadow;
        get isBottomShadow(): boolean;
        draw(context: StiContext): void;
        constructor(series: IStiSeries, clientRectangle: RectangleD, isTopShadow: boolean, isBottomShadow: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiStackedLineSeriesGeom extends StiBaseLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        private getPointCross;
        private drawLine;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedSplineAreaSeriesGeom extends StiSeriesGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        get allowMouseOver(): boolean;
        get isMouseOver(): boolean;
        set isMouseOver(value: boolean);
        private _startPoints;
        get startPoints(): PointD[];
        private _endPoints;
        get endPoints(): PointD[];
        contains(x: number, y: number): boolean;
        static getClientRectangle(startPoints: PointD[], endPoints: PointD[]): RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, startPoints: PointD[], endPoints: PointD[], series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiStackedSplineSeriesGeom extends StiBaseLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import List = Stimulsoft.System.Collections.List;
    class StiSunburstSeriesElementGeom extends StiSeriesElementGeom {
        startAngle: number;
        endAngle: number;
        radiusFrom: number;
        path: List<StiSegmentGeom>;
        borderColor: Color;
        brush: StiBrush;
        radiusTo: number;
        beginTime: TimeSpan;
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiSeries, clientRectangle: RectangleD, path: List<StiSegmentGeom>, borderColor: Color, brush: StiBrush, startAngle: number, endAngle: number, radiusFrom: number, radiusTo: number, beginTime: TimeSpan);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiTreemapSeriesElementGeom extends StiSeriesElementGeom {
        _seriesBrush: StiBrush;
        get seriesBrush(): StiBrush;
        private _seriesBorderColor;
        get seriesBorderColor(): Color;
        private _animation;
        get animation(): StiAnimation;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, clientRectangle: RectangleD, animation: StiAnimation);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiSeriesLabelsGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        private getValueIndex;
        private getHyperlink;
        private getToolTip;
        get allowMouseOver(): boolean;
        get isMouseOver(): boolean;
        set isMouseOver(value: boolean);
        private _value;
        get value(): number;
        private _index;
        get index(): number;
        private _series;
        get series(): IStiSeries;
        private _seriesLabels;
        get seriesLabels(): IStiSeriesLabels;
        private _beginTime;
        get beginTime(): TimeSpan;
        set beginTime(value: TimeSpan);
        private _duration;
        get duration(): TimeSpan;
        set duration(value: TimeSpan);
        drawMarker(context: StiContext, itemRect: Rectangle, markerColor: any, markerBrush: StiBrush): void;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterAxisLabelsGeom extends StiSeriesLabelsGeom {
        private _labelColor;
        get labelColor(): Color;
        private _labelBorderColor;
        get labelBorderColor(): Color;
        private _seriesBrush;
        get seriesBrush(): StiBrush;
        private _seriesLabelsBrush;
        get seriesLabelsBrush(): StiBrush;
        private _seriesBorderColor;
        get seriesBorderColor(): Color;
        private _font;
        get font(): StiFontGeom;
        private _text;
        get text(): string;
        private _animation;
        get animation(): StiAnimation;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, labelColor: Color, labelBorderColor: Color, seriesBrush: StiBrush, seriesLabelsBrush: StiBrush, seriesBorderColor: Color, font: StiFontGeom, animation: StiAnimation);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsideAxisLabelsGeom extends StiSeriesLabelsGeom {
        private _labelColor;
        get labelColor(): Color;
        private _labelBorderColor;
        get labelBorderColor(): Color;
        private _seriesBrush;
        get seriesBrush(): StiBrush;
        private _seriesBorderColor;
        get seriesBorderColor(): Color;
        private _font;
        get font(): StiFontGeom;
        private _text;
        get text(): string;
        private _startPoint;
        get startPoint(): PointD;
        private _endPoint;
        get endPoint(): PointD;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, labelColor: Color, labelBorderColor: Color, seriesBrush: StiBrush, seriesBorderColor: Color, font: StiFontGeom, startPoint: PointD, endPoint: PointD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCenterFunnelLabelsGeom extends StiSeriesLabelsGeom {
        private _seriesBrush;
        get seriesBrush(): StiBrush;
        private _borderColor;
        get borderColor(): Color;
        private _seriesBorderColor;
        get seriesBorderColor(): Color;
        private _labelBrush;
        get labelBrush(): StiBrush;
        private _text;
        get text(): string;
        private _labelRect;
        get labelRect(): RectangleD;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, seriesBrush: StiBrush, labelBrush: StiBrush, borderColor: Color, seriesBorderColor: Color, labelRect: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsideFunnelLabelsGeom extends StiCenterFunnelLabelsGeom {
        private _startPointLine;
        get startPointLine(): PointD;
        private _endPointLine;
        get endPointLine(): PointD;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, seriesBrush: StiBrush, labelBrush: StiBrush, borderColor: Color, seriesBorderColor: Color, labelRect: RectangleD, startPointLine: PointD, endPointLine: PointD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterPieLabelsGeom extends StiSeriesLabelsGeom {
        private _seriesBrush;
        get seriesBrush(): StiBrush;
        private _borderColor;
        get borderColor(): Color;
        private _seriesBorderColor;
        get seriesBorderColor(): Color;
        private _seriesLabelsBrush;
        get seriesLabelsBrush(): StiBrush;
        private _labelBrush;
        get labelBrush(): StiBrush;
        private _text;
        get text(): string;
        private _rotationMode;
        get rotationMode(): StiRotationMode;
        private _labelRect;
        get labelRect(): RectangleD;
        private _angleToUse;
        get angleToUse(): number;
        private _animation;
        get animation(): StiAnimation;
        set animation(value: StiAnimation);
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, seriesBrush: StiBrush, labelBrush: StiBrush, seriesLabelsBrush: StiBrush, borderColor: Color, seriesBorderColor: Color, rotationMode: StiRotationMode, labelRect: RectangleD, angleToUse: number, animation: StiAnimation);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsidePieLabelsGeom extends StiCenterPieLabelsGeom {
        private _lineColor;
        get lineColor(): Color;
        private _labelPoint;
        get labelPoint(): PointD;
        private _startPoint;
        get startPoint(): PointD;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, seriesBrush: StiBrush, labelBrush: StiBrush, seriesLabelsBrush: StiBrush, borderColor: Color, seriesBorderColor: Color, rotationMode: StiRotationMode, labelRect: RectangleD, angleToUse: number, lineColor: Color, labelPoint: PointD, startPoint: PointD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTwoColumnsPieLabelsGeom extends StiSeriesLabelsGeom {
        private _seriesBrush;
        get seriesBrush(): StiBrush;
        private _borderColor;
        get borderColor(): Color;
        private _seriesBorderColor;
        get seriesBorderColor(): Color;
        private _labelBrush;
        get labelBrush(): StiBrush;
        private _seriesLabelsBrush;
        get seriesLabelsBrush(): StiBrush;
        private _text;
        get text(): string;
        private _labelRect;
        get labelRect(): RectangleD;
        private _lineColor;
        get lineColor(): Color;
        private _startPoint;
        get startPoint(): PointD;
        private _endPoint;
        get endPoint(): PointD;
        set endPoint(value: PointD);
        private _arcPoint;
        get arcPoint(): PointD;
        private _centerPie;
        get centerPie(): PointD;
        draw(context: StiContext): void;
        drawMarker(context: StiContext, itemRect: Rectangle, markerColor: any, markerBrush: StiBrush): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, seriesBrush: StiBrush, labelBrush: StiBrush, seriesLabelsBrush: StiBrush, borderColor: Color, seriesBorderColor: Color, labelRect: RectangleD, lineColor: Color, startPoint: PointD, endPoint: PointD, arcPoint: PointD, centerPie: PointD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterTreemapLabelsGeom extends StiSeriesLabelsGeom {
        private _labelColor;
        get labelColor(): Color;
        private _labelBorderColor;
        get labelBorderColor(): Color;
        private _seriesBrush;
        get seriesBrush(): StiBrush;
        private _seriesLabelsBrush;
        get seriesLabelsBrush(): StiBrush;
        private _seriesBorderColor;
        get seriesBorderColor(): Color;
        private _font;
        get font(): StiFontGeom;
        private _text;
        get text(): string;
        private _animation;
        get animation(): StiAnimation;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, labelColor: Color, labelBorderColor: Color, seriesBrush: StiBrush, seriesLabelsBrush: StiBrush, seriesBorderColor: Color, font: StiFontGeom, animation: StiAnimation);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStripsXGeom extends StiCellGeom {
        private _strip;
        get strip(): IStiStrips;
        draw(context: StiContext): void;
        constructor(strip: IStiStrips, clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStripsYGeom extends StiCellGeom {
        private _strip;
        get strip(): IStiStrips;
        draw(context: StiContext): void;
        constructor(strip: IStiStrips, clientRectangle: RectangleD);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiChartTableGeom extends StiCellGeom {
        constructor(clientRectangle: RectangleD, table: string[][], widthCellLegendTableChart: number, heightCellHeader: number, chartTable: IStiChartTable);
        private table;
        private widthCellLegendTableChart;
        private heightCellHeader;
        private chartTable;
        private pen;
        private font;
        private fontHeader;
        private labelBrush;
        private sf;
        private sfHeader;
        private labelHeaderBrush;
        draw(context: StiContext): void;
        private drawHeaderArgument;
        private drawTitleLegend;
        private drawRootTable;
        private checkFontSize;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTrendCurveGeom extends StiCellGeom {
        private _points;
        get points(): PointD[];
        private _trendLine;
        get trendLine(): IStiTrendLine;
        draw(context: StiContext): void;
        constructor(points: PointD[], trendLine: IStiTrendLine);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTrendLineGeom extends StiCellGeom {
        private trendLine;
        private pointStart;
        private pointEnd;
        draw(context: StiContext): void;
        private static getArray;
        constructor(pointStart: PointD, pointEnd: PointD, trendLine: IStiTrendLine);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiBoxAndWhiskerHelper {
        static checkArgument(chart: IStiChart): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    class StiHistogramHelper {
        static checkValuesAndArguments(series: IStiSeries, formatService: StiFormatService): void;
        private static roundToSignificantDigits;
        private static getStandardDeviation;
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiBoxAndWhiskerArea extends StiAxisArea implements IStiBoxAndWhiskerArea {
        private static implementsStiBoxAndWhiskerArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiScatterArea extends StiClusteredColumnArea implements IStiScatterArea, IStiArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiScatterArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiBubbleArea extends StiScatterArea implements IStiScatterArea, IStiClusteredColumnArea, IStiArea, IStiAxisArea, IStiJsonReportObject, ICloneable, IStiBubbleArea {
        private static implementsStiBubbleArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCandlestickArea extends StiClusteredColumnArea implements IStiCandlestickArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, IStiArea, ICloneable {
        private static implementsStiCandlestickArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiClusteredBarArea extends StiClusteredColumnArea implements IStiArea, IStiClusteredBarArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiClusteredBarArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAreaArea extends StiClusteredColumnArea implements IStiArea, IStiClusteredColumnArea, IStiAxisArea, IStiAreaArea, IStiJsonReportObject, ICloneable {
        private static implementsStiAreaArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiHistogramArea extends StiAxisArea {
        get componentId(): StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiLineArea extends StiClusteredColumnArea implements IStiArea, IStiLineArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiLineArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiParetoArea extends StiClusteredColumnArea implements IStiArea, IStiParetoArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiParetoArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        get componentId(): StiComponentId;
        createNew(): StiParetoArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSplineArea extends StiClusteredColumnArea implements IStiArea, IStiSplineArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiSplineArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSplineAreaArea extends StiClusteredColumnArea implements IStiArea, IStiSplineAreaArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiSplineAreaArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSteppedAreaArea extends StiClusteredColumnArea implements IStiArea, IStiSteppedAreaArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiSteppedAreaArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSteppedLineArea extends StiClusteredColumnArea implements IStiArea, IStiClusteredColumnArea, IStiAxisArea, IStiSteppedLineArea, IStiJsonReportObject, ICloneable {
        private static implementsStiSteppedLineArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiWaterfallArea extends StiAxisArea implements IStiWaterfallArea, IStiRoundValuesArea {
        private static implementsStiWaterfallArea;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        roundValues: boolean;
        get componentId(): StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiPieArea extends StiArea implements IStiJsonReportObject, IStiPieArea, IStiArea, ICloneable {
        private static implementsStiPieArea;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        get componentId(): StiComponentId;
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiDoughnutArea extends StiPieArea implements IStiJsonReportObject, IStiPieArea, IStiArea, ICloneable, IStiDoughnutArea {
        private static implementsStiDoughnutArea;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedBarArea extends StiClusteredBarArea implements IStiClusteredBarArea, IStiClusteredColumnArea, IStiArea, IStiAxisArea, IStiJsonReportObject, IStiStackedBarArea, ICloneable {
        private static implementsStiStackedBarArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedBarArea extends StiStackedBarArea implements IStiClusteredBarArea, IStiClusteredColumnArea, IStiArea, IStiAxisArea, IStiFullStackedBarArea, IStiStackedBarArea, IStiJsonReportObject, ICloneable {
        private static implementsStiFullStackedBarArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedColumnArea extends StiAxisArea implements IStiJsonReportObject, IStiStackedColumnArea, IStiAxisArea, ICloneable, IStiArea {
        private static implementsStiStackedColumnArea;
        implements(): any[];
        get componentId(): StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedColumnArea extends StiStackedColumnArea implements IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiFullStackedColumnArea, IStiJsonReportObject, ICloneable {
        private static implementsStiFullStackedColumnArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedAreaArea extends StiFullStackedColumnArea implements IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiFullStackedColumnArea, IStiJsonReportObject, ICloneable, IStiFullStackedAreaArea {
        private static implementsStiFullStackedAreaArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedLineArea extends StiFullStackedColumnArea implements IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiFullStackedColumnArea, IStiJsonReportObject, ICloneable, IStiFullStackedLineArea {
        private static implementsStiFullStackedLineArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedSplineArea extends StiFullStackedColumnArea implements IStiFullStackedSplineArea, IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiFullStackedColumnArea, IStiJsonReportObject, ICloneable {
        private static implementsStiFullStackedSplineArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedSplineAreaArea extends StiFullStackedColumnArea implements IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiFullStackedColumnArea, IStiFullStackedSplineAreaArea, IStiJsonReportObject, ICloneable {
        private static implementsStiFullStackedSplineAreaArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFunnelArea extends StiArea implements IStiJsonReportObject, IStiArea, ICloneable, IStiFunnelArea {
        private static implementsStiFunnelArea;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        get componentId(): StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiFunnelWeightedSlicesArea extends StiFunnelArea {
        get componentId(): StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiGanttArea extends StiClusteredBarArea implements IStiClusteredBarArea, IStiClusteredColumnArea, IStiArea, IStiAxisArea, IStiJsonReportObject, IStiGanttArea, ICloneable {
        private static implementsStiGanttArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiPictorialArea extends StiArea implements IStiJsonReportObject, IStiPictorialArea, IStiRoundValuesArea, IStiArea, ICloneable {
        private static implementsStiPictorialArea;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        get componentId(): StiComponentId;
        roundValues: boolean;
        actual: boolean;
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarAreaArea extends StiRadarArea implements IStiJsonReportObject, IStiRadarArea, IStiArea, IStiRadarAreaArea, ICloneable {
        private static implementsStiRadarAreaArea;
        implements(): any[];
        get componentId(): StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarLineArea extends StiRadarArea implements IStiJsonReportObject, IStiRadarArea, IStiArea, ICloneable, IStiRadarLineArea {
        private static implementsStiRadarLineArea;
        implements(): any[];
        get componentId(): StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarPointArea extends StiRadarArea implements IStiJsonReportObject, IStiRadarPointArea, IStiRadarArea, IStiArea, ICloneable {
        private static implementsStiRadarPointArea;
        implements(): any[];
        get componentId(): StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRangeArea extends StiClusteredColumnArea implements IStiArea, IStiRangeArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiRangeArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRangeBarArea extends StiClusteredColumnArea implements IStiArea, IStiRangeBarArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiRangeBarArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSplineRangeArea extends StiClusteredColumnArea implements IStiArea, IStiAxisArea, IStiClusteredColumnArea, IStiSplineRangeArea, IStiJsonReportObject, ICloneable {
        private static implementsStiSplineRangeArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSteppedRangeArea extends StiClusteredColumnArea implements IStiArea, IStiClusteredColumnArea, IStiSteppedRangeArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiSteppedRangeArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedAreaArea extends StiStackedColumnArea implements IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiStackedAreaArea, IStiJsonReportObject, ICloneable {
        private static implementsStiStackedAreaArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedLineArea extends StiStackedColumnArea implements IStiStackedLineArea, IStiArea, IStiAxisArea, IStiStackedColumnArea, IStiJsonReportObject, ICloneable {
        private static implementsStiStackedLineArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedSplineArea extends StiStackedColumnArea implements IStiStackedSplineArea, IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiStackedSplineArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedSplineAreaArea extends StiStackedColumnArea implements IStiAxisArea, IStiStackedColumnArea, IStiArea, IStiStackedSplineAreaArea, IStiJsonReportObject, ICloneable {
        private static implementsStiStackedSplineAreaArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStockArea extends StiClusteredColumnArea implements IStiArea, IStiStockArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiStockArea;
        implements(): any[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        get componentId(): StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSunburstArea extends StiArea implements IStiJsonReportObject, IStiSunburstArea, ICloneable {
        private static implementsStiSunburstArea;
        implements(): any[];
        get componentId(): StiComponentId;
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTreemapArea extends StiArea implements IStiJsonReportObject, IStiTreemapArea, ICloneable {
        private static implementsStiTreemapArea;
        implements(): any[];
        get componentId(): StiComponentId;
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiAxisTitle implements IStiAxisTitle, ICloneable, IStiJsonReportObject {
        private static implementsStiAxisTitle;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxisTitle;
        private _core;
        get core(): StiAxisTitleCoreXF;
        set core(value: StiAxisTitleCoreXF);
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        private _font;
        get font(): Font;
        set font(value: Font);
        private _text;
        get text(): string;
        set text(value: string);
        private _color;
        get color(): Color;
        set color(value: Color);
        private _antialiasing;
        get antialiasing(): boolean;
        set antialiasing(value: boolean);
        private _alignment;
        get alignment(): StringAlignment;
        set alignment(value: StringAlignment);
        private _position;
        get position(): StiTitlePosition;
        set position(value: StiTitlePosition);
        private _direction;
        get direction(): StiDirection;
        set direction(value: StiDirection);
        constructor(font?: Font, text?: string, color?: Color, antialiasing?: boolean, alignment?: StringAlignment, direction?: StiDirection, allowApplyStyle?: boolean, position?: StiTitlePosition);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiConstantLines extends StiService implements IStiConstantLines, ICloneable, IStiJsonReportObject {
        private static implementsStiConstantLines;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get propName(): string;
        clone(): StiConstantLines;
        get serviceCategory(): string;
        get ServiceType(): Stimulsoft.System.Type;
        private _core;
        get core(): StiConstantLinesCoreXF;
        set core(value: StiConstantLinesCoreXF);
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        private _antialiasing;
        get antialiasing(): boolean;
        set antialiasing(value: boolean);
        private _position;
        get position(): StiConstantLines_StiTextPosition;
        set position(value: StiConstantLines_StiTextPosition);
        private _font;
        get font(): Font;
        set font(value: Font);
        private _text;
        get text(): string;
        set text(value: string);
        private _titleVisible;
        get titleVisible(): boolean;
        set titleVisible(value: boolean);
        private _orientation;
        get orientation(): StiConstantLines_StiOrientation;
        set orientation(value: StiConstantLines_StiOrientation);
        private _lineWidth;
        get lineWidth(): number;
        set lineWidth(value: number);
        private _lineStyle;
        get lineStyle(): StiPenStyle;
        set lineStyle(value: StiPenStyle);
        private _lineColor;
        get lineColor(): Color;
        set lineColor(value: Color);
        private _showInLegend;
        get showInLegend(): boolean;
        set showInLegend(value: boolean);
        private _showBehind;
        get showBehind(): boolean;
        set showBehind(value: boolean);
        private _axisValue;
        get axisValue(): string;
        set axisValue(value: string);
        private _visible;
        get visible(): boolean;
        set visible(value: boolean);
        private _chart;
        get chart(): IStiChart;
        set chart(value: IStiChart);
        toString(): string;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiChartFiltersCollection extends CollectionBase<IStiChartFilter> implements IStiJsonReportObject, ICloneable {
        private static implementsStiChartFiltersCollection;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiChartFiltersCollection;
        add(filter: StiChartFilter): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    class StiDataItem {
        argument: any;
        value: any;
        valueEnd: any;
        weight: any;
        valueOpen: any;
        valueClose: any;
        valueLow: any;
        valueHigh: any;
        title: any;
        key: any;
        color: any;
        toolTip: any;
        tag: any;
        constructor(argument: any, value: any, valueEnd: any, weight: any, valueOpen: any, valueClose: any, valueLow: any, valueHight: any, title: any, key: any, color: any, toolTip: any, tag: any);
    }
    class StiDataItemComparer implements IComparer<StiDataItem> {
        compare(x: StiDataItem, y: StiDataItem): number;
        private directionFactor;
        private sortType;
        constructor(sortType: StiSeriesSortType, sortDirection: StiSeriesSortDirection);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarGridLines implements IStiJsonReportObject, IStiRadarGridLines, ICloneable {
        private static implementsStiRadarGridLines;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        needSetAreaJsonPropertyInternal: boolean;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get propName(): string;
        clone(): StiRadarGridLines;
        private _core;
        get core(): StiRadarGridLinesCoreXF;
        set core(value: StiRadarGridLinesCoreXF);
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        private _color;
        get color(): Color;
        set color(value: Color);
        private _style;
        get style(): StiPenStyle;
        set style(value: StiPenStyle);
        private _visible;
        get visible(): boolean;
        set visible(value: boolean);
        private _area;
        get area(): IStiArea;
        set area(value: IStiArea);
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarGridLinesHor extends StiRadarGridLines implements IStiJsonReportObject, IStiRadarGridLines, IStiRadarGridLinesHor, ICloneable {
        private static implementsStiRadarGridLinesHor;
        implements(): any[];
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarGridLinesVert extends StiRadarGridLines implements IStiJsonReportObject, IStiRadarGridLines, IStiRadarGridLinesVert, ICloneable {
        private static implementsStiRadarGridLinesVert;
        implements(): any[];
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiMarker implements IStiJsonReportObject, IStiMarker, ICloneable {
        private static implementsStiMarker;
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get propName(): string;
        clone(): StiMarker;
        private _core;
        get core(): StiMarkerCoreXF;
        set core(value: StiMarkerCoreXF);
        private _showInLegend;
        get showInLegend(): boolean;
        set showInLegend(value: boolean);
        private _visible;
        get visible(): boolean;
        set visible(value: boolean);
        private _extendedVisible;
        get extendedVisible(): StiExtendedStyleBool;
        set extendedVisible(value: StiExtendedStyleBool);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _borderColor;
        get borderColor(): Color;
        set borderColor(value: Color);
        private _size;
        get size(): number;
        set size(value: number);
        private _angle;
        get angle(): number;
        set angle(value: number);
        private _type;
        get type(): StiMarkerType;
        set type(value: StiMarkerType);
        icon: StiFontIcons;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiLineMarker extends StiMarker implements IStiJsonReportObject, IStiLineMarker, IStiMarker, ICloneable {
        private static implementsStiLineMarker;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        step: number;
        icon: StiFontIcons;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarAxis implements IStiJsonReportObject, IStiRadarAxis, ICloneable {
        private static implementsStiRadarAxis;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        jsonLoadFromJsonObjectArea: boolean;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiRadarAxis;
        private _core;
        get core(): StiRadarAxisCoreXF;
        set core(value: StiRadarAxisCoreXF);
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        private _visible;
        get visible(): boolean;
        set visible(value: boolean);
        private _area;
        get area(): IStiRadarArea;
        set area(value: IStiRadarArea);
        private _range;
        get range(): IStiAxisRange;
        set range(value: IStiAxisRange);
        constructor(range?: IStiAxisRange, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiRadarAxisLabels implements IStiJsonReportObject, IStiRadarAxisLabels, ICloneable {
        private static implementsStiRadarAxisLabels;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiRadarAxisLabels;
        private _core;
        get core(): StiRadarAxisLabelsCoreXF;
        set core(value: StiRadarAxisLabelsCoreXF);
        private _rotationLabels;
        get rotationLabels(): boolean;
        set rotationLabels(value: boolean);
        private _textBefore;
        get textBefore(): string;
        set textBefore(value: string);
        private _textAfter;
        get textAfter(): string;
        set textAfter(value: string);
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        private _drawBorder;
        get drawBorder(): boolean;
        set drawBorder(value: boolean);
        private _format;
        get format(): string;
        set format(value: string);
        private _font;
        get font(): Font;
        set font(value: Font);
        private _antialiasing;
        get antialiasing(): boolean;
        set antialiasing(value: boolean);
        private _color;
        get color(): Color;
        set color(value: Color);
        private _borderColor;
        get borderColor(): Color;
        set borderColor(value: Color);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _width;
        get width(): number;
        set width(value: number);
        private _wordWrap;
        get wordWrap(): boolean;
        set wordWrap(value: boolean);
        constructor(format?: string, font?: Font, antialiasing?: boolean, drawBorder?: boolean, color?: Color, borderColor?: Color, brush?: StiBrush, allowApplyStyle?: boolean, rotationLabels?: boolean, width?: number, wordWrap?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiXRadarAxis extends StiRadarAxis implements IStiXRadarAxis, IStiRadarAxis, ICloneable, IStiJsonReportObject {
        private static implementsStiXRadarAxis;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get propName(): string;
        clone(): StiXRadarAxis;
        get xCore(): StiXRadarAxisCoreXF;
        private _labels;
        get labels(): IStiRadarAxisLabels;
        set labels(value: IStiRadarAxisLabels);
        constructor(labels?: IStiRadarAxisLabels, range?: IStiAxisRange, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiYRadarAxis extends StiRadarAxis implements IStiYRadarAxis, IStiRadarAxis, ICloneable, IStiJsonReportObject {
        private static implementsStiYRadarAxis;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get propName(): string;
        clone(): StiYRadarAxis;
        get yCore(): StiYRadarAxisCoreXF;
        private _labels;
        get labels(): IStiAxisLabels;
        set labels(value: IStiAxisLabels);
        private _ticks;
        get ticks(): IStiAxisTicks;
        set ticks(value: IStiAxisTicks);
        private _lineStyle;
        get lineStyle(): StiPenStyle;
        set lineStyle(value: StiPenStyle);
        private _lineColor;
        get lineColor(): Color;
        set lineColor(value: Color);
        private _lineWidth;
        get lineWidth(): number;
        set lineWidth(value: number);
        private _info;
        get info(): StiAxisInfoXF;
        set info(value: StiAxisInfoXF);
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, ticks?: IStiAxisTicks, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiSeriesInteraction implements IStiSeriesInteraction, IStiJsonReportObject, ICloneable {
        private static implementsStiSeriesInteraction;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get propName(): string;
        getReport(): any;
        clone(): StiSeriesInteraction;
        isDefault(): boolean;
        get hyperlink(): string;
        set hyperlink(value: string);
        get tag(): string;
        set tag(value: string);
        get toolTip(): string;
        set toolTip(value: string);
        get hyperlinkDataColumn(): string;
        set hyperlinkDataColumn(value: string);
        get tagDataColumn(): string;
        set tagDataColumn(value: string);
        get toolTipDataColumn(): string;
        set toolTipDataColumn(value: string);
        get listOfHyperlinks(): string;
        set listOfHyperlinks(value: string);
        get listOfTags(): string;
        set listOfTags(value: string);
        get listOfToolTips(): string;
        set listOfToolTips(value: string);
        get allowSeries(): boolean;
        set allowSeries(value: boolean);
        get allowSeriesElements(): boolean;
        set allowSeriesElements(value: boolean);
        get drillDownEnabled(): boolean;
        set drillDownEnabled(value: boolean);
        get drillDownReport(): string;
        set drillDownReport(value: string);
        get drillDownPage(): StiPage;
        set drillDownPage(value: StiPage);
        get drillDownPageGuid(): string;
        set drillDownPageGuid(value: string);
        get parentComponent(): StiComponent;
        parentSeries: StiSeries;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSeriesPointsInfo {
        pointsFrom: PointD[];
        points: PointD[];
        pointsZeroConnect: PointD[];
        pointsNullConnect: PointD[];
        constructor(pointsFrom?: PointD[], points?: PointD[], pointsZeroConnect?: PointD[], pointsNullConnect?: PointD[]);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiBoxAndWhiskerSeries extends StiSeries implements IStiBoxAndWhiskerSeries {
        private static implementsStiBoxAndWhiskerSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiBoxAndWhiskerSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        brush: StiBrush;
        allowApplyBrush: boolean;
        showInnerPoints: boolean;
        showMeanMarkers: boolean;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiBubbleSeries extends StiScatterSeries implements IStiBaseLineSeries, IStiBubbleSeries, IStiFontIconsSeries, IStiScatterSeries, IStiJsonReportObject, IStiSeries, ICloneable {
        private static implementsStiBubbleSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiBubbleSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _borderColor;
        get borderColor(): Color;
        set borderColor(value: Color);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _weights;
        get weights(): number[];
        set weights(value: number[]);
        get weightsString(): string;
        set weightsString(value: string);
        private _weightDataColumn;
        get weightDataColumn(): string;
        set weightDataColumn(value: string);
        getWeight: Function;
        onGetWeight(e: StiGetValueEventArgs): void;
        invokeGetWeight(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfWeights: Function;
        onGetListOfWeights(e: StiGetValueEventArgs): void;
        invokeGetListOfWeights(sender: StiComponent, e: StiGetValueEventArgs, series: StiBubbleSeries): void;
        private _weight;
        get weight(): string;
        set weight(value: string);
        private _listOfWeights;
        get listOfWeights(): string;
        set listOfWeights(value: string);
        icon: StiFontIcons;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiClusteredColumnSeries extends StiSeries implements IStiJsonReportObject, IStiClusteredColumnSeries, IStiFontIconsSeries, ICloneable, IStiSeries, IStiAllowApplyBrushNegative, IStiShowZerosSeries {
        private static implementsStiClusteredColumnSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiClusteredColumnSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        private _showZeros;
        get showZeros(): boolean;
        set showZeros(value: boolean);
        private _width;
        get width(): number;
        set width(value: number);
        private _borderColor;
        get borderColor(): Color;
        set borderColor(value: Color);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _brushNegative;
        get brushNegative(): StiBrush;
        set brushNegative(value: StiBrush);
        private _allowApplyBrushNegative;
        get allowApplyBrushNegative(): boolean;
        set allowApplyBrushNegative(value: boolean);
        icon: StiFontIcons;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiClusteredBarSeries extends StiClusteredColumnSeries implements IStiJsonReportObject, IStiClusteredColumnSeries, IStiSeries, ICloneable, IStiClusteredBarSeries, IStiAllowApplyBrushNegative {
        private static implementsStiClusteredBarSeries;
        implements(): any[];
        get componentId(): StiComponentId;
        get xAxis(): StiSeriesXAxis;
        set xAxis(value: StiSeriesXAxis);
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiLineSeries extends StiBaseLineSeries implements IStiJsonReportObject, IStiBaseLineSeries, IStiLineSeries, ICloneable, IStiSeries, IStiAllowApplyColorNegative {
        private static implementsStiLineSeries;
        implements(): any[];
        get componentId(): StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiAreaSeries extends StiLineSeries implements IStiLineSeries, IStiBaseLineSeries, IStiAreaSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyBrushNegative {
        private static implementsStiAreaSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiAreaSeries;
        private _topmostLine;
        get topmostLine(): boolean;
        set topmostLine(value: boolean);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _brushNegative;
        get brushNegative(): StiBrush;
        set brushNegative(value: StiBrush);
        private _allowApplyBrushNegative;
        get allowApplyBrushNegative(): boolean;
        set allowApplyBrushNegative(value: boolean);
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiHistogramSeries extends StiClusteredColumnSeries implements IStiHistogramSeries {
        private static implementsStiHistogramSeries;
        implements(): any[];
        get componentId(): StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        private _width1;
        get width(): number;
        set width(value: number);
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiParetoSeries extends StiSeries implements IStiJsonReportObject, IStiParetoSeries, IStiBaseLineSeries, IStiClusteredColumnSeries, ICloneable, IStiSeries, IStiAllowApplyBrushNegative, IStiShowNullsSeries, IStiShowZerosSeries {
        private static implementsStiParetoSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiParetoSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        private _showZeros;
        get showZeros(): boolean;
        set showZeros(value: boolean);
        private _width;
        get width(): number;
        set width(value: number);
        private _borderColor;
        get borderColor(): Color;
        set borderColor(value: Color);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _brushNegative;
        get brushNegative(): StiBrush;
        set brushNegative(value: StiBrush);
        private _allowApplyBrushNegative;
        get allowApplyBrushNegative(): boolean;
        set allowApplyBrushNegative(value: boolean);
        private _showNulls;
        get showNulls(): boolean;
        set showNulls(value: boolean);
        get showMarker(): boolean;
        set showMarker(value: boolean);
        get markerColor(): Color;
        set markerColor(value: Color);
        get markerSize(): number;
        set markerSize(value: number);
        get markerType(): StiMarkerType;
        set markerType(value: StiMarkerType);
        private _marker;
        get marker(): IStiMarker;
        set marker(value: IStiMarker);
        private _lineMarker;
        get lineMarker(): IStiLineMarker;
        set lineMarker(value: IStiLineMarker);
        private _lineColor;
        get lineColor(): Color;
        set lineColor(value: Color);
        getLineColor(): Color;
        setLineColor(value: Color): void;
        private _lineStyle;
        get lineStyle(): StiPenStyle;
        set lineStyle(value: StiPenStyle);
        private _lighting;
        get lighting(): boolean;
        set lighting(value: boolean);
        private _lineWidth;
        get lineWidth(): number;
        set lineWidth(value: number);
        private _labelsOffset;
        get labelsOffset(): number;
        set labelsOffset(value: number);
        private _lineColorNegative;
        get lineColorNegative(): Color;
        set lineColorNegative(value: Color);
        private _allowApplyColorNegative;
        get allowApplyColorNegative(): boolean;
        set allowApplyColorNegative(value: boolean);
        private _allowApplyLineColor;
        get allowApplyLineColor(): boolean;
        set allowApplyLineColor(value: boolean);
        showNullsAs: StiShowEmptyCellsAs;
        showZerosAs: StiShowEmptyCellsAs;
        icon: StiFontIcons;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSplineSeries extends StiBaseLineSeries implements IStiJsonReportObject, IStiBaseLineSeries, ICloneable, IStiSeries, IStiSplineSeries, IStiAllowApplyColorNegative {
        private static implementsStiSplineSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _tension;
        get tension(): number;
        set tension(value: number);
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSplineAreaSeries extends StiSplineSeries implements IStiSplineSeries, IStiBaseLineSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiSplineAreaSeries, IStiAllowApplyColorNegative {
        private static implementsStiSplineAreaSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiSplineAreaSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _topmostLine;
        get topmostLine(): boolean;
        set topmostLine(value: boolean);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _brushNegative;
        get brushNegative(): StiBrush;
        set brushNegative(value: StiBrush);
        private _allowApplyBrushNegative;
        get allowApplyBrushNegative(): boolean;
        set allowApplyBrushNegative(value: boolean);
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSteppedLineSeries extends StiBaseLineSeries implements IStiJsonReportObject, IStiBaseLineSeries, IStiSeries, ICloneable, IStiSteppedLineSeries, IStiAllowApplyColorNegative {
        private static implementsStiSteppedLineSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _pointAtCenter;
        get pointAtCenter(): boolean;
        set pointAtCenter(value: boolean);
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSteppedAreaSeries extends StiSteppedLineSeries implements IStiSteppedLineSeries, IStiBaseLineSeries, IStiJsonReportObject, IStiSteppedAreaSeries, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        private static implementsStiSteppedAreaSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiSteppedAreaSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _topmostLine;
        get topmostLine(): boolean;
        set topmostLine(value: boolean);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _brushNegative;
        get brushNegative(): StiBrush;
        set brushNegative(value: StiBrush);
        private _allowApplyBrushNegative;
        get allowApplyBrushNegative(): boolean;
        set allowApplyBrushNegative(value: boolean);
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiWaterfallSeries extends StiClusteredColumnSeries implements IStiWaterfallSeries {
        private static implementsStiWaterfallSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiWaterfallSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiSeries;
        connectorLine: IStiWaterfallConnectorLine;
        total: IStiWaterfallTotal;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Components.Design {
    class StiSeriesInteractionConverter {
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiPieSeries extends StiSeries implements IStiPieSeries, IStiFontIconsSeries, ICloneable, IStiSeries, IStiJsonReportObject, IStiAllowApplyBorderColor, IStiAllowApplyBrush {
        private static implementsStiPieSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiPieSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        showZeros: boolean;
        private _allowApplyBrush;
        get allowApplyBrush(): boolean;
        set allowApplyBrush(value: boolean);
        private _allowApplyBorderColor;
        get allowApplyBorderColor(): boolean;
        set allowApplyBorderColor(value: boolean);
        getArguments(): any[];
        setArguments(value: any[]): void;
        private _startAngle;
        get startAngle(): number;
        set startAngle(value: number);
        private _borderColor;
        get borderColor(): Color;
        set borderColor(value: Color);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _lighting;
        get lighting(): boolean;
        set lighting(value: boolean);
        private _diameter;
        get diameter(): number;
        set diameter(value: number);
        private _distance;
        get distance(): number;
        set distance(value: number);
        private _cutPieListValues;
        get cutPieListValues(): number[];
        set cutPieListValues(value: number[]);
        get cuttedPieList(): string;
        set cuttedPieList(value: string);
        private _cutPieList;
        get cutPieList(): string;
        set cutPieList(value: string);
        icon: StiFontIcons;
        getCutPieList: Function;
        onGetCutPieList(e: StiGetValueEventArgs): void;
        invokeGetCutPieList(sender: StiComponent, e: StiGetValueEventArgs): void;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDoughnutSeries extends StiPieSeries implements IStiPieSeries, IStiSeries, ICloneable, IStiDoughnutSeries, IStiJsonReportObject, IStiAllowApplyBorderColor, IStiAllowApplyBrush {
        private static implementsStiDoughnutSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        width: number;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCandlestickSeries extends StiSeries implements IStiJsonReportObject, IStiSeries, IStiFinancialSeries, ICloneable, IStiCandlestickSeries {
        private static implementsStiCandlestickSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiCandlestickSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _valuesOpen;
        get valuesOpen(): number[];
        set valuesOpen(value: number[]);
        private _valuesClose;
        get valuesClose(): number[];
        set valuesClose(value: number[]);
        get valuesStringOpen(): string;
        set valuesStringOpen(value: string);
        get valuesStringClose(): string;
        set valuesStringClose(value: string);
        get valuesStringHigh(): string;
        set valuesStringHigh(value: string);
        get valuesStringLow(): string;
        set valuesStringLow(value: string);
        private _valuesHigh;
        get valuesHigh(): number[];
        set valuesHigh(value: number[]);
        private _valuesLow;
        get valuesLow(): number[];
        set valuesLow(value: number[]);
        private _valueDataColumnOpen;
        get valueDataColumnOpen(): string;
        set valueDataColumnOpen(value: string);
        private _valueDataColumnClose;
        get valueDataColumnClose(): string;
        set valueDataColumnClose(value: string);
        private _valueDataColumnHigh;
        get valueDataColumnHigh(): string;
        set valueDataColumnHigh(value: string);
        private _valueDataColumnLow;
        get valueDataColumnLow(): string;
        set valueDataColumnLow(value: string);
        private _borderColor;
        get borderColor(): Color;
        set borderColor(value: Color);
        private _borderColorNegative;
        get borderColorNegative(): Color;
        set borderColorNegative(value: Color);
        private _borderWidth;
        get borderWidth(): number;
        set borderWidth(value: number);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _brushNegative;
        get brushNegative(): StiBrush;
        set brushNegative(value: StiBrush);
        getValueOpen: Function;
        protected onGetValueOpen(e: StiGetValueEventArgs): void;
        invokeGetValueOpen(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesOpen: Function;
        protected onGetListOfValuesOpen(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesOpen(sender: StiComponent, e: StiGetValueEventArgs): void;
        getValueClose: Function;
        protected onGetValueClose(e: StiGetValueEventArgs): void;
        invokeGetValueClose(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesClose: Function;
        protected onGetListOfValuesClose(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesClose(sender: StiComponent, e: StiGetValueEventArgs): void;
        getValueHigh: Function;
        protected onGetValueHigh(e: StiGetValueEventArgs): void;
        invokeGetValueHigh(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesHigh: Function;
        protected onGetListOfValuesHigh(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesHigh(sender: StiComponent, e: StiGetValueEventArgs): void;
        getValueLow: Function;
        protected onGetValueLow(e: StiGetValueEventArgs): void;
        invokeGetValueLow(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesLow: Function;
        protected onGetListOfValuesLow(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesLow(sender: StiComponent, e: StiGetValueEventArgs): void;
        private valueObjOpen;
        get valueOpen(): string;
        set valueOpen(value: string);
        private _listOfValuesOpen;
        get listOfValuesOpen(): string;
        set listOfValuesOpen(value: string);
        private valueObjClose;
        get valueClose(): string;
        set valueClose(value: string);
        private _listOfValuesClose;
        get listOfValuesClose(): string;
        set listOfValuesClose(value: string);
        private valueObjHigh;
        get valueHigh(): string;
        set valueHigh(value: string);
        private _listOfValuesHigh;
        get listOfValuesHigh(): string;
        set listOfValuesHigh(value: string);
        private valueObjLow;
        get valueLow(): string;
        set valueLow(value: string);
        private _listOfValuesLow;
        get listOfValuesLow(): string;
        set listOfValuesLow(value: string);
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStockSeries extends StiCandlestickSeries implements IStiJsonReportObject, IStiStockSeries, IStiFinancialSeries, ICloneable, IStiSeries, IStiAllowApplyColorNegative {
        private static implementsStiStockSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiStockSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _lineColor;
        get lineColor(): Color;
        set lineColor(value: Color);
        private _lineStyle;
        get lineStyle(): StiPenStyle;
        set lineStyle(value: StiPenStyle);
        private _lineWidth;
        get lineWidth(): number;
        set lineWidth(value: number);
        private _lineColorNegative;
        get lineColorNegative(): Color;
        set lineColorNegative(value: Color);
        private _allowApplyColorNegative;
        get allowApplyColorNegative(): boolean;
        set allowApplyColorNegative(value: boolean);
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiStackedBarSeries extends StiSeries implements IStiJsonReportObject, IStiStackedBarSeries, ICloneable, IStiSeries, IStiAllowApplyBrushNegative, IStiShowZerosSeries {
        private static implementsStiStackedBarSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiStackedBarSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _showZeros;
        get showZeros(): boolean;
        set showZeros(value: boolean);
        private _width;
        get width(): number;
        set width(value: number);
        private _borderColor;
        get borderColor(): Color;
        set borderColor(value: Color);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _brushNegative;
        get brushNegative(): StiBrush;
        set brushNegative(value: StiBrush);
        private _allowApplyBrushNegative;
        get allowApplyBrushNegative(): boolean;
        set allowApplyBrushNegative(value: boolean);
        get xAxis(): StiSeriesXAxis;
        set xAxis(value: StiSeriesXAxis);
        createNew(): StiSeries;
        icon: StiFontIcons;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedBarSeries extends StiStackedBarSeries implements IStiJsonReportObject, IStiStackedBarSeries, ICloneable, IStiSeries, IStiFullStackedBarSeries {
        private static implementsStiFullStackedBarSeries;
        implements(): any[];
        get componentId(): StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStackedBaseLineSeries extends StiSeries implements IStiJsonReportObject, IStiStackedBaseLineSeries, ICloneable, IStiSeries {
        private static implementsStiStackedBaseLineSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiStackedBaseLineSeries;
        private _showNulls;
        get showNulls(): boolean;
        set showNulls(value: boolean);
        get showMarker(): boolean;
        set showMarker(value: boolean);
        get markerColor(): Color;
        set markerColor(value: Color);
        get markerSize(): number;
        set markerSize(value: number);
        get markerType(): StiMarkerType;
        set markerType(value: StiMarkerType);
        private _marker;
        get marker(): IStiMarker;
        set marker(value: IStiMarker);
        private _lineMarker;
        get lineMarker(): IStiLineMarker;
        set lineMarker(value: IStiLineMarker);
        private _lighting;
        get lighting(): boolean;
        set lighting(value: boolean);
        private _lineColor;
        get lineColor(): Color;
        set lineColor(value: Color);
        private _lineWidth;
        get lineWidth(): number;
        set lineWidth(value: number);
        private _lineStyle;
        get lineStyle(): StiPenStyle;
        set lineStyle(value: StiPenStyle);
        private _lineColorNegative;
        get lineColorNegative(): Color;
        set lineColorNegative(value: Color);
        private _allowApplyColorNegative;
        get allowApplyColorNegative(): boolean;
        set allowApplyColorNegative(value: boolean);
        getDefaultAreaType(): Stimulsoft.System.Type;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedLineSeries extends StiStackedBaseLineSeries implements IStiJsonReportObject, IStiStackedBaseLineSeries, IStiStackedLineSeries, IStiSeries, ICloneable, IStiShowNullsSeries {
        private static implementsStiStackedLineSeries;
        implements(): any[];
        get componentId(): StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedAreaSeries extends StiStackedLineSeries implements ICloneable, IStiStackedBaseLineSeries, IStiStackedLineSeries, IStiJsonReportObject, IStiSeries, IStiStackedAreaSeries, IStiAllowApplyBrushNegative {
        private static implementsStiStackedAreaSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiStackedAreaSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        get coreBrush(): StiBrush;
        set coreBrush(value: StiBrush);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _brushNegative;
        get brushNegative(): StiBrush;
        set brushNegative(value: StiBrush);
        private _allowApplyBrushNegative;
        get allowApplyBrushNegative(): boolean;
        set allowApplyBrushNegative(value: boolean);
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedAreaSeries extends StiStackedAreaSeries implements IStiStackedAreaSeries, IStiStackedBaseLineSeries, IStiSeries, IStiJsonReportObject, IStiFullStackedAreaSeries, IStiStackedLineSeries, ICloneable, IStiAllowApplyBrushNegative {
        private static implementsStiFullStackedAreaSeries;
        implements(): any[];
        get componentId(): StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiStackedColumnSeries extends StiSeries implements IStiJsonReportObject, IStiStackedColumnSeries, IStiFontIconsSeries, ICloneable, IStiSeries, IStiAllowApplyBrushNegative, IStiShowZerosSeries {
        private static implementsStiStackedColumnSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiStackedColumnSeries;
        private _showZeros;
        get showZeros(): boolean;
        set showZeros(value: boolean);
        private _width;
        get width(): number;
        set width(value: number);
        private _borderColor;
        get borderColor(): Color;
        set borderColor(value: Color);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _brushNegative;
        get brushNegative(): StiBrush;
        set brushNegative(value: StiBrush);
        private _allowApplyBrushNegative;
        get allowApplyBrushNegative(): boolean;
        set allowApplyBrushNegative(value: boolean);
        icon: StiFontIcons;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedColumnSeries extends StiStackedColumnSeries implements IStiFullStackedColumnSeries, IStiStackedColumnSeries, ICloneable, IStiSeries, IStiJsonReportObject, IStiAllowApplyBrushNegative {
        private static implementsStiFullStackedColumnSeries;
        implements(): any[];
        get componentId(): StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedLineSeries extends StiStackedLineSeries implements IStiJsonReportObject, IStiStackedBaseLineSeries, IStiStackedLineSeries, IStiSeries, ICloneable {
        private static implementsStiFullStackedLineSeries;
        implements(): any[];
        get componentId(): StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedSplineSeries extends StiStackedBaseLineSeries implements IStiJsonReportObject, IStiStackedBaseLineSeries, ICloneable, IStiSeries, IStiStackedSplineSeries, IStiAllowApplyColorNegative {
        private static implementsStiStackedSplineSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        private _tension;
        get tension(): number;
        set tension(value: number);
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedSplineAreaSeries extends StiStackedSplineSeries implements IStiStackedSplineSeries, IStiStackedBaseLineSeries, IStiStackedSplineAreaSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyBrushNegative {
        private static implementsStiStackedSplineAreaSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiStackedSplineAreaSeries;
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _brushNegative;
        get brushNegative(): StiBrush;
        set brushNegative(value: StiBrush);
        private _allowApplyBrushNegative;
        get allowApplyBrushNegative(): boolean;
        set allowApplyBrushNegative(value: boolean);
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedSplineAreaSeries extends StiStackedSplineAreaSeries implements IStiStackedSplineSeries, IStiFullStackedSplineAreaSeries, IStiStackedBaseLineSeries, IStiStackedSplineAreaSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyBrushNegative {
        private static implementsStiFullStackedSplineAreaSeries;
        implements(): any[];
        get componentId(): StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedSplineSeries extends StiStackedSplineSeries implements IStiStackedSplineSeries, IStiStackedBaseLineSeries, IStiFullStackedSplineSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        private static implementsStiFullStackedSplineSeries;
        implements(): any[];
        get componentId(): StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiFunnelSeries extends StiSeries implements IStiJsonReportObject, IStiFunnelSeries, IStiFontIconsSeries, IStiSeries, ICloneable, IStiShowZerosSeries {
        private static implementsStiFunnelSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiFunnelSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _showZeros;
        get showZeros(): boolean;
        set showZeros(value: boolean);
        private _allowApplyBrush;
        get allowApplyBrush(): boolean;
        set allowApplyBrush(value: boolean);
        private _allowApplyBorderColor;
        get allowApplyBorderColor(): boolean;
        set allowApplyBorderColor(value: boolean);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _borderColor;
        get borderColor(): Color;
        set borderColor(value: Color);
        icon: StiFontIcons;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFunnelWeightedSlicesSeries extends StiFunnelSeries implements IStiJsonReportObject, IStiFunnelSeries, IStiFunnelWeightedSlicesSeries, IStiSeries, ICloneable {
        private static implementsStiFunnelWeightedSlicesSeries;
        implements(): any[];
        get componentId(): StiComponentId;
        clone(): StiFunnelWeightedSlicesSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiGanttSeries extends StiClusteredBarSeries implements IStiClusteredColumnSeries, IStiClusteredBarSeries, IStiRangeSeries, IStiJsonReportObject, IStiSeries, IStiGanttSeries, ICloneable, IStiAllowApplyBrushNegative {
        private static implementsStiGanttSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiGanttSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _valuesEnd;
        get valuesEnd(): number[];
        set valuesEnd(value: number[]);
        get valuesStringEnd(): string;
        set valuesStringEnd(value: string);
        private _valueDataColumnEnd;
        get valueDataColumnEnd(): string;
        set valueDataColumnEnd(value: string);
        getValueEnd: Function;
        protected onGetValueEnd(e: StiGetValueEventArgs): void;
        invokeGetValueEnd(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesEnd: Function;
        protected onGetListOfValuesEnd(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesEnd(sender: StiComponent, e: StiGetValueEventArgs, series: StiGanttSeries): void;
        private valueObjEnd;
        get valueEnd(): string;
        set valueEnd(value: string);
        private _listOfValuesEnd;
        get listOfValuesEnd(): string;
        set listOfValuesEnd(value: string);
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiPictorialSeries extends StiSeries implements IStiPictorialSeries, IStiFontIconsSeries, ICloneable, IStiSeries, IStiJsonReportObject {
        private static implementsStiPictorialSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _icon;
        get icon(): StiFontIcons;
        set icon(value: StiFontIcons);
        get componentId(): StiComponentId;
        clone(): StiPictorialSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarSeries extends StiSeries implements IStiJsonReportObject, ICloneable, IStiSeries, IStiRadarSeries, IStiShowNullsSeries {
        private static implementsStiRadarSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiRadarSeries;
        private _showNulls;
        get showNulls(): boolean;
        set showNulls(value: boolean);
        private _marker;
        get marker(): IStiMarker;
        set marker(value: IStiMarker);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarAreaSeries extends StiRadarSeries implements IStiRadarSeries, IStiRadarLineSeries, IStiJsonReportObject, IStiSeries, IStiRadarAreaSeries, ICloneable {
        private static implementsStiRadarAreaSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        private _lineColor;
        get lineColor(): Color;
        set lineColor(value: Color);
        private _lineStyle;
        get lineStyle(): StiPenStyle;
        set lineStyle(value: StiPenStyle);
        private _lighting;
        get lighting(): boolean;
        set lighting(value: boolean);
        private _lineWidth;
        get lineWidth(): number;
        set lineWidth(value: number);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarLineSeries extends StiRadarSeries implements IStiJsonReportObject, IStiRadarLineSeries, ICloneable, IStiSeries, IStiRadarSeries {
        private static implementsStiRadarLineSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        private _lineColor;
        get lineColor(): Color;
        set lineColor(value: Color);
        private _lineStyle;
        get lineStyle(): StiPenStyle;
        set lineStyle(value: StiPenStyle);
        private _lighting;
        get lighting(): boolean;
        set lighting(value: boolean);
        private _lineWidth;
        get lineWidth(): number;
        set lineWidth(value: number);
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarPointSeries extends StiRadarSeries implements IStiJsonReportObject, IStiRadarPointSeries, ICloneable, IStiSeries, IStiRadarSeries {
        private static implementsStiRadarPointSeries;
        implements(): any[];
        get componentId(): StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiRangeBarSeries extends StiClusteredColumnSeries implements IStiRangeBarSeries, IStiClusteredColumnSeries, IStiRangeSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyBrushNegative {
        private static implementsStiRangeBarSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiRangeBarSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _valuesEnd;
        get valuesEnd(): number[];
        set valuesEnd(value: number[]);
        get valuesStringEnd(): string;
        set valuesStringEnd(value: string);
        private _valueDataColumnEnd;
        get valueDataColumnEnd(): string;
        set valueDataColumnEnd(value: string);
        getValueEnd: Function;
        protected onGetValueEnd(e: StiGetValueEventArgs): void;
        invokeGetValueEnd(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesEnd: Function;
        protected onGetListOfValuesEnd(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesEnd(sender: StiComponent, e: StiGetValueEventArgs, series: StiRangeBarSeries): void;
        private valueObjEnd;
        get valueEnd(): string;
        set valueEnd(value: string);
        private _listOfValuesEnd;
        get listOfValuesEnd(): string;
        set listOfValuesEnd(value: string);
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRangeSeries extends StiLineSeries implements IStiLineSeries, IStiLineRangeSeries, IStiBaseLineSeries, IStiRangeSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        private static implementsStiRangeSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiRangeSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _valuesEnd;
        get valuesEnd(): number[];
        set valuesEnd(value: number[]);
        get valuesStringEnd(): string;
        set valuesStringEnd(value: string);
        private _valueDataColumnEnd;
        get valueDataColumnEnd(): string;
        set valueDataColumnEnd(value: string);
        private _brushNegative;
        get brushNegative(): StiBrush;
        set brushNegative(value: StiBrush);
        private _allowApplyBrushNegative;
        get allowApplyBrushNegative(): boolean;
        set allowApplyBrushNegative(value: boolean);
        getValueEnd: Function;
        onGetValueEnd(e: StiGetValueEventArgs): void;
        invokeGetValueEnd(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesEnd: Function;
        onGetListOfValuesEnd(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesEnd(sender: StiComponent, e: StiGetValueEventArgs, series: StiRangeSeries): void;
        private valueObjEnd;
        get valueEnd(): string;
        set valueEnd(value: string);
        private _listOfValuesEnd;
        get listOfValuesEnd(): string;
        set listOfValuesEnd(value: string);
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSplineRangeSeries extends StiSplineSeries implements IStiSplineSeries, IStiSplineRangeSeries, IStiBaseLineSeries, IStiRangeSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        private static implementsStiSplineRangeSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiSplineRangeSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _valuesEnd;
        get valuesEnd(): number[];
        set valuesEnd(value: number[]);
        get valuesStringEnd(): string;
        set valuesStringEnd(value: string);
        private _valueDataColumnEnd;
        get valueDataColumnEnd(): string;
        set valueDataColumnEnd(value: string);
        getValueEnd: Function;
        onGetValueEnd(e: StiGetValueEventArgs): void;
        invokeGetValueEnd(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesEnd: Function;
        onGetListOfValuesEnd(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesEnd(sender: StiComponent, e: StiGetValueEventArgs, series: StiSplineRangeSeries): void;
        private valueObjEnd;
        get valueEnd(): string;
        set valueEnd(value: string);
        private _listOfValuesEnd;
        get listOfValuesEnd(): string;
        set listOfValuesEnd(value: string);
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSteppedRangeSeries extends StiSteppedLineSeries implements IStiSteppedLineSeries, IStiBaseLineSeries, IStiRangeSeries, IStiSteppedRangeSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        private static implementsStiSteppedRangeSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiSteppedRangeSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _valuesEnd;
        get valuesEnd(): number[];
        set valuesEnd(value: number[]);
        get valuesStringEnd(): string;
        set valuesStringEnd(value: string);
        private _valueDataColumnEnd;
        get valueDataColumnEnd(): string;
        set valueDataColumnEnd(value: string);
        private _brushNegative;
        get brushNegative(): StiBrush;
        set brushNegative(value: StiBrush);
        private _allowApplyBrushNegative;
        get allowApplyBrushNegative(): boolean;
        set allowApplyBrushNegative(value: boolean);
        getValueEnd: Function;
        onGetValueEnd(e: StiGetValueEventArgs): void;
        invokeGetValueEnd(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesEnd: Function;
        onGetListOfValuesEnd(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesEnd(sender: StiComponent, e: StiGetValueEventArgs, series: StiSteppedRangeSeries): void;
        private valueObjEnd;
        get valueEnd(): string;
        set valueEnd(value: string);
        private _listOfValuesEnd;
        get listOfValuesEnd(): string;
        set listOfValuesEnd(value: string);
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiScatterSplineSeries extends StiScatterSeries implements ICloneable, IStiScatterLineSeries, IStiBaseLineSeries, IStiScatterSplineSeries, IStiJsonReportObject, IStiSeries, IStiScatterSeries, IStiAllowApplyColorNegative {
        private static implementsStiScatterSplineSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiScatterSplineSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _tension;
        get tension(): number;
        set tension(value: number);
        createNew(): StiSeries;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSunburstSeries extends StiSeries implements IStiJsonReportObject, IStiSunburstSeries, ICloneable, IStiSeries {
        private static implementsStiSunburstSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiSunburstSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiSeries;
        private _borderColor;
        get borderColor(): Color;
        set borderColor(value: Color);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiTreemapSeries extends StiSeries implements IStiJsonReportObject, IStiTreemapSeries, IStiFontIconsSeries, ICloneable, IStiSeries {
        private static implementsStiTreemapSeries;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiTreemapSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        get componentId(): StiComponentId;
        createNew(): StiSeries;
        private _borderColor;
        get borderColor(): Color;
        set borderColor(value: Color);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        icon: StiFontIcons;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiNoneLabels extends StiSeriesLabels implements IStiNoneLabels, IStiSeriesLabels, ICloneable, IStiJsonReportObject {
        private static implementsStiNoneLabels;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        get componentId(): StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiInsideBaseAxisLabels extends StiCenterAxisLabels implements IStiInsideBaseAxisLabels, IStiSeriesLabels, ICloneable, IStiAxisSeriesLabels, IStiJsonReportObject {
        private static implementsStiInsideBaseAxisLabels;
        implements(): any[];
        get componentId(): StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiInsideEndAxisLabels extends StiCenterAxisLabels implements IStiCenterAxisLabels, IStiAxisSeriesLabels, IStiSeriesLabels, IStiJsonReportObject, IStiInsideEndAxisLabels, ICloneable {
        private static implementsStiInsideEndAxisLabels;
        implements(): any[];
        get componentId(): StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiLeftAxisLabels extends StiCenterAxisLabels implements IStiCenterAxisLabels, IStiLeftAxisLabels, IStiAxisSeriesLabels, IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        private static implementsStiLeftAxisLabels;
        implements(): any[];
        get componentId(): StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiOutsideAxisLabels extends StiAxisSeriesLabels implements IStiOutsideAxisLabels, IStiSeriesLabels, ICloneable, IStiAxisSeriesLabels, IStiJsonReportObject {
        private static implementsStiOutsideAxisLabels;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        private _lineLength;
        get lineLength(): number;
        set lineLength(value: number);
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiOutsideBaseAxisLabels extends StiCenterAxisLabels implements IStiCenterAxisLabels, IStiAxisSeriesLabels, IStiJsonReportObject, IStiOutsideBaseAxisLabels, IStiSeriesLabels, ICloneable {
        private static implementsStiOutsideBaseAxisLabels;
        implements(): any[];
        get componentId(): StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiOutsideEndAxisLabels extends StiCenterAxisLabels implements IStiOutsideEndAxisLabels, IStiCenterAxisLabels, IStiAxisSeriesLabels, IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        private static implementsStiOutsideEndAxisLabels;
        implements(): any[];
        get componentId(): StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRightAxisLabels extends StiCenterAxisLabels implements IStiCenterAxisLabels, IStiAxisSeriesLabels, IStiRightAxisLabels, IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        private static implementsStiRightAxisLabels;
        implements(): any[];
        get componentId(): StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiValueAxisLabels extends StiCenterAxisLabels implements IStiValueAxisLabels, IStiCenterAxisLabels, IStiAxisSeriesLabels, IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        private static implementsStiValueAxisLabels;
        implements(): any[];
        get componentId(): StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFunnelSeriesLabels extends StiSeriesLabels implements IStiJsonReportObject, IStiFunnelSeriesLabels, ICloneable, IStiSeriesLabels {
        private static implementsStiFunnelSeriesLabels;
        implements(): any[];
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCenterFunnelLabels extends StiFunnelSeriesLabels implements IStiJsonReportObject, IStiSeriesLabels, IStiFunnelSeriesLabels, ICloneable, IStiCenterFunnelLabels {
        private static implementsStiCenterFunnelLabels;
        implements(): any[];
        get componentId(): StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiOutsideLeftFunnelLabels extends StiFunnelSeriesLabels implements IStiCenterFunnelLabels, IStiOutsideLeftFunnelLabels, IStiJsonReportObject, IStiSeriesLabels, IStiFunnelSeriesLabels, ICloneable {
        private static implementsStiOutsideLeftFunnelLabels;
        implements(): any[];
        get componentId(): StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiOutsideRightFunnelLabels extends StiFunnelSeriesLabels implements IStiOutsideRightFunnelLabels, IStiCenterFunnelLabels, IStiJsonReportObject, IStiSeriesLabels, IStiFunnelSeriesLabels, ICloneable {
        private static implementsStiOutsideRightFunnelLabels;
        implements(): any[];
        get componentId(): StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiPieSeriesLabels extends StiSeriesLabels implements IStiJsonReportObject, IStiPieSeriesLabels, IStiSeriesLabels, ICloneable {
        private static implementsStiPieSeriesLabels;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _showInPercent;
        get showInPercent(): boolean;
        set showInPercent(value: boolean);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCenterPieLabels extends StiPieSeriesLabels implements IStiJsonReportObject, IStiPieSeriesLabels, IStiSeriesLabels, IStiCenterPieLabels, ICloneable {
        private static implementsStiCenterPieLabels;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        private _autoRotate;
        get autoRotate(): boolean;
        set autoRotate(value: boolean);
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiInsideEndPieLabels extends StiCenterPieLabels implements IStiCenterPieLabels, IStiSeriesLabels, IStiPieSeriesLabels, IStiInsideEndPieLabels, IStiJsonReportObject, ICloneable {
        private static implementsStiInsideEndPieLabels;
        implements(): any[];
        get componentId(): StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiOutsidePieLabels extends StiCenterPieLabels implements IStiOutsidePieLabels, IStiCenterPieLabels, IStiPieSeriesLabels, IStiSeriesLabels, IStiJsonReportObject, ICloneable {
        private static implementsStiOutsidePieLabels;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        private _showValue;
        get showValue(): boolean;
        set showValue(value: boolean);
        private _lineLength;
        get lineLength(): number;
        set lineLength(value: number);
        private _lineColor;
        get lineColor(): Color;
        set lineColor(value: Color);
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTwoColumnsPieLabels extends StiOutsidePieLabels implements IStiTwoColumnsPieLabels, IStiOutsidePieLabels, IStiCenterPieLabels, IStiPieSeriesLabels, IStiSeriesLabels, IStiJsonReportObject, ICloneable {
        private static implementsStiTwoColumnsPieLabels;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        get componentId(): StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiCenterTreemapLabels extends StiAxisSeriesLabels implements IStiCenterAxisLabels {
        get componentId(): StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiStrips extends StiService implements IStiJsonReportObject, IStiStrips, ICloneable {
        private static implementsStiStrips;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get propName(): string;
        clone(): StiStrips;
        get serviceCategory(): string;
        get serviceType(): Stimulsoft.System.Type;
        private _core;
        get core(): StiStripsCoreXF;
        set core(value: StiStripsCoreXF);
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        private _showBehind;
        get showBehind(): boolean;
        set showBehind(value: boolean);
        private _stripBrush;
        get stripBrush(): StiBrush;
        set stripBrush(value: StiBrush);
        private _antialiasing;
        get antialiasing(): boolean;
        set antialiasing(value: boolean);
        private _font;
        get font(): Font;
        set font(value: Font);
        private _text;
        get text(): string;
        set text(value: string);
        private _titleVisible;
        get titleVisible(): boolean;
        set titleVisible(value: boolean);
        private _titleColor;
        get titleColor(): Color;
        set titleColor(value: Color);
        private _orientation;
        get orientation(): StiStrips_StiOrientation;
        set orientation(value: StiStrips_StiOrientation);
        private _showInLegend;
        get showInLegend(): boolean;
        set showInLegend(value: boolean);
        private _maxValue;
        get maxValue(): string;
        set maxValue(value: string);
        private _minValue;
        get minValue(): string;
        set minValue(value: string);
        private _visible;
        get visible(): boolean;
        set visible(value: boolean);
        private _chart;
        get chart(): IStiChart;
        set chart(value: IStiChart);
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle01 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiCustomStyle extends StiStyle01 implements IStiCustomStyle {
        private static implementsStiCustomStyle;
        implements(): any[];
        get serviceName(): string;
        get customCore(): StiCustomStyleCoreXF;
        constructor(reportStyleName?: string);
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle02 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle03 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle04 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle05 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle06 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle07 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle08 extends StiStyle03 {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle09 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle10 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle11 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle12 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle13 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle14 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle15 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle16 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle17 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle18 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle19 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle20 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle21 extends StiChartStyle {
        isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle22 extends StiChartStyle {
        isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    class StiStyle23 extends StiChartStyle {
        isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle24 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle26 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle27 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle28 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle30 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle31 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle32 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle33 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle34 extends StiChartStyle {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiChartTableDataCells implements IStiChartTableDataCells, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiChartTableDataCells;
        private _font;
        get font(): Font;
        set font(value: Font);
        private _textColor;
        get textColor(): Color;
        set textColor(value: Color);
        private _shrinkFontToFit;
        get shrinkFontToFit(): boolean;
        set shrinkFontToFit(value: boolean);
        private _shrinkFontToFitMinimumSize;
        get shrinkFontToFitMinimumSize(): number;
        set shrinkFontToFitMinimumSize(value: number);
        constructor(shrinkFontToFit?: boolean, shrinkFontToFitMinimumSize?: number, font?: Font, textColor?: Color);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiChartTableHeader implements IStiJsonReportObject, IStiChartTableHeader, ICloneable {
        private static implementsStiChartTableHeader;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiChartTableHeader;
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _font;
        get font(): Font;
        set font(value: Font);
        private _textColor;
        get textColor(): Color;
        set textColor(value: Color);
        private _wordWrap;
        get wordWrap(): boolean;
        set wordWrap(value: boolean);
        private _textAfter;
        get textAfter(): string;
        set textAfter(value: string);
        format: string;
        constructor(textAfter?: string, brush?: StiBrush, font?: Font, textColor?: Color, wordWrap?: boolean, format?: string);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSeriesTopN implements IStiJsonReportObject, IStiSeriesTopN, ICloneable {
        private static implementsStiSeriesTopN;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get propName(): string;
        clone(): StiSeriesTopN;
        private _mode;
        get mode(): StiTopNMode;
        set mode(value: StiTopNMode);
        private _count;
        get count(): number;
        set count(value: number);
        private _showOthers;
        get showOthers(): boolean;
        set showOthers(value: boolean);
        private _othersText;
        get othersText(): string;
        set othersText(value: string);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiTrendLine extends StiService implements IStiTrendLine, ICloneable, IStiJsonReportObject {
        private static implementsStiTrendLine;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromJsonObjectInternal(jObject: StiJson): IStiTrendLine;
        loadFromXml(xmlNode: XmlNode): void;
        static loadTrendLineFromXml(xmlNode: XmlNode): StiTrendLine;
        get componentId(): StiComponentId;
        get propName(): string;
        clone(): StiTrendLine;
        get serviceName(): string;
        get serviceCategory(): string;
        get serviceType(): Stimulsoft.System.Type;
        private _core;
        get core(): StiTrendLineCoreXF;
        set core(value: StiTrendLineCoreXF);
        private _lineColor;
        get lineColor(): Color;
        set lineColor(value: Color);
        private _lineWidth;
        get lineWidth(): number;
        set lineWidth(value: number);
        private _lineStyle;
        get lineStyle(): StiPenStyle;
        set lineStyle(value: StiPenStyle);
        private _showShadow;
        get showShadow(): boolean;
        set showShadow(value: boolean);
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        private _position;
        get position(): StiTrendLine_StiTextPosition;
        set position(value: StiTrendLine_StiTextPosition);
        private _font;
        get font(): Font;
        set font(value: Font);
        private _text;
        get text(): string;
        set text(value: string);
        private _titleVisible;
        get titleVisible(): boolean;
        set titleVisible(value: boolean);
        createNew(): StiTrendLine;
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTrendLineExponential extends StiTrendLine implements IStiTrendLine, ICloneable, IStiJsonReportObject, IStiTrendLineExponential {
        private static implementsStiTrendLineExponential;
        implements(): any[];
        get componentId(): StiComponentId;
        createNew(): StiTrendLine;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTrendLineLinear extends StiTrendLine implements IStiTrendLine, IStiTrendLineLinear, ICloneable, IStiJsonReportObject {
        private static implementsStiTrendLineLinear;
        implements(): any[];
        get componentId(): StiComponentId;
        createNew(): StiTrendLine;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTrendLineLogarithmic extends StiTrendLine implements IStiTrendLine, IStiTrendLineLogarithmic, ICloneable, IStiJsonReportObject {
        private static implementsStiTrendLineLogarithmic;
        implements(): any[];
        get componentId(): StiComponentId;
        createNew(): StiTrendLine;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTrendLineNone extends StiTrendLine implements IStiTrendLine, IStiTrendLineNone, IStiJsonReportObject, ICloneable {
        private static implementsStiTrendLineNone;
        implements(): any[];
        get componentId(): StiComponentId;
        createNew(): StiTrendLine;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiTrendLinesCollection extends CollectionBase<StiTrendLine> implements IStiTrendLinesCollection, ICloneable, IStiJsonReportObject {
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): object;
        add(line: StiTrendLine): void;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiWaterfallConnectorLine implements IStiWaterfallConnectorLine, ICloneable, IStiJsonReportObject {
        private static implementsStiWaterfallConnectorLine;
        implements(): any[];
        clone(): StiWaterfallConnectorLine;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        lineColor: Color;
        lineStyle: StiPenStyle;
        lineWidth: number;
        visible: boolean;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiWaterfallTotal implements IStiWaterfallTotal, ICloneable, IStiJsonReportObject {
        private static implementsStiWaterfallTotal;
        implements(): any[];
        clone(): StiWaterfallTotal;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        text: string;
        visible: boolean;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Type = Stimulsoft.System.Type;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    class StiGaugeStyleXF extends StiBaseStyle implements IStiGaugeStyle, IStiJsonReportObject {
        private static implementsStiGaugeStyleXF;
        implements(): any[];
        get componentId(): StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static createFromJsonObject(jObject: StiJson): StiGaugeStyleXF;
        static createFromXml(xmlNode: XmlNode): StiGaugeStyleXF;
        get serviceName(): string;
        get serviceCategory(): string;
        get serviceType(): Type;
        private _core;
        get core(): StiGaugeStyleCoreXF;
        set core(value: StiGaugeStyleCoreXF);
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        toString(): string;
        compareGaugeStyle(style: StiGaugeStyleXF): boolean;
        drawStyle(g: Graphics, rect: Rectangle, paintValue: boolean, paintImage: boolean): void;
        drawBox(g: Graphics, rect: Rectangle, paintValue: boolean, paintImage: boolean): void;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
        createNew(): StiGaugeStyleXF;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF26 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF27 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    class StiGaugeStyleCoreXF implements IStiGaugeStyleCoreXF {
        get localizedName(): string;
        brush: StiBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        targetColor: Color;
        tickMarkMajorBrush: StiBrush;
        tickMarkMajorBorder: StiBrush;
        tickMarkMajorBorderWidth: number;
        tickMarkMinorBrush: StiBrush;
        tickMarkMinorBorder: StiBrush;
        tickMarkMinorBorderWidth: number;
        tickLabelMajorTextBrush: StiBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiBrush;
        tickLabelMinorFont: Font;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        linearBarBorderBrush: StiBrush;
        linearBarEmptyBrush: StiBrush;
        linearBarEmptyBorderBrush: StiBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiBrush;
        radialBarBorderBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
        radialBarEmptyBorderBrush: StiBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
        markerSkin: StiMarkerSkin;
        markerBrush: StiBrush;
        markerBorderBrush: StiBrush;
        markerBorderWidth: number;
        styleId: StiGaugeStyleId;
        gauge: StiGauge;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiGaugeStyleCoreXF25 extends StiGaugeStyleCoreXF {
        get localizedName(): string;
        brush: StiBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        targetColor: Color;
        tickMarkMajorBrush: StiBrush;
        tickMarkMajorBorder: StiBrush;
        tickMarkMinorBrush: StiBrush;
        tickMarkMinorBorder: StiBrush;
        tickLabelMajorTextBrush: StiBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiBrush;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        linearBarBorderBrush: StiBrush;
        linearBarEmptyBrush: any;
        linearBarEmptyBorderBrush: any;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiBrush;
        radialBarBorderBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
        radialBarEmptyBorderBrush: StiBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiGaugeStyle = Stimulsoft.Report.StiGaugeStyle;
    class StiCustomGaugeStyleCoreXF extends StiGaugeStyleCoreXF25 {
        get localizedName(): string;
        get reportStyleName(): string;
        reportGaugeStyle: StiGaugeStyle;
        constructor(style: StiGaugeStyle);
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiCustomGaugeStyleCoreXF = Stimulsoft.Report.Gauge.StiCustomGaugeStyleCoreXF;
    class StiCustomGaugeStyle extends StiGaugeStyleXF27 {
        get serviceName(): string;
        get customCore(): StiCustomGaugeStyleCoreXF;
        constructor(style?: StiGaugeStyle);
    }
}
declare namespace Stimulsoft.Report.Gauge.Helpers {
    class StiMathHelper {
        static length1(value1: number, value2: number): number;
        static maxMinusMin(value1: number, value2: number): number;
        static getMax(...list: number[]): number;
    }
}
declare namespace Stimulsoft.Report.Gauge.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiRectangleHelper {
        static centerX(rect: Rectangle): number;
        static centerY(rect: Rectangle): number;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import StiGraphicsPathLinesGaugeGeom = Stimulsoft.Report.Gauge.GaugeGeoms.StiGraphicsPathLinesGaugeGeom;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import IStiScaleBarGeometry = Stimulsoft.Report.Gauge.Primitives.IStiScaleBarGeometry;
    import Size = Stimulsoft.System.Drawing.Size;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiLinearBarGeometry implements IStiScaleBarGeometry {
        private scale;
        private _size;
        get size(): Size;
        private _rectGeometry;
        get rectGeometry(): Rectangle;
        get radius(): number;
        get diameter(): number;
        private _center;
        get center(): Point;
        checkRectGeometry(rect: Rectangle): void;
        private getRectGeometry;
        getRestToLenght(): number;
        private checkMinMaxWidth;
        drawScaleGeometry(context: StiGaugeContextPainter): void;
        drawGeometry(context: StiGaugeContextPainter, startValue1: number, endValue1: number, startWidth: number, endWidth: number, offset: number, placement: StiPlacement, REFrect: any, returnOnlyRect: boolean): StiGraphicsPathLinesGaugeGeom;
        drawPrimitiveGeometry(context: StiGaugeContextPainter, rect: Rectangle, minAscent: number, maxAscent: number, startWidth: number, endWidth: number, placement: StiPlacement, restOffset: number, isStartGreaterEnd: boolean): StiGraphicsPathLinesGaugeGeom;
        constructor(scale: StiLinearScale);
    }
}
declare namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import IAsIs = Stimulsoft.System.IAsIs;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiApplyStyleGauge = Stimulsoft.Report.Gauge.IStiApplyStyleGauge;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiElementBase implements ICloneable, IStiApplyStyleGauge, IAsIs {
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        applyStyle(style: IStiGaugeStyle): void;
        clone(): any;
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import EventArgs = Stimulsoft.System.EventArgs;
    import IStiScaleBarGeometry = Stimulsoft.Report.Gauge.Primitives.IStiScaleBarGeometry;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiScaleBase = Stimulsoft.Report.Components.Gauge.IStiScaleBase;
    import StiElementBase = Stimulsoft.Report.Components.Gauge.Primitives.StiElementBase;
    class StiScaleHelper {
        actualMinimum: number;
        actualMaximum: number;
        minWidth: number;
        maxWidth: number;
        private _totalLength;
        get totalLength(): number;
        set totalLength(value: number);
    }
    class StiScaleBase extends StiElementBase implements IStiJsonReportObject, IStiScaleBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, report: StiReport): void;
        get componentId(): StiComponentId;
        get propName(): string;
        clone(): StiScaleBase;
        barGeometry: IStiScaleBarGeometry;
        scaleHelper: StiScaleHelper;
        get isUp(): boolean;
        private _gauge;
        get gauge(): StiGauge;
        set gauge(value: StiGauge);
        private _left;
        get left(): number;
        set left(value: number);
        private _top;
        get top(): number;
        set top(value: number);
        private _startWidth;
        get startWidth(): number;
        set startWidth(value: number);
        private _endWidth;
        get endWidth(): number;
        set endWidth(value: number);
        private _majorInterval;
        get majorInterval(): number;
        set majorInterval(value: number);
        private _minorInterval;
        get minorInterval(): number;
        set minorInterval(value: number);
        private _minimum;
        get minimum(): number;
        set minimum(value: number);
        private _maximum;
        get maximum(): number;
        set maximum(value: number);
        private _isReversed;
        get isReversed(): boolean;
        set isReversed(value: boolean);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _borderBrush;
        get borderBrush(): StiBrush;
        set borderBrush(value: StiBrush);
        _items: Stimulsoft.Report.Gauge.Collections.StiGaugeElementCollection;
        get items(): Stimulsoft.Report.Gauge.Collections.StiGaugeElementCollection;
        set(value: Stimulsoft.Report.Gauge.Collections.StiGaugeElementCollection): void;
        get scaleType(): StiGaugeElemenType;
        prepare(gauge: StiGauge): void;
        calculateMinMaxScaleHelper(): void;
        calculateWidthScaleHelper(): void;
        getPosition(value: number): number;
        interactiveClick(e: EventArgs): void;
        createNew(): StiScaleBase;
        drawElement(context: StiGaugeContextPainter): void;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import EventArgs = Stimulsoft.System.EventArgs;
    import Orientation = Stimulsoft.System.Drawing.Orientation;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiLinearScale extends StiScaleBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, report: StiReport): void;
        get componentId(): StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private _orientation;
        get orientation(): Orientation;
        set orientation(value: Orientation);
        private _relativeHeight;
        get relativeHeight(): number;
        set relativeHeight(value: number);
        get scaleType(): Stimulsoft.Report.Gauge.StiGaugeElemenType;
        interactiveClick(e: EventArgs): void;
        createNew(): StiScaleBase;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import StiGraphicsPathLinesGaugeGeom = Stimulsoft.Report.Gauge.GaugeGeoms.StiGraphicsPathLinesGaugeGeom;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import Size = Stimulsoft.System.Drawing.Size;
    import IStiScaleBarGeometry = Stimulsoft.Report.Gauge.Primitives.IStiScaleBarGeometry;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiRadialBarGeometry implements IStiScaleBarGeometry {
        private scale;
        private _size;
        get size(): Size;
        private _rectGeometry;
        get rectGeometry(): Rectangle;
        private _radius;
        get radius(): number;
        private _diameter;
        get diameter(): number;
        private _center;
        get center(): Point;
        checkRectGeometry(rect: Rectangle): void;
        drawScaleGeometry(context: StiGaugeContextPainter): void;
        getRestToLenght(): number;
        drawGeometry(context: StiGaugeContextPainter, startValue: number, endValue: number, startWidth: number, endWidth: number, offset: number, placement: StiPlacement, REFrect: any, returnOnlyRect: boolean): StiGraphicsPathLinesGaugeGeom;
        constructor(scale: StiRadialScale);
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import EventArgs = Stimulsoft.System.EventArgs;
    import Point = Stimulsoft.System.Drawing.Point;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    class StiRadialScale extends StiScaleBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, report: StiReport): void;
        protected loadPointFromXml(text: string): Point;
        get componentId(): StiComponentId;
        clone(): StiRadialScale;
        applyStyle(style: IStiGaugeStyle): void;
        private _radius;
        get radius(): number;
        set radius(value: number);
        private _radiusMode;
        get radiusMode(): Stimulsoft.Report.Gauge.StiRadiusMode;
        set radiusMode(value: Stimulsoft.Report.Gauge.StiRadiusMode);
        private _center;
        get center(): Point;
        set center(value: Point);
        private _startAngle;
        get startAngle(): number;
        set startAngle(value: number);
        private _sweepAngle;
        get sweepAngle(): number;
        set sweepAngle(value: number);
        private _skin;
        get skin(): Stimulsoft.Report.Gauge.StiRadialScaleSkin;
        set skin(value: Stimulsoft.Report.Gauge.StiRadialScaleSkin);
        get scaleType(): Stimulsoft.Report.Gauge.StiGaugeElemenType;
        getRadius(): number;
        getStartWidth(): number;
        getEndWidth(): number;
        getSweepAngle(): number;
        getCurrentAngle(angle: number): number;
        interactiveClick(e: EventArgs): void;
        createNew(): StiScaleBase;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Gauge.Collections {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    class StiScaleCollection extends CollectionBase<StiScaleBase> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, report: StiReport): void;
        private parent;
        clone(): StiScaleCollection;
        get isReadOnly(): boolean;
        private setParent;
        private clearParent;
        add(element: StiScaleBase): void;
        insert(index: number, element: StiScaleBase): void;
        remove(element: StiScaleBase): boolean;
        copyTo(elements: StiScaleBase[], arrayIndex: number): void;
        moveUp(element: StiScaleBase): boolean;
        moveDown(element: StiScaleBase): boolean;
        constructor(parent: StiGauge);
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiScaleMode = Stimulsoft.Report.Gauge.StiScaleMode;
    import StiGaugeCalculationMode = Stimulsoft.Report.Gauge.StiGaugeCalculationMode;
    import StiGaugeType = Stimulsoft.Report.Gauge.StiGaugeType;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiScaleCollection = Stimulsoft.Report.Gauge.Collections.StiScaleCollection;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiExportImageExtended = Stimulsoft.Report.Components.IStiExportImageExtended;
    import IStiBorder = Stimulsoft.Report.Components.IStiBorder;
    import IStiBrush = Stimulsoft.Report.Components.IStiBrush;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiGauge = Stimulsoft.Report.Components.Gauge.IStiGauge;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    class StiGauge extends StiComponent implements IStiExportImageExtended, IStiBorder, IStiBrush, IStiGauge, IStiJsonReportObject {
        private static implementsStiGauge;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        clone(cloneProperties?: boolean, cloneComponents?: boolean): StiGauge;
        prepareInit(): void;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        private _border;
        get border(): StiBorder;
        set border(value: StiBorder);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private valueFormat_;
        get valueFormat(): StiFormatService;
        set valueFormat(value: StiFormatService);
        private static getValueFormatDefault;
        get localizedCategory(): string;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        mode: StiScaleMode;
        shortValue: boolean;
        minimum: number;
        maximum: number;
        type: StiGaugeType;
        calculationMode: StiGaugeCalculationMode;
        painter: StiGaugeContextPainter;
        private _style;
        get style(): IStiGaugeStyle;
        set style(value: IStiGaugeStyle);
        private _allowApplyStyle;
        get allowApplyStyle(): boolean;
        set allowApplyStyle(value: boolean);
        private _customStyleName;
        get customStyleName(): string;
        set customStyleName(value: string);
        private _scales;
        get scales(): StiScaleCollection;
        set scales(value: StiScaleCollection);
        private _isAnimation;
        get isAnimation(): boolean;
        set isAnimation(value: boolean);
        private changeSkin;
        private getGaugeStyle;
        drawGauge(context: StiGaugeContextPainter): void;
        createNew(): StiComponent;
        applyStyle(style: IStiGaugeStyle): void;
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Report.Gauge.Collections {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiIndicatorRangeInfo = Stimulsoft.Report.Components.Gauge.StiIndicatorRangeInfo;
    class StiBarRangeListCollection extends CollectionBase<StiIndicatorRangeInfo> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private barType;
        clone(): StiBarRangeListCollection;
        get isReadOnly(): boolean;
        add(element: StiIndicatorRangeInfo): void;
        insert(index: number, element: StiIndicatorRangeInfo): void;
        copyTo(elements: StiIndicatorRangeInfo[], arrayIndex: number): void;
        moveUp(element: StiIndicatorRangeInfo): boolean;
        moveDown(element: StiIndicatorRangeInfo): boolean;
        constructor(barType: StiBarRangeListType);
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    import IStiCustomValueBase = Stimulsoft.Report.Components.Gauge.IStiCustomValueBase;
    class StiCustomValueBase implements ICloneable, IStiCustomValueBase, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get propName(): string;
        clone(): any;
        private _value;
        get value(): number;
        set value(value: number);
        private _placement;
        get placement(): StiPlacement;
        set placement(value: StiPlacement);
        private _offset;
        get offset(): number;
        set offset(value: number);
        get localizedName(): string;
        createNew(): StiCustomValueBase;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiCustomValueBase = Stimulsoft.Report.Components.Gauge.StiCustomValueBase;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    class StiRadialTickMarkCustomValue extends StiCustomValueBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiRadialTickMarkCustomValue;
        useBrush: boolean;
        useBorderBrush: boolean;
        useBorderWidth: boolean;
        private _relativeWidth;
        get relativeWidth(): number;
        set relativeWidth(value: number);
        private _relativeHeight;
        get relativeHeight(): number;
        set relativeHeight(value: number);
        private _offsetAngle;
        get offsetAngle(): number;
        set offsetAngle(value: number);
        private _skin;
        get skin(): StiGaugeElementSkin;
        set skin(value: StiGaugeElementSkin);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _borderBrush;
        get borderBrush(): StiBrush;
        set borderBrush(value: StiBrush);
        private _borderWidth;
        get borderWidth(): number;
        set borderWidth(value: number);
        get localizedName(): string;
        toString(): string;
        createNew(): StiCustomValueBase;
        constructor(value?: number, offset?: number, relativeWidth?: number, relativeHeight?: number, offsetAngle?: number, placement?: StiPlacement, brush?: StiBrush, borderBrush?: StiBrush, borderWidth?: number, skin?: StiGaugeElementSkin);
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiLabelRotationMode = Stimulsoft.Report.Gauge.StiLabelRotationMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    class StiRadialTickLabelCustomValue extends StiCustomValueBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        private _text;
        get text(): string;
        set text(value: string);
        private _offsetAngle;
        get offsetAngle(): number;
        set offsetAngle(value: number);
        private _labelRotationMode;
        get labelRotationMode(): StiLabelRotationMode;
        set labelRotationMode(value: StiLabelRotationMode);
        get localizedName(): string;
        toString(): string;
        createNew(): StiCustomValueBase;
        constructor(value?: number, text?: string, offset?: number, offsetAngle?: number, labelRotationMode?: StiLabelRotationMode, placement?: StiPlacement);
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    class StiLinearTickMarkCustomValue extends StiCustomValueBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        private _relativeWidth;
        get relativeWidth(): number;
        set relativeWidth(value: number);
        private _relativeHeight;
        get(): number;
        set relativeHeight(value: number);
        private _skin;
        get skin(): StiGaugeElementSkin;
        set skin(value: StiGaugeElementSkin);
        get localizedName(): string;
        toString(): string;
        createNew(): StiCustomValueBase;
        constructor(value?: number, offset?: number, relativeWidth?: number, relativeHeight?: number, placement?: StiPlacement, skin?: StiGaugeElementSkin);
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    class StiLinearTickLabelCustomValue extends StiCustomValueBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        private _text;
        get text(): string;
        set text(value: string);
        get localizedName(): string;
        toString(): string;
        createNew(): StiCustomValueBase;
        constructor(value?: number, text?: string, offset?: number, placement?: StiPlacement);
    }
}
declare namespace Stimulsoft.Report.Gauge.Collections {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiCustomValueBase = Stimulsoft.Report.Components.Gauge.StiCustomValueBase;
    class StiCustomValuesCollection extends CollectionBase<StiCustomValueBase> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiCustomValuesCollection;
        get isReadOnly(): boolean;
        copyTo(elements: StiCustomValueBase[], arrayIndex: number): void;
        moveUp(element: StiCustomValueBase): boolean;
        moveDown(element: StiCustomValueBase): boolean;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStateIndicatorFilter implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        get componentId(): StiComponentId;
        get propName(): string;
        clone(): any;
        private _startValue;
        get startValue(): number;
        set startValue(value: number);
        private _endValue;
        get endValue(): number;
        set endValue(value: number);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _borderBrush;
        get borderBrush(): StiBrush;
        set borderBrush(value: StiBrush);
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Gauge.Collections {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiStateIndicatorFilter = Stimulsoft.Report.Components.Gauge.StiStateIndicatorFilter;
    class StiFilterCollection extends CollectionBase<StiStateIndicatorFilter> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiFilterCollection;
        get isReadOnly(): boolean;
        moveUp(element: StiStateIndicatorFilter): boolean;
        moveDown(element: StiStateIndicatorFilter): boolean;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle?: number, centerPoint?: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiIndicatorBase = Stimulsoft.Report.Components.Gauge.Primitives.StiIndicatorBase;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiMarkerBaseSkin extends StiGaugeElementSkin {
        addLines(context: StiGaugeContextPainter, indicator: StiIndicatorBase, points: Point[], rect: Rectangle, angle: number, centerPoint: Point, sf: StringFormat, animation: StiAnimation): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker10Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker11Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker12Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker13Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker14Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker15Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker1Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker2Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker3Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker4Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker5Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker6Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker7Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker8Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker9Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiNeedleIndicator1Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    class StiNeedleIndicator2Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiNeedleIndicator3Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    class StiNeedleIndicator4Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiState1Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    class StiState2Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiState3Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark1Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark2Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark3Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark4Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark5Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark6Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark7Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Helpers {
    class StiGaugeSkinHelper {
        static getMarkerSkin(skin: StiMarkerSkin): StiGaugeElementSkin;
        static getTickMarkSkin(skin: StiTickMarkSkin): StiGaugeElementSkin;
        static getStateIndicatorSkin(skin: StiStateSkin): StiGaugeElementSkin;
        static getNeedleIndicatorSkin(skin: StiNeedleSkin): StiGaugeElementSkin;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import IStiGaugeElement = Stimulsoft.Report.Components.Gauge.IStiGaugeElement;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiGaugeElement extends StiElementBase implements IStiJsonReportObject, IStiGaugeElement {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get PropName(): string;
        get animation(): StiAnimation;
        set animation(value: StiAnimation);
        get elementType(): StiGaugeElemenType;
        get localizeName(): string;
        private _scale;
        get scale(): StiScaleBase;
        set scale(value: StiScaleBase);
        createNew(): StiGaugeElement;
        prepareGaugeElement(): void;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiGetValueEvent = Stimulsoft.Report.Events.StiGetValueEvent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    class StiIndicatorBase extends StiGaugeElement implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiIndicatorBase;
        private _valueObj;
        get valueObj(): number;
        set valueObj(value: number);
        private _placement;
        get placement(): Stimulsoft.Report.Gauge.StiPlacement;
        set placement(value: Stimulsoft.Report.Gauge.StiPlacement);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _borderBrush;
        get borderBrush(): StiBrush;
        set borderBrush(value: StiBrush);
        private _borderWidth;
        get borderWidth(): number;
        set borderWidth(value: number);
        onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _getValueEvent;
        get getValueEvent(): StiGetValueEvent;
        set getValueEvent(value: StiGetValueEvent);
        private _value;
        get value(): string;
        set value(value: string);
        prepareGaugeElement(): void;
        interactiveClick(rect: Rectangle, p: Point): void;
        onValueChanged(): void;
        getActualValue(): number;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import Point = Stimulsoft.System.Drawing.Point;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiIndicatorBase = Stimulsoft.Report.Components.Gauge.Primitives.StiIndicatorBase;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiNeedle extends StiIndicatorBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        protected loadPointFromXml(text: string): Point;
        get componentId(): StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private _format;
        get format(): string;
        set format(value: string);
        private _showValue;
        get showValue(): boolean;
        set showValue(value: boolean);
        private _textBrush;
        get textBrush(): StiBrush;
        set textBrush(value: StiBrush);
        private _font;
        get font(): Font;
        set font(value: Font);
        private _capBrush;
        get capBrush(): StiBrush;
        set capBrush(value: StiBrush);
        private _capBorderBrush;
        get capBorderBrush(): StiBrush;
        set capBorderBrush(value: StiBrush);
        private _capBorderWidth;
        get capBorderWidth(): number;
        set capBorderWidth(value: number);
        private _offsetNeedle;
        get offsetNeedle(): number;
        set offsetNeedle(value: number);
        private _startWidth;
        get startWidth(): number;
        set startWidth(value: number);
        private _endWidth;
        get endWidth(): number;
        set endWidth(value: number);
        private _autoCalculateCenterPoint;
        get autoCalculateCenterPoint(): boolean;
        set autoCalculateCenterPoint(value: boolean);
        private _centerPoint;
        get centerPoint(): Point;
        set centerPoint(value: Point);
        private _relativeHeight;
        get relativeHeight(): number;
        set relativeHeight(value: number);
        private _relativeWidth;
        get relativeWidth(): number;
        set relativeWidth(value: number);
        private _skin;
        get skin(): Stimulsoft.Report.Gauge.StiNeedleSkin;
        set skin(value: Stimulsoft.Report.Gauge.StiNeedleSkin);
        private _customSkin;
        get customSkin(): StiGaugeElementSkin;
        set customSkin(value: StiGaugeElementSkin);
        get elementType(): StiGaugeElemenType;
        get localizeName(): string;
        createNew(): StiGaugeElement;
        drawElement(context: StiGaugeContextPainter): any;
        interactiveClick(rect: Rectangle, p: Point): void;
        private getActualCenterPoint;
        private getActualSkin;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import IStiGaugeMarker = Stimulsoft.Report.Gauge.IStiGaugeMarker;
    class StiMarkerBase extends StiIndicatorBase implements IStiGaugeMarker, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiMarkerBase;
        private _offset;
        get offset(): number;
        set offset(value: number);
        private _relativeWidth;
        get relativeWidth(): number;
        set relativeWidth(value: number);
        private _relativeHeight;
        get relativeHeight(): number;
        set relativeHeight(value: number);
        private _skin;
        get skin(): Stimulsoft.Report.Gauge.StiMarkerSkin;
        set skin(value: Stimulsoft.Report.Gauge.StiMarkerSkin);
        private _customSkin;
        get customSkin(): StiGaugeElementSkin;
        set customSkin(value: StiGaugeElementSkin);
        private _format;
        get format(): string;
        set format(value: string);
        private _showValue;
        get showValue(): boolean;
        set showValue(value: boolean);
        private _textBrush;
        get textBrush(): StiBrush;
        set textBrush(value: StiBrush);
        private _font;
        get font(): Font;
        set font(value: Font);
        getActualSkin(): StiGaugeElementSkin;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiMarkerBase = Stimulsoft.Report.Components.Gauge.Primitives.StiMarkerBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiLinearMarker extends StiMarkerBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        get localizeName(): string;
        createNew(): StiGaugeElement;
        drawElement(context: StiGaugeContextPainter): void;
        private getRectangle;
        interactiveClick(rect: Rectangle, p: Point): void;
        private getBarPosition;
    }
}
declare namespace Stimulsoft.Report.Gauge.Helpers {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMixedColorHelper {
        static colorMixed(colors: Color[]): Color;
        private static colorMixer;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiBarRangeListCollection = Stimulsoft.Report.Gauge.Collections.StiBarRangeListCollection;
    import StiBarRangeListType = Stimulsoft.Report.Gauge.StiBarRangeListType;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiBarBase extends StiIndicatorBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiBarBase;
        private _emptyBrush;
        get emptyBrush(): StiBrush;
        set emptyBrush(value: StiBrush);
        private _emptyBorderBrush;
        get emptyBorderBrush(): StiBrush;
        set emptyBorderBrush(value: StiBrush);
        private _emptyBorderWidth;
        get emptyBorderWidth(): number;
        set emptyBorderWidth(value: number);
        private _offset;
        get offset(): number;
        set offset(value: number);
        private _startWidth;
        get startWidth(): number;
        set startWidth(value: number);
        private _endWidth;
        get endWidth(): number;
        set endWidth(value: number);
        private _useRangeColor;
        get useRangeColor(): boolean;
        set useRangeColor(value: boolean);
        private _rangeList;
        get rangeList(): StiBarRangeListCollection;
        set rangeList(value: StiBarRangeListCollection);
        get barType(): StiBarRangeListType;
        onRangeColorChanged(): void;
        checkActualBrushForTopGeometry(): void;
        onValueChanged(): void;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBarBase = Stimulsoft.Report.Components.Gauge.Primitives.StiBarBase;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiLinearBar extends StiBarBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private colorModeHelper;
        private actualBackground;
        private _skin;
        get skin(): Stimulsoft.Report.Gauge.StiLinearBarSkin;
        set skin(value: Stimulsoft.Report.Gauge.StiLinearBarSkin);
        private _rangeColorMode;
        get rangeColorMode(): Stimulsoft.Report.Gauge.StiLinearRangeColorMode;
        set rangeColorMode(value: Stimulsoft.Report.Gauge.StiLinearRangeColorMode);
        onRangeColorChanged(): void;
        get barType(): Stimulsoft.Report.Gauge.StiBarRangeListType;
        get localizeName(): string;
        checkActualBrushForTopGeometry(): void;
        private getRangeBrush;
        createNew(): StiGaugeElement;
        interactiveClick(rect: Rectangle, p: Point): void;
        drawElement(context: StiGaugeContextPainter): void;
        private drawHorizontalThermometer;
        private drawVerticalThermometer;
        private getGeometryHelperForTopIndicator;
        private getTopGeometry;
    }
}
declare namespace Stimulsoft.Report.Gauge.Events {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiGetSkipValuesEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Gauge.Events {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiGetSkipIndicesEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetSkipValuesEvent = Stimulsoft.Report.Gauge.Events.StiGetSkipValuesEvent;
    import StiGetSkipIndicesEvent = Stimulsoft.Report.Gauge.Events.StiGetSkipIndicesEvent;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiTickBase extends StiGaugeElement implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiTickBase;
        onGetSkipValues(e: StiGetValueEventArgs): void;
        invokeGetSkipValues(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _getSkipValuesEvent;
        get getSkipValuesEvent(): StiGetSkipValuesEvent;
        set getSkipValuesEvent(value: StiGetSkipValuesEvent);
        onGetSkipIndices(e: StiGetValueEventArgs): void;
        invokeGetSkipIndices(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _getSkipIndicesEvent;
        get getSkipIndicesEvent(): StiGetSkipIndicesEvent;
        set getSkipIndicesEvent(value: StiGetSkipIndicesEvent);
        private _skipValues;
        get skipValues(): string;
        set skipValues(value: string);
        private _skipIndices;
        get skipIndices(): string;
        set skipIndices(value: string);
        private _placement;
        get placement(): Stimulsoft.Report.Gauge.StiPlacement;
        set placement(value: Stimulsoft.Report.Gauge.StiPlacement);
        private _skipValuesObj;
        get skipValuesObj(): number[];
        set skipValuesObj(value: number[]);
        private _skipIndicesObj;
        get skipIndicesObj(): number[];
        set skipIndicesObj(value: number[]);
        private _offset;
        get offset(): number;
        set offset(value: number);
        private _minimumValue;
        get minimumValue(): number;
        set minimumValue(value: number);
        private _maximumValue;
        get maximumValue(): number;
        set maximumValue(value: number);
        get isSkipMajorValues(): boolean;
        getPointCollection(): Hashtable;
        getMinorCollections(): Hashtable;
        getMajorCollections(): Hashtable;
        checkTickValue(skipValues: number[], skipIndices: number[], key: number, value: number): boolean;
        prepareGaugeElement(): void;
        getOffset(value: number): number;
        getPlacement(value: Stimulsoft.Report.Gauge.StiPlacement): Stimulsoft.Report.Gauge.StiPlacement;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    class StiTickLabelBase extends StiTickBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiTickLabelBase;
        private _textFormat;
        get textFormat(): string;
        set textFormat(value: string);
        private _formatService;
        get formatService(): StiFormatService;
        set formatService(value: StiFormatService);
        private _textBrush;
        get textBrush(): StiBrush;
        set textBrush(value: StiBrush);
        private _font;
        get font(): Font;
        set font(value: Font);
        getTextForRender(value: number, format: string): string;
        getTextForRender2(value: string, format?: string): string;
    }
}
declare namespace Stimulsoft.Report.Gauge.Helpers {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class CacheInfo {
        valueKey: number;
        valueStr: string;
        count: number;
        toString(): string;
        constructor(valueKey: number, valueStr: string, count: number);
    }
    class StiTickLabelHelper {
        static getLabels(collection: Hashtable): Dictionary<number, string>;
        private static prepare;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiTickLabelBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Point = Stimulsoft.System.Drawing.Point;
    import Size = Stimulsoft.System.Drawing.Size;
    class StiRadialTickLabelBase extends StiTickLabelBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _labelRotationMode;
        get labelRotationMode(): Stimulsoft.Report.Gauge.StiLabelRotationMode;
        set labelRotationMode(value: Stimulsoft.Report.Gauge.StiLabelRotationMode);
        private _offsetAngle;
        get offsetAngle(): number;
        set offsetAngle(value: number);
        get elementType(): StiGaugeElemenType;
        drawElement(context: StiGaugeContextPainter): void;
        getMatrixRotation(context: StiGaugeContextPainter, centerPoint: Point, textSize: Size, rotateMode: Stimulsoft.Report.Gauge.StiLabelRotationMode, radius: number, angle: number, REFposition: any): number;
        private getRadialPosition;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRadialTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickLabelBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiRadialTickLabelMinor extends StiRadialTickLabelBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private _skipMajorValues;
        get skipMajorValues(): boolean;
        set skipMajorValues(value: boolean);
        get isSkipMajorValues(): boolean;
        get elementType(): StiGaugeElemenType;
        get localizeName(): string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRadialTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickLabelBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiRadialTickLabelMajor extends StiRadialTickLabelBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        get componentId(): StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        get elementType(): StiGaugeElemenType;
        get localizeName(): string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare namespace Stimulsoft.Report.Gauge.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiGetTextEventHandler: EventHandler;
    class StiGetTextEventArgs extends EventArgs {
        private _value;
        get value(): string;
        set value(value: string);
    }
}
declare namespace Stimulsoft.Report.Gauge.Events {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiGetTextEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetTextEventArgs = Stimulsoft.Report.Gauge.Events.StiGetTextEventArgs;
    import StiGetTextEvent = Stimulsoft.Report.Gauge.Events.StiGetTextEvent;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiGetValueEvent = Stimulsoft.Report.Events.StiGetValueEvent;
    import StiCustomValuesCollection = Stimulsoft.Report.Gauge.Collections.StiCustomValuesCollection;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRadialTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickLabelBase;
    import IStiTickCustom = Stimulsoft.Report.Gauge.Primitives.IStiTickCustom;
    class StiRadialTickLabelCustom extends StiRadialTickLabelBase implements IStiTickCustom, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiRadialTickLabelCustom;
        private _valueObj;
        get valueObj(): number;
        set valueObj(value: number);
        private _textObj;
        get textObj(): string;
        set textObj(value: string);
        private _values;
        get values(): StiCustomValuesCollection;
        set values(value: StiCustomValuesCollection);
        get elementType(): StiGaugeElemenType;
        get localizeName(): string;
        onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _getValueEvent;
        get getValueEvent(): StiGetValueEvent;
        set getValueEvent(value: StiGetValueEvent);
        onGetText(e: StiGetTextEventArgs): void;
        invokeGetText(sender: StiGaugeElement, e: StiGetTextEventArgs): void;
        private _getTextEvent;
        get getTextEvent(): StiGetTextEvent;
        set getTextEvent(value: StiGetTextEvent);
        private _value;
        get value(): string;
        set value(value: string);
        private _text;
        get text(): string;
        set text(value: string);
        createNew(): StiGaugeElement;
        prepareGaugeElement(): void;
        drawElement(context: StiGaugeContextPainter): void;
        private getOffsetAngle;
        private getLabelRotationMode;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiTickBase = Stimulsoft.Report.Components.Gauge.Primitives.StiTickBase;
    class StiTickMarkBase extends StiTickBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiTickMarkBase;
        private _relativeHeight;
        get relativeHeight(): number;
        set relativeHeight(value: number);
        private _relativeWidth;
        get relativeWidth(): number;
        set relativeWidth(value: number);
        private _skin;
        get skin(): Stimulsoft.Report.Gauge.StiTickMarkSkin;
        set skin(value: Stimulsoft.Report.Gauge.StiTickMarkSkin);
        private _customSkin;
        get customSkin(): StiGaugeElementSkin;
        set customSkin(value: StiGaugeElementSkin);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _borderBrush;
        get borderBrush(): StiBrush;
        set borderBrush(value: StiBrush);
        private _borderWidth;
        get borderWidth(): number;
        set borderWidth(value: number);
        getActualSkin(): StiGaugeElementSkin;
        getRelativeWidth(value: number): number;
        getRelativeHeight(value: number): number;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiLinearTickMarkBase extends StiTickMarkBase {
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiLinearTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickMarkBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiLinearTickMarkMinor extends StiLinearTickMarkBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private _skipMajorValues;
        get skipMajorValues(): boolean;
        set skipMajorValues(value: boolean);
        get isSkipMajorValues(): boolean;
        get localizeName(): string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiLinearTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickMarkBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiLinearTickMarkMajor extends StiLinearTickMarkBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        get componentId(): StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        get localizeName(): string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGetValueEvent = Stimulsoft.Report.Events.StiGetValueEvent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiLinearTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickMarkBase;
    import IStiTickCustom = Stimulsoft.Report.Gauge.Primitives.IStiTickCustom;
    import StiCustomValuesCollection = Stimulsoft.Report.Gauge.Collections.StiCustomValuesCollection;
    class StiLinearTickMarkCustom extends StiLinearTickMarkBase implements IStiTickCustom, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiLinearTickMarkCustom;
        private _valueObj;
        get valueObj(): number;
        set valueObj(value: number);
        private _values;
        get values(): StiCustomValuesCollection;
        set values(value: StiCustomValuesCollection);
        get localizeName(): string;
        onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _getValueEvent;
        get getValueEvent(): StiGetValueEvent;
        set getValueEvent(value: StiGetValueEvent);
        private _value;
        get value(): string;
        set value(value: string);
        createNew(): StiGaugeElement;
        prepareGaugeElement(): void;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import StiTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiTickLabelBase;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiLinearTickLabelBase extends StiTickLabelBase {
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiLinearTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickLabelBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiLinearTickLabelMinor extends StiLinearTickLabelBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private _skipMajorValues;
        get skipMajorValues(): boolean;
        set skipMajorValues(value: boolean);
        get isSkipMajorValues(): boolean;
        get localizeName(): string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiLinearTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickLabelBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiLinearTickLabelMajor extends StiLinearTickLabelBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        get componentId(): StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        get localizeName(): string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiTickMarkBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiRadialTickMarkBase extends StiTickMarkBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _offsetAngle;
        get offsetAngle(): number;
        set offsetAngle(value: number);
        get elementType(): StiGaugeElemenType;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRadialTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickMarkBase;
    import IStiTickCustom = Stimulsoft.Report.Gauge.Primitives.IStiTickCustom;
    import StiGetValueEvent = Stimulsoft.Report.Events.StiGetValueEvent;
    import StiCustomValuesCollection = Stimulsoft.Report.Gauge.Collections.StiCustomValuesCollection;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiRadialTickMarkCustom extends StiRadialTickMarkBase implements IStiTickCustom, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiRadialTickMarkCustom;
        private _valueObj;
        get valueObj(): number;
        set valueObj(value: number);
        private _values;
        get values(): StiCustomValuesCollection;
        set values(value: StiCustomValuesCollection);
        onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _getValueEvent;
        get getValueEvent(): StiGetValueEvent;
        set getValueEvent(value: StiGetValueEvent);
        private _value;
        get value(): string;
        set value(value: string);
        get elementType(): StiGaugeElemenType;
        get localizeName(): string;
        createNew(): StiGaugeElement;
        prepareGaugeElement(): void;
        drawElement(context: StiGaugeContextPainter): void;
        private getOffsetAngle;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRadialTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickMarkBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiRadialTickMarkMajor extends StiRadialTickMarkBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        get componentId(): StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        get elementType(): StiGaugeElemenType;
        get localizeName(): string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRadialTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickMarkBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiRadialTickMarkMinor extends StiRadialTickMarkBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private _skipMajorValues;
        get skipMajorValues(): boolean;
        set skipMajorValues(value: boolean);
        get isSkipMajorValues(): boolean;
        get elementType(): StiGaugeElemenType;
        get localizeName(): string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBarRangeListType = Stimulsoft.Report.Gauge.StiBarRangeListType;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiIndicatorRangeInfo = Stimulsoft.Report.Components.Gauge.IStiIndicatorRangeInfo;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiIndicatorRangeInfo implements ICloneable, IStiIndicatorRangeInfo, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, report: StiReport): void;
        get componentId(): StiComponentId;
        get propName(): string;
        clone(): any;
        private _value;
        get value(): number;
        set value(value: number);
        get rangeListType(): StiBarRangeListType;
        createNew(): StiIndicatorRangeInfo;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBarRangeListType = Stimulsoft.Report.Gauge.StiBarRangeListType;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiLinearIndicatorRangeInfo extends StiIndicatorRangeInfo implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, report: StiReport): void;
        get componentId(): StiComponentId;
        private _color;
        get color(): Color;
        set color(value: Color);
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        get rangeListType(): StiBarRangeListType;
        createNew(): StiIndicatorRangeInfo;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBarBase = Stimulsoft.Report.Components.Gauge.Primitives.StiBarBase;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiRadialBar extends StiBarBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private actualBush;
        private colorModeHelper;
        get elementType(): StiGaugeElemenType;
        get barType(): Stimulsoft.Report.Gauge.StiBarRangeListType;
        get localizeName(): string;
        checkActualBrushForTopGeometry(): void;
        createNew(): StiGaugeElement;
        drawElement(context: StiGaugeContextPainter): void;
        onRangeColorChanged(): void;
        interactiveClick(rect: Rectangle, p: Point): void;
        private getRangeGeometry;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBarRangeListType = Stimulsoft.Report.Gauge.StiBarRangeListType;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiRadialIndicatorRangeInfo extends StiIndicatorRangeInfo implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        get componentId(): StiComponentId;
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        get rangeListType(): StiBarRangeListType;
        createNew(): StiIndicatorRangeInfo;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiMarkerBase = Stimulsoft.Report.Components.Gauge.Primitives.StiMarkerBase;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiRadialMarker extends StiMarkerBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        get elementType(): StiGaugeElemenType;
        get localizeName(): string;
        createNew(): StiGaugeElement;
        drawElement(context: StiGaugeContextPainter): void;
        interactiveClick(rect: Rectangle, p: Point): void;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiFilterCollection = Stimulsoft.Report.Gauge.Collections.StiFilterCollection;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiIndicatorBase = Stimulsoft.Report.Components.Gauge.Primitives.StiIndicatorBase;
    import IStiGaugeMarker = Stimulsoft.Report.Gauge.IStiGaugeMarker;
    class StiStateIndicator extends StiIndicatorBase implements IStiGaugeMarker, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        private lastFilter;
        private _format;
        get format(): string;
        set format(value: string);
        private _showValue;
        get showValue(): boolean;
        set showValue(value: boolean);
        private _textBrush;
        get textBrush(): StiBrush;
        set textBrush(value: StiBrush);
        private _font;
        get font(): Font;
        set font(value: Font);
        get elementType(): Stimulsoft.Report.Gauge.StiGaugeElemenType;
        get localizeName(): string;
        private _filters;
        get filters(): StiFilterCollection;
        set filters(value: StiFilterCollection);
        private _left;
        get left(): number;
        set left(value: number);
        private _top;
        get top(): number;
        set top(value: number);
        private _relativeWidth;
        get relativeWidth(): number;
        set relativeWidth(value: number);
        private _relativeHeight;
        get relativeHeight(): number;
        set relativeHeight(value: number);
        private _skin;
        get skin(): Stimulsoft.Report.Gauge.StiStateSkin;
        set skin(value: Stimulsoft.Report.Gauge.StiStateSkin);
        private _customSkin;
        get customSkin(): Stimulsoft.Report.Gauge.StiGaugeElementSkin;
        set customSkin(value: Stimulsoft.Report.Gauge.StiGaugeElementSkin);
        createNew(): StiGaugeElement;
        onValueChanged(): void;
        interactiveClick(rect: Rectangle, p: Point): void;
        drawElement(context: StiGaugeContextPainter): void;
        getActualSkin(): Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import IStiRangeBase = Stimulsoft.Report.Components.Gauge.IStiRangeBase;
    class StiRangeBase implements ICloneable, IStiRangeBase, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get propName(): string;
        clone(): StiRangeBase;
        private _brush;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        private _borderBrush;
        get borderBrush(): StiBrush;
        set borderBrush(value: StiBrush);
        private _borderWidth;
        get borderWidth(): number;
        set borderWidth(value: number);
        private _startValue;
        get startValue(): number;
        set startValue(value: number);
        private _endValue;
        get endValue(): number;
        set endValue(value: number);
        private _startWidth;
        get startWidth(): number;
        set startWidth(value: number);
        private _endWidth;
        get endWidth(): number;
        set endWidth(value: number);
        private _placement;
        get placement(): StiPlacement;
        set placement(value: StiPlacement);
        private _offset;
        get offset(): number;
        set offset(value: number);
        private _rangeList;
        get rangeList(): StiScaleRangeList;
        set rangeList(value: StiScaleRangeList);
        get localizeName(): string;
        drawRange(context: StiGaugeContextPainter, scale: StiScaleBase): void;
        createNew(): StiRangeBase;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRangeBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRangeBase;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    class StiLinearRange extends StiRangeBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        drawRange(context: StiGaugeContextPainter, scale: StiScaleBase): void;
        get localizeName(): string;
        createNew(): StiRangeBase;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRangeBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRangeBase;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiRadialRange extends StiRangeBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        private _useValuesFromTheSpecifiedRange;
        get useValuesFromTheSpecifiedRange(): boolean;
        set useValuesFromTheSpecifiedRange(value: boolean);
        get localizeName(): string;
        drawRange(context: StiGaugeContextPainter, scale: StiScaleBase): void;
        createNew(): StiRangeBase;
    }
}
declare namespace Stimulsoft.Report.Gauge.Collections {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiRangeBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRangeBase;
    import StiScaleRangeList = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleRangeList;
    class StiRangeCollection extends CollectionBase<StiRangeBase> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): any;
        private parent;
        clone(): StiRangeCollection;
        get isReadOnly(): boolean;
        setByIndex(index: number, value: StiRangeBase): void;
        setParent(element: StiRangeBase): void;
        clearParent(element: StiRangeBase): void;
        add(element: StiRangeBase): void;
        insert(index: number, element: StiRangeBase): void;
        remove(element: StiRangeBase): boolean;
        copyTo(elements: StiRangeBase[], arrayIndex: number): void;
        moveUp(element: StiRangeBase): boolean;
        moveDown(element: StiRangeBase): boolean;
        constructor(parent: StiScaleRangeList);
    }
}
declare namespace Stimulsoft.Report.Components.Gauge.Primitives {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRangeCollection = Stimulsoft.Report.Gauge.Collections.StiRangeCollection;
    class StiScaleRangeList extends StiGaugeElement implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiScaleRangeList;
        private _ranges;
        get ranges(): StiRangeCollection;
        set ranges(value: StiRangeCollection);
        constructor();
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiScaleRangeList = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleRangeList;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiLinearRangeList extends StiScaleRangeList implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        createNew(): StiGaugeElement;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiScaleRangeList = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleRangeList;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    class StiRadialRangeList extends StiScaleRangeList implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        get elementType(): StiGaugeElemenType;
        createNew(): StiGaugeElement;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Helpers {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    class StiGaugeHelper {
        static globalDurationElement: TimeSpan;
        static globalBeginTimeElement: TimeSpan;
        static getFloatValueFromObject(valueObj: any, scale: StiScaleBase): number;
        static getFloatValueFromObject2(valueObj: any, defaultValue: number): number;
        static getFloatArrayValueFromString(value: any): number[];
        private static initializeGauge;
        private static initializeName;
        static checkGaugeName(gauge: StiGauge): void;
        static simpleRadialGauge(gauge: StiGauge, report: StiReport): void;
        static radialTwoScalesGauge(gauge: StiGauge, report: StiReport): void;
        static radialBarGauge(gauge: StiGauge, report: StiReport): void;
        static simpleTwoBarGauge(gauge: StiGauge, report: StiReport): void;
        static defaultRadialGauge(gauge: StiGauge, report: StiReport): void;
        static defaultLinearGauge(gauge: StiGauge, report: StiReport): void;
        static linearGaugeRangeList(gauge: StiGauge, report: StiReport): void;
        static bulletGraphsGreen(gauge: StiGauge, report: StiReport): void;
        static halfDonutsGauge(gauge: StiGauge, report: StiReport): void;
        static halfDonutsGauge2(gauge: StiGauge, report: StiReport): void;
        static radialGaugeHalfCircleN(gauge: StiGauge, report: StiReport): void;
        static radialGaugeHalfCircleS(gauge: StiGauge, report: StiReport): void;
        static radialGaugeQuarterCircleNW(gauge: StiGauge, report: StiReport): void;
        static radialGaugeQuarterCircleNE(gauge: StiGauge, report: StiReport): void;
        static radialGaugeQuarterCircleSW(gauge: StiGauge, report: StiReport): void;
        static radialGaugeQuarterCircleSE(gauge: StiGauge, report: StiReport): void;
        private static radialGaugeQuarterCircle;
        static horizontalThermometer(gauge: StiGauge, report: StiReport): void;
        static verticalThermometer(gauge: StiGauge, report: StiReport): void;
        static lightSpeedometer(gauge: StiGauge, report: StiReport): void;
        static darkSpeedometer(gauge: StiGauge, report: StiReport): void;
    }
}
declare namespace Stimulsoft.Report.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetTextEventArgs = Stimulsoft.Report.Gauge.Events.StiGetTextEventArgs;
    import StiGetTextEvent = Stimulsoft.Report.Gauge.Events.StiGetTextEvent;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiCustomValuesCollection = Stimulsoft.Report.Gauge.Collections.StiCustomValuesCollection;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGetValueEvent = Stimulsoft.Report.Events.StiGetValueEvent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiLinearTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickLabelBase;
    import IStiTickCustom = Stimulsoft.Report.Gauge.Primitives.IStiTickCustom;
    class StiLinearTickLabelCustom extends StiLinearTickLabelBase implements IStiTickCustom, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        get componentId(): StiComponentId;
        clone(): StiLinearTickLabelCustom;
        private _valueObj;
        get valueObj(): number;
        set valueObj(value: number);
        private _textObj;
        get textObj(): string;
        set textObj(value: string);
        private _values;
        get values(): StiCustomValuesCollection;
        set values(value: StiCustomValuesCollection);
        get localizeName(): string;
        onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _getValueEvent;
        get getValueEvent(): StiGetValueEvent;
        set getValueEvent(value: StiGetValueEvent);
        onGetText(e: StiGetTextEventArgs): void;
        invokeGetText(sender: StiGaugeElement, e: StiGetTextEventArgs): void;
        private _getTextEvent;
        get getTextEvent(): StiGetTextEvent;
        set getTextEvent(value: StiGetTextEvent);
        private _value;
        get value(): string;
        set value(value: string);
        private _text;
        get text(): string;
        set text(value: string);
        createNew(): StiGaugeElement;
        prepareGaugeElement(): void;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare namespace Stimulsoft.Report.Gauge.Collections {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    class StiGaugeElementCollection extends CollectionBase<StiGaugeElement> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, report: StiReport): void;
        private scale;
        private scaleType;
        clone(): StiGaugeElementCollection;
        get isReadOnly(): boolean;
        setByIndex(index: number, value: StiGaugeElement): void;
        toArray(): StiGaugeElement[];
        private addCore;
        add(element: StiGaugeElement): void;
        addRange(elements: StiGaugeElement[]): void;
        insert(index: number, element: StiGaugeElement): void;
        remove(element: StiGaugeElement): boolean;
        copyTo(elements: StiGaugeElement[], arrayIndex: number): void;
        private setItemInternal;
        moveUp(element: StiGaugeElement): boolean;
        moveDown(element: StiGaugeElement): boolean;
        constructor(scale: StiScaleBase);
    }
}
declare namespace Stimulsoft.Report.Gauge.Events {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiGetValueEvent extends StiEvent {
        toString(): string;
    }
}
declare namespace Stimulsoft.Report.Gauge.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiGetValueEventHandler: EventHandler;
    class StiGetValueEventArgs extends EventArgs {
        private _value;
        get value(): any;
        set value(value: any);
    }
}
declare namespace Stimulsoft.Report.Gauge.Helpers {
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiDrawingHelper {
        static getRoundedPath(rect: Rectangle, offset: number, leftTop: number, rightTop: number, rightBottom: number, leftBottom: number): void;
        private static PiDiv180;
        private static FourDivThree;
        static getArcGeometry(rect: Rectangle, startAngle: number, sweepAngle: number, startWidth: number, endWidth: number): void;
        static getRadialRangeGeometry(centerPoint: Point, startAngle: number, sweepAngle: number, radius1: number, radius2: number, radius3: number, radius4: number): void;
        private static round;
        private static convertArcToCubicBezier;
        private static convertArcToCubicBezier2;
    }
}
declare namespace Stimulsoft.Report.Gauge.Helpers {
    import IStiGauge = Stimulsoft.Report.Components.Gauge.IStiGauge;
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    class StiGaugeInitHelper {
        static isGaugeV2(gauge: IStiGauge): boolean;
        static init(gauge: StiGauge, type: StiGaugeType, skipText?: boolean): any;
        static prepare(gauge: IStiGauge): void;
        private static isFullCircularScale;
        private static createFullCircularScale;
        private static isHalfCircularScale;
        private static createHalfCircularScale;
        private static isLinearScale;
        private static createLinearScale;
        private static isBulletScale;
        private static createBullet;
        private static addLinearRanges;
    }
}
declare namespace Stimulsoft.Report.Gauge.Primitives {
    import StiGraphicsPathLinesGaugeGeom = Stimulsoft.Report.Gauge.GaugeGeoms.StiGraphicsPathLinesGaugeGeom;
    import Size = Stimulsoft.System.Drawing.Size;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    let IStiScaleBarGeometry: System.Interface<IStiScaleBarGeometry>;
    interface IStiScaleBarGeometry {
        size: Size;
        rectGeometry: Rectangle;
        center: Point;
        radius: number;
        diameter: number;
        checkRectGeometry(rect: Rectangle): void;
        drawScaleGeometry(context: StiGaugeContextPainter): void;
        getRestToLenght(): number;
        drawGeometry(context: StiGaugeContextPainter, startValue: number, endValue: number, startWidth: number, endWidth: number, offset: number, placement: StiPlacement, REFrect: any, returnOnlyRect: boolean): StiGraphicsPathLinesGaugeGeom;
    }
}
declare namespace Stimulsoft.Report.Gauge.Primitives {
    import StiCustomValuesCollection = Stimulsoft.Report.Gauge.Collections.StiCustomValuesCollection;
    let IStiTickCustom: System.Interface<IStiTickCustom>;
    interface IStiTickCustom {
        valueObj: number;
        values: StiCustomValuesCollection;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    let IStiApplyStyleGauge: System.Interface<IStiApplyStyleGauge>;
    interface IStiApplyStyleGauge {
        applyStyle(style: IStiGaugeStyle): void;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiEmptyBrush = Stimulsoft.Base.Drawing.StiEmptyBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiGaugeStyleCoreXF24 extends StiGaugeStyleCoreXF {
        get localizedName(): string;
        brush: StiSolidBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        targetColor: Color;
        tickMarkMajorBrush: StiSolidBrush;
        tickMarkMajorBorder: StiEmptyBrush;
        tickMarkMinorBrush: StiSolidBrush;
        tickMarkMinorBorder: StiEmptyBrush;
        tickLabelMajorTextBrush: StiSolidBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiSolidBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiSolidBrush;
        linearScaleBrush: StiSolidBrush;
        linearBarBrush: StiSolidBrush;
        linearBarBorderBrush: StiEmptyBrush;
        linearBarEmptyBrush: StiEmptyBrush;
        linearBarEmptyBorderBrush: StiEmptyBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiSolidBrush;
        radialBarBorderBrush: StiEmptyBrush;
        radialBarEmptyBrush: StiSolidBrush;
        radialBarEmptyBorderBrush: StiEmptyBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiSolidBrush;
        needleBorderBrush: StiEmptyBrush;
        needleCapBrush: StiSolidBrush;
        needleCapBorderBrush: StiSolidBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiEmptyBrush = Stimulsoft.Base.Drawing.StiEmptyBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiGaugeStyleCoreXF26 extends StiGaugeStyleCoreXF {
        get localizedName(): string;
        brush: StiSolidBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        targetColor: Color;
        tickMarkMajorBrush: StiSolidBrush;
        tickMarkMajorBorder: StiEmptyBrush;
        tickMarkMinorBrush: StiSolidBrush;
        tickMarkMinorBorder: StiEmptyBrush;
        tickLabelMajorTextBrush: StiSolidBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiSolidBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiSolidBrush;
        linearScaleBrush: StiSolidBrush;
        linearBarBrush: StiSolidBrush;
        linearBarBorderBrush: StiEmptyBrush;
        linearBarEmptyBrush: StiEmptyBrush;
        linearBarEmptyBorderBrush: StiEmptyBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiSolidBrush;
        radialBarBorderBrush: StiEmptyBrush;
        radialBarEmptyBrush: StiSolidBrush;
        radialBarEmptyBorderBrush: StiEmptyBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiSolidBrush;
        needleBorderBrush: StiEmptyBrush;
        needleCapBrush: StiSolidBrush;
        needleCapBorderBrush: StiSolidBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiEmptyBrush = Stimulsoft.Base.Drawing.StiEmptyBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiGaugeStyleCoreXF27 extends StiGaugeStyleCoreXF {
        get localizedName(): string;
        brush: StiSolidBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        targetColor: Color;
        tickMarkMajorBrush: StiEmptyBrush;
        tickMarkMajorBorder: StiEmptyBrush;
        tickMarkMinorBrush: StiEmptyBrush;
        tickMarkMinorBorder: StiEmptyBrush;
        tickLabelMajorTextBrush: StiSolidBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiSolidBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiSolidBrush;
        linearScaleBrush: StiSolidBrush;
        linearBarBrush: StiSolidBrush;
        linearBarBorderBrush: StiEmptyBrush;
        linearBarEmptyBrush: StiEmptyBrush;
        linearBarEmptyBorderBrush: StiEmptyBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiSolidBrush;
        radialBarBorderBrush: StiEmptyBrush;
        radialBarEmptyBrush: StiSolidBrush;
        radialBarEmptyBorderBrush: StiEmptyBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiSolidBrush;
        needleBorderBrush: StiEmptyBrush;
        needleCapBrush: StiSolidBrush;
        needleCapBorderBrush: StiSolidBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiEmptyBrush = Stimulsoft.Base.Drawing.StiEmptyBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiGaugeStyleCoreXF28 extends StiGaugeStyleCoreXF {
        get localizedName(): string;
        brush: StiSolidBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        targetColor: Color;
        tickMarkMajorBrush: StiEmptyBrush;
        tickMarkMajorBorder: StiEmptyBrush;
        tickMarkMinorBrush: StiEmptyBrush;
        tickMarkMinorBorder: StiEmptyBrush;
        tickLabelMajorTextBrush: StiSolidBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiSolidBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiSolidBrush;
        linearScaleBrush: StiSolidBrush;
        linearBarBrush: StiSolidBrush;
        linearBarBorderBrush: StiEmptyBrush;
        linearBarEmptyBrush: StiEmptyBrush;
        linearBarEmptyBorderBrush: StiEmptyBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiSolidBrush;
        radialBarBorderBrush: StiEmptyBrush;
        radialBarEmptyBrush: StiSolidBrush;
        radialBarEmptyBorderBrush: StiEmptyBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiSolidBrush;
        needleBorderBrush: StiEmptyBrush;
        needleCapBrush: StiSolidBrush;
        needleCapBorderBrush: StiSolidBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import Font = Stimulsoft.System.Drawing.Font;
    import StiEmptyBrush = Stimulsoft.Base.Drawing.StiEmptyBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiGaugeStyleCoreXF29 extends StiGaugeStyleCoreXF {
        get localizedName(): string;
        brush: StiSolidBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        targetColor: Color;
        tickMarkMajorBrush: StiSolidBrush;
        tickMarkMajorBorder: StiEmptyBrush;
        tickMarkMinorBrush: StiSolidBrush;
        tickMarkMinorBorder: StiEmptyBrush;
        tickLabelMajorTextBrush: StiSolidBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiSolidBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiSolidBrush;
        linearMarkerBorder: StiSolidBrush;
        linearScaleBrush: StiSolidBrush;
        linearBarBrush: StiSolidBrush;
        linearBarBorderBrush: StiEmptyBrush;
        linearBarEmptyBrush: StiEmptyBrush;
        linearBarEmptyBorderBrush: StiEmptyBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiSolidBrush;
        radialBarBorderBrush: StiEmptyBrush;
        radialBarEmptyBrush: StiSolidBrush;
        radialBarEmptyBorderBrush: StiEmptyBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiSolidBrush;
        needleBorderBrush: StiEmptyBrush;
        needleCapBrush: StiSolidBrush;
        needleCapBorderBrush: StiSolidBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiGaugeStyleCoreXF = Stimulsoft.Report.Gauge.StiGaugeStyleCoreXF;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiGaugeStyleCoreXF30 extends StiGaugeStyleCoreXF {
        get localizedName(): string;
        brush: StiBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        targetColor: Color;
        tickMarkMajorBrush: StiBrush;
        tickMarkMajorBorder: StiBrush;
        tickMarkMinorBrush: StiBrush;
        tickMarkMinorBorder: StiBrush;
        tickLabelMajorTextBrush: StiBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiBrush;
        linearMarkerBorder: StiBrush;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        linearBarBorderBrush: StiBrush;
        linearBarEmptyBrush: StiBrush;
        linearBarEmptyBorderBrush: StiBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiBrush;
        radialBarBorderBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
        radialBarEmptyBorderBrush: StiBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiGaugeStyleCoreXF30 = Stimulsoft.Report.Gauge.StiGaugeStyleCoreXF30;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiGaugeStyleCoreXF31 extends StiGaugeStyleCoreXF30 {
        get localizedName(): string;
        brush: StiBrush;
        targetColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        markerBrush: StiBrush;
        linearMarkerBorder: StiBrush;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        radialBarBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiGaugeStyleCoreXF30 = Stimulsoft.Report.Gauge.StiGaugeStyleCoreXF30;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiGaugeStyleCoreXF32 extends StiGaugeStyleCoreXF30 {
        get localizedName(): string;
        brush: StiBrush;
        targetColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        markerBrush: StiBrush;
        linearMarkerBorder: StiBrush;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        needleCapBorderWidth: number;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        radialBarBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiGaugeStyleCoreXF30 = Stimulsoft.Report.Gauge.StiGaugeStyleCoreXF30;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGaugeStyleCoreXF33 extends StiGaugeStyleCoreXF30 {
        get localizedName(): string;
        brush: StiBrush;
        targetColor: Color;
        foreColor: Color;
        tickLabelMajorTextBrush: StiBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiBrush;
        linearMarkerBorder: StiBrush;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        needleCapBorderWidth: number;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        radialBarBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGaugeStyleCoreXF34 extends StiGaugeStyleCoreXF {
        get localizedName(): string;
        brush: StiBrush;
        borderColor: Color;
        borderWidth: number;
        targetColor: Color;
        foreColor: Color;
        tickMarkMajorBrush: StiBrush;
        tickMarkMajorBorder: StiBrush;
        tickMarkMinorBrush: StiBrush;
        tickMarkMinorBorder: StiBrush;
        tickLabelMajorTextBrush: StiBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiBrush;
        linearMarkerBorder: StiBrush;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        linearBarBorderBrush: StiBrush;
        linearBarEmptyBrush: StiBrush;
        linearBarEmptyBorderBrush: StiBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiBrush;
        radialBarBorderBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
        radialBarEmptyBorderBrush: StiBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF24 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF25 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF28 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF29 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF30 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF31 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF32 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF33 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF34 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        get dashboardName(): string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare namespace Stimulsoft.Reflection {
    class StiTypesHelper {
        static run(type?: Stimulsoft.System.Type, namespace?: string): void;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesAfghanistan {
        static Afghanistan: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesAlbania {
        static Albania: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesAndorra {
        static Andorra: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesArgentina {
        static Argentina: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesArgentinaFD {
        static ArgentinaFD: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesArmenia {
        static Armenia: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesAsia {
        static Asia: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesAustralia {
        static Australia: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesAustria {
        static Austria: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesAzerbaijan {
        static Azerbaijan: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesBelarus {
        static Belarus: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesBelgium {
        static Belgium: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesBenelux {
        static Benelux: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesBolivia {
        static Bolivia: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesBosniaAndHerzegovina {
        static BosniaAndHerzegovina: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesBrazil {
        static Brazil: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesBulgaria {
        static Bulgaria: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesCanada {
        static Canada: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesCentralAfricanRepublic {
        static CentralAfricanRepublic: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesChile {
        static Chile: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesChina {
        static China: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesChinaWithHongKongAndMacau {
        static ChinaWithHongKongAndMacau: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesChinaWithHongKongMacauAndTaiwan {
        static ChinaWithHongKongMacauAndTaiwan: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesColombia {
        static Colombia: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesCroatia {
        static Croatia: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesCyprus {
        static Cyprus: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesCzechRepublic {
        static CzechRepublic: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesDenmark {
        static Denmark: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesEU {
        static EU: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesEcuador {
        static Ecuador: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesEstonia {
        static Estonia: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesEurope {
        static Europe: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesEuropeWithRussia {
        static EuropeWithRussia: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesFalklandIslands {
        static FalklandIslands: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesFinland {
        static Finland: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesFrance {
        static France: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesFrance18Regions {
        static France18Regions: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesFranceDepartments {
        static FranceDepartments: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesGeorgia {
        static Georgia: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesGermany {
        static Germany: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesGreece {
        static Greece: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesGuyana {
        static Guyana: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesHungary {
        static Hungary: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesIceland {
        static Iceland: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesIndia {
        static India: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesIndonesia {
        static Indonesia: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesIreland {
        static Ireland: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesIsrael {
        static Israel: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesItaly {
        static Italy: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesJapan {
        static Japan: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesKazakhstan {
        static Kazakhstan: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesLatvia {
        static Latvia: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesLiechtenstein {
        static Liechtenstein: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesLithuania {
        static Lithuania: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesLuxembourg {
        static Luxembourg: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMacedonia {
        static Macedonia: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMalaysia {
        static Malaysia: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMalta {
        static Malta: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMexico {
        static Mexico: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMiddleEast {
        static MiddleEast: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMoldova {
        static Moldova: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMonaco {
        static Monaco: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesMontenegro {
        static Montenegro: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesNetherlands {
        static Netherlands: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesNewZealand {
        static NewZealand: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesNorthAmerica {
        static NorthAmerica: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesNorway {
        static Norway: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesOceania {
        static Oceania: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesOman {
        static Oman: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesParaguay {
        static Paraguay: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesPeru {
        static Peru: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesPhilippines {
        static Philippines: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesPoland {
        static Poland: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesPortugal {
        static Portugal: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesQatar {
        static Qatar: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesRomania {
        static Romania: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesRussia {
        static Russia: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSanMarino {
        static SanMarino: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSaudiArabia {
        static SaudiArabia: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesScandinavia {
        static Scandinavia: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSerbia {
        static Serbia: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSlovakia {
        static Slovakia: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSlovenia {
        static Slovenia: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSouthAfrica {
        static SouthAfrica: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSouthAmerica {
        static SouthAmerica: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSouthKorea {
        static SouthKorea: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSoutheastAsia {
        static SoutheastAsia: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSpain {
        static Spain: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSuriname {
        static Suriname: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSweden {
        static Sweden: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesSwitzerland {
        static Switzerland: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesTaiwan {
        static Taiwan: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesThailand {
        static Thailand: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesTurkey {
        static Turkey: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesUK {
        static UK: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesUKCountries {
        static UKCountries: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesUSA {
        static USA: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesUSAAndCanada {
        static USAAndCanada: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesUkraine {
        static Ukraine: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesUruguay {
        static Uruguay: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesVatican {
        static Vatican: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesVenezuela {
        static Venezuela: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesVietnam {
        static Vietnam: string;
    }
}
declare namespace Stimulsoft.Report.Maps {
    class StiMapResourcesWorld {
        static World: string;
    }
}
declare namespace Stimulsoft.Dashboard {
    enum StiTextFormatState {
        None = 0,
        DecimalDigits = 1,
        DecimalSeparator = 2,
        GroupSeparator = 4,
        GroupSize = 8,
        PositivePattern = 16,
        NegativePattern = 32,
        CurrencySymbol = 64,
        PercentageSymbol = 128,
        Abbreviation = 256,
        NegativeInRed = 512
    }
    enum StiFilterCondition {
        EqualTo = 0,
        NotEqualTo = 1,
        GreaterThan = 2,
        GreaterThanOrEqualTo = 3,
        LessThan = 4,
        LessThanOrEqualTo = 5,
        Between = 6,
        NotBetween = 7,
        Containing = 8,
        NotContaining = 9,
        BeginningWith = 10,
        EndingWith = 11,
        IsNull = 12,
        IsNotNull = 13
    }
    enum StiFilterItem {
        Argument = 0,
        Value = 1,
        ValueEnd = 2,
        Expression = 3,
        ValueOpen = 4,
        ValueClose = 5,
        ValueLow = 6,
        ValueHigh = 7
    }
    enum StiFilterDataType {
        String = 0,
        Numeric = 1,
        DateTime = 2,
        Boolean = 3,
        Expression = 4
    }
}
declare namespace Stimulsoft.Dashboard.Components {
    enum StiMeterIdent {
        ArgumentChartMeter = 1,
        SeriesChartMeter = 2,
        ValueChartMeter = 3,
        StartValueChartMeter = 4,
        EndValueChartMeter = 5,
        OpenValueChartMeter = 6,
        CloseValueChartMeter = 7,
        LowValueChartMeter = 8,
        HighValueChartMeter = 9,
        WeightChartMeter = 10,
        XChartMeter = 11,
        YChartMeter = 12,
        MaxGaugeMeter = 13,
        MinGaugeMeter = 14,
        SeriesGaugeMeter = 15,
        ValueGaugeMeter = 16,
        TargetGaugeMeter = 17,
        SeriesIndicatorMeter = 18,
        TargetIndicatorMeter = 19,
        ValueIndicatorMeter = 20,
        SeriesProgressMeter = 21,
        TargetProgressMeter = 22,
        ValueProgressMeter = 23,
        LatitudeMapMeter = 24,
        LongitudeMapMeter = 25,
        LocationMapMeter = 26,
        LocationValueMapMeter = 27,
        LocationColorMapMeter = 28,
        LocationArgumentMapMeter = 29,
        KeyMapMeter = 30,
        NameMapMeter = 31,
        ValueMapMeter = 32,
        GroupMapMeter = 33,
        ColorMapMeter = 34,
        ColorScaleColumn = 35,
        DataBarsColumn = 36,
        DimensionColumn = 37,
        IndicatorColumn = 38,
        MeasureColumn = 39,
        SparklinesColumn = 40,
        BubbleColumn = 41,
        PivotColumn = 42,
        PivotRow = 43,
        PivotSummary = 44,
        NameListBoxMeter = 45,
        KeyListBoxMeter = 46,
        KeyTreeViewMeter = 47,
        KeyTreeViewBoxMeter = 48,
        NameComboBoxMeter = 49,
        KeyComboBoxMeter = 50,
        ValueDatePickerMeter = 51,
        TextMeter = 52,
        ImageMeter = 53
    }
}
declare namespace Stimulsoft.Dashboard.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiMargins = Stimulsoft.Report.Components.StiMargins;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiDashboard = Stimulsoft.Report.Dashboard.IStiDashboard;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiDashboardViewMode = Stimulsoft.Report.Components.StiDashboardViewMode;
    import StiDashboardContentAlignment = Stimulsoft.Report.Dashboard.StiDashboardContentAlignment;
    class StiDashboard extends StiPage implements IStiDashboard, IStiJsonReportObject {
        private static ImplementsStiDashboard;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        getMeters(nested?: boolean, group?: string): List<IStiMeter>;
        getElements(nested?: boolean, group?: string): List<IStiElement>;
        getUserFilters(element: IStiElement): List<StiDataFilterRule>;
        private getUserFilters3;
        getUnplacedElements(): List<IStiElement>;
        switchDashboardViewMode(value: StiDashboardViewMode): void;
        removeMobileSurface(): void;
        fetchAllMeters(): List<IStiMeter>;
        getNestedPages(): List<StiPage>;
        get isEnabled(): boolean;
        get isDefined(): boolean;
        get isQuerable(): boolean;
        backColor: Color;
        private shouldSerializeBackColor;
        retrieveUsedDataNames(group: string): List<string>;
        getDictionary(): IStiAppDictionary;
        getDataSources(dataNames: List<string>): List<IStiAppDataSource>;
        get serviceCategory(): string;
        get componentId(): StiComponentId;
        get localizedName(): string;
        margins: StiMargins;
        get gridSize(): number;
        get unit(): StiUnit;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        get skip(): boolean;
        set skip(value: boolean);
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        getKey(): string;
        createNew(): StiComponent;
        get key(): string;
        set key(value: string);
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        private _width2;
        get width(): number;
        set width(value: number);
        private _height2;
        get height(): number;
        set height(value: number);
        private _altSize;
        get altSize(): SizeD;
        set altSize(value: SizeD);
        private _dashboardViewMode;
        get dashboardViewMode(): StiDashboardViewMode;
        set dashboardViewMode(value: StiDashboardViewMode);
        private _contentAlignment;
        get contentAlignment(): StiDashboardContentAlignment;
        set contentAlignment(value: StiDashboardContentAlignment);
        private _altContentAlignment;
        get altContentAlignment(): StiDashboardContentAlignment;
        set altContentAlignment(value: StiDashboardContentAlignment);
        private _deviceWidth;
        get deviceWidth(): number;
        set deviceWidth(value: number);
        get isMobileSurfacePresent(): boolean;
        constructor(report?: StiReport);
    }
}
declare namespace Stimulsoft.Dashboard.Components {
    import StiReport = Stimulsoft.Report.StiReport;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiLocalizedMeter = Stimulsoft.Base.Meters.IStiLocalizedMeter;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiMeter implements IStiMeter, IStiLocalizedMeter, IStiJsonReportObject {
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        private static ImplementsStiMeter;
        implements(): any[];
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        saveToString(): string;
        loadFromString(str: string): void;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean, report?: StiReport): void;
        getUniqueCode(): number;
        expression: string;
        label: string;
        get localizedName(): string;
        ident: StiMeterIdent;
        key: string;
        isDefault(): boolean;
        getIsDefault(): boolean;
        toString(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components {
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    class StiDimensionMeter extends StiMeter implements IStiDimensionMeter {
        private static ImplementsStiDimensionMeter;
        implements(): any[];
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Panel {
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiDashboard = Stimulsoft.Report.Dashboard.IStiDashboard;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiToolboxCategory = Stimulsoft.Report.Components.StiToolboxCategory;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiPadding = Stimulsoft.Report.Dashboard.StiPadding;
    import StiMargin = Stimulsoft.Report.Dashboard.StiMargin;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiMargin = Stimulsoft.Report.Dashboard.IStiMargin;
    import IStiPadding = Stimulsoft.Report.Dashboard.IStiPadding;
    import IStiPanel = Stimulsoft.Report.Dashboard.IStiPanel;
    import IStiSimpleBorder = Stimulsoft.Report.Components.IStiSimpleBorder;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiAltProperties = Stimulsoft.Report.Dashboard.IStiAltProperties;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPanelElement extends StiPanel implements IStiSimpleBorder, IStiPanel, IStiPadding, IStiMargin, IStiAltProperties, IStiJsonReportObject {
        private static ImplementsStiPanelElement;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        getMeters(nested?: boolean, group?: string): List<IStiMeter>;
        getElements(nested?: boolean, group?: string): List<IStiElement>;
        fetchAllMeters(): List<IStiMeter>;
        getMeters2(): List<IStiMeter>;
        getFilterRules(): List<StiDataFilterRule>;
        getNestedPages(): List<StiPage>;
        get dashboard(): IStiDashboard;
        get isDefined(): boolean;
        get isQuerable(): boolean;
        get isEnabled(): boolean;
        get zoom(): number;
        retrieveUsedDataNames(group: string): List<string>;
        getDictionary(): IStiAppDictionary;
        getDataSources(dataNames: List<string>): List<IStiAppDataSource>;
        margin: StiMargin;
        private shouldSerializeMargin;
        padding: StiPadding;
        shouldSerializePadding(): boolean;
        border2: StiSimpleBorder;
        private shouldSerializeBorder;
        backColor: Color;
        private shouldSerializeBackColor;
        altTitleVisible: boolean;
        altClientRectangle: RectangleD;
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        get brush(): StiBrush;
        set brush(value: StiBrush);
        get serviceCategory(): string;
        get localizedCategory(): string;
        get toolboxCategory(): StiToolboxCategory;
        canContainIn(component: StiComponent): boolean;
        createNew(): StiComponent;
        get key(): string;
        set key(value: string);
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components {
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiToolboxCategory = Stimulsoft.Report.Components.StiToolboxCategory;
    import StiMargin = Stimulsoft.Report.Dashboard.StiMargin;
    import StiPadding = Stimulsoft.Report.Dashboard.StiPadding;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiDashboard = Stimulsoft.Report.Dashboard.IStiDashboard;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiMargin = Stimulsoft.Report.Dashboard.IStiMargin;
    import IStiPadding = Stimulsoft.Report.Dashboard.IStiPadding;
    import IStiBackColor = Stimulsoft.Report.Components.IStiBackColor;
    import IStiSimpleBorder = Stimulsoft.Report.Components.IStiSimpleBorder;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiAltProperties = Stimulsoft.Report.Dashboard.IStiAltProperties;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiElement extends StiComponent implements IStiElement, IStiSimpleBorder, IStiBackColor, IStiPadding, IStiMargin, IStiAltProperties, IStiJsonReportObject {
        private static ImplementsStiElement;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        get dashboard(): IStiDashboard;
        get isDefined(): boolean;
        get isQuerable(): boolean;
        get isEnabled(): boolean;
        get zoom(): number;
        retrieveUsedDataNames2(group: string): List<string>;
        retrieveUsedDataNames(): List<string>;
        getDictionary(): IStiAppDictionary;
        getDataSources(dataNames: List<string>): List<IStiAppDataSource>;
        clone(cloneProperties: boolean): any;
        border2: StiSimpleBorder;
        private shouldSerializeBorder;
        backColor: Color;
        private shouldSerializeBackColor;
        margin: StiMargin;
        private shouldSerializeMargin;
        padding: StiPadding;
        shouldSerializePadding(): boolean;
        altTitleVisible: boolean;
        altClientRectangle: RectangleD;
        get serviceCategory(): string;
        canContainIn(component: StiComponent): boolean;
        toolboxCategory: StiToolboxCategory;
        get localizedCategory(): string;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        get key(): string;
        set key(value: string);
        getNestedPages(): List<StiPage>;
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components {
    import IStiMeasureMeter = Stimulsoft.Base.Meters.IStiMeasureMeter;
    class StiMeasureMeter extends StiMeter implements IStiMeasureMeter {
        private static ImplementsStiMeasureMeter;
        implements(): any[];
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiTitle = Stimulsoft.Report.Dashboard.IStiTitle;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiTitle implements ICloneable, IStiJsonReportObject, IStiTitle {
        private static ImplementsStiTitle;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        static createFromJsonObject(jObject: StiJson): StiTitle;
        static createFromXml(xmlNode: XmlNode): StiTitle;
        clone(): any;
        horAlignment: StiHorAlignment;
        font: Font;
        private shouldSerializeFont;
        backColor: Color;
        private shouldSerializeBackColor;
        foreColor: Color;
        private shouldSerializeForeColor;
        text: string;
        visible: boolean;
        constructor(text?: string, foreColor?: Color, backColor?: Color, font?: Font, alignment?: StiHorAlignment, visible?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    enum StiChartLabelsStyle {
        Value = 0,
        PercentOfTotal = 1,
        Category = 2,
        CategoryValue = 3,
        CategoryPercentOfTotal = 4
    }
    enum StiLegendVisibility {
        False = 0,
        Auto = 1,
        Always = 2
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiArgumentMeter = Stimulsoft.Base.Meters.IStiArgumentMeter;
    class StiArgumentChartMeter extends StiDimensionMeter implements IStiArgumentMeter {
        private static ImplementsStiArgumentChartMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiChartArea = Stimulsoft.Report.Dashboard.IStiChartArea;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiChartArea implements IStiJsonReportObject, IStiChartArea {
        private static ImplementsStiChartArea;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(): StiChartArea;
        colorEach: boolean;
        reverseHor: boolean;
        reverseVert: boolean;
        interlacingHor: StiHorChartInterlacing;
        interlacingVert: StiVertChartInterlacing;
        gridLinesHor: StiHorChartGridLines;
        gridLinesVert: StiVertChartGridLines;
        xAxis: StiXChartAxis;
        private shouldSerializeXAxis;
        xTopAxis: StiXTopChartAxis;
        private shouldSerializeXTopAxis;
        yAxis: StiYChartAxis;
        private shouldSerializeYAxis;
        yRightAxis: StiYRightChartAxis;
        private shouldSerializeYRightAxis;
        constructor(colorEach?: boolean, reverseHor?: boolean, reverseVert?: boolean, gridLinesHor?: StiHorChartGridLines, gridLinesVert?: StiVertChartGridLines, interlacingHor?: StiHorChartInterlacing, interlacingVert?: StiVertChartInterlacing, xAxis?: StiXChartAxis, yAxis?: StiYChartAxis, xTopAxis?: StiXTopChartAxis, yRightAxis?: StiYRightChartAxis);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiLabelsPlacement = Stimulsoft.Report.Chart.StiLabelsPlacement;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiChartAxisLabels implements ICloneable, IStiFont, IStiJsonReportObject {
        private static ImplementsStiChartAxisLabels;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(): any;
        angle: number;
        color: Color;
        shouldSerializeColor(): boolean;
        font: Font;
        shouldSerializeFont(): boolean;
        placement: StiLabelsPlacement;
        textAlignment: StiHorAlignment;
        textAfter: string;
        textBefore: string;
        step: number;
        isDefault(): boolean;
        constructor(textBefore?: string, textAfter?: string, angle?: number, font?: Font, placement?: StiLabelsPlacement, color?: Color, textAlignment?: StiHorAlignment);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import IStiDefault = Stimulsoft.Base.Design.IStiDefault;
    import StiChartAxisLabels = Stimulsoft.Dashboard.Components.Chart.StiChartAxisLabels;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiChartAxis implements IStiJsonReportObject, IStiDefault, ICloneable, IAsIs {
        private static ImplementsStiChartAxis;
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        clone(): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        labels: StiChartAxisLabels;
        shouldSerializeLabels(): boolean;
        range: StiChartAxisRange;
        shouldSerializeRange(): boolean;
        visible: boolean;
        isDefault(): boolean;
        constructor(labels?: StiChartAxisLabels, range?: StiChartAxisRange, visible?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiChartAxisRange implements IStiJsonReportObject, ICloneable {
        private static ImplementsStiChartAxisRange;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(): any;
        _minimum: number;
        get minimum(): number;
        set minimum(value: number);
        maximum: number;
        auto: boolean;
        isDefault(): boolean;
        constructor(auto?: boolean, minimum?: number, maximum?: number);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IAsIs = Stimulsoft.System.IAsIs;
    import IStiDefault = Stimulsoft.Base.Design.IStiDefault;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiTitlePosition = Stimulsoft.Report.Chart.StiTitlePosition;
    import Color = Stimulsoft.System.Drawing.Color;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    enum Order {
        Alignment = 1,
        Color = 2,
        Direction = 3,
        Font = 4,
        Placement = 5,
        Position = 6,
        Text = 7,
        Visible = 8
    }
    class StiChartAxisTitle implements IStiJsonReportObject, IStiDefault, IAsIs {
        private static ImplementsStiChartAxisTitle;
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(): any;
        visible: boolean;
        alignment: StringAlignment;
        color: Color;
        private shouldSerializeColor;
        font: Font;
        private shouldSerializeFont;
        position: StiTitlePosition;
        text: string;
        isDefault(): boolean;
        constructor(font?: Font, text?: string, color?: Color, alignment?: StringAlignment, position?: StiTitlePosition, visible?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import StiConstantLines_StiTextPosition = Stimulsoft.Report.Chart.StiConstantLines_StiTextPosition;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiChartConstantLines = Stimulsoft.Report.Dashboard.IStiChartConstantLines;
    class StiChartConstantLines implements ICloneable, IStiChartConstantLines, IStiJsonReportObject {
        private static ImplementsStiChartConstantLines;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiChartConstantLines;
        text: string;
        lineStyle: StiPenStyle;
        lineColor: Color;
        axisValue: string;
        lineWidth: number;
        position: StiConstantLines_StiTextPosition;
        static createFromJson(json: StiJson): StiChartConstantLines;
        static createFromXml(xmlNode: XmlNode): StiChartConstantLines;
        constructor(text?: string, axisValue?: string, lineColor?: Color, lineStyle?: StiPenStyle, lineWidth?: number, position?: StiConstantLines_StiTextPosition);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import StiMarkerType = Stimulsoft.Report.Chart.StiMarkerType;
    import StiExtendedStyleBool = Stimulsoft.Report.Chart.StiExtendedStyleBool;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiChartMarker implements ICloneable, IStiJsonReportObject {
        private static ImplementsStiChartMarker;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(): StiChartMarker;
        isDefault(): boolean;
        size: number;
        angle: number;
        type: StiMarkerType;
        visible: StiExtendedStyleBool;
        static createFromJson(json: StiJson): StiChartConstantLines;
        static createFromXml(xmlNode: XmlNode): StiChartConstantLines;
        constructor(size?: number);
    }
}
declare namespace Stimulsoft.Dashboard.Components.TreeViewBox {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiKeyTreeViewBoxMeter extends StiDimensionMeter implements IStiValueMeter {
        private static ImplementsStiKeyTreeViewBoxMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.TreeView {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiKeyTreeViewMeter extends StiDimensionMeter implements IStiValueMeter {
        private static ImplementsStiKeyTreeViewMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Interactions.Design {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDashboardInteractionLoader {
        static loadInteractionFromJsonObject(jObject: StiJson): StiDashboardInteraction;
        static loadInteractionFromXml(xmlNode: XmlNode, isDocument: boolean): StiDashboardInteraction;
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    import IStiDashboardDrillDownParameter = Stimulsoft.Report.Dashboard.IStiDashboardDrillDownParameter;
    import List = Stimulsoft.System.Collections.List;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    import StiAvailableInteractionOnHover = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnHover;
    import StiAvailableInteractionOnDataManipulation = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnDataManipulation;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDashboardInteraction implements IStiDashboardInteraction, IStiJsonReportObject {
        private static ImplementsStiDashboardInteraction;
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        isDefault(): boolean;
        getDrillDownParameters(): List<IStiDashboardDrillDownParameter>;
        setDrillDownParameters(drillDownParameters: any[]): void;
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        availableOnHover: StiAvailableInteractionOnHover;
        availableOnDataManipulation: StiAvailableInteractionOnDataManipulation;
        onHover: StiInteractionOnHover;
        shouldSerializeOnHover(): boolean;
        onClick: StiInteractionOnClick;
        shouldSerializeOnClick(): boolean;
        hyperlinkDestination: StiInteractionOpenHyperlinkDestination;
        toolTip: string;
        hyperlink: string;
        drillDownPageKey: string;
        drillDownParameters: List<StiDashboardDrillDownParameter>;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>);
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    import List = Stimulsoft.System.Collections.List;
    class StiTableColumnDashboardInteraction extends StiDashboardInteraction {
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        onHover: StiInteractionOnHover;
        onClick: StiInteractionOnClick;
        isDefault(): boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    import IStiDataFormat = Stimulsoft.Data.Engine.IStiDataFormat;
    import StiDataFormatKind = Stimulsoft.Data.Engine.StiDataFormatKind;
    import StiSummaryColumnType = Stimulsoft.Base.StiSummaryColumnType;
    import StiReport = Stimulsoft.Report.StiReport;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import StiTableColumnDashboardInteraction = Stimulsoft.Dashboard.Interactions.StiTableColumnDashboardInteraction;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiTableColumn = Stimulsoft.Base.Meters.IStiTableColumn;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    class StiTableColumn extends StiMeter implements IStiHorAlignment, IStiTextFormat, IStiDataFormat, IStiTableColumn, IStiForeColor, IStiJsonReportObject, IStiElementInteraction {
        private static ImplementsStiTableColumn;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean, report?: StiReport): void;
        clone(): any;
        horAlignment: StiHorAlignment;
        textFormat: StiFormatService;
        private shouldSerializeTextFormat;
        getDataFormat(): StiDataFormatKind;
        foreColor: Color;
        private shouldSerializeForeColor;
        dashboardInteraction: IStiDashboardInteraction;
        private shouldSerializeDashboardInteraction;
        isDefault(): boolean;
        getUniqueCode(): number;
        get visible(): boolean;
        set visible(value: boolean);
        visibility: StiTableColumnVisibility;
        visibilityExpression: string;
        showTotalSummary: boolean;
        summaryType: StiSummaryColumnType;
        summaryAlignment: StiHorAlignment;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, visibility?: StiTableColumnVisibility, visibilityExpression?: string, foreColor?: Color, showTotalSummary?: boolean, summaryType?: StiSummaryColumnType, summaryAlignment?: StiHorAlignment, interaction?: StiTableColumnDashboardInteraction);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    import StiTableColumnDashboardInteraction = Stimulsoft.Dashboard.Interactions.StiTableColumnDashboardInteraction;
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiMeasureMeter = Stimulsoft.Base.Meters.IStiMeasureMeter;
    import IStiMeasureColumn = Stimulsoft.Base.Meters.IStiMeasureColumn;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiSummaryColumnType = Stimulsoft.Base.StiSummaryColumnType;
    class StiMeasureColumn extends StiTableColumn implements IStiMeasureMeter, IStiMeasureColumn {
        private static ImplementsStiMeasureColumn;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, visibility?: StiTableColumnVisibility, visibilityExpression?: string, foreColor?: Color, showTotalSummary?: boolean, summaryType?: StiSummaryColumnType, summaryAlignment?: StiHorAlignment, interaction?: StiTableColumnDashboardInteraction);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    import StiSummaryColumnType = Stimulsoft.Base.StiSummaryColumnType;
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiIndicatorColumn = Stimulsoft.Base.Meters.IStiIndicatorColumn;
    class StiIndicatorColumn extends StiMeasureColumn implements IStiIndicatorColumn {
        private static ImplementsStiIndicatorColumn;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, visibility?: StiTableColumnVisibility, visibilityExpression?: string, foreColor?: Color, showTotalSummary?: boolean, summaryType?: StiSummaryColumnType, summaryAlignment?: StiHorAlignment);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    import StiSummaryColumnType = Stimulsoft.Base.StiSummaryColumnType;
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiReport = Stimulsoft.Report.StiReport;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiColorScaleColumn = Stimulsoft.Base.Meters.IStiColorScaleColumn;
    class StiColorScaleColumn extends StiMeasureColumn implements IStiColorScaleColumn, IStiJsonReportObject {
        private static ImplementsStiColorScaleColumn;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean, report?: StiReport): void;
        getUniqueCode(): number;
        isDefault(): boolean;
        ident: StiMeterIdent;
        minimumColor: Color;
        private shouldSerializeMinimumColor;
        maximumColor: Color;
        private shouldSerializeMaximumColor;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, visibility?: StiTableColumnVisibility, visibilityExpression?: string, foreColor?: Color, showTotalSummary?: boolean, summaryType?: StiSummaryColumnType, summaryAlignment?: StiHorAlignment, minimumColor?: Color, maximumColor?: Color);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    import StiSummaryColumnType = Stimulsoft.Base.StiSummaryColumnType;
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    import StiReport = Stimulsoft.Report.StiReport;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiDataBarsColumn = Stimulsoft.Base.Meters.IStiDataBarsColumn;
    class StiDataBarsColumn extends StiMeasureColumn implements IStiDataBarsColumn, IStiJsonReportObject {
        private static ImplementsStiDataBarsColumn;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean, report?: StiReport): void;
        getUniqueCode(): number;
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, visibility?: StiTableColumnVisibility, visibilityExpression?: string, foreColor?: Color, showTotalSummary?: boolean, summaryType?: StiSummaryColumnType, summaryAlignment?: StiHorAlignment);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    import StiReport = Stimulsoft.Report.StiReport;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiSparklinesColumn = Stimulsoft.Base.Meters.IStiSparklinesColumn;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiSummaryColumnType = Stimulsoft.Base.StiSummaryColumnType;
    class StiSparklinesColumn extends StiMeasureColumn implements IStiSparklinesColumn, IStiJsonReportObject {
        private static ImplementsStiSparklinesColumn;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean, report?: StiReport): void;
        type: StiSparklinesType;
        showHighLowPoints: boolean;
        showFirstLastPoints: boolean;
        allowCustomColors: boolean;
        positiveColor: Color;
        negativeColor: Color;
        shouldSerializePositiveColor(): boolean;
        shouldSerializeNegativeColor(): boolean;
        getUniqueCode(): number;
        isDefault(): boolean;
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, type?: StiSparklinesType, showHighLowPoints?: boolean, showFirstLastPoints?: boolean, visibility?: StiTableColumnVisibility, visibilityExpression?: string, foreColor?: Color, showTotalSummary?: boolean, summaryType?: StiSummaryColumnType, summaryAlignment?: StiHorAlignment, allowCustomColors?: boolean, positiveColor?: Color, negativeColor?: Color);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    import StiSummaryColumnType = Stimulsoft.Base.StiSummaryColumnType;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiReport = Stimulsoft.Report.StiReport;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiBubbleColumn = Stimulsoft.Base.Meters.IStiBubbleColumn;
    class StiBubbleColumn extends StiMeasureColumn implements IStiBubbleColumn, IStiJsonReportObject {
        private static ImplementsStiBubbleColumn;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean, report?: StiReport): void;
        getUniqueCode(): number;
        isDefault(): boolean;
        ident: StiMeterIdent;
        allowCustomColors: boolean;
        positiveColor: Color;
        private shouldSerializePositiveColor;
        negativeColor: Color;
        private shouldSerializeNegativeColor;
        horAlignment: StiHorAlignment;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, visibility?: StiTableColumnVisibility, visibilityExpression?: string, foreColor?: Color, showTotalSummary?: boolean, summaryType?: StiSummaryColumnType, summaryAlignment?: StiHorAlignment, allowCustomColors?: boolean, positiveColor?: Color, negativeColor?: Color);
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiCultureHelper {
        static set(report: StiReport): CultureInfo;
        static restore(culture: CultureInfo): void;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiBooleanFormatService = Stimulsoft.Report.Components.TextFormats.StiBooleanFormatService;
    import StiDateFormatService = Stimulsoft.Report.Components.TextFormats.StiDateFormatService;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiTableElement = Stimulsoft.Dashboard.Components.Table.StiTableElement;
    import StiNumberFormatService = Stimulsoft.Report.Components.TextFormats.StiNumberFormatService;
    import StiPercentageFormatService = Stimulsoft.Report.Components.TextFormats.StiPercentageFormatService;
    import StiCurrencyFormatService = Stimulsoft.Report.Components.TextFormats.StiCurrencyFormatService;
    import StiGeneralFormatService = Stimulsoft.Report.Components.TextFormats.StiGeneralFormatService;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    class StiTextFormatHelper {
        private static _defaultGeneralFormat;
        static get defaultGeneralFormat(): StiGeneralFormatService;
        private static _defaultCurrencyFormat;
        static get defaultCurrencyFormat(): StiCurrencyFormatService;
        private static _defaultPercentageFormat;
        static get defaultPercentageFormat(): StiPercentageFormatService;
        private static _defaultNumberFormat;
        static get defaultNumberFormat(): StiNumberFormatService;
        private static _defaultIntegerFormat;
        static get defaultIntegerFormat(): StiNumberFormatService;
        private static _defaultDateFormat;
        static get defaultDateFormat(): StiDateFormatService;
        private static _defaultBooleanFormat;
        static get defaultBooleanFormat(): StiBooleanFormatService;
        static formatBasedOnColumnType(table: StiTableElement, column: StiTableColumn, value: any): string;
        static format(report: StiReport, format: StiFormatService, value: any): string;
        static formatAsPercentage(report: StiReport, value: any): string;
        static formatAsPercentage2(report: StiReport, format: StiFormatService, value: any): string;
        static getDefaultFormatForColumn(cell: IStiAppDataCell): StiFormatService;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    import StiSummaryColumnType = Stimulsoft.Base.StiSummaryColumnType;
    import StiTableColumnVisibility = Stimulsoft.Base.Drawing.StiTableColumnVisibility;
    import StiTableColumnSize = Stimulsoft.Report.Dashboard.StiTableColumnSize;
    import IStiTableColumnSize = Stimulsoft.Report.Dashboard.IStiTableColumnSize;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import IStiDimensionColumn = Stimulsoft.Base.Meters.IStiDimensionColumn;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    class StiDimensionColumn extends StiTableColumn implements IStiDimensionMeter, IStiDimensionColumn, IStiTableColumnSize {
        private static ImplementsStiDimensionColumn;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean, report?: StiReport): void;
        clone(): any;
        ident: StiMeterIdent;
        get localizedName(): string;
        showHyperlink: boolean;
        hyperlinkPattern: string;
        size: StiTableColumnSize;
        private shouldSerializeSize;
        checkRules(): void;
        isDefault(): boolean;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, visibility?: StiTableColumnVisibility, visibilityExpression?: string, visible?: boolean, foreColor?: Color, showHyperlink?: boolean, hyperlinkPattern?: string, showTotalSummary?: boolean, summaryType?: StiSummaryColumnType, summaryAlignment?: StiHorAlignment, size?: StiTableColumnSize);
    }
}
declare namespace Stimulsoft.Dashboard.Components.RegionMap {
    import IStiColorMapMeter = Stimulsoft.Base.Meters.IStiColorMapMeter;
    class StiColorMapMeter extends StiDimensionMeter implements IStiColorMapMeter {
        private static ImplementsStiColorMapMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.RegionMap {
    import IStiValueMapMeter = Stimulsoft.Base.Meters.IStiValueMapMeter;
    class StiValueMapMeter extends StiMeasureMeter implements IStiValueMapMeter {
        private static ImplementsStiValueMapMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.RegionMap {
    import IStiGroupMapMeter = Stimulsoft.Base.Meters.IStiGroupMapMeter;
    class StiGroupMapMeter extends StiDimensionMeter implements IStiGroupMapMeter {
        private static ImplementsStiGroupMapMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.RegionMap {
    import IStiNameMapMeter = Stimulsoft.Base.Meters.IStiNameMapMeter;
    class StiNameMapMeter extends StiDimensionMeter implements IStiNameMapMeter {
        private static ImplementsStiNameMapMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.RegionMap {
    import IStiKeyMapMeter = Stimulsoft.Base.Meters.IStiKeyMapMeter;
    class StiKeyMapMeter extends StiDimensionMeter implements IStiKeyMapMeter {
        private static ImplementsStiKeyMapMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Progress {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiValueProgressMeter extends StiMeasureMeter implements IStiValueMeter {
        private static ImplementsStiValueProgressMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Progress {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiTargetProgressMeter extends StiMeasureMeter implements IStiValueMeter {
        private static ImplementsStiValueProgressMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Progress {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiSeriesProgressMeter extends StiDimensionMeter implements IStiValueMeter {
        private static ImplementsStiSeriesProgressMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.PivotTable {
    import IStiTableColumnSize = Stimulsoft.Report.Dashboard.IStiTableColumnSize;
    import StiTableColumnSize = Stimulsoft.Report.Dashboard.StiTableColumnSize;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiPivotColumn = Stimulsoft.Base.Meters.IStiPivotColumn;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    import IStiDataTopN = Stimulsoft.Data.Engine.IStiDataTopN;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    class StiPivotColumn extends StiMeter implements IStiDimensionMeter, IStiHorAlignment, IStiTextFormat, IStiTableColumnSize, IStiPivotColumn, IStiDataTopN, IStiJsonReportObject {
        private static ImplementsStiPivotColumn;
        implements(): any[];
        clone(): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        horAlignment: StiHorAlignment;
        textFormat: StiFormatService;
        private shouldSerializeTextFormat;
        size: StiTableColumnSize;
        private shouldSerializeSize;
        topN: StiDataTopN;
        getUniqueCode(): number;
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, topN?: StiDataTopN, size?: StiTableColumnSize);
    }
}
declare namespace Stimulsoft.Dashboard.Components.PivotTable {
    import StiTableColumnSize = Stimulsoft.Report.Dashboard.StiTableColumnSize;
    import IStiTableColumnSize = Stimulsoft.Report.Dashboard.IStiTableColumnSize;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiPivotRow = Stimulsoft.Base.Meters.IStiPivotRow;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    import IStiDataTopN = Stimulsoft.Data.Engine.IStiDataTopN;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    class StiPivotRow extends StiMeter implements IStiDimensionMeter, IStiHorAlignment, IStiTextFormat, IStiTableColumnSize, IStiPivotRow, IStiDataTopN, IStiJsonReportObject {
        private static ImplementsStiPivotRow;
        implements(): any[];
        clone(): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        horAlignment: StiHorAlignment;
        textFormat: StiFormatService;
        private shouldSerializeTextFormat;
        size: StiTableColumnSize;
        private shouldSerializeSize;
        topN: StiDataTopN;
        getUniqueCode(): number;
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, topN?: StiDataTopN, size?: StiTableColumnSize);
    }
}
declare namespace Stimulsoft.Dashboard.Components.PivotTable {
    import StiTableColumnSize = Stimulsoft.Report.Dashboard.StiTableColumnSize;
    import IStiTableColumnSize = Stimulsoft.Report.Dashboard.IStiTableColumnSize;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiPivotSummary = Stimulsoft.Base.Meters.IStiPivotSummary;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    class StiPivotSummary extends StiMeasureMeter implements IStiHorAlignment, IStiTextFormat, IStiTableColumnSize, IStiPivotSummary, IStiJsonReportObject {
        private static ImplementsStiPivotSummary;
        implements(): any[];
        clone(): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        horAlignment: StiHorAlignment;
        textFormat: StiFormatService;
        private shouldSerializeTextFormat;
        size: StiTableColumnSize;
        private shouldSerializeSize;
        getUniqueCode(): number;
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, size?: StiTableColumnSize);
    }
}
declare namespace Stimulsoft.Dashboard.Components.OnlineMap {
    class StiLatitudeMapMeter extends StiDimensionMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.OnlineMap {
    class StiLongitudeMapMeter extends StiDimensionMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.ListBox {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiKeyListBoxMeter extends StiDimensionMeter implements IStiValueMeter {
        private static ImplementsStiKeyListBoxMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.ListBox {
    import IStiArgumentMeter = Stimulsoft.Base.Meters.IStiArgumentMeter;
    class StiNameListBoxMeter extends StiDimensionMeter implements IStiArgumentMeter {
        private static ImplementsStiNameListBoxMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.DatePicker {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiValueDatePickerMeter extends StiDimensionMeter implements IStiValueMeter {
        private static ImplementsStiValueDatePickerMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    class StiEndValueChartMeter extends StiMeasureMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.ComboBox {
    import IStiArgumentMeter = Stimulsoft.Base.Meters.IStiArgumentMeter;
    class StiNameComboBoxMeter extends StiDimensionMeter implements IStiArgumentMeter {
        private static ImplementsStiNameComboBoxMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.ComboBox {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiKeyComboBoxMeter extends StiDimensionMeter implements IStiValueMeter {
        private static ImplementsStiKeyComboBoxMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Gauge {
    import IStiSeriesMeter = Stimulsoft.Base.Meters.IStiSeriesMeter;
    class StiSeriesGaugeMeter extends StiDimensionMeter implements IStiSeriesMeter {
        private static ImplementsStiSeriesGaugeMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Gauge {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiValueGaugeMeter extends StiMeasureMeter implements IStiValueMeter {
        private static ImplementsStiValueGaugeMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Gauge {
    import IStiTargetMeter = Stimulsoft.Base.Meters.IStiTargetMeter;
    class StiTargetGaugeMeter extends StiMeasureMeter implements IStiTargetMeter {
        private static ImplementsStiTargetGaugeMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Indicator {
    import IStiSeriesMeter = Stimulsoft.Base.Meters.IStiSeriesMeter;
    class StiSeriesIndicatorMeter extends StiDimensionMeter implements IStiSeriesMeter {
        private static ImplementsStiSeriesIndicatorMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Indicator {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiValueIndicatorMeter extends StiMeasureMeter implements IStiValueMeter {
        private static ImplementsStiValueIndicatorMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Indicator {
    import IStiTargetMeter = Stimulsoft.Base.Meters.IStiTargetMeter;
    class StiTargetIndicatorMeter extends StiMeasureMeter implements IStiTargetMeter {
        private static ImplementsStiTargetIndicatorMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    class StiWeightChartMeter extends StiMeasureMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import StiChartSeriesType = Stimulsoft.Report.Dashboard.StiChartSeriesType;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiEmptyCellsAs = Stimulsoft.Report.Dashboard.StiEmptyCellsAs;
    import StiSeriesYAxis = Stimulsoft.Report.Chart.StiSeriesYAxis;
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiValueChartMeter extends StiMeasureMeter implements IStiJsonReportObject, IStiValueMeter {
        private static ImplementsStiValueChartMeter;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        seriesType: StiChartSeriesType;
        yAxis: StiSeriesYAxis;
        lineStyle: StiPenStyle;
        lineWidth: number;
        showZeros: StiEmptyCellsAs;
        showNulls: StiEmptyCellsAs;
        ident: StiMeterIdent;
        getUniqueCode(): number;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, seriesType?: StiChartSeriesType, yAxis?: StiSeriesYAxis, lineStyle?: StiPenStyle, lineWidth?: number, showZeros?: StiEmptyCellsAs, showNulls?: StiEmptyCellsAs);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import StiChartSeriesType = Stimulsoft.Report.Dashboard.StiChartSeriesType;
    class StiOpenValueChartMeter extends StiValueChartMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        seriesType: StiChartSeriesType;
        constructor(key?: string, expression?: string, label?: string, seriesType?: StiChartSeriesType);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    class StiCloseValueChartMeter extends StiMeasureMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    class StiLowValueChartMeter extends StiMeasureMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    class StiHighValueChartMeter extends StiMeasureMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiSeriesMeter = Stimulsoft.Base.Meters.IStiSeriesMeter;
    class StiSeriesChartMeter extends StiDimensionMeter implements IStiSeriesMeter {
        private static ImplementsStiSeriesChartMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.OnlineMap {
    class StiLocationMapMeter extends StiDimensionMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.OnlineMap {
    class StiLocationColorMapMeter extends StiDimensionMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.OnlineMap {
    class StiLocationValueMapMeter extends StiDimensionMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.OnlineMap {
    class StiLocationArgumentMapMeter extends StiDimensionMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import StiBubbleColumn = Stimulsoft.Dashboard.Components.Table.StiBubbleColumn;
    import StiLocationArgumentMapMeter = Stimulsoft.Dashboard.Components.OnlineMap.StiLocationArgumentMapMeter;
    import StiLocationMapMeter = Stimulsoft.Dashboard.Components.OnlineMap.StiLocationMapMeter;
    import StiLocationColorMapMeter = Stimulsoft.Dashboard.Components.OnlineMap.StiLocationColorMapMeter;
    import StiLocationValueMapMeter = Stimulsoft.Dashboard.Components.OnlineMap.StiLocationValueMapMeter;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    import Type = Stimulsoft.System.Type;
    import StiKeyTreeViewBoxMeter = Stimulsoft.Dashboard.Components.TreeViewBox.StiKeyTreeViewBoxMeter;
    import StiKeyTreeViewMeter = Stimulsoft.Dashboard.Components.TreeView.StiKeyTreeViewMeter;
    import StiIndicatorColumn = Stimulsoft.Dashboard.Components.Table.StiIndicatorColumn;
    import StiColorScaleColumn = Stimulsoft.Dashboard.Components.Table.StiColorScaleColumn;
    import StiDataBarsColumn = Stimulsoft.Dashboard.Components.Table.StiDataBarsColumn;
    import StiSparklinesColumn = Stimulsoft.Dashboard.Components.Table.StiSparklinesColumn;
    import StiDimensionColumn = Stimulsoft.Dashboard.Components.Table.StiDimensionColumn;
    import StiMeasureColumn = Stimulsoft.Dashboard.Components.Table.StiMeasureColumn;
    import StiColorMapMeter = Stimulsoft.Dashboard.Components.RegionMap.StiColorMapMeter;
    import StiValueMapMeter = Stimulsoft.Dashboard.Components.RegionMap.StiValueMapMeter;
    import StiGroupMapMeter = Stimulsoft.Dashboard.Components.RegionMap.StiGroupMapMeter;
    import StiNameMapMeter = Stimulsoft.Dashboard.Components.RegionMap.StiNameMapMeter;
    import StiKeyMapMeter = Stimulsoft.Dashboard.Components.RegionMap.StiKeyMapMeter;
    import StiValueProgressMeter = Stimulsoft.Dashboard.Components.Progress.StiValueProgressMeter;
    import StiTargetProgressMeter = Stimulsoft.Dashboard.Components.Progress.StiTargetProgressMeter;
    import StiSeriesProgressMeter = Stimulsoft.Dashboard.Components.Progress.StiSeriesProgressMeter;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import IStiDashboard = Stimulsoft.Report.Dashboard.IStiDashboard;
    import StiPivotColumn = Stimulsoft.Dashboard.Components.PivotTable.StiPivotColumn;
    import StiPivotRow = Stimulsoft.Dashboard.Components.PivotTable.StiPivotRow;
    import StiPivotSummary = Stimulsoft.Dashboard.Components.PivotTable.StiPivotSummary;
    import StiLatitudeMapMeter = Stimulsoft.Dashboard.Components.OnlineMap.StiLatitudeMapMeter;
    import StiLongitudeMapMeter = Stimulsoft.Dashboard.Components.OnlineMap.StiLongitudeMapMeter;
    import StiKeyListBoxMeter = Stimulsoft.Dashboard.Components.ListBox.StiKeyListBoxMeter;
    import StiNameListBoxMeter = Stimulsoft.Dashboard.Components.ListBox.StiNameListBoxMeter;
    import StiValueDatePickerMeter = Stimulsoft.Dashboard.Components.DatePicker.StiValueDatePickerMeter;
    import StiElement = Stimulsoft.Dashboard.Components.StiElement;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiNameComboBoxMeter = Stimulsoft.Dashboard.Components.ComboBox.StiNameComboBoxMeter;
    import StiKeyComboBoxMeter = Stimulsoft.Dashboard.Components.ComboBox.StiKeyComboBoxMeter;
    import StiSeriesGaugeMeter = Stimulsoft.Dashboard.Components.Gauge.StiSeriesGaugeMeter;
    import StiValueGaugeMeter = Stimulsoft.Dashboard.Components.Gauge.StiValueGaugeMeter;
    import StiTargetGaugeMeter = Stimulsoft.Dashboard.Components.Gauge.StiTargetGaugeMeter;
    import StiSeriesIndicatorMeter = Stimulsoft.Dashboard.Components.Indicator.StiSeriesIndicatorMeter;
    import StiValueIndicatorMeter = Stimulsoft.Dashboard.Components.Indicator.StiValueIndicatorMeter;
    import StiTargetIndicatorMeter = Stimulsoft.Dashboard.Components.Indicator.StiTargetIndicatorMeter;
    import StiWeightChartMeter = Stimulsoft.Dashboard.Components.Chart.StiWeightChartMeter;
    import StiChartElement = Stimulsoft.Dashboard.Components.Chart.StiChartElement;
    import StiOpenValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiOpenValueChartMeter;
    import StiCloseValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiCloseValueChartMeter;
    import StiLowValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiLowValueChartMeter;
    import StiHighValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiHighValueChartMeter;
    import StiArgumentChartMeter = Stimulsoft.Dashboard.Components.Chart.StiArgumentChartMeter;
    import StiValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiValueChartMeter;
    import StiSeriesChartMeter = Stimulsoft.Dashboard.Components.Chart.StiSeriesChartMeter;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiEndValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiEndValueChartMeter;
    import StiMeter = Stimulsoft.Dashboard.Components.StiMeter;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    class Chart {
        static getValue(meter: StiMeter): StiValueChartMeter;
        static getEndValue(meter: StiMeter): StiEndValueChartMeter;
        static getOpenValue(meter: StiMeter): StiOpenValueChartMeter;
        static getCloseValue(meter: StiMeter): StiCloseValueChartMeter;
        static getLowValue(meter: StiMeter): StiLowValueChartMeter;
        static getHighValue(meter: StiMeter): StiHighValueChartMeter;
        static getValue2(cell: IStiAppDataCell, element: StiChartElement): StiValueChartMeter;
        static getEndValue2(cell: IStiAppDataCell): StiEndValueChartMeter;
        static getCloseValue2(cell: IStiAppDataCell): StiCloseValueChartMeter;
        static getLowValue2(cell: IStiAppDataCell): StiLowValueChartMeter;
        static getHighValue2(cell: IStiAppDataCell): StiHighValueChartMeter;
        static getWeight(meter: StiMeter): StiWeightChartMeter;
        static getWeight2(cell: IStiAppDataCell): StiWeightChartMeter;
        static getArgument(meter: StiMeter): StiArgumentChartMeter;
        static getArgument2(cell: IStiAppDataCell): StiArgumentChartMeter;
        static getX2(cell: IStiAppDataCell): StiArgumentChartMeter;
        static getX(meter: StiMeter): StiArgumentChartMeter;
        static getY2(cell: IStiAppDataCell): StiValueChartMeter;
        static getY(meter: StiMeter): StiValueChartMeter;
        static getSeries(meter: StiMeter): StiSeriesChartMeter;
        static getSeries2(cell: IStiAppDataCell): StiSeriesChartMeter;
    }
    class ComboBox {
        static getName(meter: StiMeter): StiNameComboBoxMeter;
        static getName2(cell: IStiAppDataCell): StiNameComboBoxMeter;
        static getKey(meter: StiMeter): StiKeyComboBoxMeter;
        static getKey2(cell: IStiAppDataCell): StiKeyComboBoxMeter;
    }
    class DataFilter {
        static getFilter2(dataColumn: StiDataColumn): StiDataFilterRule;
        static getFilter(column: StiTableColumn, element: StiElement): StiDataFilterRule;
    }
    class DatePicker {
        static getValue(meter: StiMeter): StiValueDatePickerMeter;
        static getValue2(cell: IStiAppDataCell): StiValueDatePickerMeter;
    }
    class Gauge {
        static getSeries(meter: StiMeter): StiSeriesGaugeMeter;
        static getSeries2(cell: IStiAppDataCell): StiSeriesGaugeMeter;
        static getValue(meter: StiMeter): StiValueGaugeMeter;
        static getValue2(cell: IStiAppDataCell): StiValueGaugeMeter;
        static getTarget(meter: StiMeter): StiTargetGaugeMeter;
        static getTarget2(cell: IStiAppDataCell): StiTargetGaugeMeter;
    }
    class Indicator {
        static getSeries(meter: StiMeter): StiSeriesIndicatorMeter;
        static getSeries2(cell: IStiAppDataCell): StiSeriesIndicatorMeter;
        static getValue(meter: StiMeter): StiValueIndicatorMeter;
        static getValue2(cell: IStiAppDataCell): StiValueIndicatorMeter;
        static getTarget(meter: StiMeter): StiTargetIndicatorMeter;
        static getTarget2(cell: IStiAppDataCell): StiTargetIndicatorMeter;
    }
    class ListBox {
        static getName(meter: StiMeter): StiNameListBoxMeter;
        static getName2(cell: IStiAppDataCell): StiNameListBoxMeter;
        static getKey(meter: StiMeter): StiKeyListBoxMeter;
        static getKey2(cell: IStiAppDataCell): StiKeyListBoxMeter;
    }
    class OnlineMap {
        static getLatitude(meter: StiMeter): StiLatitudeMapMeter;
        static getLongitude(meter: StiMeter): StiLongitudeMapMeter;
        static getLocation(meter: StiMeter): StiLocationMapMeter;
        static getLocationColor(meter: StiMeter): StiLocationColorMapMeter;
        static getLocationValue(meter: StiMeter): StiLocationValueMapMeter;
        static getLocationArgument(meter: StiMeter): StiLocationArgumentMapMeter;
        static getLatitude2(cell: IStiAppDataCell): StiLatitudeMapMeter;
        static getLongitude2(cell: IStiAppDataCell): StiLongitudeMapMeter;
        static getLocation2(cell: IStiAppDataCell): StiLocationMapMeter;
        static getLocationColor2(cell: IStiAppDataCell): StiLocationColorMapMeter;
        static getLocationValue2(cell: IStiAppDataCell): StiLocationValueMapMeter;
        static getLocationArgument2(cell: IStiAppDataCell): StiLocationArgumentMapMeter;
    }
    class Pivot {
        static getColumn(meter: StiMeter): StiPivotColumn;
        static getRow(meter: StiMeter): StiPivotRow;
        static getSummary(meter: StiMeter): StiPivotSummary;
        static getSummary3(meter: StiMeter, dashboard?: IStiDashboard): StiPivotSummary;
        static getColumn2(cell: IStiAppDataCell): StiPivotColumn;
        static getRow2(cell: IStiAppDataCell): StiPivotRow;
        static getSummary2(cell: IStiAppDataCell): StiPivotSummary;
        static getFormat(meter: StiMeter): StiFormatService;
        static getTopN(meter: StiMeter): StiDataTopN;
    }
    class Progress {
        static getSeries(meter: StiMeter): StiSeriesProgressMeter;
        static getSeries2(cell: IStiAppDataCell): StiSeriesProgressMeter;
        static getValue(meter: StiMeter): StiValueProgressMeter;
        static getValue2(cell: IStiAppDataCell): StiValueProgressMeter;
        static getTarget(meter: StiMeter): StiTargetProgressMeter;
        static getTarget2(cell: IStiAppDataCell): StiTargetProgressMeter;
    }
    class RegionMap {
        static getKey(meter: StiMeter): StiKeyMapMeter;
        static getName(meter: StiMeter): StiNameMapMeter;
        static getGroup(meter: StiMeter): StiGroupMapMeter;
        static getValue(meter: StiMeter, dashboard: IStiDashboard): StiValueMapMeter;
        static getColor(meter: StiMeter): StiColorMapMeter;
        static getKey2(cell: IStiAppDataCell): StiKeyMapMeter;
        static getName2(cell: IStiAppDataCell): StiNameMapMeter;
        static getValue2(cell: IStiAppDataCell): StiValueMapMeter;
        static getGroup2(cell: IStiAppDataCell): StiGroupMapMeter;
        static getColor2(cell: IStiAppDataCell): StiColorMapMeter;
    }
    class Table {
        static getColumn(meter: StiMeter): StiTableColumn;
        static getDimension(tableColumn: StiTableColumn): StiDimensionColumn;
        static getDimension2(cell: IStiAppDataCell): StiDimensionColumn;
        static getMeasure(tableColumn: StiTableColumn, dashboard: IStiDashboard): StiMeasureColumn;
        static getMeasure2(cell: IStiAppDataCell): StiMeasureColumn;
        static getDataBars(tableColumn: StiTableColumn, dashboard: IStiDashboard): StiDataBarsColumn;
        static getColorScale(tableColumn: StiTableColumn, dashboard: IStiDashboard): StiColorScaleColumn;
        static getSparklines(tableColumn: StiTableColumn): StiSparklinesColumn;
        static getBubble(tableColumn: StiTableColumn, dashboard: IStiDashboard): StiBubbleColumn;
        static getIndicator(tableColumn: StiTableColumn, dashboard: IStiDashboard): StiIndicatorColumn;
    }
    class TreeView {
        static getKey(meter: StiMeter): StiKeyTreeViewMeter;
        static getKey2(cell: IStiAppDataCell): StiKeyTreeViewMeter;
    }
    class TreeViewBox {
        static getKey(meter: StiMeter): StiKeyTreeViewBoxMeter;
        static getKey2(cell: IStiAppDataCell): StiKeyTreeViewBoxMeter;
    }
    class StiMeterHelper {
        static Chart: typeof Chart;
        static ComboBox: typeof ComboBox;
        static DataFilter: typeof DataFilter;
        static DatePicker: typeof DatePicker;
        static Gauge: typeof Gauge;
        static Indicator: typeof Indicator;
        static ListBox: typeof ListBox;
        static OnlineMap: typeof OnlineMap;
        static Pivot: typeof Pivot;
        static Progress: typeof Progress;
        static RegionMap: typeof RegionMap;
        static Table: typeof Table;
        static TreeView: typeof TreeView;
        static TreeViewBox: typeof TreeViewBox;
        static toTotalExpression2(cell: IStiAppDataCell): string;
        static toTotalExpression(meter: StiMeter): string;
        static toTotalExpression3(meter: StiMeter, dashboard: IStiDashboard): string;
        static toSumExpression2(dataColumn: StiDataColumn): string;
        static toSumExpression(expression: string): string;
        static toCountExpression2(dataColumn: StiDataColumn): string;
        static toCountExpression(expression: string): string;
        static toExpression(cell: IStiAppDataCell): string;
        static toAlias(cell: IStiAppDataCell): string;
        static toDataType(cell: IStiAppDataCell): Type;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Helpers {
    import List = Stimulsoft.System.Collections.List;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiMeterLoader {
        static loadFromJson2(jsons: List<StiJson>): List<StiMeter>;
        static loadFromJson(json: StiJson): StiMeter;
        static loadFromXml(xmlNode: XmlNode, isDocument: boolean, report?: StiReport): StiMeter;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart.Helpers {
    import StiChartSeriesType = Stimulsoft.Report.Dashboard.StiChartSeriesType;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    class StiChartSeriesCreator {
        static neww(typeName: string): IStiSeries;
        static neww2(type: StiChartSeriesType): IStiSeries;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiChartLegendTitle implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(): any;
        color: Color;
        private shouldSerializeColor;
        font: Font;
        private shouldSerializeFont;
        text: string;
        isDefault(): boolean;
        constructor(font?: Font, text?: string, color?: Color);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import StiSeriesLabelsValueType = Stimulsoft.Report.Chart.StiSeriesLabelsValueType;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiChartLegendLabels implements ICloneable, IStiFont, IStiJsonReportObject {
        private static ImplementsStiChartLegendLabels;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(): any;
        color: Color;
        private shouldSerializeColor;
        font: Font;
        valueType: StiSeriesLabelsValueType;
        private shouldSerializeFont;
        isDefault(): boolean;
        constructor(font?: Font, color?: Color, valueType?: StiSeriesLabelsValueType);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import StiLegendDirection = Stimulsoft.Report.Chart.StiLegendDirection;
    import StiChartLegendTitle = Stimulsoft.Dashboard.Components.Chart.StiChartLegendTitle;
    import StiChartLegendLabels = Stimulsoft.Dashboard.Components.Chart.StiChartLegendLabels;
    import StiLegendVertAlignment = Stimulsoft.Report.Chart.StiLegendVertAlignment;
    import StiLegendHorAlignment = Stimulsoft.Report.Chart.StiLegendHorAlignment;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    enum Order {
        HorAlignment = 1,
        Labels = 2,
        Title = 3,
        VertAlignment = 4
    }
    class StiChartLegend implements IStiJsonReportObject {
        private static ImplementsStiChartLegend;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(): any;
        horAlignment: StiLegendHorAlignment;
        vertAlignment: StiLegendVertAlignment;
        get visible(): boolean;
        set visible(value: boolean);
        visibility: StiLegendVisibility;
        direction: StiLegendDirection;
        columns: number;
        labels: StiChartLegendLabels;
        title: StiChartLegendTitle;
        isDefault(): boolean;
        constructor(title?: StiChartLegendTitle, labels?: StiChartLegendLabels, horAlignment?: StiLegendHorAlignment, vertAlignment?: StiLegendVertAlignment, visibility?: StiLegendVisibility, direction?: StiLegendDirection, columns?: number);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import StiTitlePosition = Stimulsoft.Report.Chart.StiTitlePosition;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiDirection = Stimulsoft.Report.Chart.StiDirection;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiYChartAxisTitle extends StiChartAxisTitle implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        direction: StiDirection;
        isDefault(): boolean;
        constructor(font?: Font, text?: string, color?: Color, alignment?: StringAlignment, direction?: StiDirection, position?: StiTitlePosition, visible?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiYChartAxisTitle = Stimulsoft.Dashboard.Components.Chart.StiYChartAxisTitle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiYChartAxis extends StiChartAxis implements IStiJsonReportObject {
        clone(): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        title: StiYChartAxisTitle;
        shouldSerializeTitle(): boolean;
        startFromZero: boolean;
        shouldSerializeStartFromZero(): boolean;
        isDefault(): boolean;
        constructor(labels?: StiChartAxisLabels, title?: StiYChartAxisTitle, visible?: boolean, startFromZero?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiAutoBool = Stimulsoft.Base.StiAutoBool;
    class StiXChartAxis extends StiChartAxis implements IStiJsonReportObject {
        clone(): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        title: StiXChartAxisTitle;
        shouldSerializeTitle(): boolean;
        showEdgeValues: StiAutoBool;
        shouldSerializeShowEdgeValues(): boolean;
        startFromZero: StiAutoBool;
        shouldSerializeStartFromZero(): boolean;
        isDefault(): boolean;
        constructor(labels?: StiChartAxisLabels, title?: StiXChartAxisTitle, visible?: boolean, startFromZero?: StiAutoBool, showEdgeValues?: StiAutoBool);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    class StiYChartMeter extends StiDimensionMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart.Helpers {
    import StiChartSeriesType = Stimulsoft.Report.Dashboard.StiChartSeriesType;
    import List = Stimulsoft.System.Collections.List;
    class StiChartGroups {
        private static hash;
        private static isInit;
        static sameGroup(type1: StiChartSeriesType, type2: StiChartSeriesType): boolean;
        static getGroup(type: StiChartSeriesType): List<StiChartSeriesType>;
        static init(): void;
    }
}
declare namespace Stimulsoft.Dashboard.Export {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    import Attribute = Stimulsoft.System.Attribute;
    class StiExportToolAttribute extends Attribute {
        exportToolTypeName: string;
        constructor(exportToolTypeName: string);
        static attributes: Dictionary<string, StiExportToolAttribute>;
        static add(typeName: string, exportToolTypeName: string): void;
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    import StiAvailableInteractionOnDataManipulation = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnDataManipulation;
    import IStiAllowUserSortingDashboardInteraction = Stimulsoft.Report.Dashboard.IStiAllowUserSortingDashboardInteraction;
    import IStiInteractionLayout = Stimulsoft.Report.Dashboard.IStiInteractionLayout;
    import StiDashboardDrillDownParameter = Stimulsoft.Dashboard.Interactions.StiDashboardDrillDownParameter;
    import List = Stimulsoft.System.Collections.List;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    import IStiAllowUserDrillDownDashboardInteraction = Stimulsoft.Report.Dashboard.IStiAllowUserDrillDownDashboardInteraction;
    class StiChartDashboardInteraction extends StiDashboardInteraction implements IStiAllowUserDrillDownDashboardInteraction, IStiAllowUserSortingDashboardInteraction, IStiJsonReportObject, IStiInteractionLayout {
        private static ImplementsIStiChartDashboardInteraction;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        ident: StiInteractionIdent;
        allowUserDrillDown: boolean;
        allowUserSorting: boolean;
        availableOnClick: StiAvailableInteractionOnClick;
        availableOnDataManipulation: StiAvailableInteractionOnDataManipulation;
        showFullScreenButton: boolean;
        showSaveButton: boolean;
        showViewDataButton: boolean;
        fileName: string;
        headerText: string;
        footerText: string;
        get isDefaultLayout(): boolean;
        isDefault(): boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>, allowUserDrillDown?: boolean, fileName?: string, headerText?: string, footerText?: string, showFullScreenButton?: boolean, showSaveButton?: boolean, showViewDataButton?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import List = Stimulsoft.System.Collections.List;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiDrillDownHelper {
        static isDrillAvailable(element: IStiElement): boolean;
        static isDrillUpAvailable(element: IStiElement): boolean;
        static isDrillDownAvailable(element: IStiElement): boolean;
        static drillUp(element: IStiElement): void;
        static drillDown(element: IStiElement, drillDownFilters?: List<StiDataFilterRule>): void;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiChartTrendLineType = Stimulsoft.Report.Dashboard.StiChartTrendLineType;
    import IStiChartTrendLine = Stimulsoft.Report.Dashboard.IStiChartTrendLine;
    class StiChartTrendLine implements ICloneable, IStiChartTrendLine, IStiJsonReportObject {
        private static ImplementsStiChartTrendLine;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiChartTrendLine;
        type: StiChartTrendLineType;
        lineStyle: StiPenStyle;
        lineColor: Color;
        lineWidth: number;
        keyValueMeter: string;
        static createFromJson(json: StiJson): StiChartTrendLine;
        static createFromXml(xmlNode: XmlNode): StiChartTrendLine;
        constructor(keyValueMeter?: string, type?: StiChartTrendLineType, lineColor?: Color, lineStyle?: StiPenStyle, lineWidth?: number);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import StiUserViewState = Stimulsoft.Report.Dashboard.StiUserViewState;
    import IStiUserViewStates = Stimulsoft.Report.Dashboard.IStiUserViewStates;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiMarkerType = Stimulsoft.Report.Chart.StiMarkerType;
    import StiChartMarker = Stimulsoft.Dashboard.Components.Chart.StiChartMarker;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    import IStiNegativeSeriesColors = Stimulsoft.Report.Dashboard.IStiNegativeSeriesColors;
    import IStiParetoSeriesColors = Stimulsoft.Report.Dashboard.IStiParetoSeriesColors;
    import IStiSeriesColors = Stimulsoft.Report.Dashboard.IStiSeriesColors;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiChartLegend = Stimulsoft.Dashboard.Components.Chart.StiChartLegend;
    import StiYChartAxis = Stimulsoft.Dashboard.Components.Chart.StiYChartAxis;
    import StiXChartAxis = Stimulsoft.Dashboard.Components.Chart.StiXChartAxis;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiTitle = Stimulsoft.Dashboard.Components.StiTitle;
    import StiSeriesChartMeter = Stimulsoft.Dashboard.Components.Chart.StiSeriesChartMeter;
    import StiWeightChartMeter = Stimulsoft.Dashboard.Components.Chart.StiWeightChartMeter;
    import StiArgumentChartMeter = Stimulsoft.Dashboard.Components.Chart.StiArgumentChartMeter;
    import StiHighValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiHighValueChartMeter;
    import StiLowValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiLowValueChartMeter;
    import StiCloseValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiCloseValueChartMeter;
    import StiEndValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiEndValueChartMeter;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiSkipOwnFilter = Stimulsoft.Report.Dashboard.IStiSkipOwnFilter;
    import IStiChartElement = Stimulsoft.Report.Dashboard.IStiChartElement;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import IStiDrillDownElement = Stimulsoft.Data.Engine.IStiDrillDownElement;
    import IStiChartConstantLines = Stimulsoft.Report.Dashboard.IStiChartConstantLines;
    import IStiChartElementCondition = Stimulsoft.Report.Dashboard.IStiChartElementCondition;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiChartConditionalField = Stimulsoft.Report.Chart.StiChartConditionalField;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiChartTrendLine = Stimulsoft.Report.Dashboard.IStiChartTrendLine;
    import StiChartTrendLineType = Stimulsoft.Report.Dashboard.StiChartTrendLineType;
    import StiChartTrendLine = Stimulsoft.Dashboard.Components.Chart.StiChartTrendLine;
    class StiChartElement extends StiElement implements IStiChartElement, IStiUserViewStates, IStiSkipOwnFilter, IStiTitleElement, IStiElementLayout, IStiJsonReportObject, IStiGlobalizationProvider, IStiSeriesColors, IStiNegativeSeriesColors, IStiParetoSeriesColors, IStiElementInteraction, IStiDrillDownElement {
        private static ImplementsStiChartElement;
        implements(): any[];
        clone(cloneProperties: boolean): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        convertToBubble(): void;
        convertFromBubble(): void;
        getChartSeriesTypes(seriesTypeStr: string): List<string>;
        addValue(cell: IStiAppDataCell): void;
        getValue2(cell: IStiAppDataCell): IStiMeter;
        getValue(meter: IStiMeter): IStiMeter;
        fetchAllValues(): List<IStiMeter>;
        getValueByIndex(index: number): IStiMeter;
        insertValue(index: number, meter: IStiMeter): void;
        removeValue(index: number): void;
        removeAllValues(): void;
        createNewValue(): IStiMeter;
        addEndValue(cell: IStiAppDataCell): void;
        getEndValue2(cell: IStiAppDataCell): IStiMeter;
        getEndValue(meter: IStiMeter): IStiMeter;
        getEndValueByIndex(index: number): IStiMeter;
        insertEndValue(index: number, meter: IStiMeter): void;
        removeEndValue(index: number): void;
        removeAllEndValues(): void;
        createNewEndValue(): IStiMeter;
        addCloseValue(cell: IStiAppDataCell): void;
        getCloseValue2(cell: IStiAppDataCell): IStiMeter;
        getCloseValue(meter: IStiMeter): IStiMeter;
        getCloseValueByIndex(index: number): IStiMeter;
        insertCloseValue(index: number, meter: IStiMeter): void;
        removeCloseValue(index: number): void;
        removeAllCloseValues(): void;
        createNewCloseValue(): IStiMeter;
        addLowValue(cell: IStiAppDataCell): void;
        getLowValue2(cell: IStiAppDataCell): IStiMeter;
        getLowValue(meter: IStiMeter): IStiMeter;
        getLowValueByIndex(index: number): IStiMeter;
        insertLowValue(index: number, meter: IStiMeter): void;
        removeLowValue(index: number): void;
        removeAllLowValues(): void;
        createNewLowValue(): IStiMeter;
        addHighalue(cell: IStiAppDataCell): void;
        getHighValue2(cell: IStiAppDataCell): IStiMeter;
        getHighValue(meter: IStiMeter): IStiMeter;
        getHighValueByIndex(index: number): IStiMeter;
        insertHighValue(index: number, meter: IStiMeter): void;
        removeHighValue(index: number): void;
        removeAllHighValues(): void;
        createNewHighValue(): IStiMeter;
        addArgument(cell: IStiAppDataCell): void;
        getArgument2(cell: IStiAppDataCell): IStiMeter;
        getArgument(meter: IStiMeter): IStiMeter;
        fetchAllArguments(): List<IStiMeter>;
        getArgumentByIndex(index: number): IStiMeter;
        insertArgument(index: number, meter: IStiMeter): void;
        removeArgument(index: number): void;
        removeAllArguments(): void;
        createNewArgument(): void;
        addWeight(cell: IStiAppDataCell): void;
        getWeight2(cell: IStiAppDataCell): IStiMeter;
        getWeight(meter: IStiMeter): IStiMeter;
        getWeightByIndex(index: number): IStiMeter;
        insertWeight(index: number, meter: IStiMeter): void;
        removeWeight(index: number): void;
        removeAllWeights(): void;
        createNewWeight(): void;
        addSeries(cell: IStiAppDataCell): void;
        getSeries2(cell: IStiAppDataCell): IStiMeter;
        getSeries(meter: IStiMeter): IStiMeter;
        getSeries3(): IStiMeter;
        insertSeries(meter: IStiMeter): void;
        removeSeries(): void;
        createNewSeries(): void;
        fetchConstantLines(): List<IStiChartConstantLines>;
        addConstantLine(): void;
        removeConstantLine(index: number): void;
        moveConstantLine(fromIndex: number, toIndex: number): void;
        addTrendLines(keyValueMeter: string, type: StiChartTrendLineType, lineColor: Color, lineStyle: StiPenStyle, lineWidth: number): void;
        fetchTrendLines(): List<IStiChartTrendLine>;
        clearTrendLines(): void;
        addChartCondition(keyValueMeter: string, dataType: StiFilterDataType, condition: StiFilterCondition, value: string, color: Color, markerType: StiMarkerType, markerAngle: number, field: StiChartConditionalField, isExpression: boolean): void;
        fetchChartConditions(): List<IStiChartElementCondition>;
        clearChartConditions(): void;
        convertFrom(element: IStiElement): void;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        title: StiTitle;
        layout: StiElementLayout;
        private shouldSerializeLayout;
        group: string;
        get allowSkipOwnFilter(): boolean;
        crossFiltering: boolean;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        userFilters: List<StiDataFilterRule>;
        userSorts: List<StiDataSortRule>;
        userViewStates: List<StiUserViewState>;
        selectedViewStateKey: string;
        switchSelectedViewState(newKey: string): void;
        saveToJsonForViewState(): StiJson;
        loadFromJsonForViewState(jObject: StiJson): void;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        topN: StiDataTopN;
        dataTransformation: {};
        private shouldSerializeDataTransformation;
        isDefaultDataTransformation(): boolean;
        dataFilters: List<StiDataFilterRule>;
        seriesColors: Color[];
        negativeSeriesColors: Color[];
        paretoSeriesColors: Color[];
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        dashboardInteraction: IStiDashboardInteraction;
        get shouldSerializeDashboardInteraction(): boolean;
        getFonts(): Font[];
        get toolboxPosition(): number;
        get localizedName(): string;
        helpUrl: string;
        get colorEach(): boolean;
        set colorEach(value: boolean);
        values: List<StiValueChartMeter>;
        private shouldSerializeValues;
        endValues: List<StiEndValueChartMeter>;
        private shouldSerializeEndValues;
        closeValues: List<StiCloseValueChartMeter>;
        private shouldSerializeCloseValues;
        lowValues: List<StiLowValueChartMeter>;
        private shouldSerializeLowValues;
        highValues: List<StiHighValueChartMeter>;
        private shouldSerializeHighValues;
        arguments: List<StiArgumentChartMeter>;
        private shouldSerializeArguments;
        weights: List<StiWeightChartMeter>;
        private shouldSerializeWeights;
        series: StiSeriesChartMeter;
        private shouldSerializeSeries;
        get xAxis(): StiXChartAxis;
        set xAxis(value: StiXChartAxis);
        get xTopAxis(): StiXTopChartAxis;
        set xTopAxis(value: StiXTopChartAxis);
        get yAxis(): StiYChartAxis;
        set yAxis(value: StiYChartAxis);
        get yRightAxis(): StiYRightChartAxis;
        set yRightAxis(value: StiYRightChartAxis);
        legend: StiChartLegend;
        private shouldSerializeLegend;
        area: StiChartArea;
        private _labels;
        get labels(): StiChartLabels;
        set labels(value: StiChartLabels);
        private shouldSerializeLabels;
        argumentFormat: StiFormatService;
        private shouldSerializeArgumentFormat;
        valueFormat: StiFormatService;
        private static getValueFormatDefault;
        private shouldSerializeValueFormat;
        trendLines: List<StiChartTrendLine>;
        private shouldSerializeTrendLines;
        constantLines: List<StiChartConstantLines>;
        private shouldSerializeConstantLines;
        chartConditions: List<StiChartElementCondition>;
        private shouldSerializeConditions;
        marker: StiChartMarker;
        private shouldSerializeMarker;
        icon: StiFontIcons;
        private shouldSerializeIcon;
        roundValues: boolean;
        get isAxisAreaChart(): boolean;
        get isStackedChart(): boolean;
        get isLinesChart(): boolean;
        get isBubbleChart(): boolean;
        get isBarChart(): boolean;
        get isRange(): boolean;
        get isFinancial(): boolean;
        get isPieChart(): boolean;
        get isDoughnutChart(): boolean;
        get isFunnelChart(): boolean;
        get isTreemapChart(): boolean;
        get isParetoChart(): boolean;
        get isSunburstChart(): boolean;
        get isFullStackedChart(): boolean;
        get isWaterfallChart(): boolean;
        getNestedPages(): List<StiPage>;
        drillDownFiltersList: List<List<StiDataFilterRule>>;
        drillDownFilters: List<StiDataFilterRule>;
        drillDownCurrentLevel: number;
        get drillDownLevelCount(): number;
        createNew(): StiComponent;
        checkBrowsableProperties(): void;
        private setBrowsableProperty;
        getChartSeries(): IStiSeries;
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiChartElementCondition = Stimulsoft.Report.Dashboard.IStiChartElementCondition;
    import StiMarkerType = Stimulsoft.Report.Chart.StiMarkerType;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiChartConditionalField = Stimulsoft.Report.Chart.StiChartConditionalField;
    class StiChartElementCondition implements ICloneable, IStiChartElementCondition, IStiJsonReportObject {
        private static ImplementsStiChartElementCondition;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiChartElementCondition;
        color: Color;
        markerAngle: number;
        markerType: StiMarkerType;
        condition: StiFilterCondition;
        dataType: StiFilterDataType;
        value: string;
        keyValueMeter: string;
        field: StiChartConditionalField;
        isExpression: boolean;
        isDefault(): boolean;
        static createFromJson(json: StiJson): StiChartElementCondition;
        static createFromXml(xmlNode: XmlNode): StiChartElementCondition;
        constructor(keyValueMeter?: string, color?: Color, dataType?: StiFilterDataType, condition?: StiFilterCondition, value?: string, markerType?: StiMarkerType, markerAngle?: number, field?: StiChartConditionalField, isExpression?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiDefault = Stimulsoft.Base.Design.IStiDefault;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiChartGridLines implements ICloneable, IStiDefault, IStiJsonReportObject {
        private static ImplementsStiChartGridLines;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiChartGridLines;
        color: Color;
        visible: boolean;
        isDefault(): boolean;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiChartInterlacing implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiChartInterlacing;
        color: Color;
        visible: boolean;
        isDefault(): boolean;
        constructor(color?: Color, visible?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiChartLabels = Stimulsoft.Report.Dashboard.IStiChartLabels;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiChartLabelsPosition = Stimulsoft.Report.Dashboard.StiChartLabelsPosition;
    class StiChartLabels implements IStiJsonReportObject, IStiChartLabels {
        private static ImplementsStiChartLabels;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiChartLabels;
        get position(): StiChartLabelsPosition;
        set position(value: StiChartLabelsPosition);
        private shouldSerializePosition;
        axisPosition: StiChartLabelsPosition;
        piePosition: StiChartLabelsPosition;
        doughnutPosition: StiChartLabelsPosition;
        funnelPosition: StiChartLabelsPosition;
        treemapPosition: StiChartLabelsPosition;
        foreColor: Color;
        font: Font;
        autoRotate: boolean;
        style: StiChartLabelsStyle;
        textAfter: string;
        textBefore: string;
        element: StiChartElement;
        isDefault(): boolean;
        constructor(axisPosition?: StiChartLabelsPosition, piePosition?: StiChartLabelsPosition, doughnutPosition?: StiChartLabelsPosition, funnelPosition?: StiChartLabelsPosition, treemapPosition?: StiChartLabelsPosition, style?: StiChartLabelsStyle, font?: Font, foreColor?: Color, textBefore?: string, textAfter?: string, autoRotate?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    class StiChartUserViewStatesHelper {
        static saveToJsonObject(chart: StiChartElement): StiJson;
        static loadFromJsonObject(chart: StiChartElement, jObject: StiJson): void;
        static clearVisualState(chart: StiChartElement): void;
        static switchSelectedViewState(chart: StiChartElement, newKey: string): void;
        static saveVisualState(chart: StiChartElement, key: string): void;
        static loadVisualState(chart: StiChartElement, key: string): void;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiLabelsPlacement = Stimulsoft.Report.Chart.StiLabelsPlacement;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    class StiChartYRightAxisLabels extends StiChartAxisLabels {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        textAlignment: StiHorAlignment;
        isDefault(): boolean;
        constructor(textBefore?: string, textAfter?: string, angle?: number, font?: Font, placement?: StiLabelsPlacement, color?: Color, textAlignment?: StiHorAlignment);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiHorChartGridLines extends StiChartGridLines {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        visible: boolean;
        isDefault(): boolean;
        constructor(color?: Color, visible?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiHorChartInterlacing extends StiChartInterlacing {
        constructor(color?: Color, visible?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import StiChartSeriesType = Stimulsoft.Report.Dashboard.StiChartSeriesType;
    class StiStartValueChartMeter extends StiValueChartMeter {
        seriesType: StiChartSeriesType;
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string, seriesType?: StiChartSeriesType);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiVertChartGridLines extends StiChartGridLines {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        visible: boolean;
        isDefault(): boolean;
        constructor(color?: Color, visible?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiVertChartInterlacing extends StiChartInterlacing {
        constructor(color?: Color, visible?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import StiTitlePosition = Stimulsoft.Report.Chart.StiTitlePosition;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiDirection = Stimulsoft.Report.Chart.StiDirection;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiXChartAxisTitle extends StiChartAxisTitle implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        direction: StiDirection;
        isDefault(): boolean;
        constructor(font?: Font, text?: string, color?: Color, alignment?: StringAlignment, direction?: StiDirection, position?: StiTitlePosition, visible?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    class StiXChartMeter extends StiDimensionMeter {
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiXTopChartAxis extends StiXChartAxis {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        isDefault(): boolean;
        visible: boolean;
        constructor(labels?: StiChartAxisLabels, title?: StiXChartAxisTitle, visible?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiYRightChartAxis extends StiYChartAxis {
        isDefault(): boolean;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        visible: boolean;
        labels: StiChartYRightAxisLabels;
        shouldSerializeLabels(): boolean;
        constructor(labels?: StiChartAxisLabels, title?: StiYChartAxisTitle, visible?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Design {
    class StiMeterConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    class StiValueChartMeterConverter extends StiMeterConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart.Design {
    class StiXChartAxisConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart.Design {
    class StiYChartAxisConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.ComboBox {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Size = Stimulsoft.System.Drawing.Size;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import Color = Stimulsoft.System.Drawing.Color;
    import List = Stimulsoft.System.Collections.List;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiItemSelectionMode = Stimulsoft.Report.Dashboard.StiItemSelectionMode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiFixedHeightElement = Stimulsoft.Report.Dashboard.IStiFixedHeightElement;
    import IStiComboBoxElement = Stimulsoft.Report.Dashboard.IStiComboBoxElement;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    class StiComboBoxElement extends StiElement implements IStiComboBoxElement, IStiFixedHeightElement, IStiJsonReportObject {
        private static ImplementsStiComboBoxElement;
        implements(): any[];
        get componentId(): StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean): any;
        group: string;
        getParentKey(): string;
        setParentKey(key: string): void;
        applyDefaultFilters(): Promise<void>;
        userFilters: List<StiDataFilterRule>;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        font: Font;
        private shouldSerializeFont;
        foreColor: Color;
        private shouldSerializeForeColor;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        showAllValue: boolean;
        showBlanks: boolean;
        selectionMode: StiItemSelectionMode;
        addKeyMeter2(cell: IStiAppDataCell): void;
        addKeyMeter(meter: IStiMeter): void;
        getKeyMeter(): IStiMeter;
        removeKeyMeter(): void;
        createNewKeyMeter(): void;
        addNameMeter2(cell: IStiAppDataCell): void;
        addNameMeter(meter: IStiMeter): void;
        getNameMeter(): IStiMeter;
        removeNameMeter(): void;
        createNewNameMeter(): void;
        createNextMeter(cell: IStiAppDataCell): void;
        convertFrom(element: IStiElement): void;
        textFormat: StiFormatService;
        private shouldSerializeTextFormat;
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        get minSize(): Size;
        set minSize(value: Size);
        get maxSize(): Size;
        set maxSize(value: Size);
        helpUrl: string;
        createNew(): StiComponent;
        parentKey: string;
        nameMeter: StiNameComboBoxMeter;
        keyMeter: StiKeyComboBoxMeter;
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.ComboBox {
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import List = Stimulsoft.System.Collections.List;
    class StiComboBoxHelper {
        static fetchItems(comboBoxElement: StiComboBoxElement, dataTable: StiDataTable, showBlanks: boolean): List<StiComboBoxItem>;
        static isBlank(data: any): boolean;
        static fetchDefaultUserFilters(comboBoxElement: StiComboBoxElement): Promise<List<StiDataFilterRule>>;
        private static getNameMeterIndex;
        private static getKeyMeterIndex;
        static getKeyMeterExpression(comboBoxElement: StiComboBoxElement): string;
        private static format;
    }
}
declare namespace Stimulsoft.Dashboard.Components.ComboBox {
    class StiComboBoxItem {
        label: string;
        value: any;
        toString(): string;
        constructor(label: string, value?: any);
    }
}
declare namespace Stimulsoft.Dashboard.Components.DatePicker {
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiInitialDateRangeSelection = Stimulsoft.Report.Dashboard.StiInitialDateRangeSelection;
    import StiInitialDateRangeSelectionSource = Stimulsoft.Report.Dashboard.StiInitialDateRangeSelectionSource;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDateSelectionMode = Stimulsoft.Report.Dashboard.StiDateSelectionMode;
    import StiDateCondition = Stimulsoft.Report.Dashboard.StiDateCondition;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Size = Stimulsoft.System.Drawing.Size;
    import StiValueDatePickerMeter = Stimulsoft.Dashboard.Components.DatePicker.StiValueDatePickerMeter;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import List = Stimulsoft.System.Collections.List;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiGroupElement = Stimulsoft.Report.Dashboard.IStiGroupElement;
    import IStiFixedHeightElement = Stimulsoft.Report.Dashboard.IStiFixedHeightElement;
    import IStiDatePickerElement = Stimulsoft.Report.Dashboard.IStiDatePickerElement;
    class StiDatePickerElement extends StiElement implements IStiDatePickerElement, IStiFixedHeightElement, IStiGroupElement, IStiJsonReportObject {
        private static ImplementsStiDatePickerElement;
        implements(): any[];
        get componentId(): StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean): any;
        group: string;
        getParentKey(): string;
        setParentKey(key: string): void;
        applyDefaultFilters(): Promise<void>;
        userFilters: List<StiDataFilterRule>;
        dataFilters: List<StiDataFilterRule>;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        font: Font;
        private shouldSerializeFont;
        foreColor: Color;
        private shouldSerializeForeColor;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        addValueMeter2(cell: IStiAppDataCell): void;
        addValueMeter(meter: IStiMeter): void;
        getValueMeter(): IStiMeter;
        removeValueMeter(): void;
        createNewValueMeter(): void;
        convertFrom(element: IStiElement): void;
        textFormat: StiFormatService;
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        get minSize(): Size;
        set minSize(value: Size);
        get maxSize(): Size;
        set maxSize(value: Size);
        helpUrl: string;
        createNew(): StiComponent;
        condition: StiDateCondition;
        selectionMode: StiDateSelectionMode;
        valueMeter: StiValueDatePickerMeter;
        initialRangeSelection: StiInitialDateRangeSelection;
        initialRangeSelectionSource: StiInitialDateRangeSelectionSource;
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.DatePicker {
    import IStiAppVariable = Stimulsoft.Base.IStiAppVariable;
    import IStiDatePickerElement = Stimulsoft.Report.Dashboard.IStiDatePickerElement;
    import StiDataFilterCondition = Stimulsoft.Data.Engine.StiDataFilterCondition;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiInitialDateRangeSelection = Stimulsoft.Report.Dashboard.StiInitialDateRangeSelection;
    import DateTime = Stimulsoft.System.DateTime;
    import List = Stimulsoft.System.Collections.List;
    class StiDatePickerHelper {
        static calculateRangeFromInitial(selection: StiInitialDateRangeSelection, start: {
            ref: DateTime;
        }, end: {
            ref: DateTime;
        }): void;
        static fetchDefaultUserFilters(datePickerElement: StiDatePickerElement): Promise<List<StiDataFilterRule>>;
        private static getSingleDefaultUserFilters;
        private static getRangeDefaultUserFilters;
        private static getAutoRangeDefaultUserFilters;
        static getValueMeterExpression(datePickerElement: StiDatePickerElement): string;
        static getCondition(datePickerElement: StiDatePickerElement): StiDataFilterCondition;
        static getFormatedDate(dateTime: DateTime): string;
        static getVariableSpecifiedAsValue(element: IStiDatePickerElement): IStiAppVariable;
        static isVariableSpecifiedAsValue(element: IStiDatePickerElement): boolean;
        static getDefaultValue(element: IStiDatePickerElement): any;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Design {
    class StiElementEditorConsts {
        elementEditor: string;
        textFormatEditor: string;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Design {
    class StiElementLayoutConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Design {
    class StiElementStyleConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Design {
    class StiMeterListConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Design {
    class StiTitleConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Render {
    import StiElement = Stimulsoft.Dashboard.Components.StiElement;
    import StiReport = Stimulsoft.Report.StiReport;
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiElementBuilder {
        protected getSeriesKeysLimitCount(element: StiElement): number;
        protected getSeries(table: StiDataTable, seriesIndex: number, seriesKey: any, report: StiReport, shortValue?: boolean): string;
        protected getValue(table: StiDataTable, valueIndex: number, seriesIndex: number, seriesCount: number, seriesKey: string): number;
        protected getTarget(table: StiDataTable, targetIndex: number, seriesIndex: number, seriesCount: number, seriesKey: string): number;
        protected getNullableValue(table: StiDataTable, valueIndex: number, seriesIndex: number, seriesCount: number, seriesKey: string): number;
        protected getSeriesKeyValues(table: StiDataTable, seriesIndex: number, count?: number): List<any>;
        protected getSeriesKeys(table: StiDataTable, seriesIndex: number, count?: number): List<string>;
        private replaceDbNull;
        protected toString(value: any): string;
        protected toReadableString(value: any, report: StiReport): string;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Gauge {
    import IStiMinGaugeMeter = Stimulsoft.Base.Meters.IStiMinGaugeMeter;
    class StiMinGaugeMeter extends StiMeasureMeter implements IStiMinGaugeMeter {
        private static ImplementsStiMinGaugeMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Gauge {
    import IStiMaxGaugeMeter = Stimulsoft.Base.Meters.IStiMaxGaugeMeter;
    class StiMaxGaugeMeter extends StiMeasureMeter implements IStiMaxGaugeMeter {
        private static ImplementsStiMaxGaugeMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Visuals.Gauge {
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    class StiGaugeIteration {
        gauge: StiGauge;
        series: string;
    }
}
declare namespace Stimulsoft.Dashboard.Render {
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import Size = Stimulsoft.System.Drawing.Size;
    import StiGaugeElement = Stimulsoft.Dashboard.Components.Gauge.StiGaugeElement;
    import StiGaugeIteration = Stimulsoft.Dashboard.Visuals.Gauge.StiGaugeIteration;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiGaugeElementBuilder extends StiElementBuilder {
        private findMinMaxValues;
        render(element: StiGaugeElement, size: Size, dataTable: StiDataTable): List<StiGaugeIteration>;
        render2(element: StiGaugeElement, size: Size, dataTable: StiDataTable): () => List<StiGaugeIteration>;
        private fundActualValues;
        private getSummary;
        private static setStyle;
        private static getTargetBrush;
        private static getTickMarkBrush;
        private static getTickLabelBrush;
        private createScale;
        private static calculateMinorInterval;
        private createFullCircularScale;
        createHalfCircularScale(element: StiGaugeElement, skipRotateLabels: boolean, size: SizeD, minValue: number, maxValue: number, target?: number): StiScaleBase;
        createLinearScale(element: StiGaugeElement, minValue: number, maxValue: number, isHorizontal: boolean, target: number): StiScaleBase;
        private static addRadialRanges;
        createBullet(element: StiGaugeElement, minValue: number, maxValue: number, target?: number): StiScaleBase;
        private static addLinearRanges;
        private getMinValue;
        private getMaxValue;
        private getValueMeterIndex;
        private getMinMeterIndex;
        private getMaxMeterIndex;
        private getSeriesMeterIndex;
        private getTargetMeterIndex;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiGaugeRange = Stimulsoft.Report.Dashboard.IStiGaugeRange;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiGaugeRange implements IStiJsonReportObject, IStiGaugeRange, ICloneable {
        private static ImplementsStiGaugeRange;
        implements(): any[];
        clone(): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        color: Color;
        private shouldSerializeColor;
        get start(): number;
        set start(value: number);
        get end(): number;
        set end(value: number);
        startExpression: string;
        endExpression: string;
        static loadFromJson(json: StiJson): StiGaugeRange;
        static loadFromXml(xmlNode: XmlNode): StiGaugeRange;
        saveToString(): string;
        getStringRepresentation(): string;
        constructor(color?: Color, startExpression?: string, endExpression?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    import IStiInteractionLayout = Stimulsoft.Report.Dashboard.IStiInteractionLayout;
    import StiAvailableInteractionOnDataManipulation = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnDataManipulation;
    import StiAvailableInteractionOnHover = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnHover;
    import IStiAllowUserSortingDashboardInteraction = Stimulsoft.Report.Dashboard.IStiAllowUserSortingDashboardInteraction;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    class StiGaugeDashboardInteraction extends StiDashboardInteraction implements IStiAllowUserSortingDashboardInteraction, IStiJsonReportObject, IStiInteractionLayout {
        private static ImplementsIStiGaugeDashboardInteraction;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        availableOnHover: StiAvailableInteractionOnHover;
        availableOnDataManipulation: StiAvailableInteractionOnDataManipulation;
        allowUserSorting: boolean;
        showFullScreenButton: boolean;
        showSaveButton: boolean;
        showViewDataButton: boolean;
        fileName: string;
        headerText: string;
        footerText: string;
        get isDefaultLayout(): boolean;
        isDefault(): boolean;
        constructor(fileName?: string, headerText?: string, footerText?: string, showFullScreenButton?: boolean, showSaveButton?: boolean, allowUserSorting?: boolean, showViewDataButton?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiLabelRotationMode = Stimulsoft.Report.Gauge.StiLabelRotationMode;
    import StiLabelPlacement = Stimulsoft.Report.Dashboard.StiLabelPlacement;
    import IStiGaugeLabels = Stimulsoft.Report.Dashboard.IStiGaugeLabels;
    class StiGaugeLabels implements IStiJsonReportObject, IStiGaugeLabels {
        private static ImplementsStiGaugeLabels;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiGaugeLabels;
        visible: boolean;
        placement: StiLabelPlacement;
        rotationMode: StiLabelRotationMode;
        isDefault(): boolean;
        constructor(visible?: boolean, placement?: StiLabelPlacement, rotationMode?: StiLabelRotationMode);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Gauge {
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import IStiGauge = Stimulsoft.Report.Components.Gauge.IStiGauge;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiGaugeRange = Stimulsoft.Dashboard.Components.Gauge.StiGaugeRange;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import List = Stimulsoft.System.Collections.List;
    import StiTitle = Stimulsoft.Dashboard.Components.StiTitle;
    import Size = Stimulsoft.System.Drawing.Size;
    import IStiGaugeRange = Stimulsoft.Report.Dashboard.IStiGaugeRange;
    import StiSeriesGaugeMeter = Stimulsoft.Dashboard.Components.Gauge.StiSeriesGaugeMeter;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiGaugeElement = Stimulsoft.Report.Dashboard.IStiGaugeElement;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiGaugeLabels = Stimulsoft.Dashboard.Components.Gauge.StiGaugeLabels;
    class StiGaugeElement extends StiElement implements IStiGaugeElement, IStiTitleElement, IStiFont, IStiForeColor, IStiElementLayout, IStiElementInteraction, IStiJsonReportObject, IStiGlobalizationProvider {
        private static ImplementsStiGaugeElement;
        implements(): any[];
        clone(cloneProperties: boolean): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        addValue2(cell: IStiAppDataCell): void;
        addValue(meter: IStiMeter): void;
        removeValue(): void;
        getValue(): IStiMeter;
        getValue2(meter: IStiMeter): IStiMeter;
        createNewValue(): void;
        addSeries2(cell: IStiAppDataCell): void;
        addSeries(meter: IStiMeter): void;
        removeSeries(): void;
        getSeries(): IStiMeter;
        getSeries2(meter: IStiMeter): IStiMeter;
        createNewSeries(): void;
        addTarget2(cell: IStiAppDataCell): void;
        addTarget(meter: IStiMeter): void;
        removeTarget(): void;
        getTarget(): IStiMeter;
        getTarget2(meter: IStiMeter): IStiMeter;
        createNewTarget(): void;
        getRanges(): List<IStiGaugeRange>;
        private getPreferedColor;
        addRange(): IStiGaugeRange;
        removeRange(index: number): void;
        createdDefaultRanges(): void;
        getGaugeComponent(size?: Size): Promise<IStiGauge>;
        convertFrom(element: IStiElement): void;
        group: string;
        title: StiTitle;
        layout: StiElementLayout;
        crossFiltering: boolean;
        private shouldSerializeLayout;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        font: Font;
        private shouldSerializeFont;
        foreColor: Color;
        private shouldSerializeForeColor;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        userSorts: List<StiDataSortRule>;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        get toolboxPosition(): number;
        get localizedName(): string;
        helpUrl: string;
        dashboardInteraction: IStiDashboardInteraction;
        get shouldSerializeDashboardInteraction(): boolean;
        valueFormat: StiFormatService;
        private static getValueFormatDefault;
        private shouldSerializeValueFormat;
        shortValue: boolean;
        labels: StiGaugeLabels;
        private ShouldSerializeLabels;
        value: StiValueGaugeMeter;
        series: StiSeriesGaugeMeter;
        target: StiTargetGaugeMeter;
        minimum: number;
        maximum: number;
        calculationMode: Report.Gauge.StiGaugeCalculationMode;
        rangeMode: Report.Gauge.StiGaugeRangeMode;
        rangeType: Report.Gauge.StiGaugeRangeType;
        type: Report.Gauge.StiGaugeType;
        ranges: List<StiGaugeRange>;
        isSampleForStyles: boolean;
        createNew(): StiComponent;
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Gauge.Design {
    class StiGaugeRangeConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Helpers {
    class StiMeterCreator {
        static neww(identName: string): StiMeter;
        static neww2(ident: StiMeterIdent): StiMeter;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Helpers {
    class StiMeterJsonConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    import List = Stimulsoft.System.Collections.List;
    class StiImageDashboardInteraction extends StiDashboardInteraction {
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        onClick: StiInteractionOnClick;
        isDefault(): boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Text {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiImageMeter extends StiDimensionMeter implements IStiValueMeter {
        private static ImplementsStiImageMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key: string, expression: string, label: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Image {
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import List = Stimulsoft.System.Collections.List;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import Image = Stimulsoft.System.Drawing.Image;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiImageElement = Stimulsoft.Report.Dashboard.IStiImageElement;
    import IStiVertAlignment = Stimulsoft.Report.Components.IStiVertAlignment;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiImageElement extends StiElement implements IStiHorAlignment, IStiVertAlignment, IStiImageElement, IStiTitleElement, IStiJsonReportObject, IStiGlobalizationProvider, IStiElementInteraction {
        private static ImplementsStiImageElement;
        implements(): any[];
        clone(cloneProperties: boolean): any;
        get componentId(): StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get isDefined(): boolean;
        get isQuerable(): boolean;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        group: string;
        title: StiTitle;
        get imageToDraw(): Promise<Image>;
        private _image;
        get image(): Image;
        set image(value: Image);
        imageHyperlink: string;
        aspectRatio: boolean;
        icon: StiFontIcons;
        iconColor: Color;
        crossFiltering: boolean;
        copyAllImageProperties(image: IStiImageElement): void;
        horAlignment: StiHorAlignment;
        vertAlignment: StiVertAlignment;
        shouldSerializePadding(): boolean;
        setString(propertyName: string, value: string): void;
        dashboardInteraction: IStiDashboardInteraction;
        get shouldSerializeDashboardInteraction(): boolean;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        getNestedPages(): List<StiPage>;
        createNew(): StiComponent;
        resetAllImageProperties(): void;
        get isImageDefined(): boolean;
        get isImageIconDefined(): boolean;
        get isImageHyperlinkDefined(): boolean;
        isImageHyperlinkDataColumnDefined(): boolean;
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Image.Design {
    class StiImageBytesConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    import IStiInteractionLayout = Stimulsoft.Report.Dashboard.IStiInteractionLayout;
    import StiAvailableInteractionOnDataManipulation = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnDataManipulation;
    import IStiAllowUserSortingDashboardInteraction = Stimulsoft.Report.Dashboard.IStiAllowUserSortingDashboardInteraction;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import List = Stimulsoft.System.Collections.List;
    class StiIndicatorDashboardInteraction extends StiDashboardInteraction implements IStiAllowUserSortingDashboardInteraction, IStiJsonReportObject, IStiInteractionLayout {
        private static ImplementsIStiIndicatorDashboardInteraction;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        availableOnDataManipulation: StiAvailableInteractionOnDataManipulation;
        allowUserDrillDown: boolean;
        allowUserSorting: boolean;
        onClick: StiInteractionOnClick;
        shouldSerializeOnClick(): boolean;
        showFullScreenButton: boolean;
        showSaveButton: boolean;
        showViewDataButton: boolean;
        fileName: string;
        headerText: string;
        footerText: string;
        get isDefaultLayout(): boolean;
        isDefault(): boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>, allowUserDrillDown?: boolean, allowUserSorting?: boolean, fileName?: string, headerText?: string, footerText?: string, showFullScreenButton?: boolean, showSaveButton?: boolean, showViewDataButton?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Indicator {
    import StiIndicatorIconRangeMode = Stimulsoft.Report.Dashboard.StiIndicatorIconRangeMode;
    import StiIndicatorIconMode = Stimulsoft.Report.Dashboard.StiIndicatorIconMode;
    import IStiAllowSortByVariation = Stimulsoft.Data.Engine.IStiAllowSortByVariation;
    import StiTargetMode = Stimulsoft.Report.Dashboard.StiTargetMode;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import StiIndicatorConditionPermissions = Stimulsoft.Report.Dashboard.StiIndicatorConditionPermissions;
    import StiIndicatorFieldCondition = Stimulsoft.Report.Dashboard.StiIndicatorFieldCondition;
    import IStiIndicatorElementCondition = Stimulsoft.Report.Dashboard.IStiIndicatorElementCondition;
    import StiIconAlignment = Stimulsoft.Report.Dashboard.StiIconAlignment;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiFontIconSet = Stimulsoft.Report.Helpers.StiFontIconSet;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import List = Stimulsoft.System.Collections.List;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiValueIndicatorMeter = Stimulsoft.Dashboard.Components.Indicator.StiValueIndicatorMeter;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiIndicatorElement = Stimulsoft.Report.Dashboard.IStiIndicatorElement;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import StiFontSizeMode = Stimulsoft.Report.Dashboard.StiFontSizeMode;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import IStiIndicatorIconRange = Stimulsoft.Report.Dashboard.IStiIndicatorIconRange;
    class StiIndicatorElement extends StiElement implements IStiTextFormat, IStiIndicatorElement, IStiTitleElement, IStiFont, IStiForeColor, IStiElementLayout, IStiElementInteraction, IStiJsonReportObject, IStiGlobalizationProvider, IStiAllowSortByVariation {
        private static ImplementsStiIndicatorElement;
        implements(): any[];
        clone(cloneProperties: boolean): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        group: string;
        addValue2(cell: IStiAppDataCell): void;
        addValue(meter: IStiMeter): void;
        removeValue(): void;
        getValue(): IStiMeter;
        getValue2(meter: IStiMeter): IStiMeter;
        createNewValue(): void;
        addTarget2(cell: IStiAppDataCell): void;
        addTarget(meter: IStiMeter): void;
        removeTarget(): void;
        getTarget(): IStiMeter;
        getTarget2(meter: IStiMeter): IStiMeter;
        createNewTarget(): void;
        addSeries2(cell: IStiAppDataCell): void;
        addSeries(meter: IStiMeter): void;
        removeSeries(): void;
        getSeries(): IStiMeter;
        getSeries2(meter: IStiMeter): IStiMeter;
        createNewSeries(): void;
        getIconRanges(): List<IStiIndicatorIconRange>;
        addRange(): IStiIndicatorIconRange;
        removeRange(index: number): void;
        createdDefaultRanges(): void;
        addIndicatorCondition(field: StiIndicatorFieldCondition, condition: StiFilterCondition, value: string, icon: StiFontIcons, iconColor: Color, targetIcon: StiFontIcons, targetIconColor: Color, customIcon: [], iconAlignment: StiIconAlignment, targetIconAlignment: StiIconAlignment, permissions: StiIndicatorConditionPermissions, font: Font, textColor: Color, backColor: Color): void;
        fetchIndicatorConditions(): List<IStiIndicatorElementCondition>;
        clearIndicatorConditions(): void;
        convertFrom(element: IStiElement): void;
        textFormat: StiFormatService;
        private shouldSerializeTextFormat;
        font: Font;
        private shouldSerializeFont;
        foreColor: Color;
        private shouldSerializeForeColor;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        title: StiTitle;
        layout: StiElementLayout;
        private shouldSerializeLayout;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        topN: StiDataTopN;
        dataTransformation: {};
        private shouldSerializeDataTransformation;
        isDefaultDataTransformation(): boolean;
        dataFilters: List<StiDataFilterRule>;
        userSorts: List<StiDataSortRule>;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        dashboardInteraction: IStiDashboardInteraction;
        get shouldSerializeDashboardInteraction(): boolean;
        glyphColor: Color;
        private shouldSerializeGlyphColor;
        value: StiValueIndicatorMeter;
        target: StiTargetIndicatorMeter;
        series: StiSeriesIndicatorMeter;
        customIcon: number[];
        icon: StiFontIcons;
        iconSet: StiFontIconSet;
        iconAlignment: StiIconAlignment;
        targetMode: StiTargetMode;
        fontSizeMode: StiFontSizeMode;
        iconMode: StiIndicatorIconMode;
        iconRangeMode: StiIndicatorIconRangeMode;
        iconRanges: List<StiIndicatorIconRange>;
        indicatorConditions: List<StiIndicatorElementCondition>;
        crossFiltering: boolean;
        private shouldSerializeConditions;
        isSampleForStyles: boolean;
        getNestedPages(): List<StiPage>;
        createNew(): StiComponent;
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Indicator {
    import Font = Stimulsoft.System.Drawing.Font;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiIndicatorElementCondition = Stimulsoft.Report.Dashboard.IStiIndicatorElementCondition;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiIndicatorFieldCondition = Stimulsoft.Report.Dashboard.StiIndicatorFieldCondition;
    import StiIconAlignment = Stimulsoft.Report.Dashboard.StiIconAlignment;
    import StiIndicatorConditionPermissions = Stimulsoft.Report.Dashboard.StiIndicatorConditionPermissions;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiIndicatorElementCondition implements ICloneable, IStiIndicatorElementCondition, IStiJsonReportObject {
        private static ImplementsStiIndicatorElementCondition;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        iconColor: Color;
        icon: StiFontIcons;
        targetIconColor: Color;
        targetIcon: StiFontIcons;
        condition: StiFilterCondition;
        field: StiIndicatorFieldCondition;
        value: string;
        customIcon: number[];
        permissions: StiIndicatorConditionPermissions;
        textColor: Color;
        backColor: Color;
        font: Font;
        iconAlignment: StiIconAlignment;
        targetIconAlignment: StiIconAlignment;
        static createFromJson(json: StiJson): StiIndicatorElementCondition;
        static createFromXml(xmlNode: XmlNode): StiIndicatorElementCondition;
        constructor(field?: StiIndicatorFieldCondition, condition?: StiFilterCondition, value?: string, icon?: StiFontIcons, iconColor?: Color, targetIcon?: StiFontIcons, targetIconColor?: Color, customIcon?: number[], iconAlignment?: StiIconAlignment, targetIconAlignment?: StiIconAlignment, permissions?: StiIndicatorConditionPermissions, font?: Font, textColor?: Color, backColor?: Color);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Indicator {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import IStiIndicatorIconRange = Stimulsoft.Report.Dashboard.IStiIndicatorIconRange;
    class StiIndicatorIconRange implements IStiJsonReportObject, IStiIndicatorIconRange, ICloneable {
        private static ImplementsStiIndicatorIconRange;
        implements(): any[];
        clone(): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        icon: StiFontIcons;
        startExpression: string;
        endExpression: string;
        static loadFromJson(json: StiJson): StiIndicatorIconRange;
        static loadFromXml(xmlNode: XmlNode): StiIndicatorIconRange;
        saveToString(): string;
        getStringRepresentation(): string;
        constructor(icon?: StiFontIcons, start?: string, end?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.ListBox {
    import StiItemOrientation = Stimulsoft.Report.Dashboard.StiItemOrientation;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiItemSelectionMode = Stimulsoft.Report.Dashboard.StiItemSelectionMode;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiNameListBoxMeter = Stimulsoft.Dashboard.Components.ListBox.StiNameListBoxMeter;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiListBoxElement = Stimulsoft.Report.Dashboard.IStiListBoxElement;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    class StiListBoxElement extends StiElement implements IStiListBoxElement, IStiTitleElement, IStiJsonReportObject, IStiGlobalizationProvider {
        private static ImplementsStiListBoxElement;
        implements(): any[];
        clone(cloneProperties: boolean): any;
        get componentId(): StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        group: string;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        showAllValue: boolean;
        showBlanks: boolean;
        selectionMode: StiItemSelectionMode;
        orientation: StiItemOrientation;
        title: StiTitle;
        getParentKey(): string;
        setParentKey(key: string): void;
        applyDefaultFilters(): Promise<void>;
        addKeyMeter2(cell: IStiAppDataCell): void;
        addKeyMeter(meter: IStiMeter): void;
        getKeyMeter(): IStiMeter;
        removeKeyMeter(): void;
        createNewKeyMeter(): void;
        addNameMeter2(cell: IStiAppDataCell): void;
        addNameMeter(meter: IStiMeter): void;
        getNameMeter(): IStiMeter;
        removeNameMeter(): void;
        createNewNameMeter(): void;
        createNextMeter(cell: IStiAppDataCell): void;
        convertFrom(element: IStiElement): void;
        userFilters: List<StiDataFilterRule>;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        font: Font;
        private shouldSerializeFont;
        foreColor: Color;
        private shouldSerializeForeColor;
        textFormat: StiFormatService;
        private shouldSerializeTextFormat;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        createNew(): StiComponent;
        parentKey: string;
        nameMeter: StiNameListBoxMeter;
        keyMeter: StiKeyListBoxMeter;
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.ListBox {
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiListBoxHelper {
        static fetchItems(listBoxElement: StiListBoxElement, dataTable: StiDataTable, showBlanks: boolean): List<StiListBoxItem>;
        static isBlank(data: any): boolean;
        static fetchDefaultUserFilters(listBoxElement: StiListBoxElement): Promise<List<StiDataFilterRule>>;
        static getNameMeterIndex(table: StiDataTable): number;
        static getKeyMeterIndex(table: StiDataTable): number;
        static getKeyMeterExpression(listBoxElement: StiListBoxElement): string;
        static format(listBoxElement: StiListBoxElement, value: any): string;
    }
}
declare namespace Stimulsoft.Dashboard.Components.ListBox {
    class StiListBoxItem {
        label: string;
        value: any;
        toString(): string;
        constructor(label: string, value?: any);
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    import IStiInteractionLayout = Stimulsoft.Report.Dashboard.IStiInteractionLayout;
    import StiAvailableInteractionOnDataManipulation = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnDataManipulation;
    import StiAvailableInteractionOnHover = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnHover;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    class StiOnlineMapDashboardInteraction extends StiDashboardInteraction implements IStiJsonReportObject, IStiInteractionLayout {
        private static ImplementsIStiOnlineMapDashboardInteraction;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        availableOnHover: StiAvailableInteractionOnHover;
        availableOnDataManipulation: StiAvailableInteractionOnDataManipulation;
        showFullScreenButton: boolean;
        showSaveButton: boolean;
        showViewDataButton: boolean;
        fileName: string;
        headerText: string;
        footerText: string;
        get isDefaultLayout(): boolean;
        isDefault(): boolean;
        constructor(fileName?: string, headerText?: string, footerText?: string, showFullScreenButton?: boolean, showSaveButton?: boolean, showViewDataButton?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.OnlineMap {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiOnlineMapElement = Stimulsoft.Report.Dashboard.IStiOnlineMapElement;
    import StiOnlineMapLocationType = Stimulsoft.Report.Dashboard.StiOnlineMapLocationType;
    import StiOnlineMapCulture = Stimulsoft.Report.Dashboard.StiOnlineMapCulture;
    import StiOnlineMapLocationColorType = Stimulsoft.Report.Dashboard.StiOnlineMapLocationColorType;
    import StiOnlineMapValueViewMode = Stimulsoft.Report.Dashboard.StiOnlineMapValueViewMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiOnlineMapElement extends StiElement implements IStiOnlineMapElement, IStiTitleElement, IStiElementLayout, IStiElementInteraction, IStiJsonReportObject, IStiGlobalizationProvider {
        private static ImplementsStiOnlineMapElement;
        implements(): any[];
        clone(cloneProperties: boolean): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        group: string;
        title: StiTitle;
        layout: StiElementLayout;
        private shouldSerializeLayout;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        createNextMeter(cell: IStiAppDataCell): void;
        addLatitudeMeter2(cell: IStiAppDataCell): void;
        addLatitudeMeter(meter: IStiMeter): void;
        getLatitudeMeter(): IStiMeter;
        removeLatitudeMeter(): void;
        createNewLatitudeMeter(): void;
        addLongitudeMeter2(cell: IStiAppDataCell): void;
        addLongitudeMeter(meter: IStiMeter): void;
        getLongitudeMeter(): IStiMeter;
        removeLongitudeMeter(): void;
        createNewLongitudeMeter(): void;
        addLocationMeter2(cell: IStiAppDataCell): void;
        addLocationMeter(meter: IStiMeter): void;
        getLocationMeter(): IStiMeter;
        removeLocationMeter(): void;
        createNewLocationMeter(): void;
        addLocationColorMeter2(cell: IStiAppDataCell): void;
        addLocationColorMeter(meter: IStiMeter): void;
        getLocationColorMeter(): IStiMeter;
        removeLocationColorMeter(): void;
        createNewLocationColorMeter(): void;
        addLocationValueMeter2(cell: IStiAppDataCell): void;
        addLocationValueMeter(meter: IStiMeter): void;
        getLocationValueMeter(): IStiMeter;
        removeLocationValueMeter(): void;
        createNewLocationValueMeter(): void;
        addLocationArgumentMeter(cell: IStiAppDataCell): void;
        addLocationArgumentMeter2(meter: IStiMeter): void;
        getLocationArgumentMeter(): IStiMeter;
        removeLocationArgumentMeter(): void;
        createNewLocationArgumentMeter(): void;
        convertFrom(element: IStiElement): void;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        get toolboxPosition(): number;
        get localizedName(): string;
        helpUrl: string;
        dashboardInteraction: IStiDashboardInteraction;
        get shouldSerializeDashboardInteraction(): boolean;
        latitude: StiLatitudeMapMeter;
        longitude: StiLongitudeMapMeter;
        location: StiLocationMapMeter;
        locationColorMeter: StiLocationMapMeter;
        locationValue: StiLocationMapMeter;
        locationArgument: StiLocationMapMeter;
        locationType: StiOnlineMapLocationType;
        culture: StiOnlineMapCulture;
        locationColorType: StiOnlineMapLocationColorType;
        valueViewMode: StiOnlineMapValueViewMode;
        locationColor: Color;
        icon: StiFontIcons;
        iconColor: Color;
        customIcon: number[];
        crossFiltering: boolean;
        createNew(): StiComponent;
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import StiMeter = Stimulsoft.Dashboard.Components.StiMeter;
    import List = Stimulsoft.System.Collections.List;
    import StiPivotTableElement = Stimulsoft.Dashboard.Components.PivotTable.StiPivotTableElement;
    class StiPivotTableElementSelection {
        private static hash;
        static getSelected(element: StiPivotTableElement): List<StiMeter>;
        static getSelectedObjects(element: StiPivotTableElement): List<any>;
        static isSelected(element: StiPivotTableElement, column: StiMeter): boolean;
        static select(element: StiPivotTableElement, column: StiMeter): void;
        static resetSelection(element: StiPivotTableElement): void;
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    import IStiInteractionLayout = Stimulsoft.Report.Dashboard.IStiInteractionLayout;
    import StiAvailableInteractionOnDataManipulation = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnDataManipulation;
    import StiAvailableInteractionOnHover = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnHover;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    class StiPivotTableDashboardInteraction extends StiDashboardInteraction implements IStiJsonReportObject, IStiInteractionLayout {
        private static ImplementsIStiPivotTableDashboardInteraction;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        availableOnHover: StiAvailableInteractionOnHover;
        availableOnDataManipulation: StiAvailableInteractionOnDataManipulation;
        showFullScreenButton: boolean;
        showSaveButton: boolean;
        showViewDataButton: boolean;
        fileName: string;
        headerText: string;
        footerText: string;
        get isDefaultLayout(): boolean;
        isDefault(): boolean;
        constructor(fileName?: string, headerText?: string, footerText?: string, showFullScreenButton?: boolean, showSaveButton?: boolean, showViewDataButton?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.PivotTable {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiSummaryDirection = Stimulsoft.Report.CrossTab.Core.StiSummaryDirection;
    import StiIconAlignment = Stimulsoft.Report.Dashboard.StiIconAlignment;
    import StiConditionPermissions = Stimulsoft.Report.Components.StiConditionPermissions;
    import IStiPivotTableElementCondition = Stimulsoft.Report.Dashboard.IStiPivotTableElementCondition;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiPivotSummary = Stimulsoft.Dashboard.Components.PivotTable.StiPivotSummary;
    import StiPivotColumn = Stimulsoft.Dashboard.Components.PivotTable.StiPivotColumn;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiPivotTableElement = Stimulsoft.Report.Dashboard.IStiPivotTableElement;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiPivotTableElement extends StiElement implements IStiPivotTableElement, IStiTitleElement, IStiElementLayout, IStiElementInteraction, IStiJsonReportObject, IStiGlobalizationProvider {
        private static ImplementsStiPivotTableElement;
        implements(): any[];
        maxIconSize: number;
        clone(cloneProperties: boolean): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        retrieveUsedDataNames(): List<string>;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        get isDefined(): boolean;
        group: string;
        title: StiTitle;
        layout: StiElementLayout;
        private shouldSerializeLayout;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        crossFiltering: boolean;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        summaryDirection: StiSummaryDirection;
        createNextMeter(cell: IStiAppDataCell): void;
        createNewColumn(): void;
        getColumn2(cell: IStiAppDataCell): IStiMeter;
        getColumn(meter: IStiMeter): IStiMeter;
        getColumnByIndex(index: number): IStiMeter;
        insertColumn(index: number, meter: IStiMeter): void;
        removeColumn(index: number): void;
        removeAllColumns(): void;
        createNewRow(): void;
        getRow2(cell: IStiAppDataCell): IStiMeter;
        getRow(meter: IStiMeter): IStiMeter;
        getRowByIndex(index: number): IStiMeter;
        insertRow(index: number, meter: IStiMeter): void;
        removeRow(index: number): void;
        removeAllRows(): void;
        createNewSummary(): void;
        getSummary2(cell: IStiAppDataCell): IStiMeter;
        getSummary(meter: IStiMeter): IStiMeter;
        getSummaryByIndex(index: number): IStiMeter;
        insertSummary(index: number, meter: IStiMeter): void;
        removeSummary(index: number): void;
        removeAllSummaries(): void;
        addPivotTableCondition(keyValueMeter: string, dataType: StiFilterDataType, condition: StiFilterCondition, value: string, font: Font, textColor: Color, backColor: Color, permissions: StiConditionPermissions, icon: StiFontIcons, iconAlignment: StiIconAlignment, customIcon: number[], iconColor: Color): void;
        getAllMeters(): List<IStiMeter>;
        fetchPivotTableConditions(): List<IStiPivotTableElementCondition>;
        clearPivotTableConditions(): void;
        convertFrom(element: IStiElement): void;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        get toolboxPosition(): number;
        get localizedName(): string;
        helpUrl: string;
        dashboardInteraction: IStiDashboardInteraction;
        get shouldSerializeDashboardInteraction(): boolean;
        columns: List<StiPivotColumn>;
        private shouldSerializeColumns;
        rows: List<StiPivotRow>;
        private shouldSerializeRows;
        summaries: List<StiPivotSummary>;
        private shouldSerializeSummaries;
        totalLabel: string;
        pivotTableConditions: List<IStiPivotTableElementCondition>;
        shouldSerializeConditions(): boolean;
        createNew(): StiComponent;
        getFormatObjects(): List<any>;
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.PivotTable {
    import IAsIs = Stimulsoft.System.IAsIs;
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    import StiFilterDataType = Stimulsoft.Dashboard.StiFilterDataType;
    import StiFilterCondition = Stimulsoft.Dashboard.StiFilterCondition;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import Size = Stimulsoft.System.Drawing.Size;
    import StiIconAlignment = Stimulsoft.Report.Dashboard.StiIconAlignment;
    import StiConditionPermissions = Stimulsoft.Report.Components.StiConditionPermissions;
    import IStiPivotTableElementCondition = Stimulsoft.Report.Dashboard.IStiPivotTableElementCondition;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiPivotTableElementCondition implements IStiPivotTableElementCondition, IAsIs {
        private static ImplementsStiPivotTableElementCondition;
        implements(): any[];
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        clone(): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        static loadFromJson(jObject: StiJson): StiPivotTableElementCondition;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromXml(xmlNode: XmlNode): any;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get iconFontSize(): number;
        textColor: Color;
        backColor: Color;
        font: Font;
        permissions: StiConditionPermissions;
        private _customIcon;
        get customIcon(): number[];
        set customIcon(value: number[]);
        icon: StiFontIcons;
        iconAlignment: StiIconAlignment;
        condition: StiFilterCondition;
        dataType: StiFilterDataType;
        value: string;
        keyValueMeter: string;
        iconColor: Color;
        isDefault(): boolean;
        private _iconSize;
        get iconSize(): Size;
        getIcon(): Promise<number[]>;
        getUniqueCode(): number;
        constructor(keyValueMeter?: string, dataType?: StiFilterDataType, condition?: StiFilterCondition, value?: string, font?: Font, textColor?: Color, backColor?: Color, permissions?: StiConditionPermissions, icon?: StiFontIcons, iconAlignment?: StiIconAlignment, customIcon?: number[], iconColor?: Color);
    }
}
declare namespace Stimulsoft.Dashboard.Components.PivotTable.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    class StiPivotColumnConverter extends StiMeterConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.PivotTable.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    class StiPivotRowConverter extends StiMeterConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.PivotTable.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    class StiPivotSummaryConverter extends StiMeterConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    import IStiInteractionLayout = Stimulsoft.Report.Dashboard.IStiInteractionLayout;
    import StiAvailableInteractionOnDataManipulation = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnDataManipulation;
    import StiAvailableInteractionOnHover = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnHover;
    import IStiAllowUserSortingDashboardInteraction = Stimulsoft.Report.Dashboard.IStiAllowUserSortingDashboardInteraction;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    class StiProgressDashboardInteraction extends StiDashboardInteraction implements IStiAllowUserSortingDashboardInteraction, IStiJsonReportObject, IStiInteractionLayout {
        private static ImplementsIStiProgressDashboardInteraction;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        availableOnHover: StiAvailableInteractionOnHover;
        availableOnDataManipulation: StiAvailableInteractionOnDataManipulation;
        allowUserSorting: boolean;
        showFullScreenButton: boolean;
        showSaveButton: boolean;
        showViewDataButton: boolean;
        fileName: string;
        headerText: string;
        footerText: string;
        get isDefaultLayout(): boolean;
        isDefault(): boolean;
        constructor(fileName?: string, headerText?: string, footerText?: string, showFullScreenButton?: boolean, showSaveButton?: boolean, allowUserSorting?: boolean, showViewDataButton?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Progress {
    import StiProgressConditionPermissions = Stimulsoft.Report.Dashboard.StiProgressConditionPermissions;
    import StiProgressFieldCondition = Stimulsoft.Report.Dashboard.StiProgressFieldCondition;
    import IStiAllowSortByVariation = Stimulsoft.Data.Engine.IStiAllowSortByVariation;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiSeriesColors = Stimulsoft.Report.Dashboard.IStiSeriesColors;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import StiProgressElementMode = Stimulsoft.Report.Dashboard.StiProgressElementMode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import List = Stimulsoft.System.Collections.List;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTargetProgressMeter = Stimulsoft.Dashboard.Components.Progress.StiTargetProgressMeter;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiProgressElement = Stimulsoft.Report.Dashboard.IStiProgressElement;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import IStiProgressElementCondition = Stimulsoft.Report.Dashboard.IStiProgressElementCondition;
    class StiProgressElement extends StiElement implements IStiTextFormat, IStiProgressElement, IStiTitleElement, IStiFont, IStiForeColor, IStiElementLayout, IStiElementInteraction, IStiJsonReportObject, IStiGlobalizationProvider, IStiSeriesColors, IStiAllowSortByVariation {
        private static ImplementsStiProgressElement;
        implements(): any[];
        clone(cloneProperties: boolean): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        group: string;
        addValue2(cell: IStiAppDataCell): void;
        addValue(meter: IStiMeter): void;
        removeValue(): void;
        getValue(): IStiMeter;
        getValue2(meter: IStiMeter): IStiMeter;
        createNewValue(): void;
        addTarget2(cell: IStiAppDataCell): void;
        addTarget(meter: IStiMeter): void;
        removeTarget(): void;
        getTarget(): IStiMeter;
        getTarget2(meter: IStiMeter): IStiMeter;
        createNewTarget(): void;
        addSeries2(cell: IStiAppDataCell): void;
        addSeries(meter: IStiMeter): void;
        removeSeries(): void;
        getSeries(): IStiMeter;
        getSeries2(meter: IStiMeter): IStiMeter;
        createNewSeries(): void;
        convertFrom(element: IStiElement): void;
        textFormat: StiFormatService;
        private shouldSerializeTextFormat;
        font: Font;
        private shouldSerializeFont;
        foreColor: Color;
        private shouldSerializeForeColor;
        title: StiTitle;
        layout: StiElementLayout;
        private shouldSerializeLayout;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        topN: StiDataTopN;
        dataTransformation: {};
        crossFiltering: boolean;
        private shouldSerializeDataTransformation;
        isDefaultDataTransformation(): boolean;
        dataFilters: List<StiDataFilterRule>;
        userSorts: List<StiDataSortRule>;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        seriesColors: Color[];
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        addProgressCondition(field: StiProgressFieldCondition, condition: StiFilterCondition, value: string, permissions: StiProgressConditionPermissions, font: Font, textColor: Color, color: Color, trackColor: Color): void;
        fetchProgressConditions(): List<IStiProgressElementCondition>;
        clearProgressConditions(): void;
        dashboardInteraction: IStiDashboardInteraction;
        get shouldSerializeDashboardInteraction(): boolean;
        colorEach: boolean;
        value: StiValueProgressMeter;
        target: StiTargetProgressMeter;
        series: StiSeriesProgressMeter;
        mode: StiProgressElementMode;
        progressConditions: List<StiProgressElementCondition>;
        private shouldSerializeConditions;
        isSampleForStyles: boolean;
        createNew(): StiComponent;
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Progress {
    import Font = Stimulsoft.System.Drawing.Font;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiProgressElementCondition = Stimulsoft.Report.Dashboard.IStiProgressElementCondition;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiProgressFieldCondition = Stimulsoft.Report.Dashboard.StiProgressFieldCondition;
    import StiProgressConditionPermissions = Stimulsoft.Report.Dashboard.StiProgressConditionPermissions;
    class StiProgressElementCondition implements IStiJsonReportObject, ICloneable, IStiProgressElementCondition {
        private static ImplementsStiProgressElementCondition;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        condition: StiFilterCondition;
        field: StiProgressFieldCondition;
        value: string;
        permissions: StiProgressConditionPermissions;
        textColor: Color;
        color: Color;
        trackColor: Color;
        font: Font;
        static createFromJson(json: StiJson): StiProgressElementCondition;
        static createFromXml(xmlNode: XmlNode): StiProgressElementCondition;
        constructor(field?: StiProgressFieldCondition, condition?: StiFilterCondition, value?: string, permissions?: StiProgressConditionPermissions, font?: Font, textColor?: Color, color?: Color, trackColor?: Color);
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    import IStiInteractionLayout = Stimulsoft.Report.Dashboard.IStiInteractionLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    import List = Stimulsoft.System.Collections.List;
    class StiRegionMapDashboardInteraction extends StiDashboardInteraction implements IStiJsonReportObject, IStiInteractionLayout {
        private static ImplementsIStiRegionMapDashboardInteraction;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        showFullScreenButton: boolean;
        showSaveButton: boolean;
        showViewDataButton: boolean;
        fileName: string;
        headerText: string;
        footerText: string;
        get isDefaultLayout(): boolean;
        isDefault(): boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>, fileName?: string, headerText?: string, footerText?: string, showFullScreenButton?: boolean, showSaveButton?: boolean, showViewDataButton?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.RegionMap {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiKeyMapMeter = Stimulsoft.Dashboard.Components.RegionMap.StiKeyMapMeter;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiMapData = Stimulsoft.Report.Maps.StiMapData;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiDisplayNameType = Stimulsoft.Report.Maps.StiDisplayNameType;
    import StiMapType = Stimulsoft.Report.Maps.StiMapType;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiMapSource = Stimulsoft.Report.Maps.StiMapSource;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiSkipOwnFilter = Stimulsoft.Report.Dashboard.IStiSkipOwnFilter;
    import IStiRegionMapElement = Stimulsoft.Report.Dashboard.IStiRegionMapElement;
    class StiRegionMapElement extends StiElement implements IStiRegionMapElement, IStiSkipOwnFilter, IStiTitleElement, IStiElementLayout, IStiJsonReportObject, IStiGlobalizationProvider, IStiElementInteraction {
        private static ImplementsStiRegionMapElement;
        implements(): any[];
        clone(cloneProperties: boolean): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        group: string;
        get allowSkipOwnFilter(): boolean;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        get isQuerable(): boolean;
        title: StiTitle;
        layout: StiElementLayout;
        private shouldSerializeLayout;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        userFilters: List<StiDataFilterRule>;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        createNextMeter(cell: IStiAppDataCell): void;
        addKeyMeter2(cell: IStiAppDataCell): void;
        addKeyMeter(meter: IStiMeter): void;
        getKeyMeter(): IStiMeter;
        removeKeyMeter(): void;
        createNewKeyMeter(): void;
        addNameMeter2(cell: IStiAppDataCell): void;
        addNameMeter(meter: IStiMeter): void;
        getNameMeter(): IStiMeter;
        removeNameMeter(): void;
        createNewNameMeter(): void;
        addValueMeter2(cell: IStiAppDataCell): void;
        addValueMeter(meter: IStiMeter): void;
        getValueMeter(): IStiMeter;
        removeValueMeter(): void;
        createNewValueMeter(): void;
        addGroupMeter2(cell: IStiAppDataCell): void;
        addGroupMeter(meter: IStiMeter): void;
        getGroupMeter(): IStiMeter;
        removeGroupMeter(): void;
        createNewGroupMeter(): void;
        addColorMeter2(cell: IStiAppDataCell): void;
        addColorMeter(meter: IStiMeter): void;
        getColorMeter(): IStiMeter;
        removeColorMeter(): void;
        createNewColorMeter(): void;
        convertFrom(element: IStiElement): void;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        get toolboxPosition(): number;
        get localizedName(): string;
        helpUrl: string;
        dashboardInteraction: IStiDashboardInteraction;
        get shouldSerializeDashboardInteraction(): boolean;
        mapIdent: string;
        dataFrom: StiMapSource;
        mapData: string;
        mapType: StiMapType;
        showValue: boolean;
        shortValue: boolean;
        colorEach: boolean;
        showBubble: boolean;
        showName: StiDisplayNameType;
        crossFiltering: boolean;
        keyMeter: StiKeyMapMeter;
        nameMeter: StiNameMapMeter;
        valueMeter: StiValueMapMeter;
        groupMeter: StiGroupMapMeter;
        colorMeter: StiColorMapMeter;
        getNestedPages(): List<StiPage>;
        getMapData(): List<StiMapData>;
        createNew(): StiComponent;
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Shape {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import StiTitle = Stimulsoft.Dashboard.Components.StiTitle;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiRectangleShapeType = Stimulsoft.Report.Components.StiRectangleShapeType;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiShapeElement = Stimulsoft.Report.Dashboard.IStiShapeElement;
    class StiShapeElement extends StiElement implements IStiShapeElement, IStiTitleElement, IStiJsonReportObject, IStiGlobalizationProvider {
        private static ImplementsStiShapeElement;
        implements(): any[];
        clone(cloneProperties: boolean): any;
        get componentId(): StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get toolboxPosition(): number;
        get localizedName(): string;
        helpUrl: string;
        get isDefined(): boolean;
        get isQuerable(): boolean;
        title: StiTitle;
        shouldSerializePadding(): boolean;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        createNew(): StiComponent;
        shapeType: StiRectangleShapeType;
        private _size;
        get size(): number;
        set size(value: number);
        fill: StiBrush;
        stroke: Color;
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    enum StiDataBarsDirection {
        LeftToRight = 0,
        RighToLeft = 1
    }
    enum StiDataBarsBrushType {
        Solid = 0,
        Gradient = 1
    }
    enum StiSparklinesType {
        Line = 0,
        Area = 1,
        Column = 2,
        WinLoss = 3
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    import IStiTableColumn = Stimulsoft.Base.Meters.IStiTableColumn;
    import IStiReport = Stimulsoft.Base.IStiReport;
    class StiTableColumnVisibilityHelper {
        static getVisible(column: IStiTableColumn, report: IStiReport): boolean;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import List = Stimulsoft.System.Collections.List;
    import StiTableElement = Stimulsoft.Dashboard.Components.Table.StiTableElement;
    class StiTableElementSelection {
        private static hash;
        static getSelected(element: StiTableElement): List<StiTableColumn>;
        static getSelectedObjects(element: StiTableElement): List<any>;
        static isSelected(element: StiTableElement, column: StiTableColumn): boolean;
        static select(element: StiTableElement, column: StiTableColumn): void;
        static resetSelection(element: StiTableElement): void;
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    import IStiAllowUserColumnSelectionDashboardInteraction = Stimulsoft.Report.Dashboard.IStiAllowUserColumnSelectionDashboardInteraction;
    import IStiInteractionLayout = Stimulsoft.Report.Dashboard.IStiInteractionLayout;
    import List = Stimulsoft.System.Collections.List;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    import IStiTableDashboardInteraction = Stimulsoft.Report.Dashboard.IStiTableDashboardInteraction;
    import IStiAllowUserSortingDashboardInteraction = Stimulsoft.Report.Dashboard.IStiAllowUserSortingDashboardInteraction;
    import IStiAllowUserFilteringDashboardInteraction = Stimulsoft.Report.Dashboard.IStiAllowUserFilteringDashboardInteraction;
    import StiAvailableInteractionOnHover = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnHover;
    import StiAvailableInteractionOnDataManipulation = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnDataManipulation;
    class StiTableDashboardInteraction extends StiDashboardInteraction implements IStiTableDashboardInteraction, IStiAllowUserColumnSelectionDashboardInteraction, IStiAllowUserSortingDashboardInteraction, IStiAllowUserFilteringDashboardInteraction, IStiJsonReportObject, IStiInteractionLayout {
        private static ImplementsIStiTableDashboardInteraction;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        allowUserColumnSelection: boolean;
        allowUserSorting: boolean;
        allowUserFiltering: boolean;
        drillDownFiltered: boolean;
        fullRowSelect: boolean;
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        availableOnHover: StiAvailableInteractionOnHover;
        availableOnDataManipulation: StiAvailableInteractionOnDataManipulation;
        showFullScreenButton: boolean;
        showSaveButton: boolean;
        showViewDataButton: boolean;
        fileName: string;
        headerText: string;
        footerText: string;
        get isDefaultLayout(): boolean;
        isDefault(): boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>, allowFiltering?: boolean, allowSorting?: boolean, allowUserColumnSelection?: boolean, drillDownFiltered?: boolean, fullRowSelect?: boolean, fileName?: string, headerText?: string, footerText?: string, showFullScreenButton?: boolean, showSaveButton?: boolean, showViewDataButton?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    import Font = Stimulsoft.System.Drawing.Font;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiTableElementCondition = Stimulsoft.Report.Dashboard.IStiTableElementCondition;
    import StiTableConditionPermissions = Stimulsoft.Report.Dashboard.StiTableConditionPermissions;
    class StiTableElementCondition implements ICloneable, IStiTableElementCondition, IStiJsonReportObject {
        private static ImplementsStiTableElementCondition;
        implements(): any[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private parseStringArray;
        clone(): any;
        get keyValueMeters(): string[];
        set keyValueMeters(value: string[]);
        keyDataFieldMeters: string[];
        keyDestinationMeters: string[];
        dataType: StiFilterDataType;
        condition: StiFilterCondition;
        value: string;
        permissions: StiTableConditionPermissions;
        font: Font;
        foreColor: Color;
        backColor: Color;
        isExpression: boolean;
        static createFromJson(json: StiJson): StiTableElementCondition;
        static createFromXml(xmlNode: XmlNode): StiTableElementCondition;
        constructor(keyDataFieldMeters?: string[], keyDestinationMeters?: string[], dataType?: StiFilterDataType, condition?: StiFilterCondition, value?: string, permissions?: StiTableConditionPermissions, font?: Font, foreColor?: Color, backColor?: Color, isExpression?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    import StiTableConditionPermissions = Stimulsoft.Report.Dashboard.StiTableConditionPermissions;
    import IStiSkipOwnFilter = Stimulsoft.Report.Dashboard.IStiSkipOwnFilter;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiTableSizeMode = Stimulsoft.Report.Dashboard.StiTableSizeMode;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Font = Stimulsoft.System.Drawing.Font;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiTableElement = Stimulsoft.Report.Dashboard.IStiTableElement;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiTableElementCondition = Stimulsoft.Report.Dashboard.IStiTableElementCondition;
    class StiTableElement extends StiElement implements IStiTableElement, IStiTitleElement, IStiElementLayout, IStiJsonReportObject, IStiGlobalizationProvider, IStiElementInteraction, IStiSkipOwnFilter {
        private static ImplementsStiTableElement;
        implements(): any[];
        clone(cloneProperties: boolean): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get componentId(): StiComponentId;
        createMeters(source: IStiTableElement): void;
        createMeters2(dataSource: StiDataSource): void;
        createMeter3(cell: IStiAppDataCell): void;
        removeMeter(index: number): void;
        removeAllMeters(): void;
        insertMeter(index: number, meter: IStiMeter): void;
        insertNewDimension(index: number): void;
        insertNewMeasure(index: number): void;
        getMeasure(cell: IStiAppDataCell): IStiMeter;
        getDimension(cell: IStiAppDataCell): IStiMeter;
        convertFrom(element: IStiElement): void;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        title: StiTitle;
        layout: StiElementLayout;
        private shouldSerializeLayout;
        group: string;
        get allowSkipOwnFilter(): boolean;
        foreColor: Color;
        private shouldSerializeForeColor;
        font: Font;
        private shouldSerializeFont;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        userFilters: List<StiDataFilterRule>;
        userSorts: List<StiDataSortRule>;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        tableConditions: List<IStiTableElementCondition>;
        crossFiltering: boolean;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        dashboardInteraction: IStiDashboardInteraction;
        get shouldSerializeDashboardInteraction(): boolean;
        addTableCondition(keyDataFieldMeters: string[], keyDestinationMeters: string[], dataType: Report.Components.StiFilterDataType, condition: Report.Components.StiFilterCondition, value: string, permissions: StiTableConditionPermissions, font: Font, foreColor: Color, backColor: Color, isExpression: boolean): void;
        get toolboxPosition(): number;
        get localizedName(): string;
        helpUrl: string;
        columns: List<StiTableColumn>;
        private shouldSerializeColumns;
        sizeMode: StiTableSizeMode;
        headerForeColor: Color;
        private shouldSerializeHeaderForeColor;
        headerFont: Font;
        private shouldSerializeHeaderFont;
        footerForeColor: Color;
        private shouldSerializeFooterForeColor;
        footerFont: Font;
        private shouldSerializeFooterFont;
        getNestedPages(): List<StiPage>;
        getFormatObjects(): List<any>;
        createNew(): StiComponent;
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTableElementConditionHelper {
        private static getConditionResult;
        private static getConditionValue;
        static processBackColor(defaultColor: Color, keyColumn: string, tableElement: StiTableElement, rowValues: any[], columnKeys: string[]): Color;
        static processForeColor(defaultColor: Color, keyColumn: string, tableElement: StiTableElement, rowValues: any[], columnKeys: string[]): Color;
        static processFontStyle(fontText: Font, keyColumn: string, tableElement: StiTableElement, rowValues: any[], columnKeys: string[]): FontStyle;
        private static processFontStrikeout;
        private static processFontUnderline;
        private static processFontItalic;
        private static processFontBold;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    class StiDataBarsColumnConverter extends StiMeterConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    class StiDimensionColumnConverter extends StiMeterConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    class StiSparklinesColumnConverter extends StiMeterConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    class StiTableColumnConverter extends StiMeterConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    import List = Stimulsoft.System.Collections.List;
    class StiTextDashboardInteraction extends StiDashboardInteraction {
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        onClick: StiInteractionOnClick;
        isDefault(): boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Text {
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import List = Stimulsoft.System.Collections.List;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiHtmlTextHelper = Stimulsoft.Report.Dashboard.IStiHtmlTextHelper;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiTextElement = Stimulsoft.Report.Dashboard.IStiTextElement;
    import IStiVertAlignment = Stimulsoft.Report.Components.IStiVertAlignment;
    import IStiTextHorAlignment = Stimulsoft.Report.Components.IStiTextHorAlignment;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiTextFont = Stimulsoft.Report.Components.IStiTextFont;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    class StiTextElement extends StiElement implements IStiTextFont, IStiForeColor, IStiTextHorAlignment, IStiVertAlignment, IStiTextElement, IStiTitleElement, IStiJsonReportObject, IStiGlobalizationProvider, IStiElementInteraction {
        private static ImplementsStiTextElement;
        implements(): any[];
        clone(cloneProperties: boolean): any;
        get componentId(): StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        get isDefined(): boolean;
        get isQuerable(): boolean;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        title: StiTitle;
        text: string;
        getSimpleText(): string;
        group: string;
        foreColor: Color;
        crossFiltering: boolean;
        private shouldSerializeForeColor;
        getFont(): Font;
        setFontName(fontName: string): void;
        setFontSize(fontSize: number): void;
        growFontSize(): void;
        shrinkFontSize(): void;
        setFontBoldStyle(isBold: boolean): void;
        setFontItalicStyle(isItalic: boolean): void;
        setFontUnderlineStyle(isUnderline: boolean): void;
        get horAlignment(): StiTextHorAlignment;
        set horAlignment(value: StiTextHorAlignment);
        vertAlignment: StiVertAlignment;
        shouldSerializePadding(): boolean;
        setString(propertyName: string, value: string): void;
        dashboardInteraction: IStiDashboardInteraction;
        get shouldSerializeDashboardInteraction(): boolean;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        getNestedPages(): List<StiPage>;
        createNew(): StiComponent;
        getHtmlTextHelper(): IStiHtmlTextHelper;
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Text {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiTextMeter extends StiDimensionMeter implements IStiValueMeter {
        private static ImplementsStiTextMeter;
        implements(): any[];
        ident: StiMeterIdent;
        get localizedName(): string;
        constructor(key: string, expression: string, label: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Text.Design {
    class StiTextConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.TreeView {
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiTreeItem {
        key: any;
        meter: IStiMeter;
        items: List<StiTreeItem>;
        toString(): string;
        constructor(key?: any, meter?: IStiMeter);
    }
}
declare namespace Stimulsoft.Dashboard.Components.TreeView {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import StiItemSelectionMode = Stimulsoft.Report.Dashboard.StiItemSelectionMode;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiTreeViewElement = Stimulsoft.Report.Dashboard.IStiTreeViewElement;
    class StiTreeViewElement extends StiElement implements IStiTreeViewElement, IStiTitleElement, IStiGlobalizationProvider, IStiJsonReportObject {
        private static ImplementsStiTreeViewElement;
        implements(): any[];
        clone(cloneProperties: boolean): any;
        get componentId(): StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        group: string;
        getParentKey(): string;
        setParentKey(key: string): void;
        applyDefaultFilters(): Promise<void>;
        title: StiTitle;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        userFilters: List<StiDataFilterRule>;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        font: Font;
        private shouldSerializeFont;
        foreColor: Color;
        private shouldSerializeForeColor;
        showAllValue: boolean;
        showBlanks: boolean;
        selectionMode: StiItemSelectionMode;
        getKeyMeter(cell: IStiAppDataCell): IStiMeter;
        getKeyMeterByIndex(index: number): IStiMeter;
        insertKeyMeter(index: number, meter: IStiMeter): void;
        removeKeyMeter(index: number): void;
        removeAllKeyMeters(): void;
        addNewKeyMeter(): IStiMeter;
        addKey(cell: IStiAppDataCell): void;
        convertFrom(element: IStiElement): void;
        textFormat: StiFormatService;
        private shouldSerializeTextFormat;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        createNew(): StiComponent;
        parentKey: string;
        keyMeters: List<StiKeyTreeViewMeter>;
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.TreeView {
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiTreeViewBoxElement = Stimulsoft.Dashboard.Components.TreeViewBox.StiTreeViewBoxElement;
    import List = Stimulsoft.System.Collections.List;
    import StiTreeItem = Stimulsoft.Dashboard.Components.TreeView.StiTreeItem;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiTreeViewHelper {
        static fetchItems(dataTable: StiDataTable, showBlanks: boolean): List<StiTreeItem>;
        static fetchDefaultUserFilters(treeViewBoxElement: StiTreeViewBoxElement): Promise<List<StiDataFilterRule>>;
        static fetchDefaultUserFilters2(treeViewElement: StiTreeViewElement): Promise<List<StiDataFilterRule>>;
        static format(treeViewBoxElement: StiTreeViewBoxElement, value: any): string;
        static format2(treeViewElement: StiTreeViewElement, value: any): string;
    }
}
declare namespace Stimulsoft.Dashboard.Components.TreeViewBox {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Size = Stimulsoft.System.Drawing.Size;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    import StiItemSelectionMode = Stimulsoft.Report.Dashboard.StiItemSelectionMode;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiFixedHeightElement = Stimulsoft.Report.Dashboard.IStiFixedHeightElement;
    import IStiTreeViewBoxElement = Stimulsoft.Report.Dashboard.IStiTreeViewBoxElement;
    class StiTreeViewBoxElement extends StiElement implements IStiTreeViewBoxElement, IStiFixedHeightElement, IStiJsonReportObject {
        private static ImplementsStiTreeViewBoxElement;
        implements(): any[];
        get componentId(): StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean): any;
        group: string;
        getParentKey(): string;
        setParentKey(key: string): void;
        applyDefaultFilters(): Promise<void>;
        private _style;
        get style(): StiElementStyleIdent;
        set style(value: StiElementStyleIdent);
        customStyleName: string;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        get isDefined(): boolean;
        userFilters: List<StiDataFilterRule>;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        font: Font;
        private shouldSerializeFont;
        foreColor: Color;
        private shouldSerializeForeColor;
        showAllValue: boolean;
        showBlanks: boolean;
        selectionMode: StiItemSelectionMode;
        getKeyMeter(cell: IStiAppDataCell): IStiMeter;
        getKeyMeterByIndex(index: number): IStiMeter;
        insertKeyMeter(index: number, meter: IStiMeter): void;
        removeKeyMeter(index: number): void;
        removeAllKeyMeters(): void;
        addNewKeyMeter(): IStiMeter;
        addKey(cell: IStiAppDataCell): void;
        convertFrom(element: IStiElement): void;
        textFormat: StiFormatService;
        private shouldSerializeTextFormat;
        get toolboxPosition(): number;
        get localizedName(): string;
        defaultClientRectangle: Rectangle;
        get minSize(): Size;
        set minSize(value: Size);
        get maxSize(): Size;
        set maxSize(value: Size);
        helpUrl: string;
        createNew(): StiComponent;
        parentKey: string;
        keyMeters: List<StiKeyTreeViewBoxMeter>;
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Design {
    class StiInplaceDesigner {
        static isEditorActivated: boolean;
    }
}
declare namespace Stimulsoft.Dashboard.Design.Helpers {
    enum StiRichTextAlignment {
        Left = 1,
        Right = 2,
        Center = 3,
        Justify = 4
    }
}
declare namespace Stimulsoft.Dashboard.Design.Helpers {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiRichBoxControl {
        selectionFont: Font;
        selectionColor: Color;
        selectionAlignment: StiRichTextAlignment;
        font: Font;
        text: string;
        selectedText: string;
        selectAll(): void;
        select(start: number, end: number): void;
        beginUpdate(): void;
        endUpdate(): void;
        setSelectionFont(face: string): boolean;
        setSelectionSize(size: number): boolean;
        setSelectionBold(bold: boolean): boolean;
        setSelectionItalic(italic: boolean): boolean;
        setSelectionUnderlined(underlined: boolean): boolean;
        constructor();
    }
}
declare namespace Stimulsoft.Dashboard.Design.Helpers {
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import IStiHtmlTextHelper = Stimulsoft.Report.Dashboard.IStiHtmlTextHelper;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiRichBoxControl = Stimulsoft.Dashboard.Design.Helpers.StiRichBoxControl;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiHtmlTextHelper implements IStiHtmlTextHelper {
        setFontName(textObj: any, text: string, fontName: string, defaultColor: Color): string;
        setFontSize(textObj: any, text: string, fontSize: number, defaultColor: Color): string;
        growFontSize(textObj: any, text: string, defaultColor: Color): string;
        shrinkFontSize(textObj: any, text: string, defaultColor: Color): string;
        setFontBoldStyle(textObj: any, text: string, isBold: boolean, defaultColor: Color): string;
        setFontItalicStyle(textObj: any, text: string, isItalic: boolean, defaultColor: Color): string;
        setFontUnderlineStyle(textObj: any, text: string, isUnderline: boolean, defaultColor: Color): string;
        setColor(textObj: any, text: string, color: Color, defaultColor: Color): string;
        setHorAlignment(textObj: any, text: string, alignment: StiTextHorAlignment, defaultColor: Color): string;
        getFont(textObj: any, text: string, defaultColor: Color): Font;
        getColor(textObj: any, text: string, defaultColor: Color): Color;
        getHorAlign(textObj: any, text: string, defaultColor: Color): StiTextHorAlignment;
        setHtmlText(htmlText: string, textObj: any, richTextBox: StiRichBoxControl, defaultColor: Color): void;
        getHtmlText(richTextBox: StiRichBoxControl, defaultColor: Color): string;
        private getAlignment;
        private getAlignment2;
        getSimpleText(htmlText: string, defaultColor: Color): string;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    import Size = Stimulsoft.System.Drawing.Size;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    class StiAutoSizeHtmlTextHelper {
        static measure(g: Graphics, rect: Rectangle, text: string, textObj: any, scale?: number): Size;
        static getDefaultTextOptions(): StiTextOptions;
        private static getTextScale;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Size = Stimulsoft.System.Drawing.Size;
    import Font = Stimulsoft.System.Drawing.Font;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    class StiAutoSizeTextHelper {
        static toAlignment(alignment: StiHorAlignment): StiTextHorAlignment;
        static measure(g: Graphics, text: string, font: Font): Size;
        static measureFontSize(g: Graphics, text: string, rect: Rectangle, font: Font): number;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import List = Stimulsoft.System.Collections.List;
    class StiElementLocationHelper {
        private static hashLocations;
        static IsWpfMode: boolean;
        static getSumRectangle(listLocationRectangles: List<Rectangle>): Rectangle;
        static getLocationRectangles(rect: Rectangle, countRect: number, element: IStiElement): List<Rectangle>;
        private static getMinRectangle;
        private static prepareColumnRow;
        private static getUsingRect;
        private static checkMinRect;
        private static getSimpleRect;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    import IStiGaugeVisualSvgHelper = Stimulsoft.Report.Dashboard.Visuals.IStiGaugeVisualSvgHelper;
    class StiGaugeVisualSvgHelper implements IStiGaugeVisualSvgHelper {
        private static ImplementsStiGaugeVisualSvgHelper;
        implements(): any[];
        writeGauge(writer: XmlTextWriter, svgData: StiSvgData, needAnimation: boolean, refNeedToScroll?: any, refContentHeight?: any): Promise<void>;
        private paintTitle;
        private getTitleMinFontSize;
        private getTitleHeight;
    }
}
declare namespace Stimulsoft.Dashboard.Visuals.Indicator {
    class StiIndicatorIteration {
        series: string;
        value: number;
        target: number;
        constructor(series?: string, value?: number, target?: number);
    }
}
declare namespace Stimulsoft.Dashboard.Render {
    import StiIndicatorIteration = Stimulsoft.Dashboard.Visuals.Indicator.StiIndicatorIteration;
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiIndicatorElement = Stimulsoft.Dashboard.Components.Indicator.StiIndicatorElement;
    class StiIndicatorElementBuilder extends StiElementBuilder {
        render(element: StiIndicatorElement, dataTable: StiDataTable): List<StiIndicatorIteration>;
        private static processVariationSort;
        static processTopNElements(element: StiIndicatorElement, iterations: List<StiIndicatorIteration>): List<StiIndicatorIteration>;
        private getValueMeterIndex;
        private getTargetMeterIndex;
        private getSeriesMeterIndex;
    }
}
declare namespace Stimulsoft.Dashboard.Visuals {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiVisual {
        draw(context: StiContext, rect: Rectangle): void;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiStringFormatHelper {
        static getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        static measureAlignmentParameters(alignment: StiHorAlignment, elementRectText: Rectangle, rotationMode: {
            ref: StiRotationMode;
        }, point: {
            ref: Point;
        }): void;
        static getFontSize(context: StiContext, rect: Rectangle, text: string, font: Font): number;
        static getFontSize2(context: StiContext, font: Font, rect: Rectangle, text: string): number;
    }
}
declare namespace Stimulsoft.Dashboard.Visuals.Indicator {
    import Size = Stimulsoft.System.Drawing.Size;
    import List = Stimulsoft.System.Collections.List;
    import StiIndicatorElement = Stimulsoft.Dashboard.Components.Indicator.StiIndicatorElement;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiIndicatorVisual extends StiVisual {
        private minSide;
        iterations: List<StiIndicatorIteration>;
        element: StiIndicatorElement;
        draw(context: StiContext, rect: Rectangle): void;
        getContentRectangle(rect: Rectangle): Rectangle;
        private drawSingleMode;
        private getVariation;
        private getFactorByFontSize;
        private getRectanglesSingleMode;
        private processFontStyle;
        private processFontStrikeout;
        private processFontUnderline;
        private processFontItalic;
        private processFontBold;
        private processFontName;
        private processIcon;
        private processTargetIcon;
        private processCustomIcon;
        private processIconAlignment;
        private processTargetIconAlignment;
        private processBackColor;
        private processForeColor;
        private processGlyphColor;
        private processTargetIconColor;
        private getConditionResult;
        private getConditionValue;
        private drawMultiMode;
        private drawMultiModePresent;
        private drawMultiModeWithTarget;
        private getInteractionDataGeom;
        private getMaxValue;
        getTargetValues(): List<number>;
        private drawTextIcon;
        private getFontGeom;
        measureFontSize(context: StiContext, rect: Rectangle, text: string, font: {
            ref: number;
        }): void;
        protected getElementSide(isVerticalOrientation: boolean, size: Size): number;
        constructor(element: StiIndicatorElement, iterations: List<StiIndicatorIteration>);
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import IStiIndicatorVisualSvgHelper = Stimulsoft.Report.Dashboard.Visuals.IStiIndicatorVisualSvgHelper;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    class StiIndicatorVisualSvgHelper implements IStiIndicatorVisualSvgHelper {
        private static ImplementsStiIndicatorVisualSvgHelper;
        implements(): any[];
        writeIndicator(writer: XmlTextWriter, svgData: StiSvgData, refNeedToScroll?: any, refContentHeight?: any): Promise<void>;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import StiPromise = Stimulsoft.System.StiPromise;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiOnlineMapElement = Stimulsoft.Dashboard.Components.OnlineMap.StiOnlineMapElement;
    import Color = Stimulsoft.System.Drawing.Color;
    import List = Stimulsoft.System.Collections.List;
    class StiOnlineMapHelper {
        private static _ICON;
        private static get ICON();
        private static _EMPTY_ICON;
        private static get EMPTY_ICON();
        private static MAX_LOCATIONS;
        private static MAX_CHART_SECTORS;
        private static MIN_RADIUS;
        private static MAX_RADIUS;
        private static CHART_RADIUS;
        private static DELTA_RADIUS;
        private static htmlNameToColor;
        private static lockHtmlNameToColor;
        static getBingMapScriptAsync(element: IStiElement, showTitle: boolean): StiPromise<string>;
        static calculateMapData(dataTable: StiDataTable, onlineMapElement: StiOnlineMapElement): {};
        static getChartData(dataTable: StiDataTable, locIndex: number, locValueIndex: number, locAgrumentIndex: number, locValue: {}): Hashtable;
        static toUnits(number: number): string;
        static getCustomIcon(bytes: number[], mapData: {}): void;
        static imageBytesToBase64String(image: number[]): string;
        static getColors(count: number): List<Color>;
        static getLongitudeMeterIndex(dataTable: StiDataTable): number;
        static getLatitudeMeterIndex(dataTable: StiDataTable): number;
        static getLocationMeterIndex(dataTable: StiDataTable): number;
        static getLocationColorMeterIndex(dataTable: StiDataTable): number;
        static getLocationArgumentMeterIndex(dataTable: StiDataTable): number;
        static getLocationValueMeterIndex(dataTable: StiDataTable): number;
        static parseColor(colorAttribute: string): Color;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import StiPromise = Stimulsoft.System.StiPromise;
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiPivotTableElement = Stimulsoft.Dashboard.Components.PivotTable.StiPivotTableElement;
    import StiCell = Stimulsoft.Report.CrossTab.Core.StiCell;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiPivotTableElement = Stimulsoft.Report.Dashboard.IStiPivotTableElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiPivotTableHelper {
        static summaryTypes: Hashtable<string, string>;
        static getHeadersBounds(cells: StiCell[][]): Rectangle;
        static getViewerDataAsync(pivotElement: IStiPivotTableElement): StiPromise<any>;
        private static cellItem;
        static applyStyle(pivot: StiPivotTableElement, crossTab: StiCrossTab, exportDataOnly: boolean): void;
        static buildCross(masterCrossTab: StiCrossTab, dataTable: StiDataTable, pivot: StiPivotTableElement): void;
        static convertToCrossTab(pivot: StiPivotTableElement, dataTable: StiDataTable): Promise<StiCrossTab>;
        static updateCrossTab(crossTab: StiCrossTab, pivot: StiPivotTableElement, dataTable: StiDataTable, build?: boolean): Promise<void>;
        private static getCondition;
        private static setupTitle;
        private static setupField;
        private static createRowTotal;
        private static createColTotal;
        private static getLabel;
        private static getSummaryTypes;
        private static setTopN;
        private static setSummaryType;
    }
}
declare namespace Stimulsoft.Dashboard.Visuals.Progress {
    class StiProgressIteration {
        series: string;
        value: number;
        target: number;
        constructor(series?: string, value?: number, target?: number);
    }
}
declare namespace Stimulsoft.Dashboard.Render {
    import StiProgressElement = Stimulsoft.Dashboard.Components.Progress.StiProgressElement;
    import StiProgressIteration = Stimulsoft.Dashboard.Visuals.Progress.StiProgressIteration;
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiProgressElementBuilder extends StiElementBuilder {
        render(element: StiProgressElement, dataTable: StiDataTable): List<StiProgressIteration>;
        private static processVariationSort;
        static processTopNElements(element: StiProgressElement, iterations: List<StiProgressIteration>): List<StiProgressIteration>;
        private getValueMeterIndex;
        private getTargetMeterIndex;
        private getSeriesMeterIndex;
    }
}
declare namespace Stimulsoft.Dashboard.Visuals.Progress.Helpers {
    import List = Stimulsoft.System.Collections.List;
    import StiProgressElement = Stimulsoft.Dashboard.Components.Progress.StiProgressElement;
    class StiProgressVisualCreator {
        static createProgressVisual(element: StiProgressElement, iterations: List<StiProgressIteration>): StiProgressVisual;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    import IStiProgressVisualSvgHelper = Stimulsoft.Report.Dashboard.Visuals.IStiProgressVisualSvgHelper;
    class StiProgressVisualSvgHelper implements IStiProgressVisualSvgHelper {
        private static ImplementsStiProgressVisualSvgHelper;
        implements(): any[];
        writeProgress(writer: XmlTextWriter, svgData: StiSvgData, refNeedToScroll?: any, refContentHeight?: any): Promise<void>;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiAppDataCell = Stimulsoft.Base.IStiAppDataCell;
    class StiTableAlignmentHelper {
        static getHorAlign(cell: IStiAppDataCell): StiHorAlignment;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    class StiTableElementHelper {
        static minDataColumnValue(column: StiTableColumn, dataTable: StiDataTable, columnIndex: number): number;
        static maxDataColumnValue(column: StiTableColumn, dataTable: StiDataTable, columnIndex: number): number;
        static calculateTotal(column: StiTableColumn, columnIndex: number, dataTable: StiDataTable): number;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiTitle = Stimulsoft.Report.Dashboard.IStiTitle;
    import Font = Stimulsoft.System.Drawing.Font;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Size = Stimulsoft.System.Drawing.Size;
    class StiTitleMeasureHelper {
        static measureTitle(title: IStiTitle): Size;
        static measureTitle2(title: IStiTitle, titleText: string): Size;
        static measureTitle3(g: Graphics, rect: Rectangle, title: IStiTitle, titleText: string): Size;
        static measureTitle4(g: Graphics, rect: Rectangle, font: Font, titleText: string): Size;
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiWizardDashboardsHelper {
        static loadReport(report: StiReport, wizardName: string): void;
        private static financial;
        private static orders;
        private static salesOverview;
        private static ticketsStatistics;
        private static trafficAnalytics;
        private static vehicleProduction;
        private static websiteAnalytics;
    }
}
declare namespace Stimulsoft.Dashboard.Images {
    class StiDashboardImages {
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    import IStiDashboardDrillDownParameter = Stimulsoft.Report.Dashboard.IStiDashboardDrillDownParameter;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiDefault = Stimulsoft.Base.Design.IStiDefault;
    class StiDashboardDrillDownParameter implements IStiDefault, ICloneable, IStiJsonReportObject, IStiDashboardDrillDownParameter {
        clone(): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        static loadFromJson(json: StiJson): StiDashboardDrillDownParameter;
        static loadFromXml(xmlNode: XmlNode): StiDashboardDrillDownParameter;
        saveToString(): string;
        getStringRepresentation(): string;
        isDefault(): boolean;
        name: string;
        expression: string;
        constructor();
    }
}
declare namespace Stimulsoft.Dashboard.Interactions.Design {
    class StiDashboardDrillDownParameterConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Interactions.Design {
    class StiDashboardInteractionConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Interactions.Design {
    class StiDashboardInteractionCreator {
        static new2(identName: string): StiDashboardInteraction;
    }
}
declare namespace Stimulsoft.Dashboard.Interactions.Design {
    class StiDashboardInteractionJsonConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Interactions.Design {
    class StiTableDashboardInteractionConverter extends StiDashboardInteractionConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Options {
    import Type = Stimulsoft.System.Type;
    class StiDashboardOptions {
    }
    class Services {
        private static _elements;
        static get elements(): Type[];
    }
}
declare namespace Stimulsoft.Dashboard.Options {
    import Type = Stimulsoft.System.Type;
    class StiDashboardElementsLoader {
        static fetchAll(): Type[];
        static load(): void;
    }
}
declare namespace Stimulsoft.Dashboard.Render {
    import StiReport = Stimulsoft.Report.StiReport;
    import Point = Stimulsoft.System.Drawing.Point;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiMeter = Stimulsoft.Dashboard.Components.StiMeter;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import List = Stimulsoft.System.Collections.List;
    import StiChartElement = Stimulsoft.Dashboard.Components.Chart.StiChartElement;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiChartElementBuilder extends StiElementBuilder {
        render(element: StiChartElement, dataTable: StiDataTable): IStiChart;
        protected renderElements(element: StiChartElement, chart: IStiChart, dataTable: StiDataTable): void;
        private proccessSelectArguments;
        static processTopNElements(element: StiChartElement, series: IStiSeries): void;
        private static setStyle;
        protected static getDetailRows(rows: List<any[]>, argument: any, argumentIndexes: List<number>): List<any[]>;
        protected renderSeries(element: StiChartElement, value: StiMeter, seriesKey: string, chart: IStiChart): IStiSeries;
        private static renderSeriesYAxis;
        private static renderSeriesLine;
        private static renderSeriesShowZeros;
        private static renderSeriesShowNulls;
        private static renderSeriesLighting;
        private static renderSeriesIcon;
        private renderMarker;
        private renderSeriesNegativeColor;
        private renderSeriesParetoColor;
        protected renderArea(element: StiChartElement, chart: IStiChart): void;
        private static getColorEach;
        private renderAxisAxes;
        private static renderInterlacingHor;
        private static renderInterlacingVert;
        private static renderGridLinesHor;
        private static renderGridLinesVert;
        private renderXAxis;
        private renderYAxis;
        private renderXRadarAxis;
        private renderYRadarAxis;
        private static checkValueFormat;
        private static renderYRightAxis;
        private static renderXAxisTitleText;
        private static renderYAxisTitleText;
        private static renderAxisLineColor;
        private renderRadarAxis;
        private static renderAxis;
        private static renderAxisStartFromZero;
        private static renderAxisShowEdgeValues;
        private static renderAxisRange;
        private static renderAxisLabelsTitleColor;
        private static renderAxisLabelsColor;
        private static getTitleAxisChart;
        private renderLegend;
        private static getChartLegendVisible;
        private static renderLegendTitleColor;
        private static renderSeriesLabelsLegendValueType;
        private static renderLegendLabelsColor;
        protected static renderConditions(seriesKey: string, series: IStiSeries, element: StiChartElement, valueMeter: StiMeter): void;
        private static renderValueConditions;
        private static renderArgumentConditions;
        private static renderSeriesConditions;
        private static getConditionResult;
        private static renderConstantLines;
        protected static renderTrendLines(series: IStiSeries, element: StiChartElement, valueMeter: StiMeter): void;
        private static getTrendLine;
        private renderSeriesLabels;
        private static applyPropertiesToSeriesLabels;
        private static renderPieLabelsAutoRotate;
        private static renderLabelsColor;
        private static renderLabelsTextFormat;
        private static renderFunnelLabelsPosition;
        private static renderTreemapLabelsPosition;
        private static renderPieLabelsPosition;
        private static renderStackedLabelsPosition;
        private static renderWaterfallLabelsPosition;
        private static renderAxisLabelsPosition;
        private static renderDoughnutLabelsPosition;
        private static renderPieLabelsStyle;
        private static renderLabelsStyle;
        protected renderSeriesInteraction(series: IStiSeries, element: StiChartElement, count: number, seriesKey: string): void;
        private getToolTip;
        private getHyperlink;
        getTitle(meter: StiMeter): string;
        protected getSeriesTitle(element: StiChartElement, seriesKey: string, meter: StiMeter): string;
        protected getArgumentIndex(dataTable: StiDataTable, index: number): number;
        private simplifyValues;
        getShorterListPoints(series: IStiSeries): List<Point>;
        protected getString(format: StiFormatService, value: any, report: StiReport): string;
        private getFormatValue;
        static create(chart: StiChartElement): StiChartElementBuilder;
        protected getValueMeterIndexes(table: StiDataTable): number[];
        protected getArgumentMeterIndexes(table: StiDataTable): List<number>;
        protected getSeriesMeterIndex(table: StiDataTable): number;
        protected getArgumentKeys(element: IStiElement, table: StiDataTable): List<any>;
        protected getValueMeters(table: StiDataTable): List<StiMeter>;
        protected getArgumentMeters(table: StiDataTable): List<StiMeter>;
    }
}
declare namespace Stimulsoft.Dashboard.Render {
    import List = Stimulsoft.System.Collections.List;
    import StiWeightChartMeter = Stimulsoft.Dashboard.Components.Chart.StiWeightChartMeter;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import StiMeter = Stimulsoft.Dashboard.Components.StiMeter;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiChartElement = Stimulsoft.Dashboard.Components.Chart.StiChartElement;
    class StiBubbleChartElementBuilder extends StiChartElementBuilder {
        protected renderElements(element: StiChartElement, chart: IStiChart, dataTable: StiDataTable): void;
        protected renderSeries(element: StiChartElement, value: StiMeter, groupKey: string, chart: IStiChart): IStiSeries;
        protected renderSeriesInteraction(series: IStiSeries, element: StiChartElement, count: number, seriesKey: string): void;
        protected getWeightIndex(table: StiDataTable, index: number): number;
        protected getWeightMeterIndexes(table: StiDataTable): List<number>;
        protected getWeightMeters(table: StiDataTable): List<StiWeightChartMeter>;
        protected getValueMeters(table: StiDataTable): List<StiMeter>;
        protected getArgumentMeters(table: StiDataTable): List<StiMeter>;
    }
}
declare namespace Stimulsoft.Dashboard.Render {
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import StiChartElement = Stimulsoft.Dashboard.Components.Chart.StiChartElement;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiMeter = Stimulsoft.Dashboard.Components.StiMeter;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import StiCloseValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiCloseValueChartMeter;
    import StiLowValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiLowValueChartMeter;
    import StiHighValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiHighValueChartMeter;
    import List = Stimulsoft.System.Collections.List;
    class StiFinancialChartElementBuilder extends StiChartElementBuilder {
        protected renderElements(element: StiChartElement, chart: IStiChart, dataTable: StiDataTable): void;
        protected renderSeries(element: StiChartElement, value: StiMeter, groupKey: string, chart: IStiChart): IStiSeries;
        protected renderSeriesInteraction(series: IStiSeries, element: StiChartElement, count: number, seriesKey: string): void;
        protected renderArea(element: StiChartElement, chart: IStiChart): void;
        protected getValueMeters(table: StiDataTable): List<StiMeter>;
        protected getCloseValueIndex(table: StiDataTable, index: number): number;
        protected getCloseMeterIndexes(table: StiDataTable): List<number>;
        protected getCloseMeters(table: StiDataTable): List<StiCloseValueChartMeter>;
        protected getLowValueIndex(table: StiDataTable, index: number): number;
        protected getLowMeterIndexes(table: StiDataTable): List<number>;
        protected getLowMeters(table: StiDataTable): List<StiLowValueChartMeter>;
        protected getHighValueIndex(table: StiDataTable, index: number): number;
        protected getHighMeterIndexes(table: StiDataTable): List<number>;
        protected getHighMeters(table: StiDataTable): List<StiHighValueChartMeter>;
    }
}
declare namespace Stimulsoft.Dashboard.Render {
    import StiMeter = Stimulsoft.Dashboard.Components.StiMeter;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import StiEndValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiEndValueChartMeter;
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import StiChartElement = Stimulsoft.Dashboard.Components.Chart.StiChartElement;
    class StiRangeChartElementBuilder extends StiChartElementBuilder {
        protected renderElements(element: StiChartElement, chart: IStiChart, dataTable: StiDataTable): void;
        protected renderSeries(element: StiChartElement, value: StiMeter, groupKey: string, chart: IStiChart): IStiSeries;
        protected renderSeriesInteraction(series: IStiSeries, element: StiChartElement, count: number, seriesKey: string): void;
        private getToolTip2;
        private getHyperlink2;
        protected getValueMeters(table: StiDataTable): List<StiMeter>;
        protected getEndValueIndex(table: StiDataTable, index: number): number;
        protected getEndValueMeterIndexes(table: StiDataTable): List<number>;
        protected getEndValueMeters(table: StiDataTable): List<StiEndValueChartMeter>;
    }
}
declare namespace Stimulsoft.Dashboard.Render {
    import StiShape = Stimulsoft.Report.Components.StiShape;
    import StiShapeElement = Stimulsoft.Dashboard.Components.Shape.StiShapeElement;
    class StiShapeElementBuilder {
        render(element: StiShapeElement): StiShape;
    }
}
declare namespace Stimulsoft.Dashboard.Render {
    import StiChartElement = Stimulsoft.Dashboard.Components.Chart.StiChartElement;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiStackedChartElementBuilder extends StiChartElementBuilder {
        protected renderElements(element: StiChartElement, chart: IStiChart, dataTable: StiDataTable): void;
        private static getDataTable;
        private static getCountRow;
        private static getArguments;
        private static getValues;
        private static processTopNStackedChart;
        private static getListByColumnName;
    }
}
declare namespace Stimulsoft.Dashboard.Render {
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import StiMeter = Stimulsoft.Dashboard.Components.StiMeter;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiChartElement = Stimulsoft.Dashboard.Components.Chart.StiChartElement;
    class StiSunburstChartElementBuilder extends StiChartElementBuilder {
        protected renderElements(element: StiChartElement, chart: IStiChart, dataTable: StiDataTable): void;
        protected renderSeries(element: StiChartElement, value: StiMeter, seriesKey: string, chart: IStiChart): IStiSeries;
    }
}
declare namespace Stimulsoft.Dashboard.Visualizers {
    import Type = Stimulsoft.System.Type;
    class StiVisualizer {
        private static typeToGdiVisualizer;
        private static typeToWpfVisualizer;
        private static lockObject;
        static getVisualizer(type: Type): StiVisualizer;
    }
}
declare namespace Stimulsoft.Dashboard.Visualizers {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiGdiVisualizer extends StiVisualizer {
        render(element: IStiElement): void;
    }
}
declare namespace Stimulsoft.Dashboard.Visualizers {
    class StiGdiVisualizerAttribute {
        visualizerTypeName: string;
    }
}
declare namespace Stimulsoft.Dashboard.Visuals.Indicator {
    import StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
    class StiIndicatorIconRangeValue {
        start: number;
        end: number;
        icon: StiFontIcons;
        isBetween(value: number): boolean;
        constructor(start: number, end: number, icon: StiFontIcons);
    }
}
declare namespace Stimulsoft.Dashboard.Visuals.Progress {
    import Font = Stimulsoft.System.Drawing.Font;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    import StiProgressElement = Stimulsoft.Dashboard.Components.Progress.StiProgressElement;
    import Color = Stimulsoft.System.Drawing.Color;
    import List = Stimulsoft.System.Collections.List;
    import StiProgressElementStyle = Stimulsoft.Report.Dashboard.Styles.StiProgressElementStyle;
    class StiProgressVisual extends StiVisual {
        protected style: StiProgressElementStyle;
        protected minElementSide: number;
        protected minFontSize: number;
        iterations: List<StiProgressIteration>;
        element: StiProgressElement;
        private getMaxValue;
        getTargetValues(): List<number>;
        getTextValues(): List<string>;
        getColor(index: number): Color;
        getColors(seriesCount: number): Color[];
        getContentRectangle(rect: Rectangle): Rectangle;
        private getConditionResult;
        protected processColor(color: Color, iteration: StiProgressIteration): Color;
        private getVariation;
        private getConditionValue;
        protected processForeColor(iteration: StiProgressIteration, defaultColor?: Color): Color;
        protected processTrackColor(color: Color, iteration: StiProgressIteration): Color;
        processFontStyle(fontText: Font, iteration: StiProgressIteration): FontStyle;
        private processFontStrikeout;
        private processFontUnderline;
        private processFontItalic;
        private processFontBold;
        protected processFontName(fontName: string, iteration: StiProgressIteration): string;
        constructor(element: StiProgressElement, iterations: List<StiProgressIteration>);
    }
}
declare namespace Stimulsoft.Dashboard.Visuals.Progress {
    import List = Stimulsoft.System.Collections.List;
    import StiProgressElement = Stimulsoft.Dashboard.Components.Progress.StiProgressElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiPieProgressVisual extends StiProgressVisual {
        draw(context: StiContext, rectMain: Rectangle): void;
        private drawPieProgress;
        drawArrowMore(context: StiContext, rect: Rectangle): void;
        getTitleHeight(elementSide: number, size: number): number;
        constructor(element: StiProgressElement, iterations: List<StiProgressIteration>);
    }
}
declare namespace Stimulsoft.Dashboard.Visuals.Progress {
    import List = Stimulsoft.System.Collections.List;
    import StiProgressElement = Stimulsoft.Dashboard.Components.Progress.StiProgressElement;
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiCircleProgressVisual extends StiPieProgressVisual {
        draw(context: StiContext, rectMain: Rectangle): void;
        protected getPoint(centerPie: Point, radius: number, angle: number): Point;
        constructor(element: StiProgressElement, iterations: List<StiProgressIteration>);
    }
}
declare namespace Stimulsoft.Dashboard.Visuals.Progress {
    import List = Stimulsoft.System.Collections.List;
    import StiProgressElement = Stimulsoft.Dashboard.Components.Progress.StiProgressElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiDataBarsProgressVisual extends StiProgressVisual {
        draw(context: StiContext, rect: Rectangle): void;
        private isColorLight;
        constructor(element: StiProgressElement, iterations: List<StiProgressIteration>);
    }
}
declare namespace Stimulsoft.Dashboard.Export {
    enum StiDashboardExportFormat {
        Pdf = 0,
        Excel = 1,
        Data = 2,
        Image = 3,
        Html = 4,
        Document = 5
    }
}
declare namespace Stimulsoft.Dashboard.Export.Settings {
    import StiPageOrientation = Stimulsoft.Report.Components.StiPageOrientation;
    import PaperKind = Stimulsoft.System.Drawing.Printing.PaperKind;
    import IStiDashboardExportSettings = Stimulsoft.Report.Dashboard.Export.IStiDashboardExportSettings;
    class StiDashboardExportSettings implements IStiDashboardExportSettings {
        is<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): this is T;
        is2<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): boolean;
        as<T>(type: (new (...args: any[]) => T) | Stimulsoft.System.Interface<T>): T;
        private static ImplementsStiDashboardExportSettings;
        implements(): any[];
        format: StiDashboardExportFormat;
        renderBorders: boolean;
        renderSingleElement: boolean;
        renderSinglePage: boolean;
        orientation: StiPageOrientation;
        paperSize: PaperKind;
        openAfterExport: boolean;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Settings {
    import StiImageType = Stimulsoft.Report.Export.StiImageType;
    import IStiImageDashboardExportSettings = Stimulsoft.Report.Dashboard.Export.IStiImageDashboardExportSettings;
    class StiImageDashboardExportSettings extends StiDashboardExportSettings implements IStiSizeExportSettings, IStiImageDashboardExportSettings {
        private static ImplementsStiImageDashboardExportSettings;
        implements(): any[];
        format: StiDashboardExportFormat;
        imageType: StiImageType;
        private _width;
        get width(): number;
        set width(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        scale: number;
        constructor(imageType?: StiImageType);
    }
}
declare namespace Stimulsoft.Dashboard.Export.Settings {
    import StiImageType = Stimulsoft.Report.Export.StiImageType;
    class StiSvgDashboardExportSettings extends StiImageDashboardExportSettings {
        imageType: StiImageType;
        renderEmptyContent: boolean;
        designMode: boolean;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Helpers {
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiTitleExportHelper {
        static render(element: IStiElement, component: StiPanel, settings: StiDashboardExportSettings): Rectangle;
        static convert(alignment: StiHorAlignment): StiTextHorAlignment;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiLayoutExportHelper {
        static excludeMargin(element: IStiElement, rect: Rectangle): Rectangle;
        static excludePadding(element: IStiElement, rect: Rectangle): Rectangle;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Helpers {
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiBorderExportHelper {
        static render(element: IStiElement, component: StiComponent, settings: StiDashboardExportSettings): void;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Helpers {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiBackColorExportHelper {
        static render(element: IStiElement, component: StiComponent): void;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Helpers {
    import StiExportFormat = Stimulsoft.Report.StiExportFormat;
    class StiExportFormatHelper {
        static convert(format: StiDashboardExportFormat): StiExportFormat;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Settings {
    import IStiExcelDashboardExportSettings = Stimulsoft.Report.Dashboard.Export.IStiExcelDashboardExportSettings;
    class StiExcelDashboardExportSettings extends StiDashboardExportSettings implements IStiSizeExportSettings, IStiExcelDashboardExportSettings {
        private static ImplementsStiExcelDashboardExportSettings;
        implements(): any[];
        format: StiDashboardExportFormat;
        private _width;
        get width(): number;
        set width(value: number);
        private _height;
        get height(): number;
        set height(value: number);
        imageQuality: number;
        exportDataOnly: boolean;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Settings {
    import IStiPdfDashboardExportSettings = Stimulsoft.Report.Dashboard.Export.IStiPdfDashboardExportSettings;
    class StiPdfDashboardExportSettings extends StiDashboardExportSettings implements IStiPdfDashboardExportSettings {
        private static ImplementsStiPdfDashboardExportSettings;
        implements(): any[];
        format: StiDashboardExportFormat;
        autoPrint: boolean;
        imageQuality: number;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Settings {
    import StiDataType = Stimulsoft.Report.Export.StiDataType;
    import IStiDataDashboardExportSettings = Stimulsoft.Report.Dashboard.Export.IStiDataDashboardExportSettings;
    class StiDataDashboardExportSettings extends StiDashboardExportSettings implements IStiDataDashboardExportSettings {
        private static ImplementsStiDataDashboardExportSettings;
        implements(): any[];
        format: StiDashboardExportFormat;
        dataType: StiDataType;
        constructor(dataType?: StiDataType);
    }
}
declare namespace Stimulsoft.Dashboard.Export.Settings {
    class StiHtmlDashboardExportSettings extends StiDashboardExportSettings {
        format: StiDashboardExportFormat;
        imageQuality: number;
        scale: number;
        enableAnimation: boolean;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Helpers {
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiExportFormat = Stimulsoft.Report.StiExportFormat;
    import StiExportSettings = Stimulsoft.Report.Export.StiExportSettings;
    class StiExportSettingsHelper {
        static getExportSettings(settings: StiDashboardExportSettings): StiExportSettings;
        static getDashboardExportSettings(settings: StiExportSettings): StiDashboardExportSettings;
        static getDashboardExportSettings2(format: StiExportFormat): StiDashboardExportSettings;
        static isDataExport(settings: StiDashboardExportSettings): boolean;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Type = Stimulsoft.System.Type;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiExportTool {
        private static typeToTool;
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        static getTool(type: Type): StiExportTool;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import IStiControlElement = Stimulsoft.Report.Dashboard.IStiControlElement;
    import Image = Stimulsoft.System.Drawing.Image;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    class StiElementExportTool extends StiExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        protected renderContent(element: IStiElement, destination: StiPanel, rect: Rectangle): Promise<void>;
        private drawElement;
        protected draw(element: IStiElement, rect: Rectangle): Promise<Image>;
        protected paintContent(g: Graphics, rect: Rectangle, element: IStiElement): Promise<void>;
        paintAtom(g: Graphics, rect: Rectangle, element: IStiElement): Promise<void>;
        protected renderEmptyDataMessage(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): boolean;
        format(element: IStiControlElement, value: any): string;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import List = Stimulsoft.System.Collections.List;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    class StiChartElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings, chartStartValues?: List<number[]>): Promise<void>;
    }
}
declare namespace Stimulsoft.Dashboard.Export {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import List = Stimulsoft.System.Collections.List;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    class StiDashboardExportTools {
        private static exportToStreamAsync;
        private static renderDashboardAsync;
        private static renderSingleElementAsync;
        static renderElementsAsync(parent: StiContainer, elements: List<IStiElement>, scaleX: number, scaleY: number, settings: StiDashboardExportSettings): Promise<void>;
        static renderElementAsync(parent: StiContainer, element: IStiElement, scaleX: number, scaleY: number, settings: StiDashboardExportSettings, chartStartValues?: List<number[]>, refTitleRect?: {
            ref: Rectangle;
        }): Promise<StiComponent>;
    }
}
declare namespace Stimulsoft.Dashboard.Drawing.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    class StiElementControlPainter {
        static getBorderContentRect(rect: Rectangle, border: StiBorder): Rectangle;
    }
}
declare namespace Stimulsoft.Dashboard.Drawing.Helpers {
    class StiLocHelper {
        static get locAll(): string;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Painters.Table {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiIndicatorColumn = Stimulsoft.Dashboard.Components.Table.StiIndicatorColumn;
    import StiTableElement = Stimulsoft.Dashboard.Components.Table.StiTableElement;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiTableElementStyle = Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import StiSvgGeomWriter = Stimulsoft.Report.Export.StiSvgGeomWriter;
    class StiIndicatorCellPainter {
        static draw(writer: StiSvgGeomWriter, rect: RectangleD, table: StiTableElement, column: StiIndicatorColumn, zoom: number, value: number, style: StiTableElementStyle, drawText?: boolean): void;
        static draw2(writer: StiSvgGeomWriter, rect: RectangleD, table: StiTableElement, column: StiIndicatorColumn, zoom: number, value: number, style: StiTableElementStyle, str: string, drawText?: boolean): void;
        private static drawIndicator;
        private static drawText;
        static measureText(zoom: number, text: string, baseFont: Font): number;
        private static calculateIndicatorRect;
        static getCellText(table: StiTableElement, column: StiIndicatorColumn, value: number): string;
        static calculateTextRect(rect: Rectangle, textObj: any): Rectangle;
        static getColor(column: StiTableColumn, value: number, style: StiTableElementStyle): Color;
        private static toAlignment2;
        static toAlignment(value: StiHorAlignment): StringAlignment;
        private static getHorAlignment;
    }
}
declare namespace Stimulsoft.Dashboard.Drawing.Painters {
    import List = Stimulsoft.System.Collections.List;
    import Size = Stimulsoft.System.Drawing.Size;
    import Font = Stimulsoft.System.Drawing.Font;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiTableElement = Stimulsoft.Dashboard.Components.Table.StiTableElement;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTableElementStyle = Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle;
    class StiTableElementGdiPainter {
        static getBackgroundColor(style: StiTableElementStyle, isInterlaced: boolean): Color;
        private static measureColumn;
        private static getArrowSize;
        private static getRightImageRect;
        static measureSparklinesCell(table: StiTableElement, columnWidth: number, zoom: number): Size;
        static measureIndicatorCell(g: Graphics, table: StiTableElement, column: StiTableColumn, rowValue: any, zoom: number): Size;
        static measureDataBarsCell(g: Graphics, table: StiTableElement, column: StiTableColumn, rowValue: any, zoom: number): Size;
        static measureCommonCell(g: Graphics, table: StiTableElement, column: StiTableColumn, rowValue: any, columnWidth: number, zoom: number): Size;
        static measureHeader(table: StiTableElement, column: StiTableColumn): Size;
        private static measureHeader2;
        static measureCell(caption: string, baseFont: Font): Size;
        private static measureCell2;
        static measureHeaders(columns: List<StiTableColumn>, baseFont: Font): number;
        private static captionSizeCache;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Painters.Table {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiTableElement = Stimulsoft.Dashboard.Components.Table.StiTableElement;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiTableElementStyle = Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle;
    import StiSvgGeomWriter = Stimulsoft.Report.Export.StiSvgGeomWriter;
    class StiBubbleCellPainter {
        static draw(writer: StiSvgGeomWriter, rect: RectangleD, table: StiTableElement, column: StiTableColumn, zoom: number, value: number, min: number, max: number, isInterlaced: boolean, isSelected: boolean, drawText?: boolean): void;
        static getForeColor(table: StiTableElement, column: StiTableColumn, style: StiTableElementStyle, isInterlaced: boolean, isSelected: boolean): Color;
        static calculateBubbleRect(table: StiTableElement, rect: RectangleD, textObj: object, value: number, min: number, max: number): RectangleD;
        static calculateTextRect(table: StiTableElement, rect: RectangleD, textObj: object): RectangleD;
        static getCellText(table: StiTableElement, column: StiTableColumn, value: number): string;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Painters.Table {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTableElementStyle = Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle;
    class StiColorScaleCellPainter {
        static getScaleColor(value: number, min: number, max: number, style: StiTableElementStyle, minimumColor: Color, maximumColor: Color): Color;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Painters.Table {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiTableElement = Stimulsoft.Dashboard.Components.Table.StiTableElement;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiDataBarsDirection = Stimulsoft.Dashboard.Components.Table.StiDataBarsDirection;
    import StiDataBarsBrushType = Stimulsoft.Dashboard.Components.Table.StiDataBarsBrushType;
    import StiTableElementStyle = Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle;
    import StiSvgGeomWriter = Stimulsoft.Report.Export.StiSvgGeomWriter;
    class StiDataBarsCellPainter {
        static draw(writer: StiSvgGeomWriter, rect: RectangleD, table: StiTableElement, column: StiTableColumn, zoom: number, value: number, min: number, max: number, isInterlaced: boolean, isSelected: boolean, drawText?: boolean, direction?: StiDataBarsDirection, brushType?: StiDataBarsBrushType): void;
        static draw2(writer: StiSvgGeomWriter, rect: RectangleD, value: number, min: number, max: number, zoom: number, text: string, table: StiTableElement, column: StiTableColumn, isInterlaced: boolean, isSelected: boolean, drawText?: boolean, direction?: StiDataBarsDirection, brushType?: StiDataBarsBrushType): void;
        static getForeColor(table: StiTableElement, column: StiTableColumn, style: StiTableElementStyle, isInterlaced: boolean, isSelected: boolean): Color;
        static calculateDataBarsRect(rect: RectangleD, textObj: object): RectangleD;
        static calculateTextRect(rect: RectangleD, textObj: object): RectangleD;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Painters.Table {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiTableElementStyle = Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle;
    import StiSvgGeomWriter = Stimulsoft.Report.Export.StiSvgGeomWriter;
    import StiSparklinesColumn = Stimulsoft.Dashboard.Components.Table.StiSparklinesColumn;
    class StiSparklinesCellPainter {
        static draw(writer: StiSvgGeomWriter, rect: RectangleD, column: StiSparklinesColumn, value: any, style: StiTableElementStyle): void;
        static castToArray(value: any): any[];
    }
}
declare namespace Stimulsoft.Dashboard.Export.Settings {
    let IStiSizeExportSettings: System.Interface<IStiSizeExportSettings>;
    interface IStiSizeExportSettings {
        width: number;
        height: number;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiComboBoxElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        getValuesCount(element: IStiElement, dataTable: StiDataTable): number;
        private renderElement;
        private renderItem;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiDatePickerElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        private getDateTimeString;
        private getRangeVariableString;
        private getAutoRangeColumnString;
        private getRangeColumnString;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiGaugeElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import StiBorderSides = Stimulsoft.Base.Drawing.StiBorderSides;
    import List = Stimulsoft.System.Collections.List;
    import StiCheckStyle = Stimulsoft.Report.Components.StiCheckStyle;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiListBoxElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        private static getCheckStyle;
        protected renderItems(destination: StiPanel, rect: Rectangle, element: IStiElement): Promise<void>;
        protected renderItems2(destination: StiPanel, rect: Rectangle, element: IStiElement, values: List<string>, checks: List<StiCheckStyle>): void;
        private getHorizontalItemAutoWidth;
        private measureItemWidth;
        protected renderItem(destination: StiPanel, rect: Rectangle, element: IStiElement, value: string, checkStyle: StiCheckStyle, lineSide: StiBorderSides, drawCheckBox: boolean): void;
        private static renderCheckBox;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiPanelElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiPivotTableElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        private static renderForWebDesigner;
        private static renderCells;
        private static convertSizes;
        private static convert;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiRegionMapElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    class StiShapeElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPromise = Stimulsoft.System.StiPromise;
    import IStiTableElement = Stimulsoft.Report.Dashboard.IStiTableElement;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiTableElement = Stimulsoft.Dashboard.Components.Table.StiTableElement;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    class StiTableElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        static renderCellsForViewerAsync(element: IStiTableElement): StiPromise<any[]>;
        private static renderCells;
        private static measureSparklinesCell;
        private static measureHeader;
        private static measureFooter;
        private static measureIndicatorCell;
        private static measureDataBarsCell;
        private static measureCommonCell;
        private static renderHeader;
        private static renderFooter;
        static renderCell(destination: StiPanel, rect: Rectangle, table: StiTableElement, rowValues: any[], columnKeys: string[], column: StiTableColumn, zoom: number, value: any, min: number, max: number, isInterlaced: boolean, format: StiDashboardExportFormat, exportDataOnly: boolean): void;
        private static renderGraphicCell;
        private static drawColorScaleColumn;
        private static renderBoolCell2;
        private static renderTextCell;
        private static renderImageCell;
        private static renderBoolCell;
        private static getForeColor;
        private static getHeaderForeColor;
        private static getFooterForeColor;
        private static getBorderSides;
        private static fitByWidth;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiTextElementExportTool extends StiElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        private changeFontSize;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiTreeViewBoxElementExportTool extends StiComboBoxElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        getValuesCount(element: IStiElement, dataTable: StiDataTable): number;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import StiBorderSides = Stimulsoft.Base.Drawing.StiBorderSides;
    import StiCheckStyle = Stimulsoft.Report.Components.StiCheckStyle;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiTreeViewElementExportTool extends StiListBoxElementExportTool {
        render(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        private getCheckStyle;
        protected renderItems(destination: StiPanel, rect: Rectangle, element: IStiElement): Promise<void>;
        protected renderItem(destination: StiPanel, rect: Rectangle, element: IStiElement, value: string, checkStyle: StiCheckStyle, lineSide: StiBorderSides, drawCheckBox: boolean): void;
        private static renderExpander;
    }
}
declare namespace Stimulsoft.Viewer {
    enum StiContentAlignment {
        Left = 0,
        Center = 1,
        Right = 2,
        Default = 3
    }
    enum StiInterfaceType {
        Auto = 0,
        Mouse = 1,
        Touch = 2,
        Mobile = 3
    }
    enum StiChartRenderType {
        Vector = 2,
        AnimatedVector = 3
    }
    enum StiPrintDestination {
        Default = 0,
        Pdf = 1,
        Direct = 2,
        WithPreview = 3
    }
    enum StiReportType {
        Auto = 0,
        Report = 1,
        Dashboard = 2
    }
    enum StiWebViewMode {
        SinglePage = 0,
        Continuous = 1,
        MultiplePages = 2,
        OnePage = 3,
        WholeReport = 4,
        MultiPage = 5
    }
    enum StiShowMenuMode {
        Click = 0,
        Hover = 1
    }
    enum StiZoomMode {
        PageWidth = -1,
        PageHeight = -2
    }
    enum StiExportAction {
        ExportReport = 1,
        SendEmail = 2
    }
    enum StiFirstDayOfWeek {
        Auto = 0,
        Monday = 1,
        Sunday = 2
    }
    enum StiParametersPanelPosition {
        Top = 0,
        Left = 1
    }
    enum StiToolbarDisplayMode {
        Simple = 0,
        Separated = 1
    }
}
declare namespace Stimulsoft.Viewer {
    class StiEmailSettings {
        email: string;
        subject: string;
        message: string;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import StiPromise = Stimulsoft.System.StiPromise;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiExportFormat = Stimulsoft.Report.StiExportFormat;
    class StiDashboardsSvgHelper {
        private static getSvgImageValue;
        private static saveElementToVectorStringAsync;
        static saveElementToStringAsync(element: IStiElement, scaleX?: number, scaleY?: number, designMode?: boolean, exportFormat?: StiExportFormat, requestParams?: any, refNeedToScroll?: any): StiPromise<string>;
        static saveElementToBase64Async(element: IStiElement, scaleX?: number, scaleY?: number, designMode?: boolean, exportFormat?: StiExportFormat, requestParams?: any): StiPromise<string>;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import StiReport = Stimulsoft.Report.StiReport;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    import StiPromise = Stimulsoft.System.StiPromise;
    import IStiControlElement = Stimulsoft.Report.Dashboard.IStiControlElement;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    class StiDashboardElementViewHelper {
        static getElementContentAttributesAsync(element: IStiElement, scaleX: number, scaleY: number, requestParams: any): Promise<KeyObjectType>;
        static getForeColor(element: IStiElement): string;
        static getBackColor(element: IStiElement): string;
        static getBorder(element: IStiElement): any;
        static getBorderJson(border: StiSimpleBorder): KeyObjectType;
        static getFont(element: IStiElement): any;
        static getFontJson(font: Font): KeyObjectType;
        static getTitle(element: IStiElement): KeyObjectType;
        static getControlElementSettings(element: IStiElement): KeyObjectType;
        static getLayout(element: IStiElement): KeyObjectType;
        private static fixColor;
        static getActionColors(element: IStiElement): KeyObjectType;
        static getBingMapScriptAsync(element: IStiElement, showTitle: boolean): StiPromise<string>;
        static getDashboardInteractionAsync(object_: any): Promise<KeyObjectType>;
        private static getHyperlinkTextAsync;
        static format(element: IStiControlElement, value: any): string;
        static getConstants(value: string, cells: any): Hashtable;
        static parseDashboardDrillDownParameters(drillDownParameters: any[], report: StiReport): void;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiRangeBand {
        top: number;
        bottom: number;
        get height(): number;
        originalTop: number;
        originalBottom: number;
        get originalHeight(): number;
        isFixed: boolean;
        toString(): string;
        intersect(rect: Rectangle): boolean;
        constructor(top: number, bottom: number);
    }
}
declare namespace Stimulsoft.Viewer {
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    import StiPromise = Stimulsoft.System.StiPromise;
    import StiRangeBand = Stimulsoft.Viewer.Helpers.Dashboards.StiRangeBand;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import List = Stimulsoft.System.Collections.List;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiReportHelper {
        static getHtmlColor(color: Color): string;
        private static round;
        private static round2;
        static getNestedPages(report: StiReport): List<StiPage>;
        static getDashboards(report: StiReport, combineReportPages: boolean): KeyObjectType[];
        private static getElementsPositions;
        private static correctElementLocations;
        static getDashboardPageAsync(report: StiReport, pageIndex: number, requestParams: any): StiPromise<KeyObjectType>;
        static getElementAttributesAsync(page: StiPage, element: IStiElement, renderSingleElement: boolean, requestParams: any, elementOldHeights: any, bands?: List<StiRangeBand>, totalFixedHeight?: number): Promise<KeyObjectType>;
        static getSingleElementContentAsync(report: StiReport, requestParams: any): StiPromise<KeyObjectType>;
        static calculatePositionForEachBand(requestParams: any, elements: List<IStiElement>, page: StiPage, bands: {
            ref: List<StiRangeBand>;
        }, totalFixedHeight: {
            ref: number;
        }, component?: StiComponent): void;
        private static calculateParentPanelPositions;
        static applySorting(report: StiReport, parameters: any): void;
        static applyCollapsing(report: StiReport, parameters: any): void;
        static applyDrillDown(report: StiReport, renderedReport: StiReport, parameters: any, drillDownParameters: any): Promise<StiReport>;
        static applyDashboardDrillDown(report: StiReport, drillDownParameters: any): StiReport;
        private static addBookmarkNode;
        static getBookmarksContent(report: StiReport, viewerId: string, pageNumber: number): string;
        private static getBookmarksPageIndexes;
        static getTableOfContentsPointers(report: StiReport, requestParams: StiRequestParams): any[];
        private static getBookmarkPointers;
        static getReportPreviewSettings(report: StiReport): KeyObjectType;
        static getPagesCount(report: StiReport, originalPageNumber: number, combineReportPages: boolean): number;
        static isMixedReport(report: StiReport): boolean;
    }
    class StiBookmarkTreeNode {
        parent: number;
        title: string;
        url: string;
        used: boolean;
        componentGuid: string;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDataSortsHelper {
        static applySorting(report: StiReport, parameters: any): void;
        static applySortsToElement(element: IStiElement, sorts: any[]): void;
        static getElementSorts(element: IStiElement): any[];
        static sortRuleItem(sortRule: StiDataSortRule): any;
        static getSortMenuItems(element: IStiElement): any[];
        private static getSortDirection;
        private static fetchAllArguments;
        private static fetchAllValues;
        private static getSeries;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    import IStiDrillDownElement = Stimulsoft.Data.Engine.IStiDrillDownElement;
    import StiPromise = Stimulsoft.System.StiPromise;
    import StiReport = Stimulsoft.Report.StiReport;
    import List = Stimulsoft.System.Collections.List;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import Type = Stimulsoft.System.Type;
    import IStiQueryObject = Stimulsoft.Data.Engine.IStiQueryObject;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiDataFiltersHelper {
        static applyFiltering(report: StiReport, parameters: any): void;
        static applyFiltersToElement(element: IStiElement, filters: any[]): void;
        static getElementFilters(element: IStiElement): KeyObjectType[];
        static getFilterItemsAsync(report: StiReport, requestParams: any): StiPromise<any>;
        static getViewDataAsync(report: StiReport, requestParams: any): StiPromise<any>;
        private static removeSystemMeters;
        static getDataTableFilterQueryStringRepresentation(element: IStiElement): string;
        static getDrillDownFilters(drillDownElement: IStiDrillDownElement): any[];
        static getDrillDownFiltersList(drillDownElement: IStiDrillDownElement): KeyObjectType[][];
        static isStringColumnType(element: IStiElement): boolean;
        static isBlankData(data: any): boolean;
        static filterRuleItem(filterRule: StiDataFilterRule): KeyObjectType;
        private static sortFilterMenuItem;
        static getFilterItemsHelperAsync(query: IStiQueryObject, meters: List<IStiMeter>, columnIndex: number, sorts: List<StiDataSortRule>, filters: List<StiDataFilterRule>, element?: IStiElement): StiPromise<any>;
        static typeToString(type: Type): string;
        static toFilterString(value: any, type?: Type): string;
        static toDisplayString(value: any, type?: Type): string;
        private static distinct;
        private static isValueCanBeFiltered;
        private static getLevel;
        static applyDefaultFiltersForFilterElementsAsync(report: StiReport): StiPromise<any>;
        private static applyDatePickerFiltersToVariable;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDashboardElementDrillDownHelper {
        static applyDashboardElementDrillDown(report: StiReport, parameters: any): void;
        static applyDrillDownToElement(element: IStiElement, filters: any[]): void;
        static applyDashboardElementDrillUp(report: StiReport, parameters: any): void;
        static applyDrillUpToElement(element: IStiElement): void;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    import StiPromise = Stimulsoft.System.StiPromise;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import List = Stimulsoft.System.Collections.List;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import IStiChartElement = Stimulsoft.Report.Dashboard.IStiChartElement;
    class StiChartElementViewHelper {
        private static isAllowInteractive;
        static getArgumentColumnPath(chartElement: IStiChartElement): string;
        static getSeriesColumnPath(chartElement: IStiChartElement): string;
        static getBubleXColumnPath(chartElement: IStiChartElement): string;
        static getBubleYColumnPath(chartElement: IStiChartElement): string;
        static getSeriesValues(chart: IStiChart): List<number[]>;
        static getChartValuesFromCache(cacheGuid: string, requestParams: any): any;
        static saveChartValuesToCache(cacheGuid: string, page: StiPage, requestParams: any): void;
        static isBubble(chartElement: IStiChartElement): boolean;
        static getUserViewStates(chartElement: IStiChartElement): any[];
        static changeChartElementViewStateAsync(report: StiReport, requestParams: any): StiPromise<KeyObjectType>;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDashboardVariablesHelpers {
        private static isParametersExist;
        static fillParametersAsync(report: StiReport): Promise<void>;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import StiReport = Stimulsoft.Report.StiReport;
    import IStiDatePickerElement = Stimulsoft.Report.Dashboard.IStiDatePickerElement;
    class StiDatePickerElementViewHelper {
        static getAutoRangeValues(datePickerElement: IStiDatePickerElement): Promise<any>;
        static getVariableRangeValues(datePickerElement: IStiDatePickerElement): any;
        static getVariableValue(datePickerElement: IStiDatePickerElement): string;
        static isVariablePresent(datePickerElement: IStiDatePickerElement): boolean;
        static isRangeVariablePresent(datePickerElement: IStiDatePickerElement): boolean;
        static getFormattedValues(report: StiReport, requestParams: any): any;
        static getColumnPath(datePickerElement: IStiDatePickerElement): string;
        static getSettings(datePickerElement: IStiDatePickerElement): any;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import StiPromise = Stimulsoft.System.StiPromise;
    import StiReport = Stimulsoft.Report.StiReport;
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    import IStiTableElement = Stimulsoft.Report.Dashboard.IStiTableElement;
    class StiTableElementViewHelper {
        static getTableData(tableElement: IStiTableElement): Promise<KeyObjectType[][]>;
        static getTableHiddenData(tableElement: IStiTableElement): Promise<KeyObjectType[][]>;
        static getTableSettings(tableElement: IStiTableElement): KeyObjectType;
        private static getCellForeColor;
        private static getHeaderForeColor;
        private static getFooterForeColor;
        private static getCellAlignment;
        private static getSortLabel;
        private static getFilterLabel;
        static changeTableElementSelectColumns(report: StiReport, requestParams: any): StiPromise<KeyObjectType>;
    }
}
declare namespace Stimulsoft.Viewer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiJsViewer {
        options: any;
        defaultParameters: any;
        controls: any;
        reportParams: any;
        assignReport(report: StiReport): any;
        initAutoUpdateCache(jsText: any, jsObject: any): any;
        postAjax(url: string, data: any, callback?: any): any;
        postAction(action: string, bookmarkPage?: any, bookmarkAnchor?: any): any;
        postEmail(format: string, settingsObject: any): any;
        postExport(format: string, settingsObject: any, action: StiExportAction): any;
        postReportResource(resourceName: string, viewType: string): any;
        postPrint(action: string): any;
        postOpen(fileName: string, content: string): any;
        postInteraction(params: any): any;
        postDesign(): any;
        getReportParameters(action: string): any;
        viewer: StiViewer;
        InitializeErrorMessageForm(): any;
        updateVisibleState(): any;
        showParametersPanel(data: any, jsObject: any): any;
        openNewWindow(url: any, name?: any, specs?: any): any;
        removeAllEvents(): any;
        sortPropsInDrillDownParameters(obj: any): any;
        InitializeBookmarksPanel(): any;
        createPostParameters(data: any, asObject: boolean): any;
        dashboardProcessTimeout: number;
        showReportPage(data: any, jsObject: StiJsViewer): any;
        InitializePasswordForm(): any;
        collections: {
            loc: {};
        };
        constructor(parameters: any);
    }
    class StiBase64 {
    }
    class StiViewer {
        drillDownReportCache: any;
        private _renderAfterCreate;
        onPrepareVariables: Function;
        onBeginProcessData: Function;
        onEndProcessData: Function;
        onPrintReport: Function;
        onBeginExportReport: Function;
        onEndExportReport: Function;
        onInteraction: Function;
        onEmailReport: Function;
        onDesignReport: Function;
        onShowReport: Function;
        onLoadDocument: Function;
        onGetReport: Function;
        onGetSubReport: Function;
        private reportCache;
        private _viewerId;
        get viewerId(): string;
        private _options;
        get options(): StiViewerOptions;
        jsObject: StiJsViewer;
        private _currentReportGuid;
        get currentReportGuid(): string;
        set currentReportGuid(value: string);
        get reportTemplate(): StiReport;
        get report(): StiReport;
        set report(value: StiReport);
        private _visible;
        get visible(): boolean;
        set visible(value: boolean);
        renderHtml(element?: string | HTMLElement): void;
        private invokePrepareVariables;
        private invokeBeginProcessData;
        private invokeEndProcessData;
        private invokePrintReport;
        private invokeBeginExportReport;
        private invokeEndExportReport;
        private invokeInteraction;
        private invokeEmailReport;
        private invokeDesignReport;
        private invokeShowReport;
        private invokeLoadDocument;
        private invokeGetReport;
        private invokeOnGetSubReport;
        private callRemoteApi;
        private getReportPageAsync;
        private getPagesArray;
        private getReportFileName;
        showProcessIndicator(): void;
        hideProcessIndicator(): void;
        refreshViewer(): void;
        dispatch(removeEvent?: boolean): void;
        constructor(options?: StiViewerOptions, viewerId?: string, renderAfterCreate?: boolean);
    }
}
declare namespace Stimulsoft.Viewer {
    class StiViewerOptions {
        appearance: StiAppearanceOptions;
        toolbar: StiToolbarOptions;
        exports: StiExportsOptions;
        email: StiEmailOptions;
        width: string;
        height: string;
        viewerId: string;
        reportDesignerMode: boolean;
        private requestResourcesUrl;
        private requestStylesUrl;
        private productVersion;
        private actions;
        toParameters(): any;
        private serializeObject;
    }
}
declare namespace Stimulsoft.Viewer {
    class StiRequestParams {
        interaction: StiInteractionParams;
    }
    class StiInteractionParams {
        variables: {};
        sorting: {};
        collapsing: {};
        drillDown: any[];
        editable: {};
        dashboardFiltering: {};
        dashboardSorting: {};
    }
}
declare namespace Stimulsoft.Viewer {
    class StiCollectionsHelper {
        static getLocalizationItems(): any;
    }
}
declare namespace Stimulsoft.Viewer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiEditableFieldsHelper {
        static checkEditableReport(report: StiReport): boolean;
        static applyEditableFieldsToReport(report: StiReport, parameters: any): void;
    }
}
declare namespace Stimulsoft.Viewer {
    import StiPromise = Stimulsoft.System.StiPromise;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiExportFormat = Stimulsoft.Report.StiExportFormat;
    import IStiDashboardExportSettings = Stimulsoft.Report.Dashboard.Export.IStiDashboardExportSettings;
    class StiExportsHelper {
        static getReportFileName(report: StiReport): string;
        static applyExportSettings(exportFormat: StiExportFormat, settingsObject: any, settings: any): void;
        static getDashboardExportSettings(exportFormat: StiExportFormat, settingsObject: any): IStiDashboardExportSettings;
        private static getPdfDashboardExportSettings;
        private static getExcelDashboardExportSettings;
        private static getDataDashboardExportSettings;
        private static getImageDashboardExportSettings;
        private static getHtmlDashboardExportSettings;
        static exportDashboardAsync(requestParams: any, report: StiReport, exportSettings: IStiDashboardExportSettings): StiPromise<number[]>;
    }
}
declare namespace Stimulsoft.Viewer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiReportContainer {
        report: StiReport;
        resourcesIncluded: boolean;
        command: string;
        constructor(report: StiReport, resourcesIncluded: boolean, command?: string);
    }
}
declare namespace Stimulsoft.Viewer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiReportCopier {
        static cloneReport(report: StiReport, withResources: boolean): StiReport;
        private static cloneResources;
        static copyReportDictionary(reportFrom: StiReport, reportTo: StiReport): void;
        static copyElementsDrillDown(reportFrom: StiReport, reportTo: StiReport): void;
        static copyFilterElementsUserFilters(reportFrom: StiReport, reportTo: StiReport): void;
    }
}
declare namespace Stimulsoft.Viewer {
    import StiResourcesCollection = Stimulsoft.Report.Dictionary.StiResourcesCollection;
    import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiReportResourceHelper {
        static getResourcesItems(report: StiReport): any[];
        static isFontResourceType(resourceType: StiResourceType): boolean;
        static getFontResourcesArray(report: StiReport): any[];
        static getBase64DataFromFontResourceContent(resourceType: StiResourceType, content: number[]): string;
        static loadResourcesToReport(report: StiReport, resources: StiResourcesCollection): void;
    }
}
declare namespace Stimulsoft.Viewer {
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiVariablesHelper {
        private en_us_culture;
        static fillDialogInfoItems(report: StiReport): Promise<void>;
        private static getVariableAlias;
        private static getItems;
        private static containsBindingVariableValue;
        private static getDateTimeObject;
        private static getTimeSpanStringValue;
        private static getBasicType;
        private static getStiType;
        static applyReportParameters(report: StiReport, values: any): void;
        static applyReportBindingVariables(report: StiReport, values: any): void;
        private static setVariableValue;
        static getVariables(report: StiReport, values: any, sortDataItems: boolean): Promise<any>;
        static getVariablesValues(report: StiReport): KeyObjectType;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    import IStiComboBoxElement = Stimulsoft.Report.Dashboard.IStiComboBoxElement;
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiComboBoxElementViewHelper {
        static getElementItems(comboBoxElement: IStiComboBoxElement): Promise<List<any>>;
        static comboBoxItem(label: string, value: any): KeyObjectType;
        static getSettings(comboBoxElement: IStiComboBoxElement): any;
        protected static getNameMeterIndex(table: StiDataTable): number;
        protected static getKeyMeterIndex(table: StiDataTable): number;
        static getColumnPath(comboBoxElement: IStiComboBoxElement): string;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import IStiImageElement = Stimulsoft.Report.Dashboard.IStiImageElement;
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    class StiImageElementViewHelper {
        static getImageSvgContent(imageElement: IStiImageElement, scaleX?: number, scaleY?: number, requestParams?: any): Promise<KeyObjectType>;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    import IStiListBoxElement = Stimulsoft.Report.Dashboard.IStiListBoxElement;
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiListBoxElementViewHelper {
        static getElementItems(listBoxElement: IStiListBoxElement): Promise<List<any>>;
        static listBoxItem(label: string, value: any): KeyObjectType;
        static getSettings(listBoxElement: IStiListBoxElement): any;
        protected static getNameMeterIndex(table: StiDataTable): number;
        protected static getKeyMeterIndex(table: StiDataTable): number;
        static getColumnPath(listBoxElement: IStiListBoxElement): string;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    import IStiPivotTableElement = Stimulsoft.Report.Dashboard.IStiPivotTableElement;
    class StiPivotTableElementViewHelper {
        static getPivotTableData(pivotElement: IStiPivotTableElement): Promise<any>;
        static getPivotTableSettings(tableElement: IStiPivotTableElement): KeyObjectType;
        private static getCellAlignment;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import IStiRegionMapElement = Stimulsoft.Report.Dashboard.IStiRegionMapElement;
    class StiRegionMapElementViewHelper {
        static getColumnPath(regionMapElement: IStiRegionMapElement): string;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    import IStiTreeViewBoxElement = Stimulsoft.Report.Dashboard.IStiTreeViewBoxElement;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiTreeViewBoxElementViewHelper {
        static getElementItems(treeViewBoxElement: IStiTreeViewBoxElement): Promise<List<KeyObjectType>>;
        static treeViewBoxItem(treeViewBoxElement: IStiTreeViewBoxElement, key?: any, meter?: IStiMeter): KeyObjectType;
        static getSettings(treeViewBoxElement: IStiTreeViewBoxElement): any;
        static getColumnPath(treeViewBoxElement: IStiTreeViewBoxElement): string;
        static getMeterKey(treeViewBoxElement: IStiTreeViewBoxElement): string;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import KeyObjectType = Stimulsoft.System.KeyObjectType;
    import IStiTreeViewElement = Stimulsoft.Report.Dashboard.IStiTreeViewElement;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiTreeViewElementViewHelper {
        static getElementItems(treeViewElement: IStiTreeViewElement): Promise<List<KeyObjectType>>;
        static treeViewItem(treeViewElement: IStiTreeViewElement, key?: any, meter?: IStiMeter): KeyObjectType;
        static getSettings(treeViewElement: IStiTreeViewElement): any;
        static getColumnPath(treeViewElement: IStiTreeViewElement): string;
        static getMeterKey(treeViewElement: IStiTreeViewElement): string;
    }
}
declare namespace Stimulsoft.Viewer {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiHtmlExportMode = Stimulsoft.Report.Export.StiHtmlExportMode;
    class StiAppearanceOptions {
        backgroundColor: Color;
        pageBorderColor: Color;
        rightToLeft: boolean;
        fullScreenMode: boolean;
        scrollbarsMode: boolean;
        openLinksWindow: string;
        openExportedReportWindow: string;
        showTooltips: boolean;
        showTooltipsHelp: boolean;
        showDialogsHelp: boolean;
        pageAlignment: StiContentAlignment;
        showPageShadow: boolean;
        bookmarksPrint: boolean;
        bookmarksTreeWidth: number;
        parametersPanelPosition: StiParametersPanelPosition;
        parametersPanelMaxHeight: number;
        parametersPanelColumnsCount: number;
        parametersPanelDateFormat: string;
        parametersPanelSortDataItems: boolean;
        interfaceType: StiInterfaceType;
        chartRenderType: StiChartRenderType;
        reportDisplayMode: StiHtmlExportMode;
        datePickerFirstDayOfWeek: StiFirstDayOfWeek;
        datePickerIncludeCurrentDayForRanges: boolean;
        allowTouchZoom: boolean;
        combineReportPages: boolean;
        htmlRenderMode: StiHtmlExportMode;
    }
}
declare namespace Stimulsoft.Viewer {
    class StiEmailOptions {
        showEmailDialog: boolean;
        showExportDialog: boolean;
        defaultEmailAddress: string;
        defaultEmailSubject: string;
        defaultEmailMessage: string;
    }
}
declare namespace Stimulsoft.Viewer {
    class StiExportsOptions {
        storeExportSettings: boolean;
        showExportDialog: boolean;
        showExportToDocument: boolean;
        showExportToPdf: boolean;
        showExportToHtml: boolean;
        showExportToHtml5: boolean;
        showExportToWord2007: boolean;
        showExportToExcel2007: boolean;
        showExportToCsv: boolean;
        showExportToJson: boolean;
        showExportToText: boolean;
        showExportToOpenDocumentWriter: boolean;
        showExportToOpenDocumentCalc: boolean;
        showExportToPowerPoint: boolean;
        showExportToImageSvg: boolean;
    }
}
declare namespace Stimulsoft.Viewer {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiToolbarOptions {
        visible: boolean;
        displayMode: StiToolbarDisplayMode;
        backgroundColor: Color;
        borderColor: Color;
        fontColor: Color;
        fontFamily: string;
        alignment: StiContentAlignment;
        showButtonCaptions: boolean;
        showPrintButton: boolean;
        showOpenButton: boolean;
        showSaveButton: boolean;
        showSendEmailButton: boolean;
        showFindButton: boolean;
        showBookmarksButton: boolean;
        showParametersButton: boolean;
        showResourcesButton: boolean;
        showEditorButton: boolean;
        showFullScreenButton: boolean;
        showRefreshButton: boolean;
        showFirstPageButton: boolean;
        showPreviousPageButton: boolean;
        showCurrentPageControl: boolean;
        showNextPageButton: boolean;
        showLastPageButton: boolean;
        showZoomButton: boolean;
        showViewModeButton: boolean;
        showDesignButton: boolean;
        showAboutButton: boolean;
        showPinToolbarButton: boolean;
        printDestination: StiPrintDestination;
        viewMode: StiWebViewMode;
        multiPageWidthCount: number;
        multiPageHeightCount: number;
        private _zoom;
        get zoom(): number;
        set zoom(value: number);
        menuAnimation: boolean;
        showMenuMode: StiShowMenuMode;
        autoHide: boolean;
    }
}
declare namespace Stimulsoft.Report.Check {
    enum StiCheckStatus {
        ReportRenderingMessage = 0,
        Information = 1,
        Warning = 2,
        Error = 3
    }
    enum StiCheckObjectType {
        Report = 0,
        Page = 1,
        Component = 2,
        Database = 3,
        DataSource = 4,
        DataRelation = 5,
        DataColumn = 6,
        Variable = 7
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiCheck {
        private _element;
        get element(): any;
        set element(value: any);
        get previewVisible(): boolean;
        get elementName(): string;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        get objectType(): StiCheckObjectType;
        get defaultStateEnabled(): boolean;
        get enabled(): boolean;
        set enabled(value: boolean);
        private _actions;
        get actions(): StiAction[];
        processCheck(report: StiReport, obj: any): any;
        createPreviewImage(refElementImage: any, refHighlightedElementImage: {
            ref: string;
        }): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiCheckEngine {
        private invokeFinishCheckingReport;
        private invokeStartCheckingPages;
        private invokeCheckingPages;
        private invokeFinishCheckingPages;
        private invokeStartCheckingComponents;
        private invokeCheckingComponents;
        private invokeFinishCheckingComponents;
        private invokeStartCheckingDatabases;
        private invokeCheckingDatabases;
        private invokeFinishCheckingDatabases;
        private invokeStartCheckingDataSource;
        private invokeCheckingDataSource;
        private invokeFinishCheckingDataSource;
        private invokeStartCheckingRelations;
        private invokeCheckingRelations;
        private invokeFinishCheckingRelations;
        private invokeStartCheckingVariables;
        private invokeCheckingVariables;
        private invokeFinishCheckingVariables;
        private static _checks;
        static get checks(): StiCheck[];
        private _progressValue;
        get progressValue(): number;
        private _progressMaximum;
        get progressMaximum(): number;
        private _progressInformation;
        get progressInformation(): string;
        private static createChecks;
        checkReport(report: StiReport): StiCheck[];
        private static checkObject;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiCheckHelper {
        private _errorsCount;
        get errorsCount(): number;
        private _warningsCount;
        get warningsCount(): number;
        private _informationMessagesCount;
        get informationMessagesCount(): number;
        private _reportRenderingMessagesCount;
        get reportRenderingMessagesCount(): number;
        private _checks;
        get checks(): StiCheck[];
        private _reportRenderingMessagesChecks;
        get reportRenderingMessagesChecks(): StiCheck[];
        get isMessagesPresent(): boolean;
        buildChecks(report: StiReport): void;
        buildReportRenderingMessages(report: StiReport): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiLocalizationExt {
        static languages: any;
        static English: {
            "@language": string;
            "@description": string;
            "@cultureName": string;
            CheckActions: {
                ApplyEngineV2Long: string;
                Change: string;
                ChangeReportToInterpretationMode: string;
                Code: string;
                Convert: string;
                Delete: string;
                Edit: string;
                Fix: string;
                GotoCodeLong: string;
                Hide: string;
                NewName: string;
                Off: string;
                On: string;
                SetGrowToHeightToFalse: string;
                SetGrowToHeightToTrue: string;
                StiAllowHtmlTagsInTextActionLong: string;
                StiAllowOnDoublePassActionLong: string;
                StiApplyGeneralTextFormatLong: string;
                StiApplyGeneralTextFormatShort: string;
                StiCanBreakComponentInContainerActionLong: string;
                StiCanGrowComponentInContainerActionLong: string;
                StiCanGrowGrowToHeightComponentInContainerLong: string;
                StiCanGrowWordWrapTextAndWysiwygActionLong: string;
                StiColumnsWidthGreaterContainerWidthActionLong: string;
                StiComponentStyleIsNotFoundOnComponentActionLong: string;
                StiDeleteComponentActionLong: string;
                StiDeleteConnectionActionLong: string;
                StiDeleteDataRelationActionLong: string;
                StiDeleteDataSourceActionLong: string;
                StiDeleteLostPointsActionLong: string;
                StiDeletePageActionLong: string;
                StiFixCrossLinePrimitiveActionLong: string;
                StiGenerateNewNameComponentActionLong: string;
                StiGenerateNewNameDataSourceActionLong: string;
                StiGenerateNewNamePageActionLong: string;
                StiGenerateNewNameRelationActionLong: string;
                StiGrowToHeightOverlappingLong: string;
                StiLargeHeightAtPageActionLong: string;
                StiMinRowsInColumnsActionLong: string;
                StiMoveComponentToPageAreaActionLong: string;
                StiMoveComponentToPageAreaActionShort: string;
                StiMoveComponentToPrintablePageAreaActionLong: string;
                StiMoveComponentToPrintablePageAreaActionShort: string;
                StiNegativeSizesOfComponentsActionLong: string;
                StiOrientationPageToLandscapeActionLong: string;
                StiOrientationPageToLandscapeActionShort: string;
                StiOrientationPageToPortraitActionLong: string;
                StiOrientationPageToPortraitActionShort: string;
                StiPrintHeadersFootersFromPreviousPageLong: string;
                StiPrintOnPreviousPageLong: string;
                StiPropertiesOnlyEngineV1ActionLong: string;
                StiPropertiesOnlyEngineV2ActionLong: string;
                StiResetPageNumberActionLong: string;
                StiSwitchWidthAndHeightOfPageActionLong: string;
                StiVerySmallSizesOfComponentsLong: string;
                StiVerySmallSizesOfComponentsShort: string;
                StiWordWrapCanGrowTextDoesNotFitActionLong: string;
                Zero: string;
            };
            CheckComponent: {
                StiAllowHtmlTagsInTextCheckLong: string;
                StiAllowHtmlTagsInTextCheckShort: string;
                StiCanBreakComponentInContainerCheckLong: string;
                StiCanBreakComponentInContainerCheckShort: string;
                StiCanGrowComponentInContainerCheckLong: string;
                StiCanGrowComponentInContainerCheckShort: string;
                StiCanGrowGrowToHeightComponentInContainerLong: string;
                StiCanGrowGrowToHeightComponentInContainerShort: string;
                StiCanGrowWordWrapTextAndWysiwygCheckLong: string;
                StiCanGrowWordWrapTextAndWysiwygCheckShort: string;
                StiChartSeriesValueCheckLong: string;
                StiColumnsWidthGreaterContainerWidthCheckLong: string;
                StiColumnsWidthGreaterContainerWidthCheckShort: string;
                StiColumnsWidthGreaterPageWidthCheckLong: string;
                StiColumnsWidthGreaterPageWidthCheckShort: string;
                StiComponentBoundsAreOutOfBandLong: string;
                StiComponentBoundsAreOutOfBandShort: string;
                StiComponentExpressionCheckLong: string;
                StiComponentExpressionCheckShort: string;
                StiComponentResourceCheckLong: string;
                StiComponentResourceCheckShort: string;
                StiComponentStyleIsNotFoundCheckAtPageLong: string;
                StiComponentStyleIsNotFoundCheckLong: string;
                StiComponentStyleIsNotFoundCheckShort: string;
                StiContainerInEngineV2CheckLong: string;
                StiContainerInEngineV2CheckShort: string;
                StiContourTextObsoleteCheckLong: string;
                StiContourTextObsoleteCheckShort: string;
                StiCorruptedCrossLinePrimitiveCheckLong: string;
                StiCorruptedCrossLinePrimitiveCheckShort: string;
                StiCountDataDataSourceAtDataBandLong: string;
                StiCountDataDataSourceAtDataBandShort: string;
                StiCrossGroupHeaderNotEqualToCrossGroupFooterOnPageLong: string;
                StiCrossGroupHeaderNotEqualToGroupCrossFooterOnContainerLong: string;
                StiDataSourcesForImageCheckLong: string;
                StiDataSourcesForImageCheckShort: string;
                StiEventsAtInterpretationCheckLong: string;
                StiEventsAtInterpretationCheckShort: string;
                StiExpressionElementCheckLong: string;
                StiExpressionElementCheckShort: string;
                StiFilterCircularDependencyElementCheckLong: string;
                StiFilterCircularDependencyElementCheckShort: string;
                StiFilterValueCheckLong: string;
                StiFilterValueCheckShort: string;
                StiFontMissingCheckLong: string;
                StiFontMissingCheckShort: string;
                StiFunctionsOnlyForEngineV2CheckLong: string;
                StiFunctionsOnlyForEngineV2CheckShort: string;
                StiGroupHeaderNotEqualToGroupFooterOnContainerLong: string;
                StiGroupHeaderNotEqualToGroupFooterOnPageLong: string;
                StiGroupHeaderNotEqualToGroupFooterShort: string;
                StiGrowToHeightOverlappingLong: string;
                StiGrowToHeightOverlappingShort: string;
                StiIsFirstPageIsLastPageDoublePassCheckLong: string;
                StiIsFirstPageIsLastPageDoublePassCheckShort: string;
                StiIsFirstPassIsSecondPassCheckLong: string;
                StiIsFirstPassIsSecondPassCheckShort: string;
                StiLargeHeightAtPageCheckLong: string;
                StiLargeHeightAtPageCheckShort: string;
                StiLocationOutsidePageCheckLong: string;
                StiLocationOutsidePageCheckShort: string;
                StiLocationOutsidePrintableAreaCheckLong: string;
                StiLocationOutsidePrintableAreaCheckShort: string;
                StiMinRowsInColumnsCheckLong: string;
                StiMinRowsInColumnsCheckShort: string;
                StiNegativeSizesOfComponentsCheckLong: string;
                StiNegativeSizesOfComponentsCheckShort: string;
                StiNoConditionAtGroupCheckLong: string;
                StiNoConditionAtGroupCheckShort: string;
                StiNoNameComponentCheckLong: string;
                StiNoNameComponentCheckShort: string;
                StiNoNamePageCheckLong: string;
                StiNoNamePageCheckShort: string;
                StiPanelInEngineV1CheckLong: string;
                StiPanelInEngineV1CheckShort: string;
                StiPrintHeadersAndFootersFromPreviousPageLong: string;
                StiPrintHeadersAndFootersFromPreviousPageShort: string;
                StiPrintOnDoublePassCheckLong: string;
                StiPrintOnDoublePassCheckShort: string;
                StiPrintOnPreviousPageCheck2Long: string;
                StiPrintOnPreviousPageCheck2Short: string;
                StiPrintOnPreviousPageCheckLong: string;
                StiPrintOnPreviousPageCheckShort: string;
                StiPropertiesOnlyEngineV1CheckLong: string;
                StiPropertiesOnlyEngineV1CheckShort: string;
                StiPropertiesOnlyEngineV2CheckLong: string;
                StiPropertiesOnlyEngineV2CheckShort: string;
                StiResetPageNumberCheckLong: string;
                StiResetPageNumberCheckShort: string;
                StiShowInsteadNullValuesCheckLong: string;
                StiShowInsteadNullValuesCheckShort: string;
                StiSubReportPageZeroCheckLong: string;
                StiSubReportPageZeroCheckShort: string;
                StiSystemTextObsoleteCheckLong: string;
                StiSystemTextObsoleteCheckShort: string;
                StiTextColorEqualToBackColorCheckLong: string;
                StiTextColorEqualToBackColorCheckShort: string;
                StiTextTextFormatCheckLong: string;
                StiTextTextFormatCheckShort: string;
                StiTotalPageCountDoublePassCheckLong: string;
                StiUndefinedComponentCheckLong: string;
                StiUndefinedComponentCheckShort: string;
                StiVerySmallSizesOfComponentsCheckLong: string;
                StiVerySmallSizesOfComponentsCheckShort: string;
                StiWidthHeightZeroComponentCheckLongHeight: string;
                StiWidthHeightZeroComponentCheckLongWidth: string;
                StiWidthHeightZeroComponentCheckLongWidthHeight: string;
                StiWidthHeightZeroComponentCheckShortHeight: string;
                StiWidthHeightZeroComponentCheckShortWidth: string;
                StiWidthHeightZeroComponentCheckShortWidthHeight: string;
                StiWordWrapCanGrowTextDoesNotFitLong: string;
                StiWordWrapCanGrowTextDoesNotFitShort: string;
            };
            CheckConnection: {
                StiUndefinedConnectionCheckLong: string;
                StiUndefinedConnectionCheckShort: string;
                StiUnsupportedConnectionCheckLong: string;
                StiUnsupportedConnectionCheckShort: string;
            };
            CheckDataRelation: {
                StiDifferentAmountOfKeysInDataRelationCheckLong: string;
                StiDifferentAmountOfKeysInDataRelationCheckShort: string;
                StiKeysInAbsentDataRelationCheckLong: string;
                StiKeysInAbsentDataRelationCheckShort: string;
                StiKeysNotFoundRelationCheckLong: string;
                StiKeysNotFoundRelationCheckShort: string;
                StiKeysTypesMismatchDataRelationCheckLong: string;
                StiKeysTypesMismatchDataRelationCheckShort: string;
                StiNoNameDataRelationCheckLong: string;
                StiNoNameDataRelationCheckShort: string;
                StiNoNameInSourceDataRelationCheckLong: string;
                StiNoNameInSourceDataRelationCheckShort: string;
                StiSourcesInAbsentDataRelationCheckLong: string;
                StiSourcesInAbsentDataRelationCheckShort: string;
            };
            CheckDataSource: {
                StiCalculatedColumnRecursionCheckLong: string;
                StiCalculatedColumnRecursionCheckShort: string;
                StiNoNameDataSourceCheckLong: string;
                StiNoNameDataSourceCheckShort: string;
                StiNoNameInSourceDataSourceCheckLong: string;
                StiNoNameInSourceDataSourceCheckShort: string;
                StiUndefinedDataSourceCheckLong: string;
                StiUndefinedDataSourceCheckShort: string;
            };
            CheckGlobal: {
                Error: string;
                Information: string;
                RenderingMessage: string;
                Warning: string;
            };
            CheckLicense: {
                StiLicenseTrialCheckLong: string;
                StiValidSubscriptioRequiredCheckLong: string;
            };
            CheckPage: {
                StiLostPointsOnPageCheckLong: string;
                StiLostPointsOnPageCheckShort: string;
                StiOrientationPageCheckLongLandscape: string;
                StiOrientationPageCheckLongPortrait: string;
                StiOrientationPageCheckShort: string;
            };
            CheckReport: {
                StiCloudCompilationModeCheckLong: string;
                StiCloudCompilationModeCheckShort: string;
                StiCompilationErrorAssemblyCheckLong: string;
                StiCompilationErrorCheck2Long: string;
                StiCompilationErrorCheck3Long: string;
                StiCompilationErrorCheckLong: string;
                StiCompilationErrorCheckShort: string;
                StiDuplicatedName2CheckLong: string;
                StiDuplicatedNameCheckLong: string;
                StiDuplicatedNameCheckShort: string;
                StiDuplicatedNameInSourceInDataRelationReportCheckLong: string;
                StiDuplicatedNameInSourceInDataRelationReportCheckShort: string;
                StiDuplicatedReportName2CheckLong: string;
                StiDuplicatedReportNameCheckLong: string;
                StiNetCoreCompilationModeCheckLong: string;
                StiNetCoreCompilationModeCheckShort: string;
            };
            CheckVariable: {
                StiVariableInitializationCheckLong: string;
                StiVariableInitializationCheckShort: string;
                StiVariableRecursionCheckLong: string;
                StiVariableRecursionCheckShort: string;
                StiVariableTypeCheckLong: string;
                StiVariableTypeCheckShort: string;
            };
            Font: {
                Bold: string;
                Italic: string;
                Name: string;
                Size: string;
                Strikeout: string;
                Underline: string;
            };
            Publish: {
                ActionDesign: string;
                ActionExport: string;
                ActionShow: string;
                AddNewConnection: string;
                Cancel: string;
                Close: string;
                ConnectionsFromReport: string;
                ConnectionsFromReportToolTip: string;
                ConnectionsRegData: string;
                ConnectionsRegDataToolTip: string;
                ConnectionsReplace: string;
                ConnectionsReplaceToolTip: string;
                Copy: string;
                CopyingLibraries: string;
                DeployReportPlatform: string;
                DownloadingLibraries: string;
                EmbedAllDataToResources: string;
                EmbedAllDataToResourcesToolTip: string;
                ExportFormat: string;
                ExportFormatData: string;
                ExportFormatDataType: string;
                ExportFormatImage: string;
                ExportFormatImageType: string;
                FullScreenViewer: string;
                FullScreenViewerToolTip: string;
                GetLibrariesFrom: string;
                GetLibrariesFromToolTip: string;
                GroupAddons: string;
                GroupConnections: string;
                GroupParameters: string;
                HideOptions: string;
                IncludeFonts: string;
                IncludeFontsToolTip: string;
                IncludeLibrariesToStandalone: string;
                IncludeLibrariesToStandaloneToolTip: string;
                IncludeLicenseKey: string;
                IncludeLicenseKeyToolTip: string;
                IncludeLocalization: string;
                IncludeLocalizationToolTip: string;
                IncludeReportPackedStringToCode: string;
                IncludeReportPackedStringToCodeToolTip: string;
                IncludeUITheme: string;
                IncludeUIThemeToolTip: string;
                JavaScriptFramework: string;
                LicenseKeyTypeFile: string;
                LicenseKeyTypeString: string;
                LoadReport: string;
                LoadReportAssembly: string;
                LoadReportByteArray: string;
                LoadReportClass: string;
                LoadReportFile: string;
                LoadReportHyperlink: string;
                LoadReportResource: string;
                LoadReportStream: string;
                LoadReportString: string;
                ParametersFromReport: string;
                ParametersFromReportToolTip: string;
                ParametersReplace: string;
                ParametersReplacePhpInfo: string;
                ParametersReplaceToolTip: string;
                ParametersRequestFromUser: string;
                ParametersRequestFromUserToolTip: string;
                Publish: string;
                PublishType: string;
                PublishTypeProject: string;
                PublishTypeProjectToolTip: string;
                PublishTypeStandalone: string;
                PublishTypeStandaloneToolTip: string;
                ReadMore: string;
                RegDataOnlyForPreview: string;
                RegDataOnlyForPreviewToolTip: string;
                RegDataSynchronize: string;
                RegDataSynchronizeToolTip: string;
                ReplaceConnectionString: string;
                ReplacePathToData: string;
                ReportAction: string;
                ReportErrors: string;
                SaveProjectPackage: string;
                SaveStandalone: string;
                SaveStandalonePackage: string;
                SearchLibraries: string;
                ShowMore: string;
                ShowOptions: string;
                ThemeBackground: string;
                ThemeStyle: string;
                TrialVersion: string;
                Use: string;
                UseCompilationCache: string;
                UseCompilationCacheToolTip: string;
                UseCompressedScripts: string;
                UseCompressedScriptsToolTip: string;
                UseLatestVersion: string;
                UseLatestVersionToolTip: string;
                UseWpfDesignerV2: string;
                UseWpfDesignerV2ToolTip: string;
            };
            ReportComparer: {
                Change: string;
                Copy: string;
                CopyAll: string;
                Delete: string;
                SaveChangesInReports: string;
                StiBusinessObjectDifferentColumnCompareComment: string;
                StiBusinessObjectDifferentColumnCompareLong: string;
                StiBusinessObjectDifferentColumnCompareShort: string;
                StiBusinessObjectPropertiesCompareComment: string;
                StiBusinessObjectPropertiesCompareLong: string;
                StiBusinessObjectPropertiesCompareShort: string;
                StiChangeInReportPropertyActionDescription: string;
                StiComponentPropertiesCompareComment: string;
                StiComponentPropertiesCompareLong: string;
                StiComponentPropertiesCompareShort: string;
                StiCopyAllActionDescription: string;
                StiCopyBusinessDataColumnActionsDescription: string;
                StiCopyBusinessObjectActionDescription: string;
                StiCopyComponentActionDescription: string;
                StiCopyDataColumnActionDescription: string;
                StiCopyDataRelationActionDescription: string;
                StiCopyDataSourceActionDescription: string;
                StiCopyStyleActionDescription: string;
                StiCopyVariableActionDescription: string;
                StiDataRelationPropertiesCompareComment: string;
                StiDataRelationPropertiesCompareLong: string;
                StiDataRelationPropertiesCompareShort: string;
                StiDataSourceDifferentColumnCompareComment: string;
                StiDataSourceDifferentColumnCompareLong: string;
                StiDataSourceDifferentColumnCompareShort: string;
                StiDataSourcePropertiesCompareComment: string;
                StiDataSourcePropertiesCompareLong: string;
                StiDataSourcePropertiesCompareShort: string;
                StiDeleteBusinessDataColumnActionsDescription: string;
                StiDeleteBusinessObjectActionDescription: string;
                StiDeleteComponentActionDescription: string;
                StiDeleteDataColumnActionDescription: string;
                StiDeleteDataRelationActionDescription: string;
                StiDeleteDataSourceActionDescription: string;
                StiDeleteStyleActionDescription: string;
                StiDeleteVariableActionDescription: string;
                StiReportDifferentBusinessObjectCompareComment: string;
                StiReportDifferentBusinessObjectCompareLong: string;
                StiReportDifferentBusinessObjectCompareShort: string;
                StiReportDifferentComponentsCompareComment: string;
                StiReportDifferentComponentsCompareLong: string;
                StiReportDifferentComponentsCompareMessag1: string;
                StiReportDifferentComponentsCompareMessag2: string;
                StiReportDifferentComponentsCompareShort: string;
                StiReportDifferentDataRelationCompareComment: string;
                StiReportDifferentDataRelationCompareLong: string;
                StiReportDifferentDataRelationCompareShort: string;
                StiReportDifferentDataSourceCompareComment: string;
                StiReportDifferentDataSourceCompareLong: string;
                StiReportDifferentDataSourceCompareShort: string;
                StiReportDifferentStyleCompareComment: string;
                StiReportDifferentStyleCompareLong: string;
                StiReportDifferentStyleCompareShort: string;
                StiReportDifferentVariableCompareComment: string;
                StiReportDifferentVariableCompareLong: string;
                StiReportDifferentVariableCompareShort: string;
                StiReportPropertiesCompareComment: string;
                StiReportPropertiesCompareLong: string;
                StiReportPropertiesCompareShort: string;
                StiStylePropertiesCompareComment: string;
                StiStylePropertiesCompareLong: string;
                StiStylePropertiesCompareShort: string;
                StiVariablePropertiesCompareComment: string;
                StiVariablePropertiesCompareLong: string;
                StiVariablePropertiesCompareShort: string;
            };
            ReportComparerViewer: {
                Browse: string;
                BusinessObjects: string;
                BusinessObjectsDataColumns: string;
                Cancel: string;
                Compare: string;
                CompareList: string;
                CompareReports: string;
                Compares: string;
                Components: string;
                DataRelations: string;
                DataSources: string;
                DataSourcesDataColumns: string;
                EnterPassword: string;
                FirstReport: string;
                LongMessage: string;
                Next: string;
                OK: string;
                OpenReports: string;
                Previous: string;
                Report: string;
                ReportToCompare: string;
                SaveReports: string;
                SecondReport: string;
                SelectReports: string;
                StatusHigh: string;
                StatusLow: string;
                StatusMiddle: string;
                Styles: string;
                Variables: string;
                WarningFile1EqualFile2: string;
                WarningFirstAndSecondReportNotFound: string;
                WarningFirstReportNotFound: string;
                WarningSecondReportNotFound: string;
            };
            StiAdvancedBorder: {
                BottomSide: string;
                LeftSide: string;
                RightSide: string;
                TopSide: string;
            };
            StiArea: {
                BorderColor: string;
                Brush: string;
                ColorEach: string;
                GridLinesHor: string;
                GridLinesHorRight: string;
                GridLinesVert: string;
                InterlacingHor: string;
                InterlacingVert: string;
                RadarStyle: string;
                ReverseHor: string;
                ReverseVert: string;
                ShowShadow: string;
                XAxis: string;
                XTopAxis: string;
                YAxis: string;
                YRightAxis: string;
            };
            StiAreaSeries: {
                Brush: string;
            };
            StiArrowShapeType: {
                ArrowHeight: string;
                ArrowWidth: string;
            };
            StiAustraliaPost4StateBarCodeType: {
                Height: string;
                Module: string;
            };
            StiAxis: {
                ArrowStyle: string;
                Interaction: string;
                Labels: string;
                LineColor: string;
                LineStyle: string;
                LineWidth: string;
                LogarithmicScale: string;
                Range: string;
                RangeScrollEnabled: string;
                ShowEdgeValues: string;
                ShowScrollBar: string;
                ShowXAxis: string;
                ShowYAxis: string;
                StartFromZero: string;
                Step: string;
                Ticks: string;
                Title: string;
                Visible: string;
            };
            StiAxisDateTimeStep: {
                Interpolation: string;
                NumberOfValues: string;
                Step: string;
            };
            StiAxisInteraction: {
                RangeScrollEnabled: string;
            };
            StiAxisLabels: {
                Angle: string;
                Antialiasing: string;
                Color: string;
                Font: string;
                Format: string;
                Placement: string;
                Step: string;
                TextAfter: string;
                TextAlignment: string;
                TextBefore: string;
                Width: string;
                WordWrap: string;
            };
            StiAxisRange: {
                Auto: string;
                Maximum: string;
                Minimum: string;
            };
            StiAxisTicks: {
                Length: string;
                LengthUnderLabels: string;
                MinorCount: string;
                MinorLength: string;
                MinorVisible: string;
                Step: string;
                Visible: string;
            };
            StiAxisTitle: {
                Alignment: string;
                Antialiasing: string;
                Color: string;
                Direction: string;
                Font: string;
                Position: string;
                Text: string;
            };
            StiBand: {
                MaxHeight: string;
                MinHeight: string;
                PrintOnEvenOddPages: string;
                ResetPageNumber: string;
                StartNewPage: string;
                StartNewPageIfLessThan: string;
            };
            StiBandInteraction: {
                Collapsed: string;
                CollapseGroupFooter: string;
                CollapsingEnabled: string;
                SelectionEnabled: string;
            };
            StiBarCode: {
                Angle: string;
                AutoScale: string;
                BackColor: string;
                BarCodeType: string;
                Code: string;
                Font: string;
                ForeColor: string;
                GetBarCodeEvent: string;
                ShowLabelText: string;
                ShowQuietZones: string;
                Zoom: string;
            };
            StiBarCodeTypeService: {
                AddClearZone: string;
                AspectRatio: string;
                AutoDataColumns: string;
                AutoDataRows: string;
                Checksum: string;
                CheckSum: string;
                CheckSum1: string;
                CheckSum2: string;
                DataColumns: string;
                DataRows: string;
                EncodingMode: string;
                EncodingType: string;
                ErrorsCorrectionLevel: string;
                Height: string;
                MatrixSize: string;
                Module: string;
                PrintVerticalBars: string;
                Ratio: string;
                RatioY: string;
                ShowQuietZoneIndicator: string;
                Space: string;
                SupplementCode: string;
                SupplementType: string;
                UseRectangularSymbols: string;
            };
            StiBaseStyle: {
                AllowUseBackColor: string;
                AllowUseBorderFormatting: string;
                AllowUseBorderSides: string;
                AllowUseBorderSidesFromLocation: string;
                AllowUseBrush: string;
                AllowUseFont: string;
                AllowUseForeColor: string;
                AllowUseHorAlignment: string;
                AllowUseImage: string;
                AllowUseTextBrush: string;
                AllowUseTextOptions: string;
                AllowUseVertAlignment: string;
                AxisLabelsColor: string;
                AxisLineColor: string;
                AxisTitleColor: string;
                BackColor: string;
                BasicStyleColor: string;
                Border: string;
                Brush: string;
                BrushType: string;
                ChartAreaBorderColor: string;
                ChartAreaBrush: string;
                CollectionName: string;
                Color: string;
                Conditions: string;
                Description: string;
                Font: string;
                ForeColor: string;
                GridLinesHorColor: string;
                GridLinesVertColor: string;
                HorAlignment: string;
                Image: string;
                InterlacingHorBrush: string;
                InterlacingVertBrush: string;
                LegendBorderColor: string;
                LegendBrush: string;
                LegendLabelsColor: string;
                LegendTitleColor: string;
                Name: string;
                SeriesLabelsBorderColor: string;
                SeriesLabelsBrush: string;
                SeriesLabelsColor: string;
                StyleColors: string;
                TextBrush: string;
                VertAlignment: string;
            };
            StiBorder: {
                Color: string;
                DropShadow: string;
                ShadowBrush: string;
                ShadowSize: string;
                Side: string;
                Size: string;
                Style: string;
                Topmost: string;
            };
            StiBorderSide: {
                Color: string;
                Size: string;
                Style: string;
            };
            StiBusinessObject: {
                Alias: string;
                Category: string;
                Columns: string;
                Name: string;
            };
            StiButtonControl: {
                Cancel: string;
                Default: string;
                DialogResult: string;
                Image: string;
                ImageAlign: string;
                Text: string;
                TextAlign: string;
            };
            StiCandlestickSeries: {
                ListOfValuesClose: string;
                ListOfValuesHigh: string;
                ListOfValuesLow: string;
                ListOfValuesOpen: string;
                ValueClose: string;
                ValueDataColumnClose: string;
                ValueDataColumnHigh: string;
                ValueDataColumnLow: string;
                ValueDataColumnOpen: string;
                ValueHigh: string;
                ValueLow: string;
                ValueOpen: string;
            };
            StiCap: {
                Color: string;
                Fill: string;
                Height: string;
                Style: string;
                Width: string;
            };
            StiChart: {
                Area: string;
                ChartType: string;
                ConstantLines: string;
                HorSpacing: string;
                Legend: string;
                ProcessAtEnd: string;
                ProcessChartEvent: string;
                Rotation: string;
                Series: string;
                SeriesLabels: string;
                Strips: string;
                Style: string;
                Table: string;
                Title: string;
                VertSpacing: string;
            };
            StiChartArea: {
                ColorEach: string;
                GridLinesHor: string;
                GridLinesVert: string;
                InterlacingHor: string;
                InterlacingVert: string;
                ReverseHor: string;
                ReverseVert: string;
                XAxis: string;
                XTopAxis: string;
                YAxis: string;
                YRightAxis: string;
            };
            StiChartAxis: {
                Visible: string;
            };
            StiChartAxisLabels: {
                Angle: string;
                Color: string;
                Font: string;
                Placement: string;
                Step: string;
                TextAfter: string;
                TextAlignment: string;
                TextBefore: string;
            };
            StiChartAxisRange: {
                Auto: string;
                Maximum: string;
                Minimum: string;
            };
            StiChartAxisTitle: {
                Alignment: string;
                Color: string;
                Font: string;
                Position: string;
                Text: string;
                Visible: string;
            };
            StiChartElement: {
                Area: string;
                Arguments: string;
                CloseValues: string;
                ColorEach: string;
                ConstantLines: string;
                EndValues: string;
                Group: string;
                HighValues: string;
                Labels: string;
                Legend: string;
                LowValues: string;
                Series: string;
                Style: string;
                TextFormat: string;
                Title: string;
                TrendLines: string;
                Values: string;
                Weights: string;
            };
            StiChartGridLines: {
                Color: string;
            };
            StiChartInterlacing: {
                Color: string;
                Visible: string;
            };
            StiChartLabels: {
                AutoRotate: string;
                Font: string;
                ForeColor: string;
                Position: string;
                Style: string;
                TextAfter: string;
                TextBefore: string;
            };
            StiChartLegend: {
                Columns: string;
                Direction: string;
                HorAlignment: string;
                VertAlignment: string;
                Visible: string;
            };
            StiChartLegendLabels: {
                Color: string;
                Font: string;
            };
            StiChartLegendTitle: {
                Color: string;
                Font: string;
                Text: string;
            };
            StiChartTable: {
                Font: string;
                GridLineColor: string;
                GridLinesHor: string;
                GridLinesVert: string;
                GridOutline: string;
                MarkerVisible: string;
                NegativeSeriesColors: string;
                SeriesColors: string;
                Visible: string;
            };
            StiChartTitle: {
                Alignment: string;
                Antialiasing: string;
                Brush: string;
                Dock: string;
                Font: string;
                Spacing: string;
                Text: string;
                Visible: string;
            };
            StiCheckBox: {
                Checked: string;
                CheckStyleForFalse: string;
                CheckStyleForTrue: string;
                ContourColor: string;
                ExcelValue: string;
                GetCheckedEvent: string;
                Size: string;
                Values: string;
            };
            StiCheckBoxControl: {
                Checked: string;
                CheckedBinding: string;
                CheckedChangedEvent: string;
                Text: string;
                TextBinding: string;
            };
            StiCheckedListBoxControl: {
                CheckOnClick: string;
                ItemHeight: string;
                Items: string;
                ItemsBinding: string;
                SelectedIndexBinding: string;
                SelectedIndexChangedEvent: string;
                SelectedItemBinding: string;
                SelectedValueBinding: string;
                SelectionMode: string;
                Sorted: string;
            };
            StiChildBand: {
                KeepChildTogether: string;
                PrintIfParentDisabled: string;
            };
            StiClone: {
                Container: string;
                ScaleHor: string;
            };
            StiClusteredColumnSeries: {
                Width: string;
            };
            StiCodabarBarCodeType: {
                Height: string;
                Module: string;
                Ratio: string;
            };
            StiCode11BarCodeType: {
                Checksum: string;
                Height: string;
                Module: string;
            };
            StiCode128aBarCodeType: {
                Height: string;
                Module: string;
            };
            StiCode128AutoBarCodeType: {
                Height: string;
                Module: string;
            };
            StiCode128BarCodeType: {
                Height: string;
                Module: string;
            };
            StiCode128bBarCodeType: {
                Height: string;
                Module: string;
            };
            StiCode128cBarCodeType: {
                Height: string;
                Module: string;
            };
            StiCode39BarCodeType: {
                CheckSum: string;
                Height: string;
                Module: string;
                Ratio: string;
            };
            StiCode39ExtBarCodeType: {
                CheckSum: string;
                Height: string;
                Module: string;
                Ratio: string;
            };
            StiCode93BarCodeType: {
                Height: string;
                Module: string;
                Ratio: string;
            };
            StiCode93ExtBarCodeType: {
                Height: string;
                Module: string;
                Ratio: string;
            };
            StiColumnSize: {
                MaxWidth: string;
                MinWidth: string;
                Width: string;
            };
            StiComboBoxControl: {
                DropDownStyle: string;
                DropDownWidth: string;
                ItemHeight: string;
                Items: string;
                ItemsBinding: string;
                MaxDropDownItems: string;
                MaxLength: string;
                SelectedIndexChangedEvent: string;
                SelectedItemBinding: string;
                SelectedValueBinding: string;
                Sorted: string;
                Text: string;
                TextBinding: string;
            };
            StiComponent: {
                AfterPrintEvent: string;
                Alias: string;
                Anchor: string;
                BeforePrintEvent: string;
                Bookmark: string;
                Border: string;
                Brush: string;
                BusinessObject: string;
                CanBreak: string;
                CanGrow: string;
                CanShrink: string;
                CellDockStyle: string;
                CellType: string;
                CheckedChangedEvent: string;
                ClickEvent: string;
                ComponentStyle: string;
                Conditions: string;
                CountData: string;
                CrossFiltering: string;
                DataRelation: string;
                DataSource: string;
                DockStyle: string;
                DoubleClickEvent: string;
                Editable: string;
                Enabled: string;
                ExceedMargins: string;
                FilterMode: string;
                FilterOn: string;
                Filters: string;
                FixedWidth: string;
                GetBookmarkEvent: string;
                GetDrillDownReportEvent: string;
                GetHyperlinkEvent: string;
                GetTagEvent: string;
                GetToolTipEvent: string;
                GrowToHeight: string;
                Height: string;
                HorAlignment: string;
                Hyperlink: string;
                Interaction: string;
                Left: string;
                Linked: string;
                Locked: string;
                MasterComponent: string;
                MaxSize: string;
                MinSize: string;
                MouseEnterEvent: string;
                MouseLeaveEvent: string;
                Name: string;
                Printable: string;
                PrintOn: string;
                Restrictions: string;
                ShiftMode: string;
                Sort: string;
                Tag: string;
                TextBrush: string;
                ToolTip: string;
                Top: string;
                TotalLabel: string;
                UseParentStyles: string;
                VertAlignment: string;
                Width: string;
            };
            StiConstantLines: {
                Antialiasing: string;
                AxisValue: string;
                Font: string;
                LineColor: string;
                LineStyle: string;
                LineWidth: string;
                Orientation: string;
                Position: string;
                ShowBehind: string;
                ShowInLegend: string;
                Text: string;
                TitleVisible: string;
                Visible: string;
            };
            StiCrossDataBand: {
                MaxWidth: string;
                MinWidth: string;
            };
            StiCrossField: {
                DisplayValue: string;
                EnumeratorSeparator: string;
                EnumeratorType: string;
                GetCrossValueEvent: string;
                GetDisplayCrossValueEvent: string;
                HideZeros: string;
                KeepMergedCellsTogether: string;
                MergeHeaders: string;
                PrintOnAllPages: string;
                ShowPercents: string;
                ShowTotal: string;
                SortDirection: string;
                SortType: string;
                Summary: string;
                SummaryValues: string;
                UseStyleOfSummaryInColumnTotal: string;
                UseStyleOfSummaryInRowTotal: string;
                Value: string;
            };
            StiCrossFooterBand: {
                MaxWidth: string;
                MinWidth: string;
            };
            StiCrossGroupFooterBand: {
                MaxWidth: string;
                MinWidth: string;
            };
            StiCrossGroupHeaderBand: {
                MaxWidth: string;
                MinWidth: string;
            };
            StiCrossHeaderBand: {
                MaxWidth: string;
                MinWidth: string;
            };
            StiCrossTab: {
                EmptyValue: string;
                HorAlignment: string;
                KeepCrossTabTogether: string;
                PrintIfEmpty: string;
                RightToLeft: string;
                Wrap: string;
                WrapGap: string;
            };
            StiDataBand: {
                BeginRenderEvent: string;
                CalcInvisible: string;
                ColumnDirection: string;
                ColumnGaps: string;
                Columns: string;
                ColumnWidth: string;
                EndRenderEvent: string;
                EvenStyle: string;
                FilterEngine: string;
                FilterMode: string;
                GetCollapsedEvent: string;
                KeepChildTogether: string;
                KeepDetailsTogether: string;
                KeepFooterTogether: string;
                KeepGroupTogether: string;
                KeepHeaderTogether: string;
                MinRowsInColumn: string;
                OddStyle: string;
                PrintIfDetailEmpty: string;
                PrintOnAllPages: string;
                RenderingEvent: string;
                ResetDataSource: string;
                RightToLeft: string;
            };
            StiDatabase: {
                Alias: string;
                ConnectedEvent: string;
                ConnectingEvent: string;
                ConnectionString: string;
                DisconnectedEvent: string;
                DisconnectingEvent: string;
                Name: string;
                PathData: string;
                PathSchema: string;
                PromptUserNameAndPassword: string;
            };
            StiDataColumn: {
                Alias: string;
                Expression: string;
                Name: string;
                NameInSource: string;
                Type: string;
            };
            StiDataMatrixBarCodeType: {
                EncodingType: string;
                Height: string;
                MatrixSize: string;
                Module: string;
                UseRectangularSymbols: string;
            };
            StiDataParameter: {
                Alias: string;
                Expression: string;
                Name: string;
                Size: string;
                Type: string;
            };
            StiDataRelation: {
                Alias: string;
                ChildColumns: string;
                ChildSource: string;
                Name: string;
                NameInSource: string;
                ParentColumns: string;
                ParentSource: string;
            };
            StiDataSource: {
                Alias: string;
                AllowExpressions: string;
                CodePage: string;
                Columns: string;
                CommandTimeout: string;
                ConnectionOrder: string;
                ConnectOnStart: string;
                Name: string;
                NameInSource: string;
                Parameters: string;
                Path: string;
                ReconnectOnEachRow: string;
                SqlCommand: string;
                Type: string;
            };
            StiDateTimePickerControl: {
                CustomFormat: string;
                DropDownAlign: string;
                Format: string;
                MaxDate: string;
                MaxDateBinding: string;
                MinDate: string;
                MinDateBinding: string;
                ShowUpDown: string;
                Today: string;
                Value: string;
                ValueBinding: string;
                ValueChangedEvent: string;
            };
            StiDialogStyle: {
                GlyphColor: string;
                HotBackColor: string;
                HotForeColor: string;
                HotGlyphColor: string;
                HotSelectedBackColor: string;
                HotSelectedForeColor: string;
                HotSelectedGlyphColor: string;
                SelectedBackColor: string;
                SelectedForeColor: string;
                SelectedGlyphColor: string;
                SeparatorColor: string;
            };
            StiDoughnutSeries: {
                Diameter: string;
            };
            StiDrillDownParameter: {
                Expression: string;
                Name: string;
            };
            StiDutchKIXBarCodeType: {
                Height: string;
                Module: string;
            };
            StiDynamicBand: {
                BreakIfLessThan: string;
                NewColumnAfter: string;
                NewColumnBefore: string;
                NewPageAfter: string;
                NewPageBefore: string;
                PrintAtBottom: string;
                SkipFirst: string;
            };
            StiEAN128aBarCodeType: {
                Height: string;
                Module: string;
            };
            StiEAN128AutoBarCodeType: {
                Height: string;
                Module: string;
            };
            StiEAN128bBarCodeType: {
                Height: string;
                Module: string;
            };
            StiEAN128cBarCodeType: {
                Height: string;
                Module: string;
            };
            StiEAN13BarCodeType: {
                Height: string;
                Module: string;
                ShowQuietZoneIndicator: string;
                SupplementCode: string;
                SupplementType: string;
            };
            StiEAN8BarCodeType: {
                Height: string;
                Module: string;
                ShowQuietZoneIndicator: string;
                SupplementCode: string;
                SupplementType: string;
            };
            StiElement: {
                BackColor: string;
                Margin: string;
                Padding: string;
            };
            StiEmptyBand: {
                BeginRenderEvent: string;
                EndRenderEvent: string;
                EvenStyle: string;
                OddStyle: string;
                RenderingEvent: string;
                SizeMode: string;
            };
            StiFIMBarCodeType: {
                AddClearZone: string;
                Height: string;
                Module: string;
            };
            StiFooterBand: {
                KeepFooterTogether: string;
                PrintIfEmpty: string;
                PrintOnAllPages: string;
            };
            StiForm: {
                BackColor: string;
                ClickEvent: string;
                ClosedFormEvent: string;
                ClosingFormEvent: string;
                Font: string;
                LoadFormEvent: string;
                Location: string;
                RightToLeft: string;
                Size: string;
                StartMode: string;
                StartPosition: string;
                Text: string;
                Visible: string;
                WindowState: string;
            };
            StiGanttSeries: {
                GetListOfValuesEndEvent: string;
                GetValueEndEvent: string;
                ListOfValues: string;
                ListOfValuesEnd: string;
                Value: string;
                ValueDataColumn: string;
                ValueDataColumnEnd: string;
                ValueEnd: string;
            };
            StiGaugeElement: {
                Font: string;
                ForeColor: string;
                Series: string;
                Style: string;
                Title: string;
            };
            StiGaugeStyle: {
                BorderColor: string;
                BorderWidth: string;
                Brush: string;
                ForeColor: string;
                LinearBarBorderBrush: string;
                LinearBarBrush: string;
                LinearBarEmptyBorderBrush: string;
                LinearBarEmptyBrush: string;
                LinearScaleBrush: string;
                MarkerBrush: string;
                NeedleBorderBrush: string;
                NeedleBorderWidth: string;
                NeedleBrush: string;
                NeedleCapBorderBrush: string;
                NeedleCapBrush: string;
                RadialBarBorderBrush: string;
                RadialBarBrush: string;
                RadialBarEmptyBorderBrush: string;
                RadialBarEmptyBrush: string;
                TargetColor: string;
                TickLabelMajorFont: string;
                TickLabelMajorTextBrush: string;
                TickLabelMinorFont: string;
                TickLabelMinorTextBrush: string;
                TickMarkMajorBorder: string;
                TickMarkMajorBorderWidth: string;
                TickMarkMajorBrush: string;
                TickMarkMinorBorder: string;
                TickMarkMinorBorderWidth: string;
                TickMarkMinorBrush: string;
            };
            StiGlareBrush: {
                Angle: string;
                EndColor: string;
                Focus: string;
                Scale: string;
                StartColor: string;
            };
            StiGlassBrush: {
                Blend: string;
                Color: string;
                DrawHatch: string;
            };
            StiGradientBrush: {
                Angle: string;
                EndColor: string;
                StartColor: string;
            };
            StiGridColumn: {
                Alignment: string;
                DataTextField: string;
                HeaderText: string;
                NullText: string;
                Visible: string;
                Width: string;
            };
            StiGridControl: {
                AlternatingBackColor: string;
                BackColor: string;
                BackgroundColor: string;
                ColumnHeadersVisible: string;
                Columns: string;
                Filter: string;
                ForeColor: string;
                GridLineColor: string;
                GridLineStyle: string;
                HeaderBackColor: string;
                HeaderFont: string;
                HeaderForeColor: string;
                PositionChangedEvent: string;
                PreferredColumnWidth: string;
                PreferredRowHeight: string;
                RowHeadersVisible: string;
                RowHeaderWidth: string;
                SelectionBackColor: string;
                SelectionForeColor: string;
            };
            StiGridLines: {
                Color: string;
                MinorColor: string;
                MinorCount: string;
                MinorStyle: string;
                MinorVisible: string;
                Style: string;
                Visible: string;
            };
            StiGroupBoxControl: {
                Text: string;
                TextBinding: string;
            };
            StiGroupFooterBand: {
                KeepGroupFooterTogether: string;
            };
            StiGroupHeaderBand: {
                BeginRenderEvent: string;
                Condition: string;
                EndRenderEvent: string;
                GetCollapsedEvent: string;
                GetSummaryExpressionEvent: string;
                GetValueEvent: string;
                KeepGroupHeaderTogether: string;
                KeepGroupTogether: string;
                PrintOnAllPages: string;
                RenderingEvent: string;
                SortDirection: string;
                SummaryExpression: string;
                SummarySortDirection: string;
                SummaryType: string;
            };
            StiHatchBrush: {
                BackColor: string;
                ForeColor: string;
                Style: string;
            };
            StiHeaderBand: {
                KeepHeaderTogether: string;
                PrintIfEmpty: string;
                PrintOnAllPages: string;
            };
            StiHierarchicalBand: {
                Footers: string;
                Headers: string;
                Indent: string;
                KeyDataColumn: string;
                MasterKeyDataColumn: string;
                ParentValue: string;
            };
            StiHorChartGridLines: {
                Visible: string;
            };
            StiImage: {
                DataColumn: string;
                File: string;
                GetImageDataEvent: string;
                GetImageURLEvent: string;
                GlobalizedName: string;
                Image: string;
                ImageData: string;
                ImageRotation: string;
                ImageURL: string;
                ProcessingDuplicates: string;
            };
            StiInteraction: {
                AllowSeries: string;
                AllowSeriesElements: string;
                Bookmark: string;
                DrillDownEnabled: string;
                DrillDownMode: string;
                DrillDownPage: string;
                DrillDownParameter1: string;
                DrillDownParameter2: string;
                DrillDownParameter3: string;
                DrillDownParameter4: string;
                DrillDownParameter5: string;
                DrillDownReport: string;
                Hyperlink: string;
                SortingColumn: string;
                SortingEnabled: string;
                Tag: string;
                ToolTip: string;
            };
            StiInterlacing: {
                InterlacedBrush: string;
                Visible: string;
            };
            StiInterleaved2of5BarCodeType: {
                Height: string;
                Module: string;
                Ratio: string;
            };
            StiIsbn10BarCodeType: {
                Height: string;
                Module: string;
                ShowQuietZoneIndicator: string;
                SupplementCode: string;
                SupplementType: string;
            };
            StiIsbn13BarCodeType: {
                Height: string;
                Module: string;
                ShowQuietZoneIndicator: string;
                SupplementCode: string;
                SupplementType: string;
            };
            StiITF14BarCodeType: {
                Height: string;
                Module: string;
                PrintVerticalBars: string;
                Ratio: string;
            };
            StiJan13BarCodeType: {
                Height: string;
                Module: string;
                ShowQuietZoneIndicator: string;
                SupplementCode: string;
                SupplementType: string;
            };
            StiJan8BarCodeType: {
                Height: string;
                Module: string;
                ShowQuietZoneIndicator: string;
                SupplementCode: string;
                SupplementType: string;
            };
            StiLabelControl: {
                Text: string;
                TextAlign: string;
                TextBinding: string;
            };
            StiLegend: {
                BorderColor: string;
                Brush: string;
                Columns: string;
                Direction: string;
                Font: string;
                HideSeriesWithEmptyTitle: string;
                HorAlignment: string;
                HorSpacing: string;
                LabelsColor: string;
                MarkerAlignment: string;
                MarkerBorder: string;
                MarkerSize: string;
                MarkerVisible: string;
                ShowShadow: string;
                Size: string;
                Title: string;
                TitleColor: string;
                TitleFont: string;
                VertAlignment: string;
                VertSpacing: string;
                Visible: string;
            };
            StiLinePrimitive: {
                Color: string;
                EndCap: string;
                Size: string;
                StartCap: string;
                Style: string;
            };
            StiListBoxControl: {
                ItemHeight: string;
                Items: string;
                ItemsBinding: string;
                SelectedIndexBinding: string;
                SelectedIndexChangedEvent: string;
                SelectedItemBinding: string;
                SelectedValueBinding: string;
                SelectionMode: string;
                Sorted: string;
            };
            StiListViewControl: {
                SelectedIndexChangedEvent: string;
            };
            StiLookUpBoxControl: {
                Keys: string;
                KeysBinding: string;
                SelectedKeyBinding: string;
            };
            StiMargin: {
                Bottom: string;
                Left: string;
                Right: string;
                Top: string;
            };
            StiMarker: {
                Angle: string;
                BorderColor: string;
                Brush: string;
                ShowInLegend: string;
                Size: string;
                Step: string;
                Type: string;
                Visible: string;
            };
            StiMsiBarCodeType: {
                CheckSum1: string;
                CheckSum2: string;
                Height: string;
                Module: string;
            };
            StiNumericUpDownControl: {
                Increment: string;
                Maximum: string;
                MaximumBinding: string;
                Minimum: string;
                MinimumBinding: string;
                Value: string;
                ValueBinding: string;
                ValueChangedEvent: string;
            };
            StiOutsidePieLabels: {
                LineLength: string;
            };
            StiPadding: {
                Bottom: string;
                Left: string;
                Right: string;
                Top: string;
            };
            StiPage: {
                BeginRenderEvent: string;
                ColumnBeginRenderEvent: string;
                ColumnEndRenderEvent: string;
                EndRenderEvent: string;
                ExcelSheet: string;
                GetExcelSheetEvent: string;
                Icon: string;
                LargeHeight: string;
                LargeHeightFactor: string;
                Margins: string;
                MirrorMargins: string;
                NumberOfCopies: string;
                Orientation: string;
                PageHeight: string;
                PageWidth: string;
                PaperSize: string;
                PaperSourceOfFirstPage: string;
                PaperSourceOfOtherPages: string;
                PrintHeadersFootersFromPreviousPage: string;
                PrintOnPreviousPage: string;
                RenderingEvent: string;
                ResetPageNumber: string;
                SegmentPerHeight: string;
                SegmentPerWidth: string;
                StopBeforePrint: string;
                StretchToPrintArea: string;
                TitleBeforeHeader: string;
                UnlimitedBreakable: string;
                UnlimitedHeight: string;
                UnlimitedWidth: string;
                Watermark: string;
            };
            StiPanel: {
                ColumnGaps: string;
                Columns: string;
                ColumnWidth: string;
                RightToLeft: string;
            };
            StiPanelControl: {
                BorderStyle: string;
            };
            StiPdf417BarCodeType: {
                AspectRatio: string;
                AutoDataColumns: string;
                AutoDataRows: string;
                DataColumns: string;
                DataRows: string;
                EncodingMode: string;
                ErrorsCorrectionLevel: string;
                Height: string;
                Module: string;
                RatioY: string;
            };
            StiPharmacodeBarCodeType: {
                Height: string;
                Module: string;
            };
            StiPictureBoxControl: {
                BorderStyle: string;
                Image: string;
                SizeMode: string;
                TransparentColor: string;
            };
            StiPieSeries: {
                AllowApplyBorderColor: string;
                AllowApplyBrush: string;
                CutPieList: string;
                Diameter: string;
                Distance: string;
                GetCutPieListEvent: string;
                StartAngle: string;
            };
            StiPlesseyBarCodeType: {
                CheckSum1: string;
                CheckSum2: string;
                Height: string;
                Module: string;
            };
            StiPostnetBarCodeType: {
                Height: string;
                Module: string;
                Space: string;
            };
            StiPrinterSettings: {
                Collate: string;
                Copies: string;
                Duplex: string;
                PrinterName: string;
                ShowDialog: string;
            };
            StiQRCodeBarCodeType: {
                ErrorCorrectionLevel: string;
                Height: string;
                MatrixSize: string;
                Module: string;
            };
            StiRadarAxis: {
                Visible: string;
            };
            StiRadarAxisLabels: {
                Brush: string;
                DrawBorder: string;
            };
            StiRadarGridLines: {
                Color: string;
                MinorColor: string;
                MinorCount: string;
                MinorStyle: string;
                MinorVisible: string;
                Style: string;
                Visible: string;
            };
            StiRadioButtonControl: {
                Checked: string;
                CheckedBinding: string;
                CheckedChangedEvent: string;
                Text: string;
                TextBinding: string;
            };
            StiRectanglePrimitive: {
                BottomSide: string;
                LeftSide: string;
                RightSide: string;
                TopSide: string;
            };
            StiReport: {
                AutoLocalizeReportOnRun: string;
                BeginRenderEvent: string;
                CacheAllData: string;
                CacheTotals: string;
                CalculationMode: string;
                Collate: string;
                ConvertNulls: string;
                EndRenderEvent: string;
                EngineVersion: string;
                GlobalizationStrings: string;
                NumberOfPass: string;
                ParametersOrientation: string;
                PreviewMode: string;
                PreviewSettings: string;
                PrinterSettings: string;
                ReferencedAssemblies: string;
                RenderingEvent: string;
                ReportAlias: string;
                ReportAuthor: string;
                ReportCacheMode: string;
                ReportDescription: string;
                ReportIcon: string;
                ReportImage: string;
                ReportName: string;
                ReportUnit: string;
                RequestParameters: string;
                ScriptLanguage: string;
                StopBeforePage: string;
                StoreImagesInResources: string;
                Styles: string;
            };
            StiReportControl: {
                BackColor: string;
                ClickEvent: string;
                DataBindings: string;
                DoubleClickEvent: string;
                Enabled: string;
                EnterEvent: string;
                Font: string;
                ForeColor: string;
                GetTagEvent: string;
                GetToolTipEvent: string;
                LeaveEvent: string;
                Location: string;
                MouseDownEvent: string;
                MouseEnterEvent: string;
                MouseLeaveEvent: string;
                MouseMoveEvent: string;
                MouseUpEvent: string;
                RightToLeft: string;
                Size: string;
                TagValueBinding: string;
                Visible: string;
            };
            StiReportSummaryBand: {
                KeepReportSummaryTogether: string;
                PrintIfEmpty: string;
            };
            StiReportTitleBand: {
                PrintIfEmpty: string;
            };
            StiRichText: {
                BackColor: string;
                DataColumn: string;
                DataUrl: string;
                DetectUrls: string;
                FullConvertExpression: string;
                Margins: string;
                WordWrap: string;
                Wysiwyg: string;
            };
            StiRichTextBoxControl: {
                Text: string;
            };
            StiRoundedRectanglePrimitive: {
                Round: string;
            };
            StiRoundedRectangleShapeType: {
                Round: string;
            };
            StiRoyalMail4StateBarCodeType: {
                CheckSum: string;
                Height: string;
                Module: string;
            };
            StiSeries: {
                AllowApplyBrushNegative: string;
                AllowApplyColorNegative: string;
                Argument: string;
                ArgumentDataColumn: string;
                AutoSeriesColorDataColumn: string;
                AutoSeriesKeyDataColumn: string;
                AutoSeriesTitleDataColumn: string;
                BorderColor: string;
                Brush: string;
                BrushNegative: string;
                Conditions: string;
                FilterMode: string;
                Filters: string;
                Format: string;
                GetArgumentEvent: string;
                GetHyperlinkEvent: string;
                GetListOfArgumentsEvent: string;
                GetListOfHyperlinksEvent: string;
                GetListOfTagsEvent: string;
                GetListOfToolTipsEvent: string;
                GetListOfValuesEvent: string;
                GetListOfWeightsEvent: string;
                GetTagEvent: string;
                GetTitleEvent: string;
                GetToolTipEvent: string;
                GetValueEvent: string;
                GetWeightEvent: string;
                Interaction: string;
                LabelsOffset: string;
                Lighting: string;
                LineColor: string;
                LineColorNegative: string;
                LineMarker: string;
                LineStyle: string;
                LineWidth: string;
                ListOfArguments: string;
                ListOfValues: string;
                ListOfWeights: string;
                Marker: string;
                NewAutoSeriesEvent: string;
                PointAtCenter: string;
                SeriesLabels: string;
                ShowInLegend: string;
                ShowNulls: string;
                ShowSeriesLabels: string;
                ShowShadow: string;
                ShowZeros: string;
                SortBy: string;
                SortDirection: string;
                Tension: string;
                Title: string;
                TopmostLine: string;
                TopN: string;
                TrendLine: string;
                Value: string;
                ValueDataColumn: string;
                Weight: string;
                WeightDataColumn: string;
                YAxis: string;
            };
            StiSeriesInteraction: {
                AllowSeries: string;
                AllowSeriesElements: string;
                DrillDownEnabled: string;
                DrillDownPage: string;
                DrillDownReport: string;
                Hyperlink: string;
                HyperlinkDataColumn: string;
                ListOfHyperlinks: string;
                ListOfTags: string;
                ListOfToolTips: string;
                Tag: string;
                TagDataColumn: string;
                ToolTip: string;
                ToolTipDataColumn: string;
            };
            StiSeriesLabels: {
                Angle: string;
                Antialiasing: string;
                AutoRotate: string;
                BorderColor: string;
                Brush: string;
                Conditions: string;
                DrawBorder: string;
                Font: string;
                Format: string;
                LabelColor: string;
                LegendValueType: string;
                LineColor: string;
                LineLength: string;
                MarkerAlignment: string;
                MarkerSize: string;
                MarkerVisible: string;
                PreventIntersection: string;
                ShowInPercent: string;
                ShowNulls: string;
                ShowValue: string;
                ShowZeros: string;
                Step: string;
                TextAfter: string;
                TextBefore: string;
                UseSeriesColor: string;
                ValueType: string;
                ValueTypeSeparator: string;
                Visible: string;
                Width: string;
                WordWrap: string;
            };
            StiSeriesTopN: {
                Count: string;
                Mode: string;
                OtherText: string;
                ShowOther: string;
            };
            StiShape: {
                BorderColor: string;
                ShapeType: string;
                Size: string;
                Style: string;
            };
            StiShapeTypeService: {
                Direction: string;
            };
            StiSimpleBorder: {
                Color: string;
                Side: string;
                Size: string;
                Style: string;
            };
            StiSimpleText: {
                GetValueEvent: string;
                GlobalizedName: string;
                HideZeros: string;
                LinesOfUnderline: string;
                MaxNumberOfLines: string;
                OnlyText: string;
                ProcessAt: string;
                ProcessAtEnd: string;
                ProcessingDuplicates: string;
                Text: string;
            };
            StiSolidBrush: {
                Color: string;
            };
            StiSSCC18BarCodeType: {
                CompanyPrefix: string;
                ExtensionDigit: string;
                Height: string;
                Module: string;
                SerialNumber: string;
            };
            StiStandard2of5BarCodeType: {
                Height: string;
                Module: string;
                Ratio: string;
            };
            StiStrips: {
                Antialiasing: string;
                Font: string;
                MaxValue: string;
                MinValue: string;
                Orientation: string;
                ShowBehind: string;
                ShowInLegend: string;
                StripBrush: string;
                Text: string;
                TitleColor: string;
                TitleVisible: string;
                Visible: string;
            };
            StiSubReport: {
                KeepSubReportTogether: string;
                SubReportPage: string;
                UseExternalReport: string;
            };
            StiTable: {
                AutoWidth: string;
                AutoWidthType: string;
                ColumnCount: string;
                DockableTable: string;
                FooterCanBreak: string;
                FooterCanGrow: string;
                FooterCanShrink: string;
                FooterPrintAtBottom: string;
                FooterPrintIfEmpty: string;
                FooterPrintOn: string;
                FooterPrintOnAllPages: string;
                FooterPrintOnEvenOddPages: string;
                FooterRowsCount: string;
                HeaderCanBreak: string;
                HeaderCanGrow: string;
                HeaderCanShrink: string;
                HeaderPrintAtBottom: string;
                HeaderPrintIfEmpty: string;
                HeaderPrintOn: string;
                HeaderPrintOnAllPages: string;
                HeaderPrintOnEvenOddPages: string;
                HeaderRowsCount: string;
                RowCount: string;
            };
            StiTableElement: {
                Columns: string;
                Group: string;
                SizeMode: string;
                Style: string;
                Title: string;
            };
            StiTableOfContents: {
                RightToLeft: string;
            };
            StiText: {
                AllowHtmlTags: string;
                Angle: string;
                AutoWidth: string;
                ExcelValue: string;
                ExportAsImage: string;
                Font: string;
                GetExcelValueEvent: string;
                HorAlignment: string;
                Margins: string;
                RenderTo: string;
                ShrinkFontToFit: string;
                ShrinkFontToFitMinimumSize: string;
                TextFormat: string;
                TextOptions: string;
                TextQuality: string;
                WordWrap: string;
            };
            StiTextBoxControl: {
                AcceptsReturn: string;
                AcceptsTab: string;
                MaxLength: string;
                Multiline: string;
                PasswordChar: string;
                Text: string;
                TextBinding: string;
                WordWrap: string;
            };
            StiTextInCells: {
                CellHeight: string;
                CellWidth: string;
                ContinuousText: string;
                HorSpacing: string;
                RightToLeft: string;
                VertSpacing: string;
                WordWrap: string;
            };
            StiTextOptions: {
                Angle: string;
                DistanceBetweenTabs: string;
                FirstTabOffset: string;
                HotkeyPrefix: string;
                LineLimit: string;
                RightToLeft: string;
                Trimming: string;
                WordWrap: string;
            };
            StiTitle: {
                BackColor: string;
                Font: string;
                ForeColor: string;
                HorAlignment: string;
                Text: string;
                Visible: string;
            };
            StiTreeViewControl: {
                AfterSelectEvent: string;
            };
            StiTrendLine: {
                LineColor: string;
                LineStyle: string;
                LineWidth: string;
                ShowShadow: string;
            };
            StiUpcABarCodeType: {
                Height: string;
                Module: string;
                ShowQuietZoneIndicator: string;
                SupplementCode: string;
                SupplementType: string;
            };
            StiUpcEBarCodeType: {
                Height: string;
                Module: string;
                SupplementCode: string;
                SupplementType: string;
            };
            StiUpcSup2BarCodeType: {
                Height: string;
                Module: string;
                ShowQuietZoneIndicator: string;
            };
            StiUpcSup5BarCodeType: {
                Height: string;
                Module: string;
                ShowQuietZoneIndicator: string;
            };
            StiVariable: {
                Alias: string;
                Category: string;
                Description: string;
                Name: string;
            };
            StiVertChartGridLines: {
                Visible: string;
            };
            StiView: {
                AspectRatio: string;
                MultipleFactor: string;
                Smoothing: string;
                Stretch: string;
            };
            StiWatermark: {
                Angle: string;
                AspectRatio: string;
                Enabled: string;
                Font: string;
                Image: string;
                ImageAlignment: string;
                ImageMultipleFactor: string;
                ImageStretch: string;
                ImageTiling: string;
                ImageTransparency: string;
                RightToLeft: string;
                ShowBehind: string;
                ShowImageBehind: string;
                Text: string;
                TextBrush: string;
            };
            StiWinControl: {
                BackColor: string;
                Font: string;
                ForeColor: string;
                Text: string;
                TypeName: string;
            };
            StiXAxis: {
                DateTimeStep: string;
            };
            StiXChartAxis: {
                ShowEdgeValues: string;
                StartFromZero: string;
                Title: string;
            };
            StiXChartAxisTitle: {
                Direction: string;
            };
            StiYChartAxis: {
                StartFromZero: string;
            };
            StiYChartAxisTitle: {
                Direction: string;
            };
            StiZipCode: {
                Code: string;
                ForeColor: string;
                GetZipCodeEvent: string;
                Ratio: string;
                Size: string;
            };
            Universal: {
                AllowApplyStyle: string;
                Key: string;
                Label: string;
                Value: string;
            };
        };
        private static _cultureName;
        static get cultureName(): string;
        static set cultureName(value: string);
        static addLocalizationFile(filePath: string, load?: boolean, language?: string): string;
        static setLocalizationFile(filePath: string, onlyThis?: boolean): void;
        static loadLocalization(localizationXml: any, extension?: boolean): string;
        static loadLocalizationFile(filePath: string): string;
        private static loadLocalizationXmlInternal;
        static get(category: string, key: string): string;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiAllowDoublePassAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiAllowHtmlTagsInTextAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiApplyGeneralTextFormat extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiCanBreakComponentInContainerAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiCanGrowComponentInContainerAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiCanGrowGrowToHeightComponentInContainerAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiCanGrowWordWrapTextAndWysiwygAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiColumnsWidthGreaterContainerWidthAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiComponentStyleIsNotFoundAtComponentAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiConversionContainerInPanelAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiConversionContourTextInTextAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiConversionSystemTextInTextAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiDeleteComponentAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiFixCrossLinePrimitiveAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiGenerateNewNameComponentAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiGrowToHeightOverlappingAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiMinRowsInColumnsAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiMoveComponentToPageAreaAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiMoveComponentToPrintablePageAreaAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiNegativeSizesOfComponentsAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiVerySmallSizesOfComponentsAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiWordWrapCanGrowTextDoesNotFitAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiDeleteConnectionAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiDeleteDataRelationAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiGenerateNewNameRelationAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiDeleteDataSourceAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiGenerateNewNameDataSourceAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiDeleteLostPointsAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiDeletePageAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiGenerateNewNamePageAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiLargeHeightAtPageAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiOrientationPageToLandscapeAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiOrientationPageToPortraitAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiPrintHeadersFootersFromPreviousPageAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiPrintOnPreviousPageAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiResetPageNumberAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiSwitchWidthAndHeightOfPageAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiEditNameAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiEditPropertyAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiGoToCodeAction extends StiAction {
        get name(): string;
        get description(): string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiComponentCheck extends StiCheck {
        get objectType(): StiCheckObjectType;
        get elementName(): string;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiAllowHtmlTagsInTextCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiCanBreakComponentInContainerCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiCanGrowComponentInContainerCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiCanGrowGrowToHeightComponentInContainerCheck extends StiComponentCheck {
        get defaultStateEnabled(): boolean;
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiCanGrowWordWrapTextAndWysiwygCheck extends StiComponentCheck {
        get defaultStateEnabled(): boolean;
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiChartSeriesValueCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiColumnsWidthGreaterContainerWidthCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiComponentBoundsAreOutOfBand extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiComponentDataColumnCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiComponentStyleIsNotFoundAtComponentCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiContainerInEngineV2Check extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiContourTextObsoleteCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiCorruptedCrossLinePrimitiveCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiCountDataDataSourceAtDataBandCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiCrossGroupHeaderNotEqualToCrossGroupFooterOnContainerCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiDataSourcesForImageCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiFontMissingCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiGroupHeaderNotEqualToGroupFooterOnContainerCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiGrowToHeightOverlappingCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiLocationOutsidePageCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        get isOutsidePage(): boolean;
        get isOutsidePrintableArea(): boolean;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiMinRowsInColumnsCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiNegativeSizesOfComponentsCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiNoConditionAtGroupCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiNoNameComponentCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiPrintOnDoublePassCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiShowInsteadNullValuesCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiSystemTextObsoleteCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiTextColorEqualToBackColorCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiTextTextFormatCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        check(): boolean;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiUndefinedComponentCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiVerySmallSizesOfComponentsCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiWidthHeightZeroComponentCheck extends StiComponentCheck {
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiWordWrapCanGrowTextDoesNotFitCheck extends StiComponentCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiConnectionCheck extends StiCheck {
        get objectType(): StiCheckObjectType;
        get elementName(): string;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiUndefinedConnectionCheck extends StiConnectionCheck {
        private report;
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiExpressionElementCheck extends StiComponentCheck {
        get defaultStateEnabled(): boolean;
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private _expression;
        get expression(): string;
        set expression(value: string);
        private _message;
        get message(): string;
        set message(value: string);
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiFilterCircularDependencyElementCheck extends StiComponentCheck {
        get defaultStateEnabled(): boolean;
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiDataRelationCheck extends StiCheck {
        private dataBuilder;
        get objectType(): StiCheckObjectType;
        get elementName(): string;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiDifferentAmountOfKeysInDataRelationCheck extends StiDataRelationCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiKeysInAbsentDataRelationCheck extends StiDataRelationCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiKeysNotFoundRelationCheck extends StiDataRelationCheck {
        get previewVisible(): boolean;
        private _columns;
        get columns(): string;
        set columns(value: string);
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private isColumnsExist;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiKeysTypesMismatchDataRelationCheck extends StiDataRelationCheck {
        get previewVisible(): boolean;
        private _columns;
        get columns(): string;
        set columns(value: string);
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private isColumnsExist;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiNoNameDataRelationCheck extends StiDataRelationCheck {
        get previewVisible(): boolean;
        private _dataSources;
        get dataSources(): string;
        set dataSources(value: string);
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiNoNameInSourceDataRelationCheck extends StiDataRelationCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiSourcesInAbsentDataRelationCheck extends StiDataRelationCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiDataColumnCheck extends StiCheck {
        private dataBuilder;
        get previewVisible(): boolean;
        get objectType(): StiCheckObjectType;
        get elementName(): string;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiCalculatedColumnRecursionCheck extends StiDataColumnCheck {
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private checkForRecursion;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiDataSourceCheck extends StiCheck {
        private dataBuilder;
        get objectType(): StiCheckObjectType;
        get elementName(): string;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiNoNameDataSourceCheck extends StiDataSourceCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiNoNameInSourceDataSourceCheck extends StiDataSourceCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiUndefinedDataSourceCheck extends StiDataSourceCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    import StiDatabase = Stimulsoft.Report.Dictionary.StiDatabase;
    import StiResource = Stimulsoft.Report.Dictionary.StiResource;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiUsedResourceHelper {
        static getDatabasesUsedResource(report: StiReport, resource: StiResource): StiDatabase[];
        static getComponentsUsedResource(report: StiReport, resource: StiResource): StiComponent[];
        private static getImageComponentsUsedResource;
        private static getRichTextComponentsUsedResource;
        private static getReportsUsedResource;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiPageCheck extends StiCheck {
        get previewVisible(): boolean;
        get objectType(): StiCheckObjectType;
        get elementName(): string;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiColumnsWidthGreaterPageWidthCheck extends Stimulsoft.Report.Check.StiPageCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiComponentStyleIsNotFoundAtPageCheck extends StiPageCheck {
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiCrossGroupHeaderNotEqualToCrossGroupFooterOnPageCheck extends StiPageCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiGroupHeaderNotEqualToGroupFooterOnPageCheck extends StiPageCheck {
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiLargeHeightAtPageCheck extends StiPageCheck {
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiPointPrimitive = Stimulsoft.Report.Components.StiPointPrimitive;
    class StiLostPointsOnPageCheck extends StiPageCheck {
        get previewVisible(): boolean;
        private get page();
        get shortMessage(): string;
        get longMessage(): string;
        private _lostPointsNames;
        get lostPointsNames(): string;
        set lostPointsNames(value: string);
        get status(): StiCheckStatus;
        static getLostPointsOnPage(page: StiPage): StiPointPrimitive[];
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiNoNamePageCheck extends StiPageCheck {
        private get page();
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiOrientationPageCheck extends StiPageCheck {
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiPrintHeadersAndFootersFromPreviousPageCheck extends StiPageCheck {
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private getPageCount;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiPrintOnPreviousPageCheck extends StiPageCheck {
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private getPageCount;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiPrintOnPreviousPageCheck2 extends StiPageCheck {
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiResetPageNumberCheck extends StiPageCheck {
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private getPageCount;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiReportCheck extends StiCheck {
        get objectType(): StiCheckObjectType;
        get elementName(): string;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiDuplicatedNameCheck extends StiReportCheck {
        get elementName(): string;
        get previewVisible(): boolean;
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private _isDataSource;
        get isDataSource(): boolean;
        set isDataSource(value: boolean);
        private dataBuilder;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiDuplicatedNameInSourceInDataRelationReportCheck extends StiReportCheck {
        get previewVisible(): boolean;
        private _relationsNames;
        get relationsNames(): string;
        set relationsNames(value: string);
        private _relationsNameInSource;
        get relationsNameInSource(): string;
        set relationsNameInSource(value: string);
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiIsFirstPageIsLastPageDoublePassCheck extends StiReportCheck {
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiIsFirstPassIsSecondPassCheck extends StiReportCheck {
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiReportRenderingMessageCheck extends StiReportCheck {
        get shortMessage(): string;
        private _longMessage;
        get longMessage(): string;
        get status(): StiCheckStatus;
        setMessage(message: string): void;
        processCheck(report: StiReport, msg: any): void;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiTotalPageCountDoublePassCheck extends StiReportCheck {
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiVariableCheck extends StiCheck {
        get previewVisible(): boolean;
        get objectType(): StiCheckObjectType;
        get elementName(): string;
    }
}
declare namespace Stimulsoft.Report.Check {
    class StiVariableRecursionCheck extends StiVariableCheck {
        get shortMessage(): string;
        get longMessage(): string;
        get status(): StiCheckStatus;
        private checkForRecursion;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare namespace Stimulsoft.Designer {
    enum StiImagesID {
        BusinessObject = 0,
        CalcColumn = 1,
        CalcColumnBinary = 2,
        CalcColumnBool = 3,
        CalcColumnChar = 4,
        CalcColumnDateTime = 5,
        CalcColumnDecimal = 6,
        CalcColumnFloat = 7,
        CalcColumnImage = 8,
        CalcColumnInt = 9,
        CalcColumnString = 10,
        Class = 11,
        Close = 12,
        ColumnsOrder = 13,
        Connection = 14,
        ConnectionFail = 15,
        DataColumn = 16,
        DataColumnBinary = 17,
        DataColumnBool = 18,
        DataColumnChar = 19,
        DataColumnDateTime = 20,
        DataColumnDecimal = 21,
        DataColumnFloat = 22,
        DataColumnImage = 23,
        DataColumnInt = 24,
        DataColumnString = 25,
        DataSource = 26,
        DataSources = 27,
        DataStore = 28,
        DataTable = 29,
        DataTables = 30,
        Folder = 31,
        Format = 32,
        FormatBoolean = 33,
        FormatCurrency = 34,
        FormatDate = 35,
        FormatGeneral = 36,
        FormatNumber = 37,
        FormatPercentage = 38,
        FormatTime = 39,
        Function = 40,
        HtmlTag = 41,
        LabelType = 42,
        LockedCalcColumn = 43,
        LockedCalcColumnBinary = 44,
        LockedCalcColumnBool = 45,
        LockedCalcColumnChar = 46,
        LockedCalcColumnDateTime = 47,
        LockedCalcColumnDecimal = 48,
        LockedCalcColumnFloat = 49,
        LockedCalcColumnImage = 50,
        LockedCalcColumnInt = 51,
        LockedCalcColumnString = 52,
        LockedConnection = 53,
        LockedDataColumn = 54,
        LockedDataColumnBinary = 55,
        LockedDataColumnBool = 56,
        LockedDataColumnChar = 57,
        LockedDataColumnDateTime = 58,
        LockedDataColumnDecimal = 59,
        LockedDataColumnFloat = 60,
        LockedDataColumnImage = 61,
        LockedDataColumnInt = 62,
        LockedDataColumnString = 63,
        LockedDataSource = 64,
        LockedFolder = 65,
        LockedParameter = 66,
        LockedRelation = 67,
        LockedVariable = 68,
        LockedVariableBinary = 69,
        LockedVariableBool = 70,
        LockedVariableChar = 71,
        LockedVariableDateTime = 72,
        LockedVariableDecimal = 73,
        LockedVariableFloat = 74,
        LockedVariableImage = 75,
        LockedVariableInt = 76,
        LockedVariableString = 77,
        Namespace = 78,
        Parameter = 79,
        Property = 80,
        Queries = 81,
        Query = 82,
        RecentConnection = 83,
        Relation = 84,
        StoredProcedure = 85,
        StoredProcedures = 86,
        SystemVariable = 87,
        SystemVariableColumn = 88,
        SystemVariableGroupLine = 89,
        SystemVariableIsFirstPage = 90,
        SystemVariableIsFirstPageThrough = 91,
        SystemVariableIsLastPage = 92,
        SystemVariableIsLastPageThrough = 93,
        SystemVariableLine = 94,
        SystemVariableLineABC = 95,
        SystemVariableLineRoman = 96,
        SystemVariableLineThrough = 97,
        SystemVariablePageNofM = 98,
        SystemVariablePageNofMThrough = 99,
        SystemVariablePageNumber = 100,
        SystemVariablePageNumberThrough = 101,
        SystemVariableReportAlias = 102,
        SystemVariableReportAuthor = 103,
        SystemVariableReportChanged = 104,
        SystemVariableReportCreated = 105,
        SystemVariableReportDescription = 106,
        SystemVariableReportName = 107,
        SystemVariables = 108,
        SystemVariableTime = 109,
        SystemVariableToday = 110,
        SystemVariableTotalPageCount = 111,
        SystemVariableTotalPageCountThrough = 112,
        UndefinedConnection = 113,
        UndefinedDataSource = 114,
        Variable = 115,
        VariableBinary = 116,
        VariableBool = 117,
        VariableChar = 118,
        VariableDateTime = 119,
        VariableDecimal = 120,
        VariableFloat = 121,
        VariableImage = 122,
        VariableInt = 123,
        VariableString = 124,
        View = 125,
        Views = 126,
        LockedVariableListBool = 127,
        LockedVariableListChar = 128,
        LockedVariableListDateTime = 129,
        LockedVariableListDecimal = 130,
        LockedVariableListFloat = 131,
        LockedVariableListImage = 132,
        LockedVariableListInt = 133,
        LockedVariableListString = 134,
        LockedVariableRangeChar = 135,
        LockedVariableRangeDateTime = 136,
        LockedVariableRangeDecimal = 137,
        LockedVariableRangeFloat = 138,
        LockedVariableRangeInt = 139,
        LockedVariableRangeString = 140,
        VariableListBool = 141,
        VariableListChar = 142,
        VariableListDateTime = 143,
        VariableListDecimal = 144,
        VariableListFloat = 145,
        VariableListImage = 146,
        VariableListInt = 147,
        VariableListString = 148,
        VariableRangeChar = 149,
        VariableRangeDateTime = 150,
        VariableRangeDecimal = 151,
        VariableRangeFloat = 152,
        VariableRangeInt = 153,
        VariableRangeString = 154
    }
    enum StiDesignerPermissions {
        None = 0,
        Create = 1,
        Delete = 2,
        Modify = 4,
        View = 8,
        ModifyView = 12,
        All = 15
    }
    enum StiInterfaceType {
        Auto = 0,
        Mouse = 1,
        Touch = 2
    }
    enum StiFirstDayOfWeek {
        Auto = 0,
        Monday = 1,
        Sunday = 2
    }
    enum StiPropertiesGridPosition {
        Left = 0,
        Right = 1
    }
    enum StiWizardType {
        None = 0,
        StandardReport = 1,
        MasterDetailReport = 2,
        LabelReport = 3,
        InvoicesReport = 4,
        OrdersReport = 5,
        QuotationReport = 6
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiDashboardScalingHelper {
        static applyScalingToDashboard(dashboard: StiPage, prevWidth: number, prevHeight: number): void;
        private static getLevel;
        private static round;
        private static round2;
        private static getAllLocations;
        private static topUpFilterElements;
        static makeHorizontalSpacingEqual(dashboard: StiPage): number;
        static makeVerticalSpacingEqual(dashboard: StiPage): number;
        static changeDashboardSettingsValue(report: StiReport, param: any, callbackResult: any): void;
        private static resizeDashboard;
        private static addSvgContents;
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiChangeTypeElementHelper {
        static changeTypeElement(report: StiReport, param: any, callbackResult: any): void;
        static createNewComponent(elementType: string, report: StiReport): StiComponent;
    }
}
declare namespace Stimulsoft.Designer {
    import StiCheck = Stimulsoft.Report.Check.StiCheck;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiReportUnitType = Stimulsoft.Report.StiReportUnitType;
    import StiViewer = Stimulsoft.Viewer.StiViewer;
    class StiJsDesigner {
        options: any;
        defaultParameters: any;
        loc: any;
        designer: StiDesigner;
        assignReport(report: StiReport): any;
        SendCommandUpdateCache(): any;
        SendCommandLoadReportToViewer(): any;
        SendCommandCloseViewer(): any;
        SendCommandOpenReport(fileContent: any, fileName: string, reportParams: any, filePath?: string): any;
        ExecuteCommandFromStack(): any;
        Sen(evt: any): any;
        ActionExitDesigner(): any;
        InitializeAboutPanel(): any;
        InitializeProcessImage(): any;
        InitializeErrorMessageForm(): any;
        ActionOpenReport(): any;
        SendCommandSaveStyle(stylesCollection: any[]): any;
        SendCommandSavePage(pageIndex: string): any;
        SendCommandSaveDictionary(): any;
        GetFontNamesItems(): any;
        AddCustomFontsCss(customFontsCss: string): any;
        InitializeSelectDataForm(func: any): any;
        InitializeImageForm(func: any): any;
        RunWizard(wizardType: string): any;
        InitializeFileMenu(): any;
        removeAllEvents(): any;
        LoadReport(reportObject: any): any;
        InitializeCheckPopupPanel(checkItems: any, callbackFunction: any): any;
        ShowMainLoadProcess(command: any): any;
        ShowDictionaryLoadProcess(command: any): any;
        receveFromServer(args: any, jsObject: any): any;
        constructor(parameters: any);
    }
    class StiDesigner {
        private _renderAfterCreate;
        private viewState;
        undoLevel: number;
        private callbackResult;
        private viewerOptions;
        viewer: StiViewer;
        onPrepareVariables: Function;
        onBeginProcessData: Function;
        onEndProcessData: Function;
        onCreateReport: Function;
        onOpenReport: Function;
        onSaveReport: Function;
        onSaveAsReport: Function;
        onPreviewReport: Function;
        onExit: Function;
        onGetSubReport: Function;
        private _designerId;
        get designerId(): string;
        private _options;
        get options(): StiDesignerOptions;
        jsObject: StiJsDesigner;
        private _report;
        get report(): StiReport;
        set report(value: StiReport);
        private _reportGuid;
        get reportGuid(): string;
        set reportGuid(value: string);
        private _renderedReport;
        get renderedReport(): StiReport;
        set renderedReport(value: StiReport);
        private _clipboardId;
        get clipboardId(): string;
        set clipboardId(value: string);
        private _clipboard;
        get clipboard(): string;
        set clipboard(value: string);
        private _stylesClipboard;
        get stylesClipboard(): any;
        set stylesClipboard(value: any);
        private _undoArrayId;
        get undoArrayId(): string;
        set undoArrayId(value: string);
        private _undoArray;
        get undoArray(): any[];
        set undoArray(value: any[]);
        private _componentCloneId;
        get componentCloneId(): string;
        set componentCloneId(value: string);
        private _componentClone;
        get componentClone(): any;
        set componentClone(value: any);
        private _reportCheckers;
        get reportCheckers(): StiCheck[];
        set reportCheckers(value: StiCheck[]);
        get defaultUnit(): StiReportUnitType;
        set defaultUnit(value: StiReportUnitType);
        private _visible;
        get visible(): boolean;
        set visible(value: boolean);
        private _element;
        renderHtml(element?: string | HTMLElement): void;
        private invokePrepareVariables;
        private invokeBeginProcessData;
        private invokeEndProcessData;
        private invokeOnGetSubReport;
        private invokeCreateReport;
        private invokeOpenReport;
        private invokeSaveReport;
        private invokeSaveAsReport;
        private invokePreviewReport;
        private invokeExit;
        private getNewReport;
        private getNewDashboard;
        private getReportFileName;
        private static asyncPromise;
        private raiseCallbackEventAsync;
        dispatch(): void;
        constructor(options?: StiDesignerOptions, designerId?: string, renderAfterCreate?: boolean);
    }
}
declare namespace Stimulsoft.Designer {
    import StiViewerOptions = Stimulsoft.Viewer.StiViewerOptions;
    class StiDesignerOptions {
        appearance: StiAppearanceOptions;
        toolbar: StiToolbarOptions;
        bands: StiBandsOptions;
        crossBands: StiCrossBandsOptions;
        components: StiComponentsOptions;
        dashboardElements: StiDashboardElementsOptions;
        dictionary: StiDictionaryOptions;
        width: string;
        height: string;
        viewerOptions: StiViewerOptions;
        mobileDesignerId: string;
        private productVersion;
        toParameters(): any;
        private serializeObject;
    }
}
declare namespace Stimulsoft.Designer {
    class StiEncodingHelper {
        static decodeString(str: string): string;
        static encode(str: string): string;
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import StiPromise = Stimulsoft.System.StiPromise;
    import IStiOnlineMapElement = Stimulsoft.Report.Dashboard.IStiOnlineMapElement;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiOnlineMapElementHelper {
        private onlineMapElement;
        static getBingMapScriptAsync(element: IStiElement, showTitle: boolean): StiPromise<string>;
        private getOnlineMapElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        private getMeterByContainerName;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private setExpression;
        private renameMeter;
        private updateOnlineMapElementProperties;
        private createNewItem;
        private setFunction;
        private setDataColumn;
        private moveMeter;
        constructor(onlineMapElement: IStiOnlineMapElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiDatePickerElement = Stimulsoft.Report.Dashboard.IStiDatePickerElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDatePickerElementHelper {
        private datePickerElement;
        private getDatePickerElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        static isVariablePresent(datePickerElement: IStiDatePickerElement): boolean;
        static isRangeVariablePresent(datePickerElement: IStiDatePickerElement): boolean;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private moveMeter;
        private renameMeter;
        private createNewItem;
        private editField;
        private setDataColumn;
        private setPropertyValue;
        static createDatePickerElementFromDictionary(report: StiReport, param: any, callbackResult: any): void;
        constructor(datePickerElement: IStiDatePickerElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import StiPromise = Stimulsoft.System.StiPromise;
    import IStiIndicatorElement = Stimulsoft.Report.Dashboard.IStiIndicatorElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiIndicatorElementHelper {
        private indicatorElement;
        private getIndicatorElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private getMeterByContainerName;
        private moveMeter;
        private setPropertyValue;
        private getIconRanges;
        private getIconRangeItem;
        private setExpression;
        private renameMeter;
        private setFunction;
        private createNewItem;
        private setDataColumn;
        private setPropertyValueToIndicatorIconRange;
        private addIndicatorIconRange;
        private removeIndicatorIconRange;
        private static getIndicatorElementStyles;
        static getStylesContentAsync(report: StiReport, param: any): StiPromise<any[]>;
        static isSeriesPresent(indicatorElement: IStiIndicatorElement): boolean;
        static isTargetPresent(indicatorElement: IStiIndicatorElement): boolean;
        constructor(indicatorElement: IStiIndicatorElement);
    }
}
declare namespace Stimulsoft.Designer {
    import StiResource = Stimulsoft.Report.Dictionary.StiResource;
    import StiVirtualSource = Stimulsoft.Report.Dictionary.StiVirtualSource;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiDataColumnsCollection = Stimulsoft.Report.Dictionary.StiDataColumnsCollection;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiPromise = Stimulsoft.System.StiPromise;
    import StiFileDatabase = Stimulsoft.Report.Dictionary.StiFileDatabase;
    import StiDataTransformation = Stimulsoft.Report.Dictionary.StiDataTransformation;
    class StiDictionaryHelper {
        private static databaseItem4;
        private static databaseItem1;
        private static dataTransformationCategoryItem;
        private static datasourceItem;
        static dataTransformationItem(dataTransformation: StiDataTransformation): any;
        private static columnItem;
        private static parameterItem;
        private static relationItem;
        private static businessObjectItem;
        private static variableItem;
        private static tableItem;
        private static functionItem;
        private static functionsCategoryItem;
        private static resourceItem;
        private static imagesGalleryItem;
        private static richTextGalleryItem;
        static getGroupColumnsProperty(dataSource: StiVirtualSource): string;
        static getResultsProperty(dataSource: StiVirtualSource): string;
        private static setGroupColumnsAndResultsProperty;
        private static getDataParameterTypes;
        private static getItemType;
        private static getItemKeyObject;
        private static getItems;
        private static createDataBaseByTypeName;
        private static createDataBaseByServiceName;
        private static createDataAdapterByTypeName;
        private static copyProperties;
        static getColumnsByTypeAndNameOfObject(report: StiReport, props: any): StiDataColumnsCollection;
        private static getDatabaseByName;
        private static updateColumns;
        private static updateParameters;
        private static getVariableBasicType;
        private static getVariableType;
        private static getValueByType;
        private static setDialogInfoItems;
        static getBusinessObjectByFullName(report: StiReport, fullName: string[]): StiBusinessObject;
        private static getAjaxDataFromDatabaseInformation;
        private static convertAjaxDatabaseInfoToDatabaseInfo;
        private static createDataStoreSourceFromParams;
        private static saveDataSourceParam;
        static getViewDataItemValue(item: any, type: Stimulsoft.System.Type): any;
        static createNewDatabaseFromResource(report: StiReport, resource: StiResource): StiFileDatabase;
        static getNewDatabaseName(report: StiReport, fileName: string): string;
        private static isCategoryVariable;
        private static getVariableCategory;
        private static getUniqueName;
        static removeTempSampleData(report: StiReport, dataGuid: string): void;
        private static applyParametersToSqlSourse;
        private static restoreParametersToSqlSourse;
        private static applyDataSourceProps;
        private static applyConnectionProps;
        private static applyColumnProps;
        private static applyParameterProps;
        private static applyRelationProps;
        private static dataSourceContainDataRelation;
        private static dataSourceContainNameInSource;
        private static applyBusinessObjectProps;
        private static applyVariableProps;
        private static applyResourceProps;
        static getIconTypeForColumn(column: StiDataColumn): StiImagesID;
        static getLockedCalcImageIDFromType(type: Stimulsoft.System.Type, inherited: boolean): StiImagesID;
        private static getDataColumnImageIdFromType;
        private static getTypeValueToString;
        private static getTypeVariableToString;
        static getTypeFromString(type: string): Stimulsoft.System.Type;
        static getDictionaryTree(report: StiReport): any;
        static getResourcesTree(report: StiReport): any[];
        static getFunctionsTree(report: StiReport): any[];
        static getSystemVariablesTree(report: StiReport): string[];
        private static getDataBasesTree;
        private static isExistInDatabases;
        private static getObjectsTreeByCategories;
        private static getBusinessObjectsTree;
        private static getChildBusinessObjectsTree;
        private static getVariablesTree;
        private static getColumnsTree1;
        private static getColumnsTree2;
        private static getColumnsTree3;
        private static getParametersTree;
        private static getRelationsTree3;
        private static getRelationsTree2;
        private static getRelationsTree4;
        static getConnectionTypes(report: StiReport, param: any, callbackResult: any, showAdaptersInNewConnectionForm?: boolean): void;
        static getDataAdapterTypes(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditConnection(report: StiReport, param: any, callbackResult: any): void;
        static deleteConnection(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditRelation(report: StiReport, param: any, callbackResult: any): void;
        static deleteRelation(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditColumn(report: StiReport, param: any, callbackResult: any): void;
        static deleteColumn(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditParameter(report: StiReport, param: any, callbackResult: any): void;
        static deleteParameter(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditDataSource(report: StiReport, param: any, callbackResult: any): void;
        static deleteDataSource(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditBusinessObject(report: StiReport, param: any, callbackResult: any): void;
        static deleteBusinessObject(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditVariable(report: StiReport, param: any, callbackResult: any): void;
        static deleteVariable(report: StiReport, param: any, callbackResult: any): void;
        static deleteVariablesCategory(report: StiReport, param: any, callbackResult: any): void;
        static editVariablesCategory(report: StiReport, param: any, callbackResult: any): void;
        static createVariablesCategory(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditResource(report: StiReport, param: any, callbackResult: any): void;
        static deleteResource(report: StiReport, param: any, callbackResult: any): void;
        static deleteBusinessObjectCategory(report: StiReport, param: any, callbackResult: any): void;
        static editBusinessObjectCategory(report: StiReport, param: any, callbackResult: any): void;
        static synchronizeDictionary(report: StiReport, param: any, callbackResult: any): void;
        static newDictionary(report: StiReport, param: any, callbackResult: any): void;
        static getAllConnectionsAsync(report: StiReport, param: any, callbackResult: any): StiPromise<void>;
        static retrieveColumnsAsync(report: StiReport, param: any, callbackResult: any): StiPromise<void>;
        static getDatabaseDataAsync(report: StiReport, param: any, callbackResult: any): StiPromise<void>;
        static applySelectedData(report: StiReport, param: any, callbackResult: any): void;
        static testConnectionAsync(report: StiReport, param: any, callbackResult: any): StiPromise<void>;
        static runQueryScriptAsync(report: StiReport, param: any, callbackResult: any): StiPromise<void>;
        static viewDataAsync(report: StiReport, param: any, callbackResult: any): StiPromise<void>;
        static getSqlParameterTypes(report: StiReport, param: any, callbackResult: any): void;
        static createFieldOnDblClick(report: StiReport, param: any, callbackResult: any): void;
        static getParamsFromQueryString(report: StiReport, param: any, callbackResult: any): void;
        static getImagesGallery(report: StiReport, param: any, callbackResult: any): StiPromise<void>;
        static getRichTextGallery(report: StiReport, param: any, callbackResult: any): void;
        static getSampleConnectionString(report: StiReport, param: any, callbackResult: any): void;
        static createDatabaseFromResource(report: StiReport, param: any, callbackResult: any): void;
        static deleteAllDataSources(report: StiReport, param: any, callbackResult: any): void;
        static getVariableItemsFromDataColumn(report: StiReport, param: any, callbackResult: any): StiPromise<void>;
        static moveDictionaryItem(report: StiReport, param: any, callbackResult: any): void;
        static moveConnectionDataToResource(report: StiReport, param: any, callbackResult: any): void;
        static openDictionary(report: StiReport, param: any, callbackResult: any): void;
        static embedAllDataToResources(report: StiReport, param: Hashtable, callbackResult: Hashtable): Promise<void>;
        static testODataConnection(report: StiReport, param: any, callbackResult: any): void;
        static duplicateDictionaryElement(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import StiPromise = Stimulsoft.System.StiPromise;
    import IStiProgressElement = Stimulsoft.Report.Dashboard.IStiProgressElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiProgressElementHelper {
        private progressElement;
        private getProgressElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private getMeterByContainerName;
        private setExpression;
        private renameMeter;
        private setFunction;
        private moveMeter;
        private createNewItem;
        private setDataColumn;
        private setPropertyValue;
        private static getProgressElementStyles;
        static getStylesContentAsync(report: StiReport, param: any): StiPromise<any[]>;
        static isSeriesPresent(progressElement: IStiProgressElement): boolean;
        constructor(progressElement: IStiProgressElement);
    }
}
declare namespace Stimulsoft.Designer {
    import IStiTrendLinesCollection = Stimulsoft.Report.Chart.IStiTrendLinesCollection;
    import IStiChartElement = Stimulsoft.Report.Dashboard.IStiChartElement;
    import IStiSeriesLabels = Stimulsoft.Report.Chart.IStiSeriesLabels;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import IStiArea = Stimulsoft.Report.Chart.IStiArea;
    import IStiConstantLines = Stimulsoft.Report.Chart.IStiConstantLines;
    import IStiStrips = Stimulsoft.Report.Chart.IStiStrips;
    import IStiChartConditionsCollection = Stimulsoft.Report.Chart.IStiChartConditionsCollection;
    import IStiChartFiltersCollection = Stimulsoft.Report.Chart.IStiChartFiltersCollection;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiChartHelper {
        static getChartProperties(chart: IStiChart): any;
        static getSeriesArray(chart: IStiChart): any[];
        static getSeries(series: IStiSeries): any;
        static getConditions(conditions: IStiChartConditionsCollection): any[];
        static getFilters(filters: IStiChartFiltersCollection): any[];
        static getTrendLines(trendLines: IStiTrendLinesCollection): any[];
        static getTypesCollection(chart: IStiChart): any[];
        static getArea(chart: IStiChart): any;
        static getStyle(chart: IStiChart): any;
        static getMainProperties(chart: IStiChart): any;
        static getConstantLines(chart: IStiChart): any[];
        static getConstantLineProperties(constantLine: IStiConstantLines): any;
        static getStrips(chart: IStiChart): any[];
        static getStripsProperties(strip: IStiStrips): any;
        static getLabels(seriesLabels: IStiSeriesLabels): any;
        static getSeriesProperties(series: IStiSeries): any;
        static getAreaProperties(area: IStiArea): any;
        static getLabelsProperties(labels: IStiSeriesLabels): any;
        static setConditionsValue(conditions: IStiChartConditionsCollection, conditionValues: any[]): void;
        static setFiltersValue(filters: IStiChartFiltersCollection, filterValues: any[]): void;
        static setTrendLinesValue(trendLines: IStiTrendLinesCollection, trendLinesValues: any[]): void;
        static getChartSampleSvg(svgData: StiSvgData, zoom: number): string;
        private static addDefaultSeries;
        static cloneChart(chart: IStiChart): IStiChart;
        static cloneChart2(element: IStiChartElement): IStiChart;
        private static getChartStyles;
        static addSeries(report: StiReport, param: any, callbackResult: any): void;
        static removeSeries(report: StiReport, param: any, callbackResult: any): void;
        static seriesMove(report: StiReport, param: any, callbackResult: any): void;
        static addStrip(report: StiReport, param: any, callbackResult: any): void;
        static removeStrip(report: StiReport, param: any, callbackResult: any): void;
        static moveStrip(report: StiReport, param: any, callbackResult: any): void;
        static addConstantLine(report: StiReport, param: any, callbackResult: any): void;
        static removeConstantLine(report: StiReport, param: any, callbackResult: any): void;
        static moveConstantLine(report: StiReport, param: any, callbackResult: any): void;
        static addConstantLineOrStrip(report: StiReport, param: any, callbackResult: any): void;
        static removeConstantLineOrStrip(report: StiReport, param: any, callbackResult: any): void;
        static constantLineOrStripMove(report: StiReport, param: any, callbackResult: any): void;
        static getLabelsContent(report: StiReport, param: any, callbackResult: any): void;
        static getStylesContent(report: StiReport, param: any, callbackResult: any, forStylesControl: boolean): void;
        static setLabelsType(report: StiReport, param: any, callbackResult: any): void;
        static setLabelsType2(component: StiComponent, propertyValue: string): void;
        static setChartStyle(report: StiReport, param: any, callbackResult: any): void;
        static setChartPropertyValue(report: StiReport, param: any, callbackResult: any): void;
        static setContainerValue(report: StiReport, param: any, callbackResult: any): void;
        private static convertSeries;
        private static setSeriesType;
        private static rewriteArgumentDataColumns;
        private static getDraggedDataColumnValue;
        private static convertSeriesToChartSeriesType;
        private static getChartSeriesTypes;
        private static createSeries;
        private static getArgumentDataColumns;
        private static insertSeries;
        private static getSeriesDataColumnPropertyName;
        private static setDataColumnValue;
        private static getDataColumnValue;
        static isAxisAreaChart(chart: IStiChart): boolean;
        static isPieChart(chart: IStiChart): boolean;
        static isDoughnutChart(chart: IStiChart): boolean;
        static isFunnelChart(chart: IStiChart): boolean;
        static isTreemapChart(chart: IStiChart): boolean;
        static isSunburstChart(chart: IStiChart): boolean;
        static isWaterfallChart(chart: IStiChart): boolean;
        static isStackedChart(chart: IStiChart): boolean;
        static updateChart(report: StiReport, param: any, callbackResult: any): void;
        private static insertDataColumn;
        private static createSeriesOrSetDataColumn;
        private static removeDataColumn;
        private static setPropertyValue;
        static moveSeries(chart: IStiChart, param: any, callbackResult: any): void;
        static moveArgument(chart: IStiChart, param: any, callbackResult: any): void;
        static moveMeter(chart: IStiChart, param: any, callbackResult: any): void;
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiChartElement = Stimulsoft.Report.Dashboard.IStiChartElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiChartElementHelper {
        private chartElement;
        private getChartElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        static getUserViewStates(chartElement: IStiChartElement): any[];
        private setPropertySeriesType;
        private showEmptyValuesInSimpleWay;
        private isShowZeros;
        private isShowNulls;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private setPropertyValue;
        private setPropertyValueToValueMeter;
        private getMeterFromContainer;
        private renameMeter;
        private setExpression;
        private setFunction;
        private removeMeter;
        private removeAllMeters;
        private moveMeter;
        private duplicateMeter;
        private insertMeters;
        private createNewItem;
        private setSeriesType;
        private static getChartElementStyles;
        static getStylesContent(report: StiReport, param: any): any[];
        static getValueMeterItems(chartElement: IStiChartElement): any[];
        static getArgumentMeterItems(chartElement: IStiChartElement): any[];
        static getSeriesMeterItems(chartElement: IStiChartElement): any[];
        private setUserViewState;
        private changeViewState;
        private removeUserViewState;
        private createNewUserViewState;
        private getNextItemName;
        static getConstantLines(chartElement: IStiChartElement): any[];
        private static getConstantLineProperties;
        private addConstantLine;
        private removeConstantLine;
        private moveConstantLine;
        constructor(chartElement: IStiChartElement);
    }
}
declare namespace Stimulsoft.Designer {
    import IStiPivotTableElement = Stimulsoft.Report.Dashboard.IStiPivotTableElement;
    import StiPromise = Stimulsoft.System.StiPromise;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiProgressElement = Stimulsoft.Report.Dashboard.IStiProgressElement;
    import IStiIndicatorElement = Stimulsoft.Report.Dashboard.IStiIndicatorElement;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    import IStiChartElement = Stimulsoft.Report.Dashboard.IStiChartElement;
    import IStiTableElement = Stimulsoft.Report.Dashboard.IStiTableElement;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiTable = Stimulsoft.Report.Components.Table.StiTable;
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    import StiInteraction = Stimulsoft.Report.Components.StiInteraction;
    import StiBaseCondition = Stimulsoft.Report.Components.StiBaseCondition;
    import StiCondition = Stimulsoft.Report.Components.StiCondition;
    import StiColorScaleCondition = Stimulsoft.Report.Components.StiColorScaleCondition;
    import StiIconSetCondition = Stimulsoft.Report.Components.StiIconSetCondition;
    import StiDataBarCondition = Stimulsoft.Report.Components.StiDataBarCondition;
    import StiFiltersCollection = Stimulsoft.Report.Components.StiFiltersCollection;
    import StiConditionPermissions = Stimulsoft.Report.Components.StiConditionPermissions;
    import StiConditionBorderSides = Stimulsoft.Report.Components.StiConditionBorderSides;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiSubReport = Stimulsoft.Report.Components.StiSubReport;
    import StiShape = Stimulsoft.Report.Components.StiShape;
    import StiRichText = Stimulsoft.Report.Components.StiRichText;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiImage = Stimulsoft.Report.Components.StiImage;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiStylesCollection = Stimulsoft.Report.Styles.StiStylesCollection;
    class StiReportEdit {
        static setPropertyValue(report: StiReport, propertyName: string, owner: any, value: any, enumType?: any): void;
        static getPropertyValue(propertyName: string, owner: any): any;
        static getFiltersProperty(obj: any): any;
        static setFiltersProperty(obj: any, value: any): void;
        static lowerFirstChar(text: string): string;
        static lowerFirstCharPropertyNames(text: string): string;
        static upperFirstChar(text: string): string;
        static getPivotTableMeters(pivotTableElement: IStiPivotTableElement): {};
        static base64ToImageByteArray(base64String: string): number[];
        static base64ToImage(base64String: string): Stimulsoft.System.Drawing.Image;
        static imageToBase64_2(image: number[]): string;
        static imageToBase64(image: Stimulsoft.System.Drawing.Image): string;
        static fontToStr(font: Font): string;
        static brushToStr(brush: StiBrush): string;
        static borderToStr(border: StiBorder): string;
        static simpleBorderToStr(border: StiSimpleBorder): string;
        static getStringFromColor(color: Color): string;
        static addComponentToPage(component: StiComponent, currentPage: StiPage): void;
        static getParentName(comp: StiComponent): string;
        static getParentIndex(comp: StiComponent): number;
        static getComponentIndex(component: StiComponent): number;
        static getAllChildComponents(component: StiComponent): string;
        static getPropsRebuildPage(report: StiReport, currentPage: StiPage): any;
        static getAllDbsElementsSvgContentsAsync(report: StiReport): StiPromise<any>;
        static getPageIndexes(report: StiReport): any;
        static setComponentRectWithOffset(comp: StiComponent, newCompRect: RectangleD, command: string, resizeType: string, compProps: any): void;
        static setComponentRect(component: StiComponent, rect: RectangleD, alignToGrid?: boolean, correctOnlySelect?: boolean): void;
        static getComponentRect(component: StiComponent): string;
        static getPageSize(page: StiPage): string;
        static getPageMargins(page: StiPage): string;
        static getAllComponentsPositions(report: StiReport, callbackResult: any): void;
        private static getIconSetItemObject;
        private static getIconSetItemFromObject;
        static strToColor(colorStr: string): Color;
        static strToNumber(value: string): number;
        static numberToStr(value: number): string;
        static strToBrush(value: string): StiBrush;
        static strToBorder(value: string): StiBorder;
        static strToSimpleBorder(value: string): StiSimpleBorder;
        static strToFont(value: string): Font;
        static strBordersToConditionBorderSidesObject(borders: string): StiConditionBorderSides;
        static strPermissionsToConditionPermissionsObject(strPermissions: string): StiConditionPermissions;
        static getReportFileName(report: StiReport): string;
        static createInfographicComponent(componentTypeArray: string, report: StiReport, param: any): StiComponent;
        static createShapeComponent(componentTypeArray: string): StiComponent;
        private static createBarCodeComponent;
        private static applyStyleCollection;
        static applyStyles(comp: StiComponent, stylesCollection: StiStylesCollection): void;
        static getComponentMainProperties(component: StiComponent, zoom: number): any;
        static getTableCells(table: StiTable, zoom: number): any[];
        static getColumnFromColumnPath(columnPath: string, report: StiReport): StiDataColumn;
        static getImageContentForPaint(imageComp: StiImage, requestParams?: any): string;
        static getWatermarkImageContentForPaint(page: StiPage, pageProps: any): string;
        static addPrimitivePoints(addedComp: StiComponent, currentPage: StiPage): void;
        static removePrimitivePoints(removiedComp: StiComponent): void;
        static changeRectPrimitivePoints(changedComp: StiComponent, rect: RectangleD): void;
        static checkAllPrimitivePoints(page: StiPage): void;
        static isAlignedByGrid(component: StiComponent): boolean;
        static addSubReportPage(subReport: StiSubReport, callbackResult: any): void;
        static getColorsCollectionProperty(colors: Color[]): any[];
        static getAllProperties(component: StiComponent, requestParams?: any): any;
        static getRichTextProperty(component: StiRichText): string;
        static getSortDataProperty(object: any): string;
        private static getRelationNameByNameInSource;
        private static getSingleSort;
        static getFiltersObject(filters: StiFiltersCollection): any[];
        static getFilterDataProperty(component: StiBaseCondition | StiComponent): string;
        static getFilterOnProperty(component: StiBaseCondition | StiComponent): boolean;
        static getFilterModeProperty(component: StiBaseCondition | StiComponent): string;
        static getSvgContentAsync2(component: StiComponent, zoom?: number): StiPromise<string>;
        static getConditionsProperty(component: StiComponent): string;
        static getDataBarConditionObject(condition: StiDataBarCondition): any;
        static getIconSetConditionObject(condition: StiIconSetCondition): any;
        static getColorScaleConditionObject(condition: StiColorScaleCondition): any;
        static getHighlightConditionObject(condition: StiCondition): any;
        static getComponentHeaderSize(component: any): string;
        static getInteractionProperty(interaction: StiInteraction): any;
        static getCrossTabFieldsProperties(crossTab: StiCrossTab): any[];
        static getEventsProperty(object_: any): any;
        static getSubReportParametersProperty(subReport: StiSubReport): any[];
        static getShapeTypeProperty(component: StiShape): string;
        static getElementLayoutProperty(layout: StiElementLayout): string;
        static getPreviewSettingsProperty(report: StiReport): any;
        static getTopNProperty(topN: StiDataTopN): any;
        static getOnlineMapContentAsync(component: StiComponent): StiPromise<string>;
        static getCultures(): any[];
        static getPivotTableConditionsProperty(pivotTableElement: IStiPivotTableElement): any[];
        static getExpressionsProperty(component: StiComponent): any;
        static getStylesProperty(component: any): any[];
        static getDashboardInteractionProperty(dashboardInteraction: IStiDashboardInteraction): any;
        static getChartTrendLinesProperty(chartElement: IStiChartElement): any[];
        static getChartConditionsProperty(chartElement: IStiChartElement): any[];
        static getIndicatorConditionsProperty(indicatorElement: IStiIndicatorElement): any[];
        static getProgressConditionsProperty(progressElement: IStiProgressElement): any[];
        static getTableConditionsProperty(tableElement: IStiTableElement): any[];
        private static getTableMeters;
        static setAllProperties(component: StiComponent, props: any[]): void;
        static setSubReportPageProperty(component: any, propertyValue: any): void;
        static setContainerProperty(component: StiComponent, propertyValue: string): void;
        static setShapeTypeProperty(component: StiComponent, shapeType: string): void;
        static setBarCodeTypeProperty(component: StiComponent, propValue: string): void;
        static setMarginsProperty(component: StiComponent, propertyValue: string): void;
        static setTextProperty(component: StiComponent, propertyValue: string): void;
        static setExcelValueProperty(component: StiComponent, propertyValue: string): void;
        static setExcelSheetProperty(component: StiComponent, propertyValue: string): void;
        static setElementLayoutProperty(component: StiComponent, propValue: any): void;
        static setPreviewSettingsProperty(report: StiReport, previewSettings: any, callbackResult: any): void;
        static setColorsCollectionProperty(object_: any, propertyName: string, propertyValue: any[]): void;
        static setTopNProperty(component: any, propertyValue: any): void;
        static setDashboardInteractionProperty(dashboardInteraction: IStiDashboardInteraction, propertyValue: any): void;
        static setChartTrendLinesProperty(component: StiComponent, propertyValue: any): void;
        static setChartConditionsProperty(component: StiComponent, propertyValue: any): void;
        static setPivotTableConditionsProperty(component: StiComponent, propertyValue: any): void;
        static setIndicatorConditionsProperty(component: StiComponent, propertyValue: any): void;
        static setProgressConditionsProperty(component: StiComponent, propertyValue: any): void;
        static setTableConditionsProperty(component: StiComponent, propertyValue: any): void;
        static setExpressionsProperty(component: StiComponent, propertyValue: any): void;
        static setStylesProperty(component: any, propertyValue: any): void;
        static setRichTextProperty(component: StiComponent, propertyValue: string): void;
        static setTextFormatProperty(component: StiComponent, propertyValue: any, propertyName?: string): void;
        static setConditionProperty(component: StiComponent, propertyValue: string): void;
        private static getCorrectName;
        static setDataSourceProperty(component: any, propertyValue: string): void;
        static setDataRelationProperty(component: any, propertyValue: string): void;
        static setMasterComponentProperty(component: StiComponent, propertyValue: string): void;
        static setBusinessObjectProperty(component: StiComponent, propertyValue: string): void;
        static setSortDataProperty1(object: any, sortArray: any[]): void;
        static setSortDataProperty2(object: any, propertyValue: string): void;
        private static getSortArray;
        private static getColumnPathArray;
        private static getChildRelation;
        static setFilterDataProperty1(component: StiBaseCondition | any, filters: any[]): void;
        static setFilterDataProperty2(component: StiBaseCondition | any, propertyValue: string): void;
        private static filterFromObject;
        private static strToFilterDataType;
        private static strToFilterCondition;
        static setFilterOnProperty(component: StiBaseCondition | StiComponent, propertyValue: string): void;
        static setFilterModeProperty(component: StiBaseCondition | StiComponent, propertyValue: string): void;
        static setShiftModeProperty(component: any, propValue: any): void;
        static setRestrictionsProperty(component: StiComponent, propertyValue: string): void;
        static strToIndicatorConditionsPermissions(propertyValue: string): number;
        static strToProgressConditionsPermissions(propertyValue: string): number;
        static strToTableConditionsPermissions(propertyValue: string): number;
        static setAnchorProperty(component: StiComponent, propertyValue: string): void;
        static setConditionsProperty(component: StiComponent, propertyValue: string): void;
        static createHighlightCondition(conditionObject: any): StiBaseCondition;
        static createDataBarCondition(conditionObject: any): StiBaseCondition;
        static createColorScaleCondition(conditionObject: any): StiBaseCondition;
        static createIconSetCondition(conditionObject: any): StiBaseCondition;
        static setInteractionProperty(component: StiComponent, propertyValue: any): void;
        static setChartStyleProperty(component: any, propertyValue: any): void;
        static setGaugeStyleProperty(component: any, propertyValue: any): void;
        static setMapStyleProperty(component: any, propertyValue: any): void;
        static setCrossTabStyleProperty(component: any, propertyValue: any): void;
        static setSubReportParametersProperty(component: any, propertyValue: any): void;
        static writeReportToJsObject(report: StiReport, zoom?: number): any;
        static writeReportToJsObject2(report: StiReport, attachedItems: any, zoom?: number): any;
        static createComponent(report: StiReport, param: any, callbackResult: any): void;
        static removeComponent(report: StiReport, param: any, callbackResult: any): void;
        static changeRectComponent(report: StiReport, param: any, callbackResult: any): void;
        static addPage(report: StiReport, param: any, callbackResult: any): void;
        static removePage(report: StiReport, param: any, callbackResult: any): void;
        static readAllPropertiesFromString(report: StiReport, param: any, callbackResult: any): void;
        static changeUnit(report: StiReport, unitName: string): void;
        static getPreviewPagesAsync(onResult: Function, designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static cloneReportForPreview(report: StiReport): StiReport;
        static setToClipboard(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static getFromClipboard(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static addReportToUndoArray(designer: StiDesigner, report: StiReport, withResources?: boolean): void;
        static getUndoStep(designer: StiDesigner, currentReport: StiReport, param: any, callbackResult: any): StiReport;
        static getRedoStep(designer: StiDesigner, currentReport: StiReport, param: any, callbackResult: any): StiReport;
        static renameComponent(report: StiReport, param: any, callbackResult: any): void;
        static saveComponentClone(designer: StiDesigner, component: StiComponent): void;
        static canceledEditComponent(designer: StiDesigner, currentReport: StiReport, param: any): void;
        static createTextComponentFromDictionary(report: StiReport, param: any, callbackResult: any): void;
        static createComponentFromResource(report: StiReport, param: any, callbackResult: any): void;
        static createElementFromResource(report: StiReport, param: any, callbackResult: any): void;
        private static alignToMaxGrid;
        private static alignToGrid;
        static createDataComponentFromDictionary(report: StiReport, param: any, callbackResult: any): void;
        static setReportProperties(report: StiReport, param: any, callbackResult: any): void;
        static getReportProperties(report: StiReport): any;
        static pageMove(report: StiReport, param: any, callbackResult: any): void;
        static alignToGridComponents(report: StiReport, param: any, callbackResult: any): void;
        static changeArrangeComponents(report: StiReport, param: any, callbackResult: any): void;
        static duplicatePage(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static setEventValue(report: StiReport, param: any, callbackResult: any): void;
        static changeSizeComponents(report: StiReport, param: any, callbackResult: any): void;
        static createMovingCopyComponent(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static updateReportAliases(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        private static getPageTypeFromContent;
        static openPage(report: StiReport, param: any, callbackResult: any): void;
        static checkSvgContent(checkObject: any): StiPromise<void>;
    }
}
declare namespace Stimulsoft.Designer {
    import StiReportUnitType = Stimulsoft.Report.StiReportUnitType;
    class StiAppearanceOptions {
        defaultUnit: StiReportUnitType;
        interfaceType: StiInterfaceType;
        showAnimation: boolean;
        showSaveDialog: boolean;
        showTooltips: boolean;
        showTooltipsHelp: boolean;
        showDialogsHelp: boolean;
        fullScreenMode: boolean;
        maximizeAfterCreating: boolean;
        private _showLocalization;
        get showLocalization(): boolean;
        set showLocalization(value: boolean);
        allowChangeWindowTitle: boolean;
        showPropertiesGrid: boolean;
        showReportTree: boolean;
        propertiesGridPosition: StiPropertiesGridPosition;
        showSystemFonts: boolean;
        datePickerFirstDayOfWeek: StiFirstDayOfWeek;
        undoMaxLevel: number;
        wizardTypeRunningAfterLoad: StiWizardType;
        allowWordWrapTextEditors: boolean;
        private _zoom;
        get zoom(): number;
        set zoom(value: number);
    }
}
declare namespace Stimulsoft.Designer {
    class StiBandsOptions {
        showReportTitleBand: boolean;
        showReportSummaryBand: boolean;
        showPageHeaderBand: boolean;
        showPageFooterBand: boolean;
        showGroupHeaderBand: boolean;
        showGroupFooterBand: boolean;
        showHeaderBand: boolean;
        showFooterBand: boolean;
        showColumnHeaderBand: boolean;
        showColumnFooterBand: boolean;
        showDataBand: boolean;
        showHierarchicalBand: boolean;
        showChildBand: boolean;
        showEmptyBand: boolean;
        showOverlayBand: boolean;
        showTable: boolean;
        showTableOfContents: boolean;
    }
}
declare namespace Stimulsoft.Designer {
    class StiComponentsOptions {
        showText: boolean;
        showTextInCells: boolean;
        showRichText: boolean;
        showImage: boolean;
        showBarCode: boolean;
        showShape: boolean;
        showPanel: boolean;
        showClone: boolean;
        showCheckBox: boolean;
        showSubReport: boolean;
        showZipCode: boolean;
        showChart: boolean;
        showGauge: boolean;
        showSparkline: boolean;
        showMathFormula: boolean;
    }
}
declare namespace Stimulsoft.Designer {
    class StiCrossBandsOptions {
        showCrossTab: boolean;
        showCrossGroupHeaderBand: boolean;
        showCrossGroupFooterBand: boolean;
        showCrossHeaderBand: boolean;
        showCrossFooterBand: boolean;
        showCrossDataBand: boolean;
    }
}
declare namespace Stimulsoft.Designer {
    class StiDashboardElementsOptions {
        showTableElement: boolean;
        showChartElement: boolean;
        showGaugeElement: boolean;
        showPivotTableElement: boolean;
        showIndicatorElement: boolean;
        showProgressElement: boolean;
        showRegionMapElement: boolean;
        showOnlineMapElement: boolean;
        showImageElement: boolean;
        showTextElement: boolean;
        showPanelElement: boolean;
        showShapeElement: boolean;
        showListBoxElement: boolean;
        showComboBoxElement: boolean;
        showTreeViewElement: boolean;
        showTreeViewBoxElement: boolean;
        showDatePickerElement: boolean;
    }
}
declare namespace Stimulsoft.Designer {
    class StiDictionaryOptions {
        showAdaptersInNewConnectionForm: boolean;
        showDictionary: boolean;
        dataSourcesPermissions: StiDesignerPermissions;
        dataConnectionsPermissions: StiDesignerPermissions;
        dataColumnsPermissions: StiDesignerPermissions;
        dataRelationsPermissions: StiDesignerPermissions;
        businessObjectsPermissions: StiDesignerPermissions;
        variablesPermissions: StiDesignerPermissions;
        resourcesPermissions: StiDesignerPermissions;
    }
}
declare namespace Stimulsoft.Designer {
    class StiToolbarOptions {
        visible: boolean;
        showPreviewButton: boolean;
        showSaveButton: boolean;
        showAboutButton: boolean;
        showPublishButton: boolean;
        showFileMenu: boolean;
        showFileMenuNew: boolean;
        showFileMenuOpen: boolean;
        showFileMenuSave: boolean;
        showFileMenuSaveAs: boolean;
        showFileMenuClose: boolean;
        showFileMenuExit: boolean;
        showFileMenuReportSetup: boolean;
        showFileMenuOptions: boolean;
        showFileMenuInfo: boolean;
        showFileMenuAbout: boolean;
        showFileMenuNewReport: boolean;
        showFileMenuNewDashboard: boolean;
        showSetupToolboxButton: boolean;
        showNewPageButton: boolean;
        showNewDashboardButton: boolean;
    }
}
declare namespace Stimulsoft.Designer {
    class StiAggregateFunctions {
        static getItems(): any[];
    }
}
declare namespace Stimulsoft.Designer {
    import StiBarCode = Stimulsoft.Report.BarCodes.StiBarCode;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiBarCodeHelper {
        static getBarCodeJSObject(barCode: StiBarCode): any;
        static getBarCodeProperties(barCode: StiBarCode): any;
        static applyBarCodeProperties(report: StiReport, param: any, callbackResult: any): void;
        static getBarCodeSampleImage(barCode: StiBarCode): string;
    }
}
declare namespace Stimulsoft.Designer {
    class StiCodePageHelper {
        static getDBaseCodePageItems(): any[];
        static getCsvCodePageItems(): any[];
    }
}
declare namespace Stimulsoft.Designer {
    class StiConditionsStylesHelper {
        static getPredefinedStylesItems(): any[];
    }
}
declare namespace Stimulsoft.Designer {
    import StiCrossField = Stimulsoft.Report.CrossTab.StiCrossField;
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    class StiCrossTabHelper {
        private rowTotals;
        private colTotals;
        private sumHeaders;
        private createdTotals;
        private crossTab;
        private columnsContainer;
        private rowsContainer;
        private summaryContainer;
        private selectedDataSource;
        private selectedBusinessObject;
        private oldLeft;
        private oldTop;
        restorePositions(): void;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private getContainerByName;
        getCrossTabResult(): any[];
        getCrossFieldJSProperies(crossField: StiCrossField): any;
        getFieldsPropertiesForJS(): any;
        static getColorStyles(): any[];
        private updateCrossTab;
        private createRowTotal;
        private createColTotal;
        private swapColumnsAndRows;
        private changeSummaryDirection;
        private copySummaryToRow;
        private copySummaryToColumn;
        private copyHeaderToSummary;
        private copyRowToColumn;
        private copyColumnToRow;
        private copyRowTotalToColumnTotal;
        private copyColumnTotalToRowTotal;
        private copyFieldToField;
        private convertColumnTotal;
        private convertRowTotal;
        private killRightTitle;
        constructor(crossTab: StiCrossTab);
    }
}
declare namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiCultureHelper {
        static getItems(): any[];
        private static getHashtableObjectForJs;
        private static getGlobalizationContainerObject;
        static getReportGlobalizationStrings(report: StiReport): any[];
        static addReportGlobalizationStrings(report: StiReport, param: any, callbackResult: any): void;
        static removeReportGlobalizationStrings(report: StiReport, param: any, callbackResult: any): void;
        static getCultureSettingsFromReport(report: StiReport, param: any, callbackResult: any): void;
        static setCultureSettingsToReport(report: StiReport, param: any, callbackResult: any): void;
        static applyGlobalizationStrings(report: StiReport, param: any, callbackResult: any): void;
        static removeUnlocalizedGlobalizationStrings(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare namespace Stimulsoft.Designer {
    import StiPromise = Stimulsoft.System.StiPromise;
    import StiDataTransformationColumn = Stimulsoft.Report.Dictionary.StiDataTransformationColumn;
    import StiDictionary = Stimulsoft.Report.Dictionary.StiDictionary;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiDataTransformation = Stimulsoft.Report.Dictionary.StiDataTransformation;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDataTransformationHelper {
        static columnItem(column: StiDataTransformationColumn, dictionary?: StiDictionary, originalType?: string): any;
        private static actionRuleItem;
        private static getFuncs;
        static createTransformationColumnFromDataColumn(dataColumn: StiDataColumn): StiDataTransformationColumn;
        private static toSumExpression;
        private static toExpression;
        static getColumnFromJSColumnObject(columnObject: any): StiDataTransformationColumn;
        static getSortRuleFromJSSortRuleObject(sortRuleObject: any): StiDataSortRule;
        static getFilterRuleFromJSFilterRuleObject(filterRuleObject: any): StiDataFilterRule;
        static getActionRuleFromJSActionRuleObject(actionRuleObject: any): StiDataActionRule;
        static getViewQueryContentAsync(report: StiReport, param: any, callbackResult: any): StiPromise<void>;
        private static getDataTableContent;
        private static getDataValue;
        private static getSortLabels;
        private static getFilterLabels;
        private static distinct;
        private static isValueCanBeFiltered;
        static getColumns(dataTransformation: StiDataTransformation): any[];
        static getSortRules(dataTransformation: StiDataTransformation): any[];
        static getFilterRules(dataTransformation: StiDataTransformation): any[];
        static getActionRules(dataTransformation: StiDataTransformation): any[];
        static applyProperties(dataTransformation: StiDataTransformation, dataSourceProps: any, report: StiReport): void;
        static getDataGridContentAsync(dataTransformation?: StiDataTransformation): StiPromise<any>;
        static getFilterItemsHelperAsync2(dataTransformation: StiDataTransformation, parameters: any): StiPromise<any>;
        static getFilterItemsHelperAsync(report: StiReport, parameters: any): StiPromise<any>;
        static executeJSCommandAsync(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): StiPromise<void>;
        static getDataTransformationFromElementAsync(report: StiReport, param: any): StiPromise<StiDataTransformation>;
    }
}
declare namespace Stimulsoft.Designer {
    class StiDefaultConditions {
        static getItems(): any;
    }
}
declare namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDesignReportHelper {
        private report;
        getReportJsObject(): any;
        getPages(): any[];
        getPage(pageIndex: number): any;
        private getComponents;
        private getComponent;
        private getReportInfo;
        constructor(report: StiReport);
    }
}
declare namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDesignerOptionsHelper {
        static getDefaultDesignerOptions(): any;
        private static getCookie_;
        private static getCookie;
        private static removeCookie;
        static getDesignerOptions(): any;
        static applyDesignerOptionsToReport(designerOptions: any, report: StiReport): void;
    }
}
declare namespace Stimulsoft.Designer {
    class StiEmptyObject {
    }
}
declare namespace Stimulsoft.Designer {
    class StiFontNames {
        private static item;
        static getItems(): any[];
    }
}
declare namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiResource = Stimulsoft.Report.Dictionary.StiResource;
    import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
    class StiFontResourceHelper {
        static addFontToReport(report: StiReport, resource: StiResource, resourceItem: any): void;
        static getBase64DataForCssFromResourceContent(resourceType: StiResourceType, content: number[]): string;
    }
}
declare namespace Stimulsoft.Designer {
    import List = Stimulsoft.System.Collections.List;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiVariable = Stimulsoft.Report.Dictionary.StiVariable;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiResource = Stimulsoft.Report.Dictionary.StiResource;
    class StiGalleriesHelper {
        static getImageColumns(report: StiReport): List<StiDataColumn>;
        static getImageVariables(report: StiReport): StiVariable[];
        static getImageResources(report: StiReport): StiResource[];
        static getRichTextColumns(report: StiReport): StiDataColumn[];
        static getRichTextVariables(report: StiReport): StiVariable[];
        static getRichTextResources(report: StiReport): StiResource[];
        static getImageFromColumn(column: StiDataColumn, report: StiReport): Image;
        static isRtfColumn(column: StiDataColumn, report: StiReport): boolean;
        static getRichTextAsHtmlFromColumn(column: StiDataColumn, report: StiReport): string;
        static getHtmlTextFromText(text: string): string;
        static getHtmlStringFromRichTextItem(report: StiReport, itemObject: any): string;
        private static getResource;
        private static getVariable;
    }
}
declare namespace Stimulsoft.Designer {
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiGaugeHelper {
        static getGaugeProperties(gauge: StiGauge): any;
        static setGaugeProperties(report: StiReport, param: any, callbackResult: any): void;
        private static getIndicatorColumn;
        private static setIndicatorColumn;
        static getStyle(gauge: StiGauge): any;
        private static getGaugeStyles;
        static getGaugeSampleImage(gauge: StiGauge, width: number, height: number, zoom: number): string;
        static setGaugeStyle(report: StiReport, param: any, callbackResult: any): void;
        static getStylesContent(report: StiReport, param: any, callbackResult: any, forStylesControl: boolean): void;
    }
}
declare namespace Stimulsoft.Designer {
    class StiGoogleAccountHelper {
        private static tokenRequestURI;
        private static clientID;
        private static clientSecret;
        private static redirectUrl;
        static googleAuthorizationProcess(parameters: any, jsObject: any): void;
        private static exchangeCodeAtToken;
    }
}
declare namespace Stimulsoft.Designer {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiGroup extends StiContainer {
        toString2(application: string): string;
        static createFromString(text: string, application: string): StiGroup;
        static getSelectedComponents(isSelectedFinded: boolean, level: number, cont: StiContainer, allComps: StiComponentsCollection, lists: Hashtable): StiComponentsCollection;
        static getGroupFromPage(page: StiPage): StiGroup;
        private static resetSelection;
        private static getAllComps;
        insertIntoPage(page: StiPage): StiComponentsCollection;
        constructor();
    }
}
declare namespace Stimulsoft.Designer {
    class StiHatchStyles {
        private static item;
        static getItems(): any[];
    }
}
declare namespace Stimulsoft.Designer {
    class StiIconSetArrays {
        static getItems(): any;
    }
}
declare namespace Stimulsoft.Designer {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiInsertionComponents {
        static insertGroups(currentPage: StiPage, group: StiGroup): void;
        static insertComponents(currentPage: StiPage, comps: StiComponentsCollection, alignToGrid?: boolean): void;
        static insert(currentPage: StiPage, alignToGrid?: boolean): void;
    }
}
declare namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiMap = Stimulsoft.Report.Maps.StiMap;
    class StiMapHelper {
        static getMapProperties(map: StiMap): any;
        static setMapProperties(report: StiReport, param: any, callbackResult: any): void;
        static updateMapData(report: StiReport, param: any, callbackResult: any): void;
        static getMapDataForJS(map: StiMap): any[];
        private static allowGroup;
        private static allowColor;
        static getStyle(map: StiMap): any;
        private static getMapStyles;
        static getMapSampleImage(map: StiMap, width: number, height: number, zoom: number): string;
        static setMapStyle(report: StiReport, param: any, callbackResult: any): void;
        static getStylesContent(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare namespace Stimulsoft.Designer {
    class StiPaperSizes {
        static getItems(): any[];
    }
}
declare namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiPreviewHelper {
        static getPages(report: StiReport, pageNumber: number, zoom: number, designerId: string): any[];
        private static renderReportPage;
        private static renderPageParameters;
    }
}
declare namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiQuickBooksHelper {
        private static stimulsoftClientId;
        private static stimulsoftClientSecret;
        private static oauth2Url;
        private static bearerUrl;
        private static responseType;
        private static scope;
        private static stimulsoftRedirectUrl;
        static getAuthorizationUrl(report: StiReport, param: any, callbackResult: any): void;
        static getTokens(report: StiReport, param: any, callbackResult: any): void;
        static refreshTokens(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiReportCheckHelper {
        private static checkItem;
        private static checkActionItem;
        private static getActions;
        private static removeCheck;
        private static getChecksJSCollection;
        private static updateCurrentReport;
        private static createImage;
        private static getErrorsCount;
        private static buildReportRenderingMessages;
        static checkReport(designer: StiDesigner, report: StiReport, parameters: any, callbackResult: any, callbackFunc: any): void;
        static getCheckPreview(designer: StiDesigner, report: StiReport, parameters: any, callbackResult: any): void;
        static actionCheck(designer: StiDesigner, report: StiReport, parameters: any, callbackResult: any): void;
        static checkExpression(report: StiReport, parameters: any, callbackResult: any): void;
    }
}
declare namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
    class StiResourcesHelper {
        static getReportThumbnailParametersAsync(report: StiReport, zoom: number): Promise<string>;
        static getHtmlColor(color: Color): string;
        static isPackedFile(content: number[]): boolean;
        static getStringContentForJSFromResourceContentAsync(resourceType: StiResourceType, content: number[]): Promise<string>;
        static getResourceContentAsync(report: StiReport, param: any, callbackResult: any): Promise<void>;
        static getResourceText(report: StiReport, param: any, callbackResult: any): void;
        static setResourceText(report: StiReport, param: any, callbackResult: any): void;
        static getResourceViewData(report: StiReport, param: any, callbackResult: any): void;
        static isFontResourceType(resourceType: StiResourceType): boolean;
    }
}
declare namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiShapeHelper {
        static getShapeSampleImage(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiSparkline = Stimulsoft.Report.Components.StiSparkline;
    class StiSparklineHelper {
        static getSparklineProperties(sparkline: StiSparkline): any;
        static updateSparkline(report: StiReport, param: any, callbackResult: any): void;
        private static setPropertyValue;
        static getSparklineStyles(report: StiReport): any[];
    }
}
declare namespace Stimulsoft.Designer {
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiStyleConditionsCollection = Stimulsoft.Report.Styles.Conditions.StiStyleConditionsCollection;
    import StiStyleCondition = Stimulsoft.Report.Styles.Conditions.StiStyleCondition;
    import StiStylesCollection = Stimulsoft.Report.Styles.StiStylesCollection;
    class StiStylesHelper {
        private static getStyleProperties;
        static styleItem(style: StiBaseStyle): any;
        static setConditionTypeProperty(styleCondition: StiStyleCondition, propertyValue: string): void;
        static setLocationProperty(styleCondition: StiStyleCondition, propertyValue: string): void;
        static setComponentTypeProperty(styleCondition: StiStyleCondition, propertyValue: string): void;
        static setPlacementProperty(styleCondition: StiStyleCondition, propertyValue: string): void;
        static setStyleConditionsProprty(style: StiBaseStyle, conditions: any[]): void;
        static getStyleConditionsProprty(conditions: StiStyleConditionsCollection): any[];
        static getStyles(report: StiReport): any[];
        static generateNewName(styles: StiStylesCollection, newStyle: StiBaseStyle): void;
        static applyStyleProperties(style: StiBaseStyle, properties: any): void;
        static writeStylesToReport(report: StiReport, stylesCollection: any[]): void;
        private static changeStyleNameInReport;
        static updateStyles(report: StiReport, param: any, callbackResult: any): void;
        static addStyle(report: StiReport, param: any, callbackResult: any): void;
        static createStyleCollection(report: StiReport, param: any, callbackResult: any): void;
        static createStylesFromComponents(report: StiReport, param: any, callbackResult: any): void;
        static openStyle(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiTable = Stimulsoft.Report.Components.Table.StiTable;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiTableHelper {
        private table;
        private zoom;
        executeJSCommand(parameters: Hashtable, callbackResult: Hashtable): void;
        private getFirstIndexX;
        private getLastIndexX;
        private getFirstIndexY;
        private getLastIndexY;
        private joinCells;
        private unJoinCells;
        private setSelectedCurrentCells;
        private getSelectedCellNames;
        private getSelectedCellsByNames;
        static getTableStyles(report: StiReport): any[];
        static getTableCellsProperties(table: StiTable, zoom: number): any[];
        private getTableCellsForJS;
        private convertTableCell;
        constructor(table: StiTable, zoom: number);
    }
}
declare namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiTableOfContentsHelper {
        private static getIdents;
        static getIdentsCollection(report: StiReport, param: any, callbackResult: any): void;
        static updateComponentsPointerValues(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiGeneralFormatService = Stimulsoft.Report.Components.TextFormats.StiGeneralFormatService;
    import StiNumberFormatService = Stimulsoft.Report.Components.TextFormats.StiNumberFormatService;
    import StiCurrencyFormatService = Stimulsoft.Report.Components.TextFormats.StiCurrencyFormatService;
    import StiDateFormatService = Stimulsoft.Report.Components.TextFormats.StiDateFormatService;
    import StiTimeFormatService = Stimulsoft.Report.Components.TextFormats.StiTimeFormatService;
    import StiPercentageFormatService = Stimulsoft.Report.Components.TextFormats.StiPercentageFormatService;
    import StiBooleanFormatService = Stimulsoft.Report.Components.TextFormats.StiBooleanFormatService;
    import StiCustomFormatService = Stimulsoft.Report.Components.TextFormats.StiCustomFormatService;
    class StiTextFormatHelper {
        static commonTextFormatItem(service: StiFormatService): any;
        static generalTextFormatItem(service: StiGeneralFormatService): any;
        static numberTextFormatItem(service: StiNumberFormatService): any;
        static currencyTextFormatItem(service: StiCurrencyFormatService): any;
        static dateTextFormatItem(service: StiDateFormatService): any;
        static timeTextFormatItem(service: StiTimeFormatService): any;
        static percentageTextFormatItem(service: StiPercentageFormatService): any;
        static booleanTextFormatItem(service: StiBooleanFormatService): any;
        static customTextFormatItem(service: StiCustomFormatService): any;
        private static getStateProperty;
        static getCurrencySymbols(): string[];
        static getFormatService(properties: any): StiFormatService;
        static getTextFormatItem(service: StiFormatService): any;
        static getDateAndTimeFormats(category: string, service: StiFormatService): any[];
        static getTextFormatItems(): any;
        static updateTextFormatItemsByReportCulture(report: StiReport, param: any, callbackResult: any): void;
        static updateSampleTextFormat(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare namespace Stimulsoft.Designer {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiPromise = Stimulsoft.System.StiPromise;
    class StiViewDataHelper {
        constructor(dataSource: StiDataSource, businessObject?: StiBusinessObject);
        private isDataSourceConnected;
        private dataSource;
        private businessObject;
        resultDataTable: DataTable;
        private fillLevel2;
        private fillLevel4;
        private connectDataSourceFirstTimeAsync;
        buildAsync(): StiPromise<void>;
        private buildBusinessObject;
        private buildDataSourceAsync;
    }
}
declare namespace Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiWizardHelper {
        private static getGroupsFromDataSource;
        private static getColumnsFromDataSource;
        private static getSortFromDataSource;
        private static getFiltersFromDataSource;
        private static getTotalsFromDataSource;
        private static alignToMaxGrid;
        private static alignToGrid;
        static getReportFromWizardOptions(createdReport: StiReport, reportOptions: any, wizardDataSources: any): StiReport;
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiComboBoxElement = Stimulsoft.Report.Dashboard.IStiComboBoxElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiComboBoxElementHelper {
        private comboBoxElement;
        private getComboBoxElementJSProperties;
        private getMeterHashItem;
        getMetersHash(): any;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private moveMeter;
        private createNewItem;
        private editField;
        private renameMeter;
        private setDataColumn;
        private setPropertyValue;
        static createComboBoxElementFromDictionary(report: StiReport, param: any, callbackResult: any): void;
        constructor(comboBoxElement: IStiComboBoxElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import StiPromise = Stimulsoft.System.StiPromise;
    import IStiGaugeElement = Stimulsoft.Report.Dashboard.IStiGaugeElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiGaugeElementHelper {
        private gaugeElement;
        private getGaugeElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        private getGaugeRanges;
        private getGaugeRangeItem;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private getMeterByContainerName;
        private moveMeter;
        private setExpression;
        private renameMeter;
        private setFunction;
        private createNewItem;
        private setDataColumn;
        private setPropertyValue;
        private setPropertyValueToGaugeRange;
        private addGaugeRange;
        private removeGaugeRange;
        private static getGaugeElementStyles;
        static getStylesContentAsync(report: StiReport, param: any): StiPromise<any[]>;
        constructor(gaugeElement: IStiGaugeElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiRegionMapElement = Stimulsoft.Report.Dashboard.IStiRegionMapElement;
    import StiMap = Stimulsoft.Report.Maps.StiMap;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiRegionMapElementHelper {
        private regionMapElement;
        private getRegionMapElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        static getMapDataForJS(regionMapElement: IStiRegionMapElement): any[];
        private static allowGroup;
        private static allowColor;
        private getMeterByContainerName;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private setExpression;
        private renameMeter;
        private createNewItem;
        private setFunction;
        private setDataColumn;
        private moveMeter;
        private setProperties;
        private updateMapData;
        static createMapComponentFromRegionMapElement(regionMapElement: IStiRegionMapElement): StiMap;
        private static getRegionMapStyles;
        static getStylesContent(report: StiReport, param: any): any[];
        constructor(regionMapElement: IStiRegionMapElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import StiPromise = Stimulsoft.System.StiPromise;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDashboardHelper {
        static addDashboard(report: StiReport, param: any, callbackResult: any): void;
        static getDashboardGridLinesColor(page: StiPage): Color;
        static getDashboardGridDotsColor(page: StiPage): Color;
        static getSelectionBorderColor(page: StiPage): Color;
        static getSelectionCornerColor(page: StiPage): Color;
        static getDashboardBackColor(page: StiPage): Color;
        static createDashboardElement(report: StiReport, typeComponent: string): StiComponent;
        static getDashboardStylesAsync(report: StiReport, param: any, callbackResult: any): StiPromise<any[]>;
        static getDashboardStyleSampleImageAsync(element: IStiElement, width: number, height: number): StiPromise<string>;
        static changeDashboardStyle(report: StiReport, param: any, callbackResult: any): void;
        static changeDashboardViewMode(report: StiReport, param: any, callbackResult: any): void;
        static getMobileViewUnplacedElements(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import StiPromise = Stimulsoft.System.StiPromise;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiElementDataFiltersHelper {
        private element;
        private get dataFilterElement();
        private getElementDataFiltersJSPropertiesAsync;
        private getDataFilterType;
        private getFiltersAsync;
        private getDataValuesFromDataPathAsync;
        executeJSCommandAsync(parameters: any, callbackResult: any): StiPromise<void>;
        private createNewItem;
        private editField;
        private moveFilter;
        private removeFilter;
        private insertFilters;
        private setPropertyValue;
        constructor(element: IStiElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiImageElement = Stimulsoft.Report.Dashboard.IStiImageElement;
    class StiImageElementHelper {
        private imageElement;
        private getImageElementJSProperties;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private setPropertyValue;
        constructor(imageElement: IStiImageElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiListBoxElement = Stimulsoft.Report.Dashboard.IStiListBoxElement;
    class StiListBoxElementHelper {
        private listBoxElement;
        private getListBoxElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private moveMeter;
        private createNewItem;
        private editField;
        private renameMeter;
        private setDataColumn;
        private setPropertyValue;
        constructor(listBoxElement: IStiListBoxElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiPivotTableElement = Stimulsoft.Report.Dashboard.IStiPivotTableElement;
    class StiPivotTableElementHelper {
        private pivotTableElement;
        private getPivotTableElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private setPropertyValue;
        private getMeterFromContainer;
        private setExpression;
        private setTopN;
        private renameMeter;
        private setFunction;
        private removeAllMeters;
        private removeMeter;
        private moveMeter;
        private duplicateMeter;
        private insertMeters;
        private createNewItem;
        private swapColumnsRows;
        private swapSummaryDirection;
        constructor(pivotTableElement: IStiPivotTableElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiShapeElement = Stimulsoft.Report.Dashboard.IStiShapeElement;
    class StiShapeElementHelper {
        private shapeElement;
        static createShapeElement(componentTypeArray: string): StiComponent;
        static setShapeTypeProperty(comp: IStiShapeElement, propValue: any): void;
        static getShapeTypeProperty(comp: IStiShapeElement): string;
        private getShapeElementJSProperties;
        private setPropertyValue;
        executeJSCommand(parameters: any, callbackResult: any): void;
        constructor(shapeElement: IStiShapeElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTableElement = Stimulsoft.Report.Dashboard.IStiTableElement;
    import IStiDashboard = Stimulsoft.Report.Dashboard.IStiDashboard;
    import StiReport = Stimulsoft.Report.StiReport;
    import List = Stimulsoft.System.Collections.List;
    class StiTableElementHelper {
        private tableElement;
        private getMeterItem;
        private getMetersItems;
        static getMeterFunctions(meter: IStiMeter, dashboard: IStiDashboard): List<string>;
        private getTableElementJSProperties;
        static getMeterLabel(meter: IStiMeter): string;
        private static getSparklinesType;
        static getMeterType(meter: IStiMeter): string;
        static getMeterTypeIcon(meter: IStiMeter): string;
        private static checkMeasureMeterTextFormat;
        private static checkMeterTextFormatForPercentOfGrandTotal;
        private static getTableTitleByTypeAndNameOfObject;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private insertMeters;
        private removeMeter;
        private renameMeter;
        private removeAllMeters;
        private convertMeter;
        private moveMeter;
        private newMeter;
        private duplicateMeter;
        private setFunction;
        private switchToPercentOfGrandTotal;
        private changeSparklinesType;
        private setPropertyValue;
        static createTableElementFromDictionary(report: StiReport, param: any, callbackResult: any): void;
        constructor(tableElement: IStiTableElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiTextElement = Stimulsoft.Report.Dashboard.IStiTextElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiTextElementHelper {
        private textElement;
        private getTextElementJSProperties;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private setProperty;
        private static removeTagsFromText;
        static createTextElementFromDictionary(report: StiReport, param: any, callbackResult: any): void;
        constructor(textElement: IStiTextElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiTreeViewBoxElement = Stimulsoft.Report.Dashboard.IStiTreeViewBoxElement;
    class StiTreeViewBoxElementHelper {
        private treeViewBoxElement;
        private getTreeViewBoxElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private removeAllMeters;
        private createNewItem;
        private editField;
        private insertMeters;
        private removeMeter;
        private renameMeter;
        private moveMeter;
        private duplicateMeter;
        private setPropertyValue;
        constructor(treeViewBoxElement: IStiTreeViewBoxElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiTreeViewElement = Stimulsoft.Report.Dashboard.IStiTreeViewElement;
    class StiTreeViewElementHelper {
        private treeViewElement;
        private getTreeViewElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private removeAllMeters;
        private insertMeters;
        private createNewItem;
        private editField;
        private removeMeter;
        private renameMeter;
        private moveMeter;
        private duplicateMeter;
        private setPropertyValue;
        constructor(treeViewElement: IStiTreeViewElement);
    }
}
