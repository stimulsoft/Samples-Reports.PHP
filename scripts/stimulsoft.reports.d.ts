/*
Stimulsoft.Reports.JS
Version: 2018.2.3
Build date: 2018.07.05
License: https://www.stimulsoft.com/en/licensing/reports
*/
declare module Stimulsoft.System.Collections {
    class CollectionBase<T> implements IList, ICollection<T>, IEnumerable {
        protected _list: Array<T>;
        readonly list: Array<T>;
        implements(): string[];
        /** Gets the number of elements contained in the CollectionBase instance. */
        readonly count: number;
        /** Removes all objects from the CollectionBase instance. */
        clear(): void;
        removeAt(index: number): void;
        protected onClear(): void;
        protected onInsertComplete(index: number, value: Object): void;
        protected onRemoveComplete(index: number, value: Object): void;
        protected onClearComplete(): void;
    }
}
declare module Stimulsoft.System.Collections {
    class DictionaryEntry {
        key: any;
        value: any;
    }
}
declare module Stimulsoft.System.Collections {
    class Hashtable {
        private isSimpleKeys;
        keys: any[];
        values: any[];
        private indexObject;
        get(key: any): any;
        set(key: any, value: any): void;
        /** Adds an element with the specified key and value into the Hashtable. */
        add(key: any, value: any): void;
        /** Determines whether the Hashtable contains a specific key. */
        contains(key: any): boolean;
        /** Determines whether the Hashtable contains a specific key. */
        containsKey(key: any): boolean;
        /** Determines whether the Hashtable contains a specific value. */
        containsValue(value: any): boolean;
        /** Removes the element with the specified key from the Hashtable. */
        remove(key: any): void;
        /** Removes all elements from the Hashtable. */
        clear(): void;
        /** Copies the Hashtable elements to a one-dimensional Array instance at the specified index. */
        copyTo(array: Array<any>, arrayIndex: number): void;
        /** Gets the number of key/value pairs contained in the Hashtable. */
        readonly count: number;
        clone(): Hashtable;
    }
}
declare module Stimulsoft.System.Collections {
    var ICollection: string;
    interface ICollection<T> {
        list: Array<T>;
        clear(): any;
        removeAt(index: number): any;
        count: number;
    }
}
declare module Stimulsoft.System.Collections {
    var IComparer: string;
    interface IComparer<T> {
        compare(x: T, y: T): number;
    }
}
declare module Stimulsoft.System.Collections {
    var IEnumerable: string;
    interface IEnumerable {
    }
}
declare module Stimulsoft.System.Collections {
    var IEnumerator: string;
    interface IEnumerator {
        current: Object;
        moveNext(): boolean;
        reset(): any;
    }
}
declare module Stimulsoft.System.Collections {
    var IList: string;
    interface IList {
        clear(): any;
        removeAt(index: number): any;
    }
}
declare module Stimulsoft.System.ComponentModel {
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    class TypeConverter {
        canConvertFrom(context: any, sourceType: Stimulsoft.System.Type): boolean;
        canConvertTo(context: any, sourceType: Stimulsoft.System.Type): boolean;
        convertTo(context: any, culture: CultureInfo, value: any, destinationType: Stimulsoft.System.Type): any;
        convertFrom(context: any, culture: CultureInfo, value: any): any;
        convertToString(value: any): string;
        convertFromString(text: string): any;
    }
}
declare module Stimulsoft.System.Crypt {
    class AES {
        private key;
        private data;
        private nDataBytes;
        private blockSize;
        private iv;
        private prevBlock;
        private SBOX;
        private INV_SBOX;
        private SUB_MIX_0;
        private SUB_MIX_1;
        private SUB_MIX_2;
        private SUB_MIX_3;
        private INV_SUB_MIX_0;
        private INV_SUB_MIX_1;
        private INV_SUB_MIX_2;
        private INV_SUB_MIX_3;
        private RCON;
        private nRounds;
        private invKeySchedule;
        private keySchedule;
        private doReset();
        private process();
        private processBlock(words, offset);
        private xorBlock(words, offset, blockSize);
        private pkcs7pad(data);
        private pkcs7Unpad(data);
        private encryptBlock(M, offset);
        private decryptBlock(M, offset);
        private doCryptBlock(M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
        static encrypt(text: string, key: string): string;
        private encrypt(text, key);
        static decrypt(text: string, key: string): string;
        private decrypt(text, key);
        constructor();
    }
}
declare module Stimulsoft.System.Crypt {
    class BigInteger {
        private static BI_RM;
        private static BI_RC;
        private static canary;
        private static j_lm;
        private static dbits;
        private static lowprimes;
        private static lplim;
        static staticConstructor(): void;
        private static fromInt(x);
        static ZERO: BigInteger;
        static ONE: BigInteger;
        readonly DV: number;
        readonly DB: number;
        readonly DM: number;
        private BI_FP;
        private readonly FV;
        private readonly F1;
        private readonly F2;
        t: number;
        s: number;
        am(i: number, x: number, w: BigInteger, j: number, c: number, n: number): number;
        static int2char(n: any): string;
        private int2char(n);
        private intAt(s, i);
        copyTo(r: BigInteger): void;
        private fromInt(x);
        static fromString(s: any, b?: number): BigInteger;
        fromString(s: any, b?: number): void;
        clamp(): void;
        toString(radix: number): string;
        private negate();
        abs(): BigInteger;
        compareTo(a: BigInteger): number;
        private nbits(x);
        bitLength(): number;
        dlShiftTo(n: number, r: BigInteger): void;
        drShiftTo(n: number, r: BigInteger): void;
        private lShiftTo(n, r);
        private rShiftTo(n, r);
        subTo(a: BigInteger, r: BigInteger): void;
        multiplyTo(a: BigInteger, r: BigInteger): void;
        squareTo(r: BigInteger): void;
        divRemTo(m: BigInteger, q: BigInteger, r: BigInteger): void;
        mod(a: BigInteger): BigInteger;
        invDigit(): number;
        private isEven();
        private exp(e, z);
        modPowInt(e: number, m: BigInteger): BigInteger;
        private clone();
        private intValue();
        private byteValue();
        private shortValue();
        private chunkSize(r);
        private signum();
        private toRadix(b);
        private fromRadix(s, b);
        static fromNumber(a: number, b: number, c: SecureRandom): BigInteger;
        fromNumber(a: number, b: number, c: SecureRandom): void;
        private fromNumber2(a, b);
        toByteArray(): number[];
        private bitwiseTo(a, op, r);
        private op_or(x, y);
        private shiftLeft(n);
        private shiftRight(n);
        private lbit(x);
        private getLowestSetBit();
        private testBit(n);
        private addTo(a, r);
        private add(a);
        subtract(a: BigInteger): BigInteger;
        multiply(a: BigInteger): BigInteger;
        square(): BigInteger;
        divide(a: any): BigInteger;
        private remainder(a);
        private multiply2(n);
        addOffset2(n: number, w: number): void;
        multiplyLowerTo(a: BigInteger, n: number, r: BigInteger): void;
        multiplyUpperTo(a: BigInteger, n: number, r: BigInteger): void;
        private modPow(e, m);
        gcd(a: BigInteger): BigInteger;
        private modInt(n);
        modInverse(m: BigInteger): BigInteger;
        isProbablePrime(t: any): boolean;
        private millerRabin(t);
    }
}
declare module Stimulsoft.System.Crypt {
    class RSAKey {
        private n;
        private e;
        private d;
        private p;
        private q;
        private dmp1;
        private dmq1;
        private coeff;
        verifyString(message: string, signature: string): boolean;
        private base64toHex(s);
        private parseBigInt(str, r);
        private pkcs1pad2(s, n);
        private pkcs1unpad2(d, n);
        setPublic(N: string, E: string): void;
        setPrivate(N: string, E: string, D: string): void;
        setPrivateEx(N: string, E: string, D: string, P: string, Q: string, DP: string, DQ: string, C: string): void;
        generate(B: number, E: string): void;
        doPublic(x: BigInteger): BigInteger;
        private doPrivate(x);
        encrypt(text: string): string;
        decrypt(ctext: string): string;
        constructor();
    }
}
declare module Stimulsoft.System.Crypt {
    class SHA1 {
        private blockLength;
        private state;
        private K;
        static signature: string;
        static hex(data: string): string;
        hex(data: string): string;
        private getMD(data);
        private rotl(v, s);
        private round(blk);
        private paddingData(datz);
        private toHex(decz);
        private fromBigEndian32(blk);
        private toBigEndian32(blk);
        private unpack(dat);
        private pack(ary);
    }
}
declare module Stimulsoft.System.Crypt {
    class SecureRandom {
        private state;
        private pool;
        private position;
        private seedInteger(x);
        private seedTime();
        private getByte();
        nextBytes(ba: number[]): void;
        constructor();
    }
}
declare module Stimulsoft.System.Data {
    class DataStorage {
        private _column;
        static createStorage(column: DataColumn, type: Type): DataStorage;
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
declare module Stimulsoft.System.Data {
    class BooleanStorage extends DataStorage {
        private static defaultValue;
        private values;
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
declare module Stimulsoft.System.Data {
    class ByteArrayStorage extends DataStorage {
        private values;
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
declare module Stimulsoft.System.Data {
    class CharStorage extends DataStorage {
        private values;
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
declare module Stimulsoft.System.Data {
    enum CommandType {
        Text = 1,
        StoredProcedure = 4,
        TableDirect = 512,
    }
}
declare module Stimulsoft.System.Data {
    class ConnectionState {
        static Closed: number;
        static Open: number;
        static Connecting: number;
        static Executing: number;
        static Fetching: number;
        static Broken: number;
    }
}
declare module Stimulsoft.System.Data {
    class DBNull {
        static value: DBNull;
    }
}
declare module Stimulsoft.System.Data {
    class DataColumn {
        clone(): DataColumn;
        private _storage;
        readonly storage: DataStorage;
        private _caption;
        caption: string;
        private _columnName;
        columnName: string;
        private _dataType;
        dataType: Type;
        private _table;
        table: DataTable;
        getRecord(record: number): any;
        setRecord(record: number, value: any): void;
        setTable(table: DataTable): void;
        private insureStorage();
        constructor(columnName: string, dataType?: Type, caption?: string);
    }
}
declare module Stimulsoft.System.Data {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class DataColumnCollection extends CollectionBase<DataColumn> {
        private _table;
        readonly table: DataTable;
        private baseAdd(column);
        private baseRemove(column);
        add(column: DataColumn): void;
        remove(column: DataColumn): void;
        getByName(name: string): DataColumn;
        getByIndex(index: number): DataColumn;
        getIndexByName(name: string): number;
        constructor(table: DataTable);
    }
}
declare module Stimulsoft.System.Data {
    class DataKey {
        private columns;
        readonly table: DataTable;
        readonly columnsReference: any[];
        getKeyValues(record: number): any[];
        getRows(values: any[]): any[];
        toArray(): any[];
        constructor(columns: DataColumn[], copyColumns: boolean);
    }
}
declare module Stimulsoft.System.Data {
    class DataRelation {
        private _childKey;
        readonly childKey: DataKey;
        private _parentKey;
        readonly parentKey: DataKey;
        private _dataSet;
        readonly dataSet: DataSet;
        private _relationName;
        relationName: string;
        readonly parentTable: DataTable;
        readonly childTable: DataTable;
        readonly parentColumns: any[];
        readonly childColumns: any[];
        private create(relationName, parentColumns, childColumns);
        setDataSet(dataSet: DataSet): void;
        static getChildRows(parentKey: DataKey, childKey: DataKey, parentRow: DataRow): any[];
        static getParentRows(parentKey: DataKey, childKey: DataKey, childRow: DataRow): any[];
        constructor(relationName: string, parentColumns: DataColumn[], childColumns: DataColumn[]);
    }
}
declare module Stimulsoft.System.Data {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class DataRelationCollection extends CollectionBase<DataRelation> {
        addCore(relation: DataRelation): void;
        add(relation: DataRelation): void;
        addRange(relations: any[]): void;
        internalIndexOf(name: string): number;
        contains(name: string): boolean;
        remove(relation: DataRelation): void;
        removeAt(index: number): void;
        getByName(name: string): DataRelation;
        getByIndex(index: number): DataRelation;
        getDataSet(): DataSet;
        constructor();
    }
}
declare module Stimulsoft.System.Data {
    class DataRow {
        recordIndex: number;
        static create(table: DataTable): DataRow;
        columns: DataColumnCollection;
        private _table;
        readonly table: DataTable;
        private getColumnIndex(column);
        gett(column: any): any;
        sett(column: any, value: any): void;
        /** Get DataRow value by column identificator **/
        getValue(column: any): any;
        /** Set DataRow value by column identificator **/
        setValue(column: any, value: any): void;
        /** Get DataRow value by column index **/
        getValueByIndex(columnIndex: number): any;
        /** Set DataRow value by column index **/
        setValueByIndex(columnIndex: number, value: any): void;
        getDataColumn(columnName: string): DataColumn;
        getChildRows(relationName: string): any[];
        getParentRow(relationName: string): DataRow;
        getParentRows(relationName: string): any[];
        getKeyValues(key: DataKey): any[];
    }
}
declare module Stimulsoft.System.Data {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class DataRowCollection extends CollectionBase<DataRow> {
        private _table;
        readonly table: DataTable;
        add(row: DataRow): number;
        remove(row: DataRow): void;
        addArray(row: DataRow): number;
        removeArray(row: DataRow): void;
        copyTo(array: any[], startIndex: number): void;
        private replaceValues(i, j);
        private quickSort(func, l, r);
        sort(...parameters: any[]): any;
        constructor(table: DataTable);
    }
}
declare module Stimulsoft.System.Text {
    class XMLConvert {
        static encodeName(name: string): string;
        static decodeName(name: string): string;
        private static fromHex(digit);
        private static toHex(digit);
    }
}
declare module Stimulsoft.System.Xml {
    class XmlNode {
        private _nodeName;
        nodeName: string;
        private _nodeType;
        nodeType: XmlNodeType;
        private _childNodes;
        childNodes: XmlNode[];
        private _localName;
        localName: string;
        private _textContent;
        textContent: string;
        readonly firstChild: XmlNode;
        private _attributes;
        attributes: XmlAttrCollection;
        private _parentNode;
        readonly parentNode: XmlNode;
        setParentNode(node: XmlNode): void;
        getAttribute(name?: string): string;
        item(index: number): XmlNode;
        getNodeByName(name?: string): XmlNode;
        getNodesByName(name?: string): XmlNode[];
    }
}
declare module Stimulsoft.System.Xml {
    enum XmlNodeType {
        ATTRIBUTE_NODE = 0,
        ELEMENT_NODE = 1,
        TEXT_NODE = 2,
        DOCUMENT_NODE = 3,
    }
}
declare module Stimulsoft.System.Xml {
    class XmlConverter {
        static toXml(xmlString: string): XmlNode;
        static toXml2(xmlString: string): XmlNode;
        private static toXmlNode2(xmlDocument);
        private static toXmlNode(xmlDocument);
        static getXmlDocumentFromString(xmlString: string): any;
        static getAttributesArray(xmlDocument: any): any[];
        static getNodeType2(xmlDocument: any): number;
        static getNodeType(xmlDocument: any): number;
        static getNodeName(xmlDocument: any): string;
        static getNodeLocalName2(xmlDocument: any): string;
        static getNodeLocalName(xmlDocument: any): string;
        static getNodeTextContent(xmlDocument: any): string;
        static getChildNodesArray(xmlDocument: any): any[];
    }
}
declare module Stimulsoft.System.Data {
    class DataSet {
        private dataNode;
        private schemaNode;
        private isRetrieveColumns;
        private _dataSetName;
        dataSetName: string;
        private _tables;
        tables: DataTableCollection;
        private _relations;
        readonly relations: DataRelationCollection;
        private _enforceConstraints;
        enforceConstraints: boolean;
        dispose(): void;
        private correctJsonString(json);
        private correctJson(json);
        readJsonFile(filePath: string): void;
        readJson(str: string): any;
        readJson(data: number[]): any;
        readJson(data2: Uint8Array): any;
        readJson(obj: Object): any;
        readXmlFile(filePath: string): void;
        readXml(str: string): any;
        readXml(data: number[]): any;
        readXml(data2: Uint8Array): any;
        readXml(obj: Object): any;
        readXmlSchemaFile(filePath: string): void;
        readXmlSchema(str: string): any;
        readXmlSchema(data: number[]): any;
        readXmlSchema(obj: Object): any;
        private processObject2(json);
        private processObject(obj, name);
        private processTable(ht, tableName);
        private processArray(array, tableName);
        private fillDataSet();
        /** Заполняем структуру всех таблиц из xml-файла */
        private fillDataTables();
        private fillDataTable(tableNode);
        /** Создаём структуру колонок таблицы из xml-файла */
        private getDataColumnsFromTable(dataColumnsNode, table);
        /** Создаём и заполняем таблицу и все вложенные таблицы данными */
        private fillTable(tableNode);
        /** Создаём и заполняем текущую строку данных таблицы */
        private fillRow(dataColumnsNode, table);
        private parseSchema();
        /** Читаем все таблицы и связи из xsd-схемы */
        private getDataTables(dataTablesNode);
        /** Вычисление типа данных для хранилища DataColumn */
        private getStorageType(typeName);
        /** Читаем все колонки для текущей таблицы из xsd-схемы */
        private getDataColumns(dataColumnsNode, table);
        /** Читаем все связи таблиц */
        private getRelations(relationNode);
        /** Ищем нужную таблицу по её имени */
        private findTable(name);
        /** Ищем колонки в таблице по заданным именам */
        private findColumn(names, table);
        constructor(dataSetName?: string);
    }
}
declare module Stimulsoft.System.Data {
    class DataSetRelationCollection extends DataRelationCollection {
        private dataSet;
        addCore(relation: DataRelation): void;
        getDataSet(): DataSet;
        constructor(dataSet: DataSet);
    }
}
declare module Stimulsoft.System.Data {
    class DataTable {
        private _needCleanCache;
        private _index;
        /** Cache for DataKey.GetRows method */
        readonly index: any[];
        private _columns;
        readonly columns: DataColumnCollection;
        private _rows;
        readonly rows: DataRowCollection;
        private _tableName;
        tableName: string;
        private _dataSet;
        readonly dataSet: DataSet;
        private _childRelationsCollection;
        readonly childRelations: DataRelationCollection;
        private _parentRelationsCollection;
        readonly parentRelations: DataRelationCollection;
        setDataSet(dataSet: DataSet): void;
        addRow(row: DataRow): number;
        removeRow(row: DataRow): void;
        addNewRow(): DataRow;
        private _extendedProperties;
        readonly extendedProperties: any;
        newRow(): DataRow;
        clone(): DataTable;
        constructor(tableName?: string);
    }
}
declare module Stimulsoft.System.Data {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class DataTableCollection extends CollectionBase<DataTable> {
        add(table: DataTable): void;
        remove(table: DataTable): void;
        private baseAdd(table);
        private baseRemove(table);
        private _dataSet;
        readonly dataSet: DataSet;
        getByName(name: string): DataTable;
        getByIndex(index: number): DataTable;
        private checkTableName(table);
        constructor(dataSet: DataSet);
    }
}
declare module Stimulsoft.System.Data {
    class DataTableRelationCollection extends DataRelationCollection {
        private table;
        private parentCollection;
        private addCache(relation);
        addCore(relation: DataRelation): void;
        getDataSet(): DataSet;
        constructor(table: DataTable, parentCollection: boolean);
    }
}
declare module Stimulsoft.System.Data {
    class DateTimeStorage extends DataStorage {
        private values;
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
declare module Stimulsoft.System.Data {
    class DecimalStorage extends DataStorage {
        private values;
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
declare module Stimulsoft.System.Data {
    var IDbConnection: string;
    interface IDbConnection {
    }
}
declare module Stimulsoft.System.Data {
    class Int32Storage extends DataStorage {
        private values;
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
declare module Stimulsoft.System.Data {
    class ObjectStorage extends DataStorage {
        private values;
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
declare module Stimulsoft.System.Data {
    enum StorageType {
        ObjectType = 1,
        BooleanType = 3,
        CharType = 4,
        SByteType = 5,
        ByteType = 6,
        Number16Type = 7,
        Unumber16Type = 8,
        NumberType = 9,
        Number32Type = 9,
        Unumber32Type = 10,
        Number64Type = 11,
        Unumber64Type = 12,
        SingleType = 13,
        DoubleType = 14,
        DecimalType = 15,
        DateTimeType = 16,
        TimeSpanType = 17,
        StringType = 18,
        GuidType = 19,
        ByteArrayType = 20,
        IntType = 30,
        Int16Type = 31,
        Int32Type = 32,
        Int64Type = 33,
        UInt16Type = 34,
        UInt32Type = 35,
        UInt64Type = 36,
    }
}
declare module Stimulsoft.System.Data {
    class StringStorage extends DataStorage {
        private values;
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
declare module Stimulsoft.System.Globalization {
    enum UnicodeCategory {
        /**
         * Uppercase letter. Signified by the Unicode designation "Lu" (letter, uppercase).
         * The value is 0.
         */
        UppercaseLetter = 0,
        /**
         * Lowercase letter. Signified by the Unicode designation "Ll" (letter, lowercase).
         * The value is 1.
         */
        LowercaseLetter = 1,
        /**
         * Titlecase letter. Signified by the Unicode designation "Lt" (letter, titlecase).
         * The value is 2.
         */
        TitlecaseLetter = 2,
        /**
         * Modifier letter character, which is free-standing spacing character that
         * indicates modifications of a preceding letter. Signified by the Unicode designation
         * "Lm" (letter, modifier). The value is 3.
         */
        ModifierLetter = 3,
        /**
         * Letter that is not an uppercase letter, a lowercase letter, a titlecase letter,
         * or a modifier letter. Signified by the Unicode designation "Lo" (letter,
         * other). The value is 4.
         */
        OtherLetter = 4,
        /**
         * Nonspacing character that indicates modifications of a base character. Signified
         * by the Unicode designation "Mn" (mark, nonspacing). The value is 5.
         */
        NonSpacingMark = 5,
        /**
         * Spacing character that indicates modifications of a base character and affects
         * the width of the glyph for that base character. Signified by the Unicode
         * designation "Mc" (mark, spacing combining). The value is 6.
         */
        SpacingCombiningMark = 6,
        /**
         * Enclosing mark character, which is a nonspacing combining character that
         * surrounds all previous characters up to and including a base character. Signified
         * by the Unicode designation "Me" (mark, enclosing). The value is 7.
         */
        EnclosingMark = 7,
        /**
         * Decimal digit character, that is, a character in the range 0 through 9. Signified
         * by the Unicode designation "Nd" (number, decimal digit). The value is 8.
         */
        DecimalDigitNumber = 8,
        /**
         * Number represented by a letter, instead of a decimal digit, for example,
         * the Roman numeral for five, which is "V". The indicator is signified by the
         * Unicode designation "Nl" (number, letter). The value is 9.
         */
        LetterNumber = 9,
        /**
         * Number that is neither a decimal digit nor a letter number, for example,
         * the fraction 1/2. The indicator is signified by the Unicode designation "No"
         * (number, other). The value is 10.
         */
        OtherNumber = 10,
        /**
         * Space character, which has no glyph but is not a control or format character.
         * Signified by the Unicode designation "Zs" (separator, space). The value is 11.
         */
        SpaceSeparator = 11,
        /**
         * Character that is used to separate lines of text. Signified by the Unicode
         * designation "Zl" (separator, line). The value is 12.
         */
        LineSeparator = 12,
        /**
         * Character used to separate paragraphs. Signified by the Unicode designation
         * "Zp" (separator, paragraph). The value is 13.
         */
        ParagraphSeparator = 13,
        /**
         * Control code character, with a Unicode value of U+007F or in the range U+0000
         * through U+001F or U+0080 through U+009F. Signified by the Unicode designation
         * "Cc" (other, control). The value is 14.
         */
        Control = 14,
        /**
         * Format character that affects the layout of text or the operation of text
         * processes, but is not normally rendered. Signified by the Unicode designation
         * "Cf" (other, format). The value is 15.
         */
        Format = 15,
        /**
         * High surrogate or a low surrogate character. Surrogate code values are in
         * the range U+D800 through U+DFFF. Signified by the Unicode designation "Cs"
         * (other, surrogate). The value is 16.
         */
        Surrogate = 16,
        /**
         * Private-use character, with a Unicode value in the range U+E000 through U+F8FF.
         * Signified by the Unicode designation "Co" (other, private use). The value is 17.
         */
        PrivateUse = 17,
        /**
         * Connector punctuation character that connects two characters. Signified by
         * the Unicode designation "Pc" (punctuation, connector). The value is 18.
         */
        ConnectorPunctuation = 18,
        /**
         * Dash or hyphen character. Signified by the Unicode designation "Pd" (punctuation,
         * dash). The value is 19.
         */
        DashPunctuation = 19,
        /**
         * Opening character of one of the paired punctuation marks, such as parentheses,
         * square brackets, and braces. Signified by the Unicode designation "Ps" (punctuation,
         * open). The value is 20.
         */
        OpenPunctuation = 20,
        /**
         * Closing character of one of the paired punctuation marks, such as parentheses,
         * square brackets, and braces. Signified by the Unicode designation "Pe" (punctuation,
         * close). The value is 21.
         */
        ClosePunctuation = 21,
        /**
         * Opening or initial quotation mark character. Signified by the Unicode designation
         * "Pi" (punctuation, initial quote). The value is 22.
         */
        InitialQuotePunctuation = 22,
        /**
         * Closing or final quotation mark character. Signified by the Unicode designation
         * "Pf" (punctuation, final quote). The value is 23.
         */
        FinalQuotePunctuation = 23,
        /**
         * Punctuation character that is not a connector, a dash, open punctuation,
         * close punctuation, an initial quote, or a final quote. Signified by the Unicode
         * designation "Po" (punctuation, other). The value is 24.
         */
        OtherPunctuation = 24,
        /**
         * Mathematical symbol character, such as "+" or "= ". Signified by the Unicode
         * designation "Sm" (symbol, math). The value is 25.
         */
        MathSymbol = 25,
        /**
         * Currency symbol character. Signified by the Unicode designation "Sc" (symbol,
         * currency). The value is 26.
         */
        CurrencySymbol = 26,
        /**
         * Modifier symbol character, which indicates modifications of surrounding characters.
         * For example, the fraction slash indicates that the number to the left is
         * the numerator and the number to the right is the denominator. The indicator
         * is signified by the Unicode designation "Sk" (symbol, modifier). The value is 27.
         */
        ModifierSymbol = 27,
        /**
         * Symbol character that is not a mathematical symbol, a currency symbol or
         * a modifier symbol. Signified by the Unicode designation "So" (symbol, other).
         * The value is 28.
         */
        OtherSymbol = 28,
        /**
         * Character that is not assigned to any Unicode category. Signified by the
         * Unicode designation "Cn" (other, not assigned). The value is 29.
         */
        OtherNotAssigned = 29,
    }
}
declare module Stimulsoft.System {
    class Char {
        static isUpper(char: string, index?: number): boolean;
        static isLower(char: string, index?: number): boolean;
        static isLetter(char: string, index?: number): boolean;
        static isDigit(char: string, index?: number): boolean;
        static isLetterOrDigit(char: string, index?: number): boolean;
        static toLower(char: string): string;
        static toUpper(char: string): string;
        static isWhitespace(char: string, index?: number, allowNbsp?: boolean): boolean;
        private static checkLetter(uc);
        static getUnicodeCategory(char: string, index?: number): number;
        static isControl(char: string, index?: number): boolean;
    }
}
declare module Stimulsoft.System {
    class TimeSpan {
        static ticksPerMillisecond: number;
        private static millisecondsPerTick;
        static ticksPerSecond: number;
        private static secondsPerTick;
        static ticksPerMinute: number;
        private static minutesPerTick;
        static ticksPerHour: number;
        private static hoursPerTick;
        static ticksPerDay: number;
        private static daysPerTick;
        private static millisPerSecond;
        private static millisPerMinute;
        private static millisPerHour;
        private static millisPerDay;
        static maxSeconds: number;
        static minSeconds: number;
        static maxMilliSeconds: number;
        static minMilliSeconds: number;
        static ticksPerTenthSecond: number;
        static readonly zero: TimeSpan;
        static getStiNetTypeName(): string;
        private static _minValue;
        static readonly minValue: TimeSpan;
        private static _maxValue;
        static readonly maxValue: TimeSpan;
        private _ticks;
        readonly ticks: number;
        readonly days: number;
        readonly hours: number;
        readonly milliseconds: number;
        readonly minutes: number;
        readonly seconds: number;
        readonly totalDays: number;
        readonly totalHours: number;
        readonly totalMilliseconds: number;
        readonly totalMinutes: number;
        readonly totalSeconds: number;
        static fromString(value: string, format?: string): TimeSpan;
        private static interval(value, scale);
        static fromTicks(value: number): TimeSpan;
        static fromSeconds(value: number): TimeSpan;
        static fromMilliseconds(value: number): TimeSpan;
        add(value: number): TimeSpan;
        add2(value: TimeSpan): TimeSpan;
        toString(format?: string): string;
        negate(): TimeSpan;
        private static timeToTicks(hour, minute, second, milliseconds);
        constructor(param1?: number, minutes?: number, seconds?: number, milliseconds?: number);
    }
}
declare module Stimulsoft.System.Data {
    class TimeSpanStorage extends DataStorage {
        private values;
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
declare module Stimulsoft.System.Drawing.Drawing2D {
    enum DashStyle {
        Solid = 0,
        Dash = 1,
        Dot = 2,
        DashDot = 3,
        DashDotDot = 4,
        Custom = 5,
    }
}
declare module Stimulsoft.System.Drawing.Drawing2D {
    enum HatchStyle {
        /** Specifies hatch style Stimulsoft.System.Drawing.Drawing2D.HatchStyle.Horizontal. */
        Min = 0,
        /** A pattern of horizontal lines. */
        Horizontal = 0,
        /** A pattern of vertical lines. */
        Vertical = 1,
        /** A pattern of lines on a diagonal from upper left to lower right. */
        ForwardDiagonal = 2,
        /** A pattern of lines on a diagonal from upper right to lower left. */
        BackwardDiagonal = 3,
        /** Specifies hatch style Stimulsoft.System.Drawing.Drawing2D.HatchStyle.SolidDiamond. */
        Max = 4,
        /** Specifies horizontal and vertical lines that cross. */
        Cross = 4,
        /** Specifies the hatch style Stimulsoft.System.Drawing.Drawing2D.HatchStyle.Cross. */
        LargeGrid = 4,
        /** A pattern of crisscross diagonal lines. */
        DiagonalCross = 5,
        /** Specifies a 5-percent hatch. The ratio of foreground color to background color is 5:95. */
        Percent05 = 6,
        /** Specifies a 10-percent hatch. The ratio of foreground color to background color is 10:90. */
        Percent10 = 7,
        /** Specifies a 20-percent hatch. The ratio of foreground color to background color is 20:80. */
        Percent20 = 8,
        /** Specifies a 25-percent hatch. The ratio of foreground color to background color is 25:75. */
        Percent25 = 9,
        /** Specifies a 30-percent hatch. The ratio of foreground color to background color is 30:70. */
        Percent30 = 10,
        /** Specifies a 40-percent hatch. The ratio of foreground color to background color is 40:60. */
        Percent40 = 11,
        /** Specifies a 50-percent hatch. The ratio of foreground color to background color is 50:50. */
        Percent50 = 12,
        /** Specifies a 60-percent hatch. The ratio of foreground color to background color is 60:40. */
        Percent60 = 13,
        /** Specifies a 70-percent hatch. The ratio of foreground color to background color is 70:30. */
        Percent70 = 14,
        /** Specifies a 75-percent hatch. The ratio of foreground color to background color is 75:25. */
        Percent75 = 15,
        /** Specifies a 80-percent hatch. The ratio of foreground color to background color is 80:100. */
        Percent80 = 16,
        /** Specifies a 90-percent hatch. The ratio of foreground color to background color is 90:10. */
        Percent90 = 17,
        /**
         * Specifies diagonal lines that slant to the right from top points to bottom
         * points and are spaced 50 percent closer together than Stimulsoft.System.Drawing.Drawing2D.HatchStyle.ForwardDiagonal,
         * but are not antialiased.
         */
        LightDownwardDiagonal = 18,
        /**
         * Specifies diagonal lines that slant to the left from top points to bottom
         * points and are spaced 50 percent closer together than Stimulsoft.System.Drawing.Drawing2D.HatchStyle.BackwardDiagonal,
         * but they are not antialiased.
         */
        LightUpwardDiagonal = 19,
        /**
         * Specifies diagonal lines that slant to the right from top points to bottom
         * points, are spaced 50 percent closer together than, and are twice the width
         * of Stimulsoft.System.Drawing.Drawing2D.HatchStyle.ForwardDiagonal. This hatch pattern
         * is not antialiased.
         */
        DarkDownwardDiagonal = 20,
        /**
         * Specifies diagonal lines that slant to the left from top points to bottom
         * points, are spaced 50 percent closer together than Stimulsoft.System.Drawing.Drawing2D.HatchStyle.BackwardDiagonal,
         * and are twice its width, but the lines are not antialiased.
         */
        DarkUpwardDiagonal = 21,
        /**
         * Specifies diagonal lines that slant to the right from top points to bottom
         * points, have the same spacing as hatch style Stimulsoft.System.Drawing.Drawing2D.HatchStyle.ForwardDiagonal,
         * and are triple its width, but are not antialiased.
         */
        WideDownwardDiagonal = 22,
        /**
         * Specifies diagonal lines that slant to the left from top points to bottom
         * points, have the same spacing as hatch style Stimulsoft.System.Drawing.Drawing2D.HatchStyle.BackwardDiagonal,
         * and are triple its width, but are not antialiased.
         */
        WideUpwardDiagonal = 23,
        /** Specifies vertical lines that are spaced 50 percent closer together than Stimulsoft.System.Drawing.Drawing2D.HatchStyle.Vertical. */
        LightVertical = 24,
        /** Specifies horizontal lines that are spaced 50 percent closer together than Stimulsoft.System.Drawing.Drawing2D.HatchStyle.Horizontal. */
        LightHorizontal = 25,
        /**
         * Specifies vertical lines that are spaced 75 percent closer together than
         * hatch style Stimulsoft.System.Drawing.Drawing2D.HatchStyle.Vertical (or 25 percent closer
         * together than Stimulsoft.System.Drawing.Drawing2D.HatchStyle.LightVertical).
         */
        NarrowVertical = 26,
        /**
         * Specifies horizontal lines that are spaced 75 percent closer together than
         * hatch style Stimulsoft.System.Drawing.Drawing2D.HatchStyle.Horizontal (or 25 percent
         * closer together than Stimulsoft.System.Drawing.Drawing2D.HatchStyle.LightHorizontal).
         */
        NarrowHorizontal = 27,
        /** Specifies vertical lines that are spaced 50 percent closer together than Stimulsoft.System.Drawing.Drawing2D.HatchStyle.Vertical and are twice its width. */
        DarkVertical = 28,
        /**
         * Specifies horizontal lines that are spaced 50 percent closer together than
         * Stimulsoft.System.Drawing.Drawing2D.HatchStyle.Horizontal and are twice the width of
         * Stimulsoft.System.Drawing.Drawing2D.HatchStyle.Horizontal.
         */
        DarkHorizontal = 29,
        /** Specifies dashed diagonal lines, that slant to the right from top points to bottom points. */
        DashedDownwardDiagonal = 30,
        /** Specifies dashed diagonal lines, that slant to the left from top points to bottom points. */
        DashedUpwardDiagonal = 31,
        /** Specifies dashed horizontal lines. */
        DashedHorizontal = 32,
        /** Specifies dashed vertical lines. */
        DashedVertical = 33,
        /** Specifies a hatch that has the appearance of confetti. */
        SmallConfetti = 34,
        /**
         * Specifies a hatch that has the appearance of confetti, and is composed of
         * larger pieces than Stimulsoft.System.Drawing.Drawing2D.HatchStyle.SmallConfetti.
         */
        LargeConfetti = 35,
        /** Specifies horizontal lines that are composed of zigzags. */
        ZigZag = 36,
        /** Specifies horizontal lines that are composed of tildes. */
        Wave = 37,
        /** Specifies a hatch that has the appearance of layered bricks that slant to the left from top points to bottom points. */
        DiagonalBrick = 38,
        /** Specifies a hatch that has the appearance of horizontally layered bricks. */
        HorizontalBrick = 39,
        /** Specifies a hatch that has the appearance of a woven material. */
        Weave = 40,
        /** Specifies a hatch that has the appearance of a plaid material. */
        Plaid = 41,
        /** Specifies a hatch that has the appearance of divots. */
        Divot = 42,
        /** Specifies horizontal and vertical lines, each of which is composed of dots, that cross. */
        DottedGrid = 43,
        /** Specifies forward diagonal and backward diagonal lines, each of which is composed of dots, that cross. */
        DottedDiamond = 44,
        /** Specifies a hatch that has the appearance of diagonally layered shingles that slant to the right from top points to bottom points. */
        Shingle = 45,
        /** Specifies a hatch that has the appearance of a trellis. */
        Trellis = 46,
        /** Specifies a hatch that has the appearance of spheres laid adjacent to one another. */
        Sphere = 47,
        /**
         * Specifies horizontal and vertical lines that cross and are spaced 50 percent
         * closer together than hatch style Stimulsoft.System.Drawing.Drawing2D.HatchStyle.Cross.
         */
        SmallGrid = 48,
        /** Specifies a hatch that has the appearance of a checkerboard. */
        SmallCheckerBoard = 49,
        /**
         * Specifies a hatch that has the appearance of a checkerboard with squares
         * that are twice the size of Stimulsoft.System.Drawing.Drawing2D.HatchStyle.SmallCheckerBoard.
         */
        LargeCheckerBoard = 50,
        /** Specifies forward diagonal and backward diagonal lines that cross but are not antialiased. */
        OutlinedDiamond = 51,
        /** Specifies a hatch that has the appearance of a checkerboard placed diagonally. */
        SolidDiamond = 52,
    }
}
declare module Stimulsoft.System.Drawing.Drawing2D {
    enum LineCap {
        AnchorMask = 240,
        ArrowAnchor = 20,
        Custom = 255,
        DiamondAnchor = 19,
        Flat = 0,
        NoAnchor = 16,
        Round = 2,
        RoundAnchor = 18,
        Square = 1,
        SquareAnchor = 17,
        Triangle = 3,
    }
}
declare module Stimulsoft.System.Drawing.Drawing2D {
    import Point = Stimulsoft.System.Drawing.Point;
    class Matrix {
        a: number;
        c: number;
        b: number;
        d: number;
        tx: number;
        ty: number;
        readonly elements: number[];
        constructor(...arg: any[]);
        private setValues(a, c, b, d, tx, ty);
        private reset();
        clone(): Matrix;
        toString(): string;
        translate(x: number, y: number): Matrix;
        scale(scaleX: number, scaleY: number): Matrix;
        rotate(angle: number): Matrix;
        isIdentity(): boolean;
        transformPoints(points: Point[]): void;
        multiply(matrix2: Matrix): this;
    }
}
declare module Stimulsoft.System.Drawing.Imaging {
    enum EncoderValue {
        ColorTypeCMYK = 0,
        ColorTypeYCCK = 1,
        CompressionLZW = 2,
        CompressionCCITT3 = 3,
        CompressionCCITT4 = 4,
        CompressionRle = 5,
        CompressionNone = 6,
        ScanMethodInterlaced = 7,
        ScanMethodNonInterlaced = 8,
        VersionGif87 = 9,
        VersionGif89 = 10,
        RenderProgressive = 11,
        RenderNonProgressive = 12,
        TransformRotate90 = 13,
        TransformRotate180 = 14,
        TransformRotate270 = 15,
        TransformFlipHorizontal = 16,
        TransformFlipVertical = 17,
        MultiFrame = 18,
        LastFrame = 19,
        Flush = 20,
        FrameDimensionTime = 21,
        FrameDimensionResolution = 22,
        FrameDimensionPage = 23,
    }
}
declare module Stimulsoft.System.Drawing.Imaging {
    class ImageCodecInfo {
        clsid: Guid;
        codecName: string;
        filenameExtension: string;
        formatDescription: string;
        formatID: Guid;
        mimeType: string;
        version: number;
        static getImageDecoders(): ImageCodecInfo[];
        static getImageEncoders(): ImageCodecInfo[];
    }
}
declare module Stimulsoft.System.Drawing.Imaging {
    class ImageFormat {
        private static _tiff;
        static readonly Tiff: ImageFormat;
        private static _png;
        static readonly Png: ImageFormat;
        private static _gif;
        static readonly Gif: ImageFormat;
        private static _jpeg;
        static readonly Jpeg: ImageFormat;
        private static _bmp;
        static readonly Bmp: ImageFormat;
        private static _svg;
        static readonly Svg: ImageFormat;
        static getImageFormat(dataBytes: number[]): ImageFormat;
        private header;
        private guid;
        private checkHeader(dataBytes);
        getWidth(dataBytes: number[], base64?: string): number;
        getHeight(dataBytes: number[], base64?: string): number;
        getHorizontalResolution(dataBytes: number[]): number;
        getVerticalResolution(dataBytes: number[]): number;
        readonly mimeType: string;
        toString(): string;
        constructor(guid: string);
    }
}
declare module Stimulsoft.System.Drawing.Printing.PrinterSettings {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class PaperSizeCollection extends CollectionBase<PaperSize> {
        add(paperSize: PaperSize): void;
    }
}
declare module Stimulsoft.System.Drawing.Printing.PrinterSettings {
    class PrinterSettings {
        readonly paperSizes: PaperSizeCollection;
    }
}
declare module Stimulsoft.System.Drawing.Printing {
    enum PaperKind {
        A2 = 66,
        A3 = 8,
        A3Extra = 63,
        A3ExtraTransverse = 68,
        A3Rotated = 76,
        A3Transverse = 67,
        A4 = 9,
        A4Extra = 53,
        A4Plus = 60,
        A4Rotated = 77,
        A4Small = 10,
        A4Transverse = 55,
        A5 = 11,
        A5Extra = 64,
        A5Rotated = 78,
        A5Transverse = 61,
        A6 = 70,
        A6Rotated = 83,
        APlus = 57,
        B4 = 12,
        B4Envelope = 33,
        B4JisRotated = 79,
        B5 = 13,
        B5Envelope = 34,
        B5Extra = 65,
        B5JisRotated = 80,
        B5Transverse = 62,
        B6Envelope = 35,
        B6Jis = 88,
        B6JisRotated = 89,
        BPlus = 58,
        C3Envelope = 29,
        C4Envelope = 30,
        C5Envelope = 28,
        C65Envelope = 32,
        C6Envelope = 31,
        CSheet = 24,
        Custom = 0,
        DLEnvelope = 27,
        DSheet = 25,
        ESheet = 26,
        Executive = 7,
        Folio = 14,
        GermanLegalFanfold = 41,
        GermanStandardFanfold = 40,
        InviteEnvelope = 47,
        IsoB4 = 42,
        ItalyEnvelope = 36,
        JapaneseDoublePostcard = 69,
        JapaneseDoublePostcardRotated = 82,
        JapaneseEnvelopeChouNumber3 = 73,
        JapaneseEnvelopeChouNumber3Rotated = 86,
        JapaneseEnvelopeChouNumber4 = 74,
        JapaneseEnvelopeChouNumber4Rotated = 87,
        JapaneseEnvelopeKakuNumber2 = 71,
        JapaneseEnvelopeKakuNumber2Rotated = 84,
        JapaneseEnvelopeKakuNumber3 = 72,
        JapaneseEnvelopeKakuNumber3Rotated = 85,
        JapaneseEnvelopeYouNumber4 = 91,
        JapaneseEnvelopeYouNumber4Rotated = 92,
        JapanesePostcard = 43,
        JapanesePostcardRotated = 81,
        Ledger = 4,
        Legal = 5,
        LegalExtra = 51,
        Letter = 1,
        LetterExtra = 50,
        LetterExtraTransverse = 56,
        LetterPlus = 59,
        LetterRotated = 75,
        LetterSmall = 2,
        LetterTransverse = 54,
        MonarchEnvelope = 37,
        Note = 18,
        Number10Envelope = 20,
        Number11Envelope = 21,
        Number12Envelope = 22,
        Number14Envelope = 23,
        Number9Envelope = 19,
        PersonalEnvelope = 38,
        Prc16K = 93,
        Prc16KRotated = 106,
        Prc32K = 94,
        Prc32KBig = 95,
        Prc32KBigRotated = 108,
        Prc32KRotated = 107,
        PrcEnvelopeNumber1 = 96,
        PrcEnvelopeNumber10 = 105,
        PrcEnvelopeNumber10Rotated = 118,
        PrcEnvelopeNumber1Rotated = 109,
        PrcEnvelopeNumber2 = 97,
        PrcEnvelopeNumber2Rotated = 110,
        PrcEnvelopeNumber3 = 98,
        PrcEnvelopeNumber3Rotated = 111,
        PrcEnvelopeNumber4 = 99,
        PrcEnvelopeNumber4Rotated = 112,
        PrcEnvelopeNumber5 = 100,
        PrcEnvelopeNumber5Rotated = 113,
        PrcEnvelopeNumber6 = 101,
        PrcEnvelopeNumber6Rotated = 114,
        PrcEnvelopeNumber7 = 102,
        PrcEnvelopeNumber7Rotated = 115,
        PrcEnvelopeNumber8 = 103,
        PrcEnvelopeNumber8Rotated = 116,
        PrcEnvelopeNumber9 = 104,
        PrcEnvelopeNumber9Rotated = 117,
        Quarto = 15,
        Standard10x11 = 45,
        Standard10x14 = 16,
        Standard11x17 = 17,
        Standard12x11 = 90,
        Standard15x11 = 46,
        Standard9x11 = 44,
        Statement = 6,
        Tabloid = 3,
        TabloidExtra = 52,
        USStandardFanfold = 39,
    }
}
declare module Stimulsoft.System.Drawing.Printing {
    class PaperSize {
        private createdByDefaultConstructor;
        private _kind;
        readonly kind: number;
        private _name;
        name: string;
        private _width;
        width: number;
        private _height;
        height: number;
        constructor(kind?: number, name?: string, width?: number, height?: number);
    }
}
declare module Stimulsoft.System.Drawing.Printing {
    enum PrinterUnit {
        Display = 0,
        ThousandthsOfAnInch = 1,
        HundredthsOfAMillimeter = 2,
        TenthsOfAMillimeter = 3,
    }
}
declare module Stimulsoft.System.Drawing.Printing {
    class PrinterUnitConvert {
        static convert(value: number, fromUnit: PrinterUnit, toUnit: PrinterUnit): number;
        private static unitsPerDisplay(unit);
    }
}
declare module Stimulsoft.System.Drawing.Text {
    enum HotkeyPrefix {
        Hide = 0,
        None = 1,
        Show = 2,
    }
}
declare module Stimulsoft.System.Drawing {
    class Brush {
    }
}
declare module Stimulsoft.System.Drawing {
    class Brushes {
        static readonly aliceBlue: Brush;
        static readonly antiqueWhite: Brush;
        static readonly aqua: Brush;
        static readonly aquamarine: Brush;
        static readonly azure: Brush;
        static readonly beige: Brush;
        static readonly bisque: Brush;
        static readonly black: Brush;
        static readonly blanchedAlmond: Brush;
        static readonly blue: Brush;
        static readonly blueViolet: Brush;
        static readonly brown: Brush;
        static readonly burlyWood: Brush;
        static readonly cadetBlue: Brush;
        static readonly chartreuse: Brush;
        static readonly chocolate: Brush;
        static readonly coral: Brush;
        static readonly cornflowerBlue: Brush;
        static readonly cornsilk: Brush;
        static readonly crimson: Brush;
        static readonly cyan: Brush;
        static readonly darkBlue: Brush;
        static readonly darkCyan: Brush;
        static readonly darkGoldenrod: Brush;
        static readonly darkGray: Brush;
        static readonly darkGreen: Brush;
        static readonly darkKhaki: Brush;
        static readonly darkMagenta: Brush;
        static readonly darkOliveGreen: Brush;
        static readonly darkOrange: Brush;
        static readonly darkOrchid: Brush;
        static readonly darkRed: Brush;
        static readonly darkSalmon: Brush;
        static readonly darkSeaGreen: Brush;
        static readonly darkSlateBlue: Brush;
        static readonly darkSlateGray: Brush;
        static readonly darkTurquoise: Brush;
        static readonly darkViolet: Brush;
        static readonly deepPink: Brush;
        static readonly deepSkyBlue: Brush;
        static readonly dimGray: Brush;
        static readonly dodgerBlue: Brush;
        static readonly firebrick: Brush;
        static readonly floralWhite: Brush;
        static readonly forestGreen: Brush;
        static readonly fuchsia: Brush;
        static readonly gainsboro: Brush;
        static readonly ghostWhite: Brush;
        static readonly gold: Brush;
        static readonly goldenrod: Brush;
        static readonly gray: Brush;
        static readonly green: Brush;
        static readonly greenYellow: Brush;
        static readonly honeydew: Brush;
        static readonly hotPink: Brush;
        static readonly indianRed: Brush;
        static readonly indigo: Brush;
        static readonly ivory: Brush;
        static readonly khaki: Brush;
        static readonly lavender: Brush;
        static readonly lavenderBlush: Brush;
        static readonly lawnGreen: Brush;
        static readonly lemonChiffon: Brush;
        static readonly lightBlue: Brush;
        static readonly lightCoral: Brush;
        static readonly lightCyan: Brush;
        static readonly lightGoldenrodYellow: Brush;
        static readonly lightGray: Brush;
        static readonly lightGreen: Brush;
        static readonly lightPink: Brush;
        static readonly lightSalmon: Brush;
        static readonly lightSeaGreen: Brush;
        static readonly lightSkyBlue: Brush;
        static readonly lightSlateGray: Brush;
        static readonly lightSteelBlue: Brush;
        static readonly lightYellow: Brush;
        static readonly lime: Brush;
        static readonly limeGreen: Brush;
        static readonly linen: Brush;
        static readonly magenta: Brush;
        static readonly maroon: Brush;
        static readonly mediumAquamarine: Brush;
        static readonly mediumBlue: Brush;
        static readonly mediumOrchid: Brush;
        static readonly mediumPurple: Brush;
        static readonly mediumSeaGreen: Brush;
        static readonly mediumSlateBlue: Brush;
        static readonly mediumSpringGreen: Brush;
        static readonly mediumTurquoise: Brush;
        static readonly mediumVioletRed: Brush;
        static readonly midnightBlue: Brush;
        static readonly mintCream: Brush;
        static readonly mistyRose: Brush;
        static readonly moccasin: Brush;
        static readonly navajoWhite: Brush;
        static readonly navy: Brush;
        static readonly oldLace: Brush;
        static readonly olive: Brush;
        static readonly oliveDrab: Brush;
        static readonly orange: Brush;
        static readonly orangeRed: Brush;
        static readonly orchid: Brush;
        static readonly paleGoldenrod: Brush;
        static readonly paleGreen: Brush;
        static readonly paleTurquoise: Brush;
        static readonly paleVioletRed: Brush;
        static readonly papayaWhip: Brush;
        static readonly peachPuff: Brush;
        static readonly peru: Brush;
        static readonly pink: Brush;
        static readonly plum: Brush;
        static readonly powderBlue: Brush;
        static readonly purple: Brush;
        static readonly red: Brush;
        static readonly rosyBrown: Brush;
        static readonly royalBlue: Brush;
        static readonly saddleBrown: Brush;
        static readonly salmon: Brush;
        static readonly sandyBrown: Brush;
        static readonly seaGreen: Brush;
        static readonly seaShell: Brush;
        static readonly sienna: Brush;
        static readonly silver: Brush;
        static readonly skyBlue: Brush;
        static readonly slateBlue: Brush;
        static readonly slateGray: Brush;
        static readonly snow: Brush;
        static readonly springGreen: Brush;
        static readonly steelBlue: Brush;
        static readonly tan: Brush;
        static readonly teal: Brush;
        static readonly thistle: Brush;
        static readonly tomato: Brush;
        static readonly turquoise: Brush;
        static readonly violet: Brush;
        static readonly wheat: Brush;
        static readonly white: Brush;
        static readonly whiteSmoke: Brush;
        static readonly yellow: Brush;
        static readonly yellowGreen: Brush;
    }
}
declare module Stimulsoft.System.Drawing {
    class Color {
        static readonly aliceBlue: Color;
        static readonly antiqueWhite: Color;
        static readonly aqua: Color;
        static readonly aquamarine: Color;
        static readonly azure: Color;
        static readonly beige: Color;
        static readonly bisque: Color;
        static readonly black: Color;
        static readonly blanchedAlmond: Color;
        static readonly blue: Color;
        static readonly blueViolet: Color;
        static readonly brown: Color;
        static readonly burlyWood: Color;
        static readonly cadetBlue: Color;
        static readonly chartreuse: Color;
        static readonly chocolate: Color;
        static readonly coral: Color;
        static readonly cornflowerBlue: Color;
        static readonly cornsilk: Color;
        static readonly crimson: Color;
        static readonly cyan: Color;
        static readonly darkBlue: Color;
        static readonly darkCyan: Color;
        static readonly darkGoldenrod: Color;
        static readonly darkGray: Color;
        static readonly darkGreen: Color;
        static readonly darkKhaki: Color;
        static readonly darkMagenta: Color;
        static readonly darkOliveGreen: Color;
        static readonly darkOrange: Color;
        static readonly darkOrchid: Color;
        static readonly darkRed: Color;
        static readonly darkSalmon: Color;
        static readonly darkSeaGreen: Color;
        static readonly darkSlateBlue: Color;
        static readonly darkSlateGray: Color;
        static readonly darkTurquoise: Color;
        static readonly darkViolet: Color;
        static readonly deepPink: Color;
        static readonly deepSkyBlue: Color;
        static readonly dimGray: Color;
        static readonly dodgerBlue: Color;
        static readonly firebrick: Color;
        static readonly floralWhite: Color;
        static readonly forestGreen: Color;
        static readonly fuchsia: Color;
        static readonly gainsboro: Color;
        static readonly ghostWhite: Color;
        static readonly gold: Color;
        static readonly goldenrod: Color;
        static readonly gray: Color;
        static readonly green: Color;
        static readonly greenYellow: Color;
        static readonly honeydew: Color;
        static readonly hotPink: Color;
        static readonly indianRed: Color;
        static readonly indigo: Color;
        static readonly ivory: Color;
        static readonly khaki: Color;
        static readonly lavender: Color;
        static readonly lavenderBlush: Color;
        static readonly lawnGreen: Color;
        static readonly lemonChiffon: Color;
        static readonly lightBlue: Color;
        static readonly lightCoral: Color;
        static readonly lightCyan: Color;
        static readonly lightGoldenrodYellow: Color;
        static readonly lightGray: Color;
        static readonly lightGreen: Color;
        static readonly lightPink: Color;
        static readonly lightSalmon: Color;
        static readonly lightSeaGreen: Color;
        static readonly lightSkyBlue: Color;
        static readonly lightSlateGray: Color;
        static readonly lightSteelBlue: Color;
        static readonly lightYellow: Color;
        static readonly lime: Color;
        static readonly limeGreen: Color;
        static readonly linen: Color;
        static readonly magenta: Color;
        static readonly maroon: Color;
        static readonly mediumAquamarine: Color;
        static readonly mediumBlue: Color;
        static readonly mediumOrchid: Color;
        static readonly mediumPurple: Color;
        static readonly mediumSeaGreen: Color;
        static readonly mediumSlateBlue: Color;
        static readonly mediumSpringGreen: Color;
        static readonly mediumTurquoise: Color;
        static readonly mediumVioletRed: Color;
        static readonly midnightBlue: Color;
        static readonly mintCream: Color;
        static readonly mistyRose: Color;
        static readonly moccasin: Color;
        static readonly navajoWhite: Color;
        static readonly navy: Color;
        static readonly oldLace: Color;
        static readonly olive: Color;
        static readonly oliveDrab: Color;
        static readonly orange: Color;
        static readonly orangeRed: Color;
        static readonly orchid: Color;
        static readonly paleGoldenrod: Color;
        static readonly paleGreen: Color;
        static readonly paleTurquoise: Color;
        static readonly paleVioletRed: Color;
        static readonly papayaWhip: Color;
        static readonly peachPuff: Color;
        static readonly peru: Color;
        static readonly pink: Color;
        static readonly plum: Color;
        static readonly powderBlue: Color;
        static readonly purple: Color;
        static readonly red: Color;
        static readonly rosyBrown: Color;
        static readonly royalBlue: Color;
        static readonly saddleBrown: Color;
        static readonly salmon: Color;
        static readonly sandyBrown: Color;
        static readonly seaGreen: Color;
        static readonly seaShell: Color;
        static readonly sienna: Color;
        static readonly silver: Color;
        static readonly skyBlue: Color;
        static readonly slateBlue: Color;
        static readonly slateGray: Color;
        static readonly snow: Color;
        static readonly springGreen: Color;
        static readonly steelBlue: Color;
        static readonly tan: Color;
        static readonly teal: Color;
        static readonly thistle: Color;
        static readonly tomato: Color;
        static readonly turquoise: Color;
        static readonly violet: Color;
        static readonly wheat: Color;
        static readonly white: Color;
        static readonly whiteSmoke: Color;
        static readonly yellow: Color;
        static readonly yellowGreen: Color;
        static readonly transparent: Color;
        static readonly empty: Color;
        static fromName(name: string): Color;
        private _a;
        a: number;
        private _r;
        r: number;
        private _g;
        g: number;
        private _b;
        b: number;
        private static customName;
        name: string;
        readonly isNamedColor: boolean;
        stiEquals(color: Color): boolean;
        toString(): string;
        static fromArgb(alpha: number, baseColor: Color): Color;
        static fromArgb(red: number, green: number, blue: number): Color;
        static fromArgb(alpha: number, red: number, green: number, blue: number): Color;
        toArgb(): number;
    }
}
declare module Stimulsoft.System.Drawing {
    class ColorTranslator {
        static toHtml(color: Color): string;
        static fromHtml(text: string): Color;
    }
}
declare module Stimulsoft.System.Drawing {
    enum ContentAlignment {
        TopLeft = 1,
        TopCenter = 2,
        TopRight = 4,
        MiddleLeft = 16,
        MiddleCenter = 32,
        MiddleRight = 64,
        BottomLeft = 256,
        BottomCenter = 512,
        BottomRight = 1024,
    }
}
declare module Stimulsoft.System.Drawing {
    class Font implements ICloneable {
        /** Creates a new object that is a copy of the current instance. */
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        private _fontFamily;
        readonly fontFamily: FontFamily;
        readonly name: string;
        private _size;
        readonly size: number;
        readonly sizeInPoints: number;
        private _style;
        readonly style: FontStyle;
        private _unit;
        readonly unit: GraphicsUnit;
        readonly bold: boolean;
        readonly italic: boolean;
        readonly strikeout: boolean;
        readonly underline: boolean;
        toString(): string;
        getHeight(): number;
        constructor(family?: string, emSize?: number, style?: FontStyle, unit?: GraphicsUnit);
    }
}
declare module Stimulsoft.System.Drawing {
    class FontFamily {
        private static _families;
        static readonly families: FontFamily[];
        private _name;
        readonly name: string;
        isStyleAvailable(style: FontStyle): boolean;
        constructor(name: string);
    }
}
declare module Stimulsoft.System.Drawing {
    class FontResources {
        static getSize(font: Font, text: string): Size;
        private static _standardFontWidths;
        static readonly standardFontWidths: any[];
        private static _standardFontInfo;
        static readonly standardFontInfo: any[];
        private static family_Helvetica;
        private static family_Courier;
        private static family_Times_Roman;
        private static fontName;
    }
}
declare module Stimulsoft.System.Drawing {
    enum FontStyle {
        Regular = 0,
        Bold = 1,
        Italic = 2,
        Strikeout = 4,
        Underline = 8,
    }
}
declare module Stimulsoft.System.Drawing {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class Graphics {
        private context;
        private static _opentypeClass;
        static opentypeClass: any;
        drawImage(image: Image, point: Point): void;
        drawRectangle(pen: Pen, rect: Rectangle): void;
        fillRectangle(brush: Brush, x: number, y: number, width: number, height: number): void;
        drawLine(pen: Pen, x1: number, y1: number, x2: number, y2: number): void;
        drawString(text: string, font: Font, brush: Brush, x: number, y: number): void;
        translateTransform(dx: number, dy: number): void;
        static opentypeFonts: Hashtable;
        static getOpentypeFont(fontName: string, fontStyle: FontStyle): any;
        static getCustomFontsCss(): string;
        static getCustomFontName(fontName: string, fontStyle: FontStyle): string;
        static allowStyle(fontName: string, fontStyle: FontStyle): boolean;
        private static measureDiv;
        private static measureHash;
        static measureString(text1: string, font: Font, width?: number, useCache?: boolean, multiple?: number, angle?: number): Size;
        private static isWordWrapSymbol(sb, index);
        static measureChars(chars: Array<number>, count: number, font: Font): Size;
        private static rotate(size, angle, useCache);
        constructor(context: CanvasRenderingContext2D);
    }
}
declare module Stimulsoft.System.Drawing {
    enum GraphicsUnit {
        Pixel = 2,
        Point = 3,
    }
}
declare module Stimulsoft.System.Drawing {
    import ImageFormat = Stimulsoft.System.Drawing.Imaging.ImageFormat;
    class Image {
        private data;
        private _imageFormat;
        readonly imageFormat: ImageFormat;
        private _width;
        readonly width: number;
        private _height;
        readonly height: number;
        private _horizontalResolution;
        readonly horizontalResolution: number;
        private _verticalResolution;
        readonly verticalResolution: number;
        private _isConverting;
        readonly isConverting: boolean;
        imageData: any;
        base64: string;
        bytes: number[];
        static fromFile(path: string): Image;
        static fromBytes(bytes: number[]): Image;
        private setData(dataBytes, base64);
        convert(imageFormat: ImageFormat, flate?: boolean): Promise<Image>;
        dispose(): void;
        clone(): Image;
        aspectRatio: boolean;
        multipleFactor: number;
        margins: any;
        horAlignment: number;
        vertAlignment: number;
        imageRotation: number;
        stretch: boolean;
        zoom: number;
        url: string;
    }
}
declare module Stimulsoft.System.Drawing {
    import LineCap = Stimulsoft.System.Drawing.Drawing2D.LineCap;
    import DashStyle = Stimulsoft.System.Drawing.Drawing2D.DashStyle;
    class Pen {
        brush: Brush;
        color: Color;
        endCap: LineCap;
        startCap: LineCap;
        width: number;
        dashStyle: DashStyle;
        constructor(color: Color);
    }
}
declare module Stimulsoft.System.Drawing {
    class Point {
        x: number;
        y: number;
        readonly isEmpty: boolean;
        static readonly empty: Point;
        toString(): string;
        stiEquals(point: Point): boolean;
        constructor(x?: number, y?: number);
    }
}
declare module Stimulsoft.System.Drawing {
    class Rectangle {
        clone(): Rectangle;
        static readonly empty: Rectangle;
        static union(a: Rectangle, b: Rectangle): Rectangle;
        inflate(width: number, height: number): Rectangle;
        normalize(): Rectangle;
        multiply(multipleFactor: number): Rectangle;
        offsetRect(offsettingRectangle: Rectangle): Rectangle;
        intersectsWith(rect: Rectangle): boolean;
        alignToGrid(gridSize: number, aligningToGrid: boolean): Rectangle;
        fitToRectangle(rectangle: Rectangle): Rectangle;
        readonly isEmpty: Boolean;
        readonly isEmptyF: Boolean;
        contains(x: number, y: number): boolean;
        static convertFromXml(text: string): Rectangle;
        x: number;
        y: number;
        width: number;
        height: number;
        left: number;
        top: number;
        right: number;
        bottom: number;
        location: Point;
        size: Size;
        constructor(x?: number, y?: number, width?: number, height?: number);
    }
}
declare module Stimulsoft.System.Drawing {
    class Size {
        static readonly empty: Size;
        width: number;
        height: number;
        readonly isEmpty: boolean;
        readonly isDefault: boolean;
        swap(): Size;
        round(digits?: number): Size;
        static convertFromXml(text: string): Size;
        constructor(size: Size);
        constructor(width: number, height: number);
    }
}
declare module Stimulsoft.System.Drawing {
    class SolidBrush extends Brush {
        color: Color;
        constructor(color: Color);
    }
}
declare module Stimulsoft.System.Drawing {
    enum StringAlignment {
        Near = 0,
        Center = 1,
        Far = 2,
    }
}
declare module Stimulsoft.System.Drawing {
    import HotkeyPrefix = Stimulsoft.System.Drawing.Text.HotkeyPrefix;
    class StringFormat {
        alignment: StringAlignment;
        formatFlags: StringFormatFlags;
        hotkeyPrefix: HotkeyPrefix;
        lineAlignment: StringAlignment;
        trimming: StringTrimming;
    }
}
declare module Stimulsoft.System.Drawing {
    enum StringFormatFlags {
        DirectionRightToLeft = 1,
        DirectionVertical = 2,
        FitBlackBox = 4,
        DisplayFormatControl = 32,
        NoFontFallback = 1024,
        MeasureTrailingSpaces = 2048,
        NoWrap = 4096,
        LineLimit = 8192,
        NoClip = 16384,
    }
}
declare module Stimulsoft.System.Drawing {
    enum StringTrimming {
        None = 0,
        Character = 1,
        Word = 2,
        EllipsisCharacter = 3,
        EllipsisWord = 4,
        EllipsisPath = 5,
    }
}
declare module Stimulsoft.System.Globalization {
    class Calendar {
        static getWeekOfYear(time: DateTime, rule?: CalendarWeekRule, firstDayOfWeek?: DayOfWeek): number;
        private static getFirstDayWeekOfYear(time, firstDayOfWeek);
        private static getWeekOfYearFullDays(time, firstDayOfWeek, fullDays, daysOfMinYearMinusOne);
        static getDaysInYear(year: number): number;
        static getWeekOfMonth(time: DateTime, rule?: CalendarWeekRule, firstDayOfWeek?: DayOfWeek): number;
    }
}
declare module Stimulsoft.System.Globalization {
    enum CalendarWeekRule {
        /**
         *  Indicates that the first week of the year starts on the first day of the year and ends before the following designated first day of the week. The value is 0.
         */
        FirstDay = 0,
        /**
         * Indicates that the first week of the year begins on the first occurrence of the designated first day of the week on or after the first day of the year. The value is 1.
         */
        FirstFullWeek = 1,
        /**
         * Indicates that the first week of the year is the first week with four or more days before the designated first day of the week. The value is 2.
         */
        FirstFourDayWeek = 2,
    }
}
declare module Stimulsoft.System.Globalization {
    class CultureInfo {
        numberFormat: NumberFormatInfo;
        dateTimeFormat: DateTimeFormatInfo;
        name: string;
        private static _cultures;
        private static _currentCulture;
        static currentCulture: CultureInfo;
        static readonly cultures: Object;
        constructor(name: string, numberFormat?: NumberFormatInfo, dateTimeFormat?: DateTimeFormatInfo);
    }
}
declare module Stimulsoft.System.Globalization {
    class DateTimeFormatInfo {
        shortDatePattern: string;
        dateSeparator: string;
        longDatePattern: string;
        dayNames: string[];
        monthNames: string[];
        shortestDayNames: string[];
        abbreviatedMonthNames: string[];
        monthGenitiveNames: string[];
        timeSeparator: string;
        AMDesignator: string;
        PMDesignator: string;
        fullDateTimePattern: string;
        shortTimePattern: string;
        longTimePattern: string;
        yearMonthPattern: string;
        constructor(shortDatePattern: string, dateSeparator: string, longDatePattern: string, dayNames: string[], monthNames: string[], shortestDayNames: string[], abbreviatedMonthNames: string[], monthGenitiveNames: string[], timeSeparator: string, AMDesignator: string, PMDesignator: string, fullDateTimePattern: string, shortTimePattern: string, longTimePattern: string, yearMonthPattern: string);
    }
}
declare module Stimulsoft.System.Globalization {
    import IFormatProvider = System.IFormatProvider;
    import Type = System.Type;
    class NumberFormatInfo implements IFormatProvider {
        numberDecimalSeparator: string;
        numberDecimalDigits: number;
        numberGroupSeparator: string;
        numberGroupSizes: number[];
        numberNegativePattern: number;
        currencyDecimalDigits: number;
        currencyDecimalSeparator: string;
        currencyGroupSeparator: string;
        currencyGroupSizes: number[];
        currencyNegativePattern: number;
        currencyPositivePattern: number;
        currencySymbol: string;
        percentDecimalDigits: number;
        percentDecimalSeparator: string;
        percentGroupSeparator: string;
        percentGroupSizes: number[];
        percentNegativePattern: number;
        percentPositivePattern: number;
        percentSymbol: string;
        perMilleSymbol: string;
        positiveInfinitySymbol: string;
        positiveSign: string;
        NaNSymbol: string;
        negativeInfinitySymbol: string;
        negativeSign: string;
        getFormat(formatType: Type): Object;
        constructor(numberDecimalSeparator?: string, numberDecimalDigits?: number, numberGroupSeparator?: string, numberGroupSizes?: number[], numberNegativePattern?: number, currencyDecimalDigits?: number, currencyDecimalSeparator?: string, currencyGroupSeparator?: string, currencyGroupSizes?: number[], currencyNegativePattern?: number, currencyPositivePattern?: number, currencySymbol?: string, percentDecimalDigits?: number, percentDecimalSeparator?: string, percentGroupSeparator?: string, percentGroupSizes?: number[], percentNegativePattern?: number, percentPositivePattern?: number, percentSymbol?: string, perMilleSymbol?: string, positiveInfinitySymbol?: string, positiveSign?: string, NaNSymbol?: string, negativeInfinitySymbol?: string, negativeSign?: string);
    }
}
declare module Stimulsoft.System.IO {
    /** Provides the fields that represent reference points in streams for seeking. */
    enum SeekOrigin {
        /** Specifies the beginning of a stream. */
        Begin = 0,
        /** Specifies the current position within a stream. */
        Current = 1,
        /** Specifies the end of a stream. */
        End = 2,
    }
}
declare module Stimulsoft.System.IO {
    class File {
        static getFile(filePath: string, binary?: boolean, contentType?: string): any;
        static getFileAsync(callback: Function, filePath: string, binary?: boolean, contentType?: string): void;
        static saveFile(filePath: string, fileData: string): void;
        static getFilesNames(filePath: string): string[];
    }
}
declare module Stimulsoft.System.IO {
    class Http {
        static getFile(filePath: string, binary?: boolean, contentType?: string): any;
        static getFileAsync(callback: Function, filePath: string, binary?: boolean, contentType?: string): void;
    }
}
declare module Stimulsoft.System.IO {
    class MemoryStream {
        private static memStreamMaxLength;
        private _origin;
        private _buffer;
        private _position;
        readonly position: number;
        readonly length: number;
        readonly canSeek: boolean;
        readonly canWrite: boolean;
        setLength(length: number): void;
        toArray(): number[];
        writeTo(stream: MemoryStream): void;
        writeByte(byte: number): void;
        write(array: number[], offset?: number, length?: number): void;
        writeBytes(array: Uint8Array, offset?: number, length?: number): void;
        writeLine(inputString?: string, ...values: any[]): void;
        writeString(inputString: string, newLine?: boolean): void;
        read(array: number[], offset?: number, length?: number): number;
        seek(offset: number, origin: SeekOrigin): number;
        flush(): void;
        close(): void;
        constructor(array?: number[]);
    }
}
declare module Stimulsoft.System.IO {
    class Path {
        static Combine(path1: string, path2: string): string;
        static getFileNameWithoutExtension(path: string): string;
        static getExtension(path: string): string;
        static getSep(): string;
    }
}
declare module Stimulsoft.System.IO {
    import Encoding = Stimulsoft.System.Text.Encoding;
    class StreamReader {
        private stream;
        private encoding;
        constructor(stream: MemoryStream, encoding?: Encoding);
        read(): string;
        readLine(): string;
        private readLineInternal();
    }
}
declare module Stimulsoft.System.Text {
    class Encoding {
        private static CodePageDefault;
        private static CodePageNoOEM;
        private static CodePageNoMac;
        private static CodePageNoThread;
        private static CodePageNoSymbol;
        private static CodePageUnicode;
        private static CodePageBigEndian;
        private static CodePageWindows1251;
        private static CodePageWindows1252;
        private static CodePageMacGB2312;
        private static CodePageGB2312;
        private static CodePageMacKorean;
        private static CodePageDLLKorean;
        private static ISO2022JP;
        private static ISO2022JPESC;
        private static ISO2022JPSISO;
        private static ISOKorean;
        private static ISOSimplifiedCN;
        private static EUCJP;
        private static ChineseHZ;
        private static DuplicateEUCCN;
        private static EUCCN;
        private static EUCKR;
        private static CodePageASCII;
        private static ISO_8859_1;
        private static ISCIIAssemese;
        private static ISCIIBengali;
        private static ISCIIDevanagari;
        private static ISCIIGujarathi;
        private static ISCIIKannada;
        private static ISCIIMalayalam;
        private static ISCIIOriya;
        private static ISCIIPanjabi;
        private static ISCIITamil;
        private static ISCIITelugu;
        private static GB18030;
        private static ISO_8859_8I;
        private static ISO_8859_8_Visual;
        private static ENC50229;
        private static CodePageUTF7;
        private static CodePageUTF8;
        private static CodePageUTF32;
        private static CodePageUTF32BE;
        static ASCII: Encoding;
        static BigEndianUnicode: Encoding;
        static Default: Encoding;
        static Unicode: Encoding;
        static UTF32: Encoding;
        static UTF7: Encoding;
        static UTF8: Encoding;
        static Windows1251: Encoding;
        private static _windows_1251;
        private _webName;
        readonly webName: string;
        private _encodingName;
        readonly encodingName: string;
        getBytes(str: string): number[];
        getString(bytes: number[]): string;
        static getEncoding(codepage: number): Encoding;
        private static fromCodePageToUnicode(codepage, bytes);
        constructor(name: string, webName?: string);
    }
}
declare module Stimulsoft.System.Text {
    class StringBuilder {
        private isNew;
        private partArray;
        private appendSingle(item);
        appendThese(items: any[]): StringBuilder;
        append(...items: any[]): StringBuilder;
        appendCount(item: any, count?: number): StringBuilder;
        appendLine(...items: any[]): StringBuilder;
        appendLines(items: any[]): StringBuilder;
        appendFormat(str: string, ...values: any[]): StringBuilder;
        insert(index: number, value: string, count?: number): StringBuilder;
        remove(startIndex: number, length: number): StringBuilder;
        readonly isEmpty: boolean;
        length: number;
        private latest;
        toString(): string;
        join(delimiter: string): string;
        clear(): void;
        dispose(): void;
        charAt(index: number): string;
        charCodeAt(index: number): number;
        setByIndex(index: number, value: string): void;
        private formatError(st?);
        appendFormatHelper(provider: IFormatProvider, format: String, args: ParamsArray): StringBuilder;
        replace(searchValue: string, replaceValue: string): StringBuilder;
        constructor(value?: string);
    }
}
declare module Stimulsoft.System.IO {
    import StringBuilder = Stimulsoft.System.Text.StringBuilder;
    class TextWriter {
        private sb;
        write(value: any): void;
        writeLine(value?: any): void;
        close(): void;
        flush(): void;
        getStringBuilder(): StringBuilder;
    }
}
declare module Stimulsoft.System.IO {
    import Encoding = Stimulsoft.System.Text.Encoding;
    import TextWriter = Stimulsoft.System.IO.TextWriter;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StreamWriter extends TextWriter {
        private stream;
        private encoding;
        private cn;
        writeLine(value: string): void;
        write(value: string): void;
        close(): void;
        flush(): void;
        constructor(stream: MemoryStream, encoding?: Encoding);
    }
}
declare module Stimulsoft.System.Text {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiReportObjectStringConverter {
        static convertStringToColorArray(str: string): Color[];
        static convertStringToColor(str: string): Color;
        private static getByName(str);
    }
}
declare module Stimulsoft.System.Text {
    import Font = Stimulsoft.System.Drawing.Font;
    class TextUtils {
        static splitString(inputString: string, removeControl: boolean): Array<string>;
        static trimEndWhiteSpace(inputString: string): string;
        static trimEndWhiteSpace2(inputString: string, removeControl: boolean): string;
        private static isWordWrapSymbol(sb, index);
        static getWordWrapTextLines(st: string, font: Font, needWidthAlign: boolean, textW: number): string[];
    }
}
declare module Stimulsoft.System.Windows.Forms {
    /** Specifies identifiers to indicate the return value of a dialog box. */
    enum DialogResult {
        None = 0,
        OK = 1,
        Cancel = 2,
        Abort = 3,
        Retry = 4,
        Ignore = 5,
        Yes = 6,
        No = 7,
    }
}
declare module Stimulsoft.System.Windows.Forms {
    enum Orientation {
        Horizontal = 0,
        Vertical = 1,
    }
}
declare module Stimulsoft.System.Xml {
    enum Formatting {
        None = 0,
        Indented = 1,
    }
}
declare module Stimulsoft.System.Xml {
    class XmlAttr {
        private _name;
        name: string;
        private _value;
        value: string;
    }
}
declare module Stimulsoft.System.Xml {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class XmlAttrCollection extends CollectionBase<XmlAttr> {
        readonly length: number;
        add(value: XmlAttr): void;
        getNamedItem(name: string): XmlAttr;
    }
}
declare module Stimulsoft.System.Xml {
    class XmlCharType {
        static fWhitespace: number;
        static fLetter: number;
        static fNCStartName: number;
        static fNCName: number;
        static fCharData: number;
        static fPublicId: number;
        static fText: number;
        static fAttrValue: number;
        private static charPropertiesSize;
        static readonly instance: XmlCharType;
        private static s_CharProperties;
        charProperties: any[];
        private static initInstance();
        private static setProperties(ranges, value);
        private static s_Whitespace;
        private static s_Letter;
        private static s_NCStartName;
        private static s_NCName;
        private static s_CharData;
        private static s_PublicID;
        private static s_Text;
        private static s_AttrValue;
        constructor(charProperties: any[]);
    }
}
declare module Stimulsoft.System.Xml {
    class XmlReservedNs {
        static NsCollationBase: string;
        static NsCollCodePoint: string;
        static NsDataType: string;
        static NsDataTypeAlias: string;
        static NsDataTypeOld: string;
        static NsExsltCommon: string;
        static NsExsltDates: string;
        static NsExsltMath: string;
        static NsExsltRegExps: string;
        static NsExsltSets: string;
        static NsExsltStrings: string;
        static NsMsxsl: string;
        static NsWdXsl: string;
        static NsXdr: string;
        static NsXdrAlias: string;
        static NsXml: string;
        static NsXmlNs: string;
        static NsXQueryDataType: string;
        static NsXQueryFunc: string;
        static NsXs: string;
        static NsXsd: string;
        static NsXsi: string;
        static NsXslDebug: string;
        static NsXslt: string;
        static NsXsltInternal: string;
    }
}
declare module Stimulsoft.System.Xml {
    enum XmlSpace {
        Default = 1,
        None = 0,
        Preserve = 2,
    }
}
declare module Stimulsoft.System.Xml {
    import TextWriter = Stimulsoft.System.IO.TextWriter;
    class XmlTextEncoder {
        private textWriter;
        private inAttribute;
        quoteChar: string;
        private attrValue;
        private cacheAttrValue;
        private xmlCharType;
        private surHighStart;
        private surHighEnd;
        private surLowStart;
        private surLowEnd;
        startAttribute(cacheAttrValue: boolean): void;
        endAttribute(): void;
        readonly attributeValue: string;
        private writeSurrogateChar(lowChar, highChar);
        write(text: string): void;
        writeRawWithSurrogateChecking(text: string): void;
        private writeStringFragment(str, offset, count, helperBuffer);
        private writeCharEntityImpl(strVal);
        private writeEntityRefImpl(name);
        constructor(textWriter: TextWriter);
    }
}
declare module Stimulsoft.System.Xml {
    import Encoding = Stimulsoft.System.Text.Encoding;
    import TextWriter = Stimulsoft.System.IO.TextWriter;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class XmlTextWriter {
        private static stateTableDefault;
        private static stateTableDocument;
        textWriter: TextWriter;
        private xmlEncoder;
        private encoding;
        formatting: Formatting;
        private indented;
        indentation: number;
        private indentChar;
        private stack;
        private top;
        private stateTable;
        private currentState;
        private lastToken;
        private quoteChar;
        private curQuoteChar;
        private namespaces;
        private specialAttr;
        private prefixForXmlNs;
        private _flush;
        private nsStack;
        private nsTop;
        private nsHashtable;
        private useNsHashtable;
        private xmlCharType;
        private namespaceStackInitialSize;
        private maxNamespacesWalkCount;
        writeStartDocument(standalone?: boolean): void;
        writeEndDocument(): void;
        writeDocType(name: string, pubid: string, sysid: string, subset: string): void;
        writeStartElement(localName: string): void;
        private writeStartElement3(prefix, localName, ns);
        writeEndElement(): void;
        writeFullEndElement(): void;
        writeStartAttribute(prefix: string, localName: string, ns: string): void;
        writeEndAttribute(): void;
        writeString(text: string): void;
        writeRaw(data: string): void;
        close(): void;
        flush(): void;
        writeName(name: string): void;
        writeQualifiedName(localName: string, ns: string): void;
        private startDocument(standalone);
        private autoComplete(token);
        private autoCompleteAll();
        private internalWriteEndElement(longFormat);
        private writeEndStartTag(empty);
        private writeEndAttributeQuote();
        private indent(beforeEndElement);
        private pushNamespace(prefix, ns, declared);
        private addNamespace(prefix, ns, declared);
        private addToNamespaceHashtable(namespaceIndex);
        private popNamespaces(indexFrom, indexTo);
        private generatePrefix();
        private internalWriteProcessingInstruction(name, text);
        private lookupNamespace(prefix);
        private lookupNamespaceInCurrentScope(prefix);
        private findPrefix(ns);
        private internalWriteName(name, NCName);
        private validateName(name, NCName);
        private handleSpecialAttribute();
        private verifyPrefixXml(prefix, ns);
        private pushStack();
        private flushEncoders();
        writeAttributeString(localName: string, value: string): void;
        writeElementString(localName: string, value: string): void;
        writeElementString2(localName: string, ns: string, value: string): void;
        writeElementString3(prefix: string, localName: string, ns: string, value: string): void;
        constructor_(encoding: Encoding, w?: MemoryStream): void;
        constructor(encoding: Encoding, w?: MemoryStream);
    }
}
declare module Stimulsoft.System {
    class Activator {
        static createInstance(type: Type): any;
    }
}
interface Array<T> {
    count: number;
    contains(item: T): boolean;
    add(item: T): any;
    remove(item: T): any;
    remove(index: number): any;
    insert(index: number, item: T): any;
    clear(): any;
    clone(): T[];
    removeAt(index: number): any;
    addRange(items: T[]): any;
    removeRange(index: number, count: number): any;
    copyTo(array: any[]): any;
    copyTo(array: any[], index: number): any;
    getKeys(): string[];
    getByIndex(index: number, keys: string[]): T;
    removeByIndex(index: number): T;
    first(): T;
    firstOrDefault(funct: any): T;
    lastOrDefault(): T;
    where(funct: any): T[];
    select(funct: any): any[];
    selectMany(funct: any): any[];
    any(funct: any): boolean;
    exists(funct: any): boolean;
    sort2(comparer: Stimulsoft.System.Collections.IComparer<T>): T[];
    getStiLength(dimension: number): number;
    setByIndex(index: number, item: T): any;
    orderBy(funct: any): T[];
    toArray(): any[];
    peek(): T;
    cast<T>(): any;
    sum(): number;
    min(): number;
    max(): number;
    skip(index: number): T[];
    sti_indexOf(searchElement: any, fromIndex: number): number;
}
interface ArrayConstructor {
    create(type: Stimulsoft.System.Type, ...values: any[]): any;
    numberSortFunction(): any;
    copy(sourceArray: any[], startIndex: number, destinationArray: any[], count: number): any;
    reverse(array: any[]): any;
    sort(array: any[]): any;
    name: string;
    namespace: string;
    fullName: string;
    clear(array: any[], index: number, length: number): any;
    disableAllEnumerable(): any;
}
declare module Stimulsoft.System {
    class Base64 {
        private static keyStr;
        static encode(input: string): string;
        static decode(input: string): any;
        private static utf8_encode(str);
        private static utf8_decode(utftext);
    }
}
interface Boolean {
    /** Convert object to the specified interface or class, returns null if not inherited. */
    as(type: any): any;
}
interface BooleanConstructor {
    name: string;
    namespace: string;
    fullName: string;
}
declare module Stimulsoft.System {
    class Chars {
        static getUnicodeCategory(char: number): number;
        private static _table_0;
        private static _table_9fc0;
        private static _table_d780;
        private static _table_fa40;
    }
}
declare module Stimulsoft.System {
    class Convert {
        private static keyStr;
        static changeType(value: any, type: Type): any;
        static changeType2(value: any, typeCode: TypeCode): any;
        static toDateTime(value: any): DateTime;
        static toString(value: any): string;
        static toFont(value: string): Stimulsoft.System.Drawing.Font;
        static toBoolean(value: any): boolean;
        static toNumber(value: any): number;
        static toDouble(value: any): number;
        static toInt32(value: any, radix?: number): number;
        static toInt64(value: any): number;
        static toUInt64(value: any): number;
        static toUInt32(value: any): number;
        static toBase64String(input: string | number[] | Uint8Array): string;
        static fromBase64String(input: string): number[];
        static fromBase64StringText(input: string): string;
    }
}
declare module Stimulsoft.System {
    class DateTime {
        private static ticksPerMillisecond;
        private static ticksPerSecond;
        private static ticksPerMinute;
        private static ticksPerHour;
        private static ticksPerDay;
        private static millisPerSecond;
        private static millisPerMinute;
        private static millisPerHour;
        private static millisPerDay;
        private static daysPerYear;
        private static daysPer4Years;
        private static daysPer100Years;
        private static daysPer400Years;
        private static daysTo1601;
        private static daysTo1899;
        private static daysTo10000;
        private static minTicks;
        private static maxTicks;
        private static maxMillis;
        private static fileTimeOffset;
        private static doubleDateOffset;
        private static oADateMinAsTicks;
        private static oADateMinAsDouble;
        private static oADateMaxAsDouble;
        private static datePartYear;
        private static datePartDayOfYear;
        private static datePartMonth;
        private static DatePartDay;
        private static daysToMonth365;
        private static daysToMonth366;
        static minValue: DateTime;
        static maxValue: DateTime;
        static getStiNetTypeName(): string;
        private innerDate;
        readonly year: number;
        readonly month: number;
        readonly monthName: string;
        readonly monthGenitiveName: string;
        readonly monthShortName: string;
        readonly day: number;
        /** 0 – Sunday, 1 – Monday etc */
        readonly dayOfWeek: DayOfWeek;
        readonly dayName: string;
        readonly dayShortName: string;
        readonly hour: number;
        readonly minute: number;
        readonly second: number;
        readonly millisecond: number;
        readonly ticks: number;
        readonly dayOfYear: number;
        static readonly now: DateTime;
        static readonly today: DateTime;
        static isLeapYear(year: number): boolean;
        /** The month number ranging from 1 to 12. JS calculate month from 0. This will even work for December. */
        static daysInMonth(year: number, month: number): number;
        static compare(t1: DateTime, t2: DateTime): number;
        private static doubleDateToTicks(value);
        private static ticksToOADate(value);
        static ticksNetToTicksJs(ticks: number): number;
        negate(): DateTime;
        addYears(value: number): DateTime;
        addMonths(value: number): DateTime;
        addDays(value: number): DateTime;
        addHours(value: number): DateTime;
        addMinutes(value: number): DateTime;
        addSeconds(value: number): DateTime;
        addMilliseconds(value: number): DateTime;
        addTicks(value: number): DateTime;
        compareTo(value: DateTime): number;
        subtract(value: DateTime): TimeSpan;
        readonly date: Date;
        /** By default date and time is converted into American format. */
        toString(format?: string, useGenitive?: boolean): string;
        toOADate(): number;
        toNetJsonString(): string;
        static fromNetJsonString(jsonDate: string): DateTime;
        static fromOADate(oadate: number): DateTime;
        static fromString(d?: string, logError?: boolean): DateTime;
        constructor(date: Date);
        constructor(ticks: number);
        constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number);
    }
}
declare module Stimulsoft.System {
    class Enum {
        static getName(enumType: Object, value: number): string;
        static parse(enumType: Object, value: string, ignoreCase?: boolean): number;
        static getNames(enumType: Object): string[];
        static getValues(enumType: Object): number[];
    }
}
declare module Stimulsoft.System {
    enum DayOfWeek {
        Sunday = 0,
        Monday = 1,
        Tuesday = 2,
        Wednesday = 3,
        Thursday = 4,
        Friday = 5,
        Saturday = 6,
    }
}
declare module Stimulsoft.System {
    class Environment {
        static newLine(): string;
    }
}
declare module Stimulsoft.System {
    class EventArgs {
        static empty: EventArgs;
    }
}
declare module Stimulsoft.System {
    class EventHandler {
        static _this: any;
        private static handler;
        private args;
        create(script: string, _this: any): Function;
        static create(script: string, _this: any): Function;
        constructor(args: string);
    }
}
declare module Stimulsoft.System {
    class Guid {
        private id;
        static newGuid(): Guid;
        private static s4();
        toString(): string;
        static readonly empty: Guid;
        static compareTo(value: Guid): number;
        constructor(id: string);
    }
}
declare module Stimulsoft.System {
    var ICloneable: string;
    interface ICloneable {
        clone(): any;
    }
}
declare module Stimulsoft.System {
    var IComparable: string;
    interface IComparable {
        compareTo(obj: Object): number;
    }
}
declare module Stimulsoft.System {
    var IFormatProvider: string;
    interface IFormatProvider {
        getFormat(formatType: Type): Object;
    }
}
declare module Stimulsoft.System {
    class JSON2 {
        static decode(text: string): any;
        static encode(value: any): string;
        static stiPopulateObject(json: any, object: any): void;
    }
}
interface Math {
    round(value: number, digits?: number): number;
    superRound(value: number): number;
    trunc(x: number): number;
    sign(x: number): number;
    log10(value: number): number;
}
declare module Stimulsoft.System {
    enum MidpointRounding {
        ToEven = 0,
        AwayFromZero = 1,
    }
}
declare module Stimulsoft.System {
    /**
     * @hidden
     */
    class NodeJs {
        private static isInitialize;
        static initialize(onResult?: Function): void;
        private static convert;
        static platform(): any;
        static callRemoteApi(command: any, timeout: number): Promise<string>;
        private static processFirebird;
        private static processMsSql;
        private static processMySql;
        private static processPostgreSQL;
        static stripBom(data: any): any;
        static getFile(filePath: string, binary?: boolean, contentType?: string): any;
        static getFileHttp(filePath: string, binary?: boolean, contentType?: string): any;
        static saveFile(filePath: string, fileData: string): void;
        static getFilesNames(filesPath: string): string[];
        static getSep(): string;
        private static fromBase64String(s);
        private static fromBase64StringText(s);
        private static toBase64String(data);
        private static fromUnicodeString();
        private static _isNodeJs;
        static isNodeJs(): boolean;
        static useWebKit: boolean;
        static consoleLog: boolean;
        private static fillInfo(info, onResult);
        static localizationPath: string;
        private static getLocalizationInfo(onResult);
        private static getSetting(name, def);
        private static setSetting(name, value);
    }
}
interface Number {
    /** Convert object to the specified interface or class, returns null if not inherited. */
    as(type: any): any;
    compareTo(value: number): number;
    /** Serves as a hash function for a particular type. */
    getHashCode(): number;
    toStringFormat(formatString: string): string;
}
interface NumberConstructor {
    name: string;
    namespace: string;
    fullName: string;
}
interface Object {
    /** Returns the type (constructor) of this object. */
    getStiType(): Stimulsoft.System.Type;
    /** Checks inherit from the specified class or interface. */
    is(type: any): boolean;
    /** Convert object to the specified interface or class, returns null if not inherited. */
    as(type: any): any;
    /** Creates a shallow copy of the current Object. */
    memberwiseClone(): any;
    /** Determines whether the specified Object is equal to the current Object. */
    stiEquals(obj: Object): boolean;
    /** Serves as a hash function for a particular type. */
    getHashCode(): number;
    /** Compares the current instance with another object of the same type and returns an integer that indicates whether
     * the current instance precedes, follows, or occurs in the same position in the sort order as the other object. */
    compareTo(object: Object): number;
    toBoolean(): boolean;
    toNumber(): number;
    /** Returns the type name of this object class. */
    getStiTypeName(): string;
    /** Returns the full type name (with .NET namespace) of this object class. */
    getStiNetTypeName(): string;
}
interface ObjectConstructor {
    /** Determines whether the specified Object instances are the same instance. */
    referenceEquals(objA: any, objB: any): boolean;
    addEvent(element: any, eventName: string, fn: Function): any;
    stiEquals(objA: any, objB: any): boolean;
    saveAs(data: any, fileName: string, type?: string): any;
    /** Returns the type name of this object class. */
    getStiTypeName(): string;
    /** Returns the full type name (with .NET namespace) of this object class. */
    getStiNetTypeName(): string;
    isNullOrUndefined(obj: any): boolean;
}
declare module Stimulsoft.System {
    class ParamsArray {
        arg0: Object;
        arg1: Object;
        arg2: Object;
        private _length;
        constructor(arg0: Object, arg1?: Object, arg2?: Object);
        readonly length: number;
        get(index: Number): Object;
    }
}
declare module Stimulsoft.System {
    class Promise<Type> {
        _this: any;
        returnValue: Type;
        private _tryFunction;
        private _finallyFunction;
        private _timeout;
        private _startTime;
        private _callTry;
        private _callCatch;
        private _callFinaly;
        private _callTimeout;
        private _catchArgument;
        private _finalyArgument;
        private promise;
        private timeoutHanderId;
        private assignFunction;
        private _catchFunctions;
        try(tryFunction: Function): Promise<Type>;
        catch(catchFunction: Function): Promise<Type>;
        finally(finallyFunction: Function): Promise<Type>;
        this(_thisObject: any): Promise<Type>;
        timeout(timeout: number): Promise<Type>;
        callTry(returnValue?: Type): void;
        callCatch(catchArgument?: any): void;
        private callFinally(finalyArgument);
        callTimeout(): void;
        private nextPromises;
        abort(previusPromise?: Promise<any>): Promise<Type>;
        private abortFunction;
        onAbort(abortFunction: Function): void;
        constructor();
    }
}
declare module Stimulsoft.Report {
    class Range {
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: Object;
        toObject: Object;
        parse(from: string, to: string): void;
        stiEquals(obj: any): boolean;
        readonly fromStrLoc: string;
        readonly toStrLoc: string;
        getHashCode(): number;
        constructor();
    }
    class CharRange extends Range {
        from: string;
        to: string;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        contains(value: string): boolean;
        constructor(from?: string, to?: string);
    }
    class DateTimeRange extends Range {
        from: Stimulsoft.System.NullableDateTime;
        to: Stimulsoft.System.NullableDateTime;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        readonly fromDate: Stimulsoft.System.DateTime;
        readonly toDate: Stimulsoft.System.DateTime;
        contains(value: Stimulsoft.System.DateTime): boolean;
        toString(): string;
        constructor(from?: Stimulsoft.System.DateTime, to?: Stimulsoft.System.DateTime);
    }
    class TimeSpanRange extends Range {
        from: Stimulsoft.System.NullableTimeSpan;
        to: Stimulsoft.System.NullableTimeSpan;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        readonly fromTime: Stimulsoft.System.TimeSpan;
        readonly toTime: Stimulsoft.System.TimeSpan;
        contains(value: Stimulsoft.System.TimeSpan): boolean;
        constructor(from?: Stimulsoft.System.TimeSpan, to?: Stimulsoft.System.TimeSpan);
    }
    class DecimalRange extends Range {
        from: number;
        to: number;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class FloatRange extends Range {
        from: number;
        to: number;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class DoubleRange extends Range {
        from: number;
        to: number;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class ByteRange extends Range {
        from: number;
        to: number;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class ShortRange extends Range {
        from: number;
        to: number;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class IntRange extends Range {
        from: number;
        to: number;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class LongRange extends Range {
        from: number;
        to: number;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class GuidRange extends Range {
        from: Stimulsoft.System.Guid;
        to: Stimulsoft.System.Guid;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        contains(value: Stimulsoft.System.Guid): boolean;
        constructor(from?: Stimulsoft.System.Guid, to?: Stimulsoft.System.Guid);
    }
    class StringRange extends Range {
        from: String;
        to: String;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        contains(value: String): boolean;
        constructor(from?: String, to?: String);
    }
}
declare module Stimulsoft.System {
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    class ResourceManager {
        private resource;
        getString(name: string, culture: CultureInfo): string;
    }
}
declare module Stimulsoft.System {
    class StiError {
        static errorMessageForm: any;
        static showError(e: any, showForm?: boolean): void;
    }
}
/**
 * @hidden
 */
declare function unescape(s: string): string;
/**
 * @hidden
 */
declare function escape(s: string): string;
interface String {
    /** Convert object to the specified interface or class, returns null if not inherited. */
    as(type: any): any;
    /** Returns a copy of this string converted to lowercase. */
    toLower(): string;
    /** Returns a copy of this string converted to uppercase. */
    toUpper(): string;
    /** Returns a result of checking string is Base64. */
    isBase64String(): boolean;
    /** Returns a new string in which all the characters in the current instance, beginning at a specified position and continuing through the last position, have been deleted. */
    remove(startIndex: number): string;
    /** Returns a new string in which a specified number of characters in this instance beginning at a specified position have been deleted. */
    remove(startIndex: number, count: number): string;
    /** Returns a new string in which a specified string is inserted at a specified index position in this instance. */
    insert(startIndex: number, value: string, removeLength: number): string;
    /** Returns a new string that right-aligns the characters in this instance by padding them with spaces on the left, for a specified total length. */
    padLeft(totalWidth: number): string;
    /** Returns a new string that right-aligns the characters in this instance by padding them on the left with a specified Unicode character, for a specified total length. */
    padLeft(totalWidth: number, paddingChar: string): string;
    /** Determines whether the beginning of this string instance matches the specified string. */
    startsWith(value: string): boolean;
    /** Determines whether the beginning of this string instance matches the specified string when the case is ignored. */
    startsWith(value: string, ignoreCase: boolean): boolean;
    /** Determines whether the end of this string instance matches the specified string. */
    endsWith(value: string): boolean;
    /** Determines whether the end of this string instance matches the specified string when the case is ignored. */
    endsWith(value: string, ignoreCase: boolean): boolean;
    /** Removes all space characters from the start of the specified string. */
    trimStart(char?: string): string;
    /** Removes all space characters from the end of the specified string. */
    trimEnd(char?: string): string;
    /** Returns the hash code for this string. */
    getHashCode(): number;
    toBytesArray(): number[];
    toUnicodeString(): string;
    fromUnicodeString(): string;
    /** NOT IMPLEMENTS! */
    compareTo(strB: string): number;
    contains(str: string): boolean;
    indexOfAny(values: string[]): number;
    regexIndexOf(regex: RegExp, startpos: number): any;
    regexLastIndexOf(regex: RegExp, startpos: number): any;
    replaceAll(searchValue: string, replaceValue: string): string;
}
interface StringConstructor {
    /** Represents the empty string. */
    empty: string;
    /** Indicates whether the specified string is null or an empty string. */
    isNullOrEmpty(value: string): boolean;
    /** Indicates whether a specified string is null, empty, or consists only of white-space characters. */
    isNullOrWhiteSpace(value: string): boolean;
    /** Returns a string consisting of a specified string concatenated with itself a specified number of times. */
    repeat(value: string, n: number): string;
    /** Returns a string, which consists of the specified string, linked with itself the indicated number of times. */
    fill(value: string, count: number): string;
    stiFormat(str: string, ...values: any[]): string;
    stiFormat2(provider: Stimulsoft.System.IFormatProvider, format: string, ...values: any[]): string;
    parseFormatString(formatString: String, values: Array<any>): string;
    formatNumber(arg: any, decimalDigits: number, useGroupSeparator: boolean, useSign: boolean): string;
    customFormat(arg: any, format: string): string;
    customFormatNumber(arg: number, format: string): string;
    indexOfAny(str: string, searchChars: string[]): number;
    removeBOM(str: string): string;
    join(separator: string, value: string[]): string;
    fromBytesArray(bytes: number[]): string;
}
declare module Stimulsoft.System {
    enum StringComparison {
        CurrentCulture = 0,
        CurrentCultureIgnoreCase = 1,
        InvariantCulture = 2,
        InvariantCultureIgnoreCase = 3,
        Ordinal = 4,
        OrdinalIgnoreCase = 5,
    }
}
declare module Stimulsoft.System {
    class SwitchSymbolFormatter {
        private numberSymbol;
        private isValid;
        formatValue(format: string, source: any): string;
        constructor(numberSymbol?: string);
    }
}
declare module Stimulsoft.System {
    class TypeHelper {
        private static types;
        static getTypes(): Stimulsoft.System.Type[];
        static isValueType(type: Type): boolean;
    }
    class Type implements Function {
        apply(thisArg: any, argArray?: any): any;
        call(thisArg: any, ...argArray: any[]): any;
        bind(thisArg: any, ...argArray: any[]): any;
        prototype: any;
        length: number;
        arguments: any;
        caller: Function;
    }
    class Byte {
    }
    class ByteArray {
    }
    class Decimal {
    }
    class Double {
    }
    class Float {
    }
    class Int {
    }
    class Int16 {
    }
    class Int32 {
    }
    class Int64 {
    }
    class Short {
    }
    class Long {
    }
    class SByte {
    }
    class Single extends Number {
    }
    class UInt {
    }
    class UInt16 {
    }
    class UInt32 {
    }
    class UInt64 {
    }
    class UShort {
    }
    class ULong {
    }
    class Nullable {
    }
    class NullableBoolean extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableByte extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableChar extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableDateTime extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableTimeSpan extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableDecimal extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableDouble extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableFloat extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableGuid extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableInt extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableInt16 extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableInt32 extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableInt64 extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableShort extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableLong extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableSByte extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableSingle extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableUInt extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableUInt16 extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableUInt32 extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableUInt64 extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableUShort extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableULong extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftByteRange extends Stimulsoft.Report.ByteRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftCharRange extends Stimulsoft.Report.CharRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftDateTimeRange extends Stimulsoft.Report.DateTimeRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftDecimalRange extends Stimulsoft.Report.DecimalRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftDoubleRange extends Stimulsoft.Report.DoubleRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftFloatRange extends Stimulsoft.Report.FloatRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftGuidRange extends Stimulsoft.Report.GuidRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftIntRange extends Stimulsoft.Report.IntRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftLongRange extends Stimulsoft.Report.LongRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftShortRange extends Stimulsoft.Report.ShortRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftStringRange extends Stimulsoft.Report.StringRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftTimeSpanRange extends Stimulsoft.Report.TimeSpanRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftList {
    }
    class StimulsoftBoolList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftByteList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftCharList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftDateTimeList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftDecimalList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftDoubleList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftFloatList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftGuidList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftIntList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftLongList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftShortList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftStringList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftTimeSpanList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
}
declare module Stimulsoft.System {
    enum TypeCode {
        Empty = 0,
        Object = 1,
        DBNull = 2,
        Boolean = 3,
        Char = 4,
        SByte = 5,
        Byte = 6,
        Int16 = 7,
        UInt16 = 8,
        Int32 = 9,
        UInt32 = 10,
        Int64 = 11,
        UInt64 = 12,
        Single = 13,
        Double = 14,
        Decimal = 15,
        DateTime = 16,
        String = 18,
    }
}

declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    class StiAnimation {
        constructor(duration: TimeSpan, beginTime: TimeSpan);
        duration: TimeSpan;
        beginTime: TimeSpan;
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiColumnAnimation extends StiAnimation {
        constructor(valueFrom: number, rectFrom: Rectangle, duration: TimeSpan, beginTime: TimeSpan);
        valueFrom: number;
        rectFrom: Rectangle;
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiLabelAnimation extends StiAnimation {
        constructor(valueFrom: number, value: number, pointFrom: Point, point: Point, duration: TimeSpan, beginTime: TimeSpan);
        pointFrom: Point;
        point: Point;
        valueFrom: number;
        value: number;
        LabelRect: Rectangle;
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    class StiOpacityAnimation extends StiAnimation {
        constructor(duration: TimeSpan, beginTime: TimeSpan);
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiPieLabelAnimation extends StiAnimation {
        constructor(valueFrom: number, value: number, angleFrom: number, angle: number, clientRect: Rectangle, rectLabelFrom: Rectangle, rectLabel: Rectangle, duration: TimeSpan, beginTime: TimeSpan);
        valueFrom: number;
        value: number;
        rectLabelFrom: Rectangle;
        rectLabel: Rectangle;
        clientRect: Rectangle;
        angleFrom: number;
        angle: number;
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiPieSegmentAnimation extends StiAnimation {
        constructor(rectFrom: Rectangle, startAngleFrom: number, sweepAngleFrom: number, duration: TimeSpan, beginTime: TimeSpan);
        rectFrom: Rectangle;
        startAngleFrom: number;
        sweepAngleFrom: number;
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiPointAnimation extends StiAnimation {
        constructor(pointFrom: Point, duration: TimeSpan, beginTime: TimeSpan);
        pointFrom: Point;
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiPointsAnimation extends StiAnimation {
        constructor(pointsFrom: Point[], duration: TimeSpan, beginTime: TimeSpan);
        pointsFrom: Point[];
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiRotationAnimation extends StiAnimation {
        constructor(startAngle: number, endAngle: number, centerPoint: Point, duration: TimeSpan, beginTime: TimeSpan);
        startAngle: number;
        endAngle: number;
        centerPoint: Point;
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    class StiScaleAnimation extends StiAnimation {
        constructor(startScaleX: number, endScaleX: number, startScaleY: number, endScaleY: number, centerX: number, centerY: number, duration: TimeSpan, beginTime: TimeSpan);
        startScaleX: number;
        startScaleY: number;
        endScaleX: number;
        endScaleY: number;
        centerX: number;
        centerY: number;
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiTranslationAnimation extends StiAnimation {
        constructor(startPoint: Point, endPoint: Point, duration: TimeSpan, beginTime: TimeSpan);
        startPoint: Point;
        endPoint: Point;
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Base.Drawing {
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    import Brush = Stimulsoft.System.Drawing.Brush;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiBrush implements ICloneable {
        implements(): string[];
        clone(): StiBrush;
        stiEquals(obj: Object): boolean;
        static convertToBrush(text: string): StiBrush;
        static loadFromXml(text: string): StiBrush;
        static light(baseBrush: StiBrush, value: number): StiBrush;
        static dark(baseBrush: StiBrush, value: number): StiBrush;
        static getBrush(brush: StiBrush, rect: Rectangle): Brush;
        static toColor(brush: StiBrush): Color;
    }
}
declare module Stimulsoft.Base.JsonReportObject {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    var IStiJsonReportObject: string;
    interface IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): any;
    }
}
declare module Stimulsoft.Base.Context {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiGeom {
        private static implementsStiGeom;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        saveGeomListToJsonObject(geoms: StiSegmentGeom[], mode: StiJsonSaveMode): StiJson[];
        savePointDArrayToJsonObject(points: Point[]): StiJson[];
        saveBrushToJsonObject(brush: Object, mode: StiJsonSaveMode): string;
        saveRectToJsonObject(rect: Object): StiJson;
        static savePointDToJsonObject(pos: Point): StiJson;
        static saveRectangleToJsonObject(rect: Rectangle): StiJson;
        static saveRectangleDToJsonObject(rect: Rectangle): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly type: StiGeomType;
    }
}
declare module Stimulsoft.Base.Context {
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiAnimationGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _animation;
        readonly animation: StiAnimation;
        interaction: StiInteractionDataGeom;
        constructor(animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
declare module Stimulsoft.Base.Context {
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiBorderAnimationGeom extends StiAnimationGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        background: Object;
        borderPen: StiPenGeom;
        rect: Object;
        tag: Object;
        toolTip: String;
        readonly type: StiGeomType;
        constructor(background: Object, borderPen: StiPenGeom, rect: Object, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom, toolTip: String);
    }
}
declare module Stimulsoft.Base.Context {
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiClusteredBarSeriesAnimationGeom extends StiAnimationGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        background: Object;
        borderPen: StiPenGeom;
        columnRect: Object;
        upMove: boolean;
        tag: Object;
        value: Number;
        toolTip: String;
        readonly type: StiGeomType;
        constructor(background: Object, borderPen: StiPenGeom, columnRect: Object, value: Number, toolTip: String, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
declare module Stimulsoft.Base.Context {
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiClusteredColumnSeriesAnimationGeom extends StiAnimationGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        background: Object;
        borderPen: StiPenGeom;
        columnRect: Object;
        toolTip: String;
        tag: Object;
        value: Number;
        readonly type: StiGeomType;
        constructor(background: Object, borderPen: StiPenGeom, columnRect: Object, value: Number, toolTip: String, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
declare module Stimulsoft.Base.Context {
    import Point = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCurveAnimationGeom extends StiAnimationGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        pen: StiPenGeom;
        points: Point[];
        tension: number;
        readonly type: StiGeomType;
        constructor(pen: StiPenGeom, points: Point[], tension: number, animation: StiAnimation);
    }
}
declare module Stimulsoft.Base.Context {
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiEllipseAnimationGeom extends StiAnimationGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        background: Object;
        borderPen: StiPenGeom;
        rect: Object;
        tag: Object;
        toolTip: String;
        readonly type: StiGeomType;
        constructor(background: Object, borderPen: StiPenGeom, rect: Object, toolTip: String, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
declare module Stimulsoft.Base.Context {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiLabelAnimationGeom extends StiAnimationGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        text: string;
        font: StiFontGeom;
        textBrush: Object;
        labelBrush: Object;
        penBorder: StiPenGeom;
        rectangle: Rectangle;
        stringFormat: StiStringFormatGeom;
        angle: number;
        rotationMode: StiRotationMode;
        drawBorder: boolean;
        readonly type: StiGeomType;
        constructor(text: string, font: StiFontGeom, textBrush: Object, LabelBrush: Object, penBorder: StiPenGeom, rect: Rectangle, sf: StiStringFormatGeom, rotationMode: StiRotationMode, angle: number, drawBorder: boolean, animation: StiAnimation);
    }
}
declare module Stimulsoft.Base.Context {
    import Point = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiLinesAnimationGeom extends StiAnimationGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        pen: StiPenGeom;
        points: Point[];
        readonly type: StiGeomType;
        constructor(pen: StiPenGeom, points: Point[], animation: StiAnimation);
    }
}
declare module Stimulsoft.Base.Context {
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiPathAnimationGeom extends StiAnimationGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static getBoundsState: Object;
        background: Object;
        pen: StiPenGeom;
        rect: Object;
        geoms: StiSegmentGeom[];
        tag: Object;
        readonly type: StiGeomType;
        constructor(background: Object, pen: StiPenGeom, geoms: StiSegmentGeom[], rect: Object, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
declare module Stimulsoft.Base.Context {
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiPathElementAnimationGeom extends StiAnimationGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        background: Object;
        borderPen: StiPenGeom;
        rect: Object;
        pathGeoms: StiSegmentGeom[];
        tag: Object;
        toolTip: String;
        readonly type: StiGeomType;
        constructor(background: Object, borderPen: StiPenGeom, pathGeoms: StiSegmentGeom[], rect: Object, toolTip: String, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
declare module Stimulsoft.Base.Context {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiShadowAnimationGeom extends StiAnimationGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        rect: Rectangle;
        radiusX: number;
        radiusY: number;
        shadowWidth: number;
        readonly type: StiGeomType;
        constructor(rect: Rectangle, radiusX: number, radiusY: number, shadowWidth: number, animation: StiAnimation);
    }
}
declare module Stimulsoft.Base.Context {
    enum StiGeomType {
        None = 0,
        Border = 1,
        CachedShadow = 2,
        Curve = 3,
        Ellipse = 4,
        Font = 5,
        Line = 6,
        Lines = 7,
        Path = 8,
        Pen = 9,
        PopSmothingMode = 10,
        PopTextRenderingHint = 11,
        PopTransform = 12,
        PopClip = 13,
        PushClip = 14,
        PushRotateTransform = 15,
        PushSmothingMode = 16,
        PushSmothingModeToAntiAlias = 17,
        PushTextRenderingHint = 18,
        PushTextRenderingHintToAntiAlias = 19,
        PushTranslateTransform = 20,
        Segment = 21,
        Shadow = 22,
        Text = 23,
        StringFormat = 24,
        AnimationBar = 25,
        AnimationBorder = 26,
        AnimationColumn = 27,
        AnimationEllipse = 28,
        AnimationPath = 29,
        AnimationPathElement = 30,
        AnimationLines = 31,
        AnimationCurve = 32,
        AnimationLabel = 33,
        AnimationShadow = 34,
    }
    enum StiPenAlignment {
        Center = 0,
        Inset = 1,
        Outset = 2,
        Left = 3,
        Right = 4,
    }
    enum StiPenLineCap {
        Flat = 0,
        Square = 1,
        Round = 2,
        Triangle = 3,
        NoAnchor = 4,
        SquareAnchor = 5,
        RoundAnchor = 6,
        DiamondAnchor = 7,
        ArrowAnchor = 8,
    }
}
declare module Stimulsoft.Base.Context {
    class StiSegmentGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly type: StiGeomType;
    }
}
declare module Stimulsoft.Base.Context {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiArcSegmentGeom extends StiSegmentGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        rect: Rectangle;
        startAngle: number;
        sweepAngle: number;
        constructor(rect: Rectangle, startAngle: number, sweepAngle: number);
    }
}
declare module Stimulsoft.Base.Context {
    class StiBorderGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        background: Object;
        borderPen: StiPenGeom;
        rect: Object;
        interaction: StiInteractionDataGeom;
        readonly type: StiGeomType;
        constructor(background: Object, borderPen: StiPenGeom, rect: Object, interaction: StiInteractionDataGeom);
    }
}
declare module Stimulsoft.Base.Context {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiShadowSides = Stimulsoft.Base.Drawing.StiShadowSides;
    class StiCachedShadowGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        rect: Rectangle;
        sides: StiShadowSides;
        isPrinting: boolean;
        readonly type: StiGeomType;
        constructor(rect: Rectangle, sides: StiShadowSides, isPrinting: boolean);
    }
}
declare module Stimulsoft.Base.Context {
    class StiCloseFigureSegmentGeom extends StiSegmentGeom {
    }
}
declare module Stimulsoft.Base.Context {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiCurveGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        pen: StiPenGeom;
        tension: number;
        points: Point[];
        readonly type: StiGeomType;
        constructor(pen: StiPenGeom, points: Point[], tension: number);
    }
}
declare module Stimulsoft.Base.Context {
    import Point = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCurveSegmentGeom extends StiSegmentGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        tension: number;
        points: Point[];
        animation: StiAnimation;
        constructor(points: Point[], tension: number, animation?: StiAnimation);
    }
}
declare module Stimulsoft.Base.Context {
    class StiEllipseGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        background: Object;
        borderPen: StiPenGeom;
        rect: Object;
        interaction: StiInteractionDataGeom;
        readonly type: StiGeomType;
        constructor(background: Object, borderPen: StiPenGeom, rect: Object, interaction: StiInteractionDataGeom);
    }
}
declare module Stimulsoft.Base.Context {
    import Font = Stimulsoft.System.Drawing.Font;
    import GraphicsUnit = Stimulsoft.System.Drawing.GraphicsUnit;
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    class StiFontGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static changeFontSize(font: Font, newFontSize: number): StiFontGeom;
        fontName: string;
        fontSize: number;
        fontStyle: FontStyle;
        unit: GraphicsUnit;
        readonly type: StiGeomType;
        constructor(fontName: string, fontSize: number, style: FontStyle, unit: GraphicsUnit);
    }
}
declare module Stimulsoft.Base.Context {
    class StiLineGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        pen: StiPenGeom;
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        readonly type: StiGeomType;
        constructor(pen: StiPenGeom, x1: number, y1: number, x2: number, y2: number);
    }
}
declare module Stimulsoft.Base.Context {
    import Point = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiLineSegmentGeom extends StiSegmentGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        animation: StiAnimation;
        constructor(x1: number | Point, y1: number | Point, x2?: number, y2?: number, animation?: StiAnimation);
    }
}
declare module Stimulsoft.Base.Context {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiLinesGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        pen: StiPenGeom;
        points: Point[];
        readonly type: StiGeomType;
        constructor(pen: StiPenGeom, points: Point[]);
    }
}
declare module Stimulsoft.Base.Context {
    import Point = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiLinesSegmentGeom extends StiSegmentGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        points: Point[];
        animation: StiAnimation;
        constructor(points: Point[], animation?: StiAnimation);
    }
}
declare module Stimulsoft.Base.Context {
    class StiPathGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static getBoundsState: Object;
        background: Object;
        pen: StiPenGeom;
        rect: Object;
        geoms: StiSegmentGeom[];
        interaction: StiInteractionDataGeom;
        readonly type: StiGeomType;
        constructor(background: Object, pen: StiPenGeom, geoms: StiSegmentGeom[], rect: Object, interaction: StiInteractionDataGeom);
    }
}
declare module Stimulsoft.Base.Context {
    class StiPenGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        brush: Object;
        thickness: number;
        penStyle: Stimulsoft.Base.Drawing.StiPenStyle;
        alignment: StiPenAlignment;
        startCap: StiPenLineCap;
        endCap: StiPenLineCap;
        readonly type: StiGeomType;
        constructor(brush: Object, thickness?: number);
    }
}
declare module Stimulsoft.Base.Context {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiPieSegmentGeom extends StiSegmentGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        rect: Rectangle;
        startAngle: number;
        sweepAngle: number;
        animation: StiAnimation;
        constructor(rect: Rectangle, startAngle: number, sweepAngle: number, animation: StiAnimation);
    }
}
declare module Stimulsoft.Base.Context {
    class StiPopClipGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly type: StiGeomType;
    }
}
declare module Stimulsoft.Base.Context {
    class StiPopSmothingModeGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly type: StiGeomType;
    }
}
declare module Stimulsoft.Base.Context {
    class StiPopTextRenderingHintGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly type: StiGeomType;
    }
}
declare module Stimulsoft.Base.Context {
    class StiPopTransformGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly type: StiGeomType;
    }
}
declare module Stimulsoft.Base.Context {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiPushClipGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clipRectangle: Rectangle;
        readonly type: StiGeomType;
        constructor(clipRectangle: Rectangle);
    }
}
declare module Stimulsoft.Base.Context {
    class StiPushRotateTransformGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        angle: number;
        readonly type: StiGeomType;
        constructor(angle: number);
    }
}
declare module Stimulsoft.Base.Context {
    class StiPushSmothingModeToAntiAliasGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly type: StiGeomType;
    }
}
declare module Stimulsoft.Base.Context {
    class StiPushTextRenderingHintToAntiAliasGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly type: StiGeomType;
    }
}
declare module Stimulsoft.Base.Context {
    class StiPushTranslateTransformGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        x: number;
        y: number;
        readonly type: StiGeomType;
        constructor(x: number, y: number);
    }
}
declare module Stimulsoft.Base.Context {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiShadowGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        rect: Rectangle;
        radius: number;
        shadowContext: StiContext;
        readonly type: StiGeomType;
        constructor(shadowContext: StiContext, rect: Rectangle, radius: number);
    }
}
declare module Stimulsoft.Base.Context {
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import HotkeyPrefix = Stimulsoft.System.Drawing.Text.HotkeyPrefix;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
    import StringFormatFlags = Stimulsoft.System.Drawing.StringFormatFlags;
    class StiStringFormatGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        isGeneric: boolean;
        alignment: StringAlignment;
        formatFlags: StringFormatFlags;
        hotkeyPrefix: HotkeyPrefix;
        lineAlignment: StringAlignment;
        trimming: StringTrimming;
        readonly type: StiGeomType;
        constructor(sf: StringFormat);
    }
}
declare module Stimulsoft.Base.Context {
    class StiTextGeom extends StiGeom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        text: string;
        font: StiFontGeom;
        isRounded: boolean;
        isRotatedText: boolean;
        brush: Object;
        location: Object;
        stringFormat: StiStringFormatGeom;
        angle: number;
        antialiasing: boolean;
        maximalWidth: number;
        rotationMode: Stimulsoft.Base.Drawing.StiRotationMode;
        readonly type: StiGeomType;
        constructor(text: string, font: StiFontGeom, brush: Object, location: Object, stringFormat: StiStringFormatGeom, angle: number, antialiasing: boolean, maximalWidth: number, rotationMode: Stimulsoft.Base.Drawing.StiRotationMode, isRotatedText: boolean);
    }
}
declare module Stimulsoft.Base.Context {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Size = Stimulsoft.System.Drawing.Size;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiShadowSides = Stimulsoft.Base.Drawing.StiShadowSides;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiContext {
        render(rect: Rectangle): void;
        getDefaultStringFormat(): StiStringFormatGeom;
        getGenericStringFormat(): StiStringFormatGeom;
        drawString2(text: string, font: StiFontGeom, brush: Object, rect: Rectangle, sf: StiStringFormatGeom): StiTextGeom;
        drawString(text: string, font: StiFontGeom, brush: Object, rect: Rectangle, sf: StiStringFormatGeom): StiTextGeom;
        drawRotatedString2(text: string, font: StiFontGeom, brush: Object, rect: Rectangle, sf: StiStringFormatGeom, angle: number, antialiasing: boolean): StiTextGeom;
        drawRotatedString3(text: string, font: StiFontGeom, brush: Object, rect: Rectangle, sf: StiStringFormatGeom, angle: number, antialiasing: boolean): StiTextGeom;
        drawRotatedString4(text: string, font: StiFontGeom, brush: Object, pos: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean): StiTextGeom;
        drawRotatedString5(text: string, font: StiFontGeom, brush: Object, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean): StiTextGeom;
        drawRotatedString6(text: string, font: StiFontGeom, brush: Object, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean, maximalWidth: number, isRotated?: boolean): StiTextGeom;
        drawRotatedString7(text: string, font: StiFontGeom, brush: Object, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean, maximalWidth: number): StiTextGeom;
        drawRotatedString8(text: string, font: StiFontGeom, brush: Object, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean): StiTextGeom;
        drawRotatedString9(text: string, font: StiFontGeom, brush: Object, pos: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean, maximalWidth: number): StiTextGeom;
        measureString(text: string, font: StiFontGeom): Size;
        measureString2(text: string, font: StiFontGeom, width: number, sf: StiStringFormatGeom): Size;
        measureRotatedString(text: string, font: StiFontGeom, rect: Rectangle, sf: StiStringFormatGeom, angle: number): Rectangle;
        measureRotatedString2(text: string, font: StiFontGeom, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, maximalWidth?: number): Rectangle;
        measureRotatedString3(text: string, font: StiFontGeom, point: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, maximalWidth: number): Rectangle;
        measureRotatedString4(text: string, font: StiFontGeom, point: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number): Rectangle;
        drawShadow(sg: StiContext, rect: Rectangle, radius: number): void;
        drawCachedShadow(rect: Rectangle, sides: StiShadowSides, isPrinting: boolean): void;
        createShadowGraphics(): StiContext;
        pushTranslateTransform(x: number, y: number): void;
        pushRotateTransform(angle: number): void;
        popTransform(): void;
        pushClip(clipRect: Rectangle): void;
        popClip(): void;
        drawAnimationColumn(brush: Object, borderPen: StiPenGeom, rect: Object, value: Number, toolTip: String, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        drawAnimationBar(brush: Object, borderPen: StiPenGeom, columnRect: Object, value: Number, toolTip: String, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        drawAnimationRectangle(brush: Object, pen: StiPenGeom, rect: Rectangle, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom, tooltip: String): void;
        drawAnimationPathElement(brush: Object, borderPen: StiPenGeom, path: StiSegmentGeom[], rect: Object, toolTip: String, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        drawAnimationLabel(text: string, font: StiFontGeom, textBrush: Object, labelBrush: Object, penBorder: StiPenGeom, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, drawBorder: boolean, animation: StiAnimation): void;
        drawAnimationLines(pen: StiPenGeom, points: Point[], animation: StiAnimation): void;
        drawAnimationCurve(pen: StiPenGeom, points: Point[], tension: number, animation: StiAnimation): void;
        fillDrawAnimationPath(brush: Object, pen: StiPenGeom, path: StiSegmentGeom[], rect: Object, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        fillDrawAnimationEllipse(brush: Object, pen: StiPenGeom, x: number, y: number, width: number, height: number, toolTip: String, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        drawLine(pen: StiPenGeom, x1: number, y1: number, x2: number, y2: number): void;
        drawLines(pen: StiPenGeom, points: Point[]): void;
        drawRectangle(pen: StiPenGeom, rect: Rectangle): void;
        drawRectangle2(pen: StiPenGeom, x: number, y: number, width: number, height: number): void;
        drawEllipse(pen: StiPenGeom, x: number, y: number, width: number, height: number): void;
        drawEllipse2(pen: StiPenGeom, rect: Rectangle): void;
        fillEllipse(brush: Object, x: number, y: number, width: number, height: number, interaction: StiInteractionDataGeom): void;
        fillEllipse2(brush: Object, rect: Rectangle, interaction: StiInteractionDataGeom): void;
        drawPath(pen: StiPenGeom, path: StiSegmentGeom[], rect: Object): void;
        fillPath(brush: Object, path: StiSegmentGeom[], rect: Object, interaction: StiInteractionDataGeom): void;
        drawCurve(pen: StiPenGeom, points: Point[], tension: number): void;
        fillRectangle(brush: Object, rect: Rectangle, interaction: StiInteractionDataGeom): void;
        fillRectangle2(brush: Object, x: number, y: number, width: number, height: number, interaction: StiInteractionDataGeom): void;
        pushSmoothingModeToAntiAlias(): void;
        popSmoothingMode(): void;
        pushTextRenderingHintToAntiAlias(): void;
        popTextRenderingHint(): void;
        getPathBounds(geoms: StiSegmentGeom[]): Rectangle;
        geoms: StiGeom[];
        private _contextPainter;
        readonly contextPainter: StiContextPainter;
        private _options;
        readonly options: StiContextOptions;
        drawShadowRect(rect: Rectangle, shadowWidth: number, animation: StiAnimation): void;
        drawShadowRect2(rect: Rectangle, radiusX: number, radiusY: number, shadowWidth: number, animation: StiAnimation): void;
        constructor(contextPainter: StiContextPainter, isGdi: boolean, isWpf: boolean, isPrinting: boolean, zoom: number);
    }
}
declare module Stimulsoft.Base.Context {
    class StiContextOptions {
        readonly isPrinting: boolean;
        private _isWpf;
        readonly isWpf: boolean;
        private _isGdi;
        readonly isGdi: boolean;
        private _zoom;
        readonly zoom: number;
        constructor(isGdi: boolean, isWpf: boolean, isPrinting: boolean, zoom: number);
    }
}
declare module Stimulsoft.Base.Drawing {
    enum StiAction {
        None = 0,
        Move = 1,
        Select = 2,
        SizeLeft = 3,
        SizeRight = 4,
        SizeTop = 5,
        SizeBottom = 6,
        SizeLeftTop = 7,
        SizeLeftBottom = 8,
        SizeRightTop = 9,
        SizeRightBottom = 10,
        ResizeColumns = 11,
        ResizeRows = 12,
        SelectColumn = 13,
        SelectRow = 14,
    }
    enum StiBorderSides {
        None = 0,
        All = 15,
        Top = 1,
        Left = 2,
        Right = 4,
        Bottom = 8,
    }
    enum StiPenStyle {
        Solid = 0,
        Dash = 1,
        DashDot = 2,
        DashDotDot = 3,
        Dot = 4,
        Double = 5,
        None = 6,
    }
    enum StiRotationMode {
        LeftTop = 0,
        LeftCenter = 1,
        LeftBottom = 2,
        CenterTop = 3,
        CenterCenter = 4,
        CenterBottom = 5,
        RightTop = 6,
        RightCenter = 7,
        RightBottom = 8,
    }
    enum StiShadowSides {
        Top = 1,
        Right = 2,
        Edge = 4,
        Bottom = 8,
        Left = 16,
        All = 31,
    }
    enum StiVertAlignment {
        Top = 0,
        Center = 1,
        Bottom = 2,
    }
    enum StiTextHorAlignment {
        Left = 0,
        Center = 1,
        Right = 2,
        Width = 3,
    }
    enum StiHorAlignment {
        Left = 1,
        Center = 2,
        Right = 3,
    }
    enum StiTextDockMode {
        Top = 0,
        Bottom = 1,
        Left = 2,
        Right = 3,
    }
}
declare module Stimulsoft.Base.Context {
    import Size = Stimulsoft.System.Drawing.Size;
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    class StiContextPainter {
        private _svgRect;
        private svgObj;
        readonly svgRect: any;
        getDefaultStringFormat(): StiStringFormatGeom;
        getGenericStringFormat(): StiStringFormatGeom;
        createShadowGraphics(isPrinting: boolean, zoom: number): StiContext;
        getPathBounds(geoms: StiSegmentGeom[]): Rectangle;
        measureString(text: string, font: StiFontGeom, width?: number, sf?: StiStringFormatGeom): Size;
        measureRotatedString1(text: string, font: StiFontGeom, rect: Rectangle, sf: StiStringFormatGeom, angle: number): Rectangle;
        measureRotatedString2(text: string, font: StiFontGeom, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, maximalWidth?: number): Rectangle;
        measureRotatedString3(text: string, font: StiFontGeom, point: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, maximalWidth: number): Rectangle;
        measureRotatedString4(text: string, font: StiFontGeom, point: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number): Rectangle;
        private getStartPoint(rotationMode, textRect);
        render(rect: Rectangle, geoms: StiGeom[]): any;
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiGaugeGeom {
        readonly type: StiGaugeGeomType;
        animation: StiAnimation;
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiEllipseGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly type: StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number);
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiGraphicsArcGeometryGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly startAngle: number;
        readonly sweepAngle: number;
        readonly startWidth: number;
        readonly endWidth: number;
        readonly type: StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number, startAngle: number, sweepAngle: number, startWidth: number, endWidth: number);
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    class StiGraphicsPathArcGaugeGeom extends StiGaugeGeom {
        readonly x: number;
        readonly y: number;
        readonly width: number;
        readonly height: number;
        readonly startAngle: number;
        readonly sweepAngle: number;
        readonly type: StiGaugeGeomType;
        constructor(x: number, y: number, width: number, height: number, startAngle: number, sweepAngle: number);
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    class StiGraphicsPathCloseFigureGaugeGeom extends StiGaugeGeom {
        readonly type: StiGaugeGeomType;
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiGraphicsPathGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly startPoint: Point;
        readonly type: StiGaugeGeomType;
        private _geoms;
        readonly geoms: StiGaugeGeom[];
        addGraphicsPathArcGaugeGeom(x: number, y: number, width: number, height: number, startAngle: number, sweepAngle: number): void;
        addGraphicsPathCloseFigureGaugeGeom(): void;
        addGraphicsPathLinesGaugeGeom(points: Point[]): void;
        addGraphicsPathLineGaugeGeom(p1: Point, p2: Point): void;
        constructor(rect: Rectangle, startPoint: Point, background: StiBrush, borderBrush: StiBrush, borderWidth: number);
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiGraphicsPathLineGaugeGeom extends StiGaugeGeom {
        readonly p1: Point;
        readonly p2: Point;
        readonly type: StiGaugeGeomType;
        constructor(p1: Point, p2: Point);
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiGraphicsPathLinesGaugeGeom extends StiGaugeGeom {
        readonly points: Point[];
        readonly type: StiGaugeGeomType;
        constructor(points: Point[]);
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiPieGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly startAngle: number;
        readonly sweepAngle: number;
        readonly type: StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number, startAngle: number, sweepAngle: number);
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    class StiPopTranformGaugeGeom extends StiGaugeGeom {
        readonly type: StiGaugeGeomType;
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiPushMatrixGaugeGeom extends StiGaugeGeom {
        readonly angle: number;
        readonly centerPoint: Point;
        readonly type: StiGaugeGeomType;
        constructor(angle: number, centerPoint: Point);
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRadialRangeGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly centerPoint: Point;
        readonly startAngle: number;
        readonly sweepAngle: number;
        readonly radius1: number;
        readonly radius2: number;
        readonly radius3: number;
        readonly radius4: number;
        readonly type: StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number, centerPoint: Point, startAngle: number, sweepAngle: number, radius1: number, radius2: number, radius3: number, radius4: number);
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRectangleGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly type: StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number);
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRoundedRectangleGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly leftTop: number;
        readonly rightTop: number;
        readonly rightBottom: number;
        readonly leftBottom: number;
        readonly type: StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number, leftTop: number, rightTop: number, rightBottom: number, leftBottom: number);
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    class StiTextGaugeGeom extends StiGaugeGeom {
        readonly text: string;
        readonly font: Font;
        readonly foreground: StiBrush;
        readonly rect: Rectangle;
        readonly stringFormat: StringFormat;
        readonly type: StiGaugeGeomType;
        constructor(text: string, font: Font, foreground: StiBrush, rect: Rectangle, sf: StringFormat);
    }
}
declare module Stimulsoft.Report.Gauge {
    enum StiGaugeGeomType {
        GraphicsPath = 0,
        GraphicsPathArc = 1,
        GraphicsPathCloseFigure = 2,
        RoundedRectangle = 3,
        Rectangle = 4,
        Pie = 5,
        Ellipse = 6,
        GraphicsArcGeometry = 7,
        PushMatrix = 8,
        PopTranform = 9,
        GraphicsPathLines = 10,
        GraphicsPathLine = 11,
        Text = 12,
        RadialRange = 13,
    }
}
declare module Stimulsoft.Report.Gauge {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    var IStiGaugeMarker: string;
    interface IStiGaugeMarker {
        showValue: boolean;
        textBrush: StiBrush;
        font: Font;
        format: string;
    }
}
declare module Stimulsoft.Base.Maps.Geoms {
    enum StiMapGeomType {
        MoveTo = 0,
        Line = 1,
        Bezier = 2,
        Beziers = 3,
        Close = 4,
    }
}
declare module Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiMapGeom {
        readonly geomType: StiMapGeomType;
        getLastPoint(): Point;
    }
}
declare module Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiBezierMapGeom extends StiMapGeom {
        readonly geomType: StiMapGeomType;
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        x3: number;
        y3: number;
        getLastPoint(): Point;
    }
}
declare module Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiBeziersMapGeom extends StiMapGeom {
        readonly geomType: StiMapGeomType;
        array: number[];
        getLastPoint(): Point;
    }
}
declare module Stimulsoft.Base.Maps.Geoms {
    class StiCloseMapGeom extends StiMapGeom {
        readonly geomType: StiMapGeomType;
    }
}
declare module Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiLineMapGeom extends StiMapGeom {
        readonly geomType: StiMapGeomType;
        x: number;
        y: number;
        getLastPoint(): Point;
    }
}
declare module Stimulsoft.Base.Maps.Geoms {
    class StiMapGeomsContainer {
        name: string;
        width: number;
        height: number;
        geoms: StiMapGeomsObject[];
    }
}
declare module Stimulsoft.Base.Maps.Geoms {
    class StiMapGeomsObject {
        name: string;
        geoms: StiMapGeom[];
    }
}
declare module Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiMoveToMapGeom extends StiMapGeom {
        readonly geomType: StiMapGeomType;
        x: number;
        y: number;
        getLastPoint(): Point;
    }
}
declare module Stimulsoft.Base.Context {
    class StiInteractionDataGeom {
        constructor();
        componentName: String;
        pageGuid: String;
        componentIndex: String;
        pageIndex: String;
        elementIndex: String;
    }
}
declare module Stimulsoft.Base {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiCsvHelper {
        static codePageCodes: number[];
        static codePageNames: string[];
        static getTable(path: string, codePage?: number, separator?: string): DataTable;
        static getDataSet(data: number[], tableName: string, codePage: number, separator: string): DataSet;
        static getTable2(data: number[], codePage?: number, separator?: string, loadData?: boolean): DataTable;
        private static splitToColumns(REFinputString, sr, delimiter);
    }
}
declare module Stimulsoft.Base {
    class StiDataNameValidator {
        static correct(str: string): string;
    }
}
declare module Stimulsoft.Base {
    class StiFileItemTable {
        static defaultCsvTableName: string;
        static defaultDBaseTableName: string;
    }
}
declare module Stimulsoft.Base {
    class StiObjectSchema {
        name: string;
    }
}
declare module Stimulsoft.Base {
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiDataSchema extends StiObjectSchema {
        tables: StiDataTableSchema[];
        views: StiDataTableSchema[];
        storedProcedures: StiDataTableSchema[];
        queries: StiDataTableSchema[];
        relations: StiDataRelationSchema[];
        connectionIdent: StiConnectionIdent;
        isEmpty(): boolean;
        getDataSet(): DataSet;
        sort(): StiDataSchema;
        constructor(ident?: StiConnectionIdent);
    }
}
declare module Stimulsoft.Base {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import Type = Stimulsoft.System.Type;
    class StiODataHelper {
        connectionString: string;
        readonly address: string;
        readonly userName: string;
        readonly password: string;
        readonly addressBearer: string;
        private getConnectionStringKey(key);
        private getConnectionStringKey1();
        private bearerAccessToken;
        retrieveSchema(): StiDataSchema;
        fillDataTable(table: DataTable, query: string): void;
        testConnection(): StiTestConnectionResult;
        static getNetType(dbType: string): Type;
        static getBearerAccessToken(url: string, userName: string, password: string): string;
        private getDefaultWebClient();
        constructor(connectionString: string);
    }
}
declare module Stimulsoft.Base {
    class StiDataLoaderHelperData {
        name: string;
        array: any;
        toList(): StiDataLoaderHelperData[];
        constructor(name: string, array: any);
    }
    class StiDataLoaderHelper {
        static loadMultiple(path: string, fileExt: string, binary: boolean): StiDataLoaderHelperData[];
        static loadSingle(path: string, binary: boolean): StiDataLoaderHelperData;
    }
}
declare module Stimulsoft.Base {
    class StiFileUrlHelper {
        static get(path: string): number[];
    }
}
declare module Stimulsoft.Base {
    class StiTestConnectionResult {
        success: boolean;
        notice: string;
        static makeWrong(notice: string): StiTestConnectionResult;
        static makeWrong2(exception: string): StiTestConnectionResult;
        static makeWrong3(): StiTestConnectionResult;
        static makeFine(): StiTestConnectionResult;
    }
}
declare module Stimulsoft.Base {
    class StiDataColumnSchema extends StiObjectSchema {
        type: Stimulsoft.System.Type;
        constructor(name?: string, type?: Stimulsoft.System.Type);
    }
}
declare module Stimulsoft.Base {
    class StiDataParameterSchema extends StiObjectSchema {
        type: Stimulsoft.System.Type;
        value: Object;
        constructor(name?: string, type?: Stimulsoft.System.Type);
    }
}
declare module Stimulsoft.Base {
    class StiDataRelationSchema {
        name: string;
        parentSourceName: string;
        childSourceName: string;
        childColumns: string[];
        parentColumns: string[];
    }
}
declare module Stimulsoft.Base {
    class StiDataTableSchema extends StiObjectSchema {
        columns: StiDataColumnSchema[];
        parameters: StiDataParameterSchema[];
        query: string;
        static newTableOrView(name: string, connector?: any, query?: string): StiDataTableSchema;
        static newTable(name: string, connector?: any, query?: string): StiDataTableSchema;
        static newView(name: string, connector?: any, query?: string): StiDataTableSchema;
        static newProcedure(name: string, connector?: any, query?: string): StiDataTableSchema;
        constructor(name?: string, query?: string);
    }
}
declare module Stimulsoft.Base {
    enum StiDataFormatType {
        Xml = 0,
        Json = 1,
    }
    enum StiRetrieveColumnsMode {
        KeyInfo = 0,
        SchemaOnly = 1,
        FillSchema = 2,
    }
    enum StiConnectionIdent {
        Db2DataSource = 1,
        InformixDataSource = 2,
        MsAccessDataSource = 3,
        MsSqlDataSource = 4,
        MySqlDataSource = 5,
        OdbcDataSource = 6,
        OleDbDataSource = 7,
        FirebirdDataSource = 8,
        PostgreSqlDataSource = 9,
        OracleDataSource = 10,
        SqlCeDataSource = 11,
        SqLiteDataSource = 12,
        SybaseDataSource = 13,
        TeradataDataSource = 14,
        VistaDbDataSource = 15,
        UniversalDevartDataSource = 16,
        ODataDataSource = 17,
        CsvDataSource = 18,
        DBaseDataSource = 19,
        DynamicsNavDataSource = 20,
        ExcelDataSource = 21,
        JsonDataSource = 22,
        XmlDataSource = 23,
        DropboxCloudStorage = 24,
        GoogleDriveCloudStorage = 25,
        OneDriveCloudStorage = 26,
        SharePointCloudStorage = 27,
        Unspecified = 28,
    }
    enum StiConnectionOrder {
        MsSqlDataSource = 10,
        MySqlDataSource = 20,
        OdbcDataSource = 30,
        OleDbDataSource = 40,
        OracleDataSource = 50,
        MsAccessDataSource = 60,
        PostgreSqlDataSource = 70,
        FirebirdDataSource = 80,
        SqlCeDataSource = 90,
        SqLiteDataSource = 100,
        Db2DataSource = 110,
        InformixDataSource = 120,
        SybaseDataSource = 130,
        TeradataDataSource = 140,
        VistaDbDataSource = 150,
        UniversalDevartDataSource = 160,
        ODataDataSource = 170,
        ExcelDataSource = 180,
        JsonDataSource = 190,
        XmlDataSource = 200,
        CsvDataSource = 210,
        DBaseDataSource = 220,
        DynamicsNavDataSource = 230,
        DropboxCloudStorage = 240,
        GoogleDriveCloudStorage = 250,
        OneDriveCloudStorage = 260,
        SharePointCloudStorage = 270,
        Unspecified = 0,
    }
    enum StiFileType {
        Unknown = 1,
        ReportSnapshot = 2,
        Pdf = 3,
        Xps = 4,
        PowerPoint = 5,
        Html = 6,
        Text = 7,
        RichText = 8,
        Word = 9,
        OpenDocumentWriter = 10,
        Excel = 11,
        OpenDocumentCalc = 12,
        Data = 13,
        Image = 14,
        Xml = 15,
        Xsd = 16,
        Csv = 17,
        Dbf = 18,
        Sylk = 19,
        Dif = 20,
        Json = 21,
    }
}
declare module Stimulsoft.Base {
    class StiTableQuery {
        private correctName(name);
        getName(schema: string, table: string): string;
        getSelectQuery1(table: string): string;
        getSelectQuery2(schema: string, table: string): string;
        getExecuteQuery1(table: string): string;
        getExecuteQuery2(schema: string, table: string): string;
        getCallQuery1(table: string): string;
        getCallQuery2(schema: string, table: string): string;
        getProcQuery1(table: string): string;
        getProcQuery2(schema: string, table: string): string;
        static get(adapter: any): StiTableQuery;
        private adapter;
        constructor(adapter: any);
    }
}
/**
 * @hidden
 */
interface IProperties {
    LastAuthor?: string;
    Author?: string;
    CreatedDate?: Date;
    ModifiedDate?: Date;
    Application?: string;
    AppVersion?: string;
    Company?: string;
    DocSecurity?: string;
    Manager?: string;
    HyperlinksChanged?: boolean;
    SharedDoc?: boolean;
    LinksUpToDate?: boolean;
    ScaleCrop?: boolean;
    Worksheets?: number;
    SheetNames?: string[];
}
/**
 * @hidden
 */
interface IParsingOptions {
    cellFormula?: boolean;
    cellHTML?: boolean;
    cellNF?: boolean;
    cellStyles?: boolean;
    cellDates?: boolean;
    sheetStubs?: boolean;
    sheetRows?: number;
    bookDeps?: boolean;
    bookFiles?: boolean;
    bookProps?: boolean;
    bookSheets?: boolean;
    bookVBA?: boolean;
    password?: string;
    /**
     * Possible options: 'binary', 'base64', 'buffer', 'file'
     */
    type?: string;
}
/**
 * @hidden
 */
interface IWorkBook {
    /**
     * A dictionary of the worksheets in the workbook.
     * Use SheetNames to reference these.
     */
    Sheets: {
        [sheet: string]: IWorkSheet;
    };
    /**
     * ordered list of the sheet names in the workbook
     */
    SheetNames: string[];
    /**
     * an object storing the standard properties. wb.Custprops stores custom properties.
     * Since the XLS standard properties deviate from the XLSX standard, XLS parsing stores core properties in both places.
     */
    Props: IProperties;
}
/**
 * object representing the worksheet
 * @hidden
 */
interface IWorkSheet {
    [cell: string]: IWorkSheetCell;
}
/**
 * @hidden
 */
interface IWorkSheetCell {
    /**
     * The Excel Data Type of the cell.
     * b Boolean, n Number, e error, s String, d Date
     */
    t: string;
    /**
     * The raw value of the cell.
     */
    v: string;
    /**
     * rich text encoding (if applicable)
     */
    r?: string;
    /**
     * HTML rendering of the rich text (if applicable)
     */
    h?: string;
    /**
     * formatted text (if applicable)
     */
    w?: string;
    /**
     * cell formula (if applicable)
     */
    f?: string;
    /**
     * comments associated with the cell **
     */
    c?: string;
    /**
     * number format string associated with the cell (if requested)
     */
    z?: string;
    /**
     * cell hyperlink object (.Target holds link, .tooltip is tooltip)
     */
    l?: string;
    /**
     * the style/theme of the cell (if applicable)
     */
    s?: string;
}
/**
 * @hidden
 */
interface IUtils {
    sheet_to_json<T>(worksheet: IWorkSheet): T[];
    sheet_to_csv(worksheet: IWorkSheet): any;
    sheet_to_formulae(worksheet: IWorkSheet): any;
}
/**
 * @hidden
 */
declare let XLSX: {
    utils: IUtils;
    readFile(filename: string, opts?: IParsingOptions): IWorkBook;
    read(data: any, opts?: IParsingOptions): IWorkBook;
};
/**
 * @hidden
 */
declare module "xlsx" {
    export = XLSX;
}
declare module Stimulsoft.Base.Drawing {
    var PointD: typeof System.Drawing.Point;
}
declare module Stimulsoft.Base.Drawing {
    var RectangleD1: typeof System.Drawing.Rectangle;
}
declare module Stimulsoft.Base.Drawing {
    var SizeD: typeof System.Drawing.Size;
}
declare module Stimulsoft.Base.Drawing {
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiActionUtils {
        static pointInEdge(x: number, y: number, point: Point, size: number): boolean;
        static pointInRect(x: number, y: number, rect: Rectangle): boolean;
    }
}
declare module Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSolidBrush extends StiBrush {
        private _color;
        color: Color;
        constructor(color?: Color);
    }
}
declare module Stimulsoft.Base.Drawing {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    class StiBorder implements ICloneable {
        implements(): string[];
        private bits;
        /** Creates a new object that is a copy of the current instance. */
        clone(): StiBorder;
        stiEquals(other: StiBorder): boolean;
        stiEquals(obj: Object): boolean;
        getSizeOffset(): number;
        getHashCode(): number;
        private defaultHashCode;
        draw(g: Graphics, rect: Rectangle, zoom: number, emptyColor?: Color, drawBorderFormatting?: boolean, drawBorderSides?: boolean): void;
        drawBorderShadow(g: Graphics, rect: Rectangle, zoom: number): void;
        /** Gets value which indicates that top side of border is present. */
        readonly isTopBorderSidePresent: boolean;
        /** Gets value which indicates that bottom side of border is present. */
        readonly isBottomBorderSidePresent: boolean;
        /** Gets value which indicates that left side of border is present. */
        readonly isLeftBorderSidePresent: boolean;
        /** Gets value which indicates that right side of border is present. */
        readonly isRightBorderSidePresent: boolean;
        /** Gets value which indicates that all sides of border is present. */
        readonly isAllBorderSidesPresent: boolean;
        private readonly isDefaultShadowBrush;
        /** Gets or sets frame borders. */
        side: StiBorderSides;
        /** Gets or sets a border color. */
        color: Color;
        /** Gets or sets a border size. */
        size: number;
        /** Gets or sets a border style. */
        style: StiPenStyle;
        private _shadowBrush;
        /** Gets or sets the border shadow brush. */
        shadowBrush: StiBrush;
        /** Gets or sets Shadow Size. */
        shadowSize: StiPenStyle;
        /** Gets or sets value which indicates drop shadow or not. */
        dropShadow: boolean;
        /** Gets or sets value which indicates that border sides will be drawn on top of all components. */
        topmost: boolean;
        /** Gets value indicates, that this object-frame is by default. */
        readonly isDefault: boolean;
        static loadFromXml(text: string): StiBorder;
        constructor(side?: StiBorderSides, color?: Color, size?: number, style?: StiPenStyle, dropShadow?: boolean, shadowSize?: number, shadowBrush?: StiBrush, topmost?: boolean);
    }
}
declare module Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiAdvancedBorder extends StiBorder {
        /** Creates a new object that is a copy of the current instance. */
        clone(): StiAdvancedBorder;
        stiEquals(other: StiAdvancedBorder): boolean;
        stiEquals(obj: Object): boolean;
        getHashCode(): number;
        private _leftSide;
        /** Gets or sets frame of left side. */
        readonly leftSide: StiBorderSide;
        private _rightSide;
        /** Gets or sets frame of right side. */
        readonly rightSide: StiBorderSide;
        private _topSide;
        /** Gets or sets frame of top side. */
        readonly topSide: StiBorderSide;
        private _bottomSide;
        /** Gets or sets frame of bottom side. */
        readonly bottomSide: StiBorderSide;
        /** Gets value which indicates that top side of border is present. */
        readonly isTopBorderSidePresent: boolean;
        /** Gets value which indicates that bottom side of border is present. */
        readonly isBottomBorderSidePresent: boolean;
        /** Gets value which indicates that left side of border is present. */
        readonly isLeftBorderSidePresent: boolean;
        /** Gets value which indicates that right side of border is present. */
        readonly isRightBorderSidePresent: boolean;
        /** Gets value which indicates that all sides of border is present. */
        readonly isAllBorderSidesPresent: boolean;
        /** Gets or sets frame borders. Not used in StiAdvancedBorder. */
        side: StiBorderSides;
        /** Gets or sets a border color. Not used in StiAdvancedBorder. */
        color: Color;
        /** Gets or sets a border size. Not used in StiAdvancedBorder. */
        size: number;
        /** Gets or sets a border style. Not used in StiAdvancedBorder. */
        style: StiPenStyle;
        /** Gets value indicates, that this object-frame is by default. */
        readonly isDefault: boolean;
        constructor(topSide?: StiBorderSide, bottomSide?: StiBorderSide, leftSide?: StiBorderSide, rightSide?: StiBorderSide, dropShadow?: boolean, shadowSize?: number, shadowBrush?: StiBrush, topmost?: boolean);
    }
}
declare module Stimulsoft.Base.Drawing {
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBorderSide implements ICloneable {
        implements(): string[];
        /** Creates a new object that is a copy of the current instance. */
        clone(): StiBorderSide;
        stiEquals(other: StiBorderSide): boolean;
        stiEquals(obj: Object): boolean;
        getHashCode(): number;
        getSizeOffset(): number;
        side: StiBorderSides;
        private _color;
        /** Gets or sets a border color. */
        color: Color;
        private _size;
        /** Gets or sets a border size. */
        size: number;
        private _style;
        /** Gets or sets a border style. */
        style: StiPenStyle;
        /** Gets value indicates, that this object-frame is by default. */
        readonly isDefault: boolean;
        /** Creates a new instance of the StiBorderSide class. */
        constructor(color?: Color, size?: number, style?: StiPenStyle);
    }
}
declare module Stimulsoft.Base.Drawing {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    enum StiCapStyle {
        None = 0,
        Arrow = 1,
        Open = 2,
        Stealth = 3,
        Diamond = 4,
        Square = 5,
        Oval = 6,
    }
    class StiCap implements ICloneable {
        implements(): string[];
        clone(): StiCap;
        private _width;
        width: number;
        private _style;
        style: StiCapStyle;
        private _height;
        height: number;
        private _fill;
        fill: boolean;
        private _color;
        color: Color;
        loadFromXml(xmlNode: XmlNode): void;
        constructor(width?: number, style?: StiCapStyle, height?: number, fill?: boolean, color?: Color);
    }
}
declare module Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiColorUtils {
        static light(baseColor: Color, value: number): Color;
        static mixingColors(color1: Color, color2: Color, alpha: number): Color;
        static dark(baseColor: Color, value: number): Color;
    }
}
declare module Stimulsoft.Base.Drawing {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Brush = Stimulsoft.System.Drawing.Brush;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiDrawing {
        static fillRectangle(g: Graphics, brush: Brush, arg: number | Rectangle, y?: number, width?: number, height?: number): void;
    }
}
declare module Stimulsoft.Base.Drawing {
    class StiEmptyBrush extends StiBrush {
        stiEquals(obj: Object): boolean;
        private defaultHashCode;
        getHashCode(): number;
    }
}
declare module Stimulsoft.Base.Drawing {
    import Font = Stimulsoft.System.Drawing.Font;
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    class StiFontUtils {
        static correctStyle(fontName: string, style: FontStyle): FontStyle;
        static changeFontName(font: Font, newFontName: string): Font;
        static changeFontSize(font: Font, newFontSize: number): Font;
        static changeFontStyleBold(font: Font, bold: boolean): Font;
        static changeFontStyleItalic(font: Font, italic: boolean): Font;
        static changeFontStyleUnderline(font: Font, underline: boolean): Font;
        static changeFontStyleStrikeout(font: Font, strikeout: boolean): Font;
    }
}
declare module Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGlareBrush extends StiBrush {
        private _startColor;
        /** Gets or sets the starting color for the gradient. */
        startColor: Color;
        private _endColor;
        /** Gets or sets the ending color for the gradient. */
        endColor: Color;
        private _angle;
        /** Gets or sets the angle, measured in degrees clockwise from the x-axis, of the gradient's orientation line. */
        angle: number;
        private _focus;
        /** Gets or sets value from 0 through 1 that specifies the center of the gradient (the point where the gradient is composed of only the ending color). */
        focus: number;
        private _scale;
        /** Gets or sets value from 0 through 1 that specifies how fast the colors falloff from the focus. */
        scale: number;
        stiEquals(obj: Object): boolean;
        private defaultHashCode;
        getHashCode(): number;
        constructor(startColor?: Color, endColor?: Color, angle?: number, focus?: number, scale?: number);
    }
}
declare module Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiGlassBrush extends StiBrush {
        private _color;
        /** Gets or sets the color of this StiGlassBrush object. */
        color: Color;
        private _drawHatch;
        /** Gets or sets value which indicates draw hatch at background or not. */
        drawHatch: boolean;
        private _blend;
        /** Gets or sets blend factor. */
        blend: number;
        stiEquals(obj: Object): boolean;
        private defaultHashCode;
        getHashCode(): number;
        getTopColor(): Color;
        getTopColorLight(): Color;
        getBottomColor(): Color;
        getBottomColorLight(): Color;
        getTopRectangle(rect: Rectangle): Rectangle;
        getBottomRectangle(rect: Rectangle): Rectangle;
        constructor(color?: Color, drawHatch?: boolean, blend?: number);
    }
}
declare module Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGradientBrush extends StiBrush {
        private _startColor;
        /** Gets or sets the starting color for the gradient. */
        startColor: Color;
        private _endColor;
        /** Gets or sets the ending color for the gradient. */
        endColor: Color;
        private _angle;
        /** Gets or sets the angle, measured in degrees clockwise from the x-axis, of the gradient's orientation line. */
        angle: number;
        stiEquals(obj: Object): boolean;
        private defaultHashCode;
        getHashCode(): number;
        constructor(startColor?: Color, endColor?: Color, angle?: number);
    }
}
declare module Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    import HatchStyle = Stimulsoft.System.Drawing.Drawing2D.HatchStyle;
    class StiHatchBrush extends StiBrush {
        private _backColor;
        /** Gets the color of spaces between the hatch lines drawn by this StiHatchBrush object. */
        backColor: Color;
        private _foreColor;
        /** Gets the color of hatch lines drawn by this StiHatchBrush object. */
        foreColor: Color;
        private _style;
        /** Gets the hatch style of this StiHatchBrush object. */
        style: HatchStyle;
        stiEquals(obj: Object): boolean;
        private defaultHashCode;
        getHashCode(): number;
        constructor(style?: HatchStyle, foreColor?: Color, backColor?: Color);
    }
}
declare module Stimulsoft.Base.Drawing {
    import ImageCodecInfo = Stimulsoft.System.Drawing.Imaging.ImageCodecInfo;
    class StiImageCodecInfo {
        static getImageCodec(mimeType: string): ImageCodecInfo;
    }
}
declare module Stimulsoft.Base.Drawing {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImageConverter {
        static imageToString(image: Image): string;
        static bytesToImage(bytes: number[]): Image;
        static stringToImage(str: string): Image;
    }
}
declare module Stimulsoft.Base.Drawing {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImageFromURL {
        static loadBitmap(url: string): Image;
        static loadImage(url: string): Image;
    }
}
declare module Stimulsoft.Base.Drawing {
    import DashStyle = Stimulsoft.System.Drawing.Drawing2D.DashStyle;
    class StiPenUtils {
        static getPenStyle(penStyle: StiPenStyle): DashStyle;
    }
}
declare module Stimulsoft.Base.Drawing {
    import Size = Stimulsoft.System.Drawing.Size;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiTextDrawing {
        static measureString(g: Graphics, text: string, font: Font, width: number, textOptions: StiTextOptions, ha: StiTextHorAlignment, va: StiVertAlignment, antialiasing: boolean): Size;
    }
}
declare module Stimulsoft.Base {
    import DateTime = Stimulsoft.System.DateTime;
    class StiJson {
        static dateToJsonDate(date: DateTime): string;
        static jsonDateFormatToDate(jsonDate: string): DateTime;
        name: string;
        value: any;
        private isProperty;
        private isArray;
        properties(): StiJson[];
        removeProperty(propertyName: string): void;
        addPropertyNumber(propertyName: string, value: number, defaultValue?: number): void;
        addPropertyNumberNoDefaultValue(propertyName: string, value: number): void;
        addPropertyJObject(propertyName: string, value: StiJson): void;
        addPropertyJObjectArray(propertyName: string, values: StiJson[]): void;
        addPropertyIdent(propertyName: string, value: string): void;
        addPropertyBool(propertyName: string, value: boolean, defaultValue?: boolean): void;
        addPropertyDateTime(propertyName: string, value: DateTime): void;
        addPropertyEnum(propertyName: string, enumType: Object, value: any, defaultValue?: any): void;
        addPropertyString(propertyName: string, value: string, defaultValue?: string): void;
        addPropertyStringNullOfEmpty(propertyName: string, value: string): void;
        readonly count: number;
        serialize(): string;
        deserialize(text: any): void;
        private deserializeFromObject(child);
        toString(): string;
        constructor(name?: string, value?: any, isProperty?: boolean);
    }
}
declare module Stimulsoft.Base.Drawing {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
    import HotkeyPrefix = Stimulsoft.System.Drawing.Text.HotkeyPrefix;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTextOptions implements ICloneable, ICloneable {
        implements(): string[];
        saveToJsonObject(): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromXml(str: string): StiTextOptions;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiTextOptions;
        private bits;
        rightToLeft: boolean;
        lineLimit: boolean;
        private _wordWrap;
        wordWrap: boolean;
        angle: number;
        firstTabOffset: number;
        distanceBetweenTabs: number;
        hotkeyPrefix: HotkeyPrefix;
        trimming: StringTrimming;
        readonly isDefault: boolean;
        /** Serves as a hash function for a particular type. */
        getHashCode(): number;
        constructor(rightToLeft?: boolean, lineLimit?: boolean, wordWrap?: boolean, angle?: number, hotkeyPrefix?: HotkeyPrefix, trimming?: StringTrimming, firstTabOffset?: number, distanceBetweenTabs?: number);
    }
}
declare module Stimulsoft.Base.Drawing {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StringBuilder = Stimulsoft.System.Text.StringBuilder;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Font = Stimulsoft.System.Drawing.Font;
    import Size = Stimulsoft.System.Drawing.Size;
    import StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
    class StiTextRenderer {
        private static htmlNameToColor;
        static interpreteFontSizeInHtmlTagsAsInHtml: boolean;
        private static _htmlEscapeSequence;
        private static readonly htmlEscapeSequence;
        static parseHtmlToStates(inputHtml: string, baseState: StiHtmlState, storeStack?: boolean): Array<StiHtmlState>;
        static prepareStateText(stateText: StringBuilder): StringBuilder;
        private static getIndentString(indent);
        private static bulletBlack;
        private static bulletWhite;
        private static insertMarker(sb, markerInt, indent);
        private static parseHtmlTag(tag, state, stack, baseState);
        private static parseStyleAttribute(style, state);
        private static stringToListLevels(inputString);
        private static stringToStack(inputString, baseState);
        private static parseFontSize(fontSizeAttribute, delimiter);
        private static parseColor(colorAttribute);
        static measureString(maxWidth: number, font: Font, text: string, angle?: number): Size;
        static getTextLinesAndWidths(g: Graphics, REFtext: any, font: Font, bounds: Rectangle, lineSpacing: number, wordWrap: boolean, rightToLeft: boolean, scale: number, angle: number, trimming: StringTrimming, allowHtmlTags: boolean, REFtextLines: any, REFlinesInfo: any): string[];
        private static drawTextBase(g, REFtext, font, bounds, foreColor, backColor, lineSpacing, horAlign, vertAlign, wordWrap, rightToLeft, scale, angle, trimming, lineLimit, REFmeasureSize, needDraw, textLinesArray, textLinesInfo, allowHtmlTags, outRunsList, outFontsList);
        static StiForceWidthAlignTag: string;
    }
    class LineInfo {
        begin: number;
        length: number;
        needWidthAlign: boolean;
        end: number;
        width: number;
        justifyOffset: number;
        text: string;
        indexOfMaxFont: number;
        lineHeight: number;
        textAlignment: StiTextHorAlignment;
        indent: number;
    }
    enum StiHtmlTag {
        None = 0,
        B = 1,
        I = 2,
        U = 3,
        S = 4,
        Sup = 5,
        Sub = 6,
        Font = 7,
        FontName = 8,
        FontSize = 9,
        FontColor = 10,
        Backcolor = 11,
        LetterSpacing = 12,
        WordSpacing = 13,
        LineHeight = 14,
        TextAlign = 15,
        PClose = 16,
        ListItem = 17,
    }
    class StiHtmlTagsState {
        clone(): StiHtmlTagsState;
        bold: boolean;
        italic: boolean;
        underline: boolean;
        strikeout: boolean;
        fontSize: number;
        fontName: string;
        fontColor: Color;
        backColor: Color;
        subsript: boolean;
        superscript: boolean;
        letterSpacing: number;
        wordSpacing: number;
        lineHeight: number;
        textAlign: StiTextHorAlignment;
        isColorChanged: boolean;
        isBackcolorChanged: boolean;
        tag: StiHtmlTag;
        indent: number;
        htmlStyle: string;
        constructor(bold: any, italic?: boolean, underline?: boolean, strikeout?: boolean, fontSize?: number, fontName?: string, fontColor?: Color, backColor?: Color, superscript?: boolean, subscript?: boolean, letterSpacing?: number, wordSpacing?: number, lineHeight?: number, textAlign?: StiTextHorAlignment);
    }
    class StiHtmlState {
        clone(): StiHtmlState;
        ts: StiHtmlTagsState;
        text: StringBuilder;
        fontIndex: number;
        posBegin: number;
        tagsStack: Array<StiHtmlTagsState>;
        listLevels: Array<number>;
        constructor(ts: any, posBegin?: number);
    }
}
declare module Stimulsoft.Base {
    enum StiPlanIdent {
        OnlineTrial = 100,
        OnlineStandard = 101,
        ServerTrial = 200,
        ServerTeam5 = 201,
        ServerTeam10 = 202,
        ServerTeam25 = 203,
        ServerTeam50 = 204,
        ServerBusiness = 205,
        ServerEnterprise = 206,
        ServerWorldWide = 207,
        Test = 300,
    }
    enum StiPlanFeatureIdent {
        Cycles = 1,
    }
}
declare module Stimulsoft.Base {
    class StiKeyHelper {
        static generateKey(): string;
        static isKey(key: string): boolean;
        static isCorrectKey(key: string): boolean;
        static isEmptyKey(key: string): boolean;
        static isEmptyKey2(key1: string, key2: string): boolean;
        static selectKey(key1: string, key2: string): string;
        static isEqualKeys(key1: string, key2: string): boolean;
        static getOrGeneratedKey(key: string): string;
        static getOrGeneratedKey2(key1: string, key2: string): string;
    }
}
declare module Stimulsoft.Base {
    class StiKeyObject {
        key: string;
        isStored: string;
        constructor();
    }
}
declare module Stimulsoft.Base {
    class StiPacker {
        private static encryptedId;
        static allowPacking: boolean;
        static pack(bytes: number[]): number[];
        static unpack(bytes: number[]): number[];
        static packAndEncrypt(bytes: number[], encryptedId: string): number[];
        static unpackAndDecrypt(bytes: number[], encryptedId: string): number[];
        static packAndEncryptToString(bytes: number[]): string;
        static unpackAndDecrypt2(str: string): number[];
        static packToString(bytes: number[]): string;
        static unpackFromString(str: string): number[];
        static packToBytes(str: string, allowPacking?: boolean): number[];
        static unpackToString(bytes: number[]): string;
        private static addZipSignature(bytes);
        static isPacked(bytes: number[]): boolean;
        private static isPacked2(first, second, third);
    }
}
declare module Stimulsoft.Base {
    enum StiJsonSaveMode {
        Report = 0,
        Document = 1,
    }
}
declare module Stimulsoft.Base.StiJsonReportObjectHelper {
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    import StiCap = Stimulsoft.Base.Drawing.StiCap;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Font = Stimulsoft.System.Drawing.Font;
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    import GraphicsUnit = Stimulsoft.System.Drawing.GraphicsUnit;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import Size = Stimulsoft.System.Drawing.Size;
    import Point = Stimulsoft.System.Drawing.Point;
    class Serialize {
        static fontDefault(font: Font): string;
        static font(font: Font, defaultFamily?: string, defaultEmSize?: number, defaultStyle?: FontStyle, defaultUnit?: GraphicsUnit): string;
        static rectangleD(rect: Rectangle): string;
        static sizeD(size: Size | Size): string;
        static jColor(color: Color, defColor?: Color): string;
        static colorArray(array: Color[]): StiJson;
        static stringArray(array: string[]): StiJson;
        static numberArray(array: number[]): StiJson;
        static size(size: Size): StiJson;
        static point(pos: Point): StiJson;
        static jCap(cap: StiCap): string;
        static jBrush(brush: StiBrush, defaultBrush?: StiBrush): string;
        static jBorderSide(side: StiBorderSide): string;
        static jBorder(border: StiBorder): string;
    }
    class Deserialize {
        static stringArray(jObject: StiJson): string[];
        static numberArray(jObject: StiJson): number[];
        static font(text: string, defaultFont: Font): Font;
        static jBorderSide(text: string): StiBorderSide;
        static jCap(text: string): StiCap;
        static border(text: string): StiBorder;
        static color(value: string): Color;
        static brush(text: string): StiBrush;
        static colorArray(jObject: StiJson): Color[];
        static size(jObject: StiJson): Size;
        static rectangleD(text: string): Rectangle;
        static sizeD(text: string): Size;
        static point(jObject: StiJson): Point;
    }
}
declare module Stimulsoft.Base {
    class StiJsonToDataSetConverter {
        static getDataSet(str: string): any;
        static getDataSet(data: number[]): any;
        static getDataSet(obj: Object): any;
    }
}
declare module Stimulsoft.Base.Licenses {
    enum StiProductIdent {
        Ultimate = 0,
        Net = 1,
        Wpf = 2,
        Web = 3,
        Silverlight = 4,
        Js = 5,
        Java = 6,
        Php = 7,
        NetCore = 8,
        Uwp = 9,
        Flex = 10,
    }
    enum StiActivationType {
        Server = 1,
        Developer = 2,
    }
}
/**
 * @hidden
 */
declare module Stimulsoft.Base.Licenses {
    class StiCryptHelper {
        static decrypt(str: string, password: string): string;
        static encrypt(str: string, password?: string): string;
        static recrypt(str: string, oldPassword: string, newPassword: string): string;
    }
}
declare module Stimulsoft.Base.Licenses {
    class StiRsaPublicKey {
        static getKey(): any;
    }
}
declare module Stimulsoft.Base.Licenses {
    class StiLicenseObject {
        encryptKey: string;
        loadFromString(str: string): void;
        saveToString(): string;
        loadFromBytes(bytes: number[]): void;
        decryptFromBytes(bytes: number[]): void;
        decryptFromString(str: string): void;
    }
}
declare module Stimulsoft.Base.Licenses {
    import DateTime = Stimulsoft.System.DateTime;
    class StiLicenseKey extends StiLicenseObject {
        activationDate: DateTime;
        signature: string;
        owner: string;
        userName: string;
        startDate: DateTime;
        endDate: DateTime;
        seviceId: string;
        planId: StiPlanIdent;
        products: StiLicenseProduct[];
        productName: string;
        productLogo: number[];
        productFavIcon: number[];
        productDescription: string;
        productUrl: string;
        clone(): StiLicenseKey;
        readonly isServerLicense: boolean;
        readonly isProductLicense: boolean;
        static get1(bytes: number[]): StiLicenseKey;
        static get2(str: string): StiLicenseKey;
        constructor();
    }
}
declare module Stimulsoft.Base {
    import StiLicenseKey = Stimulsoft.Base.Licenses.StiLicenseKey;
    class StiLicense {
        static licenseKey: StiLicenseKey;
        private static _key;
        static key: string;
        static Key: string;
        /**
         * @hidden
         */
        static setNewLicenseKey(value: string, throwException?: boolean): void;
        private static isValidLicenseKey(licenseKey);
        static loadFromFile(file: string): void;
        static loadFromString(licenseKey: string): void;
    }
}
declare module Stimulsoft.Base.Licenses {
    class StiLicenseActivationResponse extends StiLicenseObject {
        encryptKey: string;
        licenseKey: StiLicenseKey;
        exception: string;
        resultSuccess: boolean;
        resultNotice: StiNotice;
    }
}
declare module Stimulsoft.Base.Licenses {
    class StiLicenseKeyContainer extends StiKeyObject {
        checkSum: string;
        license: number[];
    }
}
declare module Stimulsoft.Base.Licenses {
    import StiProductIdent = Stimulsoft.Base.Licenses.StiProductIdent;
    class StiLicenseKeyValidator {
        private static indexValidator;
        static isValid(ident: StiProductIdent): boolean;
        static isValidOnJS(): boolean;
        static isValidOnAnyPlatform(): boolean;
        private static isJSPlatform(ident);
        private static getLicenseKey();
    }
}
declare module Stimulsoft.Base.Licenses {
    import DateTime = Stimulsoft.System.DateTime;
    class StiLicenseProduct {
        expirationDate: DateTime;
        ident: StiProductIdent;
    }
}
declare module Stimulsoft.Base.Localization {
    class StiLocalization {
        static languages: any;
        static English: any;
        private static _cultureName;
        static cultureName: string;
        static addLocalizationFile(filePath: string, load?: boolean, language?: string): string;
        static setLocalizationFile(filePath: string, onlyThis?: boolean): void;
        static getJsonStringLocalization(): string;
        static loadLocalization(localizationXml: any, extension?: boolean): string;
        static loadLocalizationFile(filePath: string): string;
        private static loadLocalizationXmlInternal(xml);
        static get(category: string, key: string): string;
    }
}
declare module Stimulsoft.Base {
    enum StiNoticeIdent {
        ActivationMaxActivationsReached = 1,
        ActivationExpiriedBeforeFirstRelease = 2,
        ActivationLicenseIsNotCorrect = 3,
        ActivationLockedAccount = 4,
        ActivationServerVersionNotAllowed = 5,
        ActivationServerIsNotAvailableNow = 6,
        ActivationSomeTroublesOccurred = 7,
        ActivationUserNameOrPasswordIsWrong = 8,
        ActivationWrongAccountType = 9,
        AuthAccountCantBeUsedNow = 10,
        AuthAccountIsNotActivated = 11,
        AuthCantChangeSystemRole = 12,
        AuthCantChangeRoleBecauseLastAdministratorUser = 13,
        AuthCantChangeRoleBecauseLastSupervisorUser = 14,
        AuthCantDeleteHimselfUser = 15,
        AuthCantDeleteLastAdministratorUser = 16,
        AuthCantDeleteLastSupervisorUser = 17,
        AuthCantDeleteSystemRole = 18,
        AuthCantDisableUserBecauseLastAdministratorUser = 19,
        AuthCantDisableUserBecauseLastSupervisorUser = 20,
        AuthOAuthIdNotSpecified = 21,
        AuthPasswordIsTooShort = 22,
        AuthPasswordIsNotSpecified = 23,
        AuthPasswordIsNotCorrect = 24,
        AuthRequestsLimitIsExceeded = 25,
        AuthRoleCantBeDeletedBecauseUsedByUsers = 26,
        AuthRoleNameAlreadyExists = 27,
        AuthRoleNameIsSystemRole = 28,
        AuthUserHasLoggedOut = 29,
        AuthUserNameAlreadyExists = 30,
        AuthUserNameIsNotSpecified = 31,
        AuthUserNameOrPasswordIsNotCorrect = 32,
        AuthUserNameShouldLookLikeAnEmailAddress = 33,
        AuthWorkspaceNameAlreadyInUse = 34,
        CommandTimeOut = 35,
        CustomMessage = 36,
        ExecutionError = 37,
        IsNotAuthorized = 38,
        IsNotDeleted = 39,
        IsNotCorrect = 40,
        IsNotEqual = 41,
        IsNotFound = 42,
        IsNotRecognized = 43,
        IsNotSpecified = 44,
        ItemCantBeDeletedBecauseItemIsAttachedToOtherItems = 45,
        ItemCantBeMovedToSpecifiedPlace = 46,
        ItemDoesNotSupport = 47,
        KeyAndToKeyIsEqual = 48,
        NotificationFailed = 49,
        NotificationFileUploading = 50,
        NotificationFilesUploadingComplete = 51,
        NotificationItemDelete = 52,
        NotificationItemDeleteComplete = 53,
        NotificationItemRestore = 54,
        NotificationItemRestoreComplete = 55,
        NotificationItemTransfer = 56,
        NotificationItemTransferComplete = 57,
        NotificationItemWaitingProcessing = 58,
        NotificationOperationAborted = 59,
        NotificationRecycleBinCleaning = 60,
        NotificationRecycleBinCleaningComplete = 61,
        NotificationRecycleBinWaitingProcessing = 62,
        NotificationReportCompiling = 63,
        NotificationReportDataProcessing = 64,
        NotificationReportExporting = 65,
        NotificationReportExportingComplete = 66,
        NotificationReportRendering = 67,
        NotificationReportRenderingComplete = 68,
        NotificationReportSaving = 69,
        NotificationReportWaitingProcessing = 70,
        NotificationSchedulerRunning = 71,
        NotificationSchedulerRunningComplete = 72,
        NotificationSchedulerWaitingProcessing = 73,
        NotificationTransferring = 74,
        NotificationTransferringComplete = 75,
        NotificationTitleFilesUploading = 76,
        NotificationTitleItemRefreshing = 77,
        NotificationTitleItemTransferring = 78,
        NotificationTitleReportExporting = 79,
        NotificationTitleReportRendering = 80,
        NotificationTitleSchedulerRunning = 81,
        QuotaMaximumComputingCyclesCountExceeded = 82,
        QuotaMaximumFileSizeExceeded = 83,
        QuotaMaximumItemsCountExceeded = 84,
        QuotaMaximumReportPagesCountExceeded = 85,
        QuotaMaximumUsersCountExceeded = 86,
        QuotaMaximumWorkspacesCountExceeded = 87,
        AccessDenied = 88,
        OutOfRange = 89,
        ParsingCommandException = 90,
        SchedulerCantRunItSelf = 91,
        SessionTimeOut = 92,
        SnapshotAlreadyProcessed = 93,
        SpecifiedItemIsNot = 94,
        WithSpecifiedKeyIsNotFound = 95,
        VersionCopyFromItem = 96,
        VersionCreatedFromFile = 97,
        VersionCreatedFromItem = 98,
        VersionNewItemCreation = 99,
        VersionLoadedFromFile = 100,
    }
}
declare module Stimulsoft.Base {
    class StiNotice {
        ident: StiNoticeIdent;
        arguments: string[];
        customMessage: string;
    }
}
declare module Stimulsoft.Base {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRepositoryItems implements ICloneable {
        implements(): string[];
        clone(): any;
        private items;
        private valueBoolFalse;
        private valueBoolTrue;
        setNumber(key: Object, value: number, defaultValue: number): void;
        getNumber(key: Object, defaultValue: number): number;
        setBool(key: Object, value: boolean, defaultValue: boolean): void;
        getBool(key: Object, defaultValue: boolean): boolean;
        set(key: Object, value: any, defaultValue: any): void;
        get(key: Object, defaultValue: any): any;
        isPresent(key: Object): boolean;
    }
}
declare module Stimulsoft.Base.Services {
    import StiRepositoryItems = Stimulsoft.Base.StiRepositoryItems;
    import ICloneable = Stimulsoft.System.ICloneable;
    /** Describes an asbtract class that serves for services realization. */
    class StiService implements ICloneable {
        /** Creates a new object that is a copy of the current instance. */
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        implements(): string[];
        isPropertyPresent(key: Object): boolean;
        private _properties;
        properties: StiRepositoryItems;
        /** Internal use only, for LoadDocument optimization. */
        protected isPropertiesInitializedProtected(): boolean;
        /** Gets a service category. */
        readonly serviceCategory: string;
        /** Gets a service name. */
        readonly serviceName: string;
        /** Gets a service description. */
        readonly serviceInfo: string;
        /** Gets a service type. */
        readonly serviceType: Stimulsoft.System.Type;
        /** Gets or sets the value whether a service is enabled or not. */
        serviceEnabled: boolean;
    }
}
/**
 * @hidden
 */
interface JSZip {
    /**
     * Get a file from the archive
     *
     * @param Path relative path to file
     * @return File matching path, null if no file found
     */
    file(path: string): JSZipObject;
    /**
     * Get files matching a RegExp from archive
     *
     * @param path RegExp to match
     * @return Return all matching files or an empty array
     */
    file(path: RegExp): JSZipObject[];
    /**
     * Add a file to the archive
     *
     * @param path Relative path to file
     * @param content Content of the file
     * @param options Optional information about the file
     * @return JSZip object
     */
    file(path: string, data: any, options?: JSZipFileOptions): JSZip;
    /**
     * Return an new JSZip instance with the given folder as root
     *
     * @param name Name of the folder
     * @return New JSZip object with the given folder as root or null
     */
    folder(name: string): JSZip;
    /**
     * Returns new JSZip instances with the matching folders as root
     *
     * @param name RegExp to match
     * @return New array of JSZipFile objects which match the RegExp
     */
    folder(name: RegExp): JSZipObject[];
    /**
     * Get all files wchich match the given filter function
     *
     * @param predicate Filter function
     * @return Array of matched elements
     */
    filter(predicate: (relativePath: string, file: JSZipObject) => boolean): JSZipObject[];
    /**
     * Removes the file or folder from the archive
     *
     * @param path Relative path of file or folder
     * @return Returns the JSZip instance
     */
    remove(path: string): JSZip;
    /**
     * Generates a new archive
     *
     * @param options Optional options for the generator
     * @return The serialized archive
     */
    generate(options?: JSZipGeneratorOptions): any;
    /**
     * Deserialize zip file
     *
     * @param data Serialized zip file
     * @param options Options for deserializing
     * @return Returns the JSZip instance
     */
    load(data: any, options: JSZipLoadOptions): JSZip;
}
/**
 * @hidden
 */
interface JSZipObject {
    name: string;
    dir: boolean;
    date: Date;
    comment: string;
    options: JSZipObjectOptions;
    asText(): string;
    asBinary(): string;
    asArrayBuffer(): ArrayBuffer;
    asUint8Array(): Uint8Array;
}
/**
 * @hidden
 */
interface JSZipFileOptions {
    base64?: boolean;
    binary?: boolean;
    date?: Date;
    compression?: string;
    comment?: string;
    optimizedBinaryString?: boolean;
    createFolders?: boolean;
}
/**
 * @hidden
 */
interface JSZipObjectOptions {
    /** deprecated */
    base64: boolean;
    /** deprecated */
    binary: boolean;
    /** deprecated */
    dir: boolean;
    /** deprecated */
    date: Date;
    compression: string;
}
/**
 * @hidden
 */
interface JSZipGeneratorOptions {
    /** deprecated */
    base64?: boolean;
    /** DEFLATE or STORE */
    compression?: string;
    /** base64 (default), string, uint8array, blob */
    type?: string;
    comment?: string;
}
/**
 * @hidden
 */
interface JSZipLoadOptions {
    base64?: boolean;
    checkCRC32?: boolean;
    optimizedBinaryString?: boolean;
    createFolders?: boolean;
}
/**
 * @hidden
 */
interface JSZipSupport {
    arraybuffer: boolean;
    uint8array: boolean;
    blob: boolean;
    nodebuffer: boolean;
}
/**
 * @hidden
 */
interface DEFLATE {
    /** pako.deflateRaw, level:0-9 */
    compress(input: string, compressionOptions: {
        level: number;
    }): Uint8Array;
    compress(input: number[], compressionOptions: {
        level: number;
    }): Uint8Array;
    compress(input: Uint8Array, compressionOptions: {
        level: number;
    }): Uint8Array;
    /** pako.inflateRaw */
    uncompress(input: string): Uint8Array;
    uncompress(input: number[]): Uint8Array;
    uncompress(input: Uint8Array): Uint8Array;
}
/**
 * @hidden
 */
declare let JSZip: {
    /**
     * Create JSZip instance
     */
    (): JSZip;
    /**
     * Create JSZip instance
     * If no parameters given an empty zip archive will be created
     *
     * @param data Serialized zip archive
     * @param options Description of the serialized zip archive
     */
    (data: any, options?: JSZipLoadOptions): JSZip;
    /**
     * Create JSZip instance
     */
    new (): JSZip;
    /**
     * Create JSZip instance
     * If no parameters given an empty zip archive will be created
     *
     * @param data Serialized zip archive
     * @param options Description of the serialized zip archive
     */
    new (data: any, options?: JSZipLoadOptions): JSZip;
    prototype: JSZip;
    support: JSZipSupport;
    compressions: {
        DEFLATE: DEFLATE;
    };
};
/**
 * @hidden
 */
declare module "jszip" {
    export = JSZip;
}
declare module Stimulsoft.Base {
    class StiGZipHelper {
        private static DefaultLevel;
        private static DefaultMethod;
        private static ID1;
        private static ID2;
        private static _crcTable;
        static readonly crcTable: number[];
        static crc32(data: number[]): number;
        private static putByte(n, arr);
        private static putShort(n, arr);
        private static putLong(n, arr);
        private static putString(s, arr);
        private static readByte(arr);
        private static readShort(arr);
        private static readLong(arr);
        private static readString(arr);
        private static readBytes(arr, n);
        static pack(data2: string | number[], name?: string): string | number[];
        static unpack(data: string | number[]): string | number[];
    }
}
declare module Stimulsoft.Base.Zip {
    import DateTime = Stimulsoft.System.DateTime;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiZipWriter20 {
        static convertToArray(useUnicode: boolean, str: string): number[];
        static getDosTime(dt: DateTime): number;
        private _mainStream;
        private zip;
        begin(stream: MemoryStream, leaveOpen: boolean): void;
        addFile(fileName: string, dataStream: MemoryStream, closeDataStream?: boolean): void;
        end(): void;
        constructor();
    }
}
declare module Stimulsoft.Base {
    enum StiAnimationType {
        Opacity = 0,
        Scale = 1,
        Translation = 2,
        Rotation = 3,
        Column = 4,
        Points = 5,
        PieSegment = 6,
    }
    enum StiLevel {
        Basic = 0,
        Standard = 1,
        Professional = 2,
    }
}
declare module Stimulsoft.Base {
    class StiActivator {
        static createObject(_type: Stimulsoft.System.Type): any;
    }
}
declare module Stimulsoft.Base {
    class StiAlignValue {
        static alignToMaxGrid(value: number, gridSize: number, aligningToGrid: boolean): number;
        static alignToMinGrid(value: number, gridSize: number, aligningToGrid: boolean): number;
        static alignToGrid(value: number, gridSize: number, aligningToGrid: boolean): number;
    }
}
declare module Stimulsoft.Base {
    class StiConvert {
        static changeType(value: any, conversionType: Stimulsoft.System.Type, convertNulls?: boolean): any;
    }
}
declare module Stimulsoft.Base {
    class StiEncryption {
        private static randomSeed;
        private static rand_m;
        private static rand_a;
        private static rand_c;
        static encrypt(src: number[], key: number[]): number[];
        static encrypt2(src: number[], password: string): number[];
        static encryptS(src: string, password: string): string;
        static decrypt(src: number[], key: number[]): number[];
        static decrypt2(src: number[], password: string): number[];
        static decryptS(src: string, password: string): string;
        static generateRandomKey(): number[];
        private static encryptAdv(src, key);
        private static decryptAdv(src, key);
        private static cryptXor(src, key);
        private static cryptShift(src, key, encrypt);
        private static shiftLeft(value, count);
        private static shiftRight(value, count);
        private static cryptRandom(src, key, encrypt);
        private static getMixArray(count);
        private static setRandomSeed(key);
        private static getRandom(min, max);
        private static getKeyFromPassword(password);
    }
}
declare module Stimulsoft.Base {
    import FontFamily = Stimulsoft.System.Drawing.FontFamily;
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    class StiFontCollection {
        static addOpentypeFont(font: any, fontName?: string, binFont?: any, filePath?: string, fontStyle?: FontStyle): void;
        static addOpentypeFontFile(filePath: string, fontName?: string, fontStyle?: FontStyle): void;
        static addOpentypeFontFileAsync(callback: Function, filePath: string, fontName?: string, fontStyle?: FontStyle): void;
        static getFontFamilies(): FontFamily[];
        static getBinFont(fontName: string, fontStyle?: FontStyle): any;
        static getBinFonts(): string[];
    }
}
declare module Stimulsoft.Base {
    class StiGuidUtils {
        static newGuid(): string;
    }
}
declare module Stimulsoft.Base {
    class StiMD5Helper {
        static MD5(string: any): any[];
    }
}
declare module Stimulsoft.Base {
    class StiObjectConverter {
        static convertToNumber(value: Object): number;
    }
}
declare module Stimulsoft.Base {
    class StiSettings {
        static get(name: string, def: string): string;
        static set(name: string, value: string): void;
    }
}
declare module Stimulsoft.Base {
    class StiTypeFinder {
        private static findTypes;
        private static getCorrectTypeName(typeName);
        static getStiType(typeName: string): Stimulsoft.System.Type;
        private static addTypeFF(exType, typeForFinding, result);
        private static getTypeFF(exType, typeForFinding);
        static findType(exType: Stimulsoft.System.Type, typeForFinding: Stimulsoft.System.Type): boolean;
    }
}
declare module Stimulsoft.Base {
    class StiTypeWrapper {
        private _type;
        readonly type: Stimulsoft.System.Type;
        toString(): string;
        static toString(type: Stimulsoft.System.Type): string;
        private static _simpleTypes;
        static readonly simpleTypes: Stimulsoft.System.Type[];
        private static _simpleBaseTypes;
        static readonly simpleBaseTypes: Stimulsoft.System.Type[];
        static getTypeWrappers(): StiTypeWrapper[];
        constructor(type: Stimulsoft.System.Type);
    }
}
declare module Stimulsoft.Base {
    class StiUrl {
        static combine(uriParts: string[]): string;
    }
}
declare module Stimulsoft {
    /**
     * @hidden
     */
    class StiVersion {
        static version: string;
        static creationDate: string;
        static created: System.DateTime;
        static versionInfo: string;
        static copyright: string;
        static platform(): string;
    }
}

declare module Stimulsoft.Report.BarCodes {
    class ArrayHelper {
        static copy(sourceArray: any[], sourceIndex: number, destinationArray: any[], destinationIndex: number, length: number): void;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class BitVector {
        private sizeInBits;
        private array;
        constructor();
        at(index: number): number;
        size(): number;
        sizeInBytes(): number;
        appendBit(bit: number): void;
        appendBits(value: number, numBits: number): void;
        appendBitVector(bits: BitVector): void;
        xor(other: BitVector): void;
        toString(): string;
        getArray(): number[];
        private appendByte(value);
    }
}
declare module Stimulsoft.Report.BarCodes {
    class BlockPair {
        private dataBytes;
        private errorCorrectionBytes;
        constructor(data: ByteArray, errorCorrection: ByteArray);
        getDataBytes(): ByteArray;
        getErrorCorrectionBytes(): ByteArray;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class ByteArray {
        private static INITIAL_SIZE;
        private _bytes;
        private _size;
        constructor(size?: number, byteArray?: number[]);
        at(index: number): number;
        set(index: number, value: number): void;
        size(): number;
        isEmpty(): boolean;
        appendByte(value: number): void;
        reserve(capacity: number): void;
        set1(source: number[], offset: number, count: number): void;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class ByteMatrix {
        private _bytes;
        private _width;
        private _height;
        getValueString(): string;
        constructor(width: number, height: number);
        getHeight(): number;
        getWidth(): number;
        get(x: number, y: number): Stimulsoft.System.SByte;
        getArray(): Stimulsoft.System.SByte[][];
        set(x: number, y: number, value: Stimulsoft.System.SByte): void;
        set2(x: number, y: number, value: number): void;
        clear(value: Stimulsoft.System.SByte): void;
    }
}
declare module Stimulsoft.Report.BarCodes {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class CharacterSetECI {
        private static lockNAME_TO_ECI;
        private static _name_to_eci;
        static NAME_TO_ECI: Hashtable;
        private static Initialize();
        private _encodingName;
        private _value;
        constructor(value: number, encodingName: string);
        getEncodingName(): string;
        getValue(): number;
        private static addCharacterSet(value, encodingName, n);
        static getCharacterSetECIByName(name: String): CharacterSetECI;
        static GetEncodingByNumber(number: number, defaultEncoding: string): string;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class ErrorCorrectionLevel {
        static L: ErrorCorrectionLevel;
        static M: ErrorCorrectionLevel;
        static Q: ErrorCorrectionLevel;
        static H: ErrorCorrectionLevel;
        private _ordinal;
        private _bits;
        private _name;
        constructor(ordinal: number, bits: number, name: string);
        ordinal(): number;
        getBits(): number;
        getName(): string;
        toString(): string;
        static forBits(bits: number): ErrorCorrectionLevel;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class FormatInformation {
        private FORMAT_INFO_MASK_QR;
        private static FORMAT_INFO_DECODE_LOOKUP;
        private static BITS_SET_IN_HALF_BYTE;
        private errorCorrectionLevel;
        private dataMask;
        constructor(formatInfo: number);
        static numBitsDiffering(a: number, b: number): number;
        static decodeFormatInformation(maskedFormatInfo1: number, maskedFormatInfo2: number): FormatInformation;
        private static doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);
        getErrorCorrectionLevel(): ErrorCorrectionLevel;
        getDataMask(): number;
        stiEquals(o: Object): boolean;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class GF256 {
        static QR_CODE_FIELD: GF256;
        static DATA_MATRIX_FIELD: GF256;
        private _expTable;
        private _logTable;
        private _zero;
        private _one;
        constructor(primitive: number);
        getZero(): GF256Poly;
        getOne(): GF256Poly;
        buildMonomial(degree: number, coefficient: number): GF256Poly;
        static addOrSubtract(a: number, b: number): number;
        exp(a: number): number;
        log(a: number): number;
        inverse(a: number): number;
        multiply(a: number, b: number): number;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class GF256Poly {
        _field: GF256;
        _coefficients: number[];
        constructor(field: GF256, coefficients: number[]);
        getCoefficients(): number[];
        getDegree(): number;
        isZero(): boolean;
        getCoefficient(degree: number): number;
        evaluateAt(a: number): number;
        addOrSubtract(other: GF256Poly): GF256Poly;
        multiply(other: GF256Poly): GF256Poly;
        multiply1(scalar: number): GF256Poly;
        multiplyByMonomial(degree: number, coefficient: number): GF256Poly;
        divide(other: GF256Poly): GF256Poly[];
    }
}
declare module Stimulsoft.Report.BarCodes {
    class MaskUtil {
        static applyMaskPenaltyRule1(matrix: ByteMatrix): number;
        static applyMaskPenaltyRule2(matrix: ByteMatrix): number;
        static applyMaskPenaltyRule3(matrix: ByteMatrix): number;
        static applyMaskPenaltyRule4(matrix: ByteMatrix): number;
        static getDataMaskBit(maskPattern: number, x: number, y: number): boolean;
        private static ApplyMaskPenaltyRule1Internal(matrix, isHorizontal);
    }
}
declare module Stimulsoft.Report.BarCodes {
    class MatrixUtil {
        private static POSITION_DETECTION_PATTERN;
        private static HORIZONTAL_SEPARATION_PATTERN;
        private static VERTICAL_SEPARATION_PATTERN;
        private static POSITION_ADJUSTMENT_PATTERN;
        private static POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE;
        private static TYPE_INFO_COORDINATES;
        private static VERSION_INFO_POLY;
        private static TYPE_INFO_POLY;
        private static TYPE_INFO_MASK_PATTERN;
        static ClearMatrix(matrix: ByteMatrix): void;
        static BuildMatrix(dataBits: BitVector, ecLevel: ErrorCorrectionLevel, version: number, maskPattern: number, matrix: ByteMatrix): void;
        static EmbedBasicPatterns(version: number, matrix: ByteMatrix): void;
        static EmbedTypeInfo(ecLevel: ErrorCorrectionLevel, maskPattern: number, matrix: ByteMatrix): void;
        static MaybeEmbedVersionInfo(version: number, matrix: ByteMatrix): void;
        static EmbedDataBits(dataBits: BitVector, maskPattern: number, matrix: ByteMatrix): void;
        static FindMSBSet(value: number): number;
        static CalculateBCHCode(value: number, poly: number): number;
        static MakeTypeInfoBits(ecLevel: ErrorCorrectionLevel, maskPattern: number, bits: BitVector): void;
        static MakeVersionInfoBits(version: number, bits: BitVector): void;
        private static IsEmpty(value);
        private static IsValidValue(value);
        private static EmbedTimingPatterns(matrix);
        private static EmbedDarkDotAtLeftBottomCorner(matrix);
        private static EmbedHorizontalSeparationPattern(xStart, yStart, matrix);
        private static EmbedVerticalSeparationPattern(xStart, yStart, matrix);
        private static EmbedPositionAdjustmentPattern(xStart, yStart, matrix);
        private static EmbedPositionDetectionPattern(xStart, yStart, matrix);
        private static EmbedPositionDetectionPatternsAndSeparators(matrix);
        private static MaybeEmbedPositionAdjustmentPatterns(version, matrix);
    }
}
declare module Stimulsoft.Report.BarCodes {
    class Mode {
        static TERMINATOR: Mode;
        static NUMERIC: Mode;
        static ALPHANUMERIC: Mode;
        static STRUCTURED_APPEND: Mode;
        static BYTE: Mode;
        static ECI: Mode;
        static KANJI: Mode;
        static FNC1_FIRST_POSITION: Mode;
        static FNC1_SECOND_POSITION: Mode;
        private characterCountBitsForVersions;
        private bits;
        private name;
        constructor(characterCountBitsForVersions: number[], bits: number, name: string);
        static ForBits(bits: number): Mode;
        GetCharacterCountBits(version: Version): number;
        GetBits(): number;
        GetName(): string;
        ToString(): string;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class QREncoder {
        private static ALPHANUMERIC_TABLE;
        private static defaultECIByteModeEncoding;
        private static BYTE_MODE_UTF8;
        private static QUESTION_MARK_CHAR;
        private static CalculateMaskPenalty(matrix);
        static Encode(content: string, ecLevel: ErrorCorrectionLevel, qrCode: StiQRCode): void;
        private static GetEncodingName(content, defaultByteModeEncoding);
        private static GetAlphanumericCode(code);
        static ChooseMode(content: string): Mode;
        static ChooseMode1(content: string, encoding: string): Mode;
        private static ChooseMaskPattern(bits, ecLevel, version, matrix);
        private static InitQRCode(numInputBytes, ecLevel, mode, qrCode);
        private static TerminateBits(numDataBytes, bits);
        private static GetNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, blockID, numDataBytesInBlock, numECBytesInBlock);
        private static InterleaveWithECBytes(bits, numTotalBytes, numDataBytes, numRSBlocks, result);
        private static GenerateECBytes(dataBytes, numEcBytesInBlock);
        private static AppendModeInfo(mode, bits);
        private static AppendLengthInfo(numLetters, version, mode, bits);
        private static AppendBytes(content, mode, bits, encoding);
        private static AppendNumericBytes(content, bits);
        private static AppendAlphanumericBytes(content, bits);
        private static Append8BitBytes(content, bits, encoding);
        private static AppendKanjiBytes(content, bits);
        private static AppendECI(eci, bits);
    }
}
declare module Stimulsoft.Report.BarCodes {
    class ReedSolomonEncoder {
        private field;
        private cachedGenerators;
        constructor(field: GF256);
        private BuildGenerator(degree);
        Encode(toEncode: number[], ecBytes: number): void;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class StiQRCode {
        static NUM_MASK_PATTERNS: number;
        private _mode;
        private _ecLevel;
        private _version;
        private _matrixWidth;
        private _maskPattern;
        private _numTotalBytes;
        private _numDataBytes;
        private _numECBytes;
        private _numRSBlocks;
        private _matrix;
        GetMode(): Mode;
        GetECLevel(): ErrorCorrectionLevel;
        GetVersion(): number;
        GetMatrixWidth(): number;
        GetMaskPattern(): number;
        GetNumTotalBytes(): number;
        GetNumDataBytes(): number;
        GetNumECBytes(): number;
        GetNumRSBlocks(): number;
        GetMatrix(): ByteMatrix;
        At(x: number, y: number): number;
        IsValid(): boolean;
        SetMode(value: Mode): void;
        SetECLevel(value: ErrorCorrectionLevel): void;
        SetVersion(value: number): void;
        SetMatrixWidth(value: number): void;
        SetMaskPattern(value: number): void;
        SetNumTotalBytes(value: number): void;
        SetNumDataBytes(value: number): void;
        SetNumECBytes(value: number): void;
        SetNumRSBlocks(value: number): void;
        SetMatrix(value: ByteMatrix): void;
        static IsValidMaskPattern(maskPattern: number): boolean;
        constructor();
    }
}
declare module Stimulsoft.Report.BarCodes {
    class ECB {
        private _count;
        private _dataCodewords;
        constructor(count: number, dataCodewords: number);
        getCount(): number;
        getDataCodewords(): number;
    }
    class ECBlocks {
        private ecCodewordsPerBlock;
        private ecBlocks;
        constructor(ecCodewordsPerBlock: number, ecBlocks1: ECB, ecBlocks2?: ECB);
        getECCodewordsPerBlock(): number;
        getNumBlocks(): number;
        getTotalECCodewords(): number;
        getECBlocks(): ECB[];
    }
    class Version {
        private static VERSION_DECODE_INFO;
        private static BuildVersions();
        private static VERSIONS;
        private _versionNumber;
        private _alignmentPatternCenters;
        private _ecBlocks;
        private _totalCodewords;
        constructor(versionNumber: number, alignmentPatternCenters: number[], ecBlocks1: ECBlocks, ecBlocks2: ECBlocks, ecBlocks3: ECBlocks, ecBlocks4: ECBlocks);
        getVersionNumber(): number;
        getAlignmentPatternCenters(): number[];
        getTotalCodewords(): number;
        getDimensionForVersion(): number;
        getECBlocksForLevel(ecLevel: ErrorCorrectionLevel): ECBlocks;
        static getProvisionalVersionForDimension(dimension: number): Version;
        static getVersionForNumber(versionNumber: number): Version;
        static decodeVersionInformation(versionBits: number): Version;
        toString(): string;
    }
}
declare module Stimulsoft.Report.BarCodes {
    enum CodeSet {
        None = 0,
        A = 1,
        B = 2,
        C = 3,
    }
    enum ControlCodes {
        FNC1 = 129,
        FNC2 = 130,
        FNC3 = 131,
        FNC4 = 132,
        CodeA = 133,
        CodeB = 134,
        CodeC = 135,
        Shift = 136,
    }
    enum BarcodeCommands {
        FNC1 = 102,
        FNC2 = 97,
        FNC3 = 96,
        FNC4A = 101,
        FNC4B = 100,
        CodeA = 101,
        CodeB = 100,
        CodeC = 99,
        Shift = 98,
        StartA = 103,
        StartB = 104,
        StartC = 105,
        Stop = 106,
    }
    enum StiCheckSum {
        Yes = 0,
        No = 1,
    }
    enum StiPlesseyCheckSum {
        None = 0,
        Modulo10 = 1,
        Modulo11 = 2,
    }
    enum StiDataMatrixSize {
        Automatic = -1,
        s10x10 = 0,
        s12x12 = 1,
        s8x18 = 2,
        s14x14 = 3,
        s8x32 = 4,
        s16x16 = 5,
        s12x26 = 6,
        s18x18 = 7,
        s20x20 = 8,
        s12x36 = 9,
        s22x22 = 10,
        s16x36 = 11,
        s24x24 = 12,
        s26x26 = 13,
        s16x48 = 14,
        s32x32 = 15,
        s36x36 = 16,
        s40x40 = 17,
        s44x44 = 18,
        s48x48 = 19,
        s52x52 = 20,
        s64x64 = 21,
        s72x72 = 22,
        s80x80 = 23,
        s88x88 = 24,
        s96x96 = 25,
        s104x104 = 26,
        s120x120 = 27,
        s132x132 = 28,
        s144x144 = 29,
    }
    enum StiDataMatrixEncodingType {
        Ascii = 0,
        C40 = 1,
        Text = 2,
        X12 = 3,
        Edifact = 4,
        Binary = 5,
    }
    enum StiPdf417EncodingMode {
        Text = 0,
        Numeric = 1,
        Byte = 2,
    }
    enum StiPdf417ErrorsCorrectionLevel {
        Automatic = -1,
        Level0 = 0,
        Level1 = 1,
        Level2 = 2,
        Level3 = 3,
        Level4 = 4,
        Level5 = 5,
        Level6 = 6,
        Level7 = 7,
        Level8 = 8,
    }
    enum StiEanSupplementType {
        None = 0,
        TwoDigit = 1,
        FiveDigit = 2,
    }
    enum StiCode11CheckSum {
        None = 0,
        OneDigit = 1,
        TwoDigits = 2,
        Auto = 3,
    }
    enum StiQRCodeSize {
        Automatic = 0,
        v1 = 1,
        v2 = 2,
        v3 = 3,
        v4 = 4,
        v5 = 5,
        v6 = 6,
        v7 = 7,
        v8 = 8,
        v9 = 9,
        v10 = 10,
        v11 = 11,
        v12 = 12,
        v13 = 13,
        v14 = 14,
        v15 = 15,
        v16 = 16,
        v17 = 17,
        v18 = 18,
        v19 = 19,
        v20 = 20,
        v21 = 21,
        v22 = 22,
        v23 = 23,
        v24 = 24,
        v25 = 25,
        v26 = 26,
        v27 = 27,
        v28 = 28,
        v29 = 29,
        v30 = 30,
        v31 = 31,
        v32 = 32,
        v33 = 33,
        v34 = 34,
        v35 = 35,
        v36 = 36,
        v37 = 37,
        v38 = 38,
        v39 = 39,
        v40 = 40,
    }
    enum StiQRCodeErrorCorrectionLevel {
        Level1 = 0,
        Level2 = 1,
        Level3 = 2,
        Level4 = 3,
    }
    enum StiQRCodeECIMode {
        Cp437 = 2,
        ISO_8859_1 = 3,
        ISO_8859_2 = 4,
        ISO_8859_3 = 5,
        ISO_8859_4 = 6,
        ISO_8859_5 = 7,
        ISO_8859_6 = 8,
        ISO_8859_7 = 9,
        ISO_8859_8 = 10,
        ISO_8859_9 = 11,
        ISO_8859_11 = 13,
        ISO_8859_13 = 15,
        ISO_8859_15 = 17,
        Shift_JIS = 20,
        Windows_1250 = 21,
        Windows_1251 = 22,
        Windows_1252 = 23,
        Windows_1256 = 24,
        UTF_8 = 26,
    }
    enum StiMaxicodeMode {
        Mode2 = 2,
        Mode3 = 3,
        Mode4 = 4,
        Mode5 = 5,
        Mode6 = 6,
    }
}
declare module Stimulsoft.Report.BarCodes {
    import IStiBackColor = Stimulsoft.Report.Components.IStiBackColor;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    var IStiBarCode: string;
    interface IStiBarCode extends IStiBackColor, IStiForeColor {
        getBarCodeString(): string;
        autoScale: boolean;
        showLabelText: boolean;
        barCodeType: StiBarCodeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    enum StiTextFormatState {
        None = 0,
        DecimalDigits = 1,
        DecimalSeparator = 2,
        GroupSeparator = 4,
        GroupSize = 8,
        PositivePattern = 16,
        NegativePattern = 32,
        CurrencySymbol = 64,
        PercentageSymbol = 128,
    }
    enum StiIconSet {
        None = 0,
        Full = 1,
        ArrowsColored3 = 2,
        ArrowsColored4 = 3,
        ArrowsColored5 = 4,
        ArrowsGray3 = 5,
        ArrowsGray4 = 6,
        ArrowsGray5 = 7,
        Flags3 = 8,
        Latin4 = 9,
        Quarters5 = 10,
        QuartersGreen5 = 11,
        QuartersRed5 = 12,
        Ratings3 = 13,
        Ratings4 = 14,
        Ratings5 = 15,
        RedToBlack4 = 16,
        Signs3 = 17,
        Squares5 = 18,
        Stars3 = 19,
        Stars5 = 20,
        SymbolsCircled3 = 21,
        SymbolsUncircled3 = 22,
        TrafficLights4 = 23,
        TrafficLightsRimmed3 = 24,
        TrafficLightsUnrimmed3 = 25,
        Triangles3 = 26,
    }
    enum StiIcon {
        None = 0,
        ArrowRightDownGray = 1,
        ArrowRightUpGray = 2,
        ArrowDownGray = 3,
        ArrowRightGray = 4,
        ArrowUpGray = 5,
        ArrowUpGreen = 6,
        ArrowDownRed = 7,
        ArrowRightYellow = 8,
        ArrowRightDownYellow = 9,
        ArrowRightUpYellow = 10,
        CheckGreen = 11,
        CircleBlack = 12,
        CircleGreen = 13,
        CircleCheckGreen = 14,
        CircleRed = 15,
        CircleCrossRed = 16,
        CircleYellow = 17,
        CircleExclamationYellow = 18,
        CrossRed = 19,
        ExclamationYellow = 20,
        FlagGreen = 21,
        FlagRed = 22,
        FlagYellow = 23,
        FromRedToBlackGray = 24,
        FromRedToBlackPink = 25,
        FromRedToBlackRed = 26,
        Latin1 = 27,
        Latin2 = 28,
        Latin3 = 29,
        Latin4 = 30,
        LightsGreen = 31,
        LightsRed = 32,
        LightsYellow = 33,
        MinusYellow = 34,
        QuarterFull = 35,
        QuarterFullGreen = 36,
        QuarterFullRed = 37,
        QuarterHalf = 38,
        QuarterHalfGreen = 39,
        QuarterHalfRed = 40,
        QuarterNone = 41,
        QuarterNoneGreen = 42,
        QuarterNoneRed = 43,
        QuarterQuarter = 44,
        QuarterQuarterGreen = 45,
        QuarterQuarterRed = 46,
        QuarterThreeFourth = 47,
        QuarterThreeFourthGreen = 48,
        QuarterThreeFourthRed = 49,
        Rating0 = 50,
        Rating1 = 51,
        Rating2 = 52,
        Rating3 = 53,
        Rating4 = 54,
        RhombRed = 55,
        Square0 = 56,
        Square1 = 57,
        Square2 = 58,
        Square3 = 59,
        Square4 = 60,
        StarFull = 61,
        StarHalf = 62,
        StarNone = 63,
        StarQuarter = 64,
        StarThreeFourth = 65,
        TriangleGreen = 66,
        TriangleRed = 67,
        TriangleYellow = 68,
    }
    enum StiIconSetOperation {
        MoreThan = 0,
        MoreThanOrEqual = 1,
    }
    enum StiIconSetValueType {
        Value = 0,
        Percent = 1,
    }
    enum StiProcessAt {
        None = 0,
        EndOfReport = 1,
        EndOfPage = 2,
    }
    enum StiMinimumType {
        Auto = 0,
        Value = 1,
        Percent = 2,
        Minimum = 3,
    }
    enum StiMidType {
        Auto = 0,
        Value = 1,
        Percent = 2,
    }
    enum StiMaximumType {
        Auto = 0,
        Value = 1,
        Percent = 2,
        Maximum = 3,
    }
    enum StiDrillDownMode {
        SinglePage = 0,
        MultiPage = 1,
    }
    enum StiConditionBorderSides {
        None = 0,
        All = 15,
        Top = 1,
        Left = 2,
        Right = 4,
        Bottom = 8,
        NotAssigned = 16,
    }
    enum StiConditionPermissions {
        None = 0,
        Font = 1,
        FontSize = 2,
        FontStyleBold = 4,
        FontStyleItalic = 8,
        FontStyleUnderline = 16,
        FontStyleStrikeout = 32,
        TextColor = 64,
        BackColor = 128,
        Borders = 256,
        All = 511,
    }
    enum StiQuickInfoType {
        None = 0,
        ShowComponentsNames = 1,
        ShowAliases = 2,
        ShowFieldsOnly = 3,
        ShowFields = 4,
        ShowEvents = 5,
        ShowContent = 6,
    }
    enum StiAngle {
        Angle0 = 0,
        Angle90 = 90,
        Angle180 = 180,
        Angle270 = 270,
    }
    enum StiDockStyle {
        Left = 0,
        Right = 1,
        Top = 2,
        Bottom = 3,
        None = 4,
        Fill = 5,
    }
    enum StiFilterCondition {
        EqualTo = 0,
        NotEqualTo = 1,
        GreaterThan = 2,
        GreaterThanOrEqualTo = 3,
        LessThan = 4,
        LessThanOrEqualTo = 5,
        Between = 6,
        NotBetween = 7,
        Containing = 8,
        NotContaining = 9,
        BeginningWith = 10,
        EndingWith = 11,
        IsNull = 12,
        IsNotNull = 13,
    }
    enum StiFilterItem {
        Argument = 0,
        Value = 1,
        ValueEnd = 2,
        Expression = 3,
        ValueOpen = 4,
        ValueClose = 5,
        ValueLow = 6,
        ValueHigh = 7,
    }
    enum StiFilterDataType {
        String = 0,
        Numeric = 1,
        DateTime = 2,
        Boolean = 3,
        Expression = 4,
    }
    enum StiFilterMode {
        And = 0,
        Or = 1,
    }
    enum StiFilterEngine {
        ReportEngine = 0,
        SQLQuery = 1,
    }
    enum StiKeepDetails {
        None = 0,
        KeepFirstRowTogether = 1,
        KeepFirstDetailTogether = 2,
        KeepDetailsTogether = 3,
    }
    enum StiPrintOnType {
        AllPages = 0,
        ExceptFirstPage = 1,
        ExceptLastPage = 2,
        ExceptFirstAndLastPage = 3,
        OnlyFirstPage = 4,
        OnlyLastPage = 8,
        OnlyFirstAndLastPage = 12,
    }
    enum StiPrintOnEvenOddPagesType {
        Ignore = 0,
        PrintOnEvenPages = 1,
        PrintOnOddPages = 2,
    }
    enum StiShiftMode {
        None = 0,
        IncreasingSize = 1,
        DecreasingSize = 2,
        OnlyInWidthOfComponent = 4,
    }
    enum StiAnchorMode {
        Top = 1,
        Bottom = 2,
        Left = 4,
        Right = 8,
    }
    enum StiProcessingDuplicatesType {
        None = 0,
        Merge = 1,
        Hide = 2,
        RemoveText = 3,
        BasedOnTagMerge = 4,
        BasedOnTagHide = 5,
        BasedOnTagRemoveText = 6,
        GlobalMerge = 7,
        GlobalHide = 8,
        GlobalRemoveText = 9,
        BasedOnValueRemoveText = 10,
        BasedOnValueAndTagMerge = 11,
        BasedOnValueAndTagHide = 12,
        GlobalBasedOnValueRemoveText = 13,
        GlobalBasedOnValueAndTagMerge = 14,
        GlobalBasedOnValueAndTagHide = 15,
    }
    enum StiImageProcessingDuplicatesType {
        None = 0,
        Merge = 1,
        Hide = 2,
        RemoveImage = 3,
        GlobalMerge = 4,
        GlobalHide = 5,
        GlobalRemoveImage = 6,
    }
    enum StiCheckStyle {
        Cross = 0,
        Check = 1,
        CrossRectangle = 2,
        CheckRectangle = 3,
        CrossCircle = 4,
        DotCircle = 5,
        DotRectangle = 6,
        NoneCircle = 7,
        NoneRectangle = 8,
        None = 9,
    }
    enum StiToolboxCategory {
        Bands = 0,
        Cross = 1,
        Components = 2,
        Shapes = 3,
        Controls = 4,
    }
    enum StiComponentToolboxPosition {
        Component = 0,
        ReportTitleBand = 1,
        ReportSummaryBand = 2,
        PageHeaderBand = 3,
        PageFooterBand = 4,
        GroupHeaderBand = 5,
        GroupFooterBand = 6,
        HeaderBand = 7,
        FooterBand = 8,
        ColumnHeaderBand = 9,
        ColumnFooterBand = 10,
        DataBand = 11,
        HierarchicalBand = 13,
        ChildBand = 14,
        EmptyBand = 15,
        OverlayBand = 16,
        CrossGroupHeaderBand = 21,
        CrossGroupFooterBand = 22,
        CrossHeaderBand = 23,
        CrossFooterBand = 24,
        CrossDataBand = 25,
        Text = 101,
        TextInCells = 102,
        SystemText = 103,
        ContourText = 104,
        RichText = 105,
        Image = 106,
        BarCode = 107,
        Shape = 108,
        Line = 109,
        Container = 110,
        Panel = 110,
        Clone = 112,
        CheckBox = 113,
        SubReport = 114,
        WinControl = 115,
        ZipCode = 116,
        HorizontalLinePrimitive = 150,
        VerticalLinePrimitive = 151,
        RectanglePrimitive = 152,
        RoundedRectanglePrimitive = 153,
        Chart = 200,
        Table = 201,
        CrossTab = 202,
        Map = 210,
        Gauge = 220,
        TextElement = 300,
        ImageElement = 301,
        ChartElement = 302,
        GaugeElement = 303,
        MapElement = 304,
        IndicatorElement = 305,
        ListElement = 320,
        XText = 400,
        XTitle = 401,
        XSubTitle = 402,
        XHeader = 403,
        XBody = 404,
        XImage = 405,
        XBarCode = 406,
        XShape = 407,
        XData = 408,
        UserCode = 1000,
    }
    enum StiComponentPriority {
        Component = 0,
        CrossTab = 1500,
        SubReportsV1 = 1500,
        SubReportsV2 = 0,
        Container = 0,
        Panel = 0,
        ReportTitleBandBefore = -400,
        ReportTitleBandAfterV1 = -200,
        ReportTitleBandAfterV2 = 200,
        ReportSummaryBand = 500,
        PageHeaderBandBefore = -200,
        PageHeaderBandAfter = -400,
        PageFooterBandBottom = -300,
        PageFooterBandTop = 1000,
        GroupHeaderBand = 300,
        GroupFooterBand = 300,
        HeaderBand = 300,
        FooterBand = 300,
        ColumnHeaderBand = 300,
        ColumnFooterBand = 300,
        DataBand = 300,
        Table = 300,
        ChildBand = 300,
        EmptyBand = 300,
        OverlayBand = 700,
        Primitive = 1500,
        CrossGroupHeaderBand = 300,
        CrossGroupFooterBand = 300,
        CrossHeaderBand = 300,
        CrossFooterBand = 300,
        CrossDataBand = 300,
    }
    enum StiComponentType {
        /** Simple components - only one copy in one print cycle is output.*/
        Simple = 0,
        /** Master components – more than one copy in one print cycle are output.*/
        Master = 1,
        /** Detailed components – these components are output with Master components.*/
        Detail = 2,
        /** Static components – these components are the same as simple components but are output on pages only.*/
        Static = 3,
    }
    enum StiRestrictions {
        None = 0,
        AllowMove = 1,
        AllowResize = 2,
        AllowSelect = 4,
        AllowChange = 8,
        AllowDelete = 16,
        All = 31,
    }
    enum StiHighlightState {
        Hide = 0,
        Show = 1,
        Active = 2,
    }
    enum StiAligning {
        Left = 0,
        Center = 1,
        Right = 2,
        Top = 3,
        Middle = 4,
        Bottom = 5,
    }
    enum StiColumnDirection {
        DownThenAcross = 0,
        AcrossThenDown = 1,
    }
    enum StiEmptySizeMode {
        IncreaseLastRow = 0,
        DecreaseLastRow = 1,
        AlignFooterToBottom = 2,
        AlignFooterToTop = 3,
    }
    enum StiGroupSortDirection {
        Ascending = 0,
        Descending = 1,
        None = 2,
    }
    enum StiGroupSummaryType {
        Avg = 0,
        AvgDate = 1,
        AvgTime = 2,
        Count = 3,
        CountDistinct = 4,
        MaxDate = 5,
        MaxTime = 6,
        Max = 7,
        MinDate = 8,
        MinTime = 9,
        Min = 10,
        Median = 11,
        Mode = 12,
        Sum = 13,
        SumTime = 14,
    }
    enum StiPageOrientation {
        Portrait = 0,
        Landscape = 1,
    }
    enum StiTextQuality {
        Standard = 0,
        Typographic = 1,
        Wysiwyg = 2,
    }
    enum StiSystemTextType {
        Totals = 0,
        SystemVariables = 1,
        Expression = 2,
        DataColumn = 3,
        None = 4,
    }
    enum StiBrushType {
        Solid = 0,
        Gradient = 1,
    }
    enum StiColorScaleType {
        Color2 = 0,
        Color3 = 1,
    }
    enum StiDataBarDirection {
        Default = 0,
        LeftToRight = 1,
        RighToLeft = 2,
    }
    enum StiInteractionSortDirection {
        Ascending = 0,
        Descending = 1,
        None = 2,
    }
    enum StiImageRotation {
        None = 0,
        Rotate90CW = 1,
        Rotate90CCW = 2,
        Rotate180 = 3,
        FlipHorizontal = 4,
        FlipVertical = 5,
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiService = Stimulsoft.Base.Services.StiService;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import Image = Stimulsoft.System.Drawing.Image;
    import IStiBarCodePainter = Stimulsoft.Report.Painters.IStiBarCodePainter;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    interface DrawBaseLinesDelegate {
        (cobtext: any, brush: StiBrush, barCode: StiBarCodeTypeService): any;
    }
    class StiBarCodeTypeService extends StiService {
        static loadFromJsonObjectInternal(jObject: StiJson): StiBarCodeTypeService;
        static loadFromXmlInternal(xmlNode: XmlNode): StiBarCodeTypeService;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        loadFromXmlObject(xmlNode: XmlNode): void;
        visiblePropertiesCount: number;
        private _visibleProperties;
        visibleProperties: boolean[];
        readonly defaultCodeValue: string;
        private _customPainter;
        customPainter: IStiBarCodePainter;
        private _mainWidth;
        readonly mainWidth: number;
        private _mainHeight;
        readonly mainHeight: number;
        private _barCodeData;
        readonly barCodeData: StiBarCodeData;
        module: number;
        height: number;
        protected readonly textAlignment: StringAlignment;
        protected readonly textSpacing: boolean;
        protected rectWindow: RectangleD;
        readonly labelFontHeight: number;
        protected defaultLabelFontHeight: number;
        protected checkCodeSymbols(inputCode: string, tolerantSymbols: string): string;
        getCode(barCode: IStiBarCode): string;
        getCombinedCode(): string;
        protected getSymbolWidth(symbol: string): number;
        protected isSymbolLong(symbol: string): boolean;
        protected isSymbolSpace(symbol: string): boolean;
        protected isSymbolPostDescend(symbol: string): boolean;
        protected getSymbolsStringWidth(symbolsString: string): number;
        protected drawBars(context: any, sym: string, foreBrush: StiBrush): void;
        protected drawBarCode(context: any, rect: RectangleD, barCode: StiBarCode): void;
        protected drawBarCode1(context: any, rect: RectangleD, barCode: StiBarCode, drawMethod: DrawBaseLinesDelegate): void;
        protected calculateSizeFull(spaceLeft: number, spaceRight: number, spaceTop: number, spaceBottom: number, lineHeightShort: number, lineHeightLong: number, TextPosition: number, TextHeight: number, mainHeight: number, lineHeightForCut: number, wideToNarrowRatio: number, zoom: number, code: string, textString: string, barsArray: string, rect: RectangleD, barCode: StiBarCode): void;
        protected calculateSize2(spaceLeft: number, spaceRight: number, spaceTop: number, spaceBottom: number, lineHeightShort: number, lineHeightLong: number, textPosition: number, textHeight: number, mainHeight: number, wideToNarrowRatio: number, zoom: number, barsArray: string, rect: RectangleD, barCode: StiBarCode): void;
        protected draw2DBarCode(context: any, rect: RectangleD, barCode: StiBarCode, zoom: number): void;
        protected drawMaxicode(context: any, rect: RectangleD, barCode: StiBarCode, zoom: number): void;
        protected drawBarCodeError(context: any, rect: RectangleD, barCode: StiBarCode): void;
        protected drawBarCodeError2(context: any, rect: RectangleD, barCode: StiBarCode, message: string): void;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        protected translateRect(context: any, rect: RectangleD, barCode: StiBarCode): void;
        protected rollbackTransform(context: any): void;
        protected baseDrawString(context: any, st: string, font: Font, brush: StiBrush, x: number, y: number): void;
        protected baseTransform(context: any, x: number, y: number, angle: number, dx: number, dy: number): void;
        protected baseRollbackTransform(context: any): void;
        baseFillRectangle(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        protected baseFillRectangle2D(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        protected baseFillPolygon(context: any, brush: StiBrush, points: PointD[]): void;
        protected baseFillEllipse(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        protected baseDrawRectangle(context: any, penColor: Color, penSize: number, x: number, y: number, width: number, height: number): void;
        protected baseDrawImage(context: any, image: Image, report: StiReport, x: number, y: number, width: number, height: number): void;
        protected baseDrawString2(context: any, st: string, font: Font, brush: StiBrush, rect: RectangleD, sf: StringFormat): void;
        protected baseMeasureString3(context: any, st: string, font: Font): SizeD;
        createNew(): StiBarCodeTypeService;
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiAustraliaPost4StateBarCodeType extends StiBarCodeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly serviceName: string;
        protected australiaPost4StateSymbolsC: string;
        protected australiaPost4StateSymbolsN: string;
        private australiaPost4StateStartCode;
        private australiaPost4StateStopCode;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        protected australiaPost4StateSpaceLeft: number;
        protected australiaPost4StateSpaceRight: number;
        protected australiaPost4StateSpaceTop: number;
        protected australiaPost4StateSpaceBottom: number;
        protected australiaPost4StateLineHeightLong: number;
        protected australiaPost4StateLineHeightShort: number;
        protected australiaPost4StateTextPosition: number;
        protected australiaPost4StateTextHeight: number;
        protected australiaPost4StateMainHeight: number;
        protected australiaPost4StateLineHeightForCut: number;
        protected readonly textAlignment: StringAlignment;
        private mult;
        private gen;
        private rSInitialise();
        private rSEncode(infosymbols);
        private charTo4State(inputChar, useTableC);
        private stateToBar(inputCode);
        private makeBarsArray(REFcode, REFbarsArray, REFerrorString);
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.Components {
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    var IStiBorder: string;
    interface IStiBorder {
        border: StiBorder;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiEnumAngle: string;
    interface IStiEnumAngle {
        angle: StiAngle;
    }
}
declare module Stimulsoft.Report.Components {
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    var IStiHorAlignment: string;
    interface IStiHorAlignment {
        horAlignment: StiHorAlignment;
    }
}
declare module Stimulsoft.Report.Components {
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    var IStiVertAlignment: string;
    interface IStiVertAlignment {
        vertAlignment: StiVertAlignment;
    }
}
declare module Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiForeColor: string;
    interface IStiForeColor {
        foreColor: Color;
    }
}
declare module Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiBackColor: string;
    interface IStiBackColor {
        backColor: Color;
    }
}
declare module Stimulsoft.Report.Expressions {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiExpression implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private val;
        value: string;
        protected getValueProp(): string;
        protected setValueProp(value: string): void;
        parentComponent: Object;
        fullConvert: boolean;
        applyFormat: boolean;
        genAddEvent: boolean;
        toString(): string;
        clone(): Object;
        constructor(value?: string);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiConditionsCollection extends CollectionBase<StiBaseCondition> implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private isBorderSides(str);
        private convertIconSetItemFromString(str);
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiConditionsCollection;
        add(condition: StiBaseCondition): void;
        addRange(conditions: StiConditionsCollection, addOnlyNotEqual?: boolean): void;
        contains(condition: StiBaseCondition): boolean;
        indexOf(condition: StiBaseCondition): number;
        insert(index: number, condition: StiBaseCondition): void;
        remove(condition: StiBaseCondition): void;
        getByIndex(index: number): StiBaseCondition;
        setByIndex(index: number, value: StiBaseCondition): void;
    }
}
declare module Stimulsoft.Report {
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiBase extends StiService implements IStiName {
        memberwiseClone(): StiBase;
        private _name;
        /** Gets or sets a component name. */
        name: string;
        getName(): string;
        setName(value: string): void;
        implements(): string[];
        readonly localizedName: string;
        readonly localizedCategory: string;
    }
}
declare module Stimulsoft.Report.Events {
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiEvent implements ICloneable, IStiJsonReportObject {
        private static ImplementsStiEvent;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): Object;
        protected readonly propertyName: string;
        private _script;
        script: string;
        private parent;
        set(parent: Stimulsoft.Report.Components.StiComponent, value: string): void;
        constructor(script?: string | Stimulsoft.Report.Components.StiComponent);
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetToolTipEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetHyperlinkEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetTagEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetBookmarkEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiBeforePrintEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiAfterPrintEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetDrillDownReportEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiClickEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiDoubleClickEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiMouseEnterEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiMouseLeaveEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiValueEventHandler: EventHandler;
    class StiValueEventArgs extends EventArgs {
        value: Object;
        displayValue: string;
        constructor(value?: Object);
    }
}
declare module Stimulsoft.Report.Components {
    import StiPaintEventArgs = Stimulsoft.Report.Events.StiPaintEventArgs;
    import StiGetDrillDownReportEventArgs = Stimulsoft.Report.Events.StiGetDrillDownReportEventArgs;
    import StiGetToolTipEvent = Stimulsoft.Report.Events.StiGetToolTipEvent;
    import StiGetHyperlinkEvent = Stimulsoft.Report.Events.StiGetHyperlinkEvent;
    import StiGetTagEvent = Stimulsoft.Report.Events.StiGetTagEvent;
    import StiGetBookmarkEvent = Stimulsoft.Report.Events.StiGetBookmarkEvent;
    import StiBeforePrintEvent = Stimulsoft.Report.Events.StiBeforePrintEvent;
    import StiAfterPrintEvent = Stimulsoft.Report.Events.StiAfterPrintEvent;
    import StiGetDrillDownReportEvent = Stimulsoft.Report.Events.StiGetDrillDownReportEvent;
    import StiClickEvent = Stimulsoft.Report.Events.StiClickEvent;
    import StiDoubleClickEvent = Stimulsoft.Report.Events.StiDoubleClickEvent;
    import StiMouseEnterEvent = Stimulsoft.Report.Events.StiMouseEnterEvent;
    import StiMouseLeaveEvent = Stimulsoft.Report.Events.StiMouseLeaveEvent;
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBase = Stimulsoft.Report.StiBase;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiConditionsCollection = Stimulsoft.Report.Components.StiConditionsCollection;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    class StiComponent extends StiBase implements IStiComponentGuid, IStiCanGrow, IStiCanShrink, IStiUnitConvert, IStiShift, IStiGrowToHeight, IStiAnchor, IStiConditions, IStiPrintOn, IStiInherited, IStiStateSaveRestore, IStiJsonReportObject, IStiComponent {
        private static ImplementsStiComponent;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        protected loadRectangleDFromXml(text: string): RectangleD;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        private _infographicsDisplayRectangle;
        infographicsDisplayRectangle: RectangleD;
        private _isSelected;
        isSelected: boolean;
        select(): void;
        invert(): void;
        reset(): void;
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        private _states;
        readonly states: StiStatesManager;
        getStates(): StiStatesManager;
        clearAllStates(): void;
        shift: boolean;
        getShift(): boolean;
        private _shiftMode;
        shiftMode: StiShiftMode;
        private _guid;
        guid: string;
        newGuid(): void;
        private _printOn;
        printOn: StiPrintOnType;
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        memberwiseClone(): StiComponent;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        private _canShrink;
        canShrink: boolean;
        getCanShrink(): boolean;
        private _canGrow;
        canGrow: boolean;
        getCanGrow(): boolean;
        setCanGrow(value: boolean): void;
        private _growToHeight;
        growToHeight: boolean;
        getGrowToHeight(): boolean;
        private _anchor;
        anchor: StiAnchorMode;
        private _conditions;
        conditions: StiConditionsCollection;
        getConditions(): StiConditionsCollection;
        setConditions(value: StiConditionsCollection): void;
        private static propertyInherited;
        inherited: boolean;
        getActualSize(): SizeD;
        getReport(): StiReport;
        report: StiReport;
        private _interaction;
        interaction: StiInteraction;
        doBookmark(): void;
        private doGetBookmark();
        printable: boolean;
        private _isRendered;
        isRendered: boolean;
        private static propertyRenderedCount;
        renderedCount: number;
        allowPrintOn(): boolean;
        readonly isEnabled: boolean;
        prepare(): void;
        unPrepare(): void;
        setReportVariables(): void;
        internalRender(): StiComponent;
        render(): StiComponent;
        paint(g: Stimulsoft.System.Drawing.Graphics): void;
        dockStyle: StiDockStyle;
        getDockStyle(): StiDockStyle;
        readonly isAutomaticDock: boolean;
        getDockRegion(parent: StiComponent, useColumns?: boolean): RectangleD;
        dockToContainer(): void;
        dockToContainer2(rect: RectangleD): RectangleD;
        private checkWidth(width);
        private checkHeight(height);
        private disableCheckWidthHeight;
        private static propertyMinSize;
        minSize: SizeD;
        getMinSize(): SizeD;
        setMinSize(value: SizeD): void;
        private static propertyMaxSize;
        maxSize: SizeD;
        getMaxSize(): SizeD;
        setMaxSize(value: SizeD): void;
        private _left;
        left: number;
        getLeft(): number;
        setLeft(value: number): void;
        private _top;
        top: number;
        getTop(): number;
        setTop(value: number): void;
        private _width;
        width: number;
        getWidth(): number;
        protected setWidth(value: number): void;
        private _height;
        height: number;
        getHeight(): number;
        setHeight(value: number): void;
        readonly right: number;
        readonly bottom: number;
        getBottom(): number;
        clientRectangle: RectangleD;
        protected setClientRectangle(value: RectangleD): void;
        displayRectangle: RectangleD;
        getDisplayRectangle(): RectangleD;
        setDisplayRectangle(value: RectangleD): void;
        setDirectDisplayRectangle(rect: RectangleD): void;
        selectRectangle: RectangleD;
        readonly defaultClientRectangle: RectangleD;
        private _parentBookmark;
        parentBookmark: StiBookmark;
        private _currentBookmark;
        currentBookmark: StiBookmark;
        invokeEvents(): void;
        readonly isGetToolTipHandlerEmpty: boolean;
        private static eventGetToolTip;
        protected onGetToolTip(): void;
        invokeGetToolTip(sender: any, e: StiValueEventArgs): void;
        getToolTipEvent: StiGetToolTipEvent;
        readonly isGetHyperlinkHandlerEmpty: boolean;
        private static eventGetHyperlink;
        protected onGetHyperlink(e: StiValueEventArgs): void;
        invokeGetHyperlink(sender: Object, e: StiValueEventArgs): void;
        getHyperlinkEvent: StiGetHyperlinkEvent;
        readonly isGetTagHandlerEmpty: boolean;
        private static eventGetTag;
        protected onGetTag(e: StiValueEventArgs): void;
        invokeGetTag(sender: Object, e: StiValueEventArgs): void;
        getTagEvent: StiGetTagEvent;
        readonly isGetBookmarkHandlerEmpty: boolean;
        private static eventGetBookmark;
        protected onGetBookmark(): void;
        invokeGetBookmark(sender: any, e: EventArgs): void;
        getBookmarkEvent: StiGetBookmarkEvent;
        private static eventBeforePrint;
        protected onBeforePrint(e: EventArgs): void;
        invokeBeforePrint(sender: any, e: EventArgs): void;
        applyConditions(sender: Object, conditions: any[]): void;
        beforePrintEvent: StiBeforePrintEvent;
        private static eventAfterPrint;
        protected onAfterPrint(e: EventArgs): void;
        invokeAfterPrint(sender: any, e: EventArgs): void;
        afterPrintEvent: StiAfterPrintEvent;
        private static eventGetDrillDownReport;
        protected onGetDrillDownReport(e: StiGetDrillDownReportEventArgs): void;
        invokeGetDrillDownReport(sender: Object, e: StiGetDrillDownReportEventArgs): void;
        getDrillDownReportEvent: StiGetDrillDownReportEvent;
        readonly isClickHandlerEmpty: boolean;
        private static eventClick;
        protected onClick(e: EventArgs): void;
        invokeClick(sender: Object, e: EventArgs): void;
        clickEvent: StiClickEvent;
        readonly isDoubleClickHandlerEmpty: boolean;
        private static eventDoubleClick;
        protected onDoubleClick(e: EventArgs): void;
        invokeDoubleClick(sender: Object, e: EventArgs): void;
        doubleClickEvent: StiDoubleClickEvent;
        readonly isMouseEnterHandlerEmpty: boolean;
        private static eventMouseEnter;
        protected onMouseEnter(e: EventArgs): void;
        invokeMouseEnter(sender: Object, e: EventArgs): void;
        mouseEnterEvent: StiMouseEnterEvent;
        readonly isMouseLeaveHandlerEmpty: boolean;
        private static eventMouseLeave;
        protected onMouseLeave(e: EventArgs): void;
        invokeMouseLeave(sender: Object, e: EventArgs): void;
        mouseLeaveEvent: StiMouseLeaveEvent;
        private static eventPainting;
        protected onPainting(e: StiPaintEventArgs): void;
        invokePainting(sender: StiComponent, e: StiPaintEventArgs): void;
        private static eventPainted;
        protected onPainted(e: StiPaintEventArgs): void;
        invokePainted(sender: StiComponent, e: StiPaintEventArgs): void;
        bookmarkValue: Object;
        bookmark: string;
        toolTipValue: Object;
        toolTip: string;
        hyperlinkValue: Object;
        hyperlink: string;
        tagValue: Object;
        tag: string;
        private _alias;
        alias: string;
        private _events;
        protected readonly events: Hashtable;
        protected static propertyRestrictions: string;
        restrictions: StiRestrictions;
        getRestrictions(): StiRestrictions;
        setRestrictions(value: StiRestrictions): void;
        ignoreNamingRule: boolean;
        setName(value: string): void;
        protected static propertyPlaceOnToolbox: string;
        placeOnToolbox: boolean;
        readonly isPrinting: boolean;
        readonly isExporting: boolean;
        readonly isDesigning: boolean;
        allowDelete(): boolean;
        readonly priority: number;
        readonly componentType: StiComponentType;
        protected static propertyDockable: string;
        dockable: boolean;
        highlightState: StiHighlightState;
        private _componentPlacement;
        componentPlacement: string;
        private _drillDownParameters;
        drillDownParameters: any[];
        protected static propertyComponentStyle: string;
        componentStyle: string;
        getComponentStyle(): string;
        setComponentStyle(value: string): void;
        protected static propertyLocked: string;
        locked: boolean;
        protected static propertyLinked: string;
        linked: boolean;
        getLinked(): boolean;
        setLinked(value: boolean): void;
        enabled: boolean;
        getEnabled(): boolean;
        setEnabled(value: boolean): void;
        private static propertyUseParentStyles;
        useParentStyles: boolean;
        getUseParentStyles(): boolean;
        setUseParentStyles(value: boolean): void;
        private _page;
        page: StiPage;
        protected getPage(): StiPage;
        protected setPage(value: StiPage): void;
        private _parent;
        parent: StiContainer;
        isExportAsImage(format: StiExportFormat): boolean;
        private lockOnResize;
        private invokeOnResizeComponent(oldSize, newSize);
        onResizeComponent(oldSize: SizeD, newSize: SizeD): void;
        clearContents(): void;
        toString(): string;
        readonly isCross: boolean;
        canContainIn(component: StiComponent): boolean;
        componentToPage(value: PointD | RectangleD): any;
        pageToComponent(value: PointD | RectangleD): any;
        static isParentSelect(component: StiComponent): boolean;
        static doOffsetRect(component: StiComponent, rect: RectangleD, offsetRect: RectangleD): RectangleD;
        getPaintRectangle(convertToHInches?: boolean, convertByZoom?: boolean, docking?: boolean): RectangleD;
        setPaintRectangle(rect: RectangleD): void;
        getDisplayRectangle2(): RectangleD;
        getDataBand(): StiDataBand;
        getGroupHeaderBand(): StiGroupHeaderBand;
        getContainer(): StiContainer;
        checkForParentComponent(comp: StiComponent): boolean;
        getComponentStyle2(): StiBaseStyle;
        private bits;
        constructor(rect?: RectangleD, isSuper?: boolean);
        protected construct(rect?: RectangleD): void;
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import StiAngle = Stimulsoft.Report.Components.StiAngle;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import IStiBackColor = Stimulsoft.Report.Components.IStiBackColor;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    import IStiVertAlignment = Stimulsoft.Report.Components.IStiVertAlignment;
    import IStiBorder = Stimulsoft.Report.Components.IStiBorder;
    import IStiEnumAngle = Stimulsoft.Report.Components.IStiEnumAngle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiBarCode extends StiComponent implements IStiBarCode, IStiBackColor, IStiForeColor, IStiVertAlignment, IStiHorAlignment, IStiEnumAngle, IStiBorder {
        private static implementsStiBarCode;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        readonly helpUrl: string;
        readonly localizedCategory: string;
        readonly localizedName: string;
        isExportAsImage(format: StiExportFormat): boolean;
        private _angle;
        angle: StiAngle;
        private _border;
        border: StiBorder;
        private _foreColor;
        foreColor: Color;
        private _backColor;
        backColor: Color;
        private _autoScale;
        autoScale: boolean;
        private _showLabelText;
        showLabelText: boolean;
        private _showQuietZones;
        showQuietZones: boolean;
        private _barCodeType;
        barCodeType: StiBarCodeTypeService;
        getBarCodeString(): string;
        private _font;
        font: Font;
        private _horAlignment;
        horAlignment: StiHorAlignment;
        private _vertAlignment;
        vertAlignment: StiVertAlignment;
        private _codeValue;
        codeValue: string;
        private _code;
        code: string;
        invokeEvents(): void;
        private static eventGetBarCode;
        onGetBarCode(e: StiValueEventArgs): void;
        invokeGetBarCode(sender: StiComponent, e: StiValueEventArgs): void;
        getBarCodeEvent: Stimulsoft.Report.Events.StiGetBarCodeEvent;
        createNew(): StiComponent;
        readonly defaultClientRectangle: RectangleD;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.BarCodes {
    class StiBarCodeData {
        spaceLeft: number;
        spaceRight: number;
        spaceTop: number;
        spaceBottom: number;
        lineHeightShort: number;
        lineHeightLong: number;
        lineWidth: number;
        textPosition: number;
        textHeight: number;
        mainHeight: number;
        mainWidth: number;
        wideToNarrowRatio: number;
        code: string;
        textString: string;
        barsArray: string;
        fullZoomY: number;
        spaceBeforeAdd: number;
        spaceTextTop: number;
        textPositionTop: number;
        textPositionBottom: number;
        eanBarsArray: EanBarInfo[];
        offsetY: number;
        matrixGrid: number[];
        matrixWidth: number;
        matrixHeight: number;
        matrixRatioY: number;
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiCodabarBarCodeType extends StiBarCodeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        private codabarSymbols;
        private codabarTable;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _ratio;
        ratio: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        codabarSpaceLeft: number;
        codabarSpaceRight: number;
        codabarSpaceTop: number;
        codabarSpaceBottom: number;
        codabarLineHeightShort: number;
        codabarLineHeightLong: number;
        codabarTextPosition: number;
        codabarTextHeight: number;
        codabarMainHeight: number;
        codabarLineHeightForCut: number;
        codeToBar(inputCode: string): string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, ratio?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiCode11BarCodeType extends StiBarCodeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        code11Symbols: string;
        code11StartStopSymbolIndex: number;
        code11Table: string[];
        code11SpaceLeft: number;
        code11SpaceRight: number;
        code11SpaceTop: number;
        code11SpaceBottom: number;
        code11LineHeightShort: number;
        code11LineHeightLong: number;
        code11TextPosition: number;
        code11TextHeight: number;
        code11MainHeight: number;
        code11LineHeightForCut: number;
        defaultCode11Module: number;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _checksum;
        checksum: StiCode11CheckSum;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, checksum?: StiCode11CheckSum);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiCode128BarCodeType extends StiBarCodeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        protected code128Table: string[];
        private _module;
        module: number;
        private _height;
        height: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        protected code128SpaceLeft: number;
        protected code128SpaceRight: number;
        protected code128SpaceTop: number;
        protected code128SpaceBottom: number;
        protected code128LineHeightShort: number;
        protected code128LineHeightLong: number;
        protected code128TextPosition: number;
        protected code128TextHeight: number;
        protected code128MainHeight: number;
        protected code128LineHeightForCut: number;
        protected defaultCodeSetAB: CodeSet;
        protected codeToBar(inputCode: string): string;
        protected encodeAuto(inputText: string, encodeAsEan: boolean): string;
        private isDigit(aChar);
        private getSet(text, pos, prevSet);
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode128AutoBarCodeType extends StiCode128BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode128aBarCodeType extends StiCode128BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode128bBarCodeType extends StiCode128BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode128cBarCodeType extends StiCode128BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiCode39BarCodeType extends StiBarCodeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        code39Symbols: string;
        code39StartStopSymbolIndex: number;
        code39Table: string[];
        readonly defaultCodeValue: string;
        private _checkSum;
        checkSum: StiCheckSum;
        private _module;
        module: number;
        private _height;
        height: number;
        private _ratio;
        ratio: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        code39SpaceLeft: number;
        code39SpaceRight: number;
        code39SpaceTop: number;
        code39SpaceBottom: number;
        code39LineHeightShort: number;
        code39LineHeightLong: number;
        code39TextPosition: number;
        code39TextHeight: number;
        code39MainHeight: number;
        code39LineHeightForCut: number;
        codeToBar(inputCode: string): string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, ratio?: number, checkSum?: StiCheckSum);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode39ExtBarCodeType extends StiCode39BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        protected code39ExtTable: string[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, ratio?: number, checkSum?: StiCheckSum);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiCode93BarCodeType extends StiBarCodeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        private code93Symbols;
        code93Table: string[];
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _ratio;
        ratio: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        code93SpaceLeft: number;
        code93SpaceRight: number;
        code93SpaceTop: number;
        code93SpaceBottom: number;
        code93LineHeightShort: number;
        code93LineHeightLong: number;
        code93TextPosition: number;
        code93TextHeight: number;
        code93MainHeight: number;
        code93LineHeightForCut: number;
        codeToBar(inputCode: string): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, ratio?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode93ExtBarCodeType extends StiCode93BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        private code93ExtSymbols;
        private code93ExtTable;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, ratio?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDataMatrix {
        readonly matrix: number[];
        readonly width: number;
        readonly height: number;
        readonly errorMessage: string;
        private gridWidth;
        private gridHeight;
        private grid;
        private _errorMessage;
        private ecc200List;
        private dataMatrixPlacementbit(array, numRows, numColumns, row, column, pos, b);
        private dataMatrixPlacementBlock(array, numRows, numColumns, row, column, pos);
        private dataMatrixPlacementCornerA(array, numRows, numColumns, pos);
        private dataMatrixPlacementCornerB(array, numRows, numColumns, pos);
        private dataMatrixPlacementCornerC(array, numRows, numColumns, pos);
        private dataMatrixPlacementCornerD(array, numRows, numColumns, pos);
        private dataMatrixPlacement(numRows, numColumns);
        private makeEcc200Blocks(binary, bytes, datablock, rsblock);
        private dataMatrixEncode(output, matrixLength, barcode, encoding);
        private encodeB(output, matrixLength, barcode, RESbarPos, RESoutPos);
        private encodeA(output, matrixLength, barcode, RESbarPos, RESoutPos);
        private encodeE(output, matrixLength, barcode, RESbarPos, RESoutPos);
        private encodeCTX(output, matrixLength, barcode, encoding, RESbarPos, RESoutPos);
        private static isDigit(b);
        private static convertStringToBytes(st);
        private makeGrid(barcode, REFwidthOriginal, REFheightOriginal, globalEncoding);
        constructor(message: string, globalEncoding: StiDataMatrixEncodingType, useRectangularSymbols: boolean, matrixSize: StiDataMatrixSize);
    }
    class StiDataMatrixBarCodeType extends StiBarCodeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _encodingType;
        encodingType: StiDataMatrixEncodingType;
        private _matrixSize;
        matrixSize: StiDataMatrixSize;
        private _useRectangularSymbols;
        useRectangularSymbols: boolean;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, encodingType?: StiDataMatrixEncodingType, useRectangularSymbols?: boolean, matrixSize?: StiDataMatrixSize);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDutchKIXBarCodeType extends StiBarCodeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        dutchKIXSymbols: string;
        private dutchKIXCodes;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        dutchKIXSpaceLeft: number;
        dutchKIXSpaceRight: number;
        dutchKIXSpaceTop: number;
        dutchKIXSpaceBottom: number;
        dutchKIXLineHeightLong: number;
        dutchKIXLineHeightShort: number;
        dutchKIXTextPosition: number;
        dutchKIXTextHeight: number;
        dutchKIXMainHeight: number;
        dutchKIXLineHeightForCut: number;
        readonly textAlignment: StringAlignment;
        private charTo4State(inputChar);
        private stateToBar(inputCode);
        private makeBarsArray(REFcode, REFbarsArray, REFerrorString);
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEAN128AutoBarCodeType extends StiCode128BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEAN128aBarCodeType extends StiCode128BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEAN128bBarCodeType extends StiCode128BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEAN128cBarCodeType extends StiCode128BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class EanBarInfo {
        symbolType: Ean13Symbol;
        symbolText: string;
        textAtTop: boolean;
        makeLonger: boolean;
        constructor(symbolType: Ean13Symbol, symbolText: string, textAtTop: boolean, makeLonger?: boolean);
    }
    enum Ean13Symbol {
        ComboA0 = 0,
        ComboA1 = 1,
        ComboA2 = 2,
        ComboA3 = 3,
        ComboA4 = 4,
        ComboA5 = 5,
        ComboA6 = 6,
        ComboA7 = 7,
        ComboA8 = 8,
        ComboA9 = 9,
        ComboB0 = 10,
        ComboB1 = 11,
        ComboB2 = 12,
        ComboB3 = 13,
        ComboB4 = 14,
        ComboB5 = 15,
        ComboB6 = 16,
        ComboB7 = 17,
        ComboB8 = 18,
        ComboB9 = 19,
        ComboC0 = 20,
        ComboC1 = 21,
        ComboC2 = 22,
        ComboC3 = 23,
        ComboC4 = 24,
        ComboC5 = 25,
        ComboC6 = 26,
        ComboC7 = 27,
        ComboC8 = 28,
        ComboC9 = 29,
        GuardLeft = 30,
        GuardCenter = 31,
        GuardRight = 32,
        GuardSpecial = 33,
        GuardAddLeft = 34,
        GuardAddDelineator = 35,
        SpaceLeft = 36,
        SpaceRight = 37,
        SpaceBeforeAdd = 38,
    }
    class StiEAN13BarCodeType extends StiBarCodeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        readonly visibleProperties: boolean[];
        private _module;
        module: number;
        private _height;
        height: number;
        private _supplementType;
        supplementType: StiEanSupplementType;
        private _supplementCodeValue;
        supplementCode: string;
        private _showQuietZoneIndicator;
        showQuietZoneIndicator: boolean;
        readonly labelFontHeight: number;
        protected readonly eanSpaceLeft: number;
        protected readonly eanSpaceRight: number;
        protected readonly eanSpaceTop: number;
        protected readonly eanSpaceBottom: number;
        protected readonly eanSpaceBeforeAdd: number;
        protected readonly eanSpaceTextTop: number;
        protected readonly eanLineHeightShort: number;
        protected readonly eanLineHeightLong: number;
        protected readonly eanTextPositionTop: number;
        protected readonly eanTextPositionBottom: number;
        protected readonly eanTextHeight: number;
        protected readonly eanMainHeight: number;
        protected readonly eanLineHeightForCut: number;
        protected readonly eanWideToNarrowRatio: number;
        protected symComboSet: string[];
        protected symParitySetAdd2: string[];
        protected symParitySetAdd5: string[];
        protected ean13SymData: string[];
        protected calculateSizeEan(offsetY: number, zoom: number, barsArray: EanBarInfo[], rect: RectangleD, barCode: StiBarCode): void;
        protected drawEanBars(context: any, barsArray: EanBarInfo[], barCode: StiBarCode): void;
        protected makeEan13Bars(REFcode: any, isLast: boolean): EanBarInfo[];
        protected makeEanAdd2Bars(code: string, baseArray: EanBarInfo[], isLast: boolean): EanBarInfo[];
        protected makeEanAdd5Bars(code: string, baseArray: EanBarInfo[], isLast: boolean): EanBarInfo[];
        protected makeLonger(symString: string): string;
        protected getSymbolWidth(symbol: string): number;
        protected isSymbolSpace(symbol: string): boolean;
        draw(context: number, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEAN8BarCodeType extends StiEAN13BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        readonly eanSpaceLeft: number;
        readonly eanSpaceRight: number;
        readonly eanLineHeightShort: number;
        readonly eanMainHeight: number;
        makeEan8Bars(code: string, isLast: boolean): EanBarInfo[];
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiFIMBarCodeType extends StiBarCodeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        fIMSymbols: string;
        fIMTable: string[];
        defaultFIMModule: number;
        readonly defaultCodeValue: string;
        readonly visibleProperties: boolean[];
        private _module;
        module: number;
        private _height;
        height: number;
        private _addClearZone;
        addClearZone: boolean;
        readonly labelFontHeight: number;
        readonly fIMSpaceLeft: number;
        readonly fIMSpaceRight: number;
        fIMSpaceTop: number;
        fIMSpaceBottom: number;
        fIMLineHeightShort: number;
        fIMLineHeightLong: number;
        fIMTextPosition: number;
        fIMTextHeight: number;
        fIMMainHeight: number;
        fIMLineHeightForCut: number;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, addClearZone?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiITF14BarCodeType extends StiBarCodeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _ratio;
        ratio: number;
        private _printVerticalBars;
        printVerticalBars: boolean;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        protected symTableSet: string[];
        private itf14BearerBarWidth;
        private itf14SpaceLeft;
        private itf14SpaceRight;
        private itf14SpaceTop;
        private itf14SpaceBottom;
        private itf14LineHeightShort;
        private itf14LineHeightLong;
        private itf14TextHeight;
        private itf14MainHeight;
        private itf14TextPosition;
        private itf14LineHeightForCut;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, ratio?: number, printVerticalBars?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiInterleaved2of5BarCodeType extends StiBarCodeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _ratio;
        ratio: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        protected symTableSet: string[];
        private interleaved2of5SpaceLeft;
        private interleaved2of5SpaceRight;
        private interleaved2of5SpaceTop;
        private interleaved2of5SpaceBottom;
        private interleaved2of5LineHeightShort;
        private interleaved2of5LineHeightLong;
        private interleaved2of5TextHeight;
        private interleaved2of5MainHeight;
        private interleaved2of5TextPosition;
        private interleaved2of5LineHeightForCut;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        StiInterleaved2of5BarCodeType(module?: number, height?: number, ratio?: number): void;
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiIsbn13BarCodeType extends StiEAN13BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        isbnOffsetY: number;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiIsbn10BarCodeType extends StiIsbn13BarCodeType {
        readonly componentId: StiComponentId;
        readonly visibleProperties: boolean[];
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiJan13BarCodeType extends StiEAN13BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        readonly visibleProperties: boolean[];
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiJan8BarCodeType extends StiEAN8BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        readonly visibleProperties: boolean[];
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiMaxicodeMode = Stimulsoft.Report.BarCodes.StiMaxicodeMode;
    class StiMaxicodeBarCodeType extends StiBarCodeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        module: number;
        readonly height: number;
        innerHeight: number;
        private _mode;
        mode: StiMaxicodeMode;
        private _processTilde;
        processTilde: boolean;
        private _structuredAppendPosition;
        structuredAppendPosition: number;
        private _structuredAppendTotal;
        structuredAppendTotal: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(mode?: StiMaxicodeMode, structuredAppendPosition?: number, structuredAppendTotal?: number, processTilde?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiPlesseyBarCodeType extends StiBarCodeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        plesseySymbols: string;
        private plesseyTable;
        private plesseyStartCode;
        private plesseyStopCode;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _checkSum1;
        checkSum1: StiPlesseyCheckSum;
        private _checkSum2;
        checkSum2: StiPlesseyCheckSum;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        plesseySpaceLeft: number;
        plesseySpaceRight: number;
        plesseySpaceTop: number;
        plesseySpaceBottom: number;
        plesseyLineHeightShort: number;
        plesseyLineHeightLong: number;
        plesseyTextPosition: number;
        plesseyTextHeight: number;
        plesseyMainHeight: number;
        plesseyLineHeightForCut: number;
        private codeToBar(inputCode);
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, checkSum1?: StiPlesseyCheckSum, checkSum2?: StiPlesseyCheckSum);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiMsiBarCodeType extends StiPlesseyBarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        readonly visibleProperties: boolean[];
        private msiTable;
        private msiStartCode;
        private msiStopCode;
        protected codeToBarMsi(inputCode: string): string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, checkSum1?: StiPlesseyCheckSum, checkSum2?: StiPlesseyCheckSum);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiPdf417BarCodeType extends StiBarCodeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _encodingMode;
        encodingMode: StiPdf417EncodingMode;
        private _errorsCorrectionLevel;
        errorsCorrectionLevel: StiPdf417ErrorsCorrectionLevel;
        private _dataColumns;
        dataColumns: number;
        private _dataRows;
        dataRows: number;
        private _autoDataColumns;
        autoDataColumns: boolean;
        private _autoDataRows;
        autoDataRows: boolean;
        private _aspectRatio;
        aspectRatio: number;
        private _ratioY;
        ratioY: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, encodingMode?: StiPdf417EncodingMode, errorsCorrectionLevel?: StiPdf417ErrorsCorrectionLevel, dataColumns?: number, dataRows?: number, autoDataColumns?: boolean, autoDataRows?: boolean, aspectRatio?: number, ratioY?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiPharmacodeBarCodeType extends StiBarCodeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        pharmacodeSymbols: string;
        defaultPharmacodeModule: number;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        pharmacodeSpaceLeft: number;
        pharmacodeSpaceRight: number;
        pharmacodeSpaceTop: number;
        pharmacodeSpaceBottom: number;
        pharmacodeLineHeightShort: number;
        pharmacodeLineHeightLong: number;
        pharmacodeTextPosition: number;
        pharmacodeTextHeight: number;
        pharmacodeMainHeight: number;
        pharmacodeLineHeightForCut: number;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiPostnetBarCodeType extends StiBarCodeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        postnetSymbols: string;
        private postnetTable;
        private postnetStartCode;
        private postnetStopCode;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _space;
        space: number;
        private _height;
        height: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        postnetSpaceLeft: number;
        postnetSpaceRight: number;
        postnetSpaceTop: number;
        postnetSpaceBottom: number;
        postnetLineHeightLong: number;
        postnetLineHeightShort: number;
        postnetTextPosition: number;
        postnetTextHeight: number;
        postnetMainHeight: number;
        postnetLineHeightForCut: number;
        private codeToBar(inputCode);
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, space?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Image = Stimulsoft.System.Drawing.Image;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiQRCodeBarCodeType extends StiBarCodeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _errorCorrectionLevel;
        errorCorrectionLevel: StiQRCodeErrorCorrectionLevel;
        private _matrixSize;
        matrixSize: StiQRCodeSize;
        private _image;
        image: Image;
        private _imageMultipleFactor;
        imageMultipleFactor: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, errorCorrectionLevel?: StiQRCodeErrorCorrectionLevel, matrixSize?: StiQRCodeSize, image?: Image, imageMultipleFactor?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiRoyalMail4StateBarCodeType extends StiBarCodeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        royalMail4StateSymbols: string;
        private royalMail4StateStartCode;
        private royalMail4StateStopCode;
        private royalMail4StateCodes;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _checkSum;
        checkSum: StiCheckSum;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        royalMail4StateSpaceLeft: number;
        royalMail4StateSpaceRight: number;
        royalMail4StateSpaceTop: number;
        royalMail4StateSpaceBottom: number;
        royalMail4StateLineHeightLong: number;
        royalMail4StateLineHeightShort: number;
        royalMail4StateTextPosition: number;
        royalMail4StateTextHeight: number;
        royalMail4StateMainHeight: number;
        royalMail4StateLineHeightForCut: number;
        readonly textAlignment: StringAlignment;
        private charTo4State(inputChar);
        private stateToBar(inputCode);
        private makeBarsArray(REFcode, REFbarsArray, REFerrorString);
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, checkSum?: StiCheckSum);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiSSCC18BarCodeType extends StiCode128cBarCodeType {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        private _companyPrefix;
        companyPrefix: string;
        private _serialNumber;
        serialNumber: string;
        private _extensionDigit;
        extensionDigit: string;
        readonly textSpacing: boolean;
        readonly visibleProperties: boolean[];
        getCombinedCode(): string;
        private getCheckDigit(input);
        private checkContens(inputCode, arr);
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStandard2of5BarCodeType extends StiBarCodeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _ratio;
        ratio: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        protected symTableSet: string[];
        private standard2of5SpaceLeft;
        private standard2of5SpaceRight;
        private standard2of5SpaceTop;
        private standard2of5SpaceBottom;
        private standard2of5LineHeightShort;
        private standard2of5LineHeightLong;
        private standard2of5TextHeight;
        private standard2of5MainHeight;
        private standard2of5TextPosition;
        private standard2of5LineHeightForCut;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, ratio?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiUpcABarCodeType extends StiEAN13BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly eanSpaceLeft: number;
        readonly eanSpaceRight: number;
        readonly defaultCodeValue: string;
        readonly visibleProperties: boolean[];
        showQuietZoneIndicator: boolean;
        makeUpcABars(code: string, isLast: boolean): EanBarInfo[];
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    class StiUpcEBarCodeType extends StiEAN13BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        protected symParitySet: string[];
        protected readonly eanSpaceLeft: number;
        protected readonly eanSpaceRight: number;
        readonly defaultCodeValue: string;
        readonly visibleProperties: boolean[];
        showQuietZoneIndicator: boolean;
        protected makeUpcEBars(code: string, isLast: boolean): EanBarInfo[];
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiUpcSup2BarCodeType extends StiEAN13BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        readonly visibleProperties: boolean[];
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiUpcSup5BarCodeType extends StiEAN13BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        readonly visibleProperties: boolean[];
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiBubbleArea: string;
    interface IStiBubbleArea extends IStiScatterArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiCandlestickArea: string;
    interface IStiCandlestickArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiClusteredBarArea: string;
    interface IStiClusteredBarArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiAreaArea: string;
    interface IStiAreaArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiClusteredColumnArea: string;
    interface IStiClusteredColumnArea extends IStiAxisArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiLineArea: string;
    interface IStiLineArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiSplineArea: string;
    interface IStiSplineArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiSplineAreaArea: string;
    interface IStiSplineAreaArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiSteppedAreaArea: string;
    interface IStiSteppedAreaArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiSteppedLineArea: string;
    interface IStiSteppedLineArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiDoughnutArea: string;
    interface IStiDoughnutArea extends IStiPieArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedBarArea: string;
    interface IStiFullStackedBarArea extends IStiStackedBarArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedAreaArea: string;
    interface IStiFullStackedAreaArea extends IStiFullStackedColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedColumnArea: string;
    interface IStiFullStackedColumnArea extends IStiStackedColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedLineArea: string;
    interface IStiFullStackedLineArea extends IStiFullStackedColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedSplineArea: string;
    interface IStiFullStackedSplineArea extends IStiFullStackedColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedSplineAreaArea: string;
    interface IStiFullStackedSplineAreaArea extends IStiFullStackedColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFunnelArea: string;
    interface IStiFunnelArea extends IStiArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiGanttArea: string;
    interface IStiGanttArea extends IStiClusteredBarArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiPictorialArea: string;
    interface IStiPictorialArea extends IStiArea {
        roundValues: boolean;
        actual: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiPieArea: string;
    interface IStiPieArea extends IStiArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarArea: string;
    interface IStiRadarArea extends IStiArea {
        radarStyle: StiRadarStyle;
        xAxis: IStiXRadarAxis;
        yAxis: IStiYRadarAxis;
        interlacingHor: IStiInterlacingHor;
        interlacingVert: IStiInterlacingVert;
        gridLinesHor: IStiRadarGridLinesHor;
        gridLinesVert: IStiRadarGridLinesVert;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarAreaArea: string;
    interface IStiRadarAreaArea extends IStiRadarArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarLineArea: string;
    interface IStiRadarLineArea extends IStiRadarArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarPointArea: string;
    interface IStiRadarPointArea extends IStiRadarArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRangeArea: string;
    interface IStiRangeArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRangeBarArea: string;
    interface IStiRangeBarArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiSplineRangeArea: string;
    interface IStiSplineRangeArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiSteppedRangeArea: string;
    interface IStiSteppedRangeArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiScatterArea: string;
    interface IStiScatterArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiStackedBarArea: string;
    interface IStiStackedBarArea extends IStiClusteredBarArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiStackedAreaArea: string;
    interface IStiStackedAreaArea extends IStiStackedColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiStackedColumnArea: string;
    interface IStiStackedColumnArea extends IStiAxisArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiStackedLineArea: string;
    interface IStiStackedLineArea extends IStiStackedColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiStackedSplineArea: string;
    interface IStiStackedSplineArea extends IStiStackedColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiStackedSplineAreaArea: string;
    interface IStiStackedSplineAreaArea extends IStiStackedColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiStockArea: string;
    interface IStiStockArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiTreemapArea: string;
    interface IStiTreemapArea extends IStiArea {
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiArea: string;
    interface IStiArea extends ICloneable, IStiJsonReportObject {
        core: IStiAreaCoreXF;
        chart: IStiChart;
        allowApplyStyle: boolean;
        colorEach: boolean;
        showShadow: boolean;
        borderColor: Color;
        brush: StiBrush;
        isDefaultSeriesTypeFullStackedColumnSeries: boolean;
        isDefaultSeriesTypeFullStackedBarSeries: boolean;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    var IStiAreaCoreXF: string;
    interface IStiAreaCoreXF extends IStiApplyStyle {
        isAcceptableSeries(seriesType: Stimulsoft.System.Type): boolean;
        isAcceptableSeriesLabels(seriesLabelsType: Stimulsoft.System.Type): boolean;
        render(context: StiContext, rect: RectangleD): IStiCellGeom;
        checkInLabelsTypes(typeForCheck: Stimulsoft.System.Type): boolean;
        seriesOrientation: StiChartSeriesOrientation;
        getSeries(): IStiSeries[];
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiAxisArea: string;
    interface IStiAxisArea extends IStiArea {
        axisCore: IStiAxisAreaCoreXF;
        interlacingHor: IStiInterlacingHor;
        interlacingVert: IStiInterlacingVert;
        gridLinesHor: IStiGridLinesHor;
        gridLinesHorRight: IStiGridLinesHor;
        gridLinesVert: IStiGridLinesVert;
        yAxis: IStiYAxis;
        yRightAxis: IStiYAxis;
        xAxis: IStiXAxis;
        xTopAxis: IStiXAxis;
        reverseHor: boolean;
        reverseVert: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiAxisAreaCoreXF: string;
    interface IStiAxisAreaCoreXF extends IStiAreaCoreXF {
        switchOff(): any;
        getDividerX(): number;
        getDividerY(): number;
        getDividerRightY(): number;
        valuesCount: number;
        scrollRangeX: number;
        scrollRangeY: number;
        scrollDpiX: number;
        scrollDpiY: number;
        getArgumentLabel(line: IStiStripLineXF, series: IStiSeries): string;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiStripLineXF: string;
    interface IStiStripLineXF {
        valueObject: Object;
        value: number;
    }
}
declare module Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    var IStiStripLinesXF: string;
    interface IStiStripLinesXF extends ICollection<IStiStripLineXF> {
        add(valueObject: Object, value: number): any;
        getByindex(index: number): IStiStripLineXF;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiStripPositionXF: string;
    interface IStiStripPositionXF {
        stripLine: IStiStripLineXF;
        position: number;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiAxis: string;
    interface IStiAxis extends ICloneable, IStiJsonReportObject {
        logarithmicScale: boolean;
        core: IStiAxisCoreXF;
        allowApplyStyle: boolean;
        startFromZero: boolean;
        step: number;
        interaction: IStiAxisInteraction;
        labels: IStiAxisLabels;
        range: IStiAxisRange;
        title: IStiAxisTitle;
        ticks: IStiAxisTicks;
        arrowStyle: StiArrowStyle;
        lineStyle: StiPenStyle;
        lineColor: Color;
        lineWidth: number;
        visible: boolean;
        area: IStiAxisArea;
        info: IStiAxisInfoXF;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    var IStiAxisCoreXF: string;
    interface IStiAxisCoreXF extends IStiApplyStyle {
        arrowHeight: number;
        arrowWidth: number;
        ticksMaxLength: number;
        renderView(context: StiContext, rect: RectangleD): IStiCellGeom;
        render(context: StiContext, rect: RectangleD): IStiCellGeom;
        applyStyle(style: IStiChartStyle): any;
        getStartFromZero(): boolean;
        calculateStripPositions(topPosition: number, bottomPosition: number): any;
        getFontGeom(context: StiContext): StiFontGeom;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        isMouseOverDecreaseButton: boolean;
        isMouseOverIncreaseButton: boolean;
        isMouseOverTrackBar: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiAxisDateTimeStep: string;
    interface IStiAxisDateTimeStep extends ICloneable, IStiJsonReportObject {
        step: StiTimeDateStep;
        numberOfValues: number;
        interpolation: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    var IStiAxisInfoXF: string;
    interface IStiAxisInfoXF extends ICloneable {
        minimum: number;
        maximum: number;
        stripLines: IStiStripLinesXF;
        stripPositions: number[];
        dpi: number;
        ticksCollection: IStiStripPositionXF[];
        labelsCollection: IStiStripPositionXF[];
        step: number;
        range: number;
        clone(): IStiAxisInfoXF;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiAxisInteraction: string;
    interface IStiAxisInteraction extends ICloneable, IStiJsonReportObject {
        showScrollBar: boolean;
        rangeScrollEnabled: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiAxisLabels: string;
    interface IStiAxisLabels extends ICloneable, IStiJsonReportObject {
        core: IStiAxisLabelsCoreXF;
        allowApplyStyle: boolean;
        format: string;
        angle: number;
        width: number;
        textBefore: string;
        textAfter: string;
        font: Font;
        antialiasing: boolean;
        placement: StiLabelsPlacement;
        color: Color;
        textAlignment: StiHorAlignment;
        step: number;
        wordWrap: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiAxisLabelsCoreXF: string;
    interface IStiAxisLabelsCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiAxisRange: string;
    interface IStiAxisRange extends ICloneable, IStiJsonReportObject {
        minimum: number;
        maximum: number;
        auto: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiAxisTicks: string;
    interface IStiAxisTicks extends ICloneable, IStiJsonReportObject {
        lengthUnderLabels: number;
        length: number;
        minorLength: number;
        minorCount: number;
        step: number;
        minorVisible: boolean;
        visible: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiAxisTitle: string;
    interface IStiAxisTitle extends ICloneable, IStiJsonReportObject {
        core: IStiAxisTitleCoreXF;
        allowApplyStyle: boolean;
        font: Font;
        text: string;
        color: Color;
        antialiasing: boolean;
        alignment: StringAlignment;
        direction: StiDirection;
        position: StiTitlePosition;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiAxisTitleCoreXF: string;
    interface IStiAxisTitleCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    var IStiXAxis: string;
    interface IStiXAxis extends IStiAxis {
        showEdgeValues: boolean;
        showXAxis: StiShowXAxis;
        dateTimeStep: IStiAxisDateTimeStep;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiXBottomAxis: string;
    interface IStiXBottomAxis extends IStiXAxis {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiXTopAxis: string;
    interface IStiXTopAxis extends IStiXAxis {
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    var IStiYAxis: string;
    interface IStiYAxis extends IStiAxis {
        showYAxis: StiShowYAxis;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiYLeftAxis: string;
    interface IStiYLeftAxis extends IStiYAxis {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiYRightAxis: string;
    interface IStiYRightAxis extends IStiYAxis {
    }
}
declare module Stimulsoft.Report.Chart {
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiChartTitle: string;
    interface IStiChartTitle extends ICloneable, IStiJsonReportObject {
        core: IStiChartTitleCoreXF;
        allowApplyStyle: boolean;
        font: Font;
        text: string;
        brush: StiBrush;
        antialiasing: boolean;
        alignment: StringAlignment;
        dock: StiChartTitleDock;
        spacing: number;
        visible: boolean;
        chart: IStiChart;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    var IStiChartTitleCoreXF: string;
    interface IStiChartTitleCoreXF extends IStiApplyStyle {
        render(context: StiContext, chartTitle: IStiChartTitle, rect: RectangleD): IStiCellGeom;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiChartCondition: string;
    interface IStiChartCondition extends IStiChartFilter {
        color: Color;
    }
}
declare module Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    var IStiChartConditionsCollection: string;
    interface IStiChartConditionsCollection extends ICollection<IStiChartCondition> {
        add(condition: IStiChartCondition): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiConstantLines: string;
    interface IStiConstantLines extends ICloneable, IStiJsonReportObject {
        core: IStiConstantLinesCoreXF;
        allowApplyStyle: boolean;
        antialiasing: boolean;
        position: StiConstantLines_StiTextPosition;
        font: Font;
        text: string;
        titleVisible: boolean;
        orientation: StiConstantLines_StiOrientation;
        lineWidth: number;
        lineStyle: StiPenStyle;
        lineColor: Color;
        showInLegend: boolean;
        showBehind: boolean;
        axisValue: string;
        visible: boolean;
        chart: IStiChart;
    }
}
declare module Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    var IStiConstantLinesCollection: string;
    interface IStiConstantLinesCollection extends ICollection<IStiConstantLines>, IStiApplyStyle {
        add(value: IStiConstantLines): any;
        insert(index: number, value: IStiConstantLines): any;
        getByIndex(index: number): IStiConstantLines;
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    var IStiConstantLinesCoreXF: string;
    interface IStiConstantLinesCoreXF extends IStiApplyStyle {
        render(context: StiContext, geom: IStiCellGeom, rect: RectangleD): any;
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    import StiFilterItem = Stimulsoft.Report.Components.StiFilterItem;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    var IStiChartFilter: string;
    interface IStiChartFilter extends IStiJsonReportObject, ICloneable {
        clone(): any;
        condition: StiFilterCondition;
        dataType: StiFilterDataType;
        item: StiFilterItem;
        value: string;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    var IStiChartFiltersCollection: string;
    interface IStiChartFiltersCollection extends ICollection<IStiChartFilter> {
        add(value: IStiChartFilter): any;
        getByIndex(index: number): IStiChartFilter;
        insert(index: number, value: IStiChartFilter): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiGridLines: string;
    interface IStiGridLines extends ICloneable, IStiJsonReportObject {
        core: IStiGridLinesCoreXF;
        allowApplyStyle: boolean;
        color: Color;
        minorColor: Color;
        style: StiPenStyle;
        minorStyle: StiPenStyle;
        visible: boolean;
        minorVisible: boolean;
        minorCount: number;
        area: IStiArea;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiGridLinesCoreXF: string;
    interface IStiGridLinesCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiGridLinesHor: string;
    interface IStiGridLinesHor extends IStiGridLines {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiGridLinesVert: string;
    interface IStiGridLinesVert extends IStiGridLines {
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiRadarGridLines: string;
    interface IStiRadarGridLines extends ICloneable, IStiJsonReportObject {
        core: IStiRadarGridLinesCoreXF;
        allowApplyStyle: boolean;
        color: Color;
        style: StiPenStyle;
        visible: boolean;
        area: IStiArea;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarGridLinesCoreXF: string;
    interface IStiRadarGridLinesCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarGridLinesHor: string;
    interface IStiRadarGridLinesHor extends IStiRadarGridLines {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarGridLinesVert: string;
    interface IStiRadarGridLinesVert extends IStiRadarGridLines {
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiInterlacing: string;
    interface IStiInterlacing extends ICloneable, IStiJsonReportObject {
        core: IStiInterlacingCoreXF;
        allowApplyStyle: boolean;
        interlacedBrush: StiBrush;
        visible: boolean;
        area: IStiArea;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiInterlacingCoreXF: string;
    interface IStiInterlacingCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiInterlacingHor: string;
    interface IStiInterlacingHor extends IStiInterlacing {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiInterlacingVert: string;
    interface IStiInterlacingVert extends IStiInterlacing {
    }
}
declare module Stimulsoft.Report.Chart {
    import SizeD = Stimulsoft.System.Drawing.Size;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiLegend: string;
    interface IStiLegend extends ICloneable, IStiJsonReportObject {
        core: IStiLegendCoreXF;
        allowApplyStyle: boolean;
        chart: IStiChart;
        hideSeriesWithEmptyTitle: boolean;
        showShadow: boolean;
        borderColor: Color;
        brush: StiBrush;
        titleColor: Color;
        labelsColor: Color;
        direction: StiLegendDirection;
        horAlignment: StiLegendHorAlignment;
        vertAlignment: StiLegendVertAlignment;
        titleFont: Font;
        font: Font;
        visible: boolean;
        markerVisible: boolean;
        markerBorder: boolean;
        markerSize: SizeD;
        markerAlignment: StiMarkerAlignment;
        columns: number;
        horSpacing: number;
        vertSpacing: number;
        size: SizeD;
        title: string;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    var IStiLegendCoreXF: string;
    interface IStiLegendCoreXF extends IStiApplyStyle {
        render(context: StiContext, rect: RectangleD): IStiCellGeom;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    var IStiLegendMarker: string;
    interface IStiLegendMarker {
        draw(context: StiContext, series: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiLineMarker: string;
    interface IStiLineMarker extends IStiMarker {
        step: number;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiMarker: string;
    interface IStiMarker extends ICloneable, IStiJsonReportObject {
        core: IStiMarkerCoreXF;
        showInLegend: boolean;
        visible: boolean;
        brush: StiBrush;
        borderColor: Color;
        size: number;
        angle: number;
        type: StiMarkerType;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    var IStiMarkerCoreXF: string;
    interface IStiMarkerCoreXF {
        draw(context: StiContext, marker: IStiMarker, position: PointD, zoom: number, showShadow: boolean, isMouseOver: boolean, isTooltipMode: boolean, isAnimation: boolean, toolTip: String, tag: Object, interaction: StiInteractionDataGeom): any;
        drawLine(context: StiContext, x1: number, y1: number, x2: number, y2: number, scale: number, brushMarker: StiBrush, penMarker: StiPenGeom, markerType: StiMarkerType, markerStep: number, markerSize: number, angle: number): any;
        drawLines(context: StiContext, points: PointD[], scale: number, brushMarker: Object, penMarker: StiPenGeom, markerType: StiMarkerType, markerStep: number, markerSize: number, angle: number): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiRadarAxis: string;
    interface IStiRadarAxis extends ICloneable, IStiJsonReportObject {
        core: IStiRadarAxisCoreXF;
        allowApplyStyle: boolean;
        area: IStiRadarArea;
        visible: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarAxisCoreXF: string;
    interface IStiRadarAxisCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiRadarAxisLabels: string;
    interface IStiRadarAxisLabels extends ICloneable, IStiJsonReportObject {
        core: IStiRadarAxisLabelsCoreXF;
        rotationLabels: boolean;
        allowApplyStyle: boolean;
        drawBorder: boolean;
        textBefore: string;
        textAfter: string;
        format: string;
        font: Font;
        antialiasing: boolean;
        color: Color;
        borderColor: Color;
        brush: StiBrush;
        width: number;
        wordWrap: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarAxisLabelsCoreXF: string;
    interface IStiRadarAxisLabelsCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiXRadarAxis: string;
    interface IStiXRadarAxis extends IStiRadarAxis {
        xCore: IStiXRadarAxisCoreXF;
        labels: IStiRadarAxisLabels;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    var IStiXRadarAxisCoreXF: string;
    interface IStiXRadarAxisCoreXF {
        renderLabel(context: StiContext, series: IStiSeries, point: PointD, argument: Object, angle: number, colorIndex: number, colorCount: number): IStiCellGeom;
        getLabelRect(context: StiContext, point: PointD, text: string, angle: number): RectangleD;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiYRadarAxis: string;
    interface IStiYRadarAxis extends IStiRadarAxis {
        yCore: IStiYRadarAxisCoreXF;
        labels: IStiAxisLabels;
        ticks: IStiAxisTicks;
        lineStyle: StiPenStyle;
        lineColor: Color;
        lineWidth: number;
        info: IStiAxisInfoXF;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    var IStiYRadarAxisCoreXF: string;
    interface IStiYRadarAxisCoreXF {
        render(context: StiContext, rect: RectangleD): IStiCellGeom;
        ticksMaxLength: number;
        getFontGeom(context: StiContext): StiFontGeom;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        calculateStripPositions(topPosition: number, bottomPosition: number): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiAxisSeriesLabels: string;
    interface IStiAxisSeriesLabels extends IStiSeriesLabels {
        showInPercent: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiCenterAxisLabels: string;
    interface IStiCenterAxisLabels extends IStiAxisSeriesLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiInsideBaseAxisLabels: string;
    interface IStiInsideBaseAxisLabels extends IStiAxisSeriesLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiInsideEndAxisLabels: string;
    interface IStiInsideEndAxisLabels extends IStiCenterAxisLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiLeftAxisLabels: string;
    interface IStiLeftAxisLabels extends IStiCenterAxisLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiOutsideAxisLabels: string;
    interface IStiOutsideAxisLabels extends IStiAxisSeriesLabels {
        lineLength: number;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiOutsideBaseAxisLabels: string;
    interface IStiOutsideBaseAxisLabels extends IStiCenterAxisLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiOutsideEndAxisLabels: string;
    interface IStiOutsideEndAxisLabels extends IStiCenterAxisLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRightAxisLabels: string;
    interface IStiRightAxisLabels extends IStiCenterAxisLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiValueAxisLabels: string;
    interface IStiValueAxisLabels extends IStiCenterAxisLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiCenterFunnelLabels: string;
    interface IStiCenterFunnelLabels extends IStiFunnelSeriesLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFunnelSeriesLabels: string;
    interface IStiFunnelSeriesLabels extends IStiSeriesLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiOutsideLeftFunnelLabels: string;
    interface IStiOutsideLeftFunnelLabels extends IStiCenterFunnelLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiOutsideRightFunnelLabels: string;
    interface IStiOutsideRightFunnelLabels extends IStiCenterFunnelLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiCenterPieLabels: string;
    interface IStiCenterPieLabels extends IStiPieSeriesLabels {
        autoRotate: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiInsideEndPieLabels: string;
    interface IStiInsideEndPieLabels extends IStiCenterPieLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiOutsidePieLabels: string;
    interface IStiOutsidePieLabels extends IStiCenterPieLabels {
        showValue: boolean;
        lineLength: number;
        lineColor: Color;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiPieSeriesLabels: string;
    interface IStiPieSeriesLabels extends IStiSeriesLabels {
        showInPercent: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiTwoColumnsPieLabels: string;
    interface IStiTwoColumnsPieLabels extends IStiOutsidePieLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarSeriesLabels: string;
    interface IStiRadarSeriesLabels extends IStiSeriesLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiTangentRadarLabels: string;
    interface IStiTangentRadarLabels extends IStiRadarSeriesLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiNoneLabels: string;
    interface IStiNoneLabels extends IStiSeriesLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    import SizeD = Stimulsoft.System.Drawing.Size;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiSeriesLabels: string;
    interface IStiSeriesLabels extends ICloneable, IStiJsonReportObject {
        allowApplyStyle: boolean;
        showZeros: boolean;
        showNulls: boolean;
        markerVisible: boolean;
        step: number;
        valueTypeSeparator: string;
        textBefore: string;
        textAfter: string;
        angle: number;
        format: string;
        antialiasing: boolean;
        visible: boolean;
        drawBorder: boolean;
        useSeriesColor: boolean;
        markerAlignment: StiMarkerAlignment;
        valueType: StiSeriesLabelsValueType;
        legendValueType: StiSeriesLabelsValueType;
        markerSize: SizeD;
        labelColor: Color;
        borderColor: Color;
        brush: StiBrush;
        font: Font;
        chart: IStiChart;
        core: IStiSeriesLabelsCoreXF;
        preventIntersection: boolean;
        wordWrap: boolean;
        width: number;
        createNew(): IStiSeriesLabels;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    var IStiSeriesLabelsCoreXF: string;
    interface IStiSeriesLabelsCoreXF extends IStiApplyStyle {
        recalcValue(value: number, signs: number): number;
        getLabelColor(series: IStiSeries, colorIndex: number, colorCount: number): Color;
        getLabelText(series: IStiSeries, value: number, argument: string, tag: string, seriesName: string, useLegendValueType: boolean): string;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiBubbleSeries: string;
    interface IStiBubbleSeries extends IStiScatterSeries {
        weights: number[];
        borderColor: Color;
        brush: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiClusteredBarSeries: string;
    interface IStiClusteredBarSeries extends IStiClusteredColumnSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiAreaSeries: string;
    interface IStiAreaSeries extends IStiLineSeries, IStiAllowApplyBrushNegative {
        topmostLine: boolean;
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiBaseLineSeries: string;
    interface IStiBaseLineSeries extends IStiSeries, IStiAllowApplyColorNegative {
        marker: IStiMarker;
        lineMarker: IStiLineMarker;
        lineColor: Color;
        lineStyle: StiPenStyle;
        lighting: boolean;
        lineWidth: number;
        labelsOffset: number;
        showNulls: boolean;
        lineColorNegative: Color;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiClusteredColumnSeries: string;
    interface IStiClusteredColumnSeries extends IStiSeries, IStiAllowApplyBrushNegative {
        width: number;
        borderColor: Color;
        brush: StiBrush;
        brushNegative: StiBrush;
        showZeros: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiLineSeries: string;
    interface IStiLineSeries extends IStiBaseLineSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiSplineAreaSeries: string;
    interface IStiSplineAreaSeries extends IStiSplineSeries, IStiAllowApplyBrushNegative {
        topmostLine: boolean;
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiSplineSeries: string;
    interface IStiSplineSeries extends IStiBaseLineSeries, IStiAllowApplyColorNegative {
        tension: number;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiSteppedAreaSeries: string;
    interface IStiSteppedAreaSeries extends IStiSteppedLineSeries, IStiAllowApplyBrushNegative {
        topmostLine: boolean;
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiSteppedLineSeries: string;
    interface IStiSteppedLineSeries extends IStiBaseLineSeries, IStiAllowApplyColorNegative {
        pointAtCenter: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiDoughnutSeries: string;
    interface IStiDoughnutSeries extends IStiPieSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiCandlestickSeries: string;
    interface IStiCandlestickSeries extends IStiSeries, IStiFinancialSeries {
        borderColor: Color;
        borderColorNegative: Color;
        borderWidth: number;
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFinancialSeries: string;
    interface IStiFinancialSeries {
        valuesOpen: number[];
        valuesClose: number[];
        valuesHigh: number[];
        valuesLow: number[];
    }
}
declare module Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiStockSeries: string;
    interface IStiStockSeries extends IStiSeries, IStiFinancialSeries, IStiAllowApplyColorNegative {
        lineColor: Color;
        lineStyle: StiPenStyle;
        lineWidth: number;
        lineColorNegative: Color;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedBarSeries: string;
    interface IStiFullStackedBarSeries extends IStiStackedBarSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedAreaSeries: string;
    interface IStiFullStackedAreaSeries extends IStiStackedAreaSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedColumnSeries: string;
    interface IStiFullStackedColumnSeries extends IStiStackedColumnSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedLineSeries: string;
    interface IStiFullStackedLineSeries extends IStiStackedLineSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedSplineAreaSeries: string;
    interface IStiFullStackedSplineAreaSeries extends IStiStackedSplineAreaSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedSplineSeries: string;
    interface IStiFullStackedSplineSeries extends IStiStackedSplineSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiFunnelSeries: string;
    interface IStiFunnelSeries extends IStiSeries {
        showZeros: boolean;
        allowApplyBrush: boolean;
        allowApplyBorderColor: boolean;
        borderColor: Color;
        brush: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFunnelWeightedSlicesSeries: string;
    interface IStiFunnelWeightedSlicesSeries extends IStiFunnelSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiGanttSeries: string;
    interface IStiGanttSeries extends IStiClusteredBarSeries, IStiRangeSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiPictorialSeries: string;
    interface IStiPictorialSeries extends IStiSeries {
        brush: StiBrush;
        icon: StiFontIcons;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiPieSeries: string;
    interface IStiPieSeries extends IStiSeries, IStiAllowApplyBorderColor, IStiAllowApplyBrush {
        startAngle: number;
        borderColor: Color;
        brush: StiBrush;
        lighting: boolean;
        diameter: number;
        distance: number;
        cutPieListValues: number[];
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiRadarAreaSeries: string;
    interface IStiRadarAreaSeries extends IStiRadarLineSeries {
        brush: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiRadarLineSeries: string;
    interface IStiRadarLineSeries extends IStiRadarSeries {
        lineColor: Color;
        lineStyle: StiPenStyle;
        lighting: boolean;
        lineWidth: number;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarPointSeries: string;
    interface IStiRadarPointSeries extends IStiRadarSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarSeries: string;
    interface IStiRadarSeries extends IStiSeries {
        marker: IStiMarker;
        showNulls: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiLineRangeSeries: string;
    interface IStiLineRangeSeries extends IStiLineSeries, IStiRangeSeries, IStiAllowApplyBrushNegative {
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRangeBarSeries: string;
    interface IStiRangeBarSeries extends IStiClusteredColumnSeries, IStiRangeSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRangeSeries: string;
    interface IStiRangeSeries {
        valuesEnd: number[];
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiSplineRangeSeries: string;
    interface IStiSplineRangeSeries extends IStiSplineSeries, IStiRangeSeries {
        brush: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiSteppedRangeSeries: string;
    interface IStiSteppedRangeSeries extends IStiSteppedLineSeries, IStiRangeSeries, IStiAllowApplyBrushNegative {
        brush: StiBrush;
        brushNegative: StiBrush;
        allowApplyBrushNegative: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiScatterLineSeries: string;
    interface IStiScatterLineSeries extends IStiScatterSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiScatterSeries: string;
    interface IStiScatterSeries extends IStiBaseLineSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiScatterSplineSeries: string;
    interface IStiScatterSplineSeries extends IStiScatterLineSeries {
        tension: number;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiStackedBarSeries: string;
    interface IStiStackedBarSeries extends IStiSeries, IStiAllowApplyBrushNegative {
        width: number;
        borderColor: Color;
        brush: StiBrush;
        showZeros: boolean;
        brushNegative: StiBrush;
        allowApplyBrushNegative: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiStackedAreaSeries: string;
    interface IStiStackedAreaSeries extends IStiStackedLineSeries, IStiAllowApplyBrushNegative {
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiStackedBaseLineSeries: string;
    interface IStiStackedBaseLineSeries extends IStiSeries {
        marker: IStiMarker;
        lineMarker: IStiLineMarker;
        lighting: boolean;
        lineColor: Color;
        lineWidth: number;
        lineStyle: StiPenStyle;
        showNulls: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiStackedColumnSeries: string;
    interface IStiStackedColumnSeries extends IStiSeries, IStiAllowApplyBrushNegative {
        width: number;
        borderColor: Color;
        brush: StiBrush;
        showZeros: boolean;
        brushNegative: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiStackedLineSeries: string;
    interface IStiStackedLineSeries extends IStiStackedBaseLineSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiStackedSplineAreaSeries: string;
    interface IStiStackedSplineAreaSeries extends IStiStackedSplineSeries, IStiAllowApplyBrushNegative {
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiStackedSplineSeries: string;
    interface IStiStackedSplineSeries extends IStiStackedBaseLineSeries, IStiAllowApplyColorNegative {
        tension: number;
        lineColorNegative: Color;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiTreemapSeries: string;
    interface IStiTreemapSeries extends IStiSeries {
        borderColor: Color;
        brush: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiAllowApplyBorderColor: string;
    interface IStiAllowApplyBorderColor {
        allowApplyBorderColor: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiAllowApplyBrush: string;
    interface IStiAllowApplyBrush {
        allowApplyBrush: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiAllowApplyBrushNegative: string;
    interface IStiAllowApplyBrushNegative {
        allowApplyBrushNegative: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiAllowApplyColorNegative: string;
    interface IStiAllowApplyColorNegative {
        allowApplyColorNegative: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    var IStiSeries: string;
    interface IStiSeries extends ICloneable, IStiJsonReportObject {
        core: IStiSeriesCoreXF;
        allowApplyStyle: boolean;
        format: string;
        coreTitle: string;
        sortBy: StiSeriesSortType;
        sortDirection: StiSeriesSortDirection;
        showInLegend: boolean;
        showSeriesLabels: StiShowSeriesLabels;
        showShadow: boolean;
        filters: IStiChartFiltersCollection;
        topN: IStiSeriesTopN;
        conditions: IStiChartConditionsCollection;
        yAxis: StiSeriesYAxis;
        seriesLabels: IStiSeriesLabels;
        chart: IStiChart;
        values: number[];
        arguments: Object[];
        toolTips: string[];
        tags: Object[];
        hyperlinks: string[];
        interaction: IStiSeriesInteraction;
        argumentDataColumn: string;
        argument: string;
        title: string;
        filterMode: StiFilterMode;
        processSeriesColors(pointIndex: number, seriesColor: Color): Color;
        processSeriesBrushes(pointIndex: number, seriesBrush: StiBrush): StiBrush;
        getDefaultAreaType(): Stimulsoft.System.Type;
    }
}
declare module Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    var IStiSeriesCollection: string;
    interface IStiSeriesCollection extends ICollection<IStiSeries>, IStiApplyStyle {
        add(value: IStiSeries): any;
        getByIndex(index: number): IStiSeries;
        insert(index: number, value: IStiSeries): any;
        indexOf(value: IStiSeries): number;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiSeriesCoreXF: string;
    interface IStiSeriesCoreXF {
        renderSeries(context: StiContext, rect: RectangleD, geom: IStiCellGeom, seriesArray: IStiSeries[]): any;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Object;
        getSeriesLabels(): IStiAxisSeriesLabels;
        setIsMouseOverSeriesElement(seriesIndex: number, value: boolean): any;
        isDateTimeValues: boolean;
        applyStyle(style: IStiChartStyle, color: Color): any;
        getTag(tagIndex: number): string;
        getIsMouseOverSeriesElement(seriesIndex: number): boolean;
        interaction: IStiSeriesInteraction;
        isDateTimeArguments: boolean;
        isMouseOver: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiStrips: string;
    interface IStiStrips extends ICloneable, IStiJsonReportObject {
        core: IStiStripsCoreXF;
        allowApplyStyle: boolean;
        showBehind: boolean;
        stripBrush: StiBrush;
        antialiasing: boolean;
        font: Font;
        text: string;
        titleVisible: boolean;
        titleColor: Color;
        orientation: StiStrips_StiOrientation;
        showInLegend: boolean;
        maxValue: string;
        minValue: string;
        visible: boolean;
        chart: IStiChart;
    }
}
declare module Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    var IStiStripsCollection: string;
    interface IStiStripsCollection extends ICollection<IStiStrips>, IStiApplyStyle {
        add(value: IStiStrips): any;
        insert(index: number, value: IStiStrips): any;
        getByIndex(index: number): IStiStrips;
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    var IStiStripsCoreXF: string;
    interface IStiStripsCoreXF extends IStiApplyStyle {
        render(context: StiContext, geom: IStiCellGeom, rect: RectangleD): any;
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiChartStyle: string;
    interface IStiChartStyle extends ICloneable, IStiJsonReportObject {
        core: IStiStyleCoreXF;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiCustomStyle: string;
    interface IStiCustomStyle extends IStiChartStyle {
        customCore: IStiCustomStyleCoreXF;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiChartStyle = Stimulsoft.Report.Styles.StiChartStyle;
    var IStiCustomStyleCoreXF: string;
    interface IStiCustomStyleCoreXF extends IStiStyleCoreXF {
        reportStyle: StiChartStyle;
        reportStyleName: string;
        reportChartStyle: Stimulsoft.Report.Styles.StiChartStyle;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    var IStiStyleCoreXF: string;
    interface IStiStyleCoreXF {
        chart: IStiChart;
        chartBrush: StiBrush;
        chartAreaBrush: StiBrush;
        chartAreaBorderColor: Color;
        seriesShowShadow: boolean;
        seriesLighting: boolean;
        seriesLabelsFont: Font;
        seriesLabelsColor: Color;
        seriesLabelsBrush: StiBrush;
        seriesLabelsBorderColor: Color;
        axisLineColor: Color;
        axisLabelsColor: Color;
        axisTitleColor: Color;
        gridLinesHorColor: Color;
        gridLinesVertColor: Color;
        interlacingHorBrush: StiBrush;
        interlacingVertBrush: StiBrush;
        legendBrush: StiBrush;
        legendLabelsColor: Color;
        legendBorderColor: Color;
        legendTitleColor: Color;
        legendShowShadow: boolean;
        legendFont: Font;
        getAreaBrush(color: Color): StiBrush;
        getColumnBrush(color: Color): StiBrush;
        getColumnBorder(color: Color): Color;
        getColors(seriesCount: number): Color[];
        getColorByIndex(index: number, count: number): Color;
        getColorBySeries(series: IStiSeries): Color;
        basicStyleColor: Color;
        markerVisible: boolean;
        styleColors: Color[];
        fillColumn(context: StiContext, rect: RectangleD, brush: StiBrush, interaction: StiInteractionDataGeom): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiChartTable: string;
    interface IStiChartTable extends ICloneable, IStiJsonReportObject {
        core: IStiChartTableCoreXF;
        chart: IStiChart;
        allowApplyStyle: boolean;
        font: Font;
        markerVisible: boolean;
        gridLineColor: Color;
        textColor: Color;
        gridLinesHor: boolean;
        gridLinesVert: boolean;
        gridOutline: boolean;
        visible: boolean;
        format: string;
        header: IStiChartTableHeader;
        dataCells: IStiChartTableDataCells;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    var IStiChartTableCoreXF: string;
    interface IStiChartTableCoreXF extends IStiApplyStyle {
        showTable(): boolean;
        getWidthCellLegend(context: StiContext): number;
        getHeightTable(context: StiContext, widthTable: number): number;
        render(context: StiContext, rect: RectangleD): IStiCellGeom;
    }
}
declare module Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiChartTableDataCells: string;
    interface IStiChartTableDataCells extends ICloneable, IStiJsonReportObject {
        font: Font;
        textColor: Color;
        shrinkFontToFit: boolean;
        shrinkFontToFitMinimumSize: number;
    }
}
declare module Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiChartTableHeader: string;
    interface IStiChartTableHeader extends ICloneable, IStiJsonReportObject {
        brush: StiBrush;
        font: Font;
        textColor: Color;
        wordWrap: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiSeriesTopN: string;
    interface IStiSeriesTopN extends ICloneable, IStiJsonReportObject {
        mode: StiTopNMode;
        count: number;
        showOthers: boolean;
        othersText: string;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiTrendLine: string;
    interface IStiTrendLine extends ICloneable, IStiJsonReportObject {
        core: IStiTrendLineCoreXF;
        lineWidth: number;
        lineStyle: StiPenStyle;
        lineColor: Color;
        showShadow: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    var IStiTrendLineCoreXF: string;
    interface IStiTrendLineCoreXF {
        renderTrendLine(geom: IStiCellGeom, points: PointD[], posY: number): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiTrendLineExponential: string;
    interface IStiTrendLineExponential extends IStiTrendLine {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiTrendLineLinear: string;
    interface IStiTrendLineLinear extends IStiTrendLine {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiTrendLineLogarithmic: string;
    interface IStiTrendLineLogarithmic extends IStiTrendLine {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiTrendLineNone: string;
    interface IStiTrendLineNone extends IStiTrendLine {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiApplyStyle: string;
    interface IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiApplyStyleSeries: string;
    interface IStiApplyStyleSeries {
        applyStyle(style: IStiChartStyle, color: Color): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    var IStiCellGeom: string;
    interface IStiCellGeom {
        drawGeom(context: StiContext): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import IStiComponent = Stimulsoft.Report.Components.IStiComponent;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiFiltersCollection = Stimulsoft.Report.Components.StiFiltersCollection;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import IStiCanGrow = Stimulsoft.Report.Components.IStiCanGrow;
    import IStiCanShrink = Stimulsoft.Report.Components.IStiCanShrink;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiImageRotation = Stimulsoft.Report.Components.StiImageRotation;
    var IStiChart: string;
    interface IStiChart extends IStiComponent, IStiName, IStiCanGrow, IStiCanShrink {
        seriesLabelsConditions: IStiChartConditionsCollection;
        series: IStiSeriesCollection;
        area: IStiArea;
        style: IStiChartStyle;
        seriesLabels: IStiSeriesLabels;
        legend: IStiLegend;
        title: IStiChartTitle;
        table: IStiChartTable;
        strips: IStiStripsCollection;
        constantLines: IStiConstantLinesCollection;
        horSpacing: number;
        vertSpacing: number;
        isDesigning: boolean;
        isAnimation: boolean;
        brush: StiBrush;
        core: IStiChartCoreXF;
        allowApplyStyle: boolean;
        masterComponent: IStiComponent;
        jsonMasterComponentTemp: string;
        dataSourceName: string;
        chartInfo: IStiChartInfo;
        processAtEnd: boolean;
        convertToHInches(value: number): number;
        saveState(stateName: string): any;
        restoreState(stateName: string): any;
        customStyleName: string;
        name: string;
        border: StiBorder;
        filters: StiFiltersCollection;
        filterMode: StiFilterMode;
        filterOn: boolean;
        dataSource: StiDataSource;
        dataRelation: StiDataRelation;
        countData: number;
        businessObject: StiBusinessObject;
        canGrow: boolean;
        canShrink: boolean;
        rotation: StiImageRotation;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    var IStiChartCoreXF: string;
    interface IStiChartCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
        render(context: StiContext, rect: RectangleD, useMargins: boolean): IStiCellGeom;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiText = Stimulsoft.Report.Components.StiText;
    var IStiChartInfo: string;
    interface IStiChartInfo {
        interactiveComps: StiText[];
        storedForProcessAtEndChart: IStiChart;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiGeomInteraction: string;
    interface IStiGeomInteraction {
        invokeClick(options: any): any;
        invokeMouseEnter(options: any): any;
        invokeMouseLeave(options: any): any;
        invokeMouseDown(options: any): any;
        invokeMouseUp(options: any): any;
        invokeDrag(options: any): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiSeriesElement: string;
    interface IStiSeriesElement {
        elementIndex: String;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    var IStiSeriesInteraction: string;
    interface IStiSeriesInteraction extends ICloneable, IStiJsonReportObject {
        drillDownEnabled: boolean;
        allowSeries: boolean;
        allowSeriesElements: boolean;
        loadFromXml(xmlNode: XmlNode): any;
        drillDownPageGuid: string;
        drillDownPage: StiPage;
    }
}
declare module Stimulsoft.Report.Chart {
    class StiTrendLinePropertyOrder {
        lineColor: number;
        lineStyle: number;
        lineWidth: number;
        showShadow: number;
    }
    class StiSeriesLabelsPropertyOrder {
        allowApplyStyle: number;
        angle: number;
        antialiasing: number;
        autoRotate: number;
        conditions: number;
        drawBorder: number;
        borderColor: number;
        brush: number;
        font: number;
        format: number;
        labelColor: number;
        legendValueType: number;
        lineColor: number;
        lineColorNegative: number;
        lineLength: number;
        markerAlignment: number;
        markerSize: number;
        markerVisible: number;
        preventIntersection: number;
        showInPercent: number;
        showNulls: number;
        showValue: number;
        showZeros: number;
        step: number;
        textAfter: number;
        textBefore: number;
        useSeriesColor: number;
        valueType: number;
        valueTypeSeparator: number;
        visible: number;
        width: number;
        wordWrap: number;
    }
    class StiSeriesPropertyOrder {
        allowSeries: number;
        allowSeriesElements: number;
        drillDownEnabled: number;
        drillDownPage: number;
        drillDownReport: number;
        hyperlinkDataColumn: number;
        tagDataColumn: number;
        toolTipDataColumn: number;
        weightDataColumn: number;
        hyperlink: number;
        tag: number;
        toolTip: number;
        weight: number;
        listOfHyperlinks: number;
        listOfTags: number;
        listOfToolTips: number;
        listOfWeights: number;
        valueValueDataColumn: number;
        valueValue: number;
        valueListOfValues: number;
        valueValueDataColumnEnd: number;
        valueValueEnd: number;
        valueListOfValuesEnd: number;
        valueValueDataColumnOpen: number;
        valueValueOpen: number;
        valueListOfValuesOpen: number;
        valueValueDataColumnClose: number;
        valueValueClose: number;
        valueListOfValuesClose: number;
        valueValueDataColumnHigh: number;
        valueValueHigh: number;
        valueListOfValuesHigh: number;
        valueValueDataColumnLow: number;
        valueValueLow: number;
        valueListOfValuesLow: number;
        argumentArgumentDataColumn: number;
        argumentArgument: number;
        argumentListOfArguments: number;
        weightWeightDataColumn: number;
        weightWeight: number;
        weightListOfWeights: number;
        appearanceAllowApplyBorderColor: number;
        appearanceAllowApplyBrush: number;
        appearanceAllowApplyBrushNegative: number;
        appearanceAllowApplyColorNegative: number;
        appearanceDiameter: number;
        appearanceBorderColor: number;
        appearanceBrush: number;
        appearanceBrushNegative: number;
        appearanceLighting: number;
        appearanceShowShadow: number;
        appearanceTopmostLine: number;
        appearanceFunnelSliceMode: number;
        dataConditions: number;
        dataFilters: number;
        dataFilterMode: number;
        dataTopN: number;
        dataFormat: number;
        dataSortBy: number;
        dataSortDirection: number;
        dataAutoSeriesKeyDataColumn: number;
        dataAutoSeriesColorDataColumn: number;
        dataAutoSeriesTitleDataColumn: number;
    }
    enum StiChartTitleDock {
        Top = 0,
        Right = 90,
        Bottom = 180,
        Left = 270,
    }
    enum StiLegendDirection {
        LeftToRight = 0,
        RightToLeft = 1,
        TopToBottom = 2,
        BottomToTop = 3,
    }
    enum StiDirection {
        LeftToRight = 0,
        RightToLeft = 1,
        TopToBottom = 2,
        BottomToTop = 3,
    }
    enum StiLegendHorAlignment {
        LeftOutside = 0,
        Left = 1,
        Center = 2,
        Right = 3,
        RightOutside = 4,
    }
    enum StiLegendVertAlignment {
        TopOutside = 0,
        Top = 1,
        Center = 2,
        Bottom = 3,
        BottomOutside = 4,
    }
    enum StiMarkerAlignment {
        Left = 0,
        Center = 1,
        Right = 2,
    }
    enum StiChartAreaPosition {
        ClusteredColumn = 0,
        StackedColumn = 1,
        FullStackedColumn = 2,
        ClusteredBar = 10,
        StackedBar = 11,
        FullStackedBar = 12,
        Pie = 20,
        Doughnut = 21,
        Line = 30,
        SteppedLine = 31,
        StackedLine = 32,
        FullStackedLine = 33,
        Spline = 40,
        StackedSpline = 41,
        FullStackedSpline = 42,
        Area = 50,
        SteppedArea = 51,
        StackedArea = 52,
        FullStackedArea = 53,
        SplineArea = 60,
        StackedSplineArea = 61,
        FullStackedSplineArea = 62,
        Gantt = 70,
        Scatter = 80,
        Bubble = 81,
        RadarPoint = 82,
        RadarLine = 83,
        RadarArea = 84,
        Range = 90,
        SteppedRange = 91,
        RangeBar = 92,
        SplineRange = 93,
        Funnel = 100,
        Candlestick = 110,
        Stock = 120,
        Treemap = 130,
        Pictorial = 131,
    }
    enum StiChartSeriesOrientation {
        Horizontal = 0,
        Vertical = 1,
    }
    enum StiArrowStyle {
        None = 0,
        Triangle = 1,
        Lines = 2,
        Circle = 3,
        Arc = 4,
        ArcAndCircle = 5,
    }
    enum StiLabelsPlacement {
        None = 0,
        OneLine = 1,
        TwoLines = 2,
    }
    enum StiXAxisDock {
        Top = 0,
        Bottom = 1,
    }
    enum StiYAxisDock {
        Left = 0,
        Right = 1,
    }
    enum StiTitlePosition {
        Inside = 0,
        Outside = 1,
    }
    enum StiSeriesLabelsPosition {
        None = 0,
        InsideEndAxis = 1,
        InsideBaseAxis = 2,
        CenterAxis = 3,
        OutsideEndAxis = 4,
        OutsideBaseAxis = 5,
        OutsideAxis = 6,
        Left = 7,
        Value = 8,
        Right = 9,
        InsideEndPie = 10,
        CenterPie = 11,
        OutsidePie = 12,
        TwoColumnsPie = 13,
        CenterFunnel = 14,
        OutsideRightFunnel = 15,
        OutsideLeftFunnel = 16,
        CenterTreemap = 17,
    }
    enum StiSeriesLabelsType {
        Axis = 1,
        Pie = 2,
        Doughnut = 4,
        Radar = 8,
        Funnel = 10,
        Treemap = 12,
        All = 15,
    }
    enum StiSeriesLabelsValueType {
        Value = 0,
        SeriesTitle = 1,
        Argument = 2,
        Tag = 3,
        Weight = 4,
        ValueArgument = 5,
        ArgumentValue = 6,
        SeriesTitleValue = 7,
        SeriesTitleArgument = 8,
    }
    enum StiMarkerType {
        Rectangle = 0,
        Triangle = 1,
        Circle = 2,
        Star5 = 3,
        Star6 = 4,
        Star7 = 5,
        Star8 = 6,
        Hexagon = 7,
    }
    enum StiSeriesSortType {
        Value = 0,
        Argument = 1,
        None = 2,
    }
    enum StiSeriesSortDirection {
        Ascending = 0,
        Descending = 1,
    }
    enum StiSeriesYAxis {
        LeftYAxis = 0,
        RightYAxis = 1,
    }
    enum StiShowSeriesLabels {
        None = 0,
        FromChart = 1,
        FromSeries = 2,
    }
    enum StiShowYAxis {
        Left = 0,
        Center = 1,
        Both = 2,
    }
    enum StiShowXAxis {
        Bottom = 0,
        Center = 1,
        Both = 2,
    }
    enum StiRadarStyle {
        Polygon = 0,
        Circle = 1,
    }
    enum StiTimeDateStep {
        None = 0,
        Second = 1,
        Minute = 2,
        Hour = 3,
        Day = 4,
        Month = 5,
        Year = 6,
    }
    enum StiTopNMode {
        None = 0,
        Top = 1,
        Bottom = 2,
    }
    enum StiChartStyleId {
        StiStyle01 = 0,
        StiStyle02 = 1,
        StiStyle03 = 2,
        StiStyle04 = 3,
        StiStyle05 = 4,
        StiStyle06 = 5,
        StiStyle07 = 6,
        StiStyle08 = 7,
        StiStyle09 = 8,
        StiStyle10 = 9,
        StiStyle11 = 10,
        StiStyle12 = 11,
        StiStyle13 = 12,
        StiStyle14 = 13,
        StiStyle15 = 14,
        StiStyle16 = 15,
        StiStyle17 = 16,
        StiStyle18 = 17,
        StiStyle19 = 18,
        StiStyle20 = 19,
        StiStyle21 = 20,
        StiStyle22 = 21,
        StiStyle23 = 22,
        StiStyle24 = 23,
        StiStyle25 = 24,
        StiStyle26 = 25,
        StiStyle27 = 26,
        StiStyle28 = 27,
        StiStyle29 = 28,
        StiStyle30 = 29,
    }
    enum StiStrips_StiOrientation {
        Horizontal = 0,
        Vertical = 1,
        HorizontalRight = 2,
    }
    enum StiConstantLines_StiOrientation {
        Horizontal = 0,
        Vertical = 1,
        HorizontalRight = 2,
    }
    enum StiConstantLines_StiTextPosition {
        LeftTop = 0,
        LeftBottom = 1,
        CenterTop = 2,
        CenterBottom = 3,
        RightTop = 4,
        RightBottom = 5,
    }
}
declare module Stimulsoft.Report.CodeDom {
    import StiRichText = Stimulsoft.Report.Components.StiRichText;
    class StiCodeDomExpressionHelper {
        private static parseRtf(str, richText);
        static readString(codeGenerator: StiCodeGenerator, REFpos: any, REFlexem: any, script: string, REFal: any, isRichText: boolean, fullRtf: boolean): void;
        private static readChar(REFpos, REFlexem, script);
        static getLexemSimple(codeGenerator: StiCodeGenerator, script: string, richText: StiRichText): string[];
        static getLexem(script: string): string[];
        private static replaceBackslash(input, isRichText, fullRtf);
    }
}
declare module Stimulsoft.Report.CodeDom {
    class StiCodeGenerator {
        quoteSnippetString(value: string): string;
    }
}
declare module Stimulsoft.Report.Components {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Font = Stimulsoft.System.Drawing.Font;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    class StiComponentDivider {
        static breakText(g: Graphics, rect: RectangleD, REFtext: any, font: Font, textOptions: StiTextOptions, textQuality: StiTextQuality, allowHtmlTags: boolean, textComp: StiText): string;
        static breakContainer(maxAllowedHeight: number, renderedContainer: StiContainer): StiContainer;
        static breakContainerV2(maxAllowedHeight: number, renderedContainer: StiContainer): StiContainer;
        private static getDivideLine(container, divideLine);
        private static searchDivideLine(container, divideLine, maxAllowedHeight, REFbreakCounter);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiContainer extends StiComponent implements IStiBorder, IStiBrush, IStiBreakable, IStiIgnoryStyle, IStiJsonReportObject {
        private static ImplementsStiContainer;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        parseContainerFromXml(xmlNode: XmlNode): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        private static propertyCanBreak;
        canBreak: boolean;
        break(dividedComponent: StiComponent, devideFactor: number, REFdivideLine: any): boolean;
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean, convertComponents?: boolean): void;
        private _border;
        border: StiBorder;
        private _brush;
        brush: StiBrush;
        getActualSize(isFirstPass?: boolean, REFneedSecondPass?: any): SizeD;
        private _containerInfo;
        readonly containerInfo: StiContainerInfo;
        readonly priority: number;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly componentType: StiComponentType;
        parentComponentIsBand: boolean;
        parentComponentIsCrossBand: boolean;
        private _collapsedValue;
        collapsedValue: Object;
        private _collapsingIndex;
        collapsingIndex: number;
        private _collapsingTreePath;
        collapsingTreePath: string;
        readonly hasSelected: boolean;
        readonly defaultClientRectangle: RectangleD;
        private _components;
        components: StiComponentsCollection;
        protected static propertyBlocked: string;
        blocked: boolean;
        setParentStylesToChilds(style?: Stimulsoft.Report.Styles.StiBaseStyle): void;
        offsetLocation(offsetX: number, offsetY: number): void;
        changePosition(delta: RectangleD): void;
        normalize(): void;
        sortByPriority(): void;
        bringToFront(): void;
        sendToBack(): void;
        moveForward(): void;
        moveBackward(): void;
        alignTo(aligning: StiAligning): void;
        private getContainerInRectPrivate(rect, component);
        getContainerInRect(rect: RectangleD, component: StiComponent): StiContainer;
        private getSizesTable(component);
        private getNodeSize(hash, component, REFbaseRect);
        private getContainerInRect2Private(rect, component, hash);
        getContainerInRect2(rect: RectangleD, component: StiComponent, hash: Hashtable): StiContainer;
        private getIncorrect2(onlySelect, hash?);
        correct2(onlySelect: boolean): void;
        getIncorrect(onlySelect?: boolean): StiComponentsCollection;
        correct(onlySelect?: boolean): void;
        checkLargeHeight(needFullCalculation?: boolean): void;
        resetSelection(): void;
        getSelectedComponents(): StiComponentsCollection;
        getSelectedComponents2(REFcomps: any): void;
        getSelectedRectangle(): RectangleD;
        makeHorizontalSpacingEqual(): void;
        makeVerticalSpacingEqual(): void;
        makeSameSize(size: SizeD): void;
        makeSameWidth(width: number): void;
        makeSameHeight(height: number): void;
        setCenterHorizontally(): void;
        setCenterVertically(): void;
        selectAll(): void;
        containerToPage(value: PointD | RectangleD): any;
        private containerToPageRectangle(rect);
        private containerToPagePoint(point);
        pageToContainer(value: PointD | RectangleD): any;
        getComponents(): StiComponentsCollection;
        getComponents2(REFcomps: any): void;
        getComponentsList(): Array<StiComponent>;
        moveComponentsToPage(): void;
        constructor(rect?: RectangleD, isSuper?: boolean);
        protected construct(rect?: RectangleD): void;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBand extends StiContainer implements IStiResetPageNumber, IStiJsonReportObject, IStiCanGrow, IStiConditions {
        private static ImplementsStiBand;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        canContainIn(component: StiComponent): boolean;
        readonly componentType: StiComponentType;
        protected getComponentType(): StiComponentType;
        clone(cloneProperties: boolean, cloneComponents: boolean): StiBand;
        private _resetPageNumber;
        resetPageNumber: boolean;
        private _bandInfo;
        readonly bandInfo: StiBandInfo;
        printable: boolean;
        getDockStyle(): StiDockStyle;
        setDockStyle(value: StiDockStyle): void;
        readonly isAutomaticDock: boolean;
        minHeight: number;
        getMinHeight(): number;
        setMinHeight(value: number): void;
        maxHeight: number;
        getMaxHeight(): number;
        setMaxHeight(value: number): void;
        readonly defaultClientRectangle: RectangleD;
        getDisplayRectangle(): RectangleD;
        setDisplayRectangle(value: RectangleD): void;
        setDirectDisplayRectangle(rect: RectangleD): void;
        selectRectangle: RectangleD;
        readonly nestedLevel: number;
        private _rectangleMoveComponent;
        rectangleMoveComponent: RectangleD;
        headerStartColor: Color;
        headerEndColor: Color;
        getHeaderText(): string;
        readonly headerSize: number;
        readonly footerSize: number;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDynamicBand extends StiBand implements IStiPageBreak, IStiBreakable, IStiPrintAtBottom, IStiJsonReportObject {
        private _implementsStiDynamicBand;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _printAtBottom;
        printAtBottom: boolean;
        break(dividedComponent: StiComponent, devideFactor: number, divLine: number): boolean;
        private _newPageBefore;
        newPageBefore: boolean;
        private _newPageAfter;
        newPageAfter: boolean;
        private _newColumnBefore;
        newColumnBefore: boolean;
        private _newColumnAfter;
        newColumnAfter: boolean;
        private _skipFirst;
        skipFirst: boolean;
        private _breakIfLessThan;
        breakIfLessThan: number;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiChildBand extends StiDynamicBand implements IStiKeepChildTogether, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _keepChildTogether;
        keepChildTogether: boolean;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        protected getComponentType(): StiComponentType;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly priority: number;
        private _printIfParentDisabled;
        printIfParentDisabled: boolean;
        createNew(): StiComponent;
        getMaster(): StiBand;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import EventArgs = Stimulsoft.System.EventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiFooterBand extends StiDynamicBand implements IStiPrintOnAllPages, IStiPrintIfEmpty, IStiKeepFooterTogether, IStiPrintOnEvenOddPages, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _keepFooterTogether;
        keepFooterTogether: boolean;
        clone(cloneProperties: boolean, cloneComponents: boolean): StiFooterBand;
        private _startNewPage;
        startNewPage: boolean;
        startNewPageIfLessThan: number;
        private _printIfEmpty;
        printIfEmpty: boolean;
        private _printOnEvenOddPages;
        printOnEvenOddPages: StiPrintOnEvenOddPagesType;
        private _printOnAllPages;
        printOnAllPages: boolean;
        private _footerBandInfo;
        readonly footerBandInfo: StiFooterBandInfo;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly priority: number;
        protected getComponentType(): StiComponentType;
        private static eventMoveFooterToBottom;
        protected onMoveFooterToBottom(e: EventArgs): void;
        invokeMoveFooterToBottom(): void;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiColumnFooterBand extends StiFooterBand implements IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly priority: number;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHeaderBand extends StiDynamicBand implements IStiPrintIfEmpty, IStiPrintOnAllPages, IStiPrintOnEvenOddPages, IStiKeepHeaderTogether, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean, cloneComponents: boolean): StiHeaderBand;
        private _keepHeaderTogether;
        keepHeaderTogether: boolean;
        private _startNewPage;
        startNewPage: boolean;
        startNewPageIfLessThan: number;
        private _printIfEmpty;
        printIfEmpty: boolean;
        private _printOnAllPages;
        printOnAllPages: boolean;
        private _printOnEvenOddPages;
        printOnEvenOddPages: StiPrintOnEvenOddPagesType;
        private _headerBandInfo;
        readonly headerBandInfo: StiHeaderBandInfo;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly priority: number;
        protected getComponentType(): StiComponentType;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiColumnHeaderBand extends StiHeaderBand {
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiBusinessObjectsCollection extends CollectionBase<StiBusinessObject> implements IStiJsonReportObject, ICloneable, IComparer<Object> {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private directionFactor;
        compare(x: Object, y: Object): number;
        readonly toList: Array<StiBusinessObject>;
        protected onSet(index: number, oldValue: Object, newValue: Object): void;
        protected onInsert(index: number, value: Object): void;
        add(source: StiBusinessObject): void;
        addRange(sources: StiBusinessObject[] | StiBusinessObjectsCollection): void;
        contains(source: StiBusinessObject): boolean;
        indexOf(source: StiBusinessObject): number;
        insert(index: number, source: StiBusinessObject): void;
        protected onClear(): void;
        remove(source: StiBusinessObject): void;
        getByIndex(index: number): StiBusinessObject;
        setByIndex(index: number, data: StiBusinessObject): void;
        _cachedBusinessObjects: Hashtable;
        readonly cachedBusinessObjects: Hashtable;
        getByName(name: string): StiBusinessObject;
        setByName(name: string, value: StiBusinessObject): void;
        clone(): Object;
        sort(order?: StiSortOrder, sortColumns?: boolean): void;
        connect(): void;
        disconnect(): void;
        dictionary: StiDictionary;
        parentBusinessObject: StiBusinessObject;
        constructor(dictionary: StiDictionary, parentBusinessObject: StiBusinessObject);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    import StiBusinessObjectsCollection = Stimulsoft.Report.Dictionary.StiBusinessObjectsCollection;
    class StiBusinessObjectHelper {
        static getElementType(arrayType: Type): Type;
        private static getElement(value);
        static getAlias(valueProp: string): string;
        static isAllowUseProperty(valueProp: string): boolean;
        private static getType(type);
        private static getDataColumn(name, alias, type);
        private static getDataColumn2(dataColumn);
        private static getColumnsFromObject(value);
        private static getColumnsFromClass(value);
        static getColumnsFromData(data: Object, includeChildDataSources?: boolean): StiDataColumnsCollection;
        static isDataColumn(type: Type): boolean;
        static getBusinessObjectFromGuid(report: StiReport, guid: string): StiBusinessObject;
        static getBusinessObjectsFromReport(data: StiBusinessObjectsCollection | StiReport): Array<StiBusinessObject>;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetCollapsedEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiEndRenderEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiRenderingEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiBeginRenderEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Components {
    import StiGetCollapsedEvent = Stimulsoft.Report.Events.StiGetCollapsedEvent;
    import StiEndRenderEvent = Stimulsoft.Report.Events.StiEndRenderEvent;
    import StiRenderingEvent = Stimulsoft.Report.Events.StiRenderingEvent;
    import StiBeginRenderEvent = Stimulsoft.Report.Events.StiBeginRenderEvent;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiEnumerator = Stimulsoft.Report.Dictionary.IStiEnumerator;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDataBand extends StiDynamicBand implements IStiDataSource, IStiEnumerator, IStiMasterComponent, IStiDataRelation, IStiOddEvenStyles, IStiSort, IStiFilter, IStiPrintOnAllPages, IStiPrintIfDetailEmpty, IStiKeepDetailsTogether, IStiResetPageNumber, IStiRenderMaster, IStiBusinessObject, IStiJsonReportObject {
        private static ImplementsStiDataBand;
        implements(): string[];
        jsonMasterComponentTemp: string;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        static loadXmlSort(xmlNode: XmlNode): string[];
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        private _masterComponent;
        masterComponent: StiComponent;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        keepDetailsTogether: boolean;
        private _keepDetails;
        keepDetails: StiKeepDetails;
        private _sort;
        sort: string[];
        clone(cloneProperties: boolean, cloneComponents: boolean): StiBand;
        private _printOnAllPages;
        printOnAllPages: boolean;
        private _printIfDetailEmpty;
        printIfDetailEmpty: boolean;
        readonly isDataSourceEmpty: boolean;
        readonly dataSource: StiDataSource;
        private _dataSourceName;
        dataSourceName: string;
        readonly isBusinessObjectEmpty: boolean;
        readonly businessObject: StiBusinessObject;
        private _businessObjectGuid;
        businessObjectGuid: string;
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        isEofValue: boolean;
        isEof: boolean;
        isBofValue: boolean;
        isBof: boolean;
        readonly isEmpty: boolean;
        positionValue: number;
        position: number;
        readonly count: number;
        readonly dataRelation: StiDataRelation;
        private _dataRelationName;
        dataRelationName: string;
        private _filterMode;
        filterMode: StiFilterMode;
        private _filterEngine;
        filterEngine: StiFilterEngine;
        private _filterMethodHandler;
        filterMethodHandler: Function;
        private _filters;
        filters: StiFiltersCollection;
        filter: string;
        private _filterOn;
        filterOn: boolean;
        static propertyEvenStyle: string;
        evenStyle: string;
        static propertyOddStyle: string;
        oddStyle: string;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        getHeaderText(): string;
        doBookmark(): void;
        invokeGroupRendering(): void;
        private _dataBandInfo;
        readonly dataBandInfo: StiDataBandInfo;
        render(): StiComponent;
        renderMaster(): void;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly priority: number;
        protected getComponentType(): StiComponentType;
        private static eventBeginRender;
        protected onBeginRender(): void;
        invokeBeginRender(): void;
        beginRenderEvent: StiBeginRenderEvent;
        private static eventRendering;
        protected onRendering(): void;
        invokeRendering(): void;
        renderingEvent: StiRenderingEvent;
        private static eventEndRender;
        protected onEndRender(): void;
        invokeEndRender(): void;
        endRenderEvent: StiEndRenderEvent;
        private static eventGetCollapsed;
        protected onGetCollapsed(e: StiValueEventArgs): void;
        invokeGetCollapsed(e: StiValueEventArgs): void;
        getCollapsedEvent: StiGetCollapsedEvent;
        private _collapsed;
        collapsed: string;
        private _rightToLeft;
        rightToLeft: boolean;
        getRightToLeft(): boolean;
        setRightToLeft(value: boolean): void;
        getColumnWidth(): number;
        private _columnGaps;
        columnGaps: number;
        private _columnWidth;
        columnWidth: number;
        private _columns;
        columns: number;
        private _minRowsInColumn;
        minRowsInColumn: number;
        private _columnDirection;
        columnDirection: StiColumnDirection;
        private _lineThrough;
        lineThrough: number;
        private _line;
        line: number;
        private _selectedLine;
        selectedLine: number;
        private _resetDataSource;
        resetDataSource: boolean;
        private _calcInvisible;
        calcInvisible: boolean;
        private _countData;
        countData: number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiEndRenderEvent = Stimulsoft.Report.Events.StiEndRenderEvent;
    import StiRenderingEvent = Stimulsoft.Report.Events.StiRenderingEvent;
    import StiBeginRenderEvent = Stimulsoft.Report.Events.StiBeginRenderEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEmptyBand extends StiBand implements IStiOddEvenStyles, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        getHeaderText(): string;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly priority: number;
        evenStyle: string;
        oddStyle: string;
        private static eventBeginRender;
        protected onBeginRender(e: EventArgs): void;
        invokeBeginRender(): void;
        beginRenderEvent: StiBeginRenderEvent;
        private static eventRendering;
        protected onRendering(e: EventArgs): void;
        invokeRendering(): void;
        renderingEvent: StiRenderingEvent;
        private static eventEndRender;
        protected onEndRender(e: EventArgs): void;
        invokeEndRender(): void;
        endRenderEvent: StiEndRenderEvent;
        createNew(): StiComponent;
        private _sizeMode;
        sizeMode: StiEmptySizeMode;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiGroupFooterBand extends StiDynamicBand implements IStiKeepGroupFooterTogether, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean, cloneComponents: boolean): StiGroupFooterBand;
        private _keepGroupFooterTogether;
        keepGroupFooterTogether: boolean;
        private _groupFooterBandInfo;
        readonly groupFooterBandInfo: StiGroupFooterBandInfo;
        readonly line: number;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        protected getComponentType(): StiComponentType;
        readonly priority: number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetSummaryExpressionEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetGroupConditionEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiGetExcelValueEventHandler: EventHandler;
    class StiGetExcelValueEventArgs extends EventArgs {
        value: string;
        storeToPrinted: boolean;
    }
}
declare module Stimulsoft.Report.Components.TextFormats {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiService = Stimulsoft.Base.Services.StiService;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiFormatService extends StiService implements IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        static loadFormatFromXml(xmlNode: XmlNode): StiFormatService;
        static loadFromJsonObjectInternal(jObject: StiJson): StiFormatService;
        readonly position: Number;
        readonly sample: Object;
        readonly nativeFormatString: string;
        readonly isFormatStringFromVariable: boolean;
        private _stringFormat;
        stringFormat: string;
        format(arg: any): string;
        format2(format: string, arg: any): string;
    }
}
declare module Stimulsoft.Report.Components.TextFormats {
    class StiCustomFormatService extends StiFormatService {
        readonly sample: Object;
        constructor(stringFormat?: string);
    }
}
declare module Stimulsoft.Report.Components.TextFormats {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiTimeFormatService extends StiFormatService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly sample: Object;
        format(arg: any): string;
        format2(format: string, arg: any): string;
        constructor(stringFormat?: string);
    }
}
declare module Stimulsoft.Report.Components.TextFormats {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDateFormatService extends StiFormatService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly sample: Object;
        format(arg: any): string;
        format2(format: string, arg: any): string;
        private _nullDisplay;
        nullDisplay: string;
        constructor(stringFormat?: string, nullDisplay?: string);
    }
}
declare module Stimulsoft.Report.Components.TextFormats {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import NumberFormatInfo = Stimulsoft.System.Globalization.NumberFormatInfo;
    import StiTextFormatState = Stimulsoft.Report.Components.StiTextFormatState;
    class StiNumberFormatService extends StiFormatService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        private bits;
        nullDisplay: string;
        negativePattern: number;
        decimalSeparator: string;
        decimalDigits: number;
        groupSeparator: string;
        groupSize: number;
        useGroupSeparator: boolean;
        useLocalSetting: boolean;
        readonly sample: Object;
        readonly nativeFormatString: string;
        stiEquals(obj: Object): boolean;
        state: StiTextFormatState;
        fillLocalSetting(format: NumberFormatInfo): void;
        format(arg: any): string;
        format2(format: string, arg: any): string;
        formatStr(format: NumberFormatInfo, arg: Object): string;
        constructor(negativePattern?: number, decimalPlaces?: number, decimalSeparator?: string, decimalDigits?: number, groupSeparator?: string, groupSize?: number, useGroupSeparator?: boolean, useLocalSetting?: boolean, nullDisplay?: string, state?: StiTextFormatState);
    }
}
declare module Stimulsoft.Report.Components.TextFormats {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import NumberFormatInfo = Stimulsoft.System.Globalization.NumberFormatInfo;
    class StiCurrencyFormatService extends StiNumberFormatService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _positivePattern;
        positivePattern: number;
        private _symbol;
        symbol: string;
        readonly nativeFormatString: string;
        readonly sample: Object;
        stiEquals(obj: Object): boolean;
        format(arg: any): string;
        format2(format: string, arg: any): string;
        formatStr(format: NumberFormatInfo, arg: Object): string;
        constructor(positivePattern?: number, negativePattern?: number, decimalPlaces?: number, decimalSeparator?: string, decimalDigits?: number, groupSeparator?: string, groupSize?: number, symbol?: string, useGroupSeparator?: boolean, useLocalSetting?: boolean, nullDisplay?: string, state?: StiTextFormatState);
    }
}
declare module Stimulsoft.Report.Components.TextFormats {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import NumberFormatInfo = Stimulsoft.System.Globalization.NumberFormatInfo;
    class StiPercentageFormatService extends StiCurrencyFormatService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        format(arg: any): string;
        format2(format: string, arg: any): string;
        formatStr(format: NumberFormatInfo, arg: Object): string;
        constructor(positivePattern?: number, negativePattern?: number, decimalPlaces?: number, decimalSeparator?: string, decimalDigits?: number, groupSeparator?: string, groupSize?: number, symbol?: string, useGroupSeparator?: boolean, useLocalSetting?: boolean, nullDisplay?: string, state?: StiTextFormatState);
    }
}
declare module Stimulsoft.Report.Components.TextFormats {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiGeneralFormatService extends StiFormatService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly sample: string;
        stiEquals(obj: Object): boolean;
        static default: StiGeneralFormatService;
        constructor();
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetValueEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiGetValueEventHandler: EventHandler;
    class StiGetValueEventArgs extends EventArgs {
        value: string;
        storeToPrinted: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiEditable: string;
    interface IStiEditable {
        editable: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    var IStiText: string;
    interface IStiText {
        text: string;
        textValue: string;
        setText(getValue: Object): any;
        linesOfUnderline: StiPenStyle;
        hideZeros: boolean;
        processingDuplicates: StiProcessingDuplicatesType;
        onlyText: boolean;
        maxNumberOfLines: number;
        getTextInternal(): string;
        setTextInternal(value: string): any;
    }
}
declare module Stimulsoft.Report.Components {
    import StiGetValueEvent = Stimulsoft.Report.Events.StiGetValueEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiEditable = Stimulsoft.Report.Components.IStiEditable;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiSimpleText extends StiComponent implements IStiText, IStiEditable {
        private static ImplementsStiSimpleText;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        protected static propertyGlobalizedName: string;
        globalizedName: string;
        clone(cloneProperties: boolean): StiSimpleText;
        memberwiseClone(): StiSimpleText;
        getTextWithoutZero(text: string): string;
        setText(getValue?: Object, value?: string): void;
        private setTextTo(comp, runtime, getValue, value);
        private _linesOfUnderline;
        linesOfUnderline: StiPenStyle;
        linesOfUnderlining: boolean;
        private _hideZeros;
        hideZeros: boolean;
        mergeDuplicates: boolean;
        private static propertyProcessingDuplicates;
        processingDuplicates: StiProcessingDuplicatesType;
        private static propertyMaxNumberOfLines;
        maxNumberOfLines: number;
        processText(text: string): string;
        private static propertyOnlyText;
        onlyText: boolean;
        private _editable;
        editable: boolean;
        processAtEnd: boolean;
        protected static propertyProcessAt: string;
        processAt: StiProcessAt;
        invokeRenderTo(textBox: StiSimpleText): void;
        private _text;
        text: string;
        getTextInternal(): string;
        setTextInternal(value: string): void;
        private _textValue;
        textValue: string;
        private static eventGetValue;
        protected onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiComponent, e: StiGetValueEventArgs): void;
        checkDuplicates(sender: StiComponent, e: StiGetValueEventArgs): void;
        getValueEvent: StiGetValueEvent;
        private static eventTextProcess;
        protected onTextProcess(e: StiValueEventArgs): void;
        invokeTextProcess(sender: StiComponent, e: StiValueEventArgs): void;
        private applyConditionsAssignExpression(sender, conditions);
        _totalValueHelp: string;
        totalValueHelp: string;
        constructor(rect?: RectangleD, isSuper?: boolean);
        protected construct(): void;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetExcelValueEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Components {
    import Image = Stimulsoft.System.Drawing.Image;
    import StiGetExcelValueEvent = Stimulsoft.Report.Events.StiGetExcelValueEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiEditable = Stimulsoft.Report.Components.IStiEditable;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    import StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiGetExcelValueEventArgs = Stimulsoft.Report.Events.StiGetExcelValueEventArgs;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiText extends StiSimpleText implements IStiTextOptions, IStiAutoWidth, IStiTextHorAlignment, IStiVertAlignment, IStiBorder, IStiFont, IStiBrush, IStiTextBrush, IStiBreakable, IStiGlobalizationProvider, IStiEditable {
        private static ImplementsStiText;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        parseTextFromXml(xmlNode: XmlNode): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        private _indicator;
        indicator: StiIndicator;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        private static propertyCanBreak;
        canBreak: boolean;
        break(dividedComponent: StiComponent, devideFactor: number, REFdivideLine: any): boolean;
        private static propertyAutoWidth;
        autoWidth: boolean;
        protected static propertyRenderTo: string;
        renderTo: string;
        invokeRenderTo(textFrom: StiSimpleText): void;
        private getVisibleTextForRenderTo(rect, REFtext, checkedText);
        private _horAlignment;
        horAlignment: StiTextHorAlignment;
        private _vertAlignment;
        vertAlignment: StiVertAlignment;
        private _font;
        font: Font;
        private _border;
        border: StiBorder;
        private _brush;
        brush: StiBrush;
        private _textBrush;
        textBrush: StiBrush;
        private _textFormat;
        textFormat: StiFormatService;
        private _format;
        format: string;
        private _textOptions;
        textOptions: StiTextOptions;
        clone(cloneProperties: boolean): StiText;
        memberwiseClone(): StiText;
        convertTextMargins(rect: RectangleD, convert: boolean): RectangleD;
        convertTextBorders(rect: RectangleD, convert: boolean): RectangleD;
        getTextForPaint(): string;
        getActualSize(): SizeD;
        prepare(): void;
        private _excelDataValue;
        excelDataValue: string;
        excelValue: string;
        invokeEvents(): void;
        private static eventGetExcelValue;
        protected onGetExcelValue(e: StiGetExcelValueEventArgs): void;
        invokeGetExcelValue(sender: StiComponent, e: StiGetExcelValueEventArgs): void;
        getExcelValueEvent: StiGetExcelValueEvent;
        protected static propertyNullValue: string;
        nullValue: string;
        protected static propertyType: string;
        type: StiSystemTextType;
        wordWrap: boolean;
        rightToLeft: boolean;
        trimming: StringTrimming;
        angle: number;
        private static propertyExportAsImage;
        exportAsImage: boolean;
        private static propertyTextQuality;
        textQuality: StiTextQuality;
        private static propertyAllowHtmlTags;
        allowHtmlTags: boolean;
        private static propertyMargins;
        margins: StiMargins;
        private static propertyShrinkFontToFit;
        shrinkFontToFit: boolean;
        private static propertyShrinkFontToFitMinimumSize;
        shrinkFontToFitMinimumSize: number;
        createNew(): StiComponent;
        checkAllowHtmlTags(): boolean;
        getActualFont(text: string, minFontSize?: number): Font;
        constructor(rect?: RectangleD, isSuper?: boolean);
        protected construct(): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import Type = Stimulsoft.System.Type;
    class StiFunctions {
        private static functionsToCompile;
        private static functionsToCompileLower;
        private static functions;
        private static functionsLower;
        static jsFunctions: Hashtable;
        static removeFunction(functionName: string): void;
        static getFunctionsList(functionName: string): Array<StiFunction>;
        static getFunctionsGrouppedInCategories(): Hashtable;
        static getFunctions(categoryOrIsCompile: string | boolean): Array<StiFunction>;
        static getFunctionsEx(report: StiReport, functionName: string, isCompile: boolean): StiFunction[];
        static getCategories(): Array<string>;
        static getAssebliesOfFunctions(): string[];
        static addFunction(category: string, groupFunctionName: string, functionName: string, description: string, typeOfFunction: string, returnType: Type, returnDescription?: string, argumentTypes?: Type[], argumentNames?: string[], argumentDescriptions?: string[], jsFunction?: Function): StiFunction;
        static addJsFunction(functionName: string, jsFunction: Function): void;
        static StiFunctions(): void;
    }
}
declare module Stimulsoft.Report {
    /** Enum provide variants of nested factor. */
    enum StiNestedFactor {
        High = 0,
        Normal = 1,
        Low = 2,
    }
    enum StiFontIcons {
        Latin4 = 0,
        Latin3 = 1,
        Latin2 = 2,
        Latin1 = 3,
        QuarterFull = 4,
        QuarterThreeFourth = 5,
        QuarterHalf = 6,
        QuarterQuarter = 7,
        QuarterNone = 8,
        Rating4 = 9,
        Rating3 = 10,
        Rating2 = 11,
        Rating1 = 12,
        Rating0 = 13,
        Square0 = 14,
        Square1 = 15,
        Square2 = 16,
        Square3 = 17,
        Square4 = 18,
        StarFull = 19,
        StarThreeFourth = 20,
        StarHalf = 21,
        StarQuarter = 22,
        StarNone = 23,
        ArrowDown = 24,
        ArrowRight = 25,
        ArrowRightDown = 26,
        ArrowRightUp = 27,
        ArrowUp = 28,
        Check = 29,
        Circle = 30,
        CircleCheck = 31,
        CircleCross = 32,
        CircleExclamation = 33,
        Cross = 34,
        Rhomb = 35,
        Exclamation = 36,
        Flag = 37,
        Minus = 38,
        Triangle = 39,
        TriangleDown = 40,
        TriangleUp = 41,
        Home = 42,
        Cart = 43,
        Phone = 44,
        Mobile = 45,
        Mug = 46,
        Airplane = 47,
        Man = 48,
        Woman = 49,
        UserTie = 50,
        Truck = 51,
        Earth = 52,
        ManWoman = 53,
        Appleinc = 54,
        Android = 55,
        Windows8 = 56,
    }
    enum StiResizeReportOptions {
        ProcessAllPages = 1,
        RebuildReport = 2,
        RescaleContent = 4,
        PageOrientationChanged = 8,
        ShowProgressOnRebuildReport = 16,
        AllowPageMarginsRescaling = 32,
    }
    enum StiCalculationMode {
        Compilation = 0,
        Interpretation = 1,
    }
    enum StiReportLanguageType {
        CSharp = 0,
        VB = 1,
        JS = 2,
    }
    enum StiReportUnitType {
        Centimeters = 0,
        HundredthsOfInch = 1,
        Inches = 2,
        Millimeters = 3,
    }
    enum StiGridMode {
        Lines = 0,
        Dots = 1,
    }
    enum StiReportPass {
        None = 0,
        First = 1,
        Second = 2,
    }
    enum StiNumberOfPass {
        SinglePass = 0,
        DoublePass = 1,
    }
    enum StiExportFormat {
        None = 0,
        Pdf = 1,
        Xps = 2,
        HtmlTable = 3,
        HtmlSpan = 4,
        HtmlDiv = 5,
        Rtf = 6,
        RtfTable = 7,
        RtfFrame = 8,
        RtfWinWord = 9,
        RtfTabbedText = 10,
        Text = 11,
        Excel = 12,
        ExcelXml = 13,
        Excel2007 = 14,
        Word2007 = 15,
        Xml = 16,
        Csv = 17,
        Dif = 18,
        Sylk = 19,
        Image = 20,
        ImageGif = 21,
        ImageBmp = 22,
        ImagePng = 23,
        ImageTiff = 24,
        ImageJpeg = 25,
        ImagePcx = 26,
        ImageEmf = 27,
        ImageSvg = 28,
        ImageSvgz = 29,
        Mht = 30,
        Dbf = 31,
        Html = 32,
        Ods = 33,
        Odt = 34,
        Ppt2007 = 35,
        Html5 = 36,
        Data = 37,
        Document = 1000,
    }
    enum StiReportCacheMode {
        Off = 0,
        On = 1,
        Auto = 2,
    }
    enum StiReportResourceType {
        Bitmap = 0,
        Metafile = 1,
        Report = 2,
    }
    enum StiRangeType {
        All = 1,
        CurrentPage = 2,
        Pages = 3,
    }
    enum StiHtmlType {
        Html = 1,
        Html5 = 2,
        Mht = 3,
    }
    enum ImageFormat {
        Bmp = 0,
        Emf = 1,
        Exif = 2,
        Gif = 3,
        Guid = 4,
        Icon = 5,
        Jpeg = 6,
        MemoryBmp = 7,
        Png = 8,
        Tiff = 9,
        Wmf = 10,
    }
    enum StiArabicDigitsType {
        /** A value for the standard arabic digits. */
        Standard = 0,
        /** A value for the Eastern arabic digits. */
        Eastern = 1,
    }
    enum StiBrushType {
        Solid = 0,
        Glare = 1,
        Gradient0 = 2,
        Gradient90 = 3,
        Gradient180 = 4,
        Gradient270 = 5,
        Gradient45 = 6,
    }
    enum StiComponentId {
        StiComponent = 0,
        StiBarCode = 1,
        StiButtonControl = 2,
        StiChart = 3,
        StiChartCommon = 4,
        StiCheckBox = 5,
        StiCheckBoxControl = 6,
        StiCheckedListBoxControl = 7,
        StiChildBand = 8,
        StiClone = 9,
        StiColumnFooterBand = 10,
        StiColumnHeaderBand = 11,
        StiComboBoxControl = 12,
        StiContainer = 13,
        StiContourText = 14,
        StiCrossColumn = 15,
        StiCrossColumnTotal = 16,
        StiCrossDataBand = 17,
        StiCrossFooterBand = 18,
        StiCrossGroupFooterBand = 19,
        StiCrossGroupHeaderBand = 20,
        StiCrossHeaderBand = 21,
        StiCrossRow = 22,
        StiCrossRowTotal = 23,
        StiCrossSummary = 24,
        StiCrossTab = 25,
        StiCrossTitle = 26,
        StiDashboardPage = 27,
        StiDataBand = 28,
        StiDateTimePickerControl = 29,
        StiEmptyBand = 30,
        StiFooterBand = 31,
        StiForm = 32,
        StiGridControl = 33,
        StiGroupBoxControl = 34,
        StiGroupFooterBand = 35,
        StiGroupHeaderBand = 36,
        StiHeaderBand = 37,
        StiHierarchicalBand = 38,
        StiHorizontalLinePrimitive = 39,
        StiImage = 40,
        StiLabelControl = 41,
        StiListBoxControl = 42,
        StiListViewControl = 43,
        StiLookUpBoxControl = 44,
        StiNumericUpDownControl = 45,
        StiOverlayBand = 46,
        StiPage = 47,
        StiPageFooterBand = 48,
        StiPageHeaderBand = 49,
        StiPanel = 50,
        StiPanelControl = 51,
        StiPictureBoxControl = 52,
        StiRadioButtonControl = 53,
        StiRectanglePrimitive = 54,
        StiReportControl = 55,
        StiReportSummaryBand = 56,
        StiReportTitleBand = 57,
        StiRichText = 58,
        StiRichTextBoxControl = 59,
        StiRoundedRectanglePrimitive = 60,
        StiShape = 61,
        StiSubReport = 62,
        StiSystemText = 63,
        StiTable = 64,
        StiTableCell = 65,
        StiText = 66,
        StiTextBoxControl = 67,
        StiTextInCells = 68,
        StiTreeViewControl = 69,
        StiVerticalLinePrimitive = 70,
        StiWinControl = 71,
        StiUndefinedComponent = 72,
        StiZipCode = 73,
        StiTableCellCheckBox = 74,
        StiTableCellImage = 75,
        StiTableCellRichText = 76,
        StiDataColumn = 77,
        StiCalcDataColumn = 78,
        StiBusinessObject = 79,
        StiDataSource = 80,
        StiDataStoreSource = 81,
        StiFileDataSource = 82,
        StiDataRelation = 83,
        StiVariable = 84,
        StiResource = 85,
        StiReport = 86,
        StiStyle = 87,
        StiCrossTabStyle = 88,
        StiChartStyle = 89,
        StiMapStyle = 90,
        StiTableStyle = 91,
        StiGaugeStyle = 92,
        StiDialogStyle = 93,
        StiDataParameter = 94,
        StiCrossField = 95,
        StiCrossTotal = 96,
        StiCrossCell = 97,
        StiCrossHeader = 98,
        StiCrossSummaryHeader = 99,
        StiStartPointPrimitive = 100,
        StiEndPointPrimitive = 101,
        StiEvent = 102,
        StiSeries = 103,
        StiBubbleSeries = 104,
        StiClusteredColumnSeries = 105,
        StiLineSeries = 106,
        StiSteppedLineSeries = 107,
        StiSplineSeries = 108,
        StiAreaSeries = 109,
        StiSteppedAreaSeries = 110,
        StiSplineAreaSeries = 111,
        StiStackedColumnSeries = 112,
        StiStackedLineSeries = 113,
        StiStackedSplineSeries = 114,
        StiStackedAreaSeries = 115,
        StiStackedSplineAreaSeries = 116,
        StiCenterTreemapLabels = 117,
        StiTreemapArea = 118,
        StiTreemapSeries = 119,
        StiPictorialSeries = 120,
        StiFullStackedColumnSeries = 121,
        StiFullStackedLineSeries = 122,
        StiFullStackedAreaSeries = 123,
        StiFullStackedSplineSeries = 124,
        StiFullStackedSplineAreaSeries = 125,
        StiClusteredBarSeries = 126,
        StiStackedBarSeries = 127,
        StiFullStackedBarSeries = 128,
        StiPieSeries = 129,
        StiDoughnutSeries = 130,
        StiGanttSeries = 131,
        StiScatterSeries = 132,
        StiScatterLineSeries = 133,
        StiScatterSplineSeries = 134,
        StiRadarAreaSeries = 135,
        StiRadarLineSeries = 136,
        StiRadarPointSeries = 137,
        StiRangeSeries = 138,
        StiSteppedRangeSeries = 139,
        StiFunnelSeries = 140,
        StiFunnelWeightedSlicesSeries = 141,
        StiRangeBarSeries = 142,
        StiSplineRangeSeries = 143,
        StiCandlestickSeries = 144,
        StiStockSeries = 145,
        StiChartTitle = 146,
        StiLineMarker = 147,
        StiMarker = 148,
        StiChartTable = 149,
        StiSeriesTopN = 150,
        StiSeriesInteraction = 151,
        StiTrendLine = 152,
        StiSeriesLabels = 153,
        StiNoneLabels = 154,
        StiInsideEndAxisLabels = 155,
        StiInsideBaseAxisLabels = 156,
        StiCenterAxisLabels = 157,
        StiOutsideEndAxisLabels = 158,
        StiOutsideBaseAxisLabels = 159,
        StiOutsideAxisLabels = 160,
        StiLeftAxisLabels = 161,
        StiValueAxisLabels = 162,
        StiRightAxisLabels = 163,
        StiCenterFunnelLabels = 164,
        StiCenterPieLabels = 165,
        StiOutsidePieLabels = 166,
        StiTwoColumnsPieLabels = 167,
        StiOutsideLeftFunnelLabels = 168,
        StiOutsideRightFunnelLabels = 169,
        StiLegend = 170,
        StiClusteredColumnArea = 171,
        StiPieArea = 172,
        StiFunnelArea = 173,
        StiFunnelWeightedSlicesArea = 174,
        StiPictorialArea = 175,
        StiRadarAreaArea = 176,
        StiRadarLineArea = 177,
        StiRadarPointArea = 178,
        StiStackedColumnArea = 179,
        StiGridLines = 180,
        StiInterlacing = 181,
        StiXAxis = 182,
        StiXTopAxis = 183,
        StiYAxis = 184,
        StiYRightAxis = 185,
        StiRadarGridLines = 186,
        StiXRadarAxis = 187,
        StiYRadarAxis = 188,
        StiDialogInfoItem = 189,
        StiStringDialogInfoItem = 190,
        StiGuidDialogInfoItem = 191,
        StiCharDialogInfoItem = 192,
        StiBoolDialogInfoItem = 193,
        StiImageDialogInfoItem = 194,
        StiDateTimeDialogInfoItem = 195,
        StiTimeSpanDialogInfoItem = 196,
        StiDoubleDialogInfoItem = 197,
        StiDecimalDialogInfoItem = 198,
        StiLongDialogInfoItem = 199,
        StiExpressionDialogInfoItem = 200,
        StiStringRangeDialogInfoItem = 201,
        StiGuidRangeDialogInfoItem = 202,
        StiCharRangeDialogInfoItem = 203,
        StiDateTimeRangeDialogInfoItem = 204,
        StiTimeSpanRangeDialogInfoItem = 205,
        StiDoubleRangeDialogInfoItem = 206,
        StiDecimalRangeDialogInfoItem = 207,
        StiLongRangeDialogInfoItem = 208,
        StiExpressionRangeDialogInfoItem = 209,
        OracleConnectionStringBuilder = 210,
        StiStrips = 211,
        StiConstantLines = 212,
        StiShapeTypeService = 213,
        StiDiagonalDownLineShapeType = 214,
        StiRoundedRectangleShapeType = 215,
        StiTriangleShapeType = 216,
        StiComplexArrowShapeType = 217,
        StiBentArrowShapeType = 218,
        StiChevronShapeType = 219,
        StiEqualShapeType = 220,
        StiFlowchartCollateShapeType = 221,
        StiFlowchartOffPageConnectorShapeType = 222,
        StiArrowShapeType = 223,
        StiOctagonShapeType = 224,
        StiAustraliaPost4StateBarCodeType = 225,
        StiCode11BarCodeType = 226,
        StiCode128aBarCodeType = 227,
        StiCode128bBarCodeType = 228,
        StiCode128cBarCodeType = 229,
        StiCode128AutoBarCodeType = 230,
        StiCode39BarCodeType = 231,
        StiCode39ExtBarCodeType = 232,
        StiCode93BarCodeType = 233,
        StiCode93ExtBarCodeType = 234,
        StiCodabarBarCodeType = 235,
        StiEAN128aBarCodeType = 236,
        StiEAN128bBarCodeType = 237,
        StiEAN128cBarCodeType = 238,
        StiEAN128AutoBarCodeType = 239,
        StiGS1_128BarCodeType = 240,
        StiEAN13BarCodeType = 241,
        StiEAN8BarCodeType = 242,
        StiFIMBarCodeType = 243,
        StiIsbn10BarCodeType = 244,
        StiIsbn13BarCodeType = 245,
        StiITF14BarCodeType = 246,
        StiJan13BarCodeType = 247,
        StiJan8BarCodeType = 248,
        StiMsiBarCodeType = 249,
        StiPdf417BarCodeType = 250,
        StiPharmacodeBarCodeType = 251,
        StiPlesseyBarCodeType = 252,
        StiPostnetBarCodeType = 253,
        StiQRCodeBarCodeType = 254,
        StiRoyalMail4StateBarCodeType = 255,
        StiDutchKIXBarCodeType = 256,
        StiSSCC18BarCodeType = 257,
        StiUpcABarCodeType = 258,
        StiUpcEBarCodeType = 259,
        StiUpcSup2BarCodeType = 260,
        StiUpcSup5BarCodeType = 261,
        StiInterleaved2of5BarCodeType = 262,
        StiStandard2of5BarCodeType = 263,
        StiDataMatrixBarCodeType = 264,
        StiMaxicodeBarCodeType = 265,
        StiDatabase = 266,
        StiFileDatabase = 267,
        StiCsvDatabase = 268,
        StiDBaseDatabase = 269,
        StiExcelDatabase = 270,
        StiJsonDatabase = 271,
        StiXmlDatabase = 272,
        StiSqlDatabase = 273,
        StiGauge = 274,
        StiMap = 275,
        StiFullStackedColumnArea = 276,
        StiClusteredBarArea = 277,
        StiStackedBarArea = 278,
        StiFullStackedBarArea = 279,
        StiDoughnutArea = 280,
        StiLineArea = 281,
        StiSteppedLineArea = 282,
        StiStackedLineArea = 283,
        StiFullStackedLineArea = 284,
        StiSplineArea = 285,
        StiStackedSplineArea = 286,
        StiFullStackedSplineArea = 287,
        StiAreaArea = 288,
        StiSteppedAreaArea = 289,
        StiStackedAreaArea = 290,
        StiFullStackedAreaArea = 291,
        StiSplineAreaArea = 292,
        StiStackedSplineAreaArea = 293,
        StiFullStackedSplineAreaArea = 294,
        StiGanttArea = 295,
        StiScatterArea = 296,
        StiBubbleArea = 297,
        StiRangeArea = 298,
        StiSteppedRangeArea = 299,
        StiRangeBarArea = 300,
        StiSplineRangeArea = 301,
        StiCandlestickArea = 302,
        StiStockArea = 303,
        StiInsideEndPieLabels = 304,
        StiTrendLineNone = 305,
        StiTrendLineLinear = 306,
        StiTrendLineExponential = 307,
        StiTrendLineLogarithmic = 308,
        StiDB2Database = 309,
        StiDotConnectUniversalDatabase = 310,
        StiFirebirdDatabase = 311,
        StiInformixDatabase = 312,
        StiMongoDbDatabase = 313,
        StiMySqlDatabase = 314,
        StiMSAccessDatabase = 315,
        StiOdbcDatabase = 316,
        StiOleDbDatabase = 317,
        StiOracleDatabase = 318,
        StiPostgreSQLDatabase = 319,
        StiSQLiteDatabase = 320,
        StiSqlCeDatabase = 321,
        StiSybaseDatabase = 322,
        StiTeradataDatabase = 323,
        StiVistaDBDatabase = 324,
        StiODataDatabase = 325,
        StiDataTableSource = 326,
        StiDataViewSource = 327,
        StiUndefinedDataSource = 328,
        StiCsvSource = 329,
        StiDBaseSource = 330,
        StiBusinessObjectSource = 331,
        StiCrossTabDataSource = 332,
        StiEnumerableSource = 333,
        StiUserSource = 334,
        StiVirtualSource = 335,
        StiOracleODPSource = 336,
        StiFirebirdSource = 337,
        StiInformixSource = 338,
        StiMongoDbSource = 339,
        StiMSAccessSource = 340,
        StiMySqlSource = 341,
        StiOdbcSource = 342,
        StiOleDbSource = 343,
        StiOracleSource = 344,
        StiPostgreSQLSource = 345,
        StiSqlCeSource = 346,
        StiSQLiteSource = 347,
        StiSqlSource = 348,
        StiNoSqlSource = 349,
        StiSybaseSource = 350,
        StiTeradataSource = 351,
        StiVistaDBSource = 352,
        StiDB2Source = 353,
        StiDiagonalUpLineShapeType = 354,
        StiHorizontalLineShapeType = 355,
        StiLeftAndRightLineShapeType = 356,
        StiOvalShapeType = 357,
        StiRectangleShapeType = 358,
        StiTopAndBottomLineShapeType = 359,
        StiVerticalLineShapeType = 360,
        StiDivisionShapeType = 361,
        StiFlowchartCardShapeType = 362,
        StiFlowchartDecisionShapeType = 363,
        StiFlowchartManualInputShapeType = 364,
        StiFlowchartSortShapeType = 365,
        StiFrameShapeType = 366,
        StiMinusShapeType = 367,
        StiMultiplyShapeType = 368,
        StiParallelogramShapeType = 369,
        StiPlusShapeType = 370,
        StiRegularPentagonShapeType = 371,
        StiTrapezoidShapeType = 372,
        StiSnipSameSideCornerRectangleShapeType = 373,
        StiSnipDiagonalSideCornerRectangleShapeType = 374,
        StiFlowchartPreparationShapeType = 375,
        StiRadialScale = 376,
        StiLinearScale = 377,
        StiLinearBar = 378,
        StiRadialBar = 379,
        StiNeedle = 380,
        StiRadialMarker = 381,
        StiScaleRangeList = 382,
        StiRadialRange = 383,
        StiStateIndicator = 384,
        StiStateIndicatorFilter = 385,
        StiRadialRangeList = 386,
        StiLinearRangeList = 387,
        StiLinearRange = 388,
        StiLinearTickMarkMajor = 389,
        StiLinearTickMarkMinor = 390,
        StiLinearTickMarkCustomValue = 391,
        StiLinearTickLabelMajor = 392,
        StiLinearTickLabelMinor = 393,
        StiLinearTickLabelCustom = 394,
        StiLinearTickLabelCustomValue = 395,
        StiRadialTickMarkMajor = 396,
        StiRadialTickMarkMinor = 397,
        StiRadialTickMarkCustom = 398,
        StiRadialTickMarkCustomValue = 399,
        StiRadialTickLabelMajor = 400,
        StiRadialTickLabelMinor = 401,
        StiRadialTickLabelCustom = 402,
        StiRadialTickLabelCustomValue = 403,
        StiLinearMarker = 404,
        StiLinearTickMarkCustom = 405,
        StiLinearIndicatorRangeInfo = 406,
        StiRadialIndicatorRangeInfo = 407,
    }
    enum StiRankOrder {
        Asc = 0,
        Desc = 1,
    }
    enum StiXmlType {
        AdoNetXml = 0,
        Xml = 1,
    }
    enum StiStyleElements {
        Font = 1,
        Border = 2,
        Brush = 4,
        TextBrush = 8,
        TextOptions = 16,
        HorAlignment = 32,
        VertAlignment = 64,
        All = 127,
    }
    enum StiDateRangeKind {
        CurrentMonth = 0,
        CurrentQuarter = 1,
        CurrentWeek = 2,
        CurrentYear = 3,
        NextMonth = 4,
        NextQuarter = 5,
        NextWeek = 6,
        NextYear = 7,
        PreviousMonth = 8,
        PreviousQuarter = 9,
        PreviousWeek = 10,
        PreviousYear = 11,
        FirstQuarter = 12,
        SecondQuarter = 13,
        ThirdQuarter = 14,
        FourthQuarter = 15,
        MonthToDate = 16,
        QuarterToDate = 17,
        WeekToDate = 18,
        YearToDate = 19,
        Today = 20,
        Tomorrow = 21,
        Yesterday = 22,
    }
}
declare module Stimulsoft.Report.Engine {
    enum StiTokenType {
        Empty = 0,
        Delimiter = 1,
        Variable = 2,
        SystemVariable = 3,
        DataSourceField = 4,
        BusinessObjectField = 5,
        Number = 6,
        Function = 7,
        Method = 8,
        Property = 9,
        Component = 10,
        Cast = 11,
        String = 12,
        Dot = 13,
        Comma = 14,
        Colon = 15,
        SemiColon = 16,
        Shl = 17,
        Shr = 18,
        Assign = 19,
        Equal = 20,
        NotEqual = 21,
        LeftEqual = 22,
        Left = 23,
        RightEqual = 24,
        Right = 25,
        Not = 26,
        Or = 27,
        And = 28,
        Xor = 29,
        DoubleOr = 30,
        DoubleAnd = 31,
        Question = 32,
        Plus = 33,
        Minus = 34,
        Mult = 35,
        Div = 36,
        Percent = 37,
        LParenthesis = 38,
        RParenthesis = 39,
        LBracket = 40,
        RBracket = 41,
        Identifier = 42,
        Unknown = 43,
    }
    enum StiAsmCommandType {
        PushValue = 2000,
        PushVariable = 2001,
        PushSystemVariable = 2002,
        PushDataSourceField = 2003,
        PushBusinessObjectField = 2004,
        PushFunction = 2005,
        PushMethod = 2006,
        PushProperty = 2007,
        PushComponent = 2008,
        PushArrayElement = 2009,
        CopyToVariable = 2010,
        Add = 2020,
        Sub = 2021,
        Mult = 2022,
        Div = 2023,
        Mod = 2024,
        Power = 2025,
        Neg = 2026,
        Cast = 2027,
        Not = 2028,
        CompareLeft = 2029,
        CompareLeftEqual = 2030,
        CompareRight = 2031,
        CompareRightEqual = 2032,
        CompareEqual = 2033,
        CompareNotEqual = 2034,
        Shl = 2035,
        Shr = 2036,
        And = 2037,
        And2 = 2038,
        Or = 2039,
        Or2 = 2040,
        Xor = 2041,
        Jump = 2042,
        JumpTrue = 2043,
        JumpFalse = 2044,
    }
    enum StiSystemVariableType {
        Column = 0,
        Line = 1,
        LineThrough = 2,
        LineABC = 3,
        LineRoman = 4,
        GroupLine = 5,
        PageNumber = 6,
        PageNumberThrough = 7,
        PageNofM = 8,
        PageNofMThrough = 9,
        TotalPageCount = 10,
        TotalPageCountThrough = 11,
        IsFirstPage = 12,
        IsFirstPageThrough = 13,
        IsLastPage = 14,
        IsLastPageThrough = 15,
        PageCopyNumber = 16,
        ReportAlias = 17,
        ReportAuthor = 18,
        ReportChanged = 19,
        ReportCreated = 20,
        ReportDescription = 21,
        ReportName = 22,
        Time = 23,
        Today = 24,
        ConditionValue = 25,
        ConditionTag = 26,
        Sender = 27,
        DateTimeNow = 28,
        DateTimeToday = 29,
    }
    enum StiPropertyType {
        Year = 0,
        Month = 1,
        Day = 2,
        Hour = 3,
        Minute = 4,
        Second = 5,
        Length = 6,
        From = 7,
        To = 8,
        FromDate = 9,
        ToDate = 10,
        FromTime = 11,
        ToTime = 12,
        SelectedLine = 13,
        Name = 14,
        TagValue = 15,
        Days = 16,
        Hours = 17,
        Milliseconds = 18,
        Minutes = 19,
        Seconds = 20,
        Ticks = 21,
        TotalDays = 22,
        TotalHours = 23,
        TotalMinutes = 24,
        TotalSeconds = 25,
        TotalMilliseconds = 26,
        Count = 27,
        BusinessObjectValue = 28,
    }
    enum StiFunctionType {
        NameSpace = 0,
        Count = 1,
        CountDistinct = 2,
        Avg = 3,
        AvgD = 4,
        AvgDate = 5,
        AvgI = 6,
        AvgTime = 7,
        Max = 8,
        MaxD = 9,
        MaxDate = 10,
        MaxI = 11,
        MaxStr = 12,
        MaxTime = 13,
        Median = 14,
        MedianD = 15,
        MedianI = 16,
        Min = 17,
        MinD = 18,
        MinDate = 19,
        MinI = 20,
        MinStr = 21,
        MinTime = 22,
        Mode = 23,
        ModeD = 24,
        ModeI = 25,
        Sum = 26,
        SumD = 27,
        SumDistinct = 28,
        SumI = 29,
        SumTime = 30,
        First = 31,
        Last = 32,
        rCount = 33,
        rCountDistinct = 34,
        rAvg = 35,
        rAvgD = 36,
        rAvgDate = 37,
        rAvgI = 38,
        rAvgTime = 39,
        rMax = 40,
        rMaxD = 41,
        rMaxDate = 42,
        rMaxI = 43,
        rMaxStr = 44,
        rMaxTime = 45,
        rMedian = 46,
        rMedianD = 47,
        rMedianI = 48,
        rMin = 49,
        rMinD = 50,
        rMinDate = 51,
        rMinI = 52,
        rMinStr = 53,
        rMinTime = 54,
        rMode = 55,
        rModeD = 56,
        rModeI = 57,
        rSum = 58,
        rSumD = 59,
        rSumDistinct = 60,
        rSumI = 61,
        rSumTime = 62,
        rFirst = 63,
        rLast = 64,
        iCount = 65,
        iCountDistinct = 66,
        iAvg = 67,
        iAvgD = 68,
        iAvgDate = 69,
        iAvgI = 70,
        iAvgTime = 71,
        iMax = 72,
        iMaxD = 73,
        iMaxDate = 74,
        iMaxI = 75,
        iMaxStr = 76,
        iMaxTime = 77,
        iMedian = 78,
        iMedianD = 79,
        iMedianI = 80,
        iMin = 81,
        iMinD = 82,
        iMinDate = 83,
        iMinI = 84,
        iMinStr = 85,
        iMinTime = 86,
        iMode = 87,
        iModeD = 88,
        iModeI = 89,
        iSum = 90,
        iSumD = 91,
        iSumDistinct = 92,
        iSumI = 93,
        iSumTime = 94,
        iFirst = 95,
        iLast = 96,
        riCount = 97,
        riCountDistinct = 98,
        riAvg = 99,
        riAvgD = 100,
        riAvgDate = 101,
        riAvgI = 102,
        riAvgTime = 103,
        riMax = 104,
        riMaxD = 105,
        riMaxDate = 106,
        riMaxI = 107,
        riMaxStr = 108,
        riMaxTime = 109,
        riMedian = 110,
        riMedianD = 111,
        riMedianI = 112,
        riMin = 113,
        riMinD = 114,
        riMinDate = 115,
        riMinI = 116,
        riMinStr = 117,
        riMinTime = 118,
        riMode = 119,
        riModeD = 120,
        riModeI = 121,
        riSum = 122,
        riSumD = 123,
        riSumDistinct = 124,
        riSumI = 125,
        riSumTime = 126,
        riFirst = 127,
        riLast = 128,
        cCount = 129,
        cCountDistinct = 130,
        cAvg = 131,
        cAvgD = 132,
        cAvgDate = 133,
        cAvgI = 134,
        cAvgTime = 135,
        cMax = 136,
        cMaxD = 137,
        cMaxDate = 138,
        cMaxI = 139,
        cMaxStr = 140,
        cMaxTime = 141,
        cMedian = 142,
        cMedianD = 143,
        cMedianI = 144,
        cMin = 145,
        cMinD = 146,
        cMinDate = 147,
        cMinI = 148,
        cMinStr = 149,
        cMinTime = 150,
        cMode = 151,
        cModeD = 152,
        cModeI = 153,
        cSum = 154,
        cSumD = 155,
        cSumDistinct = 156,
        cSumI = 157,
        cSumTime = 158,
        cFirst = 159,
        cLast = 160,
        crCount = 161,
        crCountDistinct = 162,
        crAvg = 163,
        crAvgD = 164,
        crAvgDate = 165,
        crAvgI = 166,
        crAvgTime = 167,
        crMax = 168,
        crMaxD = 169,
        crMaxDate = 170,
        crMaxI = 171,
        crMaxStr = 172,
        crMaxTime = 173,
        crMedian = 174,
        crMedianD = 175,
        crMedianI = 176,
        crMin = 177,
        crMinD = 178,
        crMinDate = 179,
        crMinI = 180,
        crMinStr = 181,
        crMinTime = 182,
        crMode = 183,
        crModeD = 184,
        crModeI = 185,
        crSum = 186,
        crSumD = 187,
        crSumDistinct = 188,
        crSumI = 189,
        crSumTime = 190,
        crFirst = 191,
        crLast = 192,
        ciCount = 193,
        ciCountDistinct = 194,
        ciAvg = 195,
        ciAvgD = 196,
        ciAvgDate = 197,
        ciAvgI = 198,
        ciAvgTime = 199,
        ciMax = 200,
        ciMaxD = 201,
        ciMaxDate = 202,
        ciMaxI = 203,
        ciMaxStr = 204,
        ciMaxTime = 205,
        ciMedian = 206,
        ciMedianD = 207,
        ciMedianI = 208,
        ciMin = 209,
        ciMinD = 210,
        ciMinDate = 211,
        ciMinI = 212,
        ciMinStr = 213,
        ciMinTime = 214,
        ciMode = 215,
        ciModeD = 216,
        ciModeI = 217,
        ciSum = 218,
        ciSumD = 219,
        ciSumDistinct = 220,
        ciSumI = 221,
        ciSumTime = 222,
        ciFirst = 223,
        ciLast = 224,
        criCount = 225,
        criCountDistinct = 226,
        criAvg = 227,
        criAvgD = 228,
        criAvgDate = 229,
        criAvgI = 230,
        criAvgTime = 231,
        criMax = 232,
        criMaxD = 233,
        criMaxDate = 234,
        criMaxI = 235,
        criMaxStr = 236,
        criMaxTime = 237,
        criMedian = 238,
        criMedianD = 239,
        criMedianI = 240,
        criMin = 241,
        criMinD = 242,
        criMinDate = 243,
        criMinI = 244,
        criMinStr = 245,
        criMinTime = 246,
        criMode = 247,
        criModeD = 248,
        criModeI = 249,
        criSum = 250,
        criSumD = 251,
        criSumDistinct = 252,
        criSumI = 253,
        criSumTime = 254,
        criFirst = 255,
        criLast = 256,
        pCount = 257,
        pCountDistinct = 258,
        pAvg = 259,
        pAvgD = 260,
        pAvgDate = 261,
        pAvgI = 262,
        pAvgTime = 263,
        pMax = 264,
        pMaxD = 265,
        pMaxDate = 266,
        pMaxI = 267,
        pMaxStr = 268,
        pMaxTime = 269,
        pMedian = 270,
        pMedianD = 271,
        pMedianI = 272,
        pMin = 273,
        pMinD = 274,
        pMinDate = 275,
        pMinI = 276,
        pMinStr = 277,
        pMinTime = 278,
        pMode = 279,
        pModeD = 280,
        pModeI = 281,
        pSum = 282,
        pSumD = 283,
        pSumDistinct = 284,
        pSumI = 285,
        pSumTime = 286,
        pFirst = 287,
        pLast = 288,
        prCount = 289,
        prCountDistinct = 290,
        prAvg = 291,
        prAvgD = 292,
        prAvgDate = 293,
        prAvgI = 294,
        prAvgTime = 295,
        prMax = 296,
        prMaxD = 297,
        prMaxDate = 298,
        prMaxI = 299,
        prMaxStr = 300,
        prMaxTime = 301,
        prMedian = 302,
        prMedianD = 303,
        prMedianI = 304,
        prMin = 305,
        prMinD = 306,
        prMinDate = 307,
        prMinI = 308,
        prMinStr = 309,
        prMinTime = 310,
        prMode = 311,
        prModeD = 312,
        prModeI = 313,
        prSum = 314,
        prSumD = 315,
        prSumDistinct = 316,
        prSumI = 317,
        prSumTime = 318,
        prFirst = 319,
        prLast = 320,
        piCount = 321,
        piCountDistinct = 322,
        piAvg = 323,
        piAvgD = 324,
        piAvgDate = 325,
        piAvgI = 326,
        piAvgTime = 327,
        piMax = 328,
        piMaxD = 329,
        piMaxDate = 330,
        piMaxI = 331,
        piMaxStr = 332,
        piMaxTime = 333,
        piMedian = 334,
        piMedianD = 335,
        piMedianI = 336,
        piMin = 337,
        piMinD = 338,
        piMinDate = 339,
        piMinI = 340,
        piMinStr = 341,
        piMinTime = 342,
        piMode = 343,
        piModeD = 344,
        piModeI = 345,
        piSum = 346,
        piSumD = 347,
        piSumDistinct = 348,
        piSumI = 349,
        piSumTime = 350,
        piFirst = 351,
        piLast = 352,
        priCount = 353,
        priCountDistinct = 354,
        priAvg = 355,
        priAvgD = 356,
        priAvgDate = 357,
        priAvgI = 358,
        priAvgTime = 359,
        priMax = 360,
        priMaxD = 361,
        priMaxDate = 362,
        priMaxI = 363,
        priMaxStr = 364,
        priMaxTime = 365,
        priMedian = 366,
        priMedianD = 367,
        priMedianI = 368,
        priMin = 369,
        priMinD = 370,
        priMinDate = 371,
        priMinI = 372,
        priMinStr = 373,
        priMinTime = 374,
        priMode = 375,
        priModeD = 376,
        priModeI = 377,
        priSum = 378,
        priSumD = 379,
        priSumDistinct = 380,
        priSumI = 381,
        priSumTime = 382,
        priFirst = 383,
        priLast = 384,
        Rank = 385,
        Abs = 386,
        Acos = 387,
        Asin = 388,
        Atan = 389,
        Ceiling = 390,
        Cos = 391,
        Div = 392,
        Exp = 393,
        Floor = 394,
        Log = 395,
        Maximum = 396,
        Minimum = 397,
        Round = 398,
        Sign = 399,
        Sin = 400,
        Sqrt = 401,
        Tan = 402,
        Truncate = 403,
        DateDiff = 404,
        DateSerial = 405,
        Day = 406,
        DayOfWeek = 407,
        DayOfYear = 408,
        DaysInMonth = 409,
        DaysInYear = 410,
        Hour = 411,
        Minute = 412,
        Month = 413,
        Second = 414,
        TimeSerial = 415,
        Year = 416,
        MonthName = 417,
        WeekOfYear = 418,
        WeekOfMonth = 419,
        DateToStr = 420,
        DateToStrPl = 421,
        DateToStrRu = 422,
        DateToStrUa = 423,
        DateToStrPt = 424,
        DateToStrPtBr = 425,
        Insert = 426,
        Length = 427,
        Remove = 428,
        Replace = 429,
        Roman = 430,
        Substring = 431,
        ToCurrencyWords = 432,
        ToCurrencyWordsEnGb = 433,
        ToCurrencyWordsEnIn = 434,
        ToCurrencyWordsEs = 435,
        ToCurrencyWordsFr = 436,
        ToCurrencyWordsNl = 437,
        ToCurrencyWordsPl = 438,
        ToCurrencyWordsPt = 439,
        ToCurrencyWordsPtBr = 440,
        ToCurrencyWordsRu = 441,
        ToCurrencyWordsThai = 442,
        ToCurrencyWordsTr = 443,
        ToCurrencyWordsUa = 444,
        ToCurrencyWordsZh = 445,
        ToLowerCase = 446,
        ToProperCase = 447,
        ToUpperCase = 448,
        ToWords = 449,
        ToWordsEs = 450,
        ToWordsEnIn = 451,
        ToWordsFa = 452,
        ToWordsPl = 453,
        ToWordsPt = 454,
        ToWordsRu = 455,
        ToWordsTr = 456,
        ToWordsUa = 457,
        Trim = 458,
        TryParseDecimal = 459,
        TryParseDouble = 460,
        TryParseLong = 461,
        Arabic = 462,
        Persian = 463,
        ToOrdinal = 464,
        Left = 465,
        Mid = 466,
        Right = 467,
        IsNull = 468,
        Next = 469,
        NextIsNull = 470,
        Previous = 471,
        PreviousIsNull = 472,
        IIF = 473,
        Choose = 474,
        Switch = 475,
        ToString = 476,
        Format = 477,
        SystemConvertToBoolean = 478,
        SystemConvertToByte = 479,
        SystemConvertToChar = 480,
        SystemConvertToDateTime = 481,
        SystemConvertToDecimal = 482,
        SystemConvertToDouble = 483,
        SystemConvertToInt16 = 484,
        SystemConvertToInt32 = 485,
        SystemConvertToInt64 = 486,
        SystemConvertToSByte = 487,
        SystemConvertToSingle = 488,
        SystemConvertToString = 489,
        SystemConvertToUInt16 = 490,
        SystemConvertToUInt32 = 491,
        SystemConvertToUInt64 = 492,
        MathRound = 493,
        MathPow = 494,
        AddAnchor = 495,
        GetAnchorPageNumber = 496,
        GetAnchorPageNumberThrough = 497,
        ConvertRtf = 498,
        ParseInt = 499,
        ParseDouble = 500,
        ParseDecimal = 501,
        ParseDateTime = 502,
        StringIsNullOrEmpty = 503,
        StringIsNullOrWhiteSpace = 504,
        EngineHelperJoinColumnContent = 505,
        EngineHelperToQueryString = 506,
        m_Substring = 1000,
        m_ToString = 1001,
        m_ToLower = 1002,
        m_ToUpper = 1003,
        m_IndexOf = 1004,
        m_StartsWith = 1005,
        m_EndsWith = 1006,
        m_Parse = 1007,
        m_Contains = 1008,
        m_GetData = 1009,
        m_ToQueryString = 1010,
        m_AddYears = 1011,
        m_AddMonths = 1012,
        m_AddDays = 1013,
        m_AddHours = 1014,
        m_AddMinutes = 1015,
        m_AddSeconds = 1016,
        m_AddMilliseconds = 1017,
        m_MethodNameSpace = 1018,
        op_Add = 2020,
        op_Sub = 2021,
        op_Mult = 2022,
        op_Div = 2023,
        op_Mod = 2024,
        op_Power = 2025,
        op_Neg = 2026,
        op_Cast = 2027,
        op_Not = 2028,
        op_CompareLeft = 2029,
        op_CompareLeftEqual = 2030,
        op_CompareRight = 2031,
        op_CompareRightEqual = 2032,
        op_CompareEqual = 2033,
        op_CompareNotEqual = 2034,
        op_Shl = 2035,
        op_Shr = 2036,
        op_And = 2037,
        op_And2 = 2038,
        op_Or = 2039,
        op_Or2 = 2040,
        op_Xor = 2041,
        UserFunction = 3000,
    }
    enum StiMethodType {
        Substring = 1000,
        ToString = 1001,
        ToLower = 1002,
        ToUpper = 1003,
        IndexOf = 1004,
        StartsWith = 1005,
        EndsWith = 1006,
        Parse = 1007,
        Contains = 1008,
        GetData = 1009,
        ToQueryString = 1010,
        AddYears = 1011,
        AddMonths = 1012,
        AddDays = 1013,
        AddHours = 1014,
        AddMinutes = 1015,
        AddSeconds = 1016,
        AddMilliseconds = 1017,
        MethodNameSpace = 1018,
    }
    enum StiParameterNumber {
        Param1 = 1,
        Param2 = 2,
        Param3 = 4,
        Param4 = 8,
    }
}
declare module Stimulsoft.Report.Engine.StiParser {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import Type = Stimulsoft.System.Type;
    class StiParserMethodInfo {
        name: StiFunctionType;
        number: number;
        arguments: Type[];
        returnType: Type;
        constructor(name: StiFunctionType, numberr: number, argumentss: Array<Type>, returnType?: Type);
    }
    class StiParser_Properties {
        protected get_category(par: Object): number;
        protected report: StiReport;
        protected expressionPosition: number;
        private static _typesList;
        static readonly typesList: Hashtable;
        private static _systemVariablesList;
        static readonly systemVariablesList: Hashtable;
        private static _propertiesList;
        static readonly propertiesList: Hashtable;
        private static _functionsList;
        static readonly functionsList: Hashtable;
        private static _methodsList;
        static readonly methodsList: Hashtable;
        private static _parametersList;
        static readonly parametersList: Hashtable;
        private _componentsList;
        readonly componentsList: Hashtable;
        private static _methodsHash;
        static readonly methodsHash: Hashtable;
        private static _constantsList;
        static readonly constantsList: Hashtable;
        protected static namespaceObj: Object;
        private static _namespacesList;
        static readonly namespacesList: Hashtable;
        private lockUserFunctionsList;
        private _userFunctionsList;
        readonly userFunctionsList: Hashtable;
    }
}
declare module Stimulsoft.Report.Engine.StiParser {
    import Type = Stimulsoft.System.Type;
    enum ParserErrorCode {
        SyntaxError = 0,
        IntegralConstantIsTooLarge = 1,
        ExpressionIsEmpty = 2,
        DivisionByZero = 3,
        UnexpectedEndOfExpression = 4,
        NameDoesNotExistInCurrentContext = 5,
        UnprocessedLexemesRemain = 6,
        LeftParenthesisExpected = 7,
        RightParenthesisExpected = 8,
        FieldMethodOrPropertyNotFound = 9,
        OperatorCannotBeAppliedToOperands = 10,
        FunctionNotFound = 11,
        NoOverloadForMethodTakesNArguments = 12,
        FunctionHasInvalidArgument = 13,
        FunctionNotYetImplemented = 14,
        MethodHasInvalidArgument = 15,
        ItemDoesNotContainDefinition = 16,
        NoMatchingOverloadedMethod = 17,
        TheTypeOrNamespaceNotExistInTheNamespace = 18,
    }
    class StiParserException {
        message: string;
        baseMessage: string;
        position: number;
        length: number;
        constructor(message: string);
    }
    class StiParser_Check extends StiParser_Properties {
        private static errorsList;
        protected throwError(code: ParserErrorCode, token?: StiToken, message1?: string, message2?: string, message3?: string, message4?: string): void;
        checkTypes(asmList: Array<StiAsmCommand>): void;
        private getMethodResultType(type, args);
        private getPropertyType(type, baseType);
        private getArrayElementType(argsList);
        getParserMethodInfo(type: StiFunctionType, args: Array<Type>): StiParserMethodInfo;
        protected get_systemVariable(name: Object): Object;
        static isImplicitlyCastableTo(from: Type, to: Type): boolean;
        protected getTypeName(value: any): string;
    }
}
declare module Stimulsoft.Report.Engine.StiParser {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiParser_Lexer extends StiParser_Check {
        protected position: number;
        protected inputExpression: string;
        protected hashAliases: Hashtable;
        protected tokenPos: number;
        protected tokensList: Array<StiToken>;
        protected component: StiComponent;
        private getNextLexem();
        private static isWhiteSpace(ch);
        private buildAliases();
        private buildBusinessObject(report, businesObject);
        private static isValidName(name);
        private static getCorrectedAlias(alias);
        private static replaceBackslash(input);
        private scanNumber();
        private postProcessTokensList(tokensList);
        private getDataSourceByName(name);
        private getDataRelationByName(name, ds);
        private getDataColumnByName(name, ds);
        protected makeTokensList(): void;
    }
}
declare module Stimulsoft.Report.Engine.StiParser {
    class StiParser_AsmOperations extends StiParser_Lexer {
        protected op_Add(par1: Object, par2: Object): Object;
        protected op_Sub(par1: Object, par2: Object): Object;
        protected op_Mult(par1: Object, par2: Object): Object;
        protected op_Div(par1: Object, par2: Object): Object;
        protected op_Mod(par1: Object, par2: Object): Object;
        protected op_Pow(par1: Object, par2: Object): Object;
        protected op_Neg(par1: Object): Object;
        protected op_Not(par1: Object): Object;
        protected op_Cast(par1: Object, par2: Object): Object;
        protected op_CompareLeft(par1: Object, par2: Object): Object;
        protected op_CompareLeftEqual(par1: Object, par2: Object): Object;
        protected op_CompareRight(par1: Object, par2: Object): Object;
        protected op_CompareRightEqual(par1: Object, par2: Object): Object;
        protected op_CompareEqual(par1: Object, par2: Object): Object;
        protected op_CompareNotEqual(par1: Object, par2: Object): Object;
        protected op_Shl(par1: Object, par2: Object): Object;
        protected op_Shr(par1: Object, par2: Object): Object;
        protected op_And(par1: Object, par2: Object): Object;
        protected op_Or(par1: Object, par2: Object): Object;
        protected op_Xor(par1: Object, par2: Object): Object;
        protected op_And2(par1: Object, par2: Object): Object;
        protected op_Or2(par1: Object, par2: Object): Object;
    }
}
declare module Stimulsoft.Report.Engine.StiParser {
    class StiParser_AsmProperties extends StiParser_AsmOperations {
        protected call_property(name: Object, argsList: Array<any>): any;
    }
}
declare module Stimulsoft.Report.Engine.StiParser {
    class StiParser_AsmMethods extends StiParser_AsmProperties {
        protected call_method(name: Object, argsList: Array<any>): Object;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import DateTime = Stimulsoft.System.DateTime;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import CalendarWeekRule = Stimulsoft.System.Globalization.CalendarWeekRule;
    import DayOfWeek = Stimulsoft.System.DayOfWeek;
    class StiFunctionsDate {
        private static isCreated;
        static create(): void;
        static dateDiff(date1: DateTime, date2: DateTime): TimeSpan;
        static year(date: DateTime): number;
        static month(date: DateTime): number;
        static hour(date: DateTime): number;
        static minute(date: DateTime): number;
        static second(date: DateTime): number;
        static day(date: DateTime): number;
        static dayOfWeek(date: DateTime, loc?: boolean | string, upperCase?: boolean): string;
        static monthName(date: DateTime, loc?: boolean | string, upperCase?: boolean): string;
        static dayOfYear(date: DateTime): number;
        static dateSerial(year: number, month: number, day: number): DateTime;
        static timeSerial(hours: number, minutes: number, seconds: number): TimeSpan;
        static daysInMonth(yearOrDate: number | DateTime, month: number): number;
        static daysInYear(yearOrDate: number | DateTime): number;
        static weekOfYear(date: DateTime, firstDayOfWeek?: DayOfWeek, calendarWeekRule?: CalendarWeekRule): number;
        static weekOfMonth(date: DateTime, firstDayOfWeek?: DayOfWeek, calendarWeekRule?: CalendarWeekRule): number;
    }
}
declare module Stimulsoft.Report.Engine.StiParser {
    import Type = Stimulsoft.System.Type;
    class StiParser_AsmFunctions extends StiParser_AsmMethods {
        protected call_func(name: Object, argsList: Array<any>): Object;
        report: StiReport;
        private checkParserMethodInfo(type, args);
        getParserMethodInfo(type: StiFunctionType, args: Array<Type>): StiParserMethodInfo;
    }
}
declare module Stimulsoft.Report.Engine.StiParser {
    class StiParser_Parser extends StiParser_AsmFunctions {
        protected currentToken: StiToken;
        protected asmList: Array<StiAsmCommand>;
        protected eval_exp(): void;
        private eval_exp0();
        private eval_exp01();
        private eval_exp1();
        private eval_exp10();
        private eval_exp11();
        private eval_exp12();
        private eval_exp14();
        private eval_exp15();
        private eval_exp16();
        private eval_exp17();
        private eval_exp18();
        private eval_exp2();
        private eval_exp3();
        private eval_exp4();
        private eval_exp5();
        private eval_exp6();
        private eval_exp62();
        private eval_exp7();
        private atom();
        private get_args_count(name);
        private get_args();
        private get_token();
    }
}
declare module Stimulsoft.Report.Engine.StiParser {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiText = Stimulsoft.Report.Components.StiText;
    import StiVariable = Stimulsoft.Report.Dictionary.StiVariable;
    class StiParserData {
        data: Object;
        asmList: Array<StiAsmCommand>;
        asmList2: Array<StiAsmCommand>;
        conditionAsmList: Array<StiAsmCommand>;
        parser: StiParser;
        constructor(data: Object, asmList: Array<StiAsmCommand>, parser: StiParser, conditionAsmList?: Array<StiAsmCommand>);
    }
    class StiFilterParserData {
        component: StiComponent;
        expression: string;
        constructor(component: StiComponent, expression: string);
    }
    class StiToken {
        type: StiTokenType;
        value: string;
        valueObject: Object;
        position: number;
        length: number;
        constructor(type?: StiTokenType, position?: number, length?: number);
        toString(): string;
    }
    class StiAsmCommand {
        type: StiAsmCommandType;
        parameter1: Object;
        parameter2: Object;
        position: number;
        length: number;
        constructor(type: StiAsmCommandType, parameter1?: Object, parameter2?: Object);
        toString(): string;
    }
    class StiParser extends StiParser_Parser {
        private sender;
        executeAsm(objectAsmList: Object): Object;
        private getVariableValue(name);
        private call_arrayElement(argsList);
        protected get_systemVariable(name: Object): Object;
        static parseTextValue(inputExpression: string, component: StiComponent, sender?: Object, REFstoreToPrint?: any, executeIfStoreToPrint?: boolean, returnAsmList?: boolean, parser?: StiParser): Object;
        private parseToAsm(inputExpression);
        private static checkForStoreToPrint(objAsmList);
        static checkExpression(inputExpression: string, component: StiComponent): StiParserException;
        static checkForDataBandsUsedInPageTotals(stiText: StiText): void;
        static prepareReportVariables(report: StiReport): void;
        static prepareVariableValue(varr: StiVariable, report: StiReport, textBox?: StiText, fillItems?: boolean): Object;
        private static getExpressionValue(expr, comp, hash, report);
    }
}
declare module Stimulsoft.Report.Components {
    import StiGetSummaryExpressionEvent = Stimulsoft.Report.Events.StiGetSummaryExpressionEvent;
    import StiGetGroupConditionEvent = Stimulsoft.Report.Events.StiGetGroupConditionEvent;
    import StiGetCollapsedEvent = Stimulsoft.Report.Events.StiGetCollapsedEvent;
    import StiBeginRenderEvent = Stimulsoft.Report.Events.StiBeginRenderEvent;
    import StiRenderingEvent = Stimulsoft.Report.Events.StiRenderingEvent;
    import StiEndRenderEvent = Stimulsoft.Report.Events.StiEndRenderEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    class StiGroupHeaderBand extends StiDynamicBand implements IStiGroup, IStiPrintOnAllPages, IStiKeepGroupTogether, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean, cloneComponents: boolean): StiGroupHeaderBand;
        private _keepGroupHeaderTogether;
        keepGroupHeaderTogether: boolean;
        private _keepGroupTogether;
        keepGroupTogether: boolean;
        private _startNewPage;
        startNewPage: boolean;
        startNewPageIfLessThan: number;
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        private _sortDirection;
        sortDirection: StiGroupSortDirection;
        private _summarySortDirection;
        summarySortDirection: StiGroupSortDirection;
        private _summaryType;
        summaryType: StiGroupSummaryType;
        private _printOnAllPages;
        printOnAllPages: boolean;
        private _groupHeaderBandInfo;
        readonly groupHeaderBandInfo: StiGroupHeaderBandInfo;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        protected getComponentType(): StiComponentType;
        readonly priority: number;
        getDataBand(): StiDataBand;
        private _line;
        line: number;
        private static eventGetSummaryExpression;
        protected onGetSummaryExpression(e: StiValueEventArgs): void;
        invokeGetSummaryExpression(e: StiValueEventArgs): void;
        getSummaryExpressionEvent: StiGetSummaryExpressionEvent;
        private static eventGetValue;
        protected onGetValue(e: StiValueEventArgs): void;
        invokeGetValue(e: StiValueEventArgs): void;
        getValueEvent: StiGetGroupConditionEvent;
        private static eventGetCollapsed;
        protected onGetCollapsed(e: StiValueEventArgs): void;
        invokeGetCollapsed(e: StiValueEventArgs): void;
        getCollapsedEvent: StiGetCollapsedEvent;
        private static eventBeginRender;
        protected onBeginRender(): void;
        invokeBeginRender(): void;
        beginRenderEvent: StiBeginRenderEvent;
        private static eventRendering;
        protected onRendering(): void;
        invokeRendering(): void;
        renderingEvent: StiRenderingEvent;
        private static eventEndRender;
        protected onEndRender(): void;
        invokeEndRender(): void;
        endRenderEvent: StiEndRenderEvent;
        private _condition;
        condition: string;
        private _summaryExpression;
        summaryExpression: string;
        private _collapsed;
        collapsed: string;
        getHeaderText(): string;
        createNew(): StiComponent;
        getCurrentConditionValue(): Object;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHierarchicalBand extends StiDataBand implements IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        private _keyDataColumn;
        keyDataColumn: string;
        private _masterKeyDataColumn;
        masterKeyDataColumn: string;
        private _parentValue;
        parentValue: string;
        private _indent;
        indent: number;
        private _headers;
        headers: string;
        private _footers;
        footers: string;
        private _hierarchicalBandInfo;
        readonly hierarchicalBandInfo: StiHierarchicalBandInfo;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStaticBand extends StiBand implements IStiBreakable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        protected getComponentType(): StiComponentType;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOverlayBand extends StiStaticBand implements IStiVertAlignment, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _vertAlignment;
        vertAlignment: StiVertAlignment;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        protected getComponentType(): StiComponentType;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly priority: number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiPageFooterBand extends StiStaticBand implements IStiPrintOnEvenOddPages, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _printOnEvenOddPages;
        printOnEvenOddPages: StiPrintOnEvenOddPagesType;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly priority: number;
        canContainIn(component: StiComponent): boolean;
        protected getComponentType(): StiComponentType;
        getDisplayRectangle(): RectangleD;
        setDisplayRectangle(value: RectangleD): void;
        createNew(): StiComponent;
        getMaster(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPageHeaderBand extends StiStaticBand implements IStiBreakable, IStiPrintOnEvenOddPages, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly priority: number;
        canContainIn(component: StiComponent): boolean;
        protected getComponentType(): StiComponentType;
        private _printOnEvenOddPages;
        printOnEvenOddPages: StiPrintOnEvenOddPagesType;
        printOnFirstPage: boolean;
        getMaster(): StiComponent;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiReportSummaryBand extends StiDynamicBand implements IStiPrintIfEmpty, IStiKeepReportSummaryTogether, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _keepReportSummaryTogether;
        keepReportSummaryTogether: boolean;
        private _printIfEmpty;
        printIfEmpty: boolean;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        canContainIn(component: StiComponent): boolean;
        readonly priority: number;
        protected getComponentType(): StiComponentType;
        createNew(): StiComponent;
        getMaster(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiReportTitleBand extends StiStaticBand implements IStiBreakable, IStiPrintIfEmpty, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _printIfEmpty;
        printIfEmpty: boolean;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        protected getComponentType(): StiComponentType;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly priority: number;
        canContainIn(component: StiComponent): boolean;
        createNew(): StiComponent;
        getMaster(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    class StiContainerHelper {
        static checkSize(component: StiComponent): void;
        private static componentPlacedOnBand(component);
        static checkContainerGrowToHeight(component: StiComponent): void;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiBreakable = Stimulsoft.Report.Components.IStiBreakable;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiPanel extends StiContainer implements IStiBreakable {
        private static ImplementsStiPanel;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _rightToLeft;
        rightToLeft: boolean;
        private _columnGaps;
        columnGaps: number;
        private _columnWidth;
        columnWidth: number;
        private _columns;
        columns: number;
        getColumnWidth(): number;
    }
}
declare module Stimulsoft.Report.Events {
    class StiFillParametersEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiGetSubReportEventHandler: EventHandler;
    class StiGetSubReportEventArgs extends EventArgs {
        report: StiReport;
        subReportName: string;
        constructor(subReportName: string);
    }
}
declare module Stimulsoft.Report.Helpers {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiHyperlinkProcessor {
        static getBytes(report: StiReport, hyperlink: string): number[];
        static getImage(report: StiReport, hyperlink: string): Image;
        static getString(report: StiReport, hyperlink: string): string;
        private static getResource(report, resourceName);
        private static getVariable(report, variableName);
        static getServerNameFromHyperlink(hyperlink: string): string;
        static getResourceNameFromHyperlink(hyperlink: string): string;
        static getVariableNameFromHyperlink(hyperlink: string): string;
        static getFileNameFromHyperlink(hyperlink: string): string;
        static isServerHyperlink(hyperlink: string): boolean;
        static isResourceHyperlink(hyperlink: string): boolean;
        static isVariableHyperlink(hyperlink: string): boolean;
        static isFileHyperlink(hyperlink: string): boolean;
        static createResourceName(name: string): string;
        static createVariableName(name: string): string;
        static createFileName(path: string): string;
        static hyperlinkToString(hyperlink: string): string;
        static serverIdent: string;
        static resourceIdent: string;
        static variableIdent: string;
        static fileIdent: string;
    }
}
declare module Stimulsoft.Report.Components {
    import StiFillParametersEventArgs = Stimulsoft.Report.Events.StiFillParametersEventArgs;
    import StiFillParametersEvent = Stimulsoft.Report.Events.StiFillParametersEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiSubReport extends StiContainer {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentType: StiComponentType;
        clone(): StiSubReport;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        width: number;
        setClientRectangle(value: RectangleD): void;
        private updateSubReportPageWidth();
        getExternalSubReport(): StiReport;
        protected getSubReportFromUrl(url: string): StiReport;
        protected getSubReportFromFile(url: string): StiReport;
        private static eventFillParameters;
        protected onFillParameters(e: StiFillParametersEventArgs): void;
        invokeFillParameters(sender: StiComponent, e: StiFillParametersEventArgs): void;
        fillParametersEvent: StiFillParametersEvent;
        readonly useExternalReport: boolean;
        private _keepSubReportTogether;
        keepSubReportTogether: boolean;
        subReportPage: StiPage;
        private _subReportPageGuid;
        subReportPageGuid: string;
        private _subReportUrl;
        subReportUrl: string;
        private _parameters;
        parameters: StiParametersCollection;
        static getSubReportForPage(page: StiPage): StiSubReport;
    }
}
declare module Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFilter implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiFilter;
        memberwiseClone(): StiFilter;
        private _condition;
        condition: StiFilterCondition;
        private _dataType;
        dataType: StiFilterDataType;
        private _column;
        column: string;
        private _item;
        item: StiFilterItem;
        private valueObj1;
        value1: string;
        private valueObj2;
        value2: string;
        private _expression;
        expression: string;
        constructor(item?: StiFilterItem, column?: string, condition?: StiFilterCondition, value1?: string, value2?: string, dataType?: StiFilterDataType, expression?: string);
    }
}
declare module Stimulsoft.Report.Components {
    class StiBaseCondition extends StiFilter {
        implements(): string[];
        private _tag;
        tag: Object;
        constructor(item?: StiFilterItem, column?: string, condition?: StiFilterCondition, value1?: string, value2?: string, dataType?: StiFilterDataType, expression?: string);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiColorScaleCondition extends StiBaseCondition implements IStiIndicatorCondition, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        createIndicator(component: StiText): StiIndicator;
        reset(): void;
        private _scaleType;
        scaleType: StiColorScaleType;
        private _minimumColor;
        minimumColor: Color;
        private _midColor;
        midColor: Color;
        private _maximumColor;
        maximumColor: Color;
        private _minimumType;
        minimumType: StiMinimumType;
        private _minimumValue;
        minimumValue: number;
        private _midType;
        midType: StiMidType;
        private _midValue;
        midValue: number;
        private _maximumType;
        maximumType: StiMaximumType;
        private _maximumValue;
        maximumValue: number;
        getHashCode(): number;
        stiEquals(obj: Object): boolean;
        private minimum;
        private maximum;
        constructor(column?: string, scaleType?: StiColorScaleType, minimumColor?: Color, midColor?: Color, maximumColor?: Color, minimumType?: StiMinimumType, minimumValue?: number, midType?: StiMidType, midValue?: number, maximumType?: StiMaximumType, maximumValue?: number);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiCondition extends StiBaseCondition {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(): StiCondition;
        memberwiseClone(): StiCondition;
        private _enabled;
        enabled: boolean;
        private _textColor;
        textColor: Color;
        private _backColor;
        backColor: Color;
        private _font;
        font: Font;
        private _canAssignExpression;
        canAssignExpression: boolean;
        private _breakIfTrue;
        breakIfTrue: boolean;
        private _assignExpression;
        assignExpression: string;
        private _style;
        style: string;
        private _borderSides;
        borderSides: StiConditionBorderSides;
        private _permissions;
        permissions: StiConditionPermissions;
        getHashCode(): number;
        stiEquals(obj: Object): boolean;
        constructor(item?: StiFilterItem, column?: string, condition?: StiFilterCondition, value1?: string, value2?: string, dataType?: StiFilterDataType, expression?: string, textColor?: Color, backColor?: Color, font?: Font, enabled?: boolean, canAssignExpression?: boolean, assignExpression?: string, style?: string, borderSides?: StiConditionBorderSides, permissions?: StiConditionPermissions);
    }
}
declare module Stimulsoft.Report.Components {
    import Font = Stimulsoft.System.Drawing.Font;
    class StiConditionHelper extends StiFilter {
        implements(): string[];
        static apply(comp: Object, styleName: string): void;
        private static applyParentStyle(style, comp);
        static applyFont(component: Object, font: Font, perms: StiConditionPermissions): void;
    }
}
declare module Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrushType = Stimulsoft.Report.Components.StiBrushType;
    class StiDataBarCondition extends StiBaseCondition implements IStiDataBarIndicator, IStiIndicatorCondition, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        createIndicator(component: StiText): StiIndicator;
        reset(): void;
        private _brushType;
        brushType: StiBrushType;
        private _positiveColor;
        positiveColor: Color;
        private _negativeColor;
        negativeColor: Color;
        private _positiveBorderColor;
        positiveBorderColor: Color;
        private _negativeBorderColor;
        negativeBorderColor: Color;
        private _showBorder;
        showBorder: boolean;
        private _direction;
        direction: StiDataBarDirection;
        private _minimumType;
        minimumType: StiMinimumType;
        private _minimumValue;
        minimumValue: number;
        private _maximumType;
        maximumType: StiMaximumType;
        private _maximumValue;
        maximumValue: number;
        getHashCode(): number;
        stiEquals(obj: Object): boolean;
        private minimum;
        private maximum;
        constructor(column?: string, brushType?: StiBrushType, positiveColor?: Color, negativeColor?: Color, showBorder?: boolean, positiveBorderColor?: Color, negativeBorderColor?: Color, direction?: StiDataBarDirection, minimumType?: StiMinimumType, minimumValue?: number, maximumType?: StiMaximumType, maximumValue?: number);
    }
}
declare module Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import ContentAlignment = Stimulsoft.System.Drawing.ContentAlignment;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiIconSetCondition extends StiBaseCondition implements IStiIndicatorCondition, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        createIndicator(component: StiText): StiIndicator;
        private inRange(item, floatCurrentValue, floatCurrentValuePercent);
        reset(): void;
        private _iconSet;
        iconSet: StiIconSet;
        private _contentAlignment;
        contentAlignment: ContentAlignment;
        private _iconSetItem1;
        iconSetItem1: StiIconSetItem;
        private _iconSetItem2;
        iconSetItem2: StiIconSetItem;
        private _iconSetItem3;
        iconSetItem3: StiIconSetItem;
        private _iconSetItem4;
        iconSetItem4: StiIconSetItem;
        private _iconSetItem5;
        iconSetItem5: StiIconSetItem;
        getHashCode(): number;
        stiEquals(obj: Object): boolean;
        private minimum;
        private maximum;
        constructor(column?: string, iconSet?: StiIconSet, contentAlignment?: ContentAlignment, item1?: StiIconSetItem, item2?: StiIconSetItem, item3?: StiIconSetItem, item4?: StiIconSetItem, item5?: StiIconSetItem);
    }
}
declare module Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiIconSetItem implements IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _icon;
        icon: StiIcon;
        private _operation;
        operation: StiIconSetOperation;
        private _valueType;
        valueType: StiIconSetValueType;
        private _value;
        value: number;
        constructor(icon?: StiIcon, operation?: StiIconSetOperation, valueType?: StiIconSetValueType, value?: number);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiMultiCondition extends StiCondition implements IStiFilter, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadfromXmlDoc(xmlDoc: XmlNode): void;
        clone(): StiMultiCondition;
        private _filterMode;
        filterMode: StiFilterMode;
        private _filters;
        filters: StiFiltersCollection;
        filterMethodHandler: Function;
        readonly filterOn: boolean;
        condition: StiFilterCondition;
        dataType: StiFilterDataType;
        column: string;
        item: StiFilterItem;
        value1: string;
        value2: string;
        expression: string;
        getHashCode(): number;
        stiEquals(obj: Object): boolean;
        constructor(textColor?: Color, backColor?: Color, font?: Font, enabled?: boolean, filterMode?: StiFilterMode, filters?: StiFilter[], canAssignExpression?: boolean, assignExpression?: string, style?: string, borderSides?: StiConditionBorderSides);
    }
}
declare module Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiMultiConditionContainer {
        private _filters;
        filters: StiFiltersCollection;
        private _filterMode;
        filterMode: StiFilterMode;
        private _enabled;
        enabled: boolean;
        private _textColor;
        textColor: Color;
        private _backColor;
        backColor: Color;
        private _font;
        font: Font;
        private _canAssignExpression;
        canAssignExpression: boolean;
        private _assignExpression;
        assignExpression: string;
        private _style;
        style: string;
        private _borderSides;
        borderSides: StiConditionBorderSides;
        private _permissions;
        permissions: StiConditionPermissions;
    }
}
declare module Stimulsoft.Report.Components {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCrossDataBand extends StiDataBand {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        growToHeight: boolean;
        resetPageNumber: boolean;
        startNewPage: boolean;
        startNewPageIfLessThan: number;
        restoreState(stateName: string): void;
        keepHeaderTogether: boolean;
        keepFooterTogether: boolean;
        keepChildTogether: boolean;
        keepGroupTogether: boolean;
        printAtBottom: boolean;
        printOnAllPages: boolean;
        setColumnModeToParent(): void;
        getColumnModeFromParent(): void;
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        readonly localizedCategory: string;
        readonly localizedName: string;
        readonly isCross: boolean;
        isRightToLeft: boolean;
        getDockStyle(): StiDockStyle;
        minWidth: number;
        maxWidth: number;
        readonly defaultClientRectangle: RectangleD;
        selectRectangle: RectangleD;
        displayRectangle: RectangleD;
        columnCurrent: number;
        readonly headerSize: number;
        createNew(): StiComponent;
        private _columnMode;
        columnMode: boolean;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCrossFooterBand extends StiFooterBand {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        readonly helpUrl: string;
        growToHeight: boolean;
        resetPageNumber: boolean;
        startNewPage: boolean;
        startNewPageIfLessThan: number;
        printAtBottom: boolean;
        printOnAllPages: boolean;
        readonly localizedCategory: string;
        readonly localizedName: string;
        readonly isCross: boolean;
        getDockStyle(): StiDockStyle;
        setDockStyle(value: StiDockStyle): void;
        minWidth: number;
        maxWidth: number;
        readonly defaultClientRectangle: RectangleD;
        selectRectangle: RectangleD;
        displayRectangle: RectangleD;
        readonly headerSize: number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCrossGroupFooterBand extends StiGroupFooterBand {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly сomponentId: StiComponentId;
        readonly helpUrl: string;
        growToHeight: boolean;
        resetPageNumber: boolean;
        printAtBottom: boolean;
        readonly localizedCategory: string;
        readonly localizedName: string;
        readonly isCross: boolean;
        getDockStyle(): StiDockStyle;
        setDockStyle(value: StiDockStyle): void;
        minWidth: number;
        maxWidth: number;
        readonly defaultClientRectangle: RectangleD;
        selectRectangle: RectangleD;
        displayRectangle: RectangleD;
        readonly headerSize: number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCrossGroupHeaderBand extends StiGroupHeaderBand {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        readonly helpUrl: string;
        growToHeight: boolean;
        resetPageNumber: boolean;
        startNewPage: boolean;
        printOnAllPages: boolean;
        printAtBottom: boolean;
        readonly localizedCategory: string;
        readonly localizedName: string;
        readonly isCross: boolean;
        getDockStyle(): StiDockStyle;
        setDockStyle(value: StiDockStyle): void;
        minWidth: number;
        maxWidth: number;
        readonly defaultClientRectangle: RectangleD;
        selectRectangle: RectangleD;
        displayRectangle: RectangleD;
        readonly headerSize: number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCrossHeaderBand extends StiHeaderBand {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        readonly helpUrl: string;
        growToHeight: boolean;
        resetPageNumber: boolean;
        startNewPage: boolean;
        startNewPageIfLessThan: number;
        printAtBottom: boolean;
        printOnAllPages: boolean;
        readonly localizedCategory: string;
        readonly localizedName: string;
        readonly isCross: boolean;
        getDockStyle(): StiDockStyle;
        setDockStyle(value: StiDockStyle): void;
        minWidth: number;
        maxWidth: number;
        readonly defaultClientRectangle: RectangleD;
        selectRectangle: RectangleD;
        displayRectangle: RectangleD;
        readonly headerSize: number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiIndicator implements IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromJsonObjectInternal(jObject: StiJson): StiIndicator;
        static loadFromXml(text: string): StiIndicator;
    }
}
declare module Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrushType = Stimulsoft.Report.Components.StiBrushType;
    class StiDataBarIndicator extends StiIndicator implements IStiDataBarIndicator, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _brushType;
        brushType: StiBrushType;
        private _positiveColor;
        positiveColor: Color;
        private _negativeColor;
        negativeColor: Color;
        private _positiveBorderColor;
        positiveBorderColor: Color;
        private _negativeBorderColor;
        negativeBorderColor: Color;
        private _showBorder;
        showBorder: boolean;
        private _value;
        value: number;
        private _minimum;
        minimum: number;
        private _maximum;
        maximum: number;
        private _direction;
        direction: StiDataBarDirection;
        constructor(brushType?: StiBrushType, positiveColor?: Color, negativeColor?: Color, showBorder?: boolean, positiveBorderColor?: Color, negativeBorderColor?: Color, direction?: StiDataBarDirection, value?: number, minimum?: number, maximum?: number);
    }
}
declare module Stimulsoft.Report.Components {
    import StiIcon = Stimulsoft.Report.Components.StiIcon;
    class StiIconSetHelper {
        static getIconSet(iconSet: StiIconSet): StiIcon[];
        static getIcons(iconSet: StiIconSet): string[];
        static getIcon(icon: StiIcon): string;
        private static getIcon2(name);
    }
}
declare module Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import ContentAlignment = Stimulsoft.System.Drawing.ContentAlignment;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiIconSetIndicator extends StiIndicator implements IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _icon;
        icon: StiIcon;
        private _alignment;
        alignment: ContentAlignment;
        constructor(icon?: StiIcon, alignment?: ContentAlignment);
    }
}
declare module Stimulsoft.Report.Components {
    var IStiAnchor: string;
    interface IStiAnchor {
        anchor: StiAnchorMode;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiAutoWidth: string;
    interface IStiAutoWidth {
        autoWidth: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiBorderColor: string;
    interface IStiBorderColor {
        borderColor: Color;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiBreakable: string;
    interface IStiBreakable {
        canBreak: boolean;
        break(dividedComponent: StiComponent, devideFactor: number, REFdivideLine: any): boolean;
    }
}
declare module Stimulsoft.Report.Components {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiBrush: string;
    interface IStiBrush {
        brush: StiBrush;
    }
}
declare module Stimulsoft.Report.Components {
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    var IStiBusinessObject: string;
    interface IStiBusinessObject {
        businessObject: StiBusinessObject;
        businessObjectGuid: string;
        isBusinessObjectEmpty: boolean;
        first(): any;
        prior(): any;
        next(): any;
        last(): any;
        position: number;
        count: number;
        isEof: boolean;
        isBof: boolean;
        isEmpty: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiCanGrow: string;
    interface IStiCanGrow {
        canGrow: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiCanShrink: string;
    interface IStiCanShrink {
        canShrink: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    import ICloneable = Stimulsoft.System.ICloneable;
    var IStiComponent: string;
    interface IStiComponent extends ICloneable, IStiGrowToHeight, IStiPrintOn, IStiName {
        report: StiReport;
        parent: StiContainer;
        growToHeight: boolean;
        printOn: StiPrintOnType;
        printable: boolean;
        enabled: boolean;
        dockStyle: StiDockStyle;
        name: string;
        isDesigning: boolean;
        guid: string;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiComponentGuid: string;
    interface IStiComponentGuid {
        guid: string;
        newGuid(): any;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiComponentsOwnerRenderer: string;
    interface IStiComponentsOwnerRenderer {
    }
}
declare module Stimulsoft.Report.Components {
    var IStiConditions: string;
    interface IStiConditions {
        conditions: StiConditionsCollection;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiCrossTab: string;
    interface IStiCrossTab {
    }
}
declare module Stimulsoft.Report.Components {
    var IStiCrossTabField: string;
    interface IStiCrossTabField {
    }
}
declare module Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrushType = Stimulsoft.Report.Components.StiBrushType;
    var IStiDataBarIndicator: string;
    interface IStiDataBarIndicator {
        brushType: StiBrushType;
        positiveColor: Color;
        negativeColor: Color;
        positiveBorderColor: Color;
        negativeBorderColor: Color;
        showBorder: boolean;
        direction: StiDataBarDirection;
    }
}
declare module Stimulsoft.Report.Components {
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    var IStiDataRelation: string;
    interface IStiDataRelation {
        dataRelation: StiDataRelation;
        dataRelationName: string;
    }
}
declare module Stimulsoft.Report.Components {
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    var IStiDataSource: string;
    interface IStiDataSource {
        dataSource: StiDataSource;
        dataSourceName: string;
        isDataSourceEmpty: boolean;
        first(): any;
        prior(): any;
        next(): any;
        last(): any;
        position: number;
        count: number;
        isEof: boolean;
        isBof: boolean;
        isEmpty: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    import Image = Stimulsoft.System.Drawing.Image;
    var IStiExportImage: string;
    interface IStiExportImage {
        getImage(REFzoom: any, format?: StiExportFormat): Image;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiExportImageExtended: string;
    interface IStiExportImageExtended extends IStiExportImage {
        isExportAsImage(format: StiExportFormat): boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiFilter: string;
    interface IStiFilter {
        filterMethodHandler: Function;
        filterMode: StiFilterMode;
        filters: StiFiltersCollection;
        filterOn: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    import Font = Stimulsoft.System.Drawing.Font;
    var IStiFont: string;
    interface IStiFont {
        font: Font;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiGroup: string;
    interface IStiGroup {
        sortDirection: StiGroupSortDirection;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiGrowToHeight: string;
    interface IStiGrowToHeight {
        growToHeight: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiIgnoreBorderWhenExport: string;
    interface IStiIgnoreBorderWhenExport {
    }
}
declare module Stimulsoft.Report.Components {
    var IStiIndicatorCondition: string;
    interface IStiIndicatorCondition {
        createIndicator(component: StiText): StiIndicator;
        reset(): any;
    }
}
declare module Stimulsoft.Report.Components {
    interface IStiInteractionClass {
    }
}
declare module Stimulsoft.Report.Components {
    var IStiKeepChildTogether: string;
    interface IStiKeepChildTogether {
        keepChildTogether: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiKeepDetailsTogether: string;
    interface IStiKeepDetailsTogether {
        keepDetailsTogether: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiKeepFooterTogether: string;
    interface IStiKeepFooterTogether {
        keepFooterTogether: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiKeepGroupFooterTogether: string;
    interface IStiKeepGroupFooterTogether {
        keepGroupFooterTogether: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiKeepGroupTogether: string;
    interface IStiKeepGroupTogether {
        keepGroupTogether: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiKeepHeaderTogether: string;
    interface IStiKeepHeaderTogether {
        keepHeaderTogether: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiKeepReportSummaryTogether: string;
    interface IStiKeepReportSummaryTogether {
        keepReportSummaryTogether: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiMasterComponent: string;
    interface IStiMasterComponent {
        masterComponent: StiComponent;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiOddEvenStyles: string;
    interface IStiOddEvenStyles {
        evenStyle: string;
        oddStyle: string;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiPageBreak: string;
    interface IStiPageBreak {
        newColumnBefore: boolean;
        newColumnAfter: boolean;
        newPageBefore: boolean;
        newPageAfter: boolean;
        breakIfLessThan: number;
        skipFirst: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiPrintAtBottom: string;
    interface IStiPrintAtBottom {
        printAtBottom: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiPrintIfDetailEmpty: string;
    interface IStiPrintIfDetailEmpty {
        printIfDetailEmpty: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiPrintIfEmpty: string;
    interface IStiPrintIfEmpty {
        printIfEmpty: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiPrintOn: string;
    interface IStiPrintOn {
        printOn: StiPrintOnType;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiPrintOnAllPages: string;
    interface IStiPrintOnAllPages {
        printOnAllPages: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiPrintOnEvenOddPages: string;
    interface IStiPrintOnEvenOddPages {
        printOnEvenOddPages: StiPrintOnEvenOddPagesType;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiRenderMaster: string;
    interface IStiRenderMaster {
        renderMaster(): any;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiResetPageNumber: string;
    interface IStiResetPageNumber {
        resetPageNumber: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    interface IStiSeriesParent {
        parent: StiComponent;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiShape: string;
    interface IStiShape {
    }
}
declare module Stimulsoft.Report.Components {
    var IStiShift: string;
    interface IStiShift {
        shift: boolean;
        shiftMode: StiShiftMode;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiSort: string;
    interface IStiSort {
        sort: Array<string>;
    }
}
declare module Stimulsoft.Report.Components {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiTextBrush: string;
    interface IStiTextBrush {
        textBrush: StiBrush;
    }
}
declare module Stimulsoft.Report.Components {
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    var IStiTextHorAlignment: string;
    interface IStiTextHorAlignment {
        horAlignment: StiTextHorAlignment;
    }
}
declare module Stimulsoft.Report.Components {
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    var IStiTextOptions: string;
    interface IStiTextOptions {
        textOptions: StiTextOptions;
    }
}
declare module Stimulsoft.Report.Components {
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    var IStiUnitConvert: string;
    interface IStiUnitConvert {
        convert(oldUnit: StiUnit, newUnit: StiUnit): any;
    }
}
declare module Stimulsoft.Report.Components {
    enum StiShapeDirection {
        Up = 0,
        Down = 1,
        Left = 2,
        Right = 3,
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiShapeTypeService extends StiService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromJsonObjectInternal(jObject: StiJson): StiShapeTypeService;
        loadFromXml(xmlNode: XmlNode): void;
        static convertFromXml(xmlNode: XmlNode): StiShapeTypeService;
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiArrowShapeType extends StiShapeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _direction;
        direction: StiShapeDirection;
        private _arrowWidth;
        arrowWidth: number;
        private _arrowHeight;
        arrowHeight: number;
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection, arrowWidth?: number, arrowHeight?: number);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiBentArrowShapeType extends StiShapeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _direction;
        direction: StiShapeDirection;
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiChevronShapeType extends StiShapeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _direction;
        direction: StiShapeDirection;
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiComplexArrowShapeType extends StiShapeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _direction;
        direction: StiShapeDirection;
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection);
    }
}
declare module Stimulsoft.Report.Components {
    class StiDiagonalDownLineShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiDiagonalUpLineShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiDivisionShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiEqualShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiFlowchartCardShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiFlowchartCollateShapeType extends StiShapeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _direction;
        direction: StiShapeDirection;
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection);
    }
}
declare module Stimulsoft.Report.Components {
    class StiFlowchartDecisionShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiFlowchartManualInputShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiFlowchartOffPageConnectorShapeType extends StiShapeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _direction;
        direction: StiShapeDirection;
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiFlowchartPreparationShapeType extends StiShapeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _direction;
        direction: StiShapeDirection;
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection);
    }
}
declare module Stimulsoft.Report.Components {
    class StiFlowchartSortShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiFrameShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiHorizontalLineShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiLeftAndRightLineShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiMinusShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiMultiplyShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiOctagonShapeType extends StiShapeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _autoSize;
        autoSize: boolean;
        private _bevel;
        bevel: number;
        createNew(): StiShapeTypeService;
        constructor(autoSize?: boolean, bevel?: number);
    }
}
declare module Stimulsoft.Report.Components {
    class StiOvalShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiParallelogramShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiPlusShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiRectangleShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiRegularPentagonShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiRoundedRectangleShapeType extends StiShapeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _round;
        round: number;
        createNew(): StiShapeTypeService;
        constructor(round?: number);
    }
}
declare module Stimulsoft.Report.Components {
    class StiSnipDiagonalSideCornerRectangleShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiSnipSameSideCornerRectangleShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiTopAndBottomLineShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiTrapezoidShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiTriangleShapeType extends StiShapeTypeService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): Object;
        private _direction;
        direction: StiShapeDirection;
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection);
    }
}
declare module Stimulsoft.Report.Components {
    class StiVerticalLineShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetCheckedEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Components {
    import StiGetExcelValueEventArgs = Stimulsoft.Report.Events.StiGetExcelValueEventArgs;
    import StiGetExcelValueEvent = Stimulsoft.Report.Events.StiGetExcelValueEvent;
    import StiGetCheckedEvent = Stimulsoft.Report.Events.StiGetCheckedEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiEditable = Stimulsoft.Report.Components.IStiEditable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    class StiCheckBox extends StiComponent implements IStiBorder, IStiTextBrush, IStiBrush, IStiBreakable, IStiEditable {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _brush;
        brush: StiBrush;
        private _border;
        border: StiBorder;
        private _textBrush;
        textBrush: StiBrush;
        private _editable;
        editable: boolean;
        clone(cloneProperties: boolean): StiCheckBox;
        private _canBreak;
        canBreak: boolean;
        break(dividedComponent: StiComponent, devideFactor: number, REFdivideLine: any): boolean;
        invokeEvents(): void;
        private static eventGetChecked;
        protected onGetChecked(e: StiValueEventArgs): void;
        invokeGetChecked(sender: StiComponent, e: StiValueEventArgs): void;
        getCheckedEvent: StiGetCheckedEvent;
        private static eventGetExcelValue;
        protected onGetExcelValue(e: StiGetExcelValueEventArgs): void;
        invokeGetExcelValue(sender: StiComponent, e: StiGetExcelValueEventArgs): void;
        getExcelValueEvent: StiGetExcelValueEvent;
        private _checkedValue;
        checkedValue: Object;
        private _contourColor;
        contourColor: Color;
        private _size;
        size: number;
        private _checkStyle;
        checkStyle: StiCheckStyle;
        private _values;
        values: string;
        private _checkStyleForTrue;
        checkStyleForTrue: StiCheckStyle;
        private _checkStyleForFalse;
        checkStyleForFalse: StiCheckStyle;
        private _checked;
        checked: string;
        private _excelDataValue;
        excelDataValue: string;
        private _excelValue;
        excelValue: string;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiContourText extends StiText {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _contourColor;
        contourColor: Color;
        private _size;
        size: number;
        constructor(rect?: RectangleD, text?: string);
    }
}
declare module Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPrimitive extends StiComponent {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        canShrink: boolean;
        canGrow: boolean;
        shift: boolean;
        useParentStyles: boolean;
        dockStyle: StiDockStyle;
        growToHeight: boolean;
        conditions: StiConditionsCollection;
        readonly localizedCategory: string;
        readonly componentType: StiComponentType;
        readonly priority: number;
        clientRectangle: RectangleD;
        getDisplayRectangle(): RectangleD;
        setDisplayRectangle(value: RectangleD): void;
        setDirectDisplayRectangle(rect: RectangleD): void;
        constructor(rect?: RectangleD, isSuper?: boolean);
        protected construct(rect?: RectangleD | any): void;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLinePrimitive extends StiPrimitive {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly invalidateOnMouseOver: boolean;
        readonly defaultClientRectangle: RectangleD;
        private _style;
        style: StiPenStyle;
        private _color;
        color: Color;
        private _size;
        size: number;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCrossLinePrimitive extends StiLinePrimitive {
        static nullGuid: string;
        onRemoveComponent(): void;
        canContainIn(component: StiComponent): boolean;
        linked: boolean;
        left: number;
        top: number;
        height: number;
        storedStartPoint: StiStartPointPrimitive;
        getStartPoint(cont?: StiContainer): StiStartPointPrimitive;
        storedEndPoint: StiEndPointPrimitive;
        getEndPoint(cont?: StiContainer): StiEndPointPrimitive;
        isParentContainerSelected(point: StiPointPrimitive): boolean;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPointPrimitive extends StiPrimitive {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        isSelected: boolean;
        private _referenceToGuid;
        referenceToGuid: string;
        width: number;
        height: number;
        storedColumn: number;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEndPointPrimitive extends StiPointPrimitive {
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiCap = Stimulsoft.Base.Drawing.StiCap;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHorizontalLinePrimitive extends StiLinePrimitive implements IStiBorder {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean): Object;
        private _border;
        border: StiBorder;
        private _startCap;
        startCap: StiCap;
        private _endCap;
        endCap: StiCap;
        height: number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    import Image = Stimulsoft.System.Drawing.Image;
    let StiGetImageDataEventHandler: EventHandler;
    class StiGetImageDataEventArgs extends EventArgs {
        value: Image;
        constructor(image?: Image);
    }
}
declare module Stimulsoft.Report.Helpers {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiExpressionHelper {
        static parseText(page: StiPage, text: string): string;
        static parseBool(page: StiPage, text: string): boolean;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetImageDataEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetImageURLEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Components {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImageHelper {
        static getImageFromObject(imageObject: Object): Image;
        private static getImageName(data);
        private static isXml(data);
        private static isSvg(data);
        private static isIcon(data);
        private static isWmf(data);
        private static isEmf(data);
        private static isBmp(data);
        private static isJpeg(data);
        private static isGif(data);
        private static isPng(data);
        private static isTiff(data);
        static isImage(data: any): boolean;
        static isImage2(data: number[]): boolean;
        static isImage3(str: string): boolean;
    }
}
declare module Stimulsoft.Report {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiFileImageCache {
        private static imageCache;
        static createNewCache(): string;
        static getImageCacheName(cache: string, cacheImageGuid: string): string;
        static saveImage(image: Image, path: string): void;
        static loadImage(path: string): Image;
        static exist(cacheGuid: string): boolean;
        static clear(): void;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiView extends StiComponent implements IStiHorAlignment, IStiVertAlignment, IStiBorder, IStiExportImage, IStiExportImageExtended, IStiBrush {
        private static ImplementsStiView;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean): StiView;
        private _horAlignment;
        /** Gets or sets the horizontal alignment of an object. */
        horAlignment: StiHorAlignment;
        private _vertAlignment;
        /** Gets or sets the vertical alignment of an object. */
        vertAlignment: StiVertAlignment;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        private _border;
        /** Gets or sets border of the component. */
        border: StiBorder;
        private _brush;
        /** Gets or sets a brush to fill a component. */
        brush: StiBrush;
        getActualSize(): SizeD;
        getRealSize(): SizeD;
        setPage(value: StiPage): void;
        private _smoothing;
        /** Gets or sets smoothing mode for drawing image. */
        smoothing: boolean;
        private _isCachedImage;
        isCachedImage: boolean;
        private _objectToDraw;
        /** Gets or sets the WPF visual object that appeared as a result of the component rendering. This property accepts objects of two types: DrawingVisual and ImageSource. */
        objectToDraw: Object;
        private _imageToDraw;
        /** Gets or sets the image that appeared as a result of the component rendering. */
        imageToDraw: Image;
        private _stretch;
        /** Gets or sets value, indicates that this component will stretch the image till the image will get size equal in its size on the page. */
        stretch: boolean;
        private _multipleFactor;
        /** Gets or sets value to multiply by it an image size. */
        multipleFactor: number;
        private _aspectRatio;
        /** Gets or sets value, indicates that the image will save its aspect ratio. */
        aspectRatio: boolean;
        getImageFromSource(): Image;
    }
}
declare module Stimulsoft.Report.Components {
    import StiGetImageDataEventArgs = Stimulsoft.Report.Events.StiGetImageDataEventArgs;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import StiGetImageDataEvent = Stimulsoft.Report.Events.StiGetImageDataEvent;
    import StiGetImageURLEvent = Stimulsoft.Report.Events.StiGetImageURLEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiBreakable = Stimulsoft.Report.Components.IStiBreakable;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiImage extends StiView implements IStiBreakable {
        private static ImplementsStiImage;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        protected getImageFromFile(): Image;
        protected getImageFromUrl(): Image;
        /** Returns the image from specified data column. */
        protected getImageFromDataColumn(): Image;
        /** Returns the image being get as a result of rendering. */
        getImageFromSource(): Image;
        private static propertyCanBreak;
        /** Gets or sets value which indicates whether the component can or cannot break its contents on several pages. */
        canBreak: boolean;
        /** Divides content of components in two parts.Returns result of dividing.If true, then component is successful divided. */
        break(dividedComponent: StiComponent, devideFactor: number, REFdivideLine: any): boolean;
        private _imageURLValue;
        imageURLValue: Object;
        invokeEvents(): void;
        private static eventGetImageURL;
        protected onGetImageURL(e: StiValueEventArgs): void;
        invokeGetImageURL(sender: Object, e: StiValueEventArgs): void;
        getImageURLEvent: StiGetImageURLEvent;
        private static eventGetImageData;
        protected onGetImageData(e: StiGetImageDataEventArgs): void;
        invokeGetImageData(sender: Object, e: StiGetImageDataEventArgs): void;
        readonly defaultClientRectangle: RectangleD;
        getImageDataEvent: StiGetImageDataEvent;
        private static propertyProcessingDuplicates;
        /** Gets or sets value which indicates how report engine processes duplicated images. */
        processingDuplicates: StiImageProcessingDuplicatesType;
        private _imageRotation;
        /** Gets or sets value which indicates how to rotate an image before output. */
        imageRotation: StiImageRotation;
        private _image;
        /** Gets or sets the image. */
        image: Image;
        private static propertyMargins;
        /** Gets or sets image margins. */
        margins: StiMargins;
        private _file;
        /** Gets or sets the path to the file that contains the image. */
        file: string;
        private _dataColumn;
        /** Gets or sets a name of the column that contains the image. */
        dataColumn: string;
        private _imageURL;
        imageURL: string;
        private _imageData;
        imageData: string;
        convertImageMargins(rect: RectangleD, convert: boolean): RectangleD;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRectanglePrimitive extends StiCrossLinePrimitive implements IStiBorder {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _border;
        border: StiBorder;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        width: number;
        private _topSide;
        topSide: boolean;
        private _leftSide;
        leftSide: boolean;
        private _bottomSide;
        bottomSide: boolean;
        private _rightSide;
        rightSide: boolean;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetDataUrlEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Components {
    import StiGetDataUrlEventArgs = Stimulsoft.Report.Events.StiGetDataUrlEventArgs;
    import StiGetDataUrlEvent = Stimulsoft.Report.Events.StiGetDataUrlEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiEditable = Stimulsoft.Report.Components.IStiEditable;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiRichText extends StiSimpleText implements IStiEditable, IStiBorder, IStiGlobalizationProvider, IStiBackColor {
        private static implementsStiRichText;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        protected static propertyCanBreak: string;
        canBreak: boolean;
        clone(cloneProperties: boolean): StiRichText;
        private static eventGetDataUrl;
        protected onGetDataUrl(e: StiGetDataUrlEventArgs): void;
        invokeGetDataUrl(sender: StiComponent, e: StiGetDataUrlEventArgs): void;
        getDataUrlEvent: StiGetDataUrlEvent;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        private _border;
        border: StiBorder;
        private _margins;
        margins: StiMargins;
        private _defaultFont;
        defaultFont: Font;
        private _defaultColor;
        defaultColor: Color;
        private _wordWrap;
        wordWrap: boolean;
        private _detectUrls;
        detectUrls: boolean;
        private _backColor;
        backColor: Color;
        private _dataColumn;
        dataColumn: string;
        private _wysiwyg;
        wysiwyg: boolean;
        private _rightToLeft;
        rightToLeft: boolean;
        private _dataUrl;
        dataUrl: string;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRoundedRectanglePrimitive extends StiRectanglePrimitive {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _round;
        round: number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import Image = Stimulsoft.System.Drawing.Image;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import IStiBorderColor = Stimulsoft.Report.Components.IStiBorderColor;
    import IStiShape = Stimulsoft.Report.Components.IStiShape;
    class StiShape extends StiComponent implements IStiBrush, IStiBorderColor, IStiExportImageExtended, IStiExportImage, IStiShape {
        private _implementsStiShape;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean): StiShape;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        private _brush;
        brush: StiBrush;
        private _borderColor;
        borderColor: Color;
        readonly defaultClientRectangle: RectangleD;
        private _style;
        style: StiPenStyle;
        private _size;
        size: number;
        private _shapeType;
        shapeType: StiShapeTypeService;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStartPointPrimitive extends StiPointPrimitive {
        readonly componentId: StiComponentId;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiCap = Stimulsoft.Base.Drawing.StiCap;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiVerticalLinePrimitive extends StiCrossLinePrimitive implements IStiBorder {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean): Object;
        private _border;
        border: StiBorder;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        private _startCap;
        startCap: StiCap;
        private _endCap;
        endCap: StiCap;
        width: number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components.Table {
    enum StiTableStyle {
        StyleNone = 0,
        Style11 = 11,
        Style12 = 12,
        Style13 = 13,
        Style14 = 14,
        Style15 = 15,
        Style16 = 16,
        Style17 = 17,
        Style18 = 18,
        Style19 = 19,
        Style31 = 31,
        Style32 = 32,
        Style33 = 33,
        Style34 = 34,
        Style35 = 35,
        Style36 = 36,
        Style37 = 37,
        Style38 = 38,
        Style39 = 39,
        Style41 = 41,
        Style42 = 42,
        Style43 = 43,
        Style44 = 44,
        Style45 = 45,
        Style46 = 46,
        Style47 = 47,
        Style48 = 48,
        Style49 = 49,
        Style51 = 51,
        Style52 = 52,
        Style53 = 53,
        Style54 = 54,
        Style55 = 55,
        Style56 = 56,
        Style57 = 57,
        Style58 = 58,
        Style59 = 59,
    }
    enum StiTablceCellType {
        Text = 0,
        Image = 1,
        CheckBox = 2,
        RichText = 3,
    }
    enum StiTableAutoWidth {
        None = 0,
        Page = 1,
        Table = 2,
    }
    enum StiTableAutoWidthType {
        None = 0,
        LastColumns = 1,
        FullTable = 2,
    }
}
declare module Stimulsoft.Report.Components.Table {
    var IStiTableCell: string;
    interface IStiTableCell {
        joinCells: number[];
        parentJoin: number;
        join: boolean;
        id: number;
        joinWidth: number;
        joinHeight: number;
        merged: boolean;
        changeTopPosition: boolean;
        changeLeftPosition: boolean;
        changeRightPosition: boolean;
        cellType: StiTablceCellType;
        cellDockStyle: StiDockStyle;
        column: number;
        fixedWidth: boolean;
        tableTag: Object;
        parentJoinCell: StiComponent;
        getJoinComponentByGuid(id: number): StiComponent;
        getJoinComponentByIndex(index: number): StiComponent;
        containsGuid(id: number): boolean;
        setJoinSize(): any;
        getRealHeightAfterInsertRows(): number;
        getRealHeight(): number;
        getRealTop(): number;
        getRealWidth(): number;
        getRealLeft(): number;
    }
}
declare module Stimulsoft.Report.Components.Table {
    var IStiTableComponent: string;
    interface IStiTableComponent {
    }
}
declare module Stimulsoft.Report.Components.Table {
    class StiColumnSize {
        private _widths;
        private _fixedColumn;
        setFixedColumn(indexCol: number, width: number): void;
        add(indexCol: number, width: number): void;
        addLastNotFixed(width: number): void;
        subtract(indexCol: number, width: number): void;
        setWidth(indexCol: number, width: number): void;
        getFixed(index: number): boolean;
        readonly length: number;
        getCountNotFixedColumn(): number;
        getWidth(indexCol: number): number;
        normalize(): void;
        constructor(size: number);
    }
}
declare module Stimulsoft.Report.Components.Table {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTable extends StiDataBand implements IStiTableComponent {
        private static ImplementsStiTable;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        clone(cloneProperties: boolean, cloneComponents: boolean): StiTable;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        canGrow: boolean;
        readonly localizedName: string;
        readonly localizedCategory: string;
        isConverted: boolean;
        private _dockableTable;
        dockableTable: boolean;
        private _autoWidth;
        autoWidth: StiTableAutoWidth;
        private _autoWidthType;
        autoWidthType: StiTableAutoWidthType;
        private _rowCount;
        rowCount: number;
        private _columnCount;
        columnCount: number;
        private _footerRowsCount;
        footerRowsCount: number;
        private _headerRowsCount;
        headerRowsCount: number;
        readonly defaultHeightCell: number;
        private _headerPrintOn;
        headerPrintOn: StiPrintOnType;
        private _headerCanGrow;
        headerCanGrow: boolean;
        private _headerCanShrink;
        headerCanShrink: boolean;
        private _headerCanBreak;
        headerCanBreak: boolean;
        private _headerPrintAtBottom;
        headerPrintAtBottom: boolean;
        private _headerPrintIfEmpty;
        headerPrintIfEmpty: boolean;
        private _headerPrintOnAllPages;
        headerPrintOnAllPages: boolean;
        private _headerPrintOnEvenOddPages;
        headerPrintOnEvenOddPages: StiPrintOnEvenOddPagesType;
        private _footerPrintOn;
        footerPrintOn: StiPrintOnType;
        private _footerCanGrow;
        footerCanGrow: boolean;
        private _footerCanShrink;
        footerCanShrink: boolean;
        private _footerCanBreak;
        footerCanBreak: boolean;
        private _footerPrintAtBottom;
        footerPrintAtBottom: boolean;
        private _footerPrintIfEmpty;
        footerPrintIfEmpty: boolean;
        private _footerPrintOnAllPages;
        footerPrintOnAllPages: boolean;
        private _footerPrintOnEvenOddPages;
        footerPrintOnEvenOddPages: StiPrintOnEvenOddPagesType;
        private _numberID;
        numberID: number;
        readonly columns: number;
        readonly columnWidth: number;
        readonly columnGaps: number;
        readonly minRowsInColumn: number;
        minHeight: number;
        maxHeight: number;
        minSize: SizeD;
        rightToLeft: boolean;
        width: number;
        height: number;
        readonly defaultClientRectangle: RectangleD;
        dockable: boolean;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        changeGrowToHeightAtCell(cell: StiComponent): void;
        private _tableStyle;
        tableStyle: StiTableStyle;
        private refreshTableStyle();
        applyStyleNone(): void;
        private applyStyleNoneForCell(cell);
        private applyStyle1(style);
        private applyStyle3(style);
        private applyStyle4(style);
        private applyStyle5(style);
        private changeRowCount(oldValue, value);
        private changeColumnCount(oldValue, value);
        createJoin(REFsumWidth: any, REFsumHeight: any, REFjoinWidth: any, REFjoinHeight: any): number[];
        private getCountSelectedCells();
        private getCountJoinSelectedCells(REFcountJoin);
        private findLeftSelectedElement(allX, REFleftX, REFrightX);
        private findRightSelectedElement(allY, REFleftY, REFrightY);
        changeTableCellContentInImage(cell: StiTableCell | StiTableCellCheckBox | StiTableCellRichText): any;
        changeTableCellContentInText(cell: StiTableCellImage | StiTableCellCheckBox | StiTableCellRichText): void;
        changeTableCellContentInCheckBox(cell: StiTableCellImage | StiTableCell | StiTableCellRichText): void;
        changeTableCellContentInRichText(cell: StiTableCell | StiTableCellImage | StiTableCellCheckBox): void;
        getColumnForCell(cell: IStiTableCell): number;
        private setCellID(cell);
        createCell(): void;
        private setStyleForCell(cell, select);
        private addNewRows(count);
        private deleteLastRows(count, oldValue);
        private addTableNewColumns(count, oldValue);
        private deleteTableColumns(count, oldValue);
        insertColumnToLeft(numberColumn: number): void;
        insertColumnToRight(numberColumn: number): void;
        insertRowAbove(numberRow: number): void;
        insertRowBelow(numberRow: number): void;
        deleteRows(firstRow: number, lastRow: number): StiComponent[];
        deleteColumns(firstColumn: number, lastColumn: number): Array<StiComponent>;
        distributeRows(): void;
        distributeColumns(): void;
        autoSizeCells(): void;
        private resizeWidthCellsAfterChanges();
        private resizeHeightCellsAfterChanges(changeHeight);
        private resizeWidthCell(oldWidth);
        private resizeHeightCell();
        startRenderTableBand(REFnewTableComponents: any): StiDataBand;
        private startRenderTable(parentContainer, index, REFnewTableComponents);
        private reverseCells(rightToLeft);
        private setFilter(comp);
        private setInteraction(cell);
        private getParentJoin(id, REFrowNumber);
        private isEqualRows(comp1, comp2);
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components.Table {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiTableCell extends StiText implements IStiTableCell, IStiTableComponent {
        private static ImplementsStiTableCell;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private loadJoinCellsFromXml(xmlNode);
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        clone(cloneProperties: boolean): StiTableCell;
        readonly locked: boolean;
        readonly linked: boolean;
        canGrow: boolean;
        readonly autoWidth: boolean;
        private _cellDockStyle;
        cellDockStyle: StiDockStyle;
        private _parentJoinCell;
        parentJoinCell: StiComponent;
        _joinCells: number[];
        joinCells: number[];
        _parentJoin: number;
        parentJoin: number;
        _join: boolean;
        join: boolean;
        private _id;
        id: number;
        private _joinWidth;
        joinWidth: number;
        private _joinHeight;
        joinHeight: number;
        readonly merged: boolean;
        readonly changeTopPosition: boolean;
        readonly changeLeftPosition: boolean;
        readonly changeRightPosition: boolean;
        private _tableTag;
        tableTag: Object;
        private _cellType;
        cellType: StiTablceCellType;
        private _fixedWidth;
        fixedWidth: boolean;
        private _column;
        column: number;
        getJoinComponentByGuid(id: number): StiComponent;
        getJoinComponentByIndex(index: number): StiComponent;
        containsGuid(id: number): boolean;
        private createJoin();
        private deleteJoin();
        private getNewClientRectangle();
        setJoinSize(): void;
        getRealHeightAfterInsertRows(): number;
        getRealHeight(): number;
        getRealTop(): number;
        getRealWidth(): number;
        getRealLeft(): number;
        createNew(): StiComponent;
    }
}
declare module Stimulsoft.Report.Components.Table {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiTableCellCheckBox extends StiCheckBox implements IStiTableCell, IStiTableComponent {
        private static ImplementsStiTableCellCheckBox;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private loadJoinCellsFromXml(xmlNode);
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        clone(cloneProperties: boolean): StiTableCellCheckBox;
        readonly locked: boolean;
        readonly linked: boolean;
        canShrink: boolean;
        canGrow: boolean;
        private _cellDockStyle;
        cellDockStyle: StiDockStyle;
        private _parentJoinCell;
        parentJoinCell: StiComponent;
        _joinCells: number[];
        joinCells: number[];
        _parentJoin: number;
        parentJoin: number;
        _join: boolean;
        join: boolean;
        private _id;
        id: number;
        private _joinWidth;
        joinWidth: number;
        private _joinHeight;
        joinHeight: number;
        readonly merged: boolean;
        readonly changeTopPosition: boolean;
        readonly changeLeftPosition: boolean;
        readonly changeRightPosition: boolean;
        private _tableTag;
        tableTag: Object;
        private _cellType;
        cellType: StiTablceCellType;
        private _fixedWidth;
        fixedWidth: boolean;
        private _column;
        column: number;
        getJoinComponentByGuid(id: number): StiComponent;
        getJoinComponentByIndex(index: number): StiComponent;
        containsGuid(id: number): boolean;
        private createJoin();
        private deleteJoin();
        private getNewClientRectangle();
        setJoinSize(): void;
        getRealHeightAfterInsertRows(): number;
        getRealHeight(): number;
        getRealTop(): number;
        getRealWidth(): number;
        getRealLeft(): number;
        createNew(): StiComponent;
    }
}
declare module Stimulsoft.Report.Components.Table {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiTableCellImage extends StiImage implements IStiTableCell, IStiTableComponent {
        private static ImplementsStiTableCellImage;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private loadJoinCellsFromXml(xmlNode);
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        clone(cloneProperties: boolean): StiTableCellImage;
        readonly locked: boolean;
        readonly linked: boolean;
        canShrink: boolean;
        canGrow: boolean;
        private _cellDockStyle;
        cellDockStyle: StiDockStyle;
        private _parentJoinCell;
        parentJoinCell: StiComponent;
        _joinCells: number[];
        joinCells: number[];
        _parentJoin: number;
        parentJoin: number;
        _join: boolean;
        join: boolean;
        private _id;
        id: number;
        private _joinWidth;
        joinWidth: number;
        private _joinHeight;
        joinHeight: number;
        readonly merged: boolean;
        readonly changeTopPosition: boolean;
        readonly changeLeftPosition: boolean;
        readonly changeRightPosition: boolean;
        private _tableTag;
        tableTag: Object;
        private _cellType;
        cellType: StiTablceCellType;
        private _fixedWidth;
        fixedWidth: boolean;
        private _column;
        column: number;
        getJoinComponentByGuid(id: number): StiComponent;
        getJoinComponentByIndex(index: number): StiComponent;
        containsGuid(id: number): boolean;
        private createJoin();
        private deleteJoin();
        private getNewClientRectangle();
        setJoinSize(): void;
        getRealHeightAfterInsertRows(): number;
        getRealHeight(): number;
        getRealTop(): number;
        getRealWidth(): number;
        getRealLeft(): number;
        createNew(): StiComponent;
    }
}
declare module Stimulsoft.Report.Components.Table {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiTableCellRichText extends StiRichText implements IStiTableCell, IStiTableComponent {
        private static ImplementsStiTableCellRichText;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private loadJoinCellsFromXml(xmlNode);
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        clone(cloneProperties: boolean): StiTableCellRichText;
        readonly locked: boolean;
        readonly linked: boolean;
        canShrink: boolean;
        canGrow: boolean;
        private _cellDockStyle;
        cellDockStyle: StiDockStyle;
        private _parentJoinCell;
        parentJoinCell: StiComponent;
        _joinCells: number[];
        joinCells: number[];
        _parentJoin: number;
        parentJoin: number;
        _join: boolean;
        join: boolean;
        private _id;
        id: number;
        private _joinWidth;
        joinWidth: number;
        private _joinHeight;
        joinHeight: number;
        readonly merged: boolean;
        readonly changeTopPosition: boolean;
        readonly changeLeftPosition: boolean;
        readonly changeRightPosition: boolean;
        private _tableTag;
        tableTag: Object;
        private _cellType;
        cellType: StiTablceCellType;
        private _fixedWidth;
        fixedWidth: boolean;
        private _column;
        column: number;
        getJoinComponentByGuid(id: number): StiComponent;
        getJoinComponentByIndex(index: number): StiComponent;
        containsGuid(id: number): boolean;
        private createJoin();
        private deleteJoin();
        private getNewClientRectangle();
        setJoinSize(): void;
        getRealHeightAfterInsertRows(): number;
        getRealHeight(): number;
        getRealTop(): number;
        getRealWidth(): number;
        getRealLeft(): number;
        createNew(): StiComponent;
        constructor();
    }
}
declare module Stimulsoft.Report.Components.TextFormats {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiBooleanFormatService extends StiFormatService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        private bits;
        falseValue: string;
        trueValue: string;
        falseDisplay: string;
        trueDisplay: string;
        nullDisplay: string;
        readonly sample: Object;
        stiEquals(obj: Object): boolean;
        format(arg: any): string;
        format2(format: string, arg: any): string;
        constructor(falseValue?: string, trueValue?: string, falseDisplay?: string, trueDisplay?: string, nullDisplay?: string);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionSortDirection = Stimulsoft.Report.Components.StiInteractionSortDirection;
    import StiDrillDownMode = Stimulsoft.Report.Components.StiDrillDownMode;
    class StiInteraction implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadInteractionFromJsonObject(jObject: StiJson): StiInteraction;
        static loadInteractionFromXml(xmlNode: XmlNode): Stimulsoft.Report.Components.StiInteraction;
        loadFromXml(xmlNode: XmlNode): void;
        getReport(): Object;
        clone(): StiInteraction;
        isDefault(): boolean;
        private _sortingEnabled;
        sortingEnabled: boolean;
        private _sortingColumn;
        sortingColumn: string;
        private _sortingIndex;
        sortingIndex: number;
        private _sortingDirection;
        sortingDirection: StiInteractionSortDirection;
        private _drillDownEnabled;
        drillDownEnabled: boolean;
        private _drillDownReport;
        drillDownReport: string;
        private _drillDownMode;
        drillDownMode: StiDrillDownMode;
        private _drillDownParameter1;
        drillDownParameter1: StiDrillDownParameter;
        private _drillDownParameter2;
        drillDownParameter2: StiDrillDownParameter;
        private _drillDownParameter3;
        drillDownParameter3: StiDrillDownParameter;
        private _drillDownParameter4;
        drillDownParameter4: StiDrillDownParameter;
        private _drillDownParameter5;
        drillDownParameter5: StiDrillDownParameter;
        drillDownPage: StiPage;
        private _drillDownPageGuid;
        drillDownPageGuid: string;
        bookmark: string;
        hyperlink: string;
        tag: string;
        toolTip: string;
        getSortDataBandName(): string;
        getSortColumns(): string[];
        getSortColumnsString(): string;
        parentComponent: StiComponent;
        constructor();
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiBandInteraction extends StiInteraction {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        isDefault(): boolean;
        collapsingEnabled: boolean;
        selectionEnabled: boolean;
        collapseGroupFooter: boolean;
        collapsed: string;
        selectedLine: number;
    }
}
declare module Stimulsoft.Report.Components {
    class StiBookmark {
        add(name: string): void;
        private _bookmarks;
        bookmarks: StiBookmarksCollection;
        private _text;
        text: string;
        private _componentGuid;
        componentGuid: string;
        private _isManualBookmark;
        isManualBookmark: boolean;
        private _pageIndex;
        pageIndex: number;
        constructor(text?: string, parentComponent?: Object);
    }
}
declare module Stimulsoft.Report.Components {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiBookmarksCollection extends CollectionBase<StiBookmark> {
        add(bookmark: StiBookmark): void;
        addRange(bookmarks: StiBookmark[]): any;
        addRange(bookmarks: StiBookmarksCollection): any;
        contains(bookmark: StiBookmark): boolean;
        indexOf(bookmark: StiBookmark): number;
        indexOf(name: string): number;
        insert(index: number, bookmark: StiBookmark): void;
        remove(bookmark: StiBookmark): void;
        getByName(name: string): StiBookmark;
        getByIndex(index: number): StiBookmark;
        setByIndex(index: number, bookmark: StiBookmark): void;
    }
}
declare module Stimulsoft.Report.Components {
    class StiComponentHelper {
        static fillComponentPlacement(component: StiComponent): void;
    }
}
declare module Stimulsoft.Report.Components {
    import EventArgs = Stimulsoft.System.EventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiComponentsCollection extends CollectionBase<StiComponent> implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        loadDocumentFromXml(xmlNode: XmlNode): void;
        clone(): StiComponentsCollection;
        memberwiseClone(): StiComponentsCollection;
        toList(): StiComponent[];
        private addCore(component);
        add(component: StiComponent): void;
        addRange(components: StiComponent[] | StiComponentsCollection): void;
        contains(component: StiComponent): boolean;
        indexOf(name: string): number;
        indexOf(component: StiComponent): number;
        insertRange(index: number, components: StiComponentsCollection): void;
        insert(index: number, component: StiComponent): void;
        remove(component: StiComponent): any;
        remove(component: StiComponent, clearParent: boolean): any;
        protected onComponentAdded(e: EventArgs): void;
        invokeComponentAdded(sender: Object, e: EventArgs): void;
        protected onComponentRemoved(e: EventArgs): void;
        invokeComponentRemoved(sender: Object, e: EventArgs): void;
        getByIndex(index: number): StiComponent;
        setByIndex(index: number, component: StiComponent): void;
        getByName(name: string): StiComponent;
        setByName(name: string, component: StiComponent): void;
        sortBySelectionTick(): void;
        sortByPriority(): void;
        sortByTopPosition(): void;
        sortByBottomPosition(): void;
        sortByLeftPosition(): void;
        sortByRightPosition(): void;
        sortBandsByTopPosition(): void;
        sortBandsByLeftPosition(): void;
        getComponentByName(componentName: string, container: StiContainer): StiComponent;
        getPageByAlias(alias: string): StiPage;
        setParent(parent: StiContainer): void;
        private parent;
        constructor(parent?: StiContainer);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCrossHeaderInteraction extends StiInteraction {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        isDefault(): boolean;
        private _collapsingEnabled;
        collapsingEnabled: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    var IStiEnumerator: string;
    interface IStiEnumerator {
        first(): any;
        prior(): any;
        next(): any;
        last(): any;
        position: number;
        count: number;
        isEof: boolean;
        isBof: boolean;
        isEmpty: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBusinessObjectsCollection = Stimulsoft.Report.Dictionary.StiBusinessObjectsCollection;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IEnumerator = Stimulsoft.System.Collections.IEnumerator;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiBusinessObject implements ICloneable, IStiStateSaveRestore, IStiEnumerator, IStiInherited, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _states;
        protected readonly states: StiStatesManager;
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        clearAllStates(): void;
        private _inherited;
        inherited: boolean;
        protected positionValue: number;
        position: number;
        countFiltered: number;
        readonly count: number;
        protected isBofValue: boolean;
        isBof: boolean;
        protected isEofValue: boolean;
        isEof: boolean;
        private _isEmpty;
        readonly isEmpty: boolean;
        private enumeratorReset();
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        clone(): StiBusinessObject;
        currentObject: Object;
        readonly current: Object;
        private readonly report;
        private _businessObjects;
        businessObjects: StiBusinessObjectsCollection;
        private _columns;
        columns: StiDataColumnsCollection;
        private _guid;
        guid: string;
        private _category;
        category: string;
        private _name;
        name: string;
        private _alias;
        alias: string;
        private _businessObjectValue;
        businessObjectValue: Object;
        private _dictionary;
        dictionary: StiDictionary;
        private _parentBusinessObject;
        parentBusinessObject: StiBusinessObject;
        private _ownerBand;
        ownerBand: StiDataBand;
        private _key;
        key: string;
        private static _fieldsIgnoreList;
        static fieldsIgnoreList: Hashtable;
        getLevel(): number;
        private checkEnumerator();
        setPrevValue(): void;
        setNextValue(): void;
        restoreCurrentValue(): void;
        getTopParentBusinessObject(): StiBusinessObject;
        createEnumerator(): void;
        private sortData();
        private sortDataByGroups();
        filterData(): void;
        private destroyEnumerator();
        setDetails(): void;
        private updateChilds();
        private getBusinessObjectDataFromParent(businessObject);
        getColumnIndex(columnName: string): number;
        getBusinessObjectData(isColumnsRetrieve?: boolean): Object;
        getFullName(): string;
        getCorrectFullName(): string;
        toString(): string;
        connect(): void;
        disconnect(): void;
        private isEnumeratorCreated;
        private specPrevValue;
        private specNextValue;
        private specNextValueRead;
        private specMoveNextResult;
        private specStoredCurrentValue;
        enumerator: IEnumerator;
        protected rowToLevel: Hashtable;
        specSetPrevValue: boolean;
        specSetNextValue: boolean;
        specFilterData: boolean;
        specSortGroup: boolean;
        specTotalsCalculation: boolean;
        previousResetException: boolean;
        getByName(name: string): Object;
        constructor(category?: string, name?: string, alias?: string, guid?: string, key?: string);
    }
}
declare module Stimulsoft.Report.Components {
    class StiDataHelper {
        static setData(component: StiComponent, reinit: boolean, masterComponent?: StiComponent): void;
        static needGroupSort(band: StiDataBand): boolean;
        static getFilterEventHandler(component: StiComponent, dataSource: Object): Object;
        static getFilterExpression(filter: StiFilter, fullColumnName: string, report: StiReport): string;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiExpression = Stimulsoft.Report.Expressions.StiExpression;
    class StiDrillDownParameter implements IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        isDefault(): boolean;
        private _name;
        name: string;
        private _expression;
        expression: StiExpression;
        private _interaction;
        interaction: StiInteraction;
    }
}
declare module Stimulsoft.Report.Components {
    class StiFilterHelper {
        static convertStringToCondition(condition: string): StiFilterCondition;
        static convertConditionToString(condition: StiFilterCondition): string;
        static convertStringToDataType(dataType: string): StiFilterDataType;
        static convertDataTypeToString(dataType: StiFilterDataType): string;
        static setFilter(comp: StiComponent): void;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiFiltersCollection extends CollectionBase<StiFilter> implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiFiltersCollection;
        add(filter: StiFilter): void;
        addRange(filters: StiFilter[]): any;
        addRange(filters: StiFiltersCollection): any;
        contains(filter: StiFilter): boolean;
        indexOf(filter: StiFilter): number;
        insert(index: number, filter: StiFilter): void;
        remove(filter: StiFilter): void;
        getByIndex(index: number): StiFilter;
        setByIndex(index: number, filter: StiFilter): void;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiMargins {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode, defLeft: number, defRight: number, defTop: number, defBotttom: number): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromText(text: string): StiMargins;
        static loadFromXml(xmlNode: XmlNode): StiMargins;
        clone(): Object;
        private _left;
        left: number;
        private _right;
        right: number;
        private _top;
        top: number;
        private _bottom;
        bottom: number;
        readonly isEmpty: boolean;
        static empty: StiMargins;
        constructor(left?: number, right?: number, top?: number, bottom?: number);
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetExcelSheetEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiColumnEndRenderEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiColumnBeginRenderEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Components {
    import PaperKind = Stimulsoft.System.Drawing.Printing.PaperKind;
    import PaperSize = Stimulsoft.System.Drawing.Printing.PaperSize;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiPageHelper {
        static getPaperSizeFromPaperKind(paperKind: PaperKind): PaperSize;
        static getPaperSize(page: StiPage, paperSize: PaperSize): SizeD;
    }
}
declare module Stimulsoft.Report.Engine {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiComponentInfo implements ICloneable {
        implements(): string[];
        clone(): StiComponentInfo;
    }
}
declare module Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiPageInfo extends StiComponentInfo {
        overlays: StiComponentsCollection;
        indexOfStartRenderedPages: number;
        masterDataBand: StiDataBand;
        isReportTitlesRendered: boolean;
        renderedCount: number;
        positionFromTop: number;
        positionFromBottom: number;
    }
}
declare module Stimulsoft.Report.Units {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiUnit {
        static saveToJsonObject(unit: StiUnit): StiJson;
        static loadFromJsonObject(jObject: StiJson): StiUnit;
        static loadFromXml(xmlNode: XmlNode): StiUnit;
        static getUnitFromReportUnit(reportUnit: StiReportUnitType): StiUnit;
        private static _centimeters;
        static readonly Centimeters: StiCentimetersUnit;
        private static _hundredthsOfInch;
        static readonly HundredthsOfInch: StiHundredthsOfInchUnit;
        private static _inches;
        static readonly Inches: StiInchesUnit;
        private static _millimeters;
        static readonly Millimeters: StiMillimetersUnit;
        readonly rulerStep: number;
        readonly factor: number;
        readonly shortName: string;
        readonly name: string;
        convertToHInches(rect: RectangleD): RectangleD;
        convertToHInches(size: SizeD): SizeD;
        convertToHInches(value: number): number;
        convertFromHInches(rect: RectangleD): RectangleD;
        convertFromHInches(size: SizeD): SizeD;
        convertFromHInches(value: number): number;
        protected convertRectangleToHInches(rect: RectangleD): RectangleD;
        protected convertRectangleFromHInches(rect: RectangleD): RectangleD;
        protected convertSizeToHInches(size: SizeD): SizeD;
        protected convertSizeFromHInches(size: SizeD): SizeD;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ContentAlignment = Stimulsoft.System.Drawing.ContentAlignment;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiWatermark implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiWatermark;
        private _font;
        font: Font;
        private _textBrush;
        textBrush: StiBrush;
        private shouldSerializeTextBrush();
        private _text;
        text: string;
        private _angle;
        angle: number;
        private _enabled;
        enabled: boolean;
        private _showImageBehind;
        showImageBehind: boolean;
        private _showBehind;
        showBehind: boolean;
        private _rightToLeft;
        rightToLeft: boolean;
        private _imageMultipleFactor;
        imageMultipleFactor: number;
        private _imageTransparency;
        imageTransparency: number;
        private _image;
        image: Image;
        private _imageHyperlink;
        imageHyperlink: string;
        private cachedImage;
        getImage(report: StiReport): Image;
        private _imageAlignment;
        imageAlignment: ContentAlignment;
        private _imageTiling;
        imageTiling: boolean;
        private _imageStretch;
        imageStretch: boolean;
        private _aspectRatio;
        aspectRatio: boolean;
        private _enabledExpression;
        enabledExpression: string;
        private getTransparentedImage(source, transparency);
        private disposeCachedImage();
        constructor(textBrush?: StiBrush, text?: string, angle?: number, font?: Font, showBehind?: boolean, enabled?: boolean, aspectRatio?: boolean, rightToLeft?: boolean);
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiGetExcelSheetEventHandler: EventHandler;
    class StiGetExcelSheetEventArgs extends EventArgs {
        value: string;
    }
}
declare module Stimulsoft.Report.Components {
    import StiGetExcelSheetEventArgs = Stimulsoft.Report.Events.StiGetExcelSheetEventArgs;
    import StiBeginRenderEvent = Stimulsoft.Report.Events.StiBeginRenderEvent;
    import StiRenderingEvent = Stimulsoft.Report.Events.StiRenderingEvent;
    import StiEndRenderEvent = Stimulsoft.Report.Events.StiEndRenderEvent;
    import StiColumnBeginRenderEvent = Stimulsoft.Report.Events.StiColumnBeginRenderEvent;
    import StiColumnEndRenderEvent = Stimulsoft.Report.Events.StiColumnEndRenderEvent;
    import StiGetExcelSheetEvent = Stimulsoft.Report.Events.StiGetExcelSheetEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiShiftMode = Stimulsoft.Report.Components.StiShiftMode;
    import StiMargins = Stimulsoft.Report.Components.StiMargins;
    import StiPageInfo = Stimulsoft.Report.Components.StiPageInfo;
    import StiPageOrientation = Stimulsoft.Report.Components.StiPageOrientation;
    import StiWatermark = Stimulsoft.Report.Components.StiWatermark;
    import PaperKind = Stimulsoft.System.Drawing.Printing.PaperKind;
    import IStiResetPageNumber = Stimulsoft.Report.Components.IStiResetPageNumber;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiPage extends StiPanel implements IStiResetPageNumber {
        private static ImplementsStiPage;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        private _resetPageNumber;
        resetPageNumber: boolean;
        convertToHInches(unit: StiUnit, value: number): number;
        convertFromHInchesRect(unit: StiUnit, rect: RectangleD): RectangleD;
        convertFromHInches(unit: StiUnit, value: number): number;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        private _pageInfo;
        readonly pageInfo: StiPageInfo;
        readonly isAutomaticDock: boolean;
        left: number;
        top: number;
        width: number;
        height: number;
        readonly right: number;
        readonly bottom: number;
        clientRectangle: RectangleD;
        getDisplayRectangle(): RectangleD;
        shiftMode: StiShiftMode;
        printable: boolean;
        page: StiPage;
        parent: StiContainer;
        invokeEvents(): void;
        private static eventBeginRender;
        protected onBeginRender(): void;
        invokeBeginRender(): void;
        beginRenderEvent: StiBeginRenderEvent;
        private static eventRendering;
        protected onRendering(): void;
        invokeRendering(): void;
        renderingEvent: StiRenderingEvent;
        private static eventEndRender;
        protected onEndRender(): void;
        invokeEndRender(): void;
        endRenderEvent: StiEndRenderEvent;
        private static eventColumnBeginRender;
        protected onColumnBeginRender(): void;
        invokeColumnBeginRender(sender?: any): void;
        columnBeginRenderEvent: StiColumnBeginRenderEvent;
        private static eventColumnEndRender;
        protected onColumnEndRender(): void;
        invokeColumnEndRender(sender?: any): void;
        columnEndRenderEvent: StiColumnEndRenderEvent;
        private static eventGetExcelSheet;
        protected onGetExcelSheet(e: StiGetExcelSheetEventArgs): void;
        invokeGetExcelSheet(sender: StiComponent, e: StiGetExcelSheetEventArgs): void;
        getExcelSheetEvent: StiGetExcelSheetEvent;
        private _excelSheetValue;
        excelSheetValue: string;
        private _excelSheet;
        excelSheet: string;
        readonly zoom: number;
        readonly gridSize: number;
        private _printOnPreviousPage;
        printOnPreviousPage: boolean;
        private _printHeadersFootersFromPreviousPage;
        printHeadersFootersFromPreviousPage: boolean;
        private _paperSize;
        paperSize: PaperKind;
        private _paperSourceOfFirstPage;
        paperSourceOfFirstPage: string;
        private _paperSourceOfOtherPages;
        paperSourceOfOtherPages: string;
        private _numberOfCopies;
        numberOfCopies: number;
        private _unlimitedBreakable;
        unlimitedBreakable: boolean;
        private _largeHeight;
        largeHeight: boolean;
        private _largeHeightFactor;
        largeHeightFactor: number;
        private _largeHeightAutoFactor;
        largeHeightAutoFactor: number;
        private _currentWidthSegment;
        currentWidthSegment: number;
        private _currentHeightSegment;
        currentHeightSegment: number;
        private _stopBeforePrint;
        stopBeforePrint: number;
        private _skip;
        skip: boolean;
        private _stretchToPrintArea;
        stretchToPrintArea: boolean;
        private _titleBeforeHeader;
        titleBeforeHeader: boolean;
        private _unlimitedHeight;
        unlimitedHeight: boolean;
        private _unlimitedWidth;
        unlimitedWidth: boolean;
        private _offsetRectangle;
        offsetRectangle: RectangleD;
        private _orientation;
        orientation: StiPageOrientation;
        locked: boolean;
        linked: boolean;
        private _pageWidth;
        pageWidth: number;
        private _pageHeight;
        pageHeight: number;
        private _segmentPerWidth;
        segmentPerWidth: number;
        private _segmentPerHeight;
        segmentPerHeight: number;
        private _watermark;
        watermark: StiWatermark;
        private _margins;
        margins: StiMargins;
        private _mirrorMargins;
        mirrorMargins: boolean;
        private _report;
        report: StiReport;
        readonly unit: StiUnit;
        private _reportUnit;
        reportUnit: StiUnit;
        private _drillDownActivated;
        drillDownActivated: boolean;
        private _cacheGuid;
        cacheGuid: string;
        newCacheGuid(): void;
        private getIsPageTotalDataBand(name);
        clearPage(): void;
        private removeNewPageContainers(cont);
        private getComponentsCount2(container);
        getComponentsCount(): number;
        resizePage(factorX: number, factorY: number, allowPageMarginsRescaling?: boolean): void;
        toString(): string;
        constructor(report?: StiReport, isSuper?: boolean);
        protected construct(report?: StiReport | any): void;
    }
}
declare module Stimulsoft.Report.Components {
    import EventArgs = Stimulsoft.System.EventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiPagesCollection extends CollectionBase<StiPage> implements IStiStateSaveRestore, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        toList(): StiPage[];
        add(page: StiPage): void;
        addV2Internal(page: StiPage): void;
        addRange(pages: StiPagesCollection): any;
        addRange(pages: StiPage[]): any;
        contains(page: StiPage): boolean;
        indexOf(page: StiPage): number;
        insert(index: number, page: StiPage): void;
        remove(page: StiPage): any;
        remove(startIndex: number, endCount: number): any;
        getPageWithoutCache(pageIndex: number): StiPage;
        getByIndex(index: number): StiPage;
        setByIndex(index: number, page: StiPage): void;
        getByName(name: string): StiPage;
        setByName(name: string, page: StiPage): void;
        protected onClear(): void;
        protected onInsertComplete(index: number, value: Object): void;
        protected onRemoveComplete(index: number, value: Object): void;
        protected onClearComplete(): void;
        getComponentByName(componentName: string): StiComponent;
        private static setParent(parent);
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        clearAllStates(): void;
        private _canUseCacheMode;
        canUseCacheMode: boolean;
        private _report;
        report: StiReport;
        private _cacheMode;
        cacheMode: boolean;
        private quickCachedPages;
        notCachedPages: StiPage[];
        isNotSavedPage(page: StiPage): boolean;
        markPageAsNotSaved(page: StiPage): void;
        getPage(page: StiPage): StiPage;
        savePage(page: StiPage): void;
        protected onPageAdded(e: EventArgs): void;
        invokePageAdded(sender: Object, e: EventArgs): void;
        protected onPageRemoved(e: EventArgs): void;
        invokePageRemoved(sender: Object, e: EventArgs): void;
        protected onPageCleared(e: EventArgs): void;
        invokePageCleared(sender: Object, e: EventArgs): void;
        constructor(report: StiReport, originalPages?: StiPagesCollection);
    }
}
declare module Stimulsoft.Report.Components {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiParameter {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly isDefault: boolean;
        private _name;
        name: string;
        private _expression;
        expression: string;
        constructor();
    }
}
declare module Stimulsoft.Report.Components {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiParametersCollection extends CollectionBase<StiParameter> {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiParametersCollection;
        private addCore(parameter);
        add(parameter: StiParameter): void;
        addRange(parameters: StiParametersCollection): void;
        addRange2(parameters: StiParameter[]): void;
        contains(parameter: StiParameter): boolean;
        indexOf(parameter: StiParameter): number;
        indexOf2(name: string): number;
        insertRange(index: number, parameters: StiParametersCollection): void;
        insert(index: number, parameter: StiParameter): void;
        remove(parameters: StiParametersCollection): void;
        remove2(parameter: StiParameter): void;
        getByIndex(index: number): StiParameter;
        setByIndex(index: number, value: any): void;
        getByName(name: string): StiParameter;
        setByName(name: string, value: any): void;
        copyTo(array: any[], index: number): void;
        constructor();
    }
}
declare module Stimulsoft.Report.Components {
    class StiRestrictionsHelper {
        static isAllowChange(comp: StiComponent): boolean;
        static isAllowDelete2(restrictions: StiRestrictions): boolean;
        static isAllowDelete(comp: StiComponent): boolean;
        static isAllowMove(comp: StiComponent): boolean;
        static isAllowSelect(comp: StiComponent): boolean;
        static isAllowResize(comp: StiComponent): boolean;
        static isAllowChangePosition(comp: StiComponent): boolean;
    }
}
declare module Stimulsoft.Report.Components {
    class StiSortHelper {
        static getColumnIndexInSorting(sorts: string[], columnName: string): number;
        static getColumnSortDirection(sorts: string[], columnName: string): StiInteractionSortDirection;
        static changeColumnSortDirection(sorts: string[], columnName: string): string[];
        static isColumnExistInSorting(sorts: string[], columnName: string): boolean;
        static addColumnToSorting(sorts: string[], columnName: string, isAscending: boolean): string[];
    }
}
declare module Stimulsoft.Report.Components {
    import Font = Stimulsoft.System.Drawing.Font;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiStandardTextRenderer {
        static measureString(maxWidth: number, font: Font, textBox: StiText): SizeD;
    }
}
declare module Stimulsoft.Report.CrossTab.Core {
    enum StiSortDirection {
        Asc = 0,
        Desc = 1,
        None = 2,
    }
    enum StiSummaryType {
        None = 0,
        Sum = 1,
        Average = 2,
        Min = 3,
        Max = 4,
        Count = 5,
        CountDistinct = 6,
        Image = 7,
    }
    enum StiSummaryValues {
        AllValues = 0,
        SkipZerosAndNulls = 1,
        SkipNulls = 2,
    }
    enum StiSortType {
        ByValue = 0,
        ByDisplayValue = 1,
    }
    enum StiFieldType {
        Column = 0,
        Row = 1,
        Cell = 2,
    }
    enum StiSummaryDirection {
        LeftToRight = 0,
        UpToDown = 1,
    }
    enum StiEnumeratorType {
        None = 0,
        Arabic = 1,
        Roman = 2,
        ABC = 3,
    }
    enum StiEnumeratorSeparator {
        Dot = 0,
        Dash = 1,
        Colon = 2,
        RoundBrackets = 3,
        SquareBrackets = 4,
    }
}
declare module Stimulsoft.Report.CrossTab.Core {
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiCell {
        clone(): StiCell;
        size: SizeD;
        isChangeWidthForRightToLeft: boolean;
        isNumeric: boolean;
        isImage: boolean;
        field: StiCrossField;
        private _text;
        text: string;
        hyperlinkValue: Object;
        toolTipValue: Object;
        tagValue: Object;
        parentCell: StiCell;
        value: Object;
        width: number;
        height: number;
        summaryIndex: number;
        level: number;
        isCrossSummary: boolean;
        private _drillDownParameters;
        drillDownParameters: any;
        constructor(text?: string, value?: number, width?: number, height?: number, field?: StiCrossField);
    }
}
declare module Stimulsoft.Report.CrossTab.Core {
    class StiColumn {
        hyperlinkValue: Object;
        tagValue: Object;
        toolTipValue: Object;
        drillDownParameters: any;
        isTotal: boolean;
        level: number;
        cols: StiColumnCollection;
        value: Object;
        displayValue: Object;
        constructor(value: Object, displayValue: Object);
    }
}
declare module Stimulsoft.Report.CrossTab.Core {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiColumnCollection extends CollectionBase<StiColumn> {
        private directionFactor;
        private compare(x, y);
        private sortType;
        private items;
        insert(position: number, value: StiColumn): void;
        add2(value: Object, displayValue: Object): void;
        add(col: StiColumn): void;
        sort(direction: StiSortDirection, sortType: StiSortType): void;
        clear(): void;
        getByValue(value: Object): StiColumn;
        getByIndex(index: number): StiColumn;
    }
}
declare module Stimulsoft.Report.CrossTab.Core {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiGrid {
        private readonly gridSize;
        report: StiReport;
        fields: Hashtable;
        designTime: boolean;
        widths: number[];
        heights: number[];
        coordX: number[];
        coordY: number[];
        cells: StiCell[][];
        rowCount: number;
        colCount: number;
        maxWidth: number;
        maxHeight: number;
        setTextOfCell(x: number, y: number, value: string): void;
        private align(value);
        private getCellTotalWidth(cellX, width);
        private getCellTotalHeight(cellY, height);
        doAutoSize(): void;
        private getFieldWidth(field, value);
        private getFieldHeight(field, value);
        setCell(cellX: number, cellY: number, cellWidth: number, cellHeight: number, text: Object, value: Object, field: StiCrossField, isNumeric: boolean, hyperlink: Object, toolTip: Object, tag: Object, drillDownParameters: any, level?: number): StiCell;
        private cellExists(cellX, cellY);
        setCellField(cellX: number, cellY: number, field: StiCrossField): void;
        init(colCount: number, rowCount: number): void;
    }
}
declare module Stimulsoft.Report.CrossTab.Core {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiCross extends StiGrid {
        crossTab: StiCrossTab;
        private strNull;
        static emptyField: string;
        emptyField: string;
        private oneCellSize;
        private oneCellWidth;
        private oneCellHeight;
        private summaryDirection;
        private colsHeaderHeight;
        private rowsHeaderWidth;
        private widthCorrection;
        private heightCorrection;
        private colsWidth;
        private rowsHeight;
        private columnsCell;
        private rowsCell;
        private invokeEvents2(component, displayValue);
        private invokeEvents(component);
        private addRowTotal(rows, level, maxLevel, setLevel);
        private addColTotal(cols, level, maxLevel, setLevel);
        private sortRows(rows?, level?, width?);
        private sortCols(cols?, level?, height?);
        private createRowTotals();
        private createRowTotals2(rows, level, maxLevel);
        private createColTotals();
        private createColTotals2(cols, level, maxLevel);
        private getDataFromDataRow(dataRow, field);
        private getValueFromDataRow(dataRow, field);
        private allowTotal(row, prevRow);
        private getRow(dataRow);
        private getColumn(dataRow);
        private calculateDataTable(table);
        private calculateDataRow(dataRow);
        private copyRows(rows, left, top, level, emptyValue, colsWidth);
        private copyCols(cols, left, top, level, emptyValue, rowsHeight);
        private convertToDecimal(value);
        private isAllowConvertToDecimal(value);
        private getSummaryResult(sums, totalIndex, grandTotal, isMegaTotal?);
        private copySummaries(left, top, emptyValue);
        private copySummary(summary, left, top, colIndex, rowIndex, setValue, grandTotal, emptyValue);
        private getSummary(summary, calcIndex, grandTotal);
        private isDateTime(list);
        private setCellValue(x, y, value, calcIndex, level, fieldType, hyperlinkValue, toolTipValue, tagValue, drillDownParameters);
        private getColumnTotalCell(level, calcIndex);
        private getRowTotalCell(level, calcIndex);
        private getRowsArray();
        private getRowsArray2(rows, array);
        private getColsArray();
        private getColsArray2(cols, array);
        private getRowsHeaderWidth();
        private getRowsHeaderWidth2(rows);
        private getColsHeaderHeight();
        private getColsHeaderHeight2(cols);
        private getRowsHeight(rows?, maxLevel?, curLevel?);
        private getColsWidth(cols?, maxLevel?, curLevel?);
        private enumerateRows(rows, level);
        private enumerateColumns(columns, level);
        private checkSeparators();
        create(table: DataTable, report: StiReport, direction: StiSummaryDirection, emptyValue: string): void;
        clear(): boolean;
        getCorrectedColumnsHeaderHeight(): number;
        private readonly isSummaryPresent;
        private readonly isRowTitlePresent;
        private readonly isTopLinePresent;
        private readonly isShowSummarySubHeaders;
        private readonly isSummarySubHeadersPresent;
        private readonly isLeftTopLinePresent;
        private readonly isRightTopLinePresent;
        readonly isRowsEmpty: boolean;
        readonly isColsEmpty: boolean;
        rows: StiRowCollection;
        cols: StiColumnCollection;
        colTitleFields: StiComponentsCollection;
        rowTitleFields: StiComponentsCollection;
        private _rowFields;
        rowFields: StiComponentsCollection;
        private _colFields;
        colFields: StiComponentsCollection;
        private _sumFields;
        sumFields: StiComponentsCollection;
        private _sumHeaderFields;
        sumHeaderFields: StiComponentsCollection;
        summaryContainer: StiSummaryContainer;
        leftCrossTitle: StiCrossTitle;
        rightCrossTitle: StiCrossTitle;
        summaryCrossTitle: StiCrossTitle;
    }
}
declare module Stimulsoft.Report.CrossTab.Core {
    class StiRow {
        hyperlinkValue: Object;
        tagValue: Object;
        toolTipValue: Object;
        drillDownParameters: any;
        isTotal: boolean;
        level: number;
        rows: StiRowCollection;
        value: Object;
        displayValue: Object;
        constructor(value: Object, displayValue: Object);
    }
}
declare module Stimulsoft.Report.CrossTab.Core {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiRowCollection extends CollectionBase<StiRow> {
        private directionFactor;
        private compare(x, y);
        private sortType;
        private items;
        insert(position: number, value: StiRow): void;
        add2(value: Object, displayValue: Object): void;
        add(row: StiRow): void;
        clear(): void;
        sort(direction: StiSortDirection, sortType: StiSortType): void;
        getByValue(value: Object): StiRow;
        getByIndex(index: number): StiRow;
    }
}
declare module Stimulsoft.Report.CrossTab.Core {
    class StiSummary {
        sums: Object[][];
        hyperlinkValues: Object[];
        tagValues: Object[];
        toolTipValues: Object[];
        drillDownParameters: any[];
        constructor(level: number);
    }
}
declare module Stimulsoft.Report.CrossTab.Core {
    class StiSummaryContainer {
        private level;
        private dataCol;
        getSummary(col: StiColumn, row: StiRow, create?: boolean): StiSummary;
        constructor(level: number);
    }
}
declare module Stimulsoft.Report.CrossTab {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiGetCrossValueEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiGetCrossValueEventArgs extends EventArgs {
        value: Object;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiGetDisplayCrossValueEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiProcessCellEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiCell = Stimulsoft.Report.CrossTab.Core.StiCell;
    class StiProcessCellEventArgs extends EventArgs {
        cell: StiCell;
        column: number;
        row: number;
        value: number;
        text: string;
    }
}
declare module Stimulsoft.Report.CrossTab {
    enum StiCrossHorAlignment {
        Left = 0,
        Center = 1,
        Right = 2,
        None = 3,
        Width = 4,
    }
}
declare module Stimulsoft.Report.CrossTab {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiText = Stimulsoft.Report.Components.StiText;
    import StiRestrictions = Stimulsoft.Report.Components.StiRestrictions;
    import IStiBorder = Stimulsoft.Report.Components.IStiBorder;
    import IStiBrush = Stimulsoft.Report.Components.IStiBrush;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import IStiTextBrush = Stimulsoft.Report.Components.IStiTextBrush;
    import IStiTextHorAlignment = Stimulsoft.Report.Components.IStiTextHorAlignment;
    import IStiVertAlignment = Stimulsoft.Report.Components.IStiVertAlignment;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import IStiCrossTabField = Stimulsoft.Report.Components.IStiCrossTabField;
    class StiCrossField extends StiText implements IStiTextHorAlignment, IStiVertAlignment, IStiBorder, IStiFont, IStiBrush, IStiTextBrush, IStiCrossTabField {
        private static ImplementsStiCrossField;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        protected readonly defaultHorAlignment: StiTextHorAlignment;
        locked: boolean;
        linked: boolean;
        protected onProcessCell(e: StiProcessCellEventArgs): void;
        invokeProcessCell(e: StiProcessCellEventArgs): void;
        processCellEvent: StiProcessCellEvent;
        readonly helpUrl: string;
        toString(): string;
        readonly localizedCategory: string;
        getRestrictions(): StiRestrictions;
        setRestrictions(value: StiRestrictions): void;
        getTextBoxFromField(): StiText;
        readonly cellText: string;
        private _mergeHeaders;
        mergeHeaders: boolean;
        constructor();
    }
}
declare module Stimulsoft.Report.CrossTab {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiCrossCell extends StiCrossField {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        paint(g: Stimulsoft.System.Drawing.Graphics): void;
        protected onGetCrossValue(e: StiGetCrossValueEventArgs): void;
        invokeGetCrossValue(e: StiGetCrossValueEventArgs): void;
        getCrossValueEvent: StiGetCrossValueEvent;
        private val;
        value: string;
        getValue(): string;
        setValue(value: string): void;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiSortType = Stimulsoft.Report.CrossTab.Core.StiSortType;
    import StiSortDirection = Stimulsoft.Report.CrossTab.Core.StiSortDirection;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiCrossHeader extends StiCrossCell {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        protected onGetDisplayCrossValue(e: StiGetCrossValueEventArgs): void;
        invokeGetDisplayCrossValue(e: StiGetCrossValueEventArgs): void;
        getDisplayCrossValueEvent: StiGetDisplayCrossValueEvent;
        setValue(value: string): void;
        private _displayValue;
        displayValue: string;
        total: StiCrossTotal;
        readonly isTotalVisible: boolean;
        private _headerLevel;
        headerLevel: number;
        private _headerValue;
        headerValue: string;
        private _totalGuid;
        totalGuid: string;
        private _showTotal;
        showTotal: boolean;
        private _sortDirection;
        sortDirection: StiSortDirection;
        private _sortType;
        sortType: StiSortType;
        private _printOnAllPages;
        printOnAllPages: boolean;
        constructor();
    }
}
declare module Stimulsoft.Report.CrossTab {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiEnumeratorType = Stimulsoft.Report.CrossTab.Core.StiEnumeratorType;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiCrossColumn extends StiCrossHeader {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly localizedName: string;
        private _enumeratorType;
        enumeratorType: StiEnumeratorType;
        private _enumeratorSeparator;
        enumeratorSeparator: string;
        createNew(): StiComponent;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiCrossTotal extends StiCrossField {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly cellText: string;
        readonly componentId: StiComponentId;
        createNew(): StiComponent;
        constructor();
    }
}
declare module Stimulsoft.Report.CrossTab {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCrossColumnTotal extends StiCrossTotal {
        readonly componentId: StiComponentId;
        readonly localizedName: string;
        createNew(): StiComponent;
        constructor();
    }
}
declare module Stimulsoft.Report.CrossTab {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiEnumeratorType = Stimulsoft.Report.CrossTab.Core.StiEnumeratorType;
    class StiCrossRow extends StiCrossHeader {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly localizedName: string;
        private _enumeratorType;
        enumeratorType: StiEnumeratorType;
        private _enumeratorSeparator;
        enumeratorSeparator: string;
        getCrossRowTitle(): StiCrossTitle;
        getCrossRowTotal(): StiCrossRowTotal;
        createNew(): StiComponent;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCrossRowTotal extends StiCrossTotal {
        readonly componentId: StiComponentId;
        readonly localizedName: string;
        createNew(): StiComponent;
        constructor();
    }
}
declare module Stimulsoft.Report.CrossTab {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiSummaryType = Stimulsoft.Report.CrossTab.Core.StiSummaryType;
    import StiSummaryValues = Stimulsoft.Report.CrossTab.Core.StiSummaryValues;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCrossSummary extends StiCrossCell {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(cloneProperties: boolean): StiCrossSummary;
        protected readonly defaultHorAlignment: StiTextHorAlignment;
        private _aspectRatio;
        aspectRatio: boolean;
        private _stretch;
        stretch: boolean;
        private _imageHorAlignment;
        imageHorAlignment: StiHorAlignment;
        private _imageVertAlignment;
        imageVertAlignment: StiVertAlignment;
        private _crossColumnValue;
        crossColumnValue: string;
        private _crossRowValue;
        crossRowValue: string;
        private _indexOfSelectValue;
        indexOfSelectValue: number;
        readonly cellText: string;
        private _summary;
        summary: StiSummaryType;
        private _summaryValues;
        summaryValues: StiSummaryValues;
        private _useStyleOfSummaryInRowTotal;
        useStyleOfSummaryInRowTotal: boolean;
        private _useStyleOfSummaryInColumnTotal;
        useStyleOfSummaryInColumnTotal: boolean;
        readonly localizedName: string;
        private _showPercents;
        showPercents: boolean;
        createNew(): StiComponent;
        constructor();
    }
}
declare module Stimulsoft.Report.CrossTab {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCrossSummaryHeader extends StiCrossField {
        readonly cellText: string;
        readonly localizedName: string;
        readonly componentId: StiComponentId;
        createNew(): StiComponent;
    }
}
declare module Stimulsoft.Report.Styles.Conditions {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiStyleConditionElement = Stimulsoft.Report.Styles.Conditions.Elements.StiStyleConditionElement;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiStyleConditionsCollection extends CollectionBase<StiStyleCondition> implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiStyleConditionsCollection;
        add(condition: StiStyleCondition): any;
        /** Creates a new object of the type StiStyleCondition. */
        add(elements: StiStyleConditionElement[]): any;
        addRange(conditions: StiStyleCondition[]): any;
        addRange(conditions: StiStyleConditionsCollection): any;
        contains(condition: StiStyleCondition): boolean;
        indexOf(condition: StiStyleCondition): number;
        insert(index: number, condition: StiStyleCondition): void;
        remove(condition: StiStyleCondition): void;
        getByIndex(index: number): StiStyleCondition;
        setByIndex(index: number, condition: StiStyleCondition): void;
    }
}
declare module Stimulsoft.Report.Styles {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiStyleConditionsCollection = Stimulsoft.Report.Styles.Conditions.StiStyleConditionsCollection;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiBaseStyle implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        stiEquals(obj: Object, allowEqualName?: boolean, allowEqualDescription?: boolean): boolean;
        clone(): Object;
        static getStyle(component: StiComponent, styleElements?: StiStyleElements | StiBaseStyle, componentStyle?: StiBaseStyle): StiBaseStyle;
        /** Gets a style from the components. */
        getStyleFromComponents(comps: StiComponentsCollection, styleElements: StiStyleElements): void;
        /** Returns string representation of the style. */
        toString(): string;
        /** Gets the style from the component. */
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        /** Sets style to the component. */
        setStyleToComponent(component: StiComponent): void;
        private _collectionName;
        /** Gets or sets a name of the styles collection. */
        collectionName: string;
        private _conditions;
        /** Gets or sets a collection of the style conditions. */
        conditions: StiStyleConditionsCollection;
        private _description;
        /** Gets or sets a style description. */
        description: string;
        private _name;
        /** Gets or sets a style name. */
        name: string;
        report: StiReport;
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
declare module Stimulsoft.Report.Styles {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCrossTabStyle extends StiBaseStyle {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        /** Gets a style from the component. */
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        private _color;
        /** Gets or sets a color of style. */
        color: Color;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import StiComponentType = Stimulsoft.Report.Components.StiComponentType;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiSummaryDirection = Stimulsoft.Report.CrossTab.Core.StiSummaryDirection;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import StiFilterEngine = Stimulsoft.Report.Components.StiFilterEngine;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiDataSource = Stimulsoft.Report.Components.IStiDataSource;
    import IStiFilter = Stimulsoft.Report.Components.IStiFilter;
    import IStiCrossTab = Stimulsoft.Report.Components.IStiCrossTab;
    import IStiSort = Stimulsoft.Report.Components.IStiSort;
    import IStiDataRelation = Stimulsoft.Report.Components.IStiDataRelation;
    import IStiPrintIfEmpty = Stimulsoft.Report.Components.IStiPrintIfEmpty;
    import IStiBusinessObject = Stimulsoft.Report.Components.IStiBusinessObject;
    class StiCrossTab extends StiContainer implements IStiDataSource, IStiFilter, IStiCrossTab, IStiSort, IStiDataRelation, IStiPrintIfEmpty, IStiBusinessObject {
        private static ImplementsStiCrossTab;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly helpUrl: string;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        private _printIfEmpty;
        printIfEmpty: boolean;
        readonly dataRelation: StiDataRelation;
        private _dataRelationName;
        dataRelationName: string;
        readonly dataSource: StiDataSource;
        private _dataSourceName;
        dataSourceName: string;
        readonly isDataSourceEmpty: boolean;
        readonly isBusinessObjectEmpty: boolean;
        readonly businessObject: StiBusinessObject;
        private _businessObjectGuid;
        businessObjectGuid: string;
        private _sort;
        sort: string[];
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        isEof: boolean;
        isBof: boolean;
        readonly isEmpty: boolean;
        position: number;
        readonly count: number;
        clone(): StiCrossTab;
        packService(): void;
        private _crossTabInfo;
        readonly crossTabInfo: StiCrossTabInfo;
        private _filterEngine;
        filterEngine: StiFilterEngine;
        private _filterMode;
        filterMode: StiFilterMode;
        filterMethodHandler: Function;
        private _filters;
        filters: Stimulsoft.Report.Components.StiFiltersCollection;
        filter: string;
        private _filterOn;
        filterOn: boolean;
        canContainIn(component: StiComponent): boolean;
        readonly localizedCategory: string;
        readonly priority: number;
        readonly defaultClientRectangle: RectangleD;
        readonly componentType: StiComponentType;
        readonly localizedName: string;
        private _crossTabStyleIndex;
        crossTabStyleIndex: number;
        private _crossTabStyleColor;
        crossTabStyleColor: Object;
        crossTabStyle: string;
        setComponentStyle(value: string): void;
        updateStyles(): void;
        getCellColor(): Color;
        applyFieldStyle(field: StiCrossField): void;
        private _horAlignment;
        horAlignment: StiCrossHorAlignment;
        private _printTitleOnAllPages;
        printTitleOnAllPages: boolean;
        private _summaryDirection;
        summaryDirection: StiSummaryDirection;
        private _keepCrossTabTogether;
        keepCrossTabTogether: boolean;
        private _emptyValue;
        emptyValue: string;
        private _wrap;
        wrap: boolean;
        private _wrapGap;
        wrapGap: number;
        private _rightToLeft;
        rightToLeft: boolean;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.CrossTab {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiCrossTabHelper {
        static getCellRect(masterCrossTab: StiCrossTab, colIndex: number, rowIndex: number): RectangleD;
        static getCellsRect(masterCrossTab: StiCrossTab, startCol: number, startRow: number, endCol: number, endRow: number): SizeD;
        static renderCells(masterCrossTab: StiCrossTab, outContainer: StiContainer, startCol: number, startRow: number, endCol: number, endRow: number, rect: RectangleD): void;
        static createCrossForCrossTabDataSource(masterCrossTab: StiCrossTab): DataTable;
        static buildCrossForCrossTabDataSource(masterCrossTab: StiCrossTab, designTime: boolean): DataTable;
        static buildCross(masterCrossTab: StiCrossTab, designTime: boolean): void;
        static getEndCol(masterCrossTab: StiCrossTab, startCol: number, rect: RectangleD): number;
        static getEndRow(masterCrossTab: StiCrossTab, startRow: number, rect: RectangleD): number;
        static getPageSegmentsRequired(masterCrossTab: StiCrossTab): number;
        static isColFieldsEmpty(masterCrossTab: StiCrossTab): boolean;
        static isRowFieldsEmpty(masterCrossTab: StiCrossTab): boolean;
        static createCross(masterCrossTab: StiCrossTab): void;
        static isCrossTabRendering: boolean;
        static makeRightToLeft(masterCrossTab: StiCrossTab): void;
        static calculateMaxAndMin(outContainer: StiContainer, REFmaxLeft: any, REFmaxRight: any, startIndex: number): void;
        static makeHorAlignmentByWidth(outContainer: StiContainer, startIndex: number): void;
        static clearCross(masterCrossTab: StiCrossTab): void;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    import StiCross = Stimulsoft.Report.CrossTab.Core.StiCross;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiCrossTabInfo extends StiComponentInfo {
        defaultWidth: number;
        defaultHeight: number;
        hidedCells: Hashtable;
        cross: StiCross;
        renderRect: RectangleD;
        finishRender: boolean;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCrossTabParams {
        private _startRow;
        startRow: number;
        private _startColumn;
        startColumn: number;
        private _renderingIsFinished;
        renderingIsFinished: boolean;
        private _allowRendering;
        allowRendering: boolean;
        private _destinationRectangle;
        destinationRectangle: RectangleD;
        private _destinationContainer;
        destinationContainer: StiContainer;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiCrossTitle extends StiCrossField {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly localizedName: string;
        private _printOnAllPages;
        printOnAllPages: boolean;
        private _typeOfComponent;
        typeOfComponent: string;
        readonly cellText: string;
        createNew(): StiComponent;
        constructor();
    }
}
declare module Stimulsoft.Report {
    import Range = Stimulsoft.Report.Range;
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    import TypeConverter = Stimulsoft.System.ComponentModel.TypeConverter;
    class RangeConverter extends TypeConverter {
        readonly GetPropertiesSupported: boolean;
        static rangeToString(range: Range): string;
        static stringToRange(str: string): Range;
        convertTo(context: any, culture: CultureInfo, value: any, destinationType: Stimulsoft.System.Type): any;
        canConvertFrom(context: any, sourceType: Stimulsoft.System.Type): boolean;
        canConvertTo(context: any, destinationType: Stimulsoft.System.Type): boolean;
        convertFrom(context: any, culture: CultureInfo, value: any): any;
    }
}
declare module Stimulsoft.Report.Units {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiHundredthsOfInchUnit extends StiUnit {
        readonly rulerStep: number;
        readonly factor: number;
        readonly shortName: string;
        readonly name: string;
        convertToHInches(rect: RectangleD): RectangleD;
        convertToHInches(size: SizeD): SizeD;
        convertToHInches(value: number): number;
        convertFromHInches(rect: RectangleD): RectangleD;
        convertFromHInches(size: SizeD): SizeD;
        convertFromHInches(value: number): number;
    }
}
declare module Stimulsoft.Report.Units {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiCentimetersUnit extends StiUnit {
        readonly rulerStep: number;
        readonly factor: number;
        readonly shortName: string;
        readonly name: string;
        convertToHInches(rect: RectangleD): RectangleD;
        convertToHInches(size: SizeD): SizeD;
        convertToHInches(value: number): number;
        convertFromHInches(rect: RectangleD): RectangleD;
        convertFromHInches(size: SizeD): SizeD;
        convertFromHInches(value: number): number;
    }
}
declare module Stimulsoft.Report.Units {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiMillimetersUnit extends Stimulsoft.Report.Units.StiUnit {
        readonly rulerStep: number;
        readonly factor: number;
        readonly shortName: string;
        readonly name: string;
        convertToHInches(rect: RectangleD): RectangleD;
        convertToHInches(size: SizeD): SizeD;
        convertToHInches(value: number): number;
        convertFromHInches(rect: RectangleD): RectangleD;
        convertFromHInches(size: SizeD): SizeD;
        convertFromHInches(value: number): number;
    }
}
declare module Stimulsoft.Report.Design {
    import StiAction = Stimulsoft.Base.Drawing.StiAction;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiQuickInfoType = Stimulsoft.Report.Components.StiQuickInfoType;
    class StiDesignerInfo {
        clone(report: StiReport): StiDesignerInfo;
        private _forceDesigningMode;
        forceDesigningMode: boolean;
        private _quickInfoType;
        quickInfoType: StiQuickInfoType;
        private _generateLocalizedName;
        generateLocalizedName: boolean;
        private _showDimensionLines;
        showDimensionLines: boolean;
        private _quickInfoOverlay;
        quickInfoOverlay: boolean;
        private _isComponentsMoving;
        isComponentsMoving: boolean;
        private _currentAction;
        currentAction: StiAction;
        private _isTableMode;
        isTableMode: boolean;
        private _drawEventMarkers;
        drawEventMarkers: boolean;
        private _drawMarkersWhenMoving;
        drawMarkersWhenMoving: boolean;
        private _runDesignerAfterInsert;
        runDesignerAfterInsert: boolean;
        private _useLastFormat;
        useLastFormat: boolean;
        private _autoSaveInterval;
        autoSaveInterval: number;
        private _enableAutoSaveMode;
        enableAutoSaveMode: boolean;
        private _showOrder;
        showOrder: boolean;
        private _alignToGrid;
        alignToGrid: boolean;
        private _autoSaveReportToReportClass;
        autoSaveReportToReportClass: boolean;
        private _showHeaders;
        showHeaders: boolean;
        private _showGrid;
        showGrid: boolean;
        private _showInteractive;
        showInteractive: boolean;
        private _zoom;
        zoom: number;
        private _showRulers;
        showRulers: boolean;
        private _gridSizePixels;
        gridSizePixels: number;
        private _gridSizeCentimetres;
        gridSizeCentimetres: number;
        private _gridSizeHundredthsOfInch;
        gridSizeHundredthsOfInch: number;
        private _gridSizeInch;
        gridSizeInch: number;
        private _gridSizeMillimeters;
        gridSizeMillimeters: number;
        readonly gridSize: number;
        private _fillBands;
        fillBands: boolean;
        private _fillCrossBands;
        fillCrossBands: boolean;
        private _fillContainer;
        fillContainer: boolean;
        private _fillComponent;
        fillComponent: boolean;
        private _useComponentColor;
        useComponentColor: boolean;
        private _gridMode;
        gridMode: StiGridMode;
        private _report;
        report: StiReport;
        getFillColor(color: Color): Color;
        constructor(report?: StiReport);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    import StiService = Stimulsoft.Base.Services.StiService;
    import Promise = Stimulsoft.System.Promise;
    class StiDataAdapterService extends StiService {
        readonly serviceCategory: string;
        readonly serviceType: Type;
        readonly isObjectAdapter: boolean;
        getDataCategoryName(data: StiData): string;
        static getDataAdapter(dataSource: StiDataSource): StiDataAdapterService;
        static getDataAdapter2(data: StiData): StiDataAdapterService;
        create(dictionary: StiDictionary, addToDictionary?: boolean): StiDataSource;
        getDataSourceType(): Type;
        getDataTypes(): Type[];
        isAdapterDataType(type: Type): boolean;
        getColumnsFromDataAsync(data: StiData, dataSource: StiDataSource, connectionString: string): Promise<StiDataColumnsCollection>;
        getColumnsFromData(data: StiData, dataSource: StiDataSource, connectionString: string): StiDataColumnsCollection;
        getParametersFromData(data: StiData, dataSource: StiDataSource): StiDataParametersCollection;
        setDataSourceNames(data: StiData, dataSource: StiDataSource): void;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): Promise<void>;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
        toString(): string;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiDataStoreAdapterService extends StiDataAdapterService {
        setDataSourceNames(data: StiData, dataSource: StiDataSource): void;
        create(dictionary: StiDictionary, addToDictionary?: boolean): StiDataSource;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiFileAdapterService extends StiDataStoreAdapterService {
        readonly serviceName: string;
        getDataCategoryName(data: StiData): string;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiCsvAdapterService extends StiFileAdapterService {
        readonly name: string;
        getColumnsFromData(data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        getParametersFromData(data: StiData, dataSource: StiDataSource): StiDataParametersCollection;
        setDataSourceNames(data: StiData, dataSource: StiDataSource): void;
        getDataSourceType(): Stimulsoft.System.Type;
        getDataTypes(): Stimulsoft.System.Type[];
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
        checkConvertNulls(dataSource: StiCsvSource): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiNoSqlAdapterService extends StiDataStoreAdapterService {
        getDataCategoryName(data: StiData): string;
        testConnection(connectionString: string): string;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMongoDbAdapterService extends StiNoSqlAdapterService {
        readonly name: string;
        getDataSourceType(): Stimulsoft.System.Type;
        getColumnsFromData(data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Promise = Stimulsoft.System.Promise;
    import Type = Stimulsoft.System.Type;
    class StiVirtualAdapterService extends StiDataStoreAdapterService {
        readonly serviceName: string;
        readonly isObjectAdapter: boolean;
        getDataTypes(): Type[];
        getColumnsFromDataAsync(data: StiData, dataSource: StiDataSource, connectionString: string): Promise<StiDataColumnsCollection>;
        getColumnsFromData(data: StiData, dataSource: StiDataSource, connectionString: string): StiDataColumnsCollection;
        getParametersFromData(data: StiData, dataSource: StiDataSource): StiDataParametersCollection;
        getDataCategoryName(data: StiData): string;
        getDataSourceType(): Type;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): Promise<void>;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import Promise = Stimulsoft.System.Promise;
    class StiSqlAdapterService extends StiDataStoreAdapterService {
        readonly url: string;
        readonly serviceName: string;
        readonly name: string;
        getDatabaseSpecificName(name: string): string;
        getDataCategoryName(data: StiData): string;
        getColumnsFromDataAsync(data: StiData, dataSource: StiDataSource, connectionString: string): Promise<StiDataColumnsCollection>;
        getParametersFromData(data: StiData, dataSource: StiDataSource): StiDataParametersCollection;
        getDataSourceType(): Stimulsoft.System.Type;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): Promise<void>;
        callRemoteApi(command: any, timeout: number): Promise<string>;
        private static callTurn;
        process(report: StiReport, command: any, timeout: number): Promise<any>;
        testConnectionAsync(report: StiReport, connectionString: string): Promise<string>;
        createConnectionInDataStore(dictionary: StiDictionary, database: StiSqlDatabase): void;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): Promise<StiDataSchema>;
        retrieveDataAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString: string): Promise<DataTable>;
        constructor();
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import Promise = Stimulsoft.System.Promise;
    class StiODataAdapterService extends StiSqlAdapterService {
        readonly serviceName: string;
        getDataSourceType(): Stimulsoft.System.Type;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): Promise<void>;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
        testConnectionAsync(report: StiReport, connectionString: string): Promise<string>;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): Promise<StiDataSchema>;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import Promise = Stimulsoft.System.Promise;
    class StiFirebirdAdapterService extends StiSqlAdapterService {
        readonly name: string;
        getDataSourceType(): Stimulsoft.System.Type;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): Promise<StiDataSchema>;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import Promise = Stimulsoft.System.Promise;
    class StiMySqlAdapterService extends StiSqlAdapterService {
        readonly name: string;
        getDatabaseSpecificName(name: string): string;
        getDataSourceType(): Stimulsoft.System.Type;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): Promise<StiDataSchema>;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import Promise = Stimulsoft.System.Promise;
    class StiOracleAdapterService extends StiSqlAdapterService {
        readonly name: string;
        getDataSourceType(): Stimulsoft.System.Type;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): Promise<StiDataSchema>;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import Promise = Stimulsoft.System.Promise;
    class StiPostgreSQLAdapterService extends StiSqlAdapterService {
        readonly name: string;
        getDataSourceType(): Stimulsoft.System.Type;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): Promise<StiDataSchema>;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Promise = Stimulsoft.System.Promise;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    class StiCustomAdapterService extends StiSqlAdapterService {
        private processUserFunction;
        static registerCustomAdapterService(options: {
            name: string;
            process: (command: any, callback: (result: any) => void) => void;
        }): void;
        private _name;
        readonly name: string;
        getDataSourceType(): Stimulsoft.System.Type;
        callRemoteApi(command: any, timeout: number): Promise<string>;
        retrieveDataAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString: string): Promise<DataTable>;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): Promise<StiDataSchema>;
        constructor();
    }
}
declare module Stimulsoft.Report.Engine {
    import Type = Stimulsoft.System.Type;
    class StiBuilder {
        private static typeToBuilder;
        static getBuilder(componentType: Type): StiBuilder;
        setReportVariables(masterComp: Stimulsoft.Report.Components.StiComponent): void;
        prepare(masterComp: Stimulsoft.Report.Components.StiComponent): void;
        unPrepare(masterComp: Stimulsoft.Report.Components.StiComponent): void;
        internalRender(masterComp: Stimulsoft.Report.Components.StiComponent): Stimulsoft.Report.Components.StiComponent;
        render(masterComp: Stimulsoft.Report.Components.StiComponent): Stimulsoft.Report.Components.StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiComponentBuilder extends StiBuilder {
        setReportVariables(masterComp: StiComponent): void;
        prepare(masterComp: StiComponent): void;
        unPrepare(masterComp: StiComponent): void;
        internalRender(masterComp: StiComponent): StiComponent;
        render(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiContainerBuilder extends StiComponentBuilder {
        /** Returns a panel for the component rendering.*/
        static getRenderContainer(comp: StiComponent, type?: Stimulsoft.System.Type): StiContainer;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiBandBuilder extends StiContainerBuilder {
        static getChildBands(masterBand: StiBand): StiComponentsCollection;
        static getSubReports(masterBand: StiBand): StiComponentsCollection;
        prepare(masterComp: StiComponent): void;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiGroupHeaderBand = Stimulsoft.Report.Components.StiGroupHeaderBand;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiGroupHeaderBandBuilder extends StiBandBuilder {
        static getMaster(masterGroupHeaderBand: StiGroupHeaderBand): StiDataBand;
        static getCurrentConditionValue(masterGroupHeaderBand: StiGroupHeaderBand): Object;
        static getCurrentSummaryExpressionValue(masterGroupHeaderBand: StiGroupHeaderBand): Object;
        setReportVariables(masterComp: StiComponent): void;
        prepare(masterComp: StiComponent): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import DataRow = Stimulsoft.System.Data.DataRow;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import Type = Stimulsoft.System.Type;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IEnumerable = Stimulsoft.System.Collections.IEnumerable;
    import IEnumerator = Stimulsoft.System.Collections.IEnumerator;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiDataCollection = Stimulsoft.Report.Dictionary.StiDataCollection;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import Promise = Stimulsoft.System.Promise;
    class StiDataSource implements ICloneable, IStiStateSaveRestore, IStiEnumerator, IEnumerator, IEnumerable, IStiName, IStiInherited, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _inherited;
        inherited: boolean;
        readonly current: Object;
        moveNext(): boolean;
        reset(): void;
        getEnumerator(): IEnumerator;
        private _name;
        name: string;
        protected positionValue: number;
        position: number;
        readonly realCount: number;
        readonly count: number;
        protected isBofValue: boolean;
        /** Gets value indicates that this position specifies to the beginning of data. */
        isBof: boolean;
        protected isEofValue: boolean;
        /** Gets value indicates that this position specifies to the data end. */
        isEof: boolean;
        /** Gets value indicates that no data. */
        readonly isEmpty: boolean;
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        clone(): StiDataSource;
        memberwiseClone(): StiDataSource;
        private _states;
        protected readonly states: StiStatesManager;
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        clearAllStates(): void;
        private nameOfDataBandWhichInitDataSource;
        isInited: boolean;
        initForSubreport: boolean;
        xmlRefAttrValue: string;
        private relationNameStored;
        private resFilterMethod;
        private resSortColumns;
        private isEqualSort(sortColumns1, sortColumns2);
        setData(dataBand: StiDataBand, relationName: string, filterMethod: Object, sortColumns: string[], reinit: boolean, component: StiComponent): void;
        getConditions(dataBand: StiDataBand): Object[][][];
        setDetails(relationName: string): void;
        setFilter(filterMethod: Object): void;
        setSort(conditions: Object[][][], sortColumns: string[], component: StiComponent, databand: StiDataBand, groupHeaders: StiComponentsCollection): void;
        resetDetailsRows(): void;
        resetData(): void;
        getDataRow(index: number): DataRow;
        /** Returns the parent row with data for the indicated relation. */
        getParentData(relation: string): StiDataRow;
        /** Returns the colection of Parent relations. */
        getParentRelations(): Stimulsoft.Report.Dictionary.StiDataRelationsCollection;
        /** Returns a collection of Child relations. */
        getChildRelations(): Stimulsoft.Report.Dictionary.StiDataRelationsCollection;
        /** Returns the parent Data Source by the relation name. */
        getParentDataSource(relationName: string): StiDataSource;
        /** Returns the child Data Source by the relation name. */
        getChildDataSource(relationName: string): StiDataSource;
        protected invokeConnecting(): void;
        protected invokeDisconnecting(): void;
        connectAsync(datas: StiDataCollection, loadData: boolean): Promise<void>;
        connect(datas: StiDataCollection, loadData: boolean): void;
        protected getDataAdapterType(): Type;
        protected readonly dataAdapterType: string;
        fillColumns(): void;
        getDataAdapter(): StiDataAdapterService;
        private _parameters;
        parameters: StiDataParametersCollection;
        getDataTable(table?: DataTable): DataTable;
        getByName(columnName: string): Object;
        getData(columnName: string, index?: number): Object;
        getColumnIndex(columnName: string): number;
        private _rows;
        rows: StiRowsCollection;
        columnsIndexs: Hashtable;
        calcColumns: Hashtable;
        detailRows: DataRow[];
        rowToLevel: Hashtable;
        synchronizeColumns(): void;
        checkColumnsIndexs(): void;
        toString(): string;
        getLevel(): number;
        getCategoryName(): string;
        createNew(): StiDataSource;
        private _isCloud;
        readonly isCloud: boolean;
        private _dictionary;
        dictionary: StiDictionary;
        private _dataTable;
        dataTable: Stimulsoft.System.Data.DataTable;
        readonly isConnected: boolean;
        private _columns;
        columns: StiDataColumnsCollection;
        connectionOrder: number;
        disconnect(): void;
        connectOnStart: boolean;
        getByColumnName(columnName: string): Object;
        private _alias;
        alias: string;
        private _key;
        key: string;
        constructor(name: string, alias: string, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDataStoreSource extends StiDataSource {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        getCategoryName(): string;
        dataName: string;
        private _nameInSource;
        nameInSource: string;
        constructor(nameInSource?: string, name?: string, alias?: string, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Type = Stimulsoft.System.Type;
    class StiDataTableSource extends StiDataStoreSource {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        getCategoryName(): string;
        getDataAdapterType(): Type;
        readonly componentId: StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    import Promise = Stimulsoft.System.Promise;
    class StiDataTableAdapterService extends StiDataStoreAdapterService {
        readonly serviceName: string;
        readonly isObjectAdapter: boolean;
        getDataCategoryName(data: StiData): string;
        getColumnsFromDataAsync(data: StiData, dataSource: StiDataSource): Promise<StiDataColumnsCollection>;
        getColumnsFromData(data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        getParametersFromData(data: StiData, dataSource: StiDataSource): StiDataParametersCollection;
        setDataSourceNames(data: StiData, dataSource: StiDataSource): void;
        create(dictionary: StiDictionary, addToDictionary?: boolean): StiDataSource;
        getDataSourceType(): Type;
        getDataTypes(): Type[];
        getDataFromDataSource(dictionary: StiDictionary, dataSource: StiDataSource): StiData;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): Promise<void>;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiAggregateFunctionService {
        readonly serviceName: string;
        init(): void;
        reset(): void;
        calcItem(value: Object): any;
        getValue(): Object;
        setValue(value: Object): any;
        isFirstInit: boolean;
        readonly recureParam: boolean;
        private _runningTotal;
        runningTotal: boolean;
        constructor(runningTotal?: boolean);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiAvgDateFunctionService extends StiAggregateFunctionService {
        private avgValue;
        private count;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiAvgFunctionService extends StiAggregateFunctionService {
        private summary;
        private count;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiAvgTimeFunctionService extends StiAggregateFunctionService {
        private avgValue;
        private count;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiCountDistinctFunctionService extends StiAggregateFunctionService {
        private counter;
        private values;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiCountFunctionService extends StiAggregateFunctionService {
        private counter;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiFirstFunctionService extends StiAggregateFunctionService {
        private value;
        private first;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiLastFunctionService extends StiAggregateFunctionService {
        private value;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMaxDateFunctionService extends StiAggregateFunctionService {
        private valueProcessed;
        private maximum;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMaxFunctionService extends StiAggregateFunctionService {
        private maximum;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMaxStrFunctionService extends StiAggregateFunctionService {
        private values;
        static ascComparison(str1: string, str2: string): number;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMaxTimeFunctionService extends StiAggregateFunctionService {
        private valueProcessed;
        private maximum;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMedianFunctionService extends StiAggregateFunctionService {
        private values;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMinDateFunctionService extends StiAggregateFunctionService {
        private valueProcessed;
        private minimum;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMinFunctionService extends StiAggregateFunctionService {
        private minimum;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMinStrFunctionService extends StiAggregateFunctionService {
        private values;
        static ascComparison(str1: string, str2: string): number;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMinTimeFunctionService extends StiAggregateFunctionService {
        private valueProcessed;
        private minimum;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiModeFunctionService extends StiAggregateFunctionService {
        private values;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiRankOrder = Stimulsoft.Report.StiRankOrder;
    class StiRankFunctionService extends StiAggregateFunctionService {
        private hash;
        private sortOrder;
        private dense;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
        constructor(runningTotal: boolean, dense?: boolean, sortOrder?: StiRankOrder);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiSumDistinctFunctionService extends StiAggregateFunctionService {
        private summary;
        private values;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object, valueToSum?: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiSumFunctionService extends StiAggregateFunctionService {
        private summary;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiSumNullableFunctionService extends StiAggregateFunctionService {
        private summary;
        private hasValues;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiSumTimeFunctionService extends StiAggregateFunctionService {
        private sumValue;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiBusinessObjectCategory {
        private _category;
        category: string;
        constructor(category: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiBusinessObjectData {
        private _category;
        category: string;
        private _name;
        name: string;
        private _alias;
        alias: string;
        private _businessObjectValue;
        businessObjectValue: Object;
        constructor(category: string, name: string, alias: string, value: Object);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiFileDataSource extends StiDataStoreSource {
        readonly componentId: StiComponentId;
        path: string;
        codePage: number;
        constructor(path?: string, name?: string, alias?: string, codePage?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCsvSource extends StiFileDataSource {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        getDataAdapterType(): Stimulsoft.System.Type;
        separator: string;
        convertEmptyStringToNull: boolean;
        createNew(): StiDataSource;
        constructor(path?: string, name?: string, alias?: string, codePage?: number, separator?: string, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Promise = Stimulsoft.System.Promise;
    class StiSqlSource extends StiDataTableSource {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _allowExpressions;
        allowExpressions: boolean;
        private _type;
        type: StiSqlSourceType;
        private _commandTimeout;
        commandTimeout: number;
        private _reconnectOnEachRow;
        reconnectOnEachRow: boolean;
        private _sqlCommand;
        sqlCommand: string;
        getDataAdapterType(): Stimulsoft.System.Type;
        updateParameters(): void;
        retrieveDataAsync(schemaOnly?: boolean): Promise<void>;
        getFinalSqlCommand(): string;
        readonly componentId: StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiNoSqlSource extends StiSqlSource {
        query: string;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMongoDbSource extends StiNoSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiFilter = Stimulsoft.Report.Components.IStiFilter;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import Type = Stimulsoft.System.Type;
    class StiVirtualSource extends StiDataStoreSource implements IStiFilter {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _filterMethodHandler;
        filterMethodHandler: Function;
        private _filterOn;
        filterOn: boolean;
        private _filterMode;
        filterMode: StiFilterMode;
        private _filters;
        filters: Stimulsoft.Report.Components.StiFiltersCollection;
        protected getDataAdapterType(): Type;
        private _groupColumns;
        groupColumns: string[];
        private _results;
        results: string[];
        private _sort;
        sort: string[];
        connectToData(): void;
        private compare(values1, values2);
        private initTotals(totalsList);
        private addRow(table, totalsHash);
        readonly componentId: StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiODataSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiFirebirdSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMySqlSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiOracleSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiPostgreSQLSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiCustomSource extends StiSqlSource {
        static registerCustomSource(): void;
        getDataAdapterType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiDataSourceHelper {
        static getUsedDataSourcesNamesList(report: StiReport): string[];
        static getUsedDataSourcesNames(report: StiReport): Hashtable;
        static checkExpression(expression: string, component: StiComponent, datasourcesNames: Hashtable): void;
        private static addDataSourceName(hashtable, dataSourceName);
        private static addDataSourceColumn(hashtable, dataSourceName, columnName);
        private static addRelation(hashtable, relation);
        private static addSort(hashtable, tempComp, sortArray, dataSourceName);
        static getDataSourcesUsedInRequestFromUsersVariables(report: StiReport): Hashtable;
    }
}
declare module Stimulsoft.Report.Dictionary {
    enum StiVariableInitBy {
        Value = 0,
        Expression = 1,
    }
    enum StiDateTimeType {
        Date = 0,
        DateAndTime = 1,
        Time = 2,
    }
    enum StiItemsInitializationType {
        Items = 0,
        Columns = 1,
    }
    enum StiTypeMode {
        Value = 0,
        NullableValue = 1,
        List = 2,
        Range = 3,
    }
    enum StiSortOrder {
        Asc = 0,
        Desc = 1,
    }
    enum StiAutoSynchronizeMode {
        None = 0,
        IfDictionaryEmpty = 1,
        Always = 2,
    }
    enum StiRestrictionTypes {
        None = 0,
        DenyEdit = 1,
        DenyDelete = 2,
        DenyMove = 4,
        DenyShow = 8,
    }
    enum StiDataType {
        BusinessObject = 0,
        DataSource = 1,
        DataRelation = 2,
        DataColumn = 3,
        Database = 4,
        Resource = 5,
        Variable = 6,
        Total = 7,
    }
    enum StiTotalEvent {
        Never = 0,
        OnEachRecord = 1,
        OnGroupChanged = 2,
        OnPageChanged = 3,
        OnColumnChanged = 4,
        OnEachNewBand = 5,
        OnExpressionChanged = 6,
    }
    enum StiResourceType {
        Image = 0,
        Csv = 1,
        Dbf = 2,
        Json = 3,
        Xml = 4,
        Xsd = 5,
        Excel = 6,
        Rtf = 7,
        Txt = 8,
        Report = 9,
        ReportSnapshot = 10,
        FontTtc = 11,
        FontTtf = 12,
        FontOtf = 13,
        FontEot = 14,
        FontWoff = 15,
        Pdf = 16,
        Word = 17,
    }
    enum StiPropertiesProcessingType {
        All = 0,
        Browsable = 1,
    }
    enum StiFieldsProcessingType {
        All = 0,
        Browsable = 1,
    }
    enum StiConnectionOrder {
        None = 0,
        Standard = 1,
        Sql = 2,
    }
    enum StiSqlSourceType {
        Table = 0,
        StoredProcedure = 1,
    }
    enum StiColumnsSynchronizationMode {
        KeepAbsentColumns = 0,
        RemoveAbsentColumns = 1,
    }
    enum StiSelectionMode {
        FromVariable = 0,
        Nothing = 1,
        First = 2,
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiUndefinedDataSource extends StiDataTableSource {
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import Promise = Stimulsoft.System.Promise;
    class StiDataSourcesCollection extends CollectionBase<StiDataSource> implements IStiJsonReportObject, ICloneable, IComparer<Object> {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private dictionary;
        private directionFactor;
        compare(x: Object, y: Object): number;
        private _cachedDataSources;
        readonly cachedDataSources: Hashtable;
        toList(): Array<StiDataSource>;
        add(dataSource: StiDataSource): void;
        addRange(datas: StiDataSource[]): any;
        addRange(datas: StiDataSourcesCollection): any;
        contains(dataSource: StiDataSource | string): boolean;
        indexOf(dataSource: StiDataSource): number;
        insert(index: number, dataSource: StiDataSource): void;
        onClear(): void;
        remove(dataSource: StiDataSource): void;
        getByIndex(index: number): StiDataSource;
        setByIndex(index: number, data: StiDataSource): void;
        getByName(name: string): StiDataSource;
        getByXmlRef(xmlRef: string): StiDataSource;
        setByName(name: string, value: StiDataSource): void;
        readonly items: StiDataSource[];
        clone(): Object;
        sort(order?: StiSortOrder, sortColumns?: boolean): void;
        clearParametersExpression(): void;
        connectAsync(loadData: boolean, datas?: StiDataCollection): Promise<void>;
        connect(loadData: boolean, datas?: StiDataCollection): void;
        disconnect(): void;
        constructor(dictionary: StiDictionary);
    }
}
declare module Stimulsoft.Report.Helpers {
    import StiDataLoaderHelperData = Stimulsoft.Base.StiDataLoaderHelperData;
    class StiUniversalDataLoader {
        static loadMutiple(report: StiReport, path: string, filter: string, binary: boolean): StiDataLoaderHelperData[];
        static loadSingle(report: StiReport, path: string, binary: boolean): StiDataLoaderHelperData;
    }
}
declare module Stimulsoft.Report.Events {
    class StiDisconnectedEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiDisconnectingEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiConnectedEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiConnectingEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiDisconnectedEvent = Stimulsoft.Report.Events.StiDisconnectedEvent;
    import StiDisconnectingEvent = Stimulsoft.Report.Events.StiDisconnectingEvent;
    import StiConnectedEvent = Stimulsoft.Report.Events.StiConnectedEvent;
    import StiConnectingEvent = Stimulsoft.Report.Events.StiConnectingEvent;
    import EventArgs = Stimulsoft.System.EventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiService = Stimulsoft.Base.Services.StiService;
    import Type = Stimulsoft.System.Type;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import Promise = Stimulsoft.System.Promise;
    enum Order {
        Name = 100,
        Alias = 200,
        ConnectionString = 300,
        FirstRowIsHeader = 350,
        PathSchema = 400,
        PathData = 500,
        XmlType = 600,
        PromptUserNameAndPassword = 700,
        SaveDataInReportResources = 800,
    }
    class StiDatabase extends StiService implements IStiInherited, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _inherited;
        inherited: boolean;
        readonly serviceCategory: string;
        readonly serviceType: Type;
        protected onConnecting(e: EventArgs): void;
        invokeConnecting(): void;
        connectingEvent: StiConnectingEvent;
        protected onConnected(e: EventArgs): void;
        invokeConnected(): void;
        connectedEvent: StiConnectedEvent;
        protected onDisconnecting(e: EventArgs): void;
        invokeDisconnecting(): void;
        disconnectingEvent: StiDisconnectingEvent;
        protected onDisconnected(e: EventArgs): void;
        invokeDisconnected(): void;
        disconnectedEvent: StiDisconnectedEvent;
        readonly serviceName: string;
        private _name;
        name: string;
        private _alias;
        alias: string;
        private _key;
        key: string;
        readonly connectionType: StiConnectionType;
        applyDatabaseInformation(information: StiDatabaseInformation, report: StiReport, informationAll?: StiDatabaseInformation): void;
        getDatabaseInformationAsync(dictionary: StiDictionary): Promise<StiDatabaseInformation>;
        getDatabaseInformation(dictionary: StiDictionary): StiDatabaseInformation;
        toString(): string;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        regDataAsync(dictionary: StiDictionary, loadData: boolean): Promise<void>;
        createNew(): StiDatabase;
        constructor(name?: string, alias?: string, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Image = Stimulsoft.System.Drawing.Image;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiResource implements IStiName, IStiInherited, IStiJsonReportObject {
        implements(): string[];
        clone(): StiResource;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        inherited: boolean;
        private _name;
        name: string;
        alias: string;
        availableInTheViewer: boolean;
        private _content;
        content: number[];
        private _packAndEncryptContent;
        packAndEncryptContent: string;
        key: string;
        type: StiResourceType;
        getResourceAsImage(): Image;
        toString(): string;
        constructor(name?: string, alias?: string, inherited?: boolean, type?: StiResourceType, content?: number[], availableInTheViewer?: boolean);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDialogInfo {
        jsonLoadedBindingVariableName: string;
        xmlLoadedBindingVariable: XmlNode;
        saveToJsonObject(): StiJson;
        loadFromJsonObject(jObject: StiJson, report: StiReport): void;
        private _dateTimeType;
        dateTimeType: StiDateTimeType;
        private _itemsInitializationType;
        itemsInitializationType: StiItemsInitializationType;
        private _keysColumn;
        keysColumn: string;
        private _valuesColumn;
        valuesColumn: string;
        private _bindingVariable;
        bindingVariable: StiVariable;
        private _bindingValuesColumn;
        bindingValuesColumn: string;
        private _mask;
        mask: string;
        private _allowUserValues;
        allowUserValues: boolean;
        private _bindingValue;
        bindingValue: boolean;
        private _keys;
        keys: string[];
        private _values;
        values: string[];
        private _valuesBinding;
        valuesBinding: Object[];
        readonly isDefault: boolean;
        static convert(value: Object): string;
        getDialogInfoItems(type: Stimulsoft.System.Type): StiDialogInfoItem[];
        setDialogInfoItems(items: StiDialogInfoItem[], type: Stimulsoft.System.Type): void;
        constructor();
    }
    class StiDialogInfoItem {
        readonly componentId: StiComponentId;
        readonly propName: string;
        private _keyObject;
        keyObject: Object;
        private _keyObjectTo;
        keyObjectTo: Object;
        private _valueBinding;
        valueBinding: Object;
        private _value;
        value: string;
        toString(dateTimeType: StiDateTimeType): string;
    }
    class StiRangeDialogInfoItem extends StiDialogInfoItem {
    }
    class StiStringDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: string;
    }
    class StiGuidDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: Stimulsoft.System.Guid;
        constructor();
    }
    class StiCharDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: Stimulsoft.System.Char;
        constructor();
    }
    class StiBoolDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: boolean;
        constructor();
    }
    class StiImageDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: Stimulsoft.System.Drawing.Image;
        constructor();
    }
    class StiDateTimeDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: Stimulsoft.System.DateTime;
        constructor();
    }
    class StiTimeSpanDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: Stimulsoft.System.TimeSpan;
        constructor();
    }
    class StiDoubleDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: Stimulsoft.System.Double;
        constructor();
    }
    class StiDecimalDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: Stimulsoft.System.Decimal;
        constructor();
    }
    class StiLongDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: Stimulsoft.System.Long;
        constructor();
    }
    class StiExpressionDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: string;
        constructor();
    }
    class StiStringRangeDialogInfoItem extends StiRangeDialogInfoItem {
        readonly componentId: StiComponentId;
        from: string;
        to: string;
        constructor();
    }
    class StiGuidRangeDialogInfoItem extends StiRangeDialogInfoItem {
        readonly componentId: StiComponentId;
        from: Stimulsoft.System.Guid;
        to: Stimulsoft.System.Guid;
        constructor();
    }
    class StiCharRangeDialogInfoItem extends StiRangeDialogInfoItem {
        readonly componentId: StiComponentId;
        from: Stimulsoft.System.Char;
        to: Stimulsoft.System.Char;
        constructor();
    }
    class StiDateTimeRangeDialogInfoItem extends StiRangeDialogInfoItem {
        readonly componentId: StiComponentId;
        from: Stimulsoft.System.DateTime;
        to: Stimulsoft.System.DateTime;
        constructor();
    }
    class StiTimeSpanRangeDialogInfoItem extends StiRangeDialogInfoItem {
        readonly componentId: StiComponentId;
        from: Stimulsoft.System.TimeSpan;
        to: Stimulsoft.System.TimeSpan;
        constructor();
    }
    class StiDoubleRangeDialogInfoItem extends StiRangeDialogInfoItem {
        readonly componentId: StiComponentId;
        from: Stimulsoft.System.Double;
        to: Stimulsoft.System.Double;
        constructor();
    }
    class StiDecimalRangeDialogInfoItem extends StiRangeDialogInfoItem {
        readonly componentId: StiComponentId;
        from: Stimulsoft.System.Decimal;
        to: Stimulsoft.System.Decimal;
        constructor();
    }
    class StiLongRangeDialogInfoItem extends StiRangeDialogInfoItem {
        readonly componentId: StiComponentId;
        from: Stimulsoft.System.Long;
        to: Stimulsoft.System.Long;
        constructor();
    }
    class StiExpressionRangeDialogInfoItem extends StiRangeDialogInfoItem {
        readonly componentId: StiComponentId;
        from: string;
        to: string;
        constructor();
    }
}
declare module Stimulsoft.Report.Dictionary {
    import DateTime = Stimulsoft.System.DateTime;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiName = Stimulsoft.Report.IStiName;
    import StiExpression = Stimulsoft.Report.Expressions.StiExpression;
    import Type = Stimulsoft.System.Type;
    import IClonable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiDialogInfo = Stimulsoft.Report.Dictionary.StiDialogInfo;
    class StiVariable extends StiExpression implements IStiName, IStiInherited, IClonable {
        private convertTypeToJsonString(type);
        private convertJsonStringToType(text);
        saveToJsonObjectEx(): StiJson;
        loadFromJsonObjectEx(jObject: StiJson, report: StiReport): void;
        static loadFromXml(xmlNode: XmlNode, report: StiReport): StiVariable;
        static convertFromStringToDialogInfo(str: string, report: StiReport): StiDialogInfo;
        private static parseStringArray(xmlNode);
        private _inherited;
        inherited: boolean;
        private _name;
        name: string;
        readonly applyFormat: boolean;
        private _dialogInfo;
        dialogInfo: StiDialogInfo;
        private _alias;
        alias: string;
        private _type;
        type: Type;
        private _readOnly;
        readOnly: boolean;
        private _requestFromUser;
        requestFromUser: boolean;
        private _allowUseAsSqlParameter;
        allowUseAsSqlParameter: boolean;
        private _category;
        category: string;
        private _description;
        description: string;
        readonly isCategory: boolean;
        valueObject: Object;
        initByExpressionFrom: string;
        initByExpressionTo: string;
        getValueProp(): string;
        setValueProp(value: string): void;
        function: boolean;
        private _initBy;
        initBy: StiVariableInitBy;
        private _selection;
        selection: StiSelectionMode;
        private _key;
        key: string;
        private getRangeValues();
        static getValue(str: string, type: Type): Object;
        private setValue(value);
        getNativeValue(): string;
        static getDateTimeFromValue(value: string): DateTime;
        static getValueFromDateTime(value: Stimulsoft.System.DateTime): string;
        eval(report: StiReport): Object;
        toString(): string;
        constructor(category?: string, name?: string, alias?: string, description?: string, typeT?: Type, value?: string, readOnly?: boolean, initBy?: StiVariableInitBy, requestFromUser?: boolean, dialogInfo?: StiDialogInfo, key?: string, allowUseAsSqlParameter?: boolean, selection?: StiSelectionMode);
    }
}
declare module Stimulsoft.Report {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    enum StiNamingRule {
        Simple = 0,
        Advanced = 1,
    }
    class StiNameCreation {
        static namingRule: StiNamingRule;
        private static removeSpacesFromName(baseName, removeIncorrectSymbols);
        static createSimpleName(report: StiReport, baseName: string): string;
        static createName(report: StiReport, baseName: string, addOne?: boolean, removeIncorrectSymbols?: boolean, forceAdvancedNamingRule?: boolean): string;
        static createResourceName(report: StiReport, baseName: string): string;
        static createConnectionName(report: StiReport, baseName: string): string;
        static isResourceNameExists(report: StiReport, name: string): boolean;
        static isConnectionNameExists(report: StiReport, name: string): boolean;
        static isValidName(report: StiReport, name: string): boolean;
        static exists(checkedObject: Object, report: StiReport, name: string): boolean;
        static checkName(checkedObject: Object, report: StiReport, name: string, messageBoxCaption: string, isValid?: boolean): boolean;
        private static getObjectWithName(checkedObject, report, comps, name);
        static generateName1(report: StiReport, localizedName: string, name: string): string;
        static generateName2(report: StiReport, localizedName: string, type: Stimulsoft.System.Type): string;
        static generateName(component: StiComponent): string;
        static generateName4(relation: StiDataRelation): string;
        static generateName5(dataSource: StiDataSource): string;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiFileDatabase extends StiDatabase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        createDataSources(dictionary: StiDictionary): void;
        parsePathExpression(dictionary: StiDictionary, path: string): string;
        pathData: string;
        constructor(name?: string, pathData?: string, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCsvDatabase extends StiFileDatabase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly serviceName: string;
        createNew(): StiDatabase;
        readonly componentId: StiComponentId;
        separator: string;
        codePage: number;
        getDatabaseInformation(dictionary: StiDictionary): StiDatabaseInformation;
        regData(dictionary: StiDictionary, loadData: boolean): any;
        constructor(name?: string, pathData?: string, codePage?: number, separator?: string, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiExcelDatabase extends StiFileDatabase {
        createNew(): StiDatabase;
        readonly serviceName: string;
        readonly componentId: StiComponentId;
        private _firstRowIsHeader;
        firstRowIsHeader: boolean;
        getDatabaseInformation(dictionary: StiDictionary): StiDatabaseInformation;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        private getDataSet(dictionary);
        getDataSetPrivate(workbook: IWorkBook): DataSet;
        constructor(name?: string, pathData?: string, key?: string, firstRowIsHeader?: boolean);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Promise = Stimulsoft.System.Promise;
    import StiDatabase = Stimulsoft.Report.Dictionary.StiDatabase;
    class StiJsonDatabase extends StiFileDatabase {
        createNew(): StiDatabase;
        readonly serviceName: string;
        private getDataSet(dictionary);
        private getDataSetAsync(dictionary);
        getDatabaseInformation(dictionary: StiDictionary): StiDatabaseInformation;
        getDatabaseInformationAsync(dictionary: StiDictionary): Promise<StiDatabaseInformation>;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        regDataAsync(dictionary: StiDictionary, loadData: boolean): Promise<void>;
        constructor(name?: string, pathData?: string, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Promise = Stimulsoft.System.Promise;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiDatabase = Stimulsoft.Report.Dictionary.StiDatabase;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiXmlDatabase extends StiFileDatabase {
        createNew(): StiDatabase;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly serviceName: string;
        private _pathSchema;
        pathSchema: string;
        private _xmlType;
        xmlType: StiXmlType;
        private getDataSet(dictionary);
        private getDataSetAsync(dictionary);
        regData(dictionary: StiDictionary, loadData: boolean): void;
        regDataAsync(dictionary: StiDictionary, loadData: boolean): Promise<void>;
        getDatabaseInformation(dictionary: StiDictionary): StiDatabaseInformation;
        getDatabaseInformationAsync(dictionary: StiDictionary): Promise<StiDatabaseInformation>;
        constructor(name?: string, pathSchema?: string, pathData?: string, key?: string, xmlType?: StiXmlType);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiNoSqlDatabase extends StiDatabase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly connectionType: StiConnectionType;
        connectionString: string;
        connectionStringEncrypted: string;
        promptUserNameAndPassword: boolean;
        readonly canEditConnectionString: boolean;
        protected readonly dataAdapterType: string;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        protected getDataAdapterType(): Stimulsoft.System.Type;
        getDataAdapter(): StiNoSqlAdapterService;
        applyDatabaseInformation(information: StiDatabaseInformation, report: StiReport, informationAll?: StiDatabaseInformation): void;
        protected applyDatabaseInformationSource(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation, dataTable: DataTable, type?: StiSqlSourceType): void;
        getDatabaseInformation(): StiDatabaseInformation;
        protected getDatabaseInformationTables(dataSchema: StiDataSchema): DataTable[];
        createDataSource(nameInSource: string, name: string): StiNoSqlSource;
        getConnectionStringHelper(): string;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMongoDbDatabase extends StiNoSqlDatabase {
        createNew(): StiDatabase;
        readonly componentId: StiComponentId;
        protected getDataAdapterType(): Stimulsoft.System.Type;
        createDataSource(nameInSource: string, name: string): StiNoSqlSource;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Promise = Stimulsoft.System.Promise;
    class StiSqlDatabase extends StiDatabase {
        private static encryptedId;
        createNew(): StiDatabase;
        readonly serviceName: string;
        readonly componentId: StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        protected readonly dataAdapterType: string;
        readonly connectionType: StiConnectionType;
        private _connectionString;
        connectionString: string;
        connectionStringEncrypted: string;
        private _promptUserNameAndPassword;
        promptUserNameAndPassword: boolean;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapter(): StiSqlAdapterService;
        getDataAdapterType(): Stimulsoft.System.Type;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        applyDatabaseInformation(information: StiDatabaseInformation, report: StiReport, informationAll?: StiDatabaseInformation): void;
        protected applyDatabaseInformationTables(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation): void;
        protected applyDatabaseInformationViews(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation): void;
        protected applyDatabaseInformationProcedures(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation): void;
        protected applyDatabaseInformationSource(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation, dataTable: DataTable, type?: StiSqlSourceType): void;
        getDatabaseInformationAsync(dictionary: StiDictionary): Promise<StiDatabaseInformation>;
        private static getDatabaseInformationTables(dataSchema);
        private static getDatabaseInformationViews(dataSchema);
        private static getDatabaseInformationProcedures(dataSchema);
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiODataDatabase extends StiSqlDatabase {
        createNew(): StiDatabase;
        readonly serviceName: string;
        readonly componentId: StiComponentId;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getConnectionStringHelper(): string;
        mapUserNameAndPassword(userName: string, password: string): string;
        readonly connectionType: StiConnectionType;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiFirebirdDatabase extends StiSqlDatabase {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        createNew(): StiDatabase;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMySqlDatabase extends StiSqlDatabase {
        readonly componentId: StiComponentId;
        createNew(): StiDatabase;
        readonly serviceName: string;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiOracleDatabase extends StiSqlDatabase {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        createNew(): StiDatabase;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiPostgreSQLDatabase extends StiSqlDatabase {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        createNew(): StiDatabase;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiCustomDatabase extends StiSqlDatabase {
        static registerCustomDatabase(options: {
            serviceName: string;
            sampleConnectionString: string;
            process: (command: any, callback: (result: any) => void) => void;
        }): void;
        createNew(): StiDatabase;
        private _serviceName;
        readonly serviceName: string;
        createDataSource(nameInSource: string, name: string): StiCustomSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        protected applyDatabaseInformationSource(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation, dataTable: DataTable, type?: StiSqlSourceType): void;
        private _sampleConnectionString;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDatabaseCollection extends CollectionBase<StiDatabase> implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        toList(): StiDatabase[];
        add(data: StiDatabase): void;
        addRange(datas: StiDatabase[]): any;
        addRange(datas: StiDatabaseCollection): any;
        contains(data: StiDatabase): boolean;
        indexOf(data: StiDatabase): number;
        indexOf(name: string): number;
        insert(index: number, data: StiDatabase): void;
        remove(data: StiDatabase): any;
        remove(name: string): any;
        getByIndex(index: number): StiDatabase;
        setByIndex(index: number, data: StiDatabase): void;
        getByName(name: string): StiDatabase;
        setByName(name: string, value: StiDatabase): void;
        clone(): StiDatabaseCollection;
        memberwiseClone(): StiDatabaseCollection;
        private dictionary;
        constructor(dictionary: StiDictionary);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiUndefinedDatabase extends StiDatabase {
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    enum StiConnectionType {
        Sql = 0,
        NoSql = 1,
        Other = 2,
        Rest = 3,
        Custom = 4,
    }
}
declare module Stimulsoft.Report.Dictionary.Design {
    import Type = Stimulsoft.System.Type;
    class StiDataColumnConverter {
        static convertTypeToString(type: Type): string;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IComparable = Stimulsoft.System.IComparable;
    import Type = Stimulsoft.System.Type;
    class StiFunction implements IComparable {
        implements(): string[];
        compareTo(obj: Object): number;
        private _useFullPath;
        useFullPath: boolean;
        private _category;
        category: string;
        private _groupFunctionName;
        groupFunctionName: string;
        private _functionName;
        functionName: string;
        private _description;
        description: string;
        private _typeOfFunction;
        typeOfFunction: string;
        private _returnType;
        returnType: Type;
        private _returnDescription;
        returnDescription: string;
        private _argumentTypes;
        argumentTypes: Type[];
        private _argumentNames;
        argumentNames: string[];
        private _argumentDescriptions;
        argumentDescriptions: string[];
        toString(): string;
        getLongFunctionString(language: StiReportLanguageType): string;
        getFunctionString(language: StiReportLanguageType, addFunctionName?: boolean): string;
        convertTypeToString(typeT: Type, language: StiReportLanguageType): string;
        constructor(category: string, groupFunctionName: string, functionName: string, description: string, typeOfFunction: string, returnType: Type, returnDescription?: string, argumentTypes?: Type[], argumentNames?: string[], argumentDescriptions?: string[]);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiFunctionsMath {
        private static isCreated;
        static create(): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiFunctionsPrintState {
        private static isCreated;
        static create(): void;
        static isNull(dataSource: any, dataColumn: string): boolean;
        static next(dataSource: any, dataColumn: string): any;
        static nextIsNull(dataSource: any, dataColumn: string): any;
        static previous(dataSource: any, dataColumn: string): any;
        static previousIsNull(dataSource: any, dataColumn: string): any;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiFunctionsProgrammingShortcut {
        private static isCreated;
        static create(): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import DateTime = Stimulsoft.System.DateTime;
    class StiFunctionsStrings {
        private static isCreated;
        static create(): void;
        static toProperCase(str: string): string;
        static substring(str: Object, startIndex: number, length: number): string;
        static left(str: Object, length: number): string;
        static right(str: Object, length: number): string;
        static mid(str: Object, startIndex: number, length: number): string;
        static roman(value: number): string;
        static abc(value: number | string): string;
        static arabic(value: number | string): string;
        static persian(value: number | string): string;
        static toWords(value: number, upperCase?: boolean, femaleEs?: boolean): string;
        static dateToStr(value: DateTime, upperCase?: boolean): string;
        static toCurrencyWords(value: number, upperCase: boolean, showCents: boolean, dollars?: string, cents?: string): string;
        static toCurrencyWords2(value: number, upperCase?: boolean | string, showCents?: boolean | number | string, dollars?: string | boolean, cents?: string): string;
        static toOrdinal(value: number): string;
        static toWordsRu(value: number, upperCase?: boolean): string;
        static dateToStrRu(value: DateTime, upperCase?: boolean): string;
        static toCurrencyWordsRu(value: number, uppercase?: boolean, currency?: string, cents?: boolean): string;
        static toCurrencyWordsThai(value: number): string;
        private static SP_STRtNumToMny(value);
        private static SP_XCGtNumToMny(ptMoneyNum);
        private static reverseString(s);
        private static tC_0;
        private static tC_1;
        private static tC_2;
        private static tC_3;
        private static tC_4;
        private static tC_5;
        private static tC_6;
        private static tC_7;
        private static tC_8;
        private static tC_9;
        private static tC_01;
        private static tC_10;
        private static tC_20;
        private static tC_100;
        private static tC_1000;
        private static tC_10000;
        private static tC_100000;
        private static tC_1000000;
        private static tC_Baht;
        private static tC_Satang;
        private static tC_Complete;
        static toWordsUa(value: number, uppercase?: boolean, gender?: Stimulsoft.Report.Func.Gender): string;
        static dateToStrUa(value: DateTime, upperCase?: boolean): string;
        static toCurrencyWordsUa(value: number, uppercase?: boolean, currency?: string, cents?: boolean): string;
        static toWordsPt(value: number, upperCase: boolean): string;
        static toCurrencyWordsPt(value: number, upperCase: boolean, showCents: boolean): string;
        static toCurrencyWordsPtBr(value: number): string;
        static DateToStrPt(value: DateTime): string;
        static dateToStrPtBr(value: DateTime): string;
        static toCurrencyWordsFr(numberr: number, currencyISO: string, decimals: number): string;
        static toCurrencyWordsEs(numberr: number, currencyISO: string, decimals: number): string;
        static toWordsEs(value: number, upperCase: boolean): string;
        static toWordsEs2(value: number, upperCase: boolean, female: boolean): string;
        static toCurrencyWordsNl(numberr: number, currencyISO: string, decimals: number): string;
        static toCurrencyWordsEnGb(numberr: number, currencyISO: string, decimals: number): string;
        static toWordsPl(value: number, upperCase: boolean): string;
        static dateToStrPl(value: DateTime, upperCase: boolean): string;
        static toCurrencyWordsPl(value: number, currencyISO: string, showCents: boolean, upperCase: boolean): string;
        static toWordsEnIn(value: number, blankIfZero: boolean): string;
        static toCurrencyWordsEnIn(currencyBasicUnit: string, currencyFractionalUnit: string, value: number, decimalPlaces: number, blankIfZero?: boolean): string;
        static toWordsFa(value: number): string;
        static toWordsZh(value: number): string;
        static toCurrencyWordsZh(value: number): string;
        static toWordsTr(value: number): string;
        static toCurrencyWordsTr(value: number): string;
        static toCurrencyWordsTr2(value: number, currencyName: string, showZeroCents: boolean): string;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiFunctionsTotals {
        private static isCreated;
        static create(): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiAliasAttribute {
        private _alias;
        alias: string;
        constructor(alias: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    class StiBusinessObjectSort implements IComparer<Object> {
        private sortColumns;
        private rowToConditions;
        private conditions;
        private businessObject;
        compare(x: Object, y: Object): number;
        compareValues(value1: Object, value2: Object, ascendary?: boolean): number;
        clear(): void;
        constructor(sortColumns: string[], businessObject: StiBusinessObject, rowToConditions: Hashtable, conditions: Object[][][]);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiBusinessObjectToDataSet {
        private dataSet;
        private relations;
        private uniques;
        private level;
        convertBusinessObjectToDataSet(name: string, obj: Object): DataSet;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiDataColumn implements IStiJsonReportObject, ICloneable, IStiName, IStiInherited {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiDataColumn;
        memberwiseClone(): StiDataColumn;
        private _name;
        name: string;
        inherited: boolean;
        dataColumnsCollection: StiDataColumnsCollection;
        private _dataSource;
        dataSource: StiDataSource;
        private _businessObject;
        businessObject: StiBusinessObject;
        private _index;
        index: number;
        private _nameInSource;
        nameInSource: string;
        private _alias;
        alias: string;
        private _type;
        type: Stimulsoft.System.Type;
        private _key;
        key: string;
        getColumnPath(): string;
        toString(): string;
        static getDataColumnFromColumnName(dictionary: StiDictionary, column: string): StiDataColumn;
        static getRelationName(dictionary: StiDictionary, dataSource: StiDataSource, relationName: string): string;
        static getDataFromBusinessObject(dictionary: StiDictionary, column: string): Object;
        static getBusinessObjectFromDataColumn(dictionary: StiDictionary, column: string): StiBusinessObject;
        static getDataFromDataColumn(dictionary: StiDictionary, column: string, useRelationName?: boolean): Object;
        static getDataSourceFromDataColumn(dictionary: StiDictionary, column: string): StiDataSource;
        static getColumnNameFromDataColumn(dictionary: StiDictionary, column: string): string;
        static getDataListFromDataColumn(dictionary: StiDictionary, column: string, maxRows?: number): any[];
        static getDatasFromDataColumn(dictionary: StiDictionary, column: string, maxRows?: number): any[];
        constructor(nameInSource?: string, name?: string, alias?: string, type?: Stimulsoft.System.Type, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Type = Stimulsoft.System.Type;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCalcDataColumn extends StiDataColumn {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _value;
        value: string;
        expression: string;
        constructor(name?: string, alias?: string, typeT?: Type, value?: string, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiData {
        private _viewData;
        viewData: Object;
        private _data;
        data: Object;
        private _name;
        name: string;
        private _alias;
        alias: string;
        private _isReportData;
        isReportData: boolean;
        private _isBusinessObjectData;
        isBusinessObjectData: boolean;
        OriginalConnectionState: Object;
        toString(): string;
        constructor(name: string, data: Object, viewData?: Object);
    }
}
declare module Stimulsoft.Report {
    class StiNameValidator {
        private static cache;
        static correctName(str: string, checkKeywords?: boolean): string;
        private static checkKeyword(str);
        static correctBusinessObjectName(str: string): string;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiDataBuilder {
        static getColumnFromPath(path: string, dictionary: StiDictionary): StiDataColumn;
        static getColumnFromPath2(path: string, dataSource: StiDataSource): StiDataColumn;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import Type = Stimulsoft.System.Type;
    class StiDataCollection extends CollectionBase<StiData> {
        toList(): StiData[];
        add(data: StiData): void;
        addRange(data: StiData[]): void;
        contains(data: StiData): boolean;
        indexOf(data: StiData): number;
        insert(index: number, data: StiData): void;
        remove(data: StiData): void;
        getByIndex(index: number): StiData;
        setByIndex(index: number, value: StiData): void;
        getByName(name: string): StiData;
        setByName(name: string, value: StiData): void;
        readonly items: StiData[];
        regData(name: string, alias: string, data: any): void;
        private regDataDataTable(name, alias, dataTable);
        private regDataDataSet(name, alias, dataSet);
        private regDataDataTable2(dataTable);
        private regDataDataSet2(dataSet);
        regDataStiDataCollection(datas: StiDataCollection): void;
        clearReportDatabase(): void;
        GetData(typeData: Type): StiDataCollection;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import DataColumn = Stimulsoft.System.Data.DataColumn;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import Type = Stimulsoft.System.Type;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiDataColumnsCollection extends CollectionBase<StiDataColumn> implements IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private decodeTypeName(typeName);
        loadFromXml(node: XmlNode): void;
        cachedDataColumns: Hashtable;
        private directionFactor;
        dataSource: StiDataSource;
        private businessObject;
        toList(): Array<StiDataColumn>;
        onInsert(value: Object): void;
        add(column: StiDataColumn): any;
        add(name: string, typeT: Type): any;
        add(name: string, alias: string, type: Type): any;
        addRange(columns: StiDataColumn[] | StiDataColumnsCollection): void;
        contains(column: StiDataColumn | string): boolean;
        indexOf(column: StiDataColumn): number;
        insert(index: number, column: StiDataColumn): void;
        remove(column: StiDataColumn): void;
        getByIndex(index: number): StiDataColumn;
        setByIndex(index: number, value: StiDataColumn): void;
        getByName(name: string): StiDataColumn;
        setByName(name: string, value: StiDataColumn): void;
        sort(order: StiSortOrder): void;
        constructor(source?: StiBusinessObject | StiDataSource | Array<StiDataColumn> | Array<DataColumn>);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiExpression = Stimulsoft.Report.Expressions.StiExpression;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDataParameter extends StiExpression implements IStiName, IStiInherited, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        dataParametersCollection: StiDataParametersCollection;
        private _inherited;
        inherited: boolean;
        private _name;
        name: string;
        readonly applyFormat: boolean;
        expression: string;
        getParameterValue(): Object;
        private _parameterValue;
        parameterValue: Object;
        private _dataSource;
        dataSource: StiDataSource;
        private _type;
        type: number;
        private _size;
        size: number;
        private _key;
        key: string;
        toString(): string;
        constructor(name?: string, value?: string, type?: number, size?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDataParametersCollection extends CollectionBase<StiDataParameter> implements IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private dataSource;
        private cachedDataParameters;
        toList(): Array<StiDataParameter>;
        onInsert(index: number, value: Object): void;
        add(parameter: StiDataParameter): void;
        addRange(parameters: StiDataParameter[] | StiDataParametersCollection): void;
        contains(parameter: StiDataParameter | string): boolean;
        indexOf(parameter: StiDataParameter): number;
        insert(index: number, parameter: StiDataParameter): void;
        remove(parameter: StiDataParameter): void;
        getByIndex(index: number): StiDataParameter;
        setByIndex(index: number, value: StiDataParameter): void;
        getByName(name: string): StiDataParameter;
        setByName(name: string, value: StiDataParameter): void;
        constructor(dataSource?: StiDataSource);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDataRelation implements IStiName, IStiInherited, ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private parseStringArray(xmlNode);
        private _inherited;
        inherited: boolean;
        private _name;
        name: string;
        clone(): Object;
        private _dictionary;
        dictionary: StiDictionary;
        private _parentSource;
        parentSource: StiDataSource;
        private _childSource;
        childSource: StiDataSource;
        private _parentColumns;
        parentColumns: string[];
        private _childColumns;
        childColumns: string[];
        private _relationName;
        relationName: string;
        private _nameInSource;
        nameInSource: string;
        private _alias;
        alias: string;
        IsCloud: boolean;
        private _key;
        key: string;
        toString(): string;
        constructor(nameInSource?: string, name?: string, alias?: string, parentSource?: StiDataSource, childSource?: StiDataSource, parentColumns?: string[], childColumns?: string[], key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiDataRelationSetName {
        static setName(dataRelation: StiDataRelation, report: StiReport, dataSet: DataSet, name: string): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiDataRelationsCollection extends CollectionBase<StiDataRelation> implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiDataRelationsCollection;
        private dictionary;
        cachedDataRelations: Hashtable;
        toList(): Array<StiDataRelation>;
        add(relation: StiDataRelation): void;
        addRange(relations: StiDataRelation[] | StiDataRelationsCollection): void;
        contains(relation: StiDataRelation | string): boolean;
        indexOf(relation: StiDataRelation): number;
        insert(index: number, relation: StiDataRelation): void;
        remove(relation: StiDataRelation): void;
        getByIndex(index: number): StiDataRelation;
        setByIndex(index: number, value: StiDataRelation): void;
        getByName(name: string): StiDataRelation;
        setByName(name: string, value: StiDataRelation): void;
        readonly items: StiDataRelation[];
        constructor(dictionary: StiDictionary);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiDataRetrieval {
        dispose(): void;
        private buildTokens(script);
        private _usedColumns;
        readonly usedColumns: Hashtable;
        private _usedRelations;
        readonly usedRelations: Hashtable;
        private _usedDataSources;
        readonly usedDataSources: Hashtable;
        retrieval(report: StiReport): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import DataRow = Stimulsoft.System.Data.DataRow;
    class StiDataRow {
        createDataRow(dataRow: StiDataRow): StiDataRow;
        private _row;
        row: DataRow;
        private dataSource;
        readonly dictionary: StiDictionary;
        getByColumnName(columnName: string): Object;
        getParentData(relation: string): StiDataRow;
        constructor(dataSource: StiDataSource, dataRow: DataRow);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import DataRow = Stimulsoft.System.Data.DataRow;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiDataSort implements IComparer<DataRow> {
        private sortColumns;
        private rowToConditions;
        private conditions;
        private hashValues;
        private dataSource;
        private textComp;
        private static nullObject;
        compare(x: DataRow, y: DataRow): number;
        private compareRows(x, y);
        compareValues(value1: Object, value2: Object, ascendary?: boolean): number;
        clear(): void;
        constructor(rowToConditions: Hashtable, conditions: Object[][][], sortColumns: string[], dataSource: StiDataSource);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiService = Stimulsoft.Base.Services.StiService;
    import Type = Stimulsoft.System.Type;
    import StiDataTableSource = Stimulsoft.Report.Dictionary.StiDataTableSource;
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiDataTableSetNameService extends StiService {
        readonly serviceCategory: string;
        readonly serviceType: Type;
        setName(dataTableSource: StiDataTableSource, report: StiReport, dataSet: DataSet, name: string): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiDatabaseInformation {
        private _tables;
        readonly tables: DataTable[];
        private _views;
        readonly views: DataTable[];
        private _storedProcedures;
        readonly storedProcedures: DataTable[];
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiDatabaseCollection = Stimulsoft.Report.Dictionary.StiDatabaseCollection;
    import StiBusinessObjectsCollection = Stimulsoft.Report.Dictionary.StiBusinessObjectsCollection;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import DataSet = Stimulsoft.System.Data.DataSet;
    import StiDatabase = Stimulsoft.Report.Dictionary.StiDatabase;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Promise = Stimulsoft.System.Promise;
    class StiDictionary implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiDictionary;
        private _cachedUserNamesAndPasswords;
        cachedUserNamesAndPasswords: Hashtable;
        private _useInternalData;
        useInternalData: boolean;
        private _restrictions;
        restrictions: StiRestrictions;
        static autoSynchronize: StiAutoSynchronizeMode;
        static doAutoSynchronize(report: StiReport): void;
        private _cacheDataSet;
        cacheDataSet: DataSet;
        private _report;
        report: StiReport;
        private _dataStore;
        dataStore: StiDataCollection;
        private _variables;
        variables: StiVariablesCollection;
        private _resources;
        resources: StiResourcesCollection;
        private _dataSources;
        dataSources: StiDataSourcesCollection;
        private _databases;
        databases: StiDatabaseCollection;
        private _businessObjects;
        businessObjects: StiBusinessObjectsCollection;
        private _relations;
        relations: StiDataRelationsCollection;
        readonly isRequestFromUserVariablesPresent: boolean;
        private equalsColumns(columns, cols);
        createDatabases(loadData: boolean): void;
        createDatabasesAsync(loadData: boolean): Promise<void>;
        removeUnusedData(): void;
        removeUnusedDataSourcesV2(): void;
        retrievalData(REFusedRelations: any, REFusedDataSources: any, REFusedColumns: any): void;
        getUnusedRelationsFromDataStore(): StiDataRelationsCollection;
        private synchronize2(businessObjects);
        synchronize(): void;
        synchronizeBusinessObjects(): void;
        synchronizeColumns(data: StiData, dataSource: StiDataSource): void;
        synchronizeColumnsAsync(data: StiData, dataSource: StiDataSource): Promise<void>;
        synchronizeColumns3(data: StiBusinessObjectData, source: StiBusinessObject): void;
        synchronizeColumns2(data: Object, source: StiBusinessObject): void;
        clear(): void;
        private disposeCacheDataSet();
        renameDatabase(database: StiDatabase, newName: string): void;
        connectAsync(loadData?: boolean, dataSources?: StiDataSource[]): Promise<void>;
        connect(loadData?: boolean, dataSources?: StiDataSource[]): void;
        connectVirtualDataSources(): void;
        connectCrossTabDataSources(): void;
        disconnect(): void;
        private disconnectingDatabases(databases);
        private disconnectedDatabases(databases);
        private disconnectingConnectionInDataStore();
        private checkRelation(dataSet, relationName, parentColumns, childColumns);
        private equalsRelationColumns(columns, cols);
        private getRelationName(relation);
        regRelations2(virtualSources?: boolean): void;
        regRelation(relation: StiDataRelation, virtualSources: boolean): void;
        constructor(report?: StiReport);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import DataRow = Stimulsoft.System.Data.DataRow;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiGroupSummaryDataSort implements IComparer<DataRow> {
        private groupSummaries;
        private groupLines;
        private baseRowOrder;
        private groupHeaders;
        compare(row1: DataRow, row2: DataRow): number;
        private compareValues(value1, value2);
        clear(): void;
        constructor(groupSummaries: Hashtable, groupLines: Hashtable, groupHeaders: StiComponentsCollection, baseRowOrder: Hashtable);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import StiHierarchicalBand = Stimulsoft.Report.Components.StiHierarchicalBand;
    class StiHierarchicalBusinessObjectSort implements IComparer<Object> {
        compare(x: Object, y: Object): number;
        private getParentValue(value);
        process(): void;
        private createTree(values);
        private setLevelAndSort(values, masterKey, level);
        private createRowList(values, rows, masterKey);
        private businessObject;
        private keyColumn;
        private masterKeyColumn;
        private parentValue;
        private sortColumns;
        constructor(businessObject: StiBusinessObject, band: StiHierarchicalBand, sortColumns: string[]);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiHierarchicalBand = Stimulsoft.Report.Components.StiHierarchicalBand;
    class StiHierarchicalDataSort implements IComparer<Object> {
        private dataSource;
        private keyColumn;
        private masterKeyColumn;
        private parentValue;
        private sortColumns;
        compare(x: Object, y: Object): number;
        private getParentValue(value);
        process(rowToConditions: Hashtable): void;
        private createTree(values);
        private setLevelAndSort(rowToConditions, values, masterKey, level);
        private createRowList(values, rows, masterKey);
        constructor(dataSource: StiDataSource, band: StiHierarchicalBand, sortColumns: string[]);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiResourcesCollection extends CollectionBase<StiResource> implements IComparer<StiResource> {
        implements(): string[];
        clone(): StiResourcesCollection;
        saveToJsonObjectEx(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObjectEx(jObject: StiJson, report: StiReport): void;
        loadFromXml(xmlNode: XmlNode): void;
        private directionFactor;
        compare(x: StiResource, y: StiResource): number;
        sort(order?: StiSortOrder): void;
        toList(): Array<StiResource>;
        add(resource: StiResource): void;
        addRange(resources: StiResourcesCollection): void;
        contains(resource: StiResource): boolean;
        indexOf(resource: StiResource): number;
        insert(index: number, resource: StiResource): void;
        remove(resource: StiResource): void;
        getByIndex(index: number): StiResource;
        setByIndex(index: number, data: StiResource): void;
        getByName(name: string): StiResource;
        setByName(name: string, value: StiResource): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiRestrictions {
        private restrictionsDataSource;
        private restrictionsDataRelation;
        private restrictionsDataColumn;
        private restrictionsDatabase;
        private restrictionsVariable;
        private restrictionsTotal;
        private restrictionsBusinessObject;
        clear(): void;
        private getHashtable(dataType, create);
        add(name: string, dataType: StiDataType, type: StiRestrictionTypes): void;
        isAllowEdit(name: string, dataType: StiDataType): boolean;
        isAllowDelete(name: string, dataType: StiDataType): boolean;
        isAllowShow(name: string, dataType: StiDataType): boolean;
        isAllowMove(name: string, dataType: StiDataType): boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiRow {
        private dataSource;
        private rowIndex;
        getByName(columnName: string): Object;
        constructor(dataSource: StiDataSource, rowIndex: number);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IEnumerable = Stimulsoft.System.Collections.IEnumerable;
    import IEnumerator = Stimulsoft.System.Collections.IEnumerator;
    class StiRowsCollection implements IEnumerable, IEnumerator {
        getEnumerator(): IEnumerator;
        readonly current: Object;
        moveNext(): boolean;
        reset(): void;
        getbyIndex(rowIndex: number): StiRow;
        readonly count: number;
        private dataSource;
        constructor(dataSource: StiDataSource);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiStrFix {
        static Del_(str: string): string;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiSystemVariablesHelper {
        static getSystemVariableInfo(variable: string): string;
        static getSystemVariables(report: StiReport): string[];
        protected static systemVariablesV2: string[];
        static getSystemVariablesV2(): string[];
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiType {
        private _name;
        name: string;
        private _type;
        type: Stimulsoft.System.Type;
        static getTypes(): StiTypesCollection;
        static getBaseTypes(): StiTypesCollection;
        static getTypeModeFromType(type: Stimulsoft.System.Type, REFtypeMode: any): System.Type;
        static getTypeFromTypeMode(type: Stimulsoft.System.Type, typeMode: StiTypeMode): Stimulsoft.System.Type;
        toString(): string;
        constructor(name: string, type: Stimulsoft.System.Type);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiTypesCollection extends CollectionBase<StiType> {
        add(type: StiType): void;
        addRange(type: StiType[]): void;
        contains(type: StiType): boolean;
        indexOf(type: StiType): number;
        insert(index: number, type: StiType): void;
        remove(type: StiType): void;
        getByIndex(index: number): StiType;
        setByIndex(index: number, value: StiType): void;
        getByName(name: string): StiType;
        setByName(name: string, value: StiType): void;
        get(type: Stimulsoft.System.Type): StiType;
        set(type: Stimulsoft.System.Type, value: StiType): void;
        readonly items: StiType[];
        regType(name: string, type: Stimulsoft.System.Type): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiUserNameAndPassword {
        private _userName;
        readonly userName: string;
        private _password;
        readonly password: string;
        constructor(userName: string, password: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiVariableAsParameterHelper {
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiVariablesCollection extends CollectionBase<StiVariable> implements IComparer<StiVariable>, ICloneable {
        implements(): string[];
        saveToJsonObjectEx(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObjectEx(jObject: StiJson, report: StiReport): void;
        loadFromXml(xmlNode: XmlNode, report: StiReport): void;
        private directionFactor;
        compare(x: StiVariable, y: StiVariable): number;
        sort(order?: StiSortOrder): void;
        toList(): Array<StiVariable>;
        add(variable: StiVariable): void;
        addRange(variables: StiVariablesCollection): void;
        contains(name: string): boolean;
        containsCategory(name: string): boolean;
        indexOf(data: string | StiVariable): number;
        insert(index: number, variable: StiVariable): void;
        remove(data: string | StiVariable): void;
        getByIndex(index: number): StiVariable;
        setByIndex(index: number, data: StiVariable): void;
        getByName(name: string): StiVariable;
        setByName(name: string, value: StiVariable): void;
        readonly items: Array<StiVariable>;
        clone(): Object;
        moveCategoryTo(fromCategory: string, toCategory: string): void;
        getFirstCategoryIndex(category: string): number;
        getLastCategoryIndex(category: string): number;
        renameCategory(oldName: string, newName: string): void;
        removeCategory(category: string): void;
        getVariablesCount(category: string): number;
    }
}
declare module Stimulsoft.Report.Engine {
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiChartBuilder extends StiComponentBuilder {
        static renderAtEnd(masterChart: IStiChart): void;
        static renderChart(masterChart: IStiChart): StiComponent;
        prepare(masterComp: StiComponent): void;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiFooterBand = Stimulsoft.Report.Components.StiFooterBand;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    class StiFooterBandBuilder extends StiBandBuilder {
        static getMaster(masterFooterBand: StiFooterBand): StiDataBand;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiColumnFooterBandBuilder extends StiFooterBandBuilder {
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiHeaderBand = Stimulsoft.Report.Components.StiHeaderBand;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    class StiHeaderBandBuilder extends StiBandBuilder {
        static getMaster(masterHeaderBand: StiHeaderBand): StiDataBand;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiColumnHeaderBandBuilder extends StiHeaderBandBuilder {
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCrossLinePrimitiveBuilder extends StiComponentBuilder {
        prepare(masterComp: StiComponent): void;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    import StiCrossTabParams = Stimulsoft.Report.CrossTab.StiCrossTabParams;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiCrossHeader = Stimulsoft.Report.CrossTab.StiCrossHeader;
    class StiCrossTabBuilder extends StiContainerBuilder {
        static getCollapsingName(header: StiCrossHeader): string;
        static getCollapsingName2(componentName: string, level: number, value: string): string;
        static isCollapsed(masterHeader: StiCrossHeader): boolean;
        static isCollapsed2(masterHeader: StiCrossHeader, level: number, textValue: string): boolean;
        static setCollapsed(masterHeader: StiCrossHeader, isCollapsed: boolean): void;
        static makeHorAlignment(masterCrossTab: StiCrossTab, outContainer: StiContainer, startIndex: number, parentWidth: number, pageSegment: number): void;
        renderCrossTabOnDataBand(pars: StiCrossTabParams, masterCrossTab: StiCrossTab, renderedComponent: StiContainer): StiComponent;
        renderCrossTab(pars: StiCrossTabParams, masterCrossTab: StiCrossTab): StiComponent;
        private getActualHeaderRowCount(masterCrossTab);
        prepare(masterComp: StiComponent): void;
        unPrepare(masterComp: StiComponent): void;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiGroupHeaderBand = Stimulsoft.Report.Components.StiGroupHeaderBand;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiFooterBand = Stimulsoft.Report.Components.StiFooterBand;
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiDataBandBuilder extends StiBandBuilder {
        getGroupHeaders(masterDataBand: StiDataBand): StiComponentsCollection;
        getGroupFooters(masterDataBand: StiDataBand): StiComponentsCollection;
        groupsComparison(masterDataBand: StiDataBand): void;
        findHeaders(masterDataBand: StiDataBand): void;
        findHierarchicalHeaders(masterDataBand: StiDataBand): void;
        findFooters(masterDataBand: StiDataBand): void;
        findHierarchicalFooters(masterDataBand: StiDataBand): void;
        findEmptyBands(masterDataBand: StiDataBand): void;
        findGroupHeaders(masterDataBand: StiDataBand): void;
        findGroupFooters(masterDataBand: StiDataBand): void;
        findDetailDataBands(masterDataBand: any): StiDataBand;
        private isParentOrCurrentBO(currentBO, parentBO);
        findSubReports(masterDataBand: StiDataBand): void;
        findDetails(masterDataBand: StiDataBand): void;
        resetHeaders(masterDataBand: StiDataBand): void;
        resetHierarchicalHeaders(masterDataBand: StiDataBand): void;
        resetFooters(masterDataBand: StiDataBand): void;
        resetHierarchicalFooters(masterDataBand: StiDataBand): void;
        resetEmptyBands(masterDataBand: StiDataBand): void;
        resetGroupHeaders(masterDataBand: StiDataBand): void;
        resetGroupFooters(masterDataBand: StiDataBand): void;
        resetDetailDataBands(masterDataBand: StiDataBand): void;
        resetDetails(masterDataBand: StiDataBand): void;
        addKeepLevelAtLatestDataBand(masterDataBand: StiDataBand): void;
        addKeepLevel(masterDataBand: StiDataBand): void;
        removeKeepLevel(masterDataBand: StiDataBand): void;
        removeKeepGroupHeaders(masterDataBand: StiDataBand): void;
        removeKeepHeaders(masterDataBand: StiDataBand, keepHeaders: boolean[]): void;
        allowKeepDetails(masterDataBand: StiDataBand): boolean;
        addKeepDetails(masterDataBand: StiDataBand): void;
        removeKeepDetails(masterDataBand: StiDataBand): void;
        removeKeepDetailsRow(masterDataBand: StiDataBand): void;
        startBands(masterDataBand: StiDataBand, bands: StiComponentsCollection): void;
        /** Starts monitoring of specified band OnAllPages.*/
        startBand(masterDataBand: StiDataBand, band: StiBand): void;
        /** Ends monitoring of band OnAllPages.*/
        endBands(masterDataBand: StiDataBand): void;
        getGroupHeaderResult(masterDataBand: StiDataBand, groupHeaderBand: StiGroupHeaderBand): boolean;
        getGroupFooterResult(masterDataBand: StiDataBand, groupHeaderBand: StiGroupHeaderBand): boolean;
        linkGroupHeadersAndGroupFooters(masterDataBand: StiDataBand): void;
        resetLinkGroupHeadersAndGroupFooters(masterDataBand: StiDataBand): void;
        static prepareGroupResults(masterDataBand: StiDataBand): void;
        /** Renders all group headers of this databand.*/
        renderGroupHeaders(masterDataBand: StiDataBand): void;
        renderGroupFooters(masterDataBand: StiDataBand): void;
        static setDetails(masterDataBand: StiDataBand): void;
        renderDetailDataBands(masterDataBand: StiDataBand): void;
        /** Returns databand on which specified container in splaced.*/
        private getParentDataBand(cont);
        /** Returns true if specified detail DataBand can be printed.*/
        private isAllow(master, detail);
        allowDetailDataBands(masterDataBand: StiDataBand): boolean;
        isDenyDetailsOnFirstPage(masterDataBand: StiDataBand): boolean;
        /** Gets value indicates that all detail components are empty.*/
        static isDetailDataSourcesEmpty(masterDataBand: StiDataBand): boolean;
        static isPrintIfDetailEmpty(masterDataBand: StiDataBand): boolean;
        renderHeaders(masterDataBand: StiDataBand, keepHeaders: boolean[]): void;
        renderHierarchicalHeaders(masterDataBand: StiDataBand, allowIndent: boolean, level: number): void;
        addFooterMarker(masterDataBand: StiDataBand, footerMaster: StiFooterBand): void;
        renderMarkerFootersOnAllPages(masterDataBand: StiDataBand): void;
        renderFootersOnLastPage(masterDataBand: StiDataBand): void;
        renderFootersOnAllPages(masterDataBand: StiDataBand): void;
        renderHierarchicalFooters(masterDataBand: StiDataBand, allowIndent: boolean, level: number): void;
        renderReportTitles(masterDataBand: StiDataBand): void;
        renderReportSummaries(masterDataBand: StiDataBand): void;
        checkKeepReportSummaryTogether(masterDataBand: StiDataBand): boolean;
        block(masterDataBand: StiDataBand): void;
        unBlock(masterDataBand: StiDataBand): void;
        checkHierarchicalHeaders(masterDataBand: StiDataBand): void;
        checkHierarchicalFooters(masterDataBand: StiDataBand): void;
        renderBand(masterDataBand: StiDataBand, band: StiBand, ignorePageBreaks?: boolean, allowRenderingEvents?: boolean): void;
        renderColumns(masterDataBand: StiDataBand): void;
        registerEmptyBands(masterDataBand: StiDataBand): void;
        static isCollapsed(masterDataBand: StiContainer, isRendering: boolean): boolean;
        /** Sets system variables which are specific for the specified component.*/
        setReportVariables(masterComp: StiComponent): void;
        prepare(masterComp: StiComponent): void;
        /** Clears a component after rendering.*/
        unPrepare(masterComp: StiComponent): void;
        private static invokeCollapsedEvent(masterDataBand);
        render(masterComp: StiComponent): StiComponent;
        renderMaster(masterDataBand: StiDataBand): void;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiGaugeBuilder extends StiComponentBuilder {
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiGroupFooterBand = Stimulsoft.Report.Components.StiGroupFooterBand;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiGroupFooterBandBuilder extends StiBandBuilder {
        static getMaster(masterFooterBand: StiGroupFooterBand): StiDataBand;
        setReportVariables(masterComp: StiComponent): void;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiHierarchicalBand = Stimulsoft.Report.Components.StiHierarchicalBand;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiHierarchicalBandBuilder extends StiDataBandBuilder {
        internalRender(masterComp: StiComponent): StiComponent;
        private isCollapsed(masterDataBand, isRendering?);
        static createIndention(masterHierarchical: StiHierarchicalBand, container: StiContainer, level: number): void;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiViewBuilder extends StiComponentBuilder {
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiImageBuilder extends StiViewBuilder {
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiMap = Stimulsoft.Report.Maps.StiMap;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiMapBuilder extends StiComponentBuilder {
        static renderMap(masterMap: StiMap): StiMap;
        prepare(masterComp: StiComponent): void;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiPageBuilder extends StiContainerBuilder {
        prepare(masterComp: StiComponent): void;
        unPrepare(masterComp: StiComponent): void;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiPointPrimitiveBuilder extends StiComponentBuilder {
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    class StiReportBuilder {
        static renderSingleReport(masterReport: StiReport, renderState: StiRenderState): void;
        static renderSubReports(ownerReport: StiReport, renderState: StiRenderState): void;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiSimpleTextBuilder extends StiComponentBuilder {
        prepare(masterComp: StiComponent): void;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiSubReportBuilder extends StiContainerBuilder {
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiBandInfo extends StiComponentInfo {
        forceCanBreak: boolean;
        forceCanGrow: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiContainerInfo extends StiComponentInfo {
        dataBandPosition: number;
        dataSourceRow: Stimulsoft.System.Data.DataRow;
        businessObjectCurrent: Object;
        isAutoRendered: boolean;
        ignoreResetPageNumber: boolean;
        isColumns: boolean;
        renderStep: number;
        setSegmentPerWidth: number;
        parentBand: StiBand;
    }
}
declare module Stimulsoft.Report.Components {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiDataBandInfo extends StiComponentInfo {
        groupHeaders: StiComponentsCollection;
        groupFooters: StiComponentsCollection;
        groupHeaderComponents: StiComponentsCollection;
        groupFooterComponents: StiComponentsCollection;
        detailDataBands: StiComponentsCollection;
        details: StiComponentsCollection;
        subReports: StiComponentsCollection;
        emptyBands: StiComponentsCollection;
        headers: StiComponentsCollection;
        hierarchicalHeaders: StiComponentsCollection;
        footersOnAllPages: StiComponentsCollection;
        footersOnLastPage: StiComponentsCollection;
        hierarchicalFooters: StiComponentsCollection;
        groupHeaderResults: Array<boolean>;
        groupFooterResults: Array<boolean>;
        reportTitles: Array<StiReportTitleBand>;
        reportSummaries: Array<StiReportSummaryBand>;
        detailDataBandsFromSubReports: Hashtable;
        storedParentBookmark: StiBookmark;
    }
}
declare module Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiFooterBandInfo extends StiComponentInfo {
        isTableFooter: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiGroupFooterBandInfo extends StiComponentInfo {
        printAtBottomComponent: StiComponent;
        groupHeader: StiGroupHeaderBand;
        isTableGroupFooter: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiGroupHeaderBandInfo extends StiComponentInfo {
        skipKeepGroups: boolean;
        groupFooter: StiGroupFooterBand;
        silentModeEnabled: boolean;
        oldSilentMode: boolean;
        isTableGroupHeader: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiHeaderBandInfo extends StiComponentInfo {
        isTableHeader: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiHierarchicalBandInfo extends StiComponentInfo {
        specifiedLevel: number;
        finalFooterCalculation: boolean;
    }
}
declare module Stimulsoft.Report.Engine {
    var IStiReportProperty: string;
    interface IStiReportProperty {
        getReport(): Object;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiBand = Stimulsoft.Report.Components.StiBand;
    class StiBandsOnAllPages {
        private bands;
        engine: StiEngine;
        private _denyRendering;
        /** If the property is true then bands rendering on all pages is blocked. The property is used to
         * output headers, with the height higher than one page, on all pages.*/
        denyRendering: boolean;
        /** Starts monitoring of this band for rendering OnAllPages.*/
        add(dataBand: StiDataBand, band: StiBand): void;
        /** Ends monitoring of this band for rendering OnAllPages. All bands which are dependent on the specified DataBand are removed.*/
        remove(dataBand: StiDataBand): void;
        private allowRenderBand(band);
        /** Outputs bands, which were previously added to the collection of bands, which are output on all pages, on a new page.*/
        render(): void;
        private renderBand(band, ignorePageBreaks, ignoreRenderingEvents);
        isBandInBandsList(band: StiBand): boolean;
        constructor(engine: StiEngine);
    }
}
declare module Stimulsoft.Report.Engine {
    import StiBookmark = Stimulsoft.Report.Components.StiBookmark;
    class StiBookmarksHelper {
        static getBookmark(bookmark: StiBookmark, name: string): StiBookmark;
        static prepareBookmark(bookmark: StiBookmark): void;
        static createBookmark(text: string, componentGuid?: string): StiBookmark;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiBreakableHelper {
        engine: StiEngine;
        isCanBreak(container: StiContainer): boolean;
        isNeedBreak(container: StiContainer): boolean;
        break(originalContainer: StiContainer): StiContainer;
        setCanBreak(container: StiContainer): void;
        processBreakable(container: StiContainer): StiContainer;
        constructor(engine: StiEngine);
    }
}
declare module Stimulsoft.Report.Engine {
    import StiColumnDirection = Stimulsoft.Report.Components.StiColumnDirection;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiColumnsContainer extends StiContainer {
        private countOfItems;
        columns: number;
        columnWidth: number;
        columnGaps: number;
        columnDirection: StiColumnDirection;
        rightToLeft: boolean;
        minRowsInColumn: number;
        private engine;
        /** Adds a specified container into the container of columns. The CountOfItems field is increased on 1.*/
        addContainer(container: StiContainer): void;
        /** Returns the height of space to place a container into the current container of colimns.*/
        howMuchAdditionalSpaceNeeded(currentHeight: number, container: StiContainer): number;
        /** Finishes column formation in the container of columns. All containers are placed on their proper places.*/
        finishColumns(onlyCalc?: boolean): number;
        /** Returns the number of a column on the current moment. The number starts with 1.*/
        getCurrentColumn(): number;
        /** Returns the number of output databands in the last row. The method can be used only for the  AcrossThenDown mode.*/
        getLengthOfLastRow(): number;
        constructor(engine?: StiEngine);
    }
}
declare module Stimulsoft.Report.Engine {
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    class StiColumnsOnDataBand {
        engine: StiEngine;
        private _enabled;
        /** Gets or sets value which indicates about current state of column on DataBand mode.*/
        enabled: boolean;
        /** Adds a container of columns to the current page.
         * A container of columns is used to output columns on a databand.*/
        renderColumns(dataBand: StiDataBand): StiColumnsContainer;
        /** Returns a container of columns that is the last on a page.
         * If after a container of columns other bands were output then return null.*/
        getColumns(): StiColumnsContainer;
        /** Creates and returns a container to output columns on a Databand.*/
        createColumns(dataBand: StiDataBand): StiColumnsContainer;
        constructor(engine: StiEngine);
    }
}
declare module Stimulsoft.Report.Engine {
    class StiColumnsOnPanel {
        engine: StiEngine;
        readonly count: number;
        readonly rightToLeft: boolean;
        readonly columnGaps: number;
        private _currentColumn;
        currentColumn: number;
        getColumnWidth(): number;
        constructor(engine: StiEngine);
    }
}
declare module Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiEmptyBandsHelper {
        engine: StiEngine;
        private emptyBand;
        register(emptyBands: StiComponentsCollection): void;
        clear(): void;
        private createEmptyBandContainer(containerForRender);
        render(containerForRender: StiContainer, selectedContainer: StiContainer): void;
        constructor(engine: StiEngine);
    }
}
declare module Stimulsoft.Report.Engine {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiFooterBand = Stimulsoft.Report.Components.StiFooterBand;
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import IStiPageBreak = Stimulsoft.Report.Components.IStiPageBreak;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiSimpleText = Stimulsoft.Report.Components.StiSimpleText;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiEngine {
        /** If true then it is allowed to add any Bookmarks. If false then
         * add Bookmarks of components which the IsRendered property = false
         * (in other words it is rendered first time). This property allows adding Bookmarks
         * for static components only once (to avoid duplication).*/
        isDynamicBookmarksMode: boolean;
        /** This property is set to true for printing CrossBands.*/
        isCrossBandsMode: boolean;
        /** Returns true if the first DataBand is printed on the current page. */
        isFirstDataBandOnPage: boolean;
        /** Returns true if the last DataBand is printed on the current page.*/
        isLastDataBandOnPage: boolean;
        /** Contains the list of bands which should be passed when rendering.*/
        printOnAllPagesIgnoreList: Hashtable;
        private printOnAllPagesIgnoreList2;
        /** A class helps to output the progress bar when report rendering.*/
        /** Contains a collection of bands which should be output on all pages.*/
        bandsOnAllPages: StiBandsOnAllPages;
        /** If true then the Render method of a container will not render components of the
         * Master type. This property is used with the RenderSimpleComponents method of a page.
         * It is used to deny master components and render simple ones.*/
        denyRenderMasterComponentsInContainer: boolean;
        /** Contains a collection of bands which should be output on the bottom of a page.
         * The list is filled when stream rendering and the list is cleared when rendering
         * of the current stream is finished.*/
        printAtBottom: StiPrintAtBottom;
        /** Cotnains a collection of Footers which should be output on the bottom of a page.
         * The list is filled when stream rendering and the list is cleared when rendering
         * of the current stream is finished.*/
        footersOnAllPages: StiFootersOnAllPages;
        /** An object helps to output static bands on a page.*/
        staticBands: StiStaticBandsHelper;
        /** This object helps to print groups of bands from containers which are placed directly on a page.*/
        threads: StiThreads;
        /** An object helps to work with IStiBreakable interface.*/
        breakable: StiBreakableHelper;
        /** If true then it is impossible to change stream of printing.*/
        denyChangeThread: boolean;
        /** Contains a list of Slave Engines.*/
        slaveEngines: Hashtable;
        /** If an engine is slave then this reference indicates the parent report engine. */
        masterEngine: StiEngine;
        /** Used to output EmptyBands in the current container.*/
        emptyBands: StiEmptyBandsHelper;
        pageNumbers: StiPageNumberHelper;
        /** Used to output columns on the DataBand.*/
        columnsOnDataBand: StiColumnsOnDataBand;
        /** Used to output columns on the Panel.*/
        columnsOnPanel: StiColumnsOnPanel;
        /** Contains a freespace in a container in what the printing is done.*/
        freeSpace: number;
        /** Contains a freespace in a container in what the printing is done. Used to output Cross bands only.*/
        crossFreeSpace: number;
        /** Indicates the current position bands output on the X axis.*/
        positionX: number;
        /** Indicates the current position bands output on the Y axis.*/
        positionY: number;
        /** Indicates the current position bands output on the Y axis on the bottom of a page.*/
        positionBottomY: number;
        /** Gets or sets a container in what rendering of bands is done.*/
        containerForRender: StiContainer;
        /** Gets or sets a page in what rendering of bands is done.*/
        page: StiPage;
        /** Gets or sets a page from a template. This page is being rendered in the current moment.*/
        templatePage: StiPage;
        /** Gets or sets a container from a template. This page is being rendered in the current moment. If a page is output then
         * the TemplateContainer property is equal in TemplatePage.*/
        templateContainer: StiContainer;
        /** Gets or sets a report that is being rendered in the current moment.*/
        report: StiReport;
        /** Gets or sets a master report that is being rendered in the current moment.*/
        masterReport: StiReport;
        /** If true then UnlimitedHeight property is ignored when NewPage method is called.*/
        ignoreUnlimitedHeightForNewPage: boolean;
        /** Contains a list of stored bands for keepFirstDetailTogether property*/
        keepFirstDetailTogetherList: Hashtable;
        keepFirstDetailTogetherTablesList: Hashtable;
        specialContainerHeight: number;
        specialContainerHeight2: number;
        static specialContainerHeight2: number;
        startIndexPageForPageTotal: number;
        indexPageForPageTotal: number;
        private childsBandHash;
        silentMode: boolean;
        renderState: StiRenderState;
        indexOfLatestDataBand: StiIndex;
        generateNewPageBeforeBand: boolean;
        ignoreSkipFirst: boolean;
        generateNewColumnBeforeBand: boolean;
        /** Коллекция служит для определения случая пропуска генерации новой страницы или новой колонки при помощи свойства SkipFirst.
         * Если бэнд уже пропускал один раз генерацию новой страницы или колонки, то он заносится в эту коллекцию.*/
        pageBreakSkipFirstCollection: Hashtable;
        indexOfStartList: number;
        skipFirstPageBeforePrintEvent: boolean;
        firstCallNewPage: boolean;
        /** Флаг устанавливается во время рендеринга StiBandsOnAllPages для того,
         * чтобы датабэнды, которые выводятся на каждой странице, не обнуляли этот список*/
        denyClearPrintOnAllPagesIgnoreList: boolean;
        duplilcatesLastValues: Hashtable;
        anchorsArguments: Hashtable;
        private needResetPageNumberForNewPage;
        private _parserConversionStore;
        parserConversionStore: Hashtable;
        hashParentStyles: Hashtable;
        private _hashUseParentStyles;
        hashUseParentStyles: Hashtable;
        lastInvokeTextProcessValueEventArgsValue: Object;
        atLeastOneDatabandRenderedOnPage: boolean;
        lastFreeSpaceOnPageAfterNewList: number;
        bandsInProgress: StiBand[];
        allowEndOfPageProcessing: boolean;
        private flagRenderColumnsOnDataBandOnNewPage;
        private componentPlacementRemakeTable;
        hashCheckSize: Hashtable;
        hashDataSourceReferencesCounter: Hashtable;
        offsetNewColumnY: number;
        latestProgressValue: number;
        newList(skipStaticBands?: boolean): void;
        newColumn(ignoreKeepContainers?: boolean): void;
        newPage(ignoreKeepContainers?: boolean): void;
        private newContainer(ignoreKeepContainers);
        newDestination(ignoreKeepContainers?: boolean): void;
        /** Adds a FooterMarker (special container) into the current container of output.
         * A container-marker is used for the engine to know on what place in a container
         * of output FooterBands for PrintOnAllPages should be replaced after their rendering is complete.*/
        addFooterMarker(footerMaster: StiFooterBand): void;
        /** Adds a container-marker of the beginning of grouping before the last rendered DataBand.*/
        addKeepLevelAtLatestDataBand(): void;
        /** Adds a container-marker of the beginning of grouping into the current position of output in the stream.*/
        addLevel(): void;
        /** Adds a container-marker of the end of grouping into the current position of output in the stream.*/
        removeLevel(): void;
        private getChildBands(band);
        clearPageBreakSkipFirst(): void;
        canGenerateNewContainer(pageBreak: IStiPageBreak): boolean;
        removeBandFromPageBreakSkipList(pageBreak: IStiPageBreak): void;
        processPageAfterRendering(page: StiPage, final: boolean): void;
        processLastPageAfterRendering(): void;
        private processRendering();
        private reprocessRuntimeVariables(container);
        finalClear(): void;
        private isPrintAtBottomOrFooterOnAllPages(container);
        private changeEngineParamsByKeep(containerForRender, selectedContainer);
        private setNewColumnParameters();
        setNewPageParameters(): void;
        private processNewContainerBefore(band);
        private processNewContainerAfter(band);
        private processNewContainerInDetailBands(band, newPage, newColumn);
        private searchStartOfKeepContainer(cont, oldIndexOfStartList);
        private moveKeepComponentsOnNextContainer(cont, selectedStartCont);
        private correctPrintOnAllPagesIgnoreListBeforeNewList(cont, selectedStartCont, clear);
        private isNeedToPrintOddEven(band);
        private isNeedToSkip(band);
        renderFootersOnAllPages(outContainer: StiContainer, startIndex?: number, REFmarkerContainer?: any): void;
        renderEmptyBands(containerForRender: StiContainer, selectedContainer: StiContainer): void;
        renderPrintAtBottom(container: StiContainer, startIndex: number, markerContainer: StiContainer): void;
        finishContainer(containerForRender: StiContainer): void;
        finishResetPageNumberContainer(containerForRender: StiContainer, isFinal: boolean): void;
        finishColumns(containerForRender: StiContainer): void;
        /** Adds a specified container into the container for output.*/
        addContainerToDestination(container: StiContainer): void;
        invokePageAfterPrint(): void;
        addPageToRenderedPages(page: StiPage): void;
        private checkFreeSpace1(container);
        private checkFreeSpace2(value);
        private storeLatestDataBand(band);
        private setReportVariables(band);
        checkForDuplicate(textName: string, value: string, tag: string): boolean;
        resetProcessingDuplicates1(componentName: string): void;
        resetProcessingDuplicates2(component: StiSimpleText): void;
        getSumTagsOnPage(page: StiPage, componentName: string): number;
        getComponentByNameFromRenderedPage(page: StiPage, componentName: string): StiComponent;
        renderBand(band: StiBand, ignorePageBreaks?: boolean, allowRenderingEvents?: boolean): StiComponentsCollection;
        private internalRenderBand(band, ignorePageBreaks?, allowRenderingEvents?, REFisChildsEnabled?);
        private checkContainerOnTable(panel);
        renderContainer(container: StiContainer, isPrintAtBottom?: boolean, isFooterOnAllPages?: boolean): StiContainer;
        private internalRenderColumnsContainer(container);
        private internalRenderContainerToColumns(container, isPrintAtBottom, isFooterOnAllPages);
        private internalRenderContainer(container, isPrintAtBottom, isFooterOnAllPages);
        constructor(report: StiReport);
    }
}
declare module Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiFooterMarkerContainer extends StiContainer {
    }
}
declare module Stimulsoft.Report.Engine {
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiFootersOnAllPages {
        private bands;
        engine: StiEngine;
        add(container: StiContainer): void;
        canProcess(band: StiBand): boolean;
        render(outContainer: StiContainer, startIndex: number, REFmarkerContainer: any): void;
        constructor(engine: StiEngine);
    }
}
declare module Stimulsoft.Report.Engine {
    class StiIndex {
        index: number;
        indexInColumnContainer: number;
        constructor(index: number, indexInColumnContainer?: number);
    }
}
declare module Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiLevelContainer extends StiContainer {
    }
}
declare module Stimulsoft.Report.Engine {
    class StiLevelEndContainer extends StiLevelContainer {
        constructor();
    }
}
declare module Stimulsoft.Report.Engine {
    class StiLevelStartContainer extends StiLevelContainer {
        constructor();
    }
}
declare module Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiNewPageContainer extends StiContainer {
        constructor();
    }
}
declare module Stimulsoft.Report.Engine {
    import IStiOddEvenStyles = Stimulsoft.Report.Components.IStiOddEvenStyles;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    class StiOddEvenStylesHelper {
        static applyOddEvenStyles(report: StiReport, styles: IStiOddEvenStyles, cont: StiContainer): StiBaseStyle;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiSubReport = Stimulsoft.Report.Components.StiSubReport;
    import StiReportSummaryBand = Stimulsoft.Report.Components.StiReportSummaryBand;
    import StiReportTitleBand = Stimulsoft.Report.Components.StiReportTitleBand;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiPageHelper {
        static createListOfDataBands(page: StiPage, dataBandsOnPage: StiDataBand[], dataBandsInContainers: StiDataBand[], subReportsOnPage: StiSubReport[], crossTabsOnPage: StiCrossTab[]): void;
        static getReportTitles(page: StiPage): StiReportTitleBand[];
        static getReportSummaries(page: StiPage): StiReportSummaryBand[];
        static renderSimpleComponents(page: StiPage, outContainer: StiContainer): void;
        static prepareBookmark(page: StiPage): void;
        static renderPage(page: StiPage): void;
        static renderOverlays(masterPage: StiPage, renderedPage: StiPage): void;
        static getPageFromTemplate(templatePage: StiPage): StiPage;
    }
}
declare module Stimulsoft.Report.Engine {
    class StiPageNumber {
        resetPageNumber: boolean;
        pageNumber: number;
        totalPageCount: number;
        pageNumberThrough: number;
        totalPageCountThrough: number;
        segmentPerWidth: number;
        segmentPerHeight: number;
        readonly step: number;
        fixedPosition: boolean;
    }
}
declare module Stimulsoft.Report.Engine {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiPageNumberCollection extends CollectionBase<StiPageNumber> {
        add(pageNumber: StiPageNumber): void;
        getByIndex(index: number): StiPageNumber;
        setByIndex(index: number, value: StiPageNumber): void;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiPageNumberHelper {
        private engine;
        private finished;
        private _clearPageNumbersOnFinish;
        clearPageNumbersOnFinish: boolean;
        private _pageNumbers;
        pageNumbers: StiPageNumberCollection;
        resetPageNumber(pageIndex?: number): void;
        addPageNumber(pageIndex: number, segmentPerWidth: number, segmentPerHeight: number): void;
        getPageNumber(page: StiPage): number;
        getPageNumber(pageIndex: number): number;
        getTotalPageCount(page: StiPage): number;
        getTotalPageCount(pageIndex: number): number;
        getPageNumberThrough(page: StiPage): any;
        getPageNumberThrough(pageIndex: number): any;
        getTotalPageCountThrough(pageIndex: number): number;
        /** Calculates the PageNumber and TotalPageCount values for each page in the specified range.*/
        private setSystemVariables(startIndex, endIndex);
        /** Counts the PageNumber, TotalPageCount, PageNumberThrough, and TotalPageCountThrough values for every page.*/
        processPageNumbers(): void;
        clear(): void;
        clearNotFixed(): void;
        constructor(engine: StiEngine);
    }
}
declare module Stimulsoft.Report.Engine {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    enum TypeOfDuplicates {
        Text = 0,
        Image = 1,
    }
    class StiMergeComparer implements IComparer<StiComponent> {
        compare(x: StiComponent, y: StiComponent): number;
    }
    class StiPostProcessDuplicatesHelper {
        private static isImageEqual(image1, image2);
        static postProcessDuplicates(comps: StiComponentsCollection, parentCont: Hashtable, typeOfDuplicates?: TypeOfDuplicates): void;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    import StiCrossLinePrimitive = Stimulsoft.Report.Components.StiCrossLinePrimitive;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiLinePrimitive = Stimulsoft.Report.Components.StiLinePrimitive;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiPostProcessProvider {
        private static nullGuid;
        static postProcessPages(pages: StiPagesCollection): void;
        private static removeAllPointPrimitives(container);
        static postProcessPrimitives(page: StiPagesCollection | Stimulsoft.Report.Components.StiPage): void;
        static postProcessPrimitivesInContainer(container: StiContainer): void;
        static postProcessPrimitivesInContainer2(container: StiContainer, pages: StiPagesCollection, REFstartPointsHash: any, REFendPointsHash: any, REFlines: any, REFendPoints: any): void;
        private static processOneEndPoint(startPointsHash, lines, page, pages, endPoint);
        private static processOnePrimitive(pages, page, crossLine, startPoint, nextStartPoint, endPoint);
        static addPrimitive(crossLine: StiCrossLinePrimitive, startPos: PointD, endPos: PointD, page: StiContainer): void;
        static copyStyles(dest: StiLinePrimitive, source: StiLinePrimitive): void;
        static postProcessPage(page: Stimulsoft.Report.Components.StiPage, isFirstPage: boolean, isLastPage: boolean, clearPage?: boolean): void;
        private static postProcessPrintOn(comps, isFirstPage, isLastPage);
        private static allowPrintOn(comp, isFirstPage, isLastPage);
    }
}
declare module Stimulsoft.Report.Engine {
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiPrintAtBottom {
        private bands;
        engine: StiEngine;
        canProcess(band: StiBand): boolean;
        add(container: StiContainer): void;
        render(outContainer: StiContainer, startIndex: number, markerContainer: StiContainer): void;
        constructor(engine: StiEngine);
    }
}
declare module Stimulsoft.Report.Engine {
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import Promise = Stimulsoft.System.Promise;
    class StiRenderProvider {
        static render(report: StiReport, state: StiRenderState): void;
        static StiRenderProviderV2_AddAnchor_Rendering(sender: any, e: EventArgs): void;
        static connectToDataAsync(report: StiReport): Promise<void>;
        static connectToData(report: StiReport): void;
        private static disconnectFromData(report);
        private static isDialogsOnStartExist(report);
        private static renderFormsOnStart(report);
        private static renderFormsOnEnd(report);
        private static checkDialogsInPreview(report);
        static clearPagesWhichLessThenFromPageAndGreaterThenToPage(report: StiReport, state: StiRenderState): void;
        private static initCacheMode(report);
        private static removeAllPagesLessThenFromPageAndGreaterThenToPage(report, state);
        private static finishAllPagesInNotCachedPagesArray(report);
        static processPageToCache(report: StiReport, page: StiPage, final: boolean): void;
        static isFirstPage(report: StiReport, page: StiPage): boolean;
        static isLastPage(report: StiReport, page: StiPage): boolean;
        private static renderFirstPass(report, numberOfPass);
        static clearPagesForFirstPass(report: StiReport): void;
        private static getNumberOfPass(report);
        private static madeCollate(report);
        private static madeMirrorMargins(report);
        private static initReport(report);
        private static clearTotals(report);
        private static prepareSubReportsAndDrillDownPages(report);
        private static renderReport(report, masterReport, state);
        static renderTable(report: StiReport): void;
        private static finishProgressForm(report);
    }
}
declare module Stimulsoft.Report.Engine {
    class StiRenderState {
        latestProgressValue: number;
        private _fromPage;
        readonly fromPage: number;
        private _toPage;
        readonly toPage: number;
        private _showProgress;
        showProgress: boolean;
        private _isSubReportMode;
        isSubReportMode: boolean;
        private _destroyPagesWhichNotInRange;
        readonly destroyPagesWhichNotInRange: boolean;
        private _renderOnlyPagesFromRange;
        readonly renderOnlyPagesFromRange: boolean;
        constructor(fromPage?: number, toPage?: number, showProgress?: boolean, destroyPagesWhichNotInRange?: boolean, renderOnlyPagesFromRange?: boolean);
    }
}
declare module Stimulsoft.Report.Engine {
    class StiStaticBandsHelper {
        private denyReportBands;
        private denyPageBands;
        engine: StiEngine;
        private _reservedFreeSpace;
        readonly reservedFreeSpace: number;
        private _reservedCrossFreeSpace;
        readonly reservedCrossFreeSpace: number;
        private _reservedPositionX;
        readonly reservedPositionX: number;
        private _reservedPositionY;
        readonly reservedPositionY: number;
        private _reservedPositionBottomY;
        readonly reservedPositionBottomY: number;
        render(): void;
        private renderTitleBeforeHeader();
        private renderHeaderBeforeTitle();
        private renderReportTitleBands();
        private renderPageHeaderBands();
        private renderPageFooterBands();
        private getPageHeaders();
        private getPageFooters();
        private getPageHeadersFromPage(page);
        private getPageFootersFromPage(page);
        constructor(engine: StiEngine);
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiFillParametersEventHandler: EventHandler;
    class StiFillParametersEventArgs extends EventArgs {
        private val;
        value: {
            key: string;
            value: any;
        }[];
        constructor(value?: {
            key: string;
            value: any;
        }[]);
    }
}
declare module Stimulsoft.Report.Engine {
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiSubReport = Stimulsoft.Report.Components.StiSubReport;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiSubReportsHelper {
        static getMasterDataBand(parent: StiContainer): StiDataBand;
        static getParentBand(parent: StiContainer): StiBand;
        static renderSubReport(containerOfSubReport: StiContainer, subReport: StiSubReport): void;
        static specialSubReportHeight: number;
        private static renderInternalSubReport(subReport);
        private static renderExternalSubReport(subReport, externalReport);
        static renderDataBandsInContainer(containerOfDataBands: StiContainer, container: StiContainer, skipStaticBands?: boolean): void;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiThreads {
        isActive: boolean;
        currentPage: number;
        currentColumn: number;
        destinationName: string;
        /** Prepares a new page to output a container. A new page is not always a page*/
        newPage(): void;
        /** Sets the stream to output the specified component. If the stream does not exist then it is created.*/
        selectThreadFromContainer(container: StiContainer): void;
        /** Creates a new engine sample to output in the specified container.*/
        createContainerEngine(destinationName: string, report: StiReport, masterEngine: StiEngine, indexOfStartRenderedPages: number): StiEngine;
        getTemplateContainer(template?: StiContainer, name?: string): StiContainer;
        getDestinationContainer(): StiContainer;
        private getDestinationContainer2(container, name, columnNumber);
        engine: StiEngine;
        constructor(engine: StiEngine);
    }
}
declare module Stimulsoft.Report.Engine {
    import StiVariable = Stimulsoft.Report.Dictionary.StiVariable;
    class StiVariableHelper {
        static fillItemsOfVariables(compiledReport: StiReport): void;
        static fillItemsOfVariables2(variable: StiVariable, compiledReport: StiReport): boolean;
        static setDefaultValueForRequestFromUserVariables(compiledReport: StiReport): void;
        static getDataSourcesWithRequestFromUserVariablesInCommand(report: StiReport): Array<string>;
        private static checkExpressionForVariables(expression, component, vars);
    }
}
declare module Stimulsoft.Report.Events {
    class StiAfterSelectEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiCheckedChangedEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiClosedFormEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiClosingFormEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiEnterEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiExportEventHandler: EventHandler;
    class StiExportEventArgs extends EventArgs {
        exportFormat: StiExportFormat;
        constructor(format: StiExportFormat);
    }
}
declare module Stimulsoft.Report.Events {
    class StiExportedEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiExportingEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiFillDataEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetArgumentEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetBarCodeEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiGetDataUrlEventHandler: EventHandler;
    class StiGetDataUrlEventArgs extends EventArgs {
        value: string;
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiGetDrillDownReportEventHandler: EventHandler;
    class StiGetDrillDownReportEventArgs extends EventArgs {
        report: StiReport;
        cancel: boolean;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetFilterEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetZipCodeEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    /**
     * @hidden
     */
    let StiGotoCompEventHandler: EventHandler;
    /**
     * @hidden
     */
    class StiGotoCompEventArgs extends EventArgs {
        component: Stimulsoft.Report.Components.StiComponent;
        constructor(component: Stimulsoft.Report.Components.StiComponent);
    }
}
declare module Stimulsoft.Report.Events {
    class StiLoadFormEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiMouseDownEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiMouseMoveEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiMouseUpEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiMoveFooterToBottomEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    let StiPaintEventHandler: EventHandler;
    class StiPaintEventArgs extends EventArgs implements ICloneable {
        clone(): Object;
        context: Object;
        readonly graphics: Graphics;
        clipRectangle: RectangleD;
        drawChilds: boolean;
        cancel: boolean;
        drawBorderFormatting: boolean;
        drawTopmostBorderSides: boolean;
        constructor(context: Object, clipRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Events {
    class StiPositionChangedEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiPrintedEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiPrintingEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import StiExportService = Stimulsoft.Report.Export.StiExportService;
    import StiExportSettings = Stimulsoft.Report.Export.StiExportSettings;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    let StiProcessExportEventHandler: EventHandler;
    class StiProcessExportEventArgs extends StiExportEventArgs {
        exportService: StiExportService;
        stream: MemoryStream;
        exportSettings: StiExportSettings;
        processed: boolean;
        constructor(format: StiExportFormat, exportService: StiExportService, stream: MemoryStream, settings: StiExportSettings);
    }
}
declare module Stimulsoft.Report.Events {
    class StiReportCacheProcessingEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiSelectedIndexChangedEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiStateRestoreEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiStateSaveEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiValueChangedEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Export {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    class StiExportService {
        exportFormat: StiExportFormat;
        isStopped: boolean;
        renderedPagesCount: number;
        currentPassNumber: number;
        maximumPassNumber: number;
        exportServiceId: string;
        invokeExporting(page: StiPage, pages: StiPagesCollection, currentPass: number, maximumPass: number): void;
        invokeExporting2(value: number, maximum: number, currentPass: number, maximumPass: number): void;
    }
}
declare module Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiCsvExportService extends StiExportService {
        readonly defaultExtension: string;
        readonly exportFormat: StiExportFormat;
        readonly groupCategory: string;
        readonly position: number;
        readonly exportNameInMenu: string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private report;
        private fileName;
        private sendEMail;
        multipleFiles(): boolean;
        readonly getFilter: string;
        private writer;
        exportCsv(report: StiReport, stream: MemoryStream, settings: StiDataExportSettings): void;
    }
}
declare module Stimulsoft.Report.Export {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiBrushSvgHelper {
        static hatchData: string[];
        static writeHatchBrush(writer: XmlTextWriter, brush: any): string;
        private static hexToByteString(hex);
        static writeGlareBrush(writer: XmlTextWriter, brush: any, rect: RectangleD): string;
        static writeGradientBrush(writer: XmlTextWriter, brush: any, rect: RectangleD): string;
        static writeGlassBrush(writer: XmlTextWriter, brush: any, rect: RectangleD): string;
    }
}
declare module Stimulsoft.Report {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiCurveHelper {
        static cardinalSpline(pts: PointD[], closed: boolean): PointD[];
        private static calcCurveEnd(end, adj, tension);
        private static calcCurve(pts, tenstion);
    }
}
declare module Stimulsoft.Report.Export {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import Image = Stimulsoft.System.Drawing.Image;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    class StiChartSvgHelper {
        private static isAddStimulsoftIconFont;
        private static dx;
        private static dy;
        private static listTransformGeom;
        static getImage(svgData: StiSvgData): Image;
        static addAnimation(writer: XmlTextWriter, actions: string, begin: TimeSpan, duration: TimeSpan, numberr?: string): void;
        static writeChart(writer: XmlTextWriter, svgData: StiSvgData, zoom: number, needAnimation: boolean): void;
        private static writeInteracrion(writer, interaction);
        private static getPathData(geoms, dx, dy, refAnimatedPath, refDuration);
        private static addArcPath(arcSegment, path, dx, dy);
        private static round(value);
        private static addPiePath(pieSegment, path, dx, dy, animatedPath, refDuration);
        static correctRectLabel(rotationMode: StiRotationMode, textRect: RectangleD): RectangleD;
        private static convertArcToCubicBezier(rect, startAngle1, sweepAngle1);
        static writeFillBrush(writer: XmlTextWriter, brush: any, rect: RectangleD): string;
        private static writeBorderStroke(writer, brush, rect);
        private static convertSplineToCubicBezier(points, tension);
        private static calculateCurveBezier(points, index, tension);
        private static calculateCurveBezierEndPoints(end, adj, tension);
        private static writeBrush(writer, brush, rect);
        private static checkPenGeom(penGeom);
        private static p(f);
        static writeStimulsoftIconFont(): void;
    }
}
declare module Stimulsoft.Report.Painters {
    import StiGaugeGeom = Stimulsoft.Report.Gauge.GaugeGeoms.StiGaugeGeom;
    import StiGraphicsPathGaugeGeom = Stimulsoft.Report.Gauge.GaugeGeoms.StiGraphicsPathGaugeGeom;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import RectangleF = Stimulsoft.System.Drawing.Rectangle;
    import Font = Stimulsoft.System.Drawing.Font;
    import SizeF = Stimulsoft.System.Drawing.Size;
    import PointF = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import IStiGauge = Stimulsoft.Report.Components.Gauge.IStiGauge;
    class StiGaugeContextPainter {
        zoom: number;
        rect: RectangleF;
        gauge: IStiGauge;
        geoms: StiGaugeGeom[];
        static changeFontSize(font: Font, zoom: number): Font;
        measureString(text: string, font: Font): SizeF;
        addPieGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number, startAngle: number, sweepAngle: number): void;
        addEllipseGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number): void;
        addGraphicsArcGeometryGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number, startAngle: number, sweepAngle: number, startWidth: number, endWidth: number): void;
        addPopTranformGaugeGeom(): void;
        addPushMatrixGaugeGeom(angle: number, centerPoint: PointF): void;
        addRadialRangeGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number, centerPoint: PointF, startAngle: number, sweepAngle: number, radius1: number, radius2: number, radius3: number, radius4: number): void;
        addRectangleGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number): void;
        addRoundedRectangleGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number, leftTop: number, rightTop: number, rightBottom: number, leftBottom: number): void;
        addTextGaugeGeom(text: string, font: Font, foreground: StiBrush, rect: RectangleF, sf: StringFormat): void;
        addGraphicsPathGaugeGeom(geom: StiGraphicsPathGaugeGeom): void;
        render(): void;
        constructor(gauge: IStiGauge, rect: RectangleF, zoom: number);
    }
}
declare module Stimulsoft.Report.Export {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    class StiGaugeSvgHelper {
        private static readonly PiDiv180;
        private static readonly FourDivThree;
        private static addAnimation(writer, actions, begin, duration, number?);
        static writeGauge(writer: XmlTextWriter, svgData: StiSvgData, zoom?: number, needAnimation?: boolean): void;
        private static getPathData(geoms, startPoint);
        static getArcPath(rect: Rectangle, path_: string, startAngle: number, sweepAngle: number, isSetStartPoint: boolean): string;
        private static convertArcToCubicBezier(centerPoint, radius, startAngle, sweepAngle);
        private static addArcPath(arcSegment, path);
        private static addPiePath(pieSegment, path);
        private static convertArcToCubicBezier2(rect, startAngle1, sweepAngle1);
        private static convertArcToCubicBezier3(centerPoint, radius1, radius2, startAngle, sweepAngle);
        private static round(value);
        private static calculateCurveBezier(points, index, tension);
        private static calculateCurveBezierEndPoints(end, adj, tension);
        static writeFillBrush(writer: XmlTextWriter, brush: any, rect: Rectangle): string;
        private static writeBorderStroke(writer, brush, rect);
        private static rectToRectangle(rect);
    }
}
declare module Stimulsoft.Report.Styles {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMapStyle extends StiBaseStyle {
        readonly componentId: StiComponentId;
        private _colors;
        colors: Color[];
        private _heatmapColors;
        heatmapColors: Color[];
        private _defaultColor;
        defaultColor: Color;
        private _backColor;
        backColor: Color;
        private _foreColor;
        foreColor: Color;
        private _borderSize;
        borderSize: number;
        private _borderColor;
        borderColor: Color;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
declare module Stimulsoft.Report.Maps {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiMapStyle = Stimulsoft.Report.Styles.StiMapStyle;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiBorder = Stimulsoft.Report.Components.IStiBorder;
    import IStiBrush = Stimulsoft.Report.Components.IStiBrush;
    import IStiDataSource = Stimulsoft.Report.Components.IStiDataSource;
    import IStiBusinessObject = Stimulsoft.Report.Components.IStiBusinessObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiMap extends StiComponent implements IStiBorder, IStiBrush, IStiDataSource, IStiBusinessObject {
        private static implementsStiMap;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties?: boolean): StiMap;
        isExportAsImage(format: StiExportFormat): boolean;
        readonly isDataSourceEmpty: boolean;
        readonly dataSource: StiDataSource;
        private _dataSourceName;
        dataSourceName: string;
        readonly isBusinessObjectEmpty: boolean;
        readonly businessObject: StiBusinessObject;
        private _businessObjectGuid;
        businessObjectGuid: string;
        private _countData;
        countData: number;
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        isEofValue: boolean;
        isEof: boolean;
        isBofValue: boolean;
        isBof: boolean;
        readonly isEmpty: boolean;
        positionValue: number;
        position: number;
        readonly count: number;
        private isCacheValues;
        private cachedCount;
        private cachedIsBusinessObjectEmpty;
        private cachedIsDataSourceEmpty;
        private cachedDataSource;
        private cachedBusinessObject;
        cacheValues(cache: boolean): void;
        private _border;
        border: StiBorder;
        private _brush;
        brush: StiBrush;
        readonly componentId: StiComponentId;
        readonly localizedCategory: string;
        readonly localizedName: string;
        readonly defaultClientRectangle: RectangleD;
        private _mapStyle;
        mapStyle: StiMapStyleIdent;
        private _stretch;
        stretch: boolean;
        private _showValue;
        showValue: boolean;
        private _mapID;
        mapID: StiMapID;
        private _showLegend;
        showLegend: boolean;
        private _showName;
        showName: boolean;
        private _mapType;
        mapType: StiMapType;
        private isMapDataChanged;
        private _mapData;
        mapData: string;
        private _keyDataColumn;
        keyDataColumn: string;
        private _nameDataColumn;
        nameDataColumn: string;
        private _valueDataColumn;
        valueDataColumn: string;
        private _groupDataColumn;
        groupDataColumn: string;
        private _colorDataColumn;
        colorDataColumn: string;
        private _latitude;
        latitude: string;
        private _longitude;
        longitude: string;
        private _mapMode;
        mapMode: StiMapMode;
        private _isHashDataEmpty;
        readonly isHashDataEmpty: boolean;
        createNew(): StiComponent;
        private _hashData;
        getMapData(): StiMapData[];
        getCurrentStyleColors(): Color[];
        static getStyleColors(style: StiMapStyleIdent): Color[];
        getStyleBackground(): StiBrush;
        static getMapStyle2(map: StiMap): StiMapStyle;
        static getMapStyle(style: StiMapStyleIdent): StiMapStyle;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Export {
    import SolidBrush = Stimulsoft.System.Drawing.SolidBrush;
    import Brush = Stimulsoft.System.Drawing.Brush;
    import StiMap = Stimulsoft.Report.Maps.StiMap;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    class StiMapSvgHelper {
        static defaultBrush: Brush;
        static drawMap(xmlsWriter: XmlTextWriter, map: StiMap, width: number, height: number, animated: boolean): void;
        static render(map: StiMap, xmlsWriter: XmlTextWriter, animated: boolean, sScale: number): void;
        private static writeBorderStroke(writer, color);
        static writeFillBrush(writer: XmlTextWriter, brush: SolidBrush): string;
        private static getFill(mapData, map, heatmapInfo, hashGroup);
        private static getGroupedBrush(mapData, heatmapInfo, hashGroup, map);
        private static getNoneBrush(mapData, map);
        private static fillGroupColors(colorsContainer, map, hashGroup);
        private static initData(map, mapData, hashGroup);
    }
}
declare module Stimulsoft.Report.Export {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiSvgData {
        private _x;
        /** X coordinate of the border. */
        x: number;
        private _y;
        /** Y coordinate of the border. */
        y: number;
        private _width;
        /** Width of the border. */
        width: number;
        private _height;
        /** Height of the border. */
        height: number;
        private _right;
        /** Right (X + Width) coordinate of the border. */
        readonly right: number;
        private _bottom;
        /** Bottom (Y + Height) coordinate of the border. */
        readonly bottom: number;
        component: StiComponent;
    }
}
declare module Stimulsoft.Report.Export {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import Pen = Stimulsoft.System.Drawing.Pen;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiSvgGeomWriter implements IStiExportGeomWriter {
        constructor(writer: XmlTextWriter);
        private writer;
        beginPath(): void;
        closeFigure(): void;
        endPath(): void;
        fillPath(brush: any): void;
        strokePath(pen: any): void;
        moveTo(point: PointD): void;
        drawLine(pointFrom: PointD, pointTo: PointD, pen: any): void;
        drawLineTo(pointTo: PointD, pen: any): void;
        drawRectangle(rect: RectangleD, pen: any): void;
        drawPolyline(points: PointD[], pen: any): void;
        drawPolylineTo(points: PointD[], pen: any): void;
        drawPolygon(points: PointD[], pen: any): void;
        fillPolygon(points: PointD[], brush: any): void;
        drawBezier(p1: PointD, p2: PointD, p3: PointD, p4: PointD, pen: any): void;
        drawBezierTo(p2: PointD, p3: PointD, p4: PointD, pen: any): void;
        drawArc2(rect: RectangleD, p1: PointD, p2: PointD, pen: Pen): void;
        setPixel(point: PointD, color: Color): void;
        drawImage(img: Image, rect: RectangleD): void;
        drawText(basePoint: PointD, text: string, charsOffset: number[], font: Font, textColor: Color, angle: number, textAlign: EmfTextAlignmentMode): void;
        drawString(st: string, font: Font, brush: StiBrush, rect: RectangleD, sf: StringFormat): void;
        saveState(): void;
        restoreState(): void;
        fillRectangle(rect: RectangleD, brush: any): void;
        fillRectangle2(rect: RectangleD, color: Color): void;
        rotateTransform(angle: number): void;
        translateTransform(x: number, y: number): void;
        endTransform(): void;
        measureString(st: string, font: Font): SizeD;
        drawEllipse(rect: RectangleD, pen: any): void;
        fillEllipse(rect: RectangleD, brush: any): void;
    }
}
declare module Stimulsoft.Report.Export {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiSvgHelper {
        private static correctFontSize;
        private static pdfCKT;
        static getLineStyleDash(penStyle: StiPenStyle, width: number): string;
        private static toUnits(numberr);
        private static writeCoordinates(writer, svgData);
        private static writeStrokeInfo(writer, color, width, style);
        private static writeFillInfo(writer, color);
        private static checkShape(component);
        private static writeDocument(report, page, standalone, REFbaseClipCounter, imageFormat, imageQuality, imageResolution);
        static writeWatermark(writer: XmlTextWriter, xmlIndentation: number, page: StiPage, behind: boolean, pageWidth: number, pageHeight: number, imageResolution: number, zoom?: number): void;
        private static writeBorder1(writer, svgData, REFgradientCounter);
        private static writeBorder2(writer, svgData);
        private static writeText(writer, svgData, REFclipCounter, xmlIndentation, useClip);
        private static writeImage(writer, svgData, imageResolution, imageFormat, imageQuality, imageCodec, REFclipCounter);
        private static writeBarCode(writer, svgData);
        static writeShape(writer: XmlTextWriter, svgData: StiSvgData): void;
        static writeFillBrush(writer: XmlTextWriter, brush: any, rect: RectangleD): string;
        private static writeBrush(writer, brush, rect);
        private static writeRoundedRectanglePrimitive(writer, svgData);
        private static writeIndicator(writer, svgData);
        private static writeIconSetIndicatorTypePainter(writer, textComp, rect);
        private static writeDataBarIndicator(writer, textComp, rect);
        static saveComponentToString(component: StiComponent, imageFormat?: ImageFormat, imageQuality?: number, imageResolution?: number, isDesigner?: boolean): string;
        static saveToString(report: StiReport, page: StiPage, compressed: boolean, standalone?: boolean, REFclipCounter?: any, imageFormat?: ImageFormat, imageQuality?: number, imageResolution?: number): string;
        static writeCheckBox(writer: XmlTextWriter, svgData: StiSvgData, checkedValue: Object): void;
        private static getCheckBoxData(checkbox, checkedValue);
    }
}
declare module Stimulsoft.Report.Export {
    class StiHtml5ExportService extends StiExportService {
        renderAsDocument: boolean;
        readonly defaultExtension: string;
        readonly exportFormat: StiExportFormat;
        readonly groupCategory: string;
        readonly position: number;
        readonly exportNameInMenu: string;
        exportTo(report: StiReport, writer: StiHtmlTextWriter, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, writer: StiHtmlTextWriter, settings: StiExportSettings): void;
        private reporTmp;
        private documentFileName;
        private sendEMail;
        readonly multipleFiles: boolean;
        getFilter(): string;
        report: StiReport;
        fileName: string;
        imageFormat: ImageFormat;
        htmlWriter: StiHtmlTextWriter;
        imageQuality: number;
        imageResolution: number;
        compressToArchive: boolean;
        private renderPage(report, page, REFclipCounter);
        private renderStartDoc(pages, encoding);
        private renderEndDoc();
        exportHtml(report: StiReport, htmlWriter: StiHtmlTextWriter, settings: StiHtmlExportSettings): void;
        constructor();
    }
}
declare module Stimulsoft.Report.Export {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiText = Stimulsoft.Report.Components.StiText;
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import IStiComponent = Stimulsoft.Report.Components.IStiComponent;
    class StiHtmlExportService extends StiExportService {
        renderedPagesCount: number;
        currentPassNumber: number;
        maximumPassNumber: number;
        readonly exportFormat: StiExportFormat;
        exportTo(report: StiReport, writer: StiHtmlTextWriter, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, writer: StiHtmlTextWriter, settings: StiExportSettings): void;
        private exportSettings;
        private reportTmp;
        private documentFileName;
        private sendEMail;
        readonly multipleFiles: boolean;
        clearOnFinish: boolean;
        tableRender: StiHtmlTableRender;
        htmlWriter: StiHtmlTextWriter;
        private zip;
        report: StiReport;
        private fileName;
        private startPage;
        private imageNumber;
        zoom: number;
        imageFormat: ImageFormat;
        exportQuality: StiHtmlExportQuality;
        useStylesTable: boolean;
        private isFileStreamMode;
        private imageQuality;
        imageResolution: number;
        private compressToArchive;
        private useEmbeddedImages;
        openLinksTarget: string;
        chartType: StiHtmlChartType;
        private coordX;
        private coordY;
        private strSpanDiv;
        private hyperlinksToTag;
        chartData: Hashtable;
        hashBookmarkGuid: Hashtable;
        renderStyles: boolean;
        styles: StiCellStyle[];
        insertInteractionParameters: boolean;
        htmlImageHost: StiHtmlImageHost;
        totalPageWidth: number;
        totalPageHeight: number;
        renderAsDocument: boolean;
        removeEmptySpaceAtBottom: boolean;
        pageHorAlignment: StiHorAlignment;
        private addCoord(x, y?);
        private formatCoords(report);
        formatCoord(value: number): string;
        formatColor(color: Color): string;
        formatColorRgba(color: Color): string;
        private getBorderStyle(style);
        setCurrentCulture(): void;
        restoreCulture(): void;
        renderFont(cell: StiHtmlTableCell, font: Font): void;
        renderTextHorAlignment(cell: StiHtmlTableCell, textOptions: any, textHorAlignment: StiTextHorAlignment): void;
        renderVertAlignment(cell: StiHtmlTableCell, textVertAlignment: StiVertAlignment, textOptions?: any): void;
        renderTextAngle(textOptions: StiTextOptions): void;
        renderTextDirection(cell: StiHtmlTableCell, textOptions: StiTextOptions): void;
        renderBackColor(cell: StiHtmlTableCell, color: Color): void;
        renderTextColor(cell: StiHtmlTableCell, color: Color, forceAnyColor?: boolean): void;
        renderBorder(comp: StiComponent): void;
        private renderBorder2(border);
        renderBorder3(cell: StiHtmlTableCell, border: StiBorderSide, side: string, borderRadius?: number): void;
        private renderPosition(comp);
        private getHeight(comp);
        private getWidth(comp);
        private renderImage(comp);
        private renderImage2(stiImage, exportImage, imageURL);
        private forceExportAsImage(exportImage);
        private renderImage3(stiImage, image, imageURL, zoom);
        renderHyperlink(comp: StiComponent): boolean;
        private renderPage(pages, useBookmarksTree, bookmarkWidth);
        private renderEndPage();
        private renderStartDoc(render, asTable, useBookmarks, exportBookmarksOnly, cssStyles, pages, encoding);
        private fillBitmapBackground(bmp, fillColor);
        private renderBookmarkScript();
        private renderChartScripts(writeScriptTag?);
        private renderMapsScripts(writeScriptTag?);
        private renderGaugeScripts(writeScriptTag?);
        getGuid(comp: IStiComponent): string;
        private renderEndDoc();
        private renderBookmarkTree(root, bookmarkWidth, bookmarksPageIndex);
        private addBookmarkNode(bkm, parentNode, bookmarksTree);
        prepareTextForHtml(text: string): string;
        static convertTextWithHtmlTagsToHtmlText(stiText: StiText, text: string): string;
        private static getParagraphString(text, textAlign, lineHeight);
        private getBackgroundImagePath(pages, zoomBase, useMargins);
        private getWatermarkImage(page, zoom, useMargins);
        static getImage(assemblyName: string, imageName: string, makeTransparent: boolean): Image;
        static getFile(assemblyName: string, fileName: string): Uint8Array;
        private assembleGuidUsedInBookmark(node, hash);
        private prepareSvg(sWriter, width, height);
        prepareChartData(writer: StiHtmlTextWriter, chart: IStiChart, width: number, height: number): string;
        prepareGaugeData(writer: StiHtmlTextWriter, gauge: any, width: number, height: number): string;
        prepareMapData(writer: StiHtmlTextWriter, map: any, width: number, height: number): string;
        getChartScript(): string;
        clear(): void;
        private isComponentHasInteraction(component);
        exportHtml(report: StiReport, writer: StiHtmlTextWriter, settings: StiHtmlExportSettings, pages?: StiPagesCollection): void;
        constructor();
    }
    class StiBookmarkTreeNode {
        parent: number;
        title: string;
        url: string;
        used: boolean;
    }
}
declare module Stimulsoft.Report.Export {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiExcel2007ExportService extends StiExportService {
        getDefaultExtension(): String;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private report;
        private fileName;
        private sendEMail;
        matrix: StiMatrix;
        private fontList;
        private fillList;
        private borderList;
        private xfList;
        private sstList;
        private sstHash;
        private sstHashIsTags;
        private imageList;
        private formatList;
        private sstCount;
        private sheetNameList;
        private imageListOffset;
        private printAreasList;
        private matrixList;
        private firstPageIndexList;
        private hyperlinkList;
        private minRowList;
        private maxRowList;
        private useOnePageHeaderAndFooter;
        private exportDataOnly;
        private exportObjectFormatting;
        private exportEachPageToSheet;
        private exportHorizontalPageBreaks;
        private imageResolution;
        private imageQuality;
        private imageCache;
        private restrictEditing;
        private reportCulture;
        private docCompanyString;
        private docLastModifiedString;
        private xmlIndentation;
        private wrongUrlSymbols;
        private getLineStyle(border);
        private getRefString(column, row);
        private getRefAbsoluteString(column, row);
        private floatToString(number_);
        private stringToUrl(input);
        private getFontNumber(dataIn);
        private getFillNumber(dataIn);
        private getBorderNumber(dataIn);
        private getXFNumber(dataIn);
        private getSSTNumber(dataIn);
        private getFormatNumber(dataIn);
        HiToTwips: number;
        private TwipsToColinfo;
        private convert(x);
        private compareExcellSheetNames(name1, name2);
        private prepareData();
        private writeContentTypes();
        private writeMainRels();
        private writeDocPropsApp();
        private writeDocPropsCore();
        private writeWorkbookRels();
        private writeWorkbook();
        private writeSheetRels(indexSheet);
        private writeSheet(indexSheet, page);
        private prepareMatrix(pages);
        private convertAllowHtmlTagsToExcelString(textBox, input);
        private convertTextToExcelString(writer, input);
        private writeDrawingRels(indexSheet);
        private writeDrawing(indexSheet);
        private writeStyles();
        private writeBorderData(writer, side, border);
        private writeSST();
        private writeAdditionalData(st, base64);
        private writeImage(_number);
        exportExcel(report: StiReport, stream: MemoryStream, settings: StiExcelExportSettings): void;
    }
    class DataFont {
        Name: string;
        Bold: boolean;
        Italic: boolean;
        Underlined: boolean;
        Strikeout: boolean;
        Height: number;
        Color: Color;
        Charset: number;
        Family: number;
        constructor(Name: string, Bold: boolean, Italic: boolean, Underlined: boolean, Strikeout: boolean, Height: number, Color: Color, Charset: number, Family: number);
        stiEquals(obj: DataFont): boolean;
    }
    class DataFill {
        Type: string;
        FgColor: Color;
        BgColor: Color;
        constructor(Type: string, FgColor: Color, BgColor: Color);
        stiEquals(obj: DataFill): boolean;
    }
    class DataBorder {
        BorderLeft: StiBorderSide;
        BorderRight: StiBorderSide;
        BorderTop: StiBorderSide;
        BorderBottom: StiBorderSide;
        constructor(BorderLeft: StiBorderSide, BorderRight: StiBorderSide, BorderTop: StiBorderSide, BorderBottom: StiBorderSide);
        stiEquals(obj: DataBorder): boolean;
        private eq(obj1, obj2);
    }
    class DataXF {
        FormatIndex: number;
        FontIndex: number;
        FillIndex: number;
        BorderIndex: number;
        XFId: number;
        HorAlign: StiTextHorAlignment;
        VertAlign: StiVertAlignment;
        TextRotationAngle: number;
        TextWrapped: boolean;
        RightToLeft: boolean;
        Editable: boolean;
        equalDataXF(xf: DataXF): boolean;
        constructor(FormatIndex: number, FontIndex: number, FillIndex: number, BorderIndex: number, XFId: number, HorAlign: StiTextHorAlignment, VertAlign: StiVertAlignment, TextRotationAngle: number, TextWrapped: boolean, RightToLeft: boolean, Editable: boolean);
    }
    class ExcelImageData {
        FirstRowIndex: number;
        FirstRowOffset: number;
        FirstColumnIndex: number;
        FirstColumnOffset: number;
        LastRowIndex: number;
        LastRowOffset: number;
        LastColumnIndex: number;
        LastColumnOffset: number;
        ImageIndex: number;
        Hyperlink: string;
        constructor(FirstRowIndex: number, FirstRowOffset: number, FirstColumnIndex: number, FirstColumnOffset: number, LastRowIndex: number, LastRowOffset: number, LastColumnIndex: number, LastColumnOffset: number, ImageIndex: number, Hyperlink: string);
    }
    class CellRangeAddress {
        FirstRow: number;
        LastRow: number;
        FirstColumn: number;
        LastColumn: number;
        constructor(FirstRow: number, LastRow: number, FirstColumn: number, LastColumn: number);
    }
    class HlinkData {
        Range: CellRangeAddress;
        Description: string;
        Bookmark: string;
        constructor(Range: CellRangeAddress, Description: string, Bookmark: string);
    }
}
declare module Stimulsoft.Report.Export {
    class StiExcelXmlExportService extends StiExportService {
    }
}
declare module Stimulsoft.Report.Export {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    import Image = Stimulsoft.System.Drawing.Image;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    enum StiTableLineInfo {
        Empty = 0,
        Unknown = 1,
        PageHeader = 2,
        PageFooter = 3,
        HeaderAP = 4,
        FooterAP = 5,
        HeaderD = 6,
        FooterD = 7,
        Data = 8,
        Trash = 9,
    }
    class StiMatrix {
        cells: StiCell[][];
        cellsMap: StiCell[][];
        totalHeight: number;
        totalWidth: number;
        styles: StiCellStyle[];
        coordX: number[];
        coordY: number[];
        linePlacement: StiTableLineInfo[];
        parentBandName: string[];
        bordersX: StiBorderSide[][];
        bordersY: StiBorderSide[][];
        horizontalPageBreaks: number[];
        cellStyles: StiCellStyle[][];
        bookmarks: string[][];
        interactions: number[][][];
        private maxRowHeight;
        private _defaultLinePrimitiveWidth;
        private static staticRectanglePrimitive;
        private coordXCheck;
        private coordYCheck;
        private coordXNew;
        private coordYNew;
        private coordXPrim;
        private coordYPrim;
        imagesBaseRect: Hashtable;
        private leftCached;
        private topCached;
        private xcHash;
        private ycHash;
        private tagSplitCache;
        private stylesCache;
        private fontsCache;
        private createdCells;
        borderSides: StiBorderSide[];
        exportFormat: StiExportFormat;
        private isHtmlService;
        private isHtmlOrExcelXmlService;
        private isHtmlPngMode;
        report: StiReport;
        private pages;
        private addComponentWithInteractions;
        private replaceCheckboxes;
        private hyperlinksToTag;
        private maxCoordY;
        private defaultLinePrimitiveWidth;
        private static sortForMatrix(array);
        private round(value);
        private addCoord(rect);
        static htmlScaleX: number;
        static htmlScaleY: number;
        private addCoord2(x, y, convert?);
        prepareTable(): void;
        getRange(rect: RectangleD): Rectangle;
        getStyleFromComponent(component: StiComponent, x: number, y: number, id: string): StiCellStyle;
        private getStyle(style);
        private renderComponent(component, exportData, isPage, id);
        private getCellRectangle(startX, startY, cell);
        private cutRectangleFromCellsMap(cellRect, cell);
        isComponentHasInteraction(component: StiComponent): boolean;
        scanComponentsPlacement(optimize: boolean, exportObjectFormatting?: boolean): void;
        private processIntersectedCells(createdCells2);
        splitTagWithCache(inputString: string): string[];
        static splitTag(inputString: string): string[];
        static getStringsFromTag(tag: string, startPosition: number): string[];
        private copyFieldsListToFields();
        fields: DataField[];
        dataArrayLength: number;
        private fieldsList;
        private sizeX;
        private sizeY;
        private htName;
        prepareDocument(service: StiExportService, mode: StiDataExportMode): void;
        checkStylesNames(): void;
        getRealImageData(cell: StiCell, baseImage: Image): Image;
        private checkComponentPlacement(component, dataMode);
        private lastPage;
        private lastPageId;
        private lastComps;
        getBorderSideIndex(side: StiBorderSide): number;
        static GCCollect(): void;
        clear(): void;
        constructor(pages: StiPagesCollection, checkForExcel: boolean, service: StiExportService, styles?: StiCellStyle[], dataMode?: StiDataExportMode);
    }
    class DataField {
        name: string;
        info: number[];
        formatString: string;
        dataArray: string[];
        readyName: boolean;
        readyType: boolean;
        constructor(size: number);
    }
}
declare module Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiWord2007ExportService extends StiExportService {
        readonly defaultExtension: string;
        readonly exportFormat: StiExportFormat;
        readonly groupCategory: string;
        readonly position: number;
        readonly exportNameInMenu: string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private report;
        private fileName;
        private sendEMail;
        readonly multipleFiles: boolean;
        getFilter(): string;
        private _matrix;
        readonly matrix: StiMatrix;
        private _removeEmptySpaceAtBottom;
        readonly removeEmptySpaceAtBottom: boolean;
        private fontList;
        private styleList;
        private imageCache;
        private bookmarkList;
        private hyperlinkList;
        private embedsList;
        private xmlIndentation;
        private imageQuality;
        private imageResolution;
        private lineSpace;
        private usePageHeadersAndFooters;
        private restrictEditing;
        private headersData;
        private headersRels;
        private footersData;
        private footersRels;
        private docCompanyString;
        private docLastModifiedString;
        private checkFontsToCorrectHeight(name);
        private getLineStyle(penStyle);
        private getColorString(color);
        private getStyleNumber(tmpStyleList, styleInfo);
        private getStyleFromComponent(component);
        private stringToUrl(input);
        private wrongUrlSymbols;
        private static readonly hiToTwips;
        private convert(x);
        private convertHiToTwips(x);
        private convertTwipsToEmu(x);
        private convertStringToBookmark(inputString);
        private writeFromMatrix(writer, startLine, endLine, outHeadersAndFooters);
        private writeCellContent(writer, cell, REFneedEmptyParagraph, indexRow, indexColumn, wordCoordX, wordCoordY);
        private writeTableInfo(writer, wordCoordX, maxCoordX);
        private writeHtmlTags(writer, cell);
        private writeParagraphBegin(writer, cell, styleIndex, states, stateIndex);
        private writeRunProperties(writer, cell);
        private renderBorder2TableGetValues(rowIndex, columnIndex, REFstyles);
        private getLineStyle2TableGetValues(border);
        private writeDocument(pages, report, outHeadersAndFooters);
        private compareExcellSheetNames(name1, name2);
        private writePageInfo(writer, page, partIndex);
        private writeBorders(writer, indexRow, indexColumn, height, width);
        private writeBorderData(writer, side, border);
        private writeFootNotes();
        private writeEndNotes();
        private writeHeader(startLine, endLine, needHeader);
        private writeFooter(startLine, endLine, needFooter);
        private writeContentTypes();
        private writeMainRels();
        private writeDocPropsApp();
        private writeDocPropsCore();
        private writeSettings();
        private writeWebSettings();
        private writeFontTable();
        private writeDocumentRels();
        private writeHeaderFooterRels();
        private writeStyles();
        private writeImage(_number);
        private writeAdditionalData(st, base64);
        exportWord(report: StiReport, stream: MemoryStream, settings: StiWord2007ExportSettings): void;
    }
}
declare module Stimulsoft.Report.Export {
    import Color = Stimulsoft.System.Drawing.Color;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiHatchBrush = Stimulsoft.Base.Drawing.StiHatchBrush;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiPdfData {
        X: number;
        Y: number;
        Width: number;
        Height: number;
        Component: StiComponent;
        service: StiPdfExportService;
        readonly Right: number;
        readonly Top: number;
        constructor(service: StiPdfExportService);
    }
    class StiEditableObject {
        X: number;
        Y: number;
        Width: number;
        Height: number;
        Page: number;
        Text: string;
        Content: number[];
        Content2: number[];
        Multiline: boolean;
        Alignment: Stimulsoft.Base.Drawing.StiTextHorAlignment;
        FontNumber: number;
        FontSize: number;
        FontColor: Color;
        Component: StiComponent;
    }
    class StiPdfExportService extends StiExportService {
        readonly exportFormat: StiExportFormat;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        report: StiReport;
        readonly multipleFiles: boolean;
        private imageQuality;
        private imageResolutionMain;
        private imageResolutionMode;
        private sw;
        pageStream: MemoryStream;
        private imageList;
        private imageCache;
        private imageInterpolationTable;
        private imageCacheIndexToList;
        private imageInfoList;
        private imageInfoCounter;
        private imagesCurrent;
        private fontsCounter;
        private bookmarksCounter;
        private linksCounter;
        private annotsCounter;
        annotsCurrent: number;
        private annots2Counter;
        private annots2Current;
        private unsignedSignaturesCounter;
        shadingCurrent: number;
        private tooltipsCounter;
        private colorTable;
        private alphaTable;
        pdfFont: PdfFonts;
        bidi: StiBidirectionalConvert;
        private standardPdfFonts;
        private embeddedFonts;
        useUnicodeMode: boolean;
        private reduceFontSize;
        private compressed;
        private compressedFonts;
        private encrypted;
        private usePdfA;
        private pdfComplianceMode;
        private exportRtfTextAsImage;
        private autoPrint;
        private imageCompressionMethod;
        private imageFormat;
        private monochromeDitheringType;
        private allowEditable;
        private fontGlyphsReduceNotNeed;
        private xref;
        annotsArray: Array<StiEditableObject>;
        private annots2Array;
        private unsignedSignaturesArray;
        private shadingArray;
        private hatchArray;
        private haveBookmarks;
        private haveLinks;
        haveAnnots: boolean;
        private haveTooltips;
        CodePage1252part80AF: number[];
        private CodePage1252;
        hiToTwips: number;
        private precision_digits_font;
        pdfCKT: number;
        private IDValue;
        private IDValueString;
        private IDValueStringMeta;
        private currentDateTime;
        private currentDateTimeMeta;
        private producerName;
        private creatorName;
        private keywords;
        private currentObjectNumber;
        private currentGenerationNumber;
        private keyLength;
        private lastColorStrokeA;
        private lastColorNonStrokeA;
        private colorStack;
        info: StiPdfStructure;
        private haveDigitalSignature;
        printScaling: boolean;
        private static regexEscape;
        stringReplace(st: string, oldValue: string, newValue: string): string;
        getHatchNumber(brush: StiHatchBrush): number;
        private addXref(num);
        convertToString(value: number, precision?: number): string;
        static convertToEscapeSequence(value: string): string;
        static convertToEscapeSequencePlusTabs(value: string): string;
        setStrokeColor(tempColor: Color): void;
        setNonStrokeColor(tempColor: Color): void;
        private colorHash1;
        private colorHash2;
        private _gsTable;
        readonly gsTable: string[][];
        pushColorToStack(): void;
        popColorFromStack(): void;
        private storeStringLine(noCryptString, cryptString, escaping?);
        private storeString(st);
        private convertToHexString(inString, escaping);
        private storeMemoryStream2(mem, dictionaryString);
        private storeMemoryStream3(data, dictionaryString);
        private storeMemoryStream4(data, dictionaryString);
        private renderStartDoc(report, pages);
        private renderEndDoc();
        private renderPageHeader(pageNumber);
        private renderPageFooter(pageH, pageW);
        private renderFontTable();
        private renderImageTable();
        private renderPatternTable();
        private writeHatchPattern(indexHatch);
        private writeShadingPattern(indexShading);
        private renderAnnotTable();
        private renderExtGStateRecord();
        storeImageData(image: Image, imageResolution: number, isImageComponent: boolean, needSmoothing: boolean): number;
        private writeImageInfo(pp, imageResolution);
        renderImage(pp: StiPdfData, imageResolution: number): void;
        private renderWatermark(page, behind, pageWidth, pageHeight, imageResolution);
        storeShadingData1(brush: StiBrush, pageNumber: number): void;
        storeShadingData2(x: number, y: number, width: number, height: number, brush: StiBrush): number;
        storeHatchData(brush: StiBrush): void;
        private renderMetadata(report);
        private renderColorSpace();
        private renderAutoPrint();
        exportPdf(report: StiReport, stream: MemoryStream, settings: StiPdfExportSettings): void;
        private exportPdf1(report, stream, settings);
    }
}
declare module Stimulsoft.Report.Export {
    import StringBuilder = Stimulsoft.System.Text.StringBuilder;
    import Font = Stimulsoft.System.Drawing.Font;
    class PdfFontInfo {
        Widths: Array<number>;
        CharPdfNames: Array<string>;
        CH: number;
        XH: number;
        ASC: number;
        DESC: number;
        tmASC: number;
        tmDESC: number;
        tmExternal: number;
        MacAscend: number;
        MacDescend: number;
        MacLineGap: number;
        LLX: number;
        LLY: number;
        URX: number;
        URY: number;
        StemV: number;
        ItalicAngle: number;
        LineGap: number;
        NtmFlags: number;
        UnderscoreSize: number;
        UnderscorePosition: number;
        StrikeoutSize: number;
        StrikeoutPosition: number;
        UnicodeMap: Array<number>;
        UnicodeMapBack: Array<number>;
        GlyphList: Array<number>;
        GlyphBackList: Array<number>;
        GlyphRtfList: Array<number>;
        SymsToPDF: Array<number>;
        MappedSymbolsCount: number;
        NeedSynt: boolean;
        GlyphWidths: Array<number>;
        ChildFontsMap: Array<number>;
    }
    class pfontInfo {
        Name: string;
        PdfName: string;
        Bold: boolean;
        Italic: boolean;
        Number: number;
        Font: Font;
        ParentFontNumber: number;
        ChildFontsMap: Array<number>;
    }
    class PdfFonts extends PdfFontInfo {
        getFontMetrics(font: Font, currentFontInfo: PdfFontInfo, glyphMap: number[]): void;
        private standardFontQuantity;
        private standardFontNumWidths;
        private standardFontNumChars;
        firstMappedSymbol: number;
        factor: number;
        maxSymbols: number;
        useUnicode: boolean;
        WIDTHS: number[];
        fonts: Array<PdfFontInfo>;
        UnicodeMapsList: Array<number[]>;
        GlyphMapsList: Array<number[]>;
        standardPdfFonts: boolean;
        fontList: Array<pfontInfo>;
        private fontsInfoStore;
        private family_Helvetica;
        private family_Courier;
        private family_Times_Roman;
        private family_Symbol;
        private family_ZapfDingbats;
        PdfFontName: string[];
        private _currentFont;
        currentFont: number;
        InitFontsData(): void;
        constructor();
        getFontNumber(incomingFont: Font): number;
        storeUnicodeSymbolsInMap(sb: StringBuilder): void;
        private TtfHeaderSize;
        getCharToGlyphTable(buff: Uint8Array, fontName: string): number[];
        reduceFontSize(buff: Uint8Array, fontName: string, remakeGlyphTable: boolean): Stimulsoft.System.IO.MemoryStream;
        private scanFontFile(buff, fontName);
        private getCmapTable(buff, ttf);
        private copyUint8Array(source, from, destination, to, count);
        ARG_1_AND_2_ARE_WORDS: number;
        ARGS_ARE_XY_VALUES: number;
        ROUND_XY_TO_GRID: number;
        WE_HAVE_A_SCALE: number;
        MORE_COMPONENTS: number;
        WE_HAVE_AN_X_AND_Y_SCALE: number;
        WE_HAVE_A_TWO_BY_TWO: number;
        WE_HAVE_INSTRUCTIONS: number;
        USE_MY_METRICS: number;
        OVERLAP_COMPOUND: number;
        SCALED_COMPONENT_OFFSET: number;
        UNSCALED_COMPONENT_OFFSET: number;
        TablesNames: Array<string>;
        private getTtfInfo(buff, bufOffset);
        private GetUInt8(buff, pos);
        private GetUInt16(buff, pos);
        private GetUInt32(buff, pos);
        private GetInt16(buff, pos);
        private SetUInt16(buff, pos, value);
        private SetUInt32(buff, pos, value);
        clear(): void;
    }
    class FontsInfoStore {
        clear(): void;
    }
}
declare module Stimulsoft.Report.Export {
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Matrix = Stimulsoft.System.Drawing.Drawing2D.Matrix;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Pen = Stimulsoft.System.Drawing.Pen;
    import Image = Stimulsoft.System.Drawing.Image;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiPdfGeomWriter {
        private penWidthDefault;
        private precision_digits;
        private hiToTwips;
        private pdfCKT;
        private lastPoint;
        private makepath;
        private pathClosed;
        private path;
        private pageStream;
        private pdfService;
        assembleData: boolean;
        pageNumber: number;
        matrixCache: Array<Matrix>;
        private xmin;
        private xmax;
        private ymin;
        private ymax;
        private calculateMinMax(pt);
        private convertToString(value);
        setPen(objPen: Object, saveState?: boolean): boolean;
        setBrush(brush: Object, rect: Rectangle, saveState?: boolean): boolean;
        private outputLineString(st, pen);
        private convertArcToBezierPoints(rect, startAngle, sweepAngle);
        convertSplineToCubicBezier(points: Point[], tension: number): Point[];
        private calculateCurveBezier(points, index, tension);
        private calculateCurveBezierEndPoints(end, adj, tension);
        getPointString(point: Point): string;
        getLineToString(pointTo: Point): string;
        getRectString4(x: number, y: number, width: number, height: number): string;
        getRectString(rect: Rectangle): string;
        getBezierString(p1: Point, p2: Point, p3: Point): string;
        getBezierString2(p1x: number, p1y: number, p2x: number, p2y: number, p3x: number, p3y: number): string;
        getPolylineString(points: Point[], close: boolean, drawTo: boolean): string;
        getEllipseString4(x: number, y: number, width: number, height: number): string;
        getEllipseString(rect: Rectangle): string;
        private getPenStyleDashString(style, step);
        beginPath(): void;
        closeFigure(): void;
        endPath(): void;
        fillPath(brush: Object): void;
        strokePath(pen: Object): void;
        moveTo(point: Point): void;
        drawLine(pointFrom: Point, pointTo: Point, pen: Object): void;
        drawLineTo(pointTo: Point, pen: Object): void;
        drawRectangle(rect: Rectangle, pen: Object): void;
        fillRectangle(rect: Rectangle, brush: Object): void;
        drawPolygon(points: Point[], pen: Object): void;
        drawPolyline(points: Point[], pen: Object, close?: boolean, drawTo?: boolean): void;
        drawPolylineTo(points: Point[], pen: Object): void;
        fillPolygon(points: Point[], brush: Object): void;
        drawBezier(p1: Point, p2: Point, p3: Point, p4: Point, pen: Object): void;
        drawBezierTo(p2: Point, p3: Point, p4: Point, pen: Object): void;
        drawSpline(points: Point[], tension: number, pen: Object): void;
        drawArc(rect: Rectangle, startAngle: number, sweepAngle: number): void;
        drawEllipse(rect: Rectangle, pen: Object): void;
        fillEllipse(rect: Rectangle, brush: Object): void;
        drawPie(rect: Rectangle, startAngle: number, sweepAngle: number): void;
        drawString(st: string, font: Font, brush: StiBrush, rect: Rectangle, sf: StringFormat): void;
        saveState(): void;
        restoreState(): void;
        translateTransform(x: number, y: number): void;
        rotateTransform(angle: number): void;
        setClip(rect: Rectangle): void;
        drawArc2(rect: RectangleD, p1: PointD, p2: PointD, pen: Pen): void;
        drawText(basePoint: PointD, text: string, charsOffset: number[], font: Font, textColor: Color, angle: number, textAlign: EmfTextAlignmentMode): void;
        setPixel(point: PointD, color: Color): void;
        measureString(st: string, font: Font): SizeD;
        drawImage(img: Image, rect: RectangleD): void;
        constructor(stream: MemoryStream, service: StiPdfExportService, assembleData?: boolean);
    }
}
declare module Stimulsoft.Report.Export {
    class StiPdfRenderChart {
        static renderChart(pp: StiPdfData, assemble: boolean, pageNumber: number): void;
        private static getStartPoint(rotationMode, textRect);
        private static rectToRectangle(rect);
        private static brushToStiBrush(brush);
        private static checkPenGeom(penGeom);
    }
}
declare module Stimulsoft.Report.Export {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiShape = Stimulsoft.Report.Components.StiShape;
    import StiCheckBox = Stimulsoft.Report.Components.StiCheckBox;
    class StiPdfRenderPrimitives {
        static renderBorder1(pp: StiPdfData): void;
        static renderBorder2(pp: StiPdfData): void;
        private static storeBorderSideData(border, pp);
        static getPenStyleDashString(style: StiPenStyle, step: number, pp: StiPdfData): string;
        static checkShape(shape: StiShape): boolean;
        static renderShape(pp: StiPdfData, imageResolution: number): void;
        static renderCheckbox(pp: StiPdfData, checkBoxValue: boolean, storeShading?: boolean): void;
        static getCheckBoxValue(checkbox: StiCheckBox): boolean;
    }
}
declare module Stimulsoft.Report.Export {
    class StiPdfRenderText {
        private static hiToTwips;
        private static precision_digits_font;
        private static fontCorrectValue;
        private static boldFontStrokeWidthValue;
        private static italicAngleTanValue;
        static renderText(pp: StiPdfData): void;
        private static isWordWrapSymbol(sb, index);
        private static getTabsSize(textOp, sizeInPt, currentPosition);
        static renderTextFont(pp: StiPdfData): void;
    }
}
declare module Stimulsoft.Report.Export {
    class StiPdfResources {
        static sRGBprofile: number[];
        static hatchData: string[];
        private static standardFontWidths;
        private static standardFontInfo;
        private static _standardFontCharsNames;
        static readonly standardFontCharsNames: string[];
    }
}
declare module Stimulsoft.Report.Export {
    class StiPdfObjInfo {
        ref: number;
        info: StiPdfStructure;
        readonly isUsed: boolean;
        addRef(): void;
        toString(): string;
    }
    class StiPdfContentObjInfo extends StiPdfObjInfo {
        content: StiPdfObjInfo;
    }
    class StiPdfXObjectObjInfo extends StiPdfObjInfo {
        mask: StiPdfObjInfo;
    }
    class StiPdfFontObjInfo extends StiPdfObjInfo {
        descendantFont: StiPdfObjInfo;
        toUnicode: StiPdfObjInfo;
        cIDSet: StiPdfObjInfo;
        encoding: StiPdfObjInfo;
        fontDescriptor: StiPdfObjInfo;
        fontFile2: StiPdfObjInfo;
    }
    class StiPdfOutlinesObjInfo extends StiPdfObjInfo {
        items: StiPdfObjInfo[];
    }
    class StiPdfShadingObjInfo extends StiPdfObjInfo {
        function: StiPdfObjInfo;
    }
    class StiPdfPatternsObjInfo extends StiPdfObjInfo {
        resources: StiPdfObjInfo;
        first: StiPdfObjInfo;
        hatchItems: StiPdfObjInfo[];
        shadingItems: StiPdfShadingObjInfo[];
    }
    class StiPdfAnnotObjInfo extends StiPdfObjInfo {
        aP: StiPdfObjInfo;
        aA: StiPdfObjInfo[];
    }
    class StiPdfCheckBoxObjInfo {
        items: StiPdfAnnotObjInfo[];
    }
    class StiPdfAcroFormObjInfo extends StiPdfObjInfo {
        annots: StiPdfAnnotObjInfo[];
        checkBoxes: StiPdfCheckBoxObjInfo[];
        unsignedSignatures: StiPdfAnnotObjInfo[];
        signatures: StiPdfAnnotObjInfo[];
        tooltips: StiPdfAnnotObjInfo[];
        annotFontItems: StiPdfFontObjInfo[];
    }
    class StiPdfStructure {
        root: StiPdfObjInfo;
        info: StiPdfObjInfo;
        colorSpace: StiPdfObjInfo;
        pages: StiPdfObjInfo;
        structTreeRoot: StiPdfObjInfo;
        optionalContentGroup: StiPdfObjInfo;
        pageList: StiPdfContentObjInfo[];
        xObjectList: StiPdfXObjectObjInfo[];
        fontList: StiPdfFontObjInfo[];
        outlines: StiPdfOutlinesObjInfo;
        patterns: StiPdfPatternsObjInfo;
        linkList: StiPdfObjInfo[];
        encode: StiPdfObjInfo;
        extGState: StiPdfObjInfo;
        acroForm: StiPdfAcroFormObjInfo;
        metadata: StiPdfObjInfo;
        destOutputProfile: StiPdfObjInfo;
        outputIntents: StiPdfObjInfo;
        embeddedJS: StiPdfContentObjInfo;
        embeddedFilesList: StiPdfContentObjInfo[];
        private objectsCounter;
        private objects;
        addRef(info: StiPdfObjInfo): void;
        createObject(addRef?: boolean): StiPdfObjInfo;
        createContentObject(addRef?: boolean): StiPdfContentObjInfo;
        createXObject(addRef?: boolean, haveMask?: boolean): StiPdfXObjectObjInfo;
        createFontObject(addRef?: boolean, useUnicodeMode?: boolean, standardPdfFonts?: boolean, embeddedFonts?: boolean, annotFont?: boolean): StiPdfFontObjInfo;
        createOutlinesObject(addRef?: boolean): StiPdfOutlinesObjInfo;
        createPatternsObject(addRef?: boolean): StiPdfPatternsObjInfo;
        createShadingObject(addRef?: boolean): StiPdfShadingObjInfo;
        createAcroFormObject(addRef?: boolean): StiPdfAcroFormObjInfo;
        createAnnotObject(addRef?: boolean, createAP?: boolean, numberAA?: number): StiPdfAnnotObjInfo;
        constructor();
    }
}
declare module Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiRtfExportService extends StiExportService {
        readonly defaultExtension: string;
        readonly exportFormat: StiExportFormat;
        readonly groupCategory: string;
        readonly position: number;
        readonly exportNameInMenu: string;
        getFilter(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private report;
        private fileName;
        private sendEMail;
        readonly multipleFiles: boolean;
        private getColorNumberInt(tmpColorList, incomingColor);
        private getColorNumber(tmpColorList, incomingColor);
        private getFontNumber2(tmpFontList, incomingFont);
        private getFontNumber3(tmpFontList, incomingFont, charset);
        private getCharsetIndex(charset);
        private colorList;
        private fontList;
        private styleList;
        private unicodeMapArray;
        private codePageToFont;
        private charsetCount;
        private fontToCodePages;
        private baseFontNumber;
        private usePageHeadersAndFooters;
        private imageResolution;
        private imageQuality;
        private imageFormat;
        private useStyles;
        private bookmarkList;
        private usedBookmarks;
    }
}
declare module Stimulsoft.Report.Export {
    class StiExportSettings {
        getExportFormat(): StiExportFormat;
    }
}
declare module Stimulsoft.Report.Export {
    class StiPageRangeExportSettings extends StiExportSettings {
        pageRange: StiPagesRange;
    }
}
declare module Stimulsoft.Report.Export {
    import Encoding = Stimulsoft.System.Text.Encoding;
    class StiDataExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        dataType: StiDataType;
        dataExportMode: StiDataExportMode;
        encoding: Encoding;
        exportDataOnly: boolean;
        codePage: StiDbfCodePages;
        separator: string;
        skipColumnHeaders: boolean;
        useDefaultSystemEncoding: boolean;
        constructor(dataType?: StiDataType);
    }
}
declare module Stimulsoft.Report.Export {
    class StiCsvExportSettings extends StiDataExportSettings {
        constructor();
    }
}
declare module Stimulsoft.Report.Export {
    import Encoding = Stimulsoft.System.Text.Encoding;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    class StiHtmlExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        htmlType: StiHtmlType;
        imageQuality: number;
        imageResolution: number;
        imageFormat: ImageFormat;
        encoding: Encoding;
        zoom: number;
        exportMode: Export.StiHtmlExportMode;
        exportQuality: StiHtmlExportQuality;
        addPageBreaks: boolean;
        bookmarksTreeWidth: number;
        exportBookmarksMode: StiHtmlExportBookmarksMode;
        useStylesTable: boolean;
        removeEmptySpaceAtBottom: boolean;
        pageHorAlignment: StiHorAlignment;
        compressToArchive: boolean;
        useEmbeddedImages: boolean;
        continuousPages: boolean;
        chartType: StiHtmlChartType;
        openLinksTarget: string;
        useWatermarkMargins: boolean;
        constructor(htmlType?: StiHtmlType);
    }
}
declare module Stimulsoft.Report.Export {
    class StiHtml5ExportSettings extends StiHtmlExportSettings {
        constructor();
    }
}
declare module Stimulsoft.Report.Export {
    class StiExcelExportSettings extends StiPageRangeExportSettings {
        excelType: StiExcelType;
        useOnePageHeaderAndFooter: boolean;
        exportDataOnly: boolean;
        exportPageBreaks: boolean;
        exportObjectFormatting: boolean;
        exportEachPageToSheet: boolean;
        imageQuality: number;
        imageResolution: number;
        companyString: string;
        lastModifiedString: string;
        restrictEditing: StiExcel2007RestrictEditing;
        getExportFormat(): StiExportFormat;
        constructor(excelType?: StiExcelType);
    }
}
declare module Stimulsoft.Report.Export {
    class StiExcel2007ExportSettings extends StiExcelExportSettings {
        constructor();
    }
}
declare module Stimulsoft.Report.Export {
    class StiWord2007ExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        usePageHeadersAndFooters: boolean;
        imageQuality: number;
        imageResolution: number;
        removeEmptySpaceAtBottom: boolean;
        companyString: string;
        lastModifiedString: string;
        restrictEditing: StiWord2007RestrictEditing;
    }
}
declare module Stimulsoft.Report.Export {
    class StiPdfExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        imageQuality: number;
        imageResolution: number;
        imageResolutionMode: StiImageResolutionMode;
        embeddedFonts: boolean;
        standardPdfFonts: boolean;
        compressed: boolean;
        useUnicode: boolean;
        useDigitalSignature: boolean;
        getCertificateFromCryptoUI: boolean;
        exportRtfTextAsImage: boolean;
        passwordInputUser: string;
        passwordInputOwner: string;
        userAccessPrivileges: StiUserAccessPrivileges;
        keyLength: StiPdfEncryptionKeyLength;
        creatorString: string;
        keywordsString: string;
        imageCompressionMethod: StiPdfImageCompressionMethod;
        imageFormat: StiImageFormat;
        ditheringType: StiMonochromeDitheringType;
        pdfACompliance: boolean;
        pdfComplianceMode: StiPdfComplianceMode;
        autoPrintMode: StiPdfAutoPrintMode;
        allowEditable: StiPdfAllowEditable;
    }
}
declare module Stimulsoft.Report.Export {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiPdfGeomWriter = Stimulsoft.Report.Export.StiPdfGeomWriter;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Pen = Stimulsoft.System.Drawing.Pen;
    import Image = Stimulsoft.System.Drawing.Image;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    class StiBarCodeExportPainter implements Stimulsoft.Report.Painters.IStiBarCodePainter {
        private geomWriter;
        baseTransform(context: any, x: number, y: number, angle: number, dx: number, dy: number): void;
        baseRollbackTransform(context: any): void;
        baseFillRectangle(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        baseFillRectangle2D(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        baseFillPolygon(context: any, brush: StiBrush, points: PointD[]): void;
        baseFillEllipse(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        baseDrawRectangle(context: any, penColor: Color, penSize: number, x: number, y: number, width: number, height: number): void;
        baseDrawImage(context: any, image: Image, report: StiReport, x: number, y: number, width: number, height: number): void;
        baseDrawString(context: any, st: string, font: Font, brush: StiBrush, rect: RectangleD, sf: StringFormat): void;
        baseMeasureString(context: any, st: string, font: Font): SizeD;
        static createNew(geomWriter1: StiPdfGeomWriter): StiBarCodeExportPainter;
        constructor(geomWriter1: StiSvgGeomWriter);
    }
    interface IStiExportGeomWriter {
        beginPath(): any;
        closeFigure(): any;
        endPath(): any;
        fillPath(brush: any): any;
        strokePath(pen: any): any;
        moveTo(point: PointD): any;
        drawLine(pointFrom: PointD, pointTo: PointD, pen: any): any;
        drawLineTo(pointTo: PointD, pen: any): any;
        drawRectangle(rect: RectangleD, pen: any): any;
        fillRectangle(rect: RectangleD, color: Color): any;
        fillRectangle(rect: RectangleD, brush: any): any;
        drawPolyline(points: PointD[], pen: any): any;
        drawPolylineTo(points: PointD[], pen: any): any;
        drawPolygon(points: PointD[], pen: any): any;
        fillPolygon(points: PointD[], brush: any): any;
        fillEllipse(rect: RectangleD, brush: any): any;
        drawBezier(p1: PointD, p2: PointD, p3: PointD, p4: PointD, pen: any): any;
        drawBezierTo(p2: PointD, p3: PointD, p4: PointD, pen: any): any;
        drawArc2(rect: RectangleD, p1: PointD, p2: PointD, pen: Pen): any;
        setPixel(point: PointD, color: Color): any;
        drawImage(img: Image, rect: RectangleD): any;
        drawText(basePoint: PointD, text: string, charsOffset: number[], font: Font, textColor: Color, angle: number, textAlign: EmfTextAlignmentMode): any;
        drawString(st: string, font: Font, brush: StiBrush, rect: RectangleD, sf: StringFormat): any;
        saveState(): any;
        restoreState(): any;
        translateTransform(x: number, y: number): any;
        rotateTransform(angle: number): any;
        measureString(st: string, font: Font): SizeD;
    }
}
declare module Stimulsoft.Report.Export {
    import StringBuilder = Stimulsoft.System.Text.StringBuilder;
    class StiBidirectionalConvert {
        private arabicTableSize;
        private ligaturesTableSize;
        private static ligaturesTable;
        private static arabicTable;
        private static arabicTableArray;
        private stSeparator;
        private modePdf;
        convert(inputString: StringBuilder, useRightToLeft: boolean): StringBuilder;
        private convertArabic(inputSB);
        private symbolIsDigitOrDelimiter(num);
        private static symbolIsArabicOrHebrew(num);
        static stringContainArabicOrHebrew(st: string): boolean;
        private symbolIsBidiMark(num);
        private symbolIsLTRMark(num);
        private symbolIsRTLMark(num);
        clear(): void;
        constructor(modePdf?: boolean);
    }
}
declare module Stimulsoft.Report.Export {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiExportImage = Stimulsoft.Report.Components.IStiExportImage;
    class StiCell {
        clone(): StiCell;
        forceExportAsImage(exportImage: any): boolean;
        private _exportFormat;
        exportFormat: StiExportFormat;
        private _component;
        component: StiComponent;
        _exportImage: IStiExportImage;
        exportImage: IStiExportImage;
        cellStyle: StiCellStyle;
        left: number;
        top: number;
        width: number;
        private _height;
        height: number;
        text: string;
        constructor(exportFormat?: StiExportFormat);
    }
}
declare module Stimulsoft.Report.Export {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    class StiCellStyle {
        clone(): StiCellStyle;
        getHashCode(): number;
        stiEquals(obj: Object): boolean;
        static getStyleFromCache(color: Color, textColor: Color, font: Font, horAlignment: StiTextHorAlignment, vertAlignment: StiVertAlignment, border: StiBorderSide, borderL: StiBorderSide, borderR: StiBorderSide, borderB: StiBorderSide, textOptions: StiTextOptions, wordWrap: boolean, format: string, internalStyleName: string, hashStyles: Hashtable, styles: Array<StiCellStyle>, fontsCache: Hashtable, cellStyle: StiCellStyle, simplyAdd: boolean, overflow: boolean, borderRadius: number): StiCellStyle;
        border: StiBorderSide;
        borderL: StiBorderSide;
        borderR: StiBorderSide;
        borderB: StiBorderSide;
        absolutePosition: boolean;
        color: Color;
        font: Font;
        horAlignment: StiTextHorAlignment;
        vertAlignment: StiVertAlignment;
        textOptions: StiTextOptions;
        textColor: Color;
        wordWrap: boolean;
        format: string;
        overflow: boolean;
        borderRadius: number;
        private _internalStyleName;
        internalStyleName: string;
        private _styleName;
        styleName: string;
        constructor(color: Color, textColor: Color, font: Font, horAlignment: StiTextHorAlignment, vertAlignment: StiVertAlignment, border: StiBorderSide, borderL: StiBorderSide, borderR: StiBorderSide, borderB: StiBorderSide, textOptions: StiTextOptions, wordWrap: boolean, format: string, styleName?: string, overflow?: boolean, borderRadius?: number);
    }
}
declare module Stimulsoft.Report.Export {
    import ImageFormat = Stimulsoft.System.Drawing.Imaging.ImageFormat;
    import Promise = Stimulsoft.System.Promise;
    class StiExportImageHelper {
        static convertAllImages(renderedReport: StiReport, imageFormat: ImageFormat, flate?: boolean): Promise<void>;
    }
}
declare module Stimulsoft.Report.Export {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiExportUtils {
        static convertDigitsToArabic(outputString: string, digitsType: StiArabicDigitsType): string;
        private static reportVersion;
        static getReportVersion(): string;
        static saveComponentToString(component: StiComponent, imageFormat?: ImageFormat, imageQuality?: number, imageResolution?: number): string;
        static trimEndWhiteSpace(inputString: string): string;
        static trimEndWhiteSpace2(inputString: string, removeControl: boolean): string;
        static splitString(inputString: string, removeControl: boolean): Array<string>;
        static stringToUrl(input: string): string;
        private static wrongUrlSymbols;
        static additionalData: string;
    }
}
declare module Stimulsoft.Report.Export {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiHtmlImageHost {
        htmlExport: StiHtmlExportService;
        isMhtExport: boolean;
        forcePng: boolean;
        getImageString(bmp: Image): string;
        constructor(htmlExport: StiHtmlExportService);
    }
}
declare module Stimulsoft.Report.Export {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import TextWriter = Stimulsoft.System.IO.TextWriter;
    import StiMargins = Stimulsoft.Report.Components.StiMargins;
    enum StiHtmlUnitType {
        Pixel = 0,
        Point = 1,
    }
    class StiHtmlUnit {
        private static hiToPt;
        value: number;
        unitType: StiHtmlUnitType;
        toString(): string;
        static toPixelString(value: number): string;
        static newUnit2(value: number, unitType: StiHtmlUnitType): StiHtmlUnit;
        static newUnit(value: number, usePoints?: boolean): StiHtmlUnit;
        static isNullOrZero(unit: StiHtmlUnit): boolean;
    }
    class StiHtmlSvg {
        text: string;
    }
    class StiHtmlHyperlink {
        text: string;
        toolTip: string;
        navigateUrl: string;
        attributes: Hashtable;
        style: Hashtable;
        imageUrl: string;
        cssClass: string;
        width: StiHtmlUnit;
        height: StiHtmlUnit;
        openLinksTarget: string;
        id: string;
        constructor();
    }
    class StiHtmlImage {
        toolTip: string;
        imageUrl: string;
        width: StiHtmlUnit;
        height: StiHtmlUnit;
        aspectRatio: boolean;
        multipleFactor: number;
        margins: StiMargins;
        horAlignment: number;
        vertAlignment: number;
        imageRotation: number;
        stretch: boolean;
        zoom: number;
        base64: string;
    }
    class StiHtmlTableCell {
        width: StiHtmlUnit;
        height: StiHtmlUnit;
        style: Hashtable;
        columnSpan: number;
        rowSpan: number;
        cssClass: string;
        text: string;
        toolTip: string;
        controls: any[];
        id: string;
        interaction: string;
        collapsed: string;
        sortDirection: string;
        dataBandSort: string;
        pageGuid: string;
        pageIndex: string;
        reportFile: string;
        componentIndex: string;
        editable: string;
        constructor();
    }
    class StiHtmlTableRow {
        style: Hashtable;
        cells: StiHtmlTableCell[];
        height: StiHtmlUnit;
        constructor();
    }
    class StiHtmlTable {
        backImageUrl: string;
        backgroundRepeat: string;
        backgroundPosition: string;
        width: StiHtmlUnit;
        borderWidth: number;
        cellPadding: number;
        cellSpacing: number;
        rows: Array<StiHtmlTableRow>;
        align: StiHorAlignment;
        static marginsKey: string;
        static pageBreakBeforeKey: string;
        static vertAlignKey: string;
        static horAlignKey: string;
        static wordwrapKey: string;
        private static wrongUrlSymbols;
        htmlExportSettings: StiHtmlExportSettings;
        static stringToUrl(input: string): string;
        renderControl(writer: StiHtmlTextWriter): void;
        private writeTableBegin(writer, writePageBreak);
        private writeTableEnd(writer);
        constructor();
    }
    enum WriterMode {
        None = 0,
        BeginTag = 1,
        Attribute = 2,
        Data = 3,
    }
    class StiHtmlTextWriter {
        private stream;
        private mode;
        indent: number;
        write(st: string): void;
        writeLine(st?: string): void;
        writeBeginTag(st: string): void;
        writeFullBeginTag(st: string): void;
        writeEndTag(st: string): void;
        writeFullEndTag(st: string): void;
        writeAttribute(attr: string, value: string): void;
        writeStyleAttribute(attr: string, value: string): void;
        flush(): void;
        private closeTag();
        private checkIndent();
        constructor(baseStream: TextWriter);
    }
    class StiHtmlTableRender {
        private htmlExport;
        private htmlExportSettings;
        matrix: StiMatrix;
        renderStyle(style: StiCellStyle): void;
        renderStyleTable(cell: StiHtmlTableCell, style: StiCellStyle): void;
        renderStyles(useBookmarks: boolean, exportBookmarksOnly: boolean, cssStyles: Hashtable): void;
        renderStylesTable(useBookmarks: boolean, exportBookmarksOnly: boolean, cssStyles?: Hashtable): void;
        renderStylesTable2(useBookmarks: boolean, exportBookmarksOnly: boolean, addStyleTag: boolean, cssStyles?: Hashtable): void;
        private getWidth(listX, listXKeys, columnIndex, zoom);
        private getHeight(listY, listYKeys, rowIndex, zoom);
        renderTable(renderStyles: boolean, backGroundImageString: string, useBookmarks: boolean, exportBookmarksOnly: boolean, cssStyles: Hashtable): void;
        constructor(htmlExport: StiHtmlExportService, htmlExportSettings: StiHtmlExportSettings, pages: StiPagesCollection);
    }
}
declare module Stimulsoft.Report.Export {
    enum EmfTextAlignmentMode {
        TA_LEFT = 0,
        TA_RIGHT = 2,
        TA_CENTER = 6,
        TA_TOP = 0,
        TA_BOTTOM = 8,
        TA_BASELINE = 24,
        TA_NOUPDATECP = 0,
        TA_UPDATECP = 1,
        TA_RTLREADING = 256,
        TA_MASK = 287,
    }
}
declare module Stimulsoft.Report.Export {
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    class StiSegmentPagesDivider {
        static divide(pages: StiPagesCollection, service?: StiExportService): StiPagesCollection;
    }
}
declare module Stimulsoft.Report.Export {
    enum StiHtmlExportMode {
        Span = 1,
        Div = 2,
        Table = 3,
    }
    enum StiHtmlExportQuality {
        High = 1,
        Low = 2,
    }
    enum StiUserAccessPrivileges {
        None = 0,
        PrintDocument = 1,
        ModifyContents = 2,
        CopyTextAndGraphics = 4,
        AddOrModifyTextAnnotations = 8,
        All = 15,
    }
    enum StiPdfEncryptionKeyLength {
        Bit40 = 1,
        Bit128 = 2,
        Bit256_r5 = 3,
        Bit256_r6 = 4,
    }
    enum StiPdfImageCompressionMethod {
        Jpeg = 1,
        Flate = 2,
    }
    enum StiPdfAutoPrintMode {
        None = 1,
        Dialog = 2,
        Silent = 3,
    }
    enum StiTxtBorderType {
        Simple = 1,
        UnicodeSingle = 2,
        UnicodeDouble = 3,
    }
    enum StiPcxPaletteType {
        Monochrome = 1,
        Color = 2,
    }
    enum StiMonochromeDitheringType {
        None = 1,
        FloydSteinberg = 2,
        Ordered = 3,
    }
    enum StiImageType {
        Bmp = 1,
        Gif = 2,
        Jpeg = 3,
        Pcx = 4,
        Png = 5,
        Tiff = 6,
        Emf = 7,
        Svg = 8,
        Svgz = 9,
    }
    enum StiHtmlType {
        Html = 1,
        Html5 = 2,
        Mht = 3,
    }
    enum StiHtmlChartType {
        Image = 1,
        Vector = 2,
        AnimatedVector = 3,
    }
    enum StiExcelType {
        ExcelBinary = 1,
        ExcelXml = 2,
        Excel2007 = 3,
    }
    enum StiDataType {
        Csv = 1,
        Dbf = 2,
        Dif = 3,
        Sylk = 4,
        Xml = 5,
    }
    enum StiExportPosition {
        Pdf = 0,
        Xps = 1,
        Ppt2007 = 2,
        Html = 10,
        Html5 = 11,
        Mht = 12,
        Txt = 20,
        Rtf = 21,
        Word2007 = 22,
        Odt = 23,
        Excel = 30,
        ExcelXml = 31,
        Excel2007 = 32,
        Ods = 33,
        Data = 40,
        Image = 50,
    }
    enum StiHtmlExportBookmarksMode {
        BookmarksOnly = 1,
        ReportOnly = 2,
        All = 3,
    }
    enum StiDbfCodePages {
        Default = 0,
        USDOS = 437,
        MazoviaDOS = 620,
        GreekDOS = 737,
        InternationalDOS = 850,
        EasternEuropeanDOS = 852,
        IcelandicDOS = 861,
        NordicDOS = 865,
        RussianDOS = 866,
        KamenickyDOS = 895,
        TurkishDOS = 857,
        EasternEuropeanWindows = 1250,
        RussianWindows = 1251,
        WindowsANSI = 1252,
        GreekWindows = 1253,
        TurkishWindows = 1254,
        StandardMacintosh = 10000,
        GreekMacintosh = 10006,
        RussianMacintosh = 10007,
        EasternEuropeanMacintosh = 10029,
    }
    enum StiExportDataType {
        String = 0,
        Int = 1,
        Long = 2,
        Float = 3,
        Double = 4,
        Date = 5,
        Bool = 6,
    }
    enum StiImageFormat {
        Color = 1,
        Grayscale = 2,
        Monochrome = 3,
    }
    enum StiRtfExportMode {
        Table = 4,
        Frame = 1,
        WinWord = 2,
        TabbedText = 3,
    }
    enum StiDataExportMode {
        Data = 1,
        Headers = 2,
        Footers = 4,
        HeadersFooters = 6,
        DataAndHeadersFooters = 7,
        AllBands = 15,
    }
    enum StiWord2007RestrictEditing {
        No = 1,
        ExceptEditableFields = 2,
        Yes = 3,
    }
    enum StiExcel2007RestrictEditing {
        No = 1,
        ExceptEditableFields = 2,
        Yes = 3,
    }
    enum StiPdfAllowEditable {
        No = 1,
        Yes = 2,
    }
    enum StiImageResolutionMode {
        Exactly = 1,
        NoMoreThan = 2,
        Auto = 3,
    }
    enum StiPdfComplianceMode {
        None = 0,
        A1 = 1,
        A2 = 2,
        A3 = 3,
    }
    enum StiExcelSheetViewMode {
        Normal = 1,
        PageLayout = 2,
        PageBreakPreview = 3,
    }
}
declare module Stimulsoft.Report {
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    class StiPagesRange {
        static All: StiPagesRange;
        rangeType: StiRangeType;
        pageRanges: string;
        currentPage: number;
        stiEquals(obj: any): boolean;
        getSelectedPages(originalPages: StiPagesCollection): StiPagesCollection;
        constructor(rangeType?: StiRangeType, pageRanges?: string, currentPage?: number);
    }
}
declare module Stimulsoft.Report.Func {
    import DateTime = Stimulsoft.System.DateTime;
    class En {
        private static months;
        private static units;
        private static tens;
        private static addUnits(sb, value);
        private static addTens(sb, value);
        private static addRank(sb, REFrank, REFvalue, unit);
        static decline(value: number, oneOrShowCents: string | boolean, twoOrDollars: string, cents?: string): string;
        static numToStr(value: number, uppercase?: boolean): string;
        static currToStr3(value: number, showCents: boolean): string;
        static currToStr(value: number, uppercase?: boolean, showCents?: boolean, dollars?: string, cents?: string): string;
        static dateToStr(date: DateTime, uppercase?: boolean): string;
    }
}
declare module Stimulsoft.Report.Func {
    class EnGb {
        static zeroWord: string;
        static lessWord: string;
        static triplets: string[][];
        static lessTwenty: string[];
        static tens: string[];
        static convertToWord(numberr: number, currencyISO: string, decimals: number): string;
        private static convertToWord2(numberr, gender, tranche);
        private static calculateOver(numberr, gender);
    }
}
declare module Stimulsoft.Report.Func {
    class EnIn {
        static numberToStr(value: number, blankIfZero?: boolean): string;
        static currencyToStr(currencyBasicUnit: string, currencyFractionalUnit: string, value: number, decimalPlaces: number, blankIfZero?: boolean): string;
        private static numberToWords(numberr, blankIfZero);
        private static _wordsDictionary;
        private static readonly wordsDictionary;
    }
}
declare module Stimulsoft.Report.Func {
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    import ResourceManager = Stimulsoft.System.ResourceManager;
    import DateTime = Stimulsoft.System.DateTime;
    enum Gender {
        Masculine = 0,
        Feminine = 1,
        Neutral = 2,
    }
    class BaseCurrency {
        readonly gender: Gender;
        readonly centsGender: Gender;
    }
    class Currency extends BaseCurrency {
        readonly dollars: string[];
        readonly cents: string[];
        readonly dollarOne: string;
        readonly dollarTwo: string;
        readonly dollarFive: string;
        readonly centOne: string;
        readonly centTwo: string;
        readonly centFive: string;
    }
    class NumToWordHelper {
        static maxValue: number;
        private static addWord(REFvalue, word, separator);
        static addWords(integerString: string, decimalString: string, mainCurrency: string, centCurrency: string, postCurrency: string): string;
        static determinateCurrencies(culture: CultureInfo, currencyISO: string, integerPart: number, decimalPart: number, REFmainCurrency: any, REFcentCurrency: any): void;
    }
    function NumToWordException(message: string, num: number): string;
    class Resource {
        private static resourceMan;
        private static resourceCulture;
        static readonly resourceManager: ResourceManager;
        static culture: CultureInfo;
        static readonly eurBigSeparator: string;
        static readonly eurCentGender: string;
        static readonly eurCentPlural: string;
        static readonly EURCentSingle: string;
        static readonly EURGender: string;
        static readonly EURPlural: string;
        static readonly EURSingle: string;
        static readonly GBPBigSeparator: string;
        static readonly GBPCentGender: string;
        static readonly GBPCentPlural: string;
        static readonly GBPCentSingle: string;
        static readonly GBPGender: string;
        static readonly GBPPlural: string;
        static readonly GBPSingle: string;
        static readonly TooLongError: string;
    }
    class Convert {
        private static arabics;
        private static romans;
        private static subs;
        private static abc;
        private static abcRu;
        static toRoman(value: number): string;
        static toABC(value: number): string;
        static toABCNumeric(value: number): string;
        static toABCRu(value: number): string;
        static toArabic(val: number | string, useEasternDigits: boolean): string;
    }
    class EngineHelper {
        static joinColumnContent(source: StiBusinessObject | StiDataSource, columnName: string, delimiter: string, distinct?: boolean): string;
        static toQueryString<T>(list: Array<T>, quotationMark: string, dateTimeFormat: string): string;
    }
    class MonthToStr {
        private static months;
        private static defaultUpperCaseList;
        private static cultureIndexes;
        static monthName(dateTime: DateTime, cultureOrIsLocalized?: string | boolean, upperCase?: boolean): string;
        static addCulture(monthsNames: string[], cultureNames: string[], defaultUpperCase: boolean): void;
        static MonthToStr(): void;
    }
    class DayOfWeekToStr {
        private static days;
        private static defaultUpperCaseList;
        private static cultureIndexes;
        static dayOfWeek(date: DateTime, cultureOrLocalized?: string | boolean, upperCase?: boolean): string;
        static addCulture(monthsNames: string[], cultureNames: string[], defaultUpperCase: boolean): void;
        static DayOfWeekToStr(): void;
    }
}
declare module Stimulsoft.Report.Func {
    class Es {
        static zeroWord: string;
        static lessWord: string;
        static triplets: string[][];
        static lessTwenty: string[];
        static tens: string[];
        static currencies: string[][];
        static convertToWord(numberr: number, currencyISO: string, decimals: number): string;
        private static determinateCurrenciesEurUsd(culture, currencyISO, integerPart, decimalPart, REFmainCurrency, REFcentCurrency);
        static numToStr(numberr: number, uppercase: boolean): string;
        static numToStr2(numberr: number, uppercase: boolean, female: boolean): string;
        private static convertToWord2(numberr, gender, tranche, alone?);
    }
}
declare module Stimulsoft.Report.Func {
    class Fa {
        static convertToWord(numberr: number): string;
        private static changingNum(numberr);
    }
}
declare module Stimulsoft.Report.Func {
    class Fr {
        static zeroWord: string;
        static lessWord: string;
        static triplets: string[][];
        static lessTwentys: string[];
        static tens: string[];
        static convertToWord(numberr: number, currencyISO: string, decimals: number): string;
        private static convertToWord2(numberr, gender, tranche);
        private static calculateOver(numberr, gender);
    }
}
declare module Stimulsoft.Report.Func {
    class Nl {
        static zeroWord: string;
        static lessWord: string;
        static triplets: string[][];
        static lessTwenty: string[];
        static tens: string[];
        static convertToWord(numberr: number, currencyISO: string, decimals: number): string;
        private static convertToWord2(numberr, gender, tranche);
        private static calculateOver(numberr, gender);
    }
}
declare module Stimulsoft.Report.Func {
    import DateTime = Stimulsoft.System.DateTime;
    class Pl {
        private static units;
        private static tens;
        private static hundreds;
        private static thousends;
        private static million;
        private static billion;
        private static trillion;
        private static quadrillion;
        private static quintillion;
        private static zloty;
        private static grosz;
        private static dollar;
        private static cent;
        private static euro;
        private static months;
        static numToStr(value: number, uppercase: boolean): string;
        private static addUnits(sb, value);
        private static addTens(sb, value);
        private static addHundreds(sb, value);
        private static addRank(sb, reff, unit);
        private static decline2(value, post);
        private static decline(value, showCents, dollars, cents);
        private static currToStr2(value, uppercase, showCents, dollars, cents);
        static currToStr(value: number, currencyISO: string, showCents: boolean, uppercase: boolean): string;
        static dateToStr(date: DateTime, uppercase: boolean): string;
    }
}
declare module Stimulsoft.Report.Func {
    import DateTime = Stimulsoft.System.DateTime;
    class Pt {
        private static units;
        private static tens;
        private static months;
        static numToStr(value: number, uppercase: boolean): string;
        private static addRank(sb, refRank, refValue, unit, greaterOrEqualThanThousand);
        private static addUnits(sb, value);
        private static addTens(sb, value);
        private static decline(value, showCents, dollars, cents);
        private static decline2(value, one, two);
        static currToStr(value: number, uppercase: boolean, showCents: boolean): string;
        static dateToStr(value: DateTime): string;
    }
}
declare module Stimulsoft.Report.Func {
    class PtBr {
        private static unid;
        private static dezena;
        private static centena;
        static numToStr(value: number): string;
    }
}
declare module Stimulsoft.Report.Func {
    import DateTime = Stimulsoft.System.DateTime;
    class Ru {
        private static currencies;
        static registerCurrency(currency: Currency, currencyName: string): void;
        private static getCurrency(currencyName);
        private static months;
        private static units;
        private static tens;
        private static hundreds;
        private static gendered;
        private static addUnits(sb, value, gender);
        private static addTens(sb, value);
        private static addHundreds(sb, value);
        private static addThousand(sb, value, gender);
        private static addRank(sb, refRank, refValue, one, two, five, gender);
        static numToStr(value: number, uppercase?: boolean, gender?: Gender): string;
        static currToStr(value: number, uppercase?: boolean, currency?: string, cents?: boolean): string;
        static decline2(value: number, one: string, two: string, five: string): string;
        static decline(value: number, currency: string, cents?: boolean): string;
        static dateToStr(date: DateTime, uppercase?: boolean): string;
    }
}
declare module Stimulsoft.Report.Func {
    class Tr {
        static Birler: string[];
        static Onlar: string[];
        static Binler: string[];
        static numToStr(value: number): string;
        static currToStr(value: number, currencyName?: string, showZeroCents?: boolean): string;
    }
}
declare module Stimulsoft.Report.Func {
    import DateTime = Stimulsoft.System.DateTime;
    class Ua {
        private static currencies;
        static registerCurrency(currency: Currency, currencyName: string): void;
        private static getCurrency(currencyName);
        private static months;
        private static units;
        private static tens;
        private static hundreds;
        private static gendered;
        private static addUnits(sb, value, gender);
        private static addTens(sb, value);
        private static addHundreds(sb, value);
        private static addThousand(sb, value, gender);
        private static addRank(sb, refRank, refValue, one, two, five, gender);
        static numToStr(value: number, uppercase?: boolean, gender?: Gender): string;
        static currToStr(value: number, uppercase?: boolean, currency?: string, cents?: boolean): string;
        static decline2(value: number, one: string, two: string, five: string): string;
        static decline(value: number, currency: string, cents?: boolean): string;
        static dateToStr(date: DateTime, uppercase?: boolean): string;
    }
}
declare module Stimulsoft.Report.Func {
    class Zh {
        private static numChineseCharacter;
        static toWordsZh(num: number): string;
        static toCurrencyWordsZh(num: number): string;
        private static floatString(num);
        private static numberString(num);
        private static convert4(num);
        private static convertString(num);
        private static convert2(num);
        private static convert3(num);
    }
}
declare module Stimulsoft.Report {
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    var IStiGlobalizationManager: string;
    interface IStiGlobalizationManager {
        culture: CultureInfo;
        getString(name: string): string;
        getObject(name: string): any;
    }
}
declare module Stimulsoft.Report {
    var IStiGlobalizationManagerList: string;
    interface IStiGlobalizationManagerList {
        getTextGlobalizedNames(): string[];
        getImageGlobalizedNames(): string[];
    }
}
declare module Stimulsoft.Report {
    var IStiGlobalizationProvider: string;
    interface IStiGlobalizationProvider {
        setString(propertyName: string, value: string): any;
        getString(propertyName: string): string;
        getAllStrings(): string[];
    }
}
declare module Stimulsoft.Report {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiGlobalizationContainer implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _cultureName;
        cultureName: string;
        private _items;
        items: StiGlobalizationItemCollection;
        getAllStringsForReport(report: StiReport): Hashtable;
        localizeReport(report: StiReport): void;
        fillItemsFromReport(report: StiReport): void;
        removeUnlocalizedItemsFromReport(report: StiReport): void;
        constructor(cultureName?: string);
    }
}
declare module Stimulsoft.Report {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiGlobalizationContainerCollection extends CollectionBase<StiGlobalizationContainer> implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        add(data: StiGlobalizationContainer): void;
        addRange(data: StiGlobalizationContainer[]): void;
        contains(data: StiGlobalizationContainer): boolean;
        indexOf(data: StiGlobalizationContainer): number;
        insert(index: number, data: StiGlobalizationContainer): void;
        remove(data: StiGlobalizationContainer): void;
        getByIndex(index: number): StiGlobalizationContainer;
        setByIndex(index: number, value: StiGlobalizationContainer): void;
        getByName(name: string): StiGlobalizationContainer;
        setByName(name: string, value: StiGlobalizationContainer): void;
        private report;
        skipException: boolean;
        localizeReport(cultureName: string): void;
        localizeReport2(info: CultureInfo): void;
        fillItemsFromReport(): void;
        removeUnlocalizedItemsFromReport(): void;
        removeComponent(comp: StiComponent): void;
        renameComponent(comp: StiComponent, oldName: string, newName: string): void;
        constructor(report: StiReport);
    }
}
declare module Stimulsoft.Report {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiGlobalizationItem implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _propertyName;
        propertyName: string;
        private _text;
        text: string;
        toString(): string;
        constructor(propertyName?: string, text?: string);
    }
}
declare module Stimulsoft.Report {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    class StiGlobalizationItemCollection extends CollectionBase<StiGlobalizationItem> implements IComparer<StiGlobalizationItem> {
        compare(item1: StiGlobalizationItem, item2: StiGlobalizationItem): number;
        add(data: StiGlobalizationItem): void;
        addRange(data: StiGlobalizationItem[]): void;
        contains(data: StiGlobalizationItem): boolean;
        indexOf(data: StiGlobalizationItem): number;
        insert(index: number, data: StiGlobalizationItem): void;
        remove(data: StiGlobalizationItem): void;
        getByIndex(index: number): StiGlobalizationItem;
        setByIndex(index: number, value: StiGlobalizationItem): void;
        sort(): void;
    }
}
declare module Stimulsoft.Report.Helpers {
    class StiFileDialogHelper {
        static dataExts: string[];
        static imageExts: string[];
        static reportExts: string[];
        static textExts: string[];
        static documentExts: string[];
        static fontExts: string[];
    }
}
declare module Stimulsoft.Report {
    class StiFontIconsHelper {
        static getContent(fontIcons: StiFontIcons): string;
        private static getNetContent(fontIcons);
    }
}
declare module Stimulsoft.Report.Helpers {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImageTransparenceHelper {
        static getTransparentedImage(source: Image, transparency: number): Image;
    }
}
declare module Stimulsoft.Report.Helpers {
    import DataSet = Stimulsoft.System.Data.DataSet;
    import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
    class StiResourceArrayToDataSet {
        static get(resourceType: StiResourceType, array: number[]): DataSet;
    }
}
declare module Stimulsoft.Report.Helpers {
    import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
    class StiResourceTypeHelper {
        static getTypeFromExtension(extension: string): StiResourceType;
        static isImageType(ext: string): boolean;
        static isTextType(ext: string): boolean;
        private static isExtensionType(exts, ext);
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    var IStiCustomValueBase: string;
    interface IStiCustomValueBase {
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    var IStiGauge: string;
    interface IStiGauge extends IStiComponent {
        scales: any;
        drawGauge(context: StiGaugeContextPainter): any;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): any;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    var IStiGaugeElement: string;
    interface IStiGaugeElement {
    }
}
declare module Stimulsoft.Report.Gauge {
    var IStiGaugeStyleXF: string;
    interface IStiGaugeStyleXF {
        createNew(): IStiGaugeStyleXF;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    var IStiIndicatorRangeInfo: string;
    interface IStiIndicatorRangeInfo {
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    var IStiRangeBase: string;
    interface IStiRangeBase {
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    var IStiScaleBase: string;
    interface IStiScaleBase {
        prepare(gauge: IStiGauge): any;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapData {
        constructor(key: string);
        key: string;
        private _value;
        value: string;
        private _group;
        group: string;
        name: string;
        private _color;
        color: string;
        toString(): string;
        private invokeValueChanged();
    }
}
declare module Stimulsoft.Report.Maps {
    import StiMapGeom = Stimulsoft.Base.Maps.Geoms.StiMapGeom;
    import StiMapGeomsContainer = Stimulsoft.Base.Maps.Geoms.StiMapGeomsContainer;
    class StiMapLoader {
        private static hashMaps;
        static loadResource(resourceName: string): StiMapSvgContainer;
        static getGeomsObject(resourceName: string): StiMapGeomsContainer;
        private static createGeom(ident, values, startIndex, index, commands);
        static parsePath(text: string): StiMapGeom[];
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapSvg {
        key: string;
        data: string;
        toString(): string;
    }
}
declare module Stimulsoft.Report.Maps {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiMapSvgContainer {
        name: string;
        width: number;
        height: number;
        paths: StiMapSvg[];
        hashSvg: Hashtable;
        prepare(): void;
    }
}
declare module Stimulsoft.Report.Maps {
    import StiMapStyle = Stimulsoft.Report.Styles.StiMapStyle;
    class StiMapStyleFX extends StiMapStyle {
        readonly localizeName: string;
        readonly styleId: StiMapStyleIdent;
    }
}
declare module Stimulsoft.Report.Maps {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap21StyleFX extends StiMapStyleFX {
        readonly styleId: StiMapStyleIdent;
        readonly localizeName: string;
        colors: Color[];
        heatmapColors: Color[];
        defaultColor: Color;
        backColor: Color;
        foreColor: Color;
    }
}
declare module Stimulsoft.Report.Maps {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap24StyleFX extends StiMapStyleFX {
        readonly styleId: StiMapStyleIdent;
        readonly localizeName: string;
        colors: Color[];
        heatmapColors: Color[];
        defaultColor: Color;
        backColor: Color;
        foreColor: Color;
    }
}
declare module Stimulsoft.Report.Maps {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap25StyleFX extends StiMapStyleFX {
        readonly styleId: StiMapStyleIdent;
        readonly localizeName: string;
        colors: Color[];
        heatmapColors: Color[];
        defaultColor: Color;
        backColor: Color;
        foreColor: Color;
    }
}
declare module Stimulsoft.Report.Maps {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap26StyleFX extends StiMapStyleFX {
        readonly styleId: StiMapStyleIdent;
        readonly localizeName: string;
        colors: Color[];
        heatmapColors: Color[];
        defaultColor: Color;
        backColor: Color;
        foreColor: Color;
    }
}
declare module Stimulsoft.Report.Maps {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap27StyleFX extends StiMapStyleFX {
        readonly styleId: StiMapStyleIdent;
        readonly localizeName: string;
        colors: Color[];
        heatmapColors: Color[];
        defaultColor: Color;
        backColor: Color;
        foreColor: Color;
    }
}
declare module Stimulsoft.Report.Maps {
    enum StiMapMode {
        Choropleth = 0,
        Online = 1,
    }
    enum StiMapID {
        World = 1,
        Australia = 2,
        Austria = 3,
        Brazil = 4,
        Canada = 5,
        China = 6,
        EU = 7,
        Europe = 8,
        France = 9,
        Germany = 10,
        Italy = 11,
        Netherlands = 12,
        Russia = 13,
        UK = 14,
        USA = 15,
        Albania = 16,
        Andorra = 17,
        Argentina = 18,
        Armenia = 19,
        Azerbaijan = 20,
        Belarus = 21,
        Belgium = 22,
        Bolivia = 23,
        BosniaAndHerzegovina = 24,
        Bulgaria = 25,
        Chile = 26,
        Colombia = 27,
        Croatia = 28,
        Cyprus = 29,
        CzechRepublic = 30,
        Denmark = 31,
        Ecuador = 32,
        Estonia = 33,
        FalklandIslands = 34,
        Finland = 35,
        Georgia = 36,
        Greece = 37,
        Guyana = 38,
        Hungary = 39,
        Iceland = 40,
        India = 41,
        Indonesia = 42,
        Ireland = 43,
        Israel = 44,
        Japan = 45,
        Kazakhstan = 46,
        Latvia = 47,
        Liechtenstein = 48,
        Lithuania = 49,
        Luxembourg = 50,
        Macedonia = 51,
        Malaysia = 52,
        Malta = 53,
        Mexico = 54,
        Moldova = 55,
        Monaco = 56,
        Montenegro = 57,
        NewZealand = 58,
        Norway = 59,
        Paraguay = 60,
        Peru = 61,
        Philippines = 62,
        Poland = 63,
        Portugal = 64,
        Romania = 65,
        SanMarino = 66,
        SaudiArabia = 67,
        Serbia = 68,
        Slovakia = 69,
        Slovenia = 70,
        SouthAfrica = 71,
        SouthKorea = 72,
        Spain = 73,
        Suriname = 74,
        Sweden = 75,
        Switzerland = 76,
        Thailand = 77,
        Turkey = 78,
        Ukraine = 79,
        Uruguay = 80,
        Vatican = 81,
        Venezuela = 82,
        Vietnam = 83,
    }
    enum StiMapStyleIdent {
        Style21 = 0,
        Style24 = 1,
        Style25 = 2,
        Style26 = 3,
        Style27 = 4,
    }
    enum StiMapType {
        None = 0,
        Group = 1,
        Heatmap = 2,
        HeatmapWithGroup = 3,
        Individual = 4,
    }
}
declare module Stimulsoft.Report.Maps {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMapHelper {
        private static globalReport;
        private static globalMap;
        static getMapSample(): StiMap;
        static getColors(): Color[];
    }
}
declare module Stimulsoft.Report.Painters {
    import Type = Stimulsoft.System.Type;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiPainter {
        private static typePainter;
        static getPainter(componentType: Type): StiPainter;
        getImage(component: Stimulsoft.Report.Components.StiComponent, REFzoom: any, format: StiExportFormat): Image;
        paint(component: Stimulsoft.Report.Components.StiComponent, g: Stimulsoft.System.Drawing.Graphics): void;
    }
}
declare module Stimulsoft.Report.Painters {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiComponentPainter extends StiPainter {
        paintBorder(component: StiComponent, g: Graphics, rect: RectangleD, zoom: number, drawBorderFormatting: boolean, drawBorderSides: boolean): void;
    }
}
declare module Stimulsoft.Report.Painters {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiContainerPainter extends StiComponentPainter {
        paintComponents(container: StiContainer, g: Graphics): void;
        paint(component: StiComponent, g: Graphics): void;
    }
}
declare module Stimulsoft.Report.Painters {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiViewPainter extends StiComponentPainter {
        getImage(component: Stimulsoft.Report.Components.StiComponent, REFzoom: any, format: StiExportFormat): Image;
    }
}
declare module Stimulsoft.Report.Painters {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImagePainter extends StiViewPainter {
        getImage(component: Stimulsoft.Report.Components.StiComponent, REFzoom: any, format: StiExportFormat): Image;
    }
}
declare module Stimulsoft.Report.Painters {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    class StiPagePainter extends StiContainerPainter implements IStiPagePainter {
        implements(): string[];
        paint(comp: StiComponent, g: Graphics): void;
    }
}
declare module Stimulsoft.Report.Painters {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiText = Stimulsoft.Report.Components.StiText;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTextPainter extends StiComponentPainter {
        paintText(textComp: StiText, g: Graphics, rect: RectangleD): void;
        paintBackground(text: StiText, g: Graphics, rect: RectangleD): void;
        paintBorder(component: StiComponent, g: Graphics, rect: RectangleD, zoom: number, drawBorderFormatting: boolean, drawTopmostBorderSides: boolean): void;
        paint(component: StiComponent, g: Graphics): void;
    }
}
declare module Stimulsoft.Report.Painters {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Image = Stimulsoft.System.Drawing.Image;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    var IStiBarCodePainter: string;
    interface IStiBarCodePainter {
        baseTransform(context: any, x: number, y: number, angle: number, dx: number, dy: number): any;
        baseRollbackTransform(context: any): any;
        baseFillRectangle(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): any;
        baseFillRectangle2D(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): any;
        baseFillPolygon(context: any, brush: StiBrush, points: PointD[]): any;
        baseFillEllipse(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): any;
        baseDrawRectangle(context: any, penColor: Color, penSize: number, x: number, y: number, width: number, height: number): any;
        baseDrawImage(context: any, image: Image, report: StiReport, x: number, y: number, width: number, height: number): any;
        baseDrawString(context: any, st: string, font: Font, brush: StiBrush, rect: RectangleD, sf: StringFormat): any;
        baseMeasureString(context: any, st: string, font: Font): SizeD;
    }
}
declare module Stimulsoft.Report.Painters {
    var IStiPagePainter: string;
    interface IStiPagePainter {
    }
}
declare module Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionElement {
    }
}
declare module Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionComponentNameElement extends StiStyleConditionElement {
        private _operationComponentName;
        /** Gets or sets type of operation which will be used for comparison of component names. */
        operationComponentName: StiStyleConditionOperation;
        private _componentName;
        /** Gets or sets component name or part of component name. */
        componentName: string;
        constructor(componentName: string, operationComponentName?: StiStyleConditionOperation);
    }
}
declare module Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionComponentTypeElement extends StiStyleConditionElement {
        private _componentType;
        /** Gets or sets component type which can be detected by style condition. */
        componentType: StiStyleComponentType;
        private _operationComponentType;
        /** Gets or sets type of operation which will be used for comparison of component types. */
        operationComponentType: StiStyleConditionOperation;
        constructor(componentType: StiStyleComponentType, operationComponentType?: StiStyleConditionOperation);
    }
}
declare module Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionLocationElement extends StiStyleConditionElement {
        private _operationLocation;
        /** Gets or sets type of operation which will be used for comparison of component locations. */
        operationLocation: StiStyleConditionOperation;
        private _location;
        /** Gets or sets variant of component location on parent component area. */
        location: StiStyleLocation;
        constructor(location: StiStyleLocation, operationLocation?: StiStyleConditionOperation);
    }
}
declare module Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionPlacementElement extends StiStyleConditionElement {
        private _placement;
        /** Gets or sets type of bands on which component can be placed. */
        placement: StiStyleComponentPlacement;
        private _operationPlacement;
        /** Gets or sets type of operation which will be used for comparison of component placements. */
        operationPlacement: StiStyleConditionOperation;
        constructor(placement: StiStyleComponentPlacement, operationPlacement?: StiStyleConditionOperation);
    }
}
declare module Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionPlacementNestedLevelElement extends StiStyleConditionElement {
        private _placementNestedLevel;
        /** Gets or sets value which indicates nested level of specified component. */
        placementNestedLevel: number;
        private _operationPlacementNestedLevel;
        /** Gets or sets type of operation which will be used for comparison of component nested level. */
        operationPlacementNestedLevel: StiStyleConditionOperation;
        constructor(placementNestedLevel: number, operationPlacementNestedLevel?: StiStyleConditionOperation);
    }
}
declare module Stimulsoft.Report.Styles.Conditions {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiStyleConditionElement = Stimulsoft.Report.Styles.Conditions.Elements.StiStyleConditionElement;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiStyleCondition implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiStyleCondition;
        private _type;
        /** Gets or sets type of this style condition. */
        type: StiStyleConditionType;
        private _operationPlacement;
        /** Gets or sets type of operation which will be used for comparison of component placements. */
        operationPlacement: StiStyleConditionOperation;
        private _operationPlacementNestedLevel;
        /** Gets or sets type of operation which will be used for comparison of component nested level. */
        operationPlacementNestedLevel: StiStyleConditionOperation;
        private _operationComponentType;
        /** Gets or sets type of operation which will be used for comparison of component types. */
        operationComponentType: StiStyleConditionOperation;
        private _operationLocation;
        /** Gets or sets type of operation which will be used for comparison of component locations. */
        operationLocation: StiStyleConditionOperation;
        private _operationComponentName;
        /** Gets or sets type of operation which will be used for comparison of component names. */
        operationComponentName: StiStyleConditionOperation;
        private _placement;
        /** Gets or sets type of bands on which component can be placed. */
        placement: StiStyleComponentPlacement;
        private _placementNestedLevel;
        /** Gets or sets value which indicates nested level of specified component. */
        placementNestedLevel: number;
        private _componentType;
        /** Gets or sets component type which can be detected by style condition. */
        componentType: StiStyleComponentType;
        private _location;
        /** Gets or sets variant of component location on parent component area. */
        location: StiStyleLocation;
        private _componentName;
        /** Gets or sets component name or part of component name. */
        componentName: string;
        fromElements(elements: StiStyleConditionElement[]): void;
        constructor();
        constructor(type: StiStyleConditionElement[]);
        constructor(type: StiStyleConditionType, operationPlacement: StiStyleConditionOperation, operationPlacementNestedLevel: StiStyleConditionOperation, operationComponentType: StiStyleConditionOperation, operationLocation: StiStyleConditionOperation, operationComponentName: StiStyleConditionOperation, placement: StiStyleComponentPlacement, placementNestedLevel: number, componentType: StiStyleComponentType, location: StiStyleLocation, componentName: string);
    }
}
declare module Stimulsoft.Report.Styles {
    /** Enum provide types of style condition. */
    enum StiStyleConditionType {
        ComponentType = 1,
        Placement = 2,
        PlacementNestedLevel = 4,
        ComponentName = 8,
        Location = 16,
    }
    /** Enum provide type of bands on which component can be placed. */
    enum StiStyleComponentPlacement {
        None = 0,
        ReportTitle = 1,
        ReportSummary = 2,
        PageHeader = 4,
        PageFooter = 8,
        GroupHeader = 16,
        GroupFooter = 32,
        Header = 64,
        Footer = 128,
        ColumnHeader = 256,
        ColumnFooter = 512,
        Data = 1024,
        DataEvenStyle = 2048,
        DataOddStyle = 4096,
        Table = 8192,
        Hierarchical = 16384,
        Child = 32768,
        Empty = 65536,
        Overlay = 131072,
        Panel = 262144,
        Page = 524288,
        AllExeptStyles = 1042431,
    }
    /** Enum provide component type which can be detected by style condition. */
    enum StiStyleComponentType {
        Text = 1,
        Primitive = 2,
        Image = 4,
        CrossTab = 8,
        Chart = 16,
        CheckBox = 32,
    }
    /** Enum provide all variants of location component on parent component area. */
    enum StiStyleLocation {
        None = 0,
        TopLeft = 1,
        TopCenter = 2,
        TopRight = 4,
        MiddleLeft = 8,
        MiddleCenter = 16,
        MiddleRight = 32,
        BottomLeft = 64,
        BottomCenter = 128,
        BottomRight = 256,
        Left = 512,
        Right = 1024,
        Top = 2048,
        Bottom = 4096,
        CenterHorizontal = 8192,
        CenterVertical = 16384,
    }
    enum StiStyleConditionOperation {
        EqualTo = 0,
        NotEqualTo = 1,
        GreaterThan = 2,
        GreaterThanOrEqualTo = 3,
        LessThan = 4,
        LessThanOrEqualTo = 5,
        Containing = 6,
        NotContaining = 7,
        BeginningWith = 8,
        EndingWith = 9,
    }
}
declare module Stimulsoft.Report {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    class StiStyleConditionHelper {
        static isAllowStyle(component: StiComponent, style: StiBaseStyle): boolean;
    }
}
declare module Stimulsoft.Report.Styles {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiBrushType = Stimulsoft.Report.StiBrushType;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiChartStyle extends StiBaseStyle {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        border: StiBorder;
        brush: StiBrush;
        chartAreaBrush: StiBrush;
        chartAreaBorderColor: Color;
        chartAreaShowShadow: boolean;
        seriesLighting: boolean;
        seriesShowShadow: boolean;
        trendLineColor: Color;
        trendLineShowShadow: boolean;
        seriesLabelsBrush: StiBrush;
        seriesLabelsColor: Color;
        seriesLabelsBorderColor: Color;
        legendBrush: StiBrush;
        legendLabelsColor: Color;
        legendBorderColor: Color;
        legendTitleColor: Color;
        axisTitleColor: Color;
        axisLineColor: Color;
        axisLabelsColor: Color;
        interlacingHorBrush: StiBrush;
        interlacingVertBrush: StiBrush;
        gridLinesHorColor: Color;
        gridLinesVertColor: Color;
        brushType: StiBrushType;
        styleColors: Color[];
        basicStyleColor: Color;
        allowUseBorderFormatting: boolean;
        allowUseBorderSides: boolean;
        allowUseBrush: boolean;
        /** Gets a style from the component. */
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements, componentStyle?: StiBaseStyle): void;
    }
}
declare module Stimulsoft.Report.Styles {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiDialogStyle extends StiBaseStyle {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _foreColor;
        /** Gets or sets a foreground color for drawing this style. */
        foreColor: Color;
        private _backColor;
        /** Gets or sets a background color for drawing this style. */
        backColor: Color;
        private _font;
        /** Gets or sets a font for drawing this style. */
        font: Font;
        private _allowUseFont;
        /** Gets or sets a value which indicates whether a report engine can use Font for dialog controls. */
        allowUseFont: boolean;
        private _allowUseBackColor;
        /** Gets or sets a value which indicates whether a report engine can use BackColor for dialog controls. */
        allowUseBackColor: boolean;
        private _allowUseForeColor;
        /** Gets or sets a value which indicates whether a report engine can use ForeColor for dialog controls. */
        allowUseForeColor: boolean;
    }
}
declare module Stimulsoft.Report {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGaugeStyle extends StiBaseStyle {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        private _brush;
        brush: StiBrush;
        private _borderColor;
        borderColor: Color;
        private _borderWidth;
        borderWidth: number;
        private _tickMarkMajorBrush;
        tickMarkMajorBrush: StiBrush;
        private _tickMarkMajorBorder;
        tickMarkMajorBorder: StiBrush;
        private _tickMarkMinorBrush;
        tickMarkMinorBrush: StiBrush;
        private _tickMarkMinorBorder;
        tickMarkMinorBorder: StiBrush;
        private _tickLabelMajorTextBrush;
        tickLabelMajorTextBrush: StiBrush;
        private _tickLabelMajorFont;
        tickLabelMajorFont: Font;
        private _tickLabelMinorTextBrush;
        tickLabelMinorTextBrush: StiBrush;
        private _tickLabelMinorFont;
        tickLabelMinorFont: Font;
        private _markerBrush;
        markerBrush: StiBrush;
        private _linearBarBrush;
        linearBarBrush: StiBrush;
        private _linearBarBorderBrush;
        linearBarBorderBrush: StiBrush;
        private _linearBarEmptyBrush;
        linearBarEmptyBrush: StiBrush;
        private _linearBarEmptyBorderBrush;
        linearBarEmptyBorderBrush: StiBrush;
        private _radialBarBrush;
        radialBarBrush: StiBrush;
        private _radialBarBorderBrush;
        radialBarBorderBrush: StiBrush;
        private _radialBarEmptyBrush;
        radialBarEmptyBrush: StiBrush;
        private _radialBarEmptyBorderBrush;
        radialBarEmptyBorderBrush: StiBrush;
        private _needleBrush;
        needleBrush: StiBrush;
        private _needleBorderBrush;
        needleBorderBrush: StiBrush;
        private _needleCapBrush;
        needleCapBrush: StiBrush;
        private _needleCapBorderBrush;
        needleCapBorderBrush: StiBrush;
        drawStyle(g: Graphics, rect: Rectangle, paintValue: boolean, paintImage: boolean): void;
        drawBox(g: Graphics, rect: Rectangle, paintValue: boolean, paintImage: boolean): void;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
declare module Stimulsoft.Report.Styles {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiStyle extends StiBaseStyle {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): Object;
        private _horAlignment;
        /** Gets or sets a horizontal alignment of the style. */
        horAlignment: StiTextHorAlignment;
        private _vertAlignment;
        /** Gets or sets a vertical alignment of the style. */
        vertAlignment: StiVertAlignment;
        private _font;
        /** Gets or sets a font for drawing this style. */
        font: Font;
        private _border;
        /** Gets or sets a border of the component. */
        border: StiBorder;
        private _brush;
        /** Gets or sets a brush to fill the style. */
        brush: StiBrush;
        private _textBrush;
        /** Gets or sets a brush to draw the text. */
        textBrush: StiBrush;
        private _allowUseHorAlignment;
        /** Gets or sets a value which indicates whether a report engine can use HorAlignment formatting or not. */
        allowUseHorAlignment: boolean;
        private _allowUseVertAlignment;
        /** Gets or sets a value which indicates whether a report engine can use VertAlignment formatting or not. */
        allowUseVertAlignment: boolean;
        private _allowUseImage;
        /** Gets or sets a value which indicates whether a report engine can use Image formatting or not. */
        allowUseImage: boolean;
        private _allowUseFont;
        /** Gets or sets a value which indicates whether a report engine can use Font formatting or not. */
        allowUseFont: boolean;
        /** Gets or sets a value which indicates whether a report engine can use Border formatting or not. */
        allowUseBorder: boolean;
        private _allowUseBorderFormatting;
        /** Gets or sets a value which indicates whether a report engine can use Border formatting or not. */
        allowUseBorderFormatting: boolean;
        private _allowUseBorderSides;
        /** Gets or sets a value which indicates whether a report engine can use Border Sides or not. */
        allowUseBorderSides: boolean;
        private _allowUseBorderSidesFromLocation;
        /** Gets or sets a value which indicates whether a report engine can set border sides of a component depending on the component location. */
        allowUseBorderSidesFromLocation: boolean;
        private _allowUseBrush;
        /** Gets or sets a value which indicates whether a report engine can use Brush formatting or not. */
        allowUseBrush: boolean;
        private _allowUseTextBrush;
        /** Gets or sets a value which indicates whether a report engine can use TextBrush formatting or not. */
        allowUseTextBrush: boolean;
        private _allowUseTextOptions;
        /** Gets or sets a value which indicates whether a report engine can use TextOptions formatting or not. */
        allowUseTextOptions: boolean;
        /** Gets a style from the component. */
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements, componentStyle?: StiBaseStyle): void;
        /** Sets style to a component. */
        setStyleToComponent(component: StiComponent): void;
        private _image;
        /** Gets or sets an image to fill the Image property of the Image component. */
        image: Image;
    }
}
declare module Stimulsoft.Report.Styles {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiStylesCollection extends CollectionBase<StiBaseStyle> implements IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        add(style: StiBaseStyle): void;
        /** Removes all objects from the CollectionBase instance. */
        clear(): void;
        addRange(styles: StiBaseStyle[]): any;
        addRange(styles: StiStylesCollection): any;
        contains(style: StiBaseStyle): boolean;
        contains(styleName: string): boolean;
        indexOf(style: StiBaseStyle): number;
        insert(index: number, style: StiBaseStyle): void;
        remove(style: StiBaseStyle): void;
        getByIndex(index: number): StiBaseStyle;
        setByIndex(index: number, style: StiBaseStyle): void;
        getByName(name: string): StiBaseStyle;
        setByName(name: string, value: StiBaseStyle): void;
        private updateHash();
        toList(): StiBaseStyle[];
        private report;
        private hash;
        private needUpdateHash;
        private lastCount;
        constructor(report?: StiReport);
    }
}
declare module Stimulsoft.Report {
    import StiNestedFactor = Stimulsoft.Report.StiNestedFactor;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStylesCreator {
        private report;
        private _showReportTitles;
        showReportTitles: boolean;
        private _showReportSummaries;
        showReportSummaries: boolean;
        private _showPageHeaders;
        showPageHeaders: boolean;
        private _showPageFooters;
        showPageFooters: boolean;
        private _showGroupHeaders;
        showGroupHeaders: boolean;
        private _showGroupFooters;
        showGroupFooters: boolean;
        private _showHeaders;
        showHeaders: boolean;
        private _showDatas;
        showDatas: boolean;
        private _showFooters;
        showFooters: boolean;
        private _showBorders;
        showBorders: boolean;
        private readonly colorFactor;
        private _maxNestedLevel;
        maxNestedLevel: number;
        private _nestedFactor;
        nestedFactor: StiNestedFactor;
        createStyles(collectionName: string, baseColor: Color): StiBaseStyle[];
        private createStyles1(name, showBorders, font, headerBrush1, headerForeBrush, border, simpleCompTypes, placement, placementNestedLevel, operation, styles);
        private createStyles2(name, font, brush, textBrush, border, placement, placementNestedLevel, placementNestedLevelOperation, componentType, showBorders);
        private createStyle(name, font, brush, textBrush, border, placement, placementNestedLevel, placementNesterLevelOperation, componentType);
        private getStyleName(baseName);
        constructor(report: StiReport);
    }
}
declare module Stimulsoft.Report.Styles {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBorderSides = Stimulsoft.Base.Drawing.StiBorderSides;
    /** This class contains method which helps convert component location to its border sides. */
    class StiStylesHelper {
        static getBorderSidesFromLocation(component: StiComponent): StiBorderSides;
    }
}
declare module Stimulsoft.Report.Units {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiInchesUnit extends StiUnit {
        readonly rulerStep: number;
        readonly factor: number;
        readonly shortName: string;
        readonly name: string;
        convertToHInches(rect: RectangleD): RectangleD;
        convertToHInches(size: SizeD): SizeD;
        convertToHInches(value: number): number;
        convertFromHInches(rect: RectangleD): RectangleD;
        convertFromHInches(size: SizeD): SizeD;
        convertFromHInches(value: number): number;
    }
}
declare module Stimulsoft.Report {
    var IStiIgnoryStyle: string;
    interface IStiIgnoryStyle {
    }
}
declare module Stimulsoft.Report {
    var IStiInherited: string;
    interface IStiInherited {
        inherited: boolean;
    }
}
declare module Stimulsoft.Report {
    var IStiName: string;
    interface IStiName {
        name: string;
    }
}
declare module Stimulsoft.Report {
    var IStiStateSaveRestore: string;
    interface IStiStateSaveRestore {
        saveState(stateName: string): any;
        restoreState(stateName: string): any;
        clearAllStates(): any;
    }
}
declare module Stimulsoft.Report {
    class StiCells {
        clear(): void;
        private getRow(y);
        private rows;
        gett(x: number, y: number): number;
        distX: number;
        distY: number;
        setCell(x: number, y: number, value: number): void;
        private report;
        constructor(report: StiReport);
    }
}
declare module Stimulsoft.Report {
    import StiConditionsCollection = Stimulsoft.Report.Components.StiConditionsCollection;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiConditionsHelper {
        static getConditions(comps: StiComponentsCollection, REFglobalConditions?: any): StiConditionsCollection;
        static setConditions(comps: StiComponentsCollection, conditions: StiConditionsCollection, globalConditions: Hashtable): void;
        private static setConditionAllComponents(condition, comps);
    }
}
declare module Stimulsoft.Report {
    class StiDpiHelper {
        private static LOGPIXELSX;
        private static LOGPIXELSY;
        private static _deviceCapsDpi;
        private static _graphicsDpi;
        private static _graphicsRichTextDpi;
        static readonly deviceCapsDpi: number;
        static readonly graphicsDpi: number;
        static readonly graphicsRichTextDpi: number;
        private static getDpi();
        private static getRegistryValue();
        static readonly deviceCapsScale: number;
        static readonly graphicsScale: number;
        static readonly graphicsRichTextScale: number;
        static readonly needDeviceCapsScale: boolean;
        static readonly needGraphicsScale: boolean;
        static readonly needGraphicsRichTextScale: boolean;
    }
}
declare module Stimulsoft.Report {
    class StiEditableItem {
        private _pageIndex;
        pageIndex: number;
        private _position;
        position: number;
        private _componentName;
        componentName: string;
        private _textValue;
        textValue: string;
        constructor(pageIndex: number, position: number, componentName: string, textValue: string);
    }
    class StiEditableItemsContainer {
        private _items;
        readonly items: Array<any>;
    }
}
declare module Stimulsoft.Report {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImageCache {
        imageStore: Array<Image>;
        imagePackedStore: Array<number[]>;
        imageMaskStore: Array<number[]>;
        imageIndex: Array<number>;
        imageFormatStore: Array<ImageFormat>;
        private imageHashTable;
        private _useImageComparer;
        private _useImageCompression;
        private _useImageTransparency;
        private _imageSaveFormat;
        private _imageQuality;
        private static crcSeed;
        private static crcTable;
        clear(): void;
        addImageIntRaw(image: Image, imageFormat: Stimulsoft.System.Drawing.Imaging.ImageFormat): number;
        addImageInt(image: Image, imageFormat?: ImageFormat): number;
        constructor(useImageComparer: boolean, useImageCompression?: boolean, imageFormat?: ImageFormat, imageQuality?: number, useImageTransparency?: boolean);
    }
}
declare module Stimulsoft.Report {
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    class StiNullGlobalizationManager implements IStiGlobalizationManager {
        private _culture;
        culture: CultureInfo;
        getString(name: string): string;
        getObject(name: string): any;
        constructor();
    }
}
declare module Stimulsoft.Report {
    class StiNullValuesHelper {
        static isNull(report: StiReport, dataColumn: string): boolean;
    }
}
declare module StiOptions {
    import IStiGaugeStyleXF = Stimulsoft.Report.Gauge.IStiGaugeStyleXF;
    import StiColumnsSynchronizationMode = Stimulsoft.Report.Dictionary.StiColumnsSynchronizationMode;
    import StiWord2007RestrictEditing = Stimulsoft.Report.Export.StiWord2007RestrictEditing;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import PaperSizeCollection = Stimulsoft.System.Drawing.Printing.PrinterSettings.PaperSizeCollection;
    import StiTextQuality = Stimulsoft.Report.Components.StiTextQuality;
    import StiNamingRule = Stimulsoft.Report.StiNamingRule;
    import StiAutoSynchronizeMode = Stimulsoft.Report.Dictionary.StiAutoSynchronizeMode;
    import StiPropertiesProcessingType = Stimulsoft.Report.Dictionary.StiPropertiesProcessingType;
    import StiFieldsProcessingType = Stimulsoft.Report.Dictionary.StiFieldsProcessingType;
    import StiExcel2007RestrictEditing = Stimulsoft.Report.Export.StiExcel2007RestrictEditing;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiArabicDigitsType = Stimulsoft.Report.StiArabicDigitsType;
    import StiPdfAutoPrintMode = Stimulsoft.Report.Export.StiPdfAutoPrintMode;
    import IStiIndicatorRangeInfo = Stimulsoft.Report.Components.Gauge.IStiIndicatorRangeInfo;
    import IStiCustomValueBase = Stimulsoft.Report.Components.Gauge.IStiCustomValueBase;
    import IStiGaugeElement = Stimulsoft.Report.Components.Gauge.IStiGaugeElement;
    import IStiRangeBase = Stimulsoft.Report.Components.Gauge.IStiRangeBase;
    import IStiScaleBase = Stimulsoft.Report.Components.Gauge.IStiScaleBase;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class CrossTab2 {
        styleColors: Color[];
    }
    class Designer {
        static useComponentPlacementOptimization: boolean;
        static autoCorrectDataSourceName: boolean;
        static autoCorrectDataRelationName: boolean;
        static autoCorrectDataColumnName: boolean;
        static autoCorrectComponentName: boolean;
        static autoCorrectReportName: boolean;
        static autoLargeHeight: boolean;
        static sortDictionaryByAliases: boolean;
        static Editors: {
            allowConnectToDataInGallery: boolean;
        };
        private static _styles;
        static readonly styles: Stimulsoft.Report.Styles.StiStylesCollection;
        static CrossTab: CrossTab2;
    }
    class Image {
        /** Gets or sets absolute path which will be used in combination with path from File property of image component. */
        absolutePathOfImages: string;
        /** Gets or sets a value forcing render RichText components in other application domain. */
        useImageCloning: boolean;
    }
    class Watemark {
        allowExpression: boolean;
    }
    class CrossTab {
        defaultWidth: number;
        defaultHeight: number;
    }
    class Globalization {
        allowUseText: boolean;
        allowUseTag: boolean;
        allowUseToolTip: boolean;
        allowUseHyperlink: boolean;
        allowUseVariableAlias: boolean;
    }
    class Engine {
        /** A class which controls of settings of the report engine. */
        static Image: Image;
        static Watermark: Watemark;
        static printIfDetailEmptyDefaultValue: boolean;
        static fullTrust: boolean;
        static allowUseResetMethodInBusinessObject: boolean;
        static allowResetValuesAtComponent: boolean;
        /**
         * If the property is set to true, the report generator will use the PrintOn property when rendering a report.
         * Using this mode is not recommended because of problems with page numbers.
         * If the property is set to false, then the property will be processed after rendering a report.
         */
        static useAdvancedPrint: boolean;
        /** The default value for the TextQuality property. */
        static defaultTextQualityMode: StiTextQuality;
        /** If the value is set to true, the names of the new components are generated as localized regardless the settings of the report designer. */
        static forceGenerationLocalizedName: boolean;
        /** If the property is set to true, the report generator will use the PrintOn property when rendering a report.
            Using this mode is not recommended because of problems with page numbers.
            If the property is set to false, then the property will be processed after rendering a report. */
        static useAdvancedPrintOnEngine: boolean;
        /** If the value is set to true, the names of the new components are generated as not localized regardless the settings of the report designer. */
        static forceGenerationNonLocalizedName: boolean;
        static forceNewPageForExtraColumns: boolean;
        static useRoundForToCurrencyWordsFunctions: boolean;
        static forceNewPageInSubReports: boolean;
        static useTemplateForPagePrintEvents: boolean;
        /** Gets or sets a value which controls of naming of new components in the report. */
        static namingRule: StiNamingRule;
        /** Gets or sets a value which indicates whether use the CheckSize method for Continued containers*/
        static useCheckSizeForContinuedContainers: boolean;
        /** Gets or sets a value, which indicates that if data are absent then controls of the data emulation. This value is used for report rendering in the designer without data. */
        static emulateData: boolean;
        static allowCacheForGetActualSize: boolean;
        static allowBreakContainerOptimization: boolean;
        static removeBottomBorderOfSplitContainer: boolean;
        static checkDockToContainerIfComponentDisabled: boolean;
        static usePrintOnAllPagesPropertyOfHeadersInSubreports: boolean;
        static useParentStylesOldMode: boolean;
        static useCollateOldMode: boolean;
        static dpiAware: boolean;
        static dockPageFooterToBottom: boolean;
        static defaultValueOfAllowApplyStyleProperty: boolean;
        static allowFixPieChartMarkerAlignment: boolean;
        static applyStylesInAutoSeries: boolean;
        static allowInvokeProcessChartEventForTemplateOfChart: boolean;
        static allowInteractionInChartWithComponents: boolean;
        static dontSaveDataSourceBeforeChartRendering: boolean;
        private static measureTrailingSpaces;
        static renderExternalSubReportsWithHelpOfUnlimitedHeightPages: boolean;
        static escapeQueryParameters: boolean;
        static optimizeDetailDataFiltering: boolean;
        static CrossTab: CrossTab;
        static printIfDetailEmptyNesting: boolean;
        static allowForceCanBreakForCrossTabPrintOnAllPages: boolean;
        static Globalization: Globalization;
        static reportResources: any;
        static filterDataInDataSourceBeforeSorting: boolean;
    }
    class Print {
        static customPaperSizes: PaperSizeCollection;
        static allowUsePaperSizesFromPrinterSettings: boolean;
    }
    class BusinessObjects {
        static allowUseDataColumn: boolean;
        static allowUseFields: boolean;
        static allowUseProperties: boolean;
        static propertiesProcessingType: StiPropertiesProcessingType;
        static fieldsProcessingType: StiFieldsProcessingType;
        columnsSynchronizationMode: StiColumnsSynchronizationMode;
    }
    class Dictionary {
        static BusinessObjects: BusinessObjects;
        /** Gets or sets a value indicating that instead of a database name an alias will be shown. */
        static showOnlyAliasForDatabase: boolean;
        /** Gets or sets a value indicating that instead of a data name an alias will be shown. */
        static showOnlyAliasForData: boolean;
        /** Gets or sets a value indicating that instead of a DataColumn name an alias will be shown. */
        static showOnlyAliasForDataColumn: boolean;
        /** Gets or sets a value indicating that instead of a DataRelation name an alias will be shown. */
        static showOnlyAliasForDataRelation: boolean;
        static hideRelationExceptions: boolean;
        static autoSynchronize: StiAutoSynchronizeMode;
        static useAdvancedDataSearch: boolean;
        static showOnlyAliasForComponents: boolean;
        static showOnlyAliasForDataSource: boolean;
        static allowRestConnections: boolean;
        static allowConnectToFirstTableForEmptyDataSource: boolean;
        static useNullableDateTime: boolean;
        static useNullableTimeSpan: boolean;
        static columnsSynchronizationMode: StiColumnsSynchronizationMode;
        static showOnlyAliasForResource: boolean;
    }
    class Services {
        private static _components;
        static readonly components: Stimulsoft.System.Type[];
        private static _databases;
        static readonly databases: Stimulsoft.Report.Dictionary.StiDatabase[];
        private static _dataAdapters;
        static readonly dataAdapters: Stimulsoft.Report.Dictionary.StiDataAdapterService[];
        private static _dataSource;
        static readonly dataSource: Stimulsoft.Report.Dictionary.StiDataSource[];
        private static _formats;
        static readonly formats: Stimulsoft.Report.Components.TextFormats.StiFormatService[];
        private static _styles;
        static readonly styles: Stimulsoft.Report.Styles.StiBaseStyle[];
        private static _chartAreas;
        static readonly chartAreas: Stimulsoft.Report.Chart.IStiArea[];
        private static _chartSeries;
        static readonly chartSeries: Stimulsoft.Report.Chart.IStiSeries[];
        private static _chartTrendLines;
        static readonly chartTrendLines: Stimulsoft.Report.Chart.IStiTrendLine[];
        private static _chartSerieLabels;
        static readonly chartSerieLabels: Stimulsoft.Report.Chart.IStiSeriesLabels[];
        private static _chartStyles;
        static readonly chartStyles: Stimulsoft.Report.Chart.IStiChartStyle[];
        private static _shapes;
        static readonly shapes: Stimulsoft.Report.Components.StiShapeTypeService[];
        private static _barCodes;
        static readonly barCodes: Stimulsoft.Report.BarCodes.StiBarCodeTypeService[];
        private static _indicatorRanges;
        static readonly indicatorRanges: IStiIndicatorRangeInfo[];
        private static _customValues;
        static readonly customValues: IStiCustomValueBase[];
        private static _gaugeElements;
        static readonly gaugeElements: IStiGaugeElement[];
        private static _ranges;
        static readonly ranges: IStiRangeBase[];
        private static _gaugeScales;
        static readonly gaugeScales: IStiScaleBase[];
        private static _gaugeStyles;
        static readonly gaugeStyles: IStiGaugeStyleXF[];
        private static _mapStyles;
        static readonly mapStyles: Stimulsoft.Report.Maps.StiMapStyleFX[];
    }
    class ExportWord {
        divideSegmentPages: boolean;
        allowImageComparer: boolean;
        removeEmptySpaceAtBottom: boolean;
        spaceBetweenCharacters: number;
        lineHeightExactly: boolean;
        lineHeightExactlyForPHFMode: boolean;
        forceLineHeight: boolean;
        rightMarginCorrection: number;
        bottomMarginCorrection: number;
        renderRichTextAsImage: boolean;
        renderHtmlTagsAsImage: boolean;
        allowCorrectFontSize11Problem: boolean;
        normalStyleDefaultFontSize: number;
        lineSpacing: number;
        divideBigCells: boolean;
        restrictEditing: StiWord2007RestrictEditing;
    }
    class ExportHtml {
        convertDigitsToArabic: boolean;
        arabicDigitsType: Stimulsoft.Report.StiArabicDigitsType;
        allowImageComparer: boolean;
        forceWysiwygWordwrap: boolean;
        replaceSpecialCharacters: boolean;
        useImageResolution: boolean;
        useWordWrapBreakWordMode: boolean;
        useStrictTableCellSize: boolean;
        forceIE6Compatibility: boolean;
        allowStrippedImages: boolean;
        removeEmptySpaceAtBottom: boolean;
        useExtendedStyle: boolean;
        printLayoutOptimization: boolean;
        useComponentStyleName: boolean;
    }
    class ExportExcel {
        AllowExportDateTime: boolean;
        ColumnsRightToLeft: boolean;
        ShowGridLines: boolean;
        MaximumSheetHeight: number;
        RemoveEmptySpaceAtBottom: boolean;
        DivideBigCells: boolean;
        UseImageResolution: boolean;
        TrimTrailingSpaces: boolean;
        AllowExportFootersInDataOnlyMode: boolean;
        AllowImageComparer: boolean;
        AllowFreezePanes: boolean;
        RenderHtmlTagsAsImage: boolean;
        RestrictEditing: StiExcel2007RestrictEditing;
        FitToOnePageWide: boolean;
    }
    class ExportPdf {
        divideSegmentPages: boolean;
        convertDigitsToArabic: boolean;
        arabicDigitsType: StiArabicDigitsType;
        reduceFontFileSize: boolean;
        useEditableFieldName: boolean;
        useEditableFieldAlias: boolean;
        useEditableFieldTag: boolean;
        allowImageComparer: boolean;
        allowImageTransparency: boolean;
        allowInheritedPageResources: boolean;
        allowExtGState: boolean;
        private _creatorString;
        creatorString: string;
        keywordsString: string;
        defaultCoordinatesPrecision: Number;
        defaultAutoPrintMode: StiPdfAutoPrintMode;
        useAlternativeFontNames: boolean;
        private static _alternativeFontNames;
        alternativeFontNames: Hashtable;
    }
    class CheckBoxReplacementForExcelValue_ {
        Font: Font;
        HorAlignment: StiTextHorAlignment;
        VertAlignment: StiVertAlignment;
    }
    class Export {
        static Word: ExportWord;
        static Html: ExportHtml;
        static Excel: ExportExcel;
        static Pdf: ExportPdf;
        static CheckBoxReplacementForExcelValue: CheckBoxReplacementForExcelValue_;
        static optimizeDataOnlyMode: boolean;
        static checkBoxTextForTrue: string;
        static checkBoxTextForFalse: string;
    }
    class WebServer {
        static url: string;
        static timeout: number;
    }
}
declare module Stimulsoft.Report {
    class StiOptionsFontHelperAttribute {
        private _index;
        readonly index: number;
        constructor(index: number);
    }
}
declare module Stimulsoft.Report {
    import StiExportSettings = Stimulsoft.Report.Export.StiExportSettings;
    import StiExportService = Stimulsoft.Report.Export.StiExportService;
    import StiExportEventArgs = Stimulsoft.Report.Events.StiExportEventArgs;
    import StiPrintedEvent = Stimulsoft.Report.Events.StiPrintedEvent;
    import StiPrintingEvent = Stimulsoft.Report.Events.StiPrintingEvent;
    import StiExportedEvent = Stimulsoft.Report.Events.StiExportedEvent;
    import StiEndRenderEvent = Stimulsoft.Report.Events.StiEndRenderEvent;
    import StiRenderingEvent = Stimulsoft.Report.Events.StiRenderingEvent;
    import StiBeginRenderEvent = Stimulsoft.Report.Events.StiBeginRenderEvent;
    import StiExportingEvent = Stimulsoft.Report.Events.StiExportingEvent;
    import StiReportCacheProcessingEvent = Stimulsoft.Report.Events.StiReportCacheProcessingEvent;
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiGetSubReportEventArgs = Stimulsoft.Report.Events.StiGetSubReportEventArgs;
    import StiHtmlExportMode = Stimulsoft.Report.Export.StiHtmlExportMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiDialogInfo = Stimulsoft.Report.Dictionary.StiDialogInfo;
    import StiDataCollection = Stimulsoft.Report.Dictionary.StiDataCollection;
    import StiDictionary = Stimulsoft.Report.Dictionary.StiDictionary;
    import StiDataSourcesCollection = Stimulsoft.Report.Dictionary.StiDataSourcesCollection;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    import IStiUnitConvert = Stimulsoft.Report.Components.IStiUnitConvert;
    import StiEngine = Stimulsoft.Report.Engine.StiEngine;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiBookmark = Stimulsoft.Report.Components.StiBookmark;
    import StiStylesCollection = Stimulsoft.Report.Styles.StiStylesCollection;
    import StiAggregateFunctionService = Stimulsoft.Report.Dictionary.StiAggregateFunctionService;
    import Type = Stimulsoft.System.Type;
    import DateTime = Stimulsoft.System.DateTime;
    import StiBusinessObjectData = Stimulsoft.Report.Dictionary.StiBusinessObjectData;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiDesignerInfo = Stimulsoft.Report.Design.StiDesignerInfo;
    import IStiMasterComponent = Stimulsoft.Report.Components.IStiMasterComponent;
    class StiJsonLoaderHelper {
        masterComponents: IStiMasterComponent[];
        dialogInfo: StiDialogInfo[];
        refNames: string[];
        clean(): void;
    }
    class StiReport implements IStiUnitConvert {
        implements(): string[];
        jsonLoaderHelper: StiJsonLoaderHelper;
        private static assignSignature(report, ident);
        private saveToJsonInternal(mode);
        private loadFromJsonInternal(text);
        private loadFromXmlInternal(xml);
        private isPackedFile(content);
        load(str: string): any;
        load(data: number[]): any;
        load(xml: XmlNode): any;
        load(json: Object): any;
        loadFile(filePath: string): void;
        loadPacked(str: string): any;
        loadPacked(data: number[]): any;
        loadPackedFile(filePath: string): void;
        loadEncryptedReport(reportStr: string, key: string): any;
        loadEncryptedReport(data: number[], key: string): any;
        loadEncryptedReportFile(filePath: string, key: string): void;
        loadDocument(str: string): any;
        loadDocument(data: number[]): any;
        loadDocument(obj: Object): any;
        loadDocumentFile(filePath: string): void;
        loadPackedDocument(str: string): any;
        loadPackedDocument(data: number[]): any;
        loadPackedDocumentFile(filePath: string): void;
        loadEncryptedDocument(reportStr: string, key: string): any;
        loadEncryptedDocument(data: number[], key: string): any;
        loadEncryptedDocumentFile(filePath: string, key: string): void;
        saveEncryptedReportToByteArray(key: string): number[];
        saveEncryptedReportToString(key: string): string;
        saveEncryptedReportFile(path: string, key: string): void;
        saveToJsonString(): string;
        saveFile(path: string): void;
        saveDocumentToJsonString(): string;
        saveDocumentFile(path: string): void;
        saveEncryptedDocumentToByteArray(key: string): number[];
        private _pageNumber;
        pageNumber: number;
        readonly pageNumberThrough: number;
        _totalPageCountValue: number;
        totalPageCount: number;
        readonly totalPageCountThrough: number;
        readonly pageNofM: string;
        readonly pageNofMThrough: string;
        private _pageNofMLocalizationString;
        pageNofMLocalizationString: string;
        private _line;
        line: number;
        private _groupLine;
        groupLine: number;
        readonly lineRoman: string;
        readonly lineABC: string;
        private _column;
        column: number;
        private _lineThrough;
        lineThrough: number;
        readonly date: DateTime;
        readonly today: DateTime;
        readonly time: DateTime;
        private _cacheAllData;
        cacheAllData: boolean;
        private _retrieveOnlyUsedData;
        retrieveOnlyUsedData: boolean;
        private _reportCacheMode;
        reportCacheMode: StiReportCacheMode;
        readonly isFirstPage: boolean;
        readonly isLastPage: boolean;
        readonly isFirstPageThrough: boolean;
        readonly isLastPageThrough: boolean;
        readonly isFirstPass: boolean;
        readonly isSecondPass: boolean;
        private _currentPage;
        currentPage: number;
        private _currentPrintPage;
        currentPrintPage: number;
        private _pageCopyNumber;
        pageCopyNumber: number;
        private _businessObjectsStore;
        readonly businessObjectsStore: Array<StiBusinessObjectData>;
        private _variables;
        variables: Hashtable;
        getVariable(name: string, onlyVariable?: boolean): any;
        setVariable(name: string, value: Object, onlyVariable?: boolean): void;
        private _aggregateFunctions;
        aggregateFunctions: StiAggregateFunctionService[];
        private _dictionary;
        dictionary: StiDictionary;
        readonly dataSources: StiDataSourcesCollection;
        readonly dataStore: StiDataCollection;
        regData(name: string, alias: string, data: any): void;
        regBusinessObject2(category: string, name: string, alias: string, value: Object): void;
        regBusinessObject(businessObjects: StiBusinessObjectData[]): void;
        private storeBusinessObjectWithCheckExistingData(businessObject);
        private _script;
        script: string;
        scriptNew(): void;
        onBeginProcessData: Function;
        invokeBeginProcessData(args: any, callback: Function): any;
        onEndProcessData: Function;
        invokeEndProcessData(args: any): any;
        invokeRefreshPreview(): void;
        invokeRefreshViewer(): void;
        invokeClick(sender: Object, e: EventArgs): void;
        invokeDoubleClick(sender: Object, e: EventArgs): void;
        invokeGotoComp(e: StiGotoCompEventArgs): void;
        invokePaint(sender: Object, e: EventArgs): void;
        invokeBeginRender(): void;
        beginRenderEvent: StiBeginRenderEvent;
        invokeRendering(): void;
        renderingEvent: StiRenderingEvent;
        invokeEndRender(): void;
        endRenderEvent: StiEndRenderEvent;
        invokeStatusChanged(): void;
        protected onExporting(e: StiExportEventArgs): void;
        exportingEvent: StiExportingEvent;
        invokeExporting(exportFormat: StiExportFormat): void;
        protected onExported(e: StiExportEventArgs): void;
        exportedEvent: StiExportedEvent;
        invokeExported(exportFormat: StiExportFormat): void;
        protected onPrinting(e: EventArgs): void;
        printingEvent: StiPrintingEvent;
        invokePrinting(): void;
        protected onPrinted(e: EventArgs): void;
        printedEvent: StiPrintedEvent;
        invokePrinted(): void;
        onGetSubReport: Function;
        invokeGetSubReport(args: StiGetSubReportEventArgs): void;
        invokeReportCacheProcessing(): void;
        reportCacheProcessingEvent: StiReportCacheProcessingEvent;
        unit: StiUnit;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        static changeType(value: Object, conversionType: Type, convertNulls?: boolean): Object;
        applyStyleCollection(collectionName: string): void;
        applyStyles(): void;
        getCurrentPage(): StiPage;
        static getReportVersion(): string;
        private updateReportVersion();
        writeToReportRenderingMessages(str: string): void;
        getComponentByName(componentName: string): StiComponent;
        toString2(obj: Object): string;
        checkExcelValue(sender: any, value: Object): Object;
        toString(sender: any, obj: Object, allowExcelCheck?: boolean): string;
        private generateReportGuid();
        addAnchor(value: any, component?: any): void;
        getAnchorPageNumber(value: any): number;
        getAnchorPageNumberThrough(value: any): number;
        private getAnchor(value);
        /** Returns a list of all components, including pages in the report. */
        getComponents(): StiComponentsCollection;
        getRenderedComponents(): StiComponentsCollection;
        getComponentsCount(): number;
        /** Renames a style with the specified name to a new name. */
        renameStyle(oldStylename: string, newStyleName: string): void;
        localizeReport(cultureName: string): void;
        private anchors;
        /** The master report for subreports. Do not use this field.**/
        subReportsMasterReport: StiReport;
        subReportsResetPageNumber: boolean;
        subReportsPrintOnPreviousPage: boolean;
        /** Internal use only. */
        indexName: number;
        containsTables: boolean;
        cachedTotals: Hashtable;
        cachedTotalsLocked: boolean;
        modifiedVariables: Hashtable;
        private _reportVersion;
        reportVersion: string;
        private _engine;
        engine: StiEngine;
        private _reportRenderingMessages;
        reportRenderingMessages: string[];
        private _interactionCollapsingStates;
        interactionCollapsingStates: any;
        private _subReports;
        subReports: StiReportsCollection;
        private _reportGuid;
        reportGuid: string;
        private _imageCachePath;
        /** Gets path to the report image cache path. Path can't be changed. */
        imageCachePath: string;
        private _parentReport;
        parentReport: StiReport;
        private _globalizationManager;
        globalizationManager: IStiGlobalizationManager;
        private _pages;
        readonly pages: StiPagesCollection;
        private _renderedPages;
        renderedPages: StiPagesCollection;
        private _info;
        info: StiDesignerInfo;
        bookmarkValue: StiBookmark;
        bookmark: StiBookmark;
        private _manualBookmark;
        manualBookmark: StiBookmark;
        private _totals;
        totals: Hashtable;
        private _cells;
        readonly cells: StiCells;
        private _password;
        password: string;
        private _dataBandsUsedInPageTotals;
        dataBandsUsedInPageTotals: string[];
        private _listOfUsedData;
        listOfUsedData: string[];
        private _reportPass;
        reportPass: StiReportPass;
        private _isRendered;
        isRendered: boolean;
        private _isRendering;
        isRendering: boolean;
        private _isModified;
        isModified: boolean;
        private _isStopped;
        isStopped: boolean;
        private _isExporting;
        isExporting: boolean;
        private _isSerializing;
        isSerializing: boolean;
        private _isPageDesigner;
        isPageDesigner: boolean;
        private isPrintingValue;
        isPrinting: boolean;
        readonly isDesigning: boolean;
        private _isPreviewDialogs;
        isPreviewDialogs: boolean;
        private _isDocument;
        isDocument: boolean;
        private _isInteractionRendering;
        isInteractionRendering: boolean;
        private _reportName;
        reportName: string;
        private _reportAlias;
        reportAlias: string;
        private _reportAuthor;
        reportAuthor: string;
        private _reportDescription;
        reportDescription: string;
        private _reportCreated;
        reportCreated: DateTime;
        private _reportChanged;
        reportChanged: DateTime;
        private _styles;
        readonly styles: StiStylesCollection;
        private _numberOfPass;
        /** Gets or sets the number of passes which the report generator makes while report rendering.*/
        numberOfPass: StiNumberOfPass;
        private _calculationMode;
        calculationMode: StiCalculationMode;
        private _reportUnit;
        reportUnit: StiReportUnitType;
        private _stopBeforePage;
        stopBeforePage: number;
        private _collate;
        collate: number;
        private _globalizationStrings;
        readonly globalizationStrings: StiGlobalizationContainerCollection;
        private _autoLocalizeReportOnRun;
        autoLocalizeReportOnRun: boolean;
        private _requestParameters;
        requestParameters: boolean;
        private _cacheTotals;
        cacheTotals: boolean;
        private _culture;
        culture: string;
        private _refreshTime;
        refreshTime: number;
        private _compiledReport;
        compiledReport: StiReport;
        resetAggregateFunctions(): void;
        licenseKey: string;
        constructor();
        isAsyncMode: boolean;
        renderAsync(onRender: Function, showProgress?: boolean, fromPage?: number, toPage?: number): void;
        render(showProgress?: boolean, fromPage?: number, toPage?: number): void;
        private storedCulture;
        private renderReport(renderState, before?, after?);
        print(pagesRange?: StiPagesRange, exportMode?: StiHtmlExportMode): void;
        printToPdf(pagesRange?: StiPagesRange): void;
        private _reportFile;
        reportFile: string;
        exportDocumentAsync(onExport: Function, exportFormat: StiExportFormat, exportService?: StiExportService, settings?: StiExportSettings): void;
        exportDocument(exportFormat: StiExportFormat, exportService?: StiExportService, settings?: StiExportSettings, onExport?: Function): string | number[];
    }
}
declare module Stimulsoft.Report {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiReportsCollection extends CollectionBase<StiReport> {
        add(report: StiReport, resetPageNumber?: boolean, printOnPreviousPage?: boolean): void;
        getByIndex(index: number): StiReport;
        setByIndex(index: number, value: StiReport): void;
        private owner;
        constructor(owner: StiReport);
    }
}
declare module Stimulsoft.Report {
    import PaperKind = Stimulsoft.System.Drawing.Printing.PaperKind;
    import StiPageOrientation = Stimulsoft.Report.Components.StiPageOrientation;
    import StiMargins = Stimulsoft.Report.Components.StiMargins;
    import StiResizeReportOptions = Stimulsoft.Report.StiResizeReportOptions;
    class StiResizeReportHelper {
        private static setPageParameters(page, orientation, paperSize, margins, pageWidth, pageHeight, options);
        static resizeReport(report: StiReport, orientation: StiPageOrientation, paperSize: PaperKind, margins: StiMargins, pageWidth: number, pageHeight: number, options: StiResizeReportOptions, indexOfRenderedPage?: number): void;
    }
}
declare module Stimulsoft.Report {
    import StiSimpleText = Stimulsoft.Report.Components.StiSimpleText;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiRuntimeVariables {
        clone(): StiRuntimeVariables;
        page: StiPage;
        textBox: StiSimpleText;
        line: number;
        column: number;
        lineThrough: number;
        dataSourcesPosition: Hashtable;
        private _pageIndex;
        pageIndex: number;
        private _currentPrintPage;
        currentPrintPage: number;
        setVariables(report: StiReport): void;
        constructor(report: StiReport);
    }
}
declare module Stimulsoft.Report {
    class StiStatesManager {
        private static ValueBoolFalse;
        private static ValueBoolTrue;
        private states;
        push(stateName: string, obj: Object, property: string, value: any): void;
        pushBool(stateName: string, obj: Object, property: string, value: boolean): void;
        pushInt(stateName: string, obj: Object, property: string, value: number): void;
        pushInt64(stateName: string, obj: Object, property: string, value: number): void;
        pushFloat(stateName: string, obj: Object, property: string, value: number): void;
        pushDouble(stateName: string, obj: Object, property: string, value: number): void;
        pushDecimal(stateName: string, obj: Object, property: string, value: number): void;
        pushRange(stateName: string, obj: Object, property: string, value: Range): void;
        pop(stateName: string, obj: Object, property: string): any;
        popBool(stateName: string, obj: Object, property: string): boolean;
        popInt(stateName: string, obj: Object, property: string): number;
        popInt64(stateName: string, obj: Object, property: string): number;
        popDouble(stateName: string, obj: Object, property: string): number;
        popFloat(stateName: string, obj: Object, property: string): number;
        popDecimal(stateName: string, obj: Object, property: string): number;
        popRange(stateName: string, obj: Object, property: string): Range;
        isExist(stateName: string, obj: Object): boolean;
        clear(): void;
    }
}
declare module Stimulsoft.Report {
    class StiSystemVariableLocHelper {
        static getPageNofM(report: StiReport): string;
        static getPageNofMThrough(report: StiReport): string;
        static getPageNofMIdent(report: StiReport): string;
        private static getIdent(culture);
        private static locs;
    }
}
declare module Stimulsoft.Report {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiText = Stimulsoft.Report.Components.StiText;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiFitTextInfo {
        hashText: Hashtable;
        hashComponent: Hashtable;
        private hashFontString;
        getFontString(font: Font): string;
        getFontSizeObject(textBox: StiText, rect: RectangleD, text: string, REFfontSize?: any, REFhashSt?: any): Object;
        clear(): void;
    }
    class StiViewerFitTextHelper {
        private static hashes;
        private static _enabled;
        static enabled: boolean;
        static addReport(report: StiReport): void;
        static removeReport(report: StiReport): void;
        static clearReportInfo(report: StiReport): void;
        static getReportInfo(report: StiReport): StiFitTextInfo;
        static clear(): void;
    }
}
declare module Stimulsoft.Report {
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import DateTime = Stimulsoft.System.DateTime;
    class Totals {
        static getMethod(report: StiReport, name: string): any;
        private static calculate(functionn, data, report, name, allLevels?, onlyChilds?, isPageTotal?);
        private static calculate1(functionn, data, report, name, allLevels, onlyChilds, isPageTotal);
        private static calcItem(calcData);
        private static calculateByCondition(functionn, data, report, name, filterCondition, value1, value2, allLevels, onlyChilds);
        private static compareValue(value, filterCondition, value1, value2);
        private static calculateNullable(functionn, data, report, name, allLevels, onlyChilds);
        private static calculateRunning(functionn, data, report, name);
        static sum(data: Object, report: StiReport, name: string): number;
        static sumNullable(data: Object, report: StiReport, name: string): number;
        static sumDistinct(data: Object, report: StiReport, name: string, name2?: string): number;
        static cSum(data: Object, report: StiReport, name: string): number;
        static cSumRunning(data: Object, report: StiReport, name: string): number;
        static sumAllLevels(data: Object, report: StiReport, name: string): number;
        static sumAllLevelsByCondition(data: Object, report: StiReport, name: string, filterCondition: StiFilterCondition, value1: number, value2: number): number;
        static sumAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): number;
        static sumOnlyChilds(data: Object, report: StiReport, name: string): number;
        static sumTime(data: Object, report: StiReport, name: string): TimeSpan;
        static cSumTime(data: Object, report: StiReport, name: string): TimeSpan;
        static sumTimeAllLevels(data: Object, report: StiReport, name: string): TimeSpan;
        static sumTimeAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): TimeSpan;
        static sumTimeOnlyChilds(data: Object, report: StiReport, name: string): TimeSpan;
        static avg(data: Object, report: StiReport, name: string): number;
        static cAvg(data: Object, report: StiReport, name: string): number;
        static cAvgRunning(data: Object, report: StiReport, name: string): number;
        static avgAllLevels(data: Object, report: StiReport, name: string): number;
        static avgAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): number;
        static avgOnlyChilds(data: Object, report: StiReport, name: string): number;
        static avgDate(data: Object, report: StiReport, name: string): DateTime;
        static cAvgDate(data: Object, report: StiReport, name: string): DateTime;
        static avgDateAllLevels(data: Object, report: StiReport, name: string): DateTime;
        static avgDateAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): DateTime;
        static avgDateOnlyChilds(data: Object, report: StiReport, name: string): DateTime;
        static avgTime(data: Object, report: StiReport, name: string): TimeSpan;
        static cAvgTime(data: Object, report: StiReport, name: string): TimeSpan;
        static avgTimeAllLevels(data: Object, report: StiReport, name: string): TimeSpan;
        static avgTimeAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): TimeSpan;
        static avgTimeOnlyChilds(data: Object, report: StiReport, name: string): TimeSpan;
        static max(data: Object, report: StiReport, name: string): number;
        static cMax(data: Object, report: StiReport, name: string): number;
        static cMaxRunning(data: Object, report: StiReport, name: string): number;
        static maxAllLevels(data: Object, report: StiReport, name: string): number;
        static maxAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): number;
        static maxOnlyChilds(data: Object, report: StiReport, name: string): number;
        static min(data: Object, report: StiReport, name: string): number;
        static cMin(data: Object, report: StiReport, name: string): number;
        static cMinRunning(data: Object, report: StiReport, name: string): number;
        static minAllLevels(data: Object, report: StiReport, name: string): number;
        static minAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): number;
        static minOnlyChilds(data: Object, report: StiReport, name: string): number;
        static median(data: Object, report: StiReport, name: string): number;
        static cMedian(data: Object, report: StiReport, name: string): number;
        static cMedianRunning(data: Object, report: StiReport, name: string): number;
        static medianAllLevels(data: Object, report: StiReport, name: string): number;
        static medianAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): number;
        static medianOnlyChilds(data: Object, report: StiReport, name: string): number;
        static mode(data: Object, report: StiReport, name: string): number;
        static cMode(data: Object, report: StiReport, name: string): number;
        static cModeRunning(data: Object, report: StiReport, name: string): number;
        static modeAllLevels(data: Object, report: StiReport, name: string): number;
        static modeAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): number;
        static modeOnlyChilds(data: Object, report: StiReport, name: string): number;
        static first(data: Object, report: StiReport, name: string): Object;
        static cFirst(data: Object, report: StiReport, name: string): Object;
        static cFirstRunning(data: Object, report: StiReport, name: string): Object;
        static firstAllLevels(data: Object, report: StiReport, name: string): Object;
        static firstAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): Object;
        static firstOnlyChilds(data: Object, report: StiReport, name: string): Object;
        static last(data: Object, report: StiReport, name: string): Object;
        static cLast(data: Object, report: StiReport, name: string): Object;
        static cLastRunning(data: Object, report: StiReport, name: string): Object;
        static lastAllLevels(data: Object, report: StiReport, name: string): Object;
        static lastAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): Object;
        static lastOnlyChilds(data: Object, report: StiReport, name: string): Object;
        static count(data: Object, report?: StiReport, name?: string): number;
        static cCount(data: Object, report?: StiReport, name?: string): number;
        static cCountRunning(data: Object, report?: StiReport, name?: string): number;
        static countAllLevels(data: Object): number;
        static countAllLevelsOnlyChilds(data: Object): number;
        static countOnlyChilds(data: Object): number;
        static countDistinct(data: Object, report: StiReport, name: string): number;
        static cCountDistinct(data: Object, report: StiReport, name: string): number;
        static cCountDistinctRunning(data: Object, report: StiReport, name: string): number;
        static countDistinctAllLevels(data: Object, report: StiReport, name: string): number;
        static countDistinctAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): number;
        static countDistinctOnlyChilds(data: Object, report: StiReport, name: string): number;
        static minDate(data: Object, report: StiReport, name: string): DateTime;
        static cMinDate(data: Object, report: StiReport, name: string): DateTime;
        static minDateAllLevels(data: Object, report: StiReport, name: string): DateTime;
        static minDateAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): DateTime;
        static minDateOnlyChilds(data: Object, report: StiReport, name: string): DateTime;
        static minTime(data: Object, report: StiReport, name: string): TimeSpan;
        static cMinTime(data: Object, report: StiReport, name: string): TimeSpan;
        static minTimeAllLevels(data: Object, report: StiReport, name: string): TimeSpan;
        static minTimeAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): TimeSpan;
        static minTimeOnlyChilds(data: Object, report: StiReport, name: string): TimeSpan;
        static minStr(data: Object, report: StiReport, name: string): string;
        static cMinStr(data: Object, report: StiReport, name: string): string;
        static minStrAllLevels(data: Object, report: StiReport, name: string): string;
        static minStrAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): string;
        static minStrOnlyChilds(data: Object, report: StiReport, name: string): string;
        static maxDate(data: Object, report: StiReport, name: string): DateTime;
        static cMaxDate(data: Object, report: StiReport, name: string): DateTime;
        static maxDateAllLevels(data: Object, report: StiReport, name: string): DateTime;
        static maxDateAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): DateTime;
        static maxDateOnlyChilds(data: Object, report: StiReport, name: string): DateTime;
        static maxTime(data: Object, report: StiReport, name: string): TimeSpan;
        static cMaxTime(data: Object, report: StiReport, name: string): TimeSpan;
        static maxTimeAllLevels(data: Object, report: StiReport, name: string): TimeSpan;
        static maxTimeAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): TimeSpan;
        static maxTimeOnlyChilds(data: Object, report: StiReport, name: string): TimeSpan;
        static maxStr(data: Object, report: StiReport, name: string): string;
        static cMaxStr(data: Object, report: StiReport, name: string): string;
        static maxStrAllLevels(data: Object, report: StiReport, name: string): string;
        static maxStrAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): string;
        static maxStrOnlyChilds(data: Object, report: StiReport, name: string): string;
        static rank(data: Object, report: StiReport, name: string, dense?: boolean, sortOrder?: StiRankOrder): number;
        private static saveState(dataBand);
        private static restoreState(dataBand);
        private static storeCachedValue(data, report, storeId, result);
        private static getCachedValue(ffunction, data, report, name, allLevels, onlyChilds, isPageTotal, REFresult, REFstoreId);
    }
}

declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiFilterItem = Stimulsoft.Report.Components.StiFilterItem;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    class StiChartFilter implements IStiJsonReportObject, IStiChartFilter, ICloneable {
        private static implementsStiChartFilter;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(): StiChartFilter;
        readonly index: number;
        private _condition;
        condition: StiFilterCondition;
        private _dataType;
        dataType: StiFilterDataType;
        private _item;
        item: StiFilterItem;
        private _valueObj;
        value: string;
        toString(): string;
        filters: StiChartFiltersCollection;
        constructor(item?: StiFilterItem, dataType?: StiFilterDataType, condition?: StiFilterCondition, value?: string);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    import StiFilterItem = Stimulsoft.Report.Components.StiFilterItem;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiChartCondition extends StiChartFilter implements IStiChartCondition, IStiChartFilter {
        private static implementsStiChartCondition;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(): StiChartCondition;
        private _color;
        color: Color;
        conditions: StiChartConditionsCollection;
        constructor(color?: Color, item?: StiFilterItem, dataType?: StiFilterDataType, condition?: StiFilterCondition, value?: string);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiChartConditionsCollection extends CollectionBase<StiChartCondition> implements IStiJsonReportObject, ICloneable, IStiChartConditionsCollection {
        private static implementsStiChartConditionsCollection;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiChartConditionsCollection;
        add(condition: StiChartCondition): void;
        addRange(conditions: StiChartConditionsCollection): void;
        addRange2(conditions: StiChartCondition[]): void;
        contains(condition: StiChartCondition): boolean;
        indexOf(condition: StiChartCondition): number;
        insert(index: number, condition: StiChartCondition): void;
        remove(condition: StiChartCondition): void;
        getByIndex(index: number): StiChartCondition;
        setByIndex(index: number, value: StiChartCondition): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiNewAutoSeriesEventArgs = Stimulsoft.Report.Events.StiNewAutoSeriesEventArgs;
    import StiGetTitleEventArgs = Stimulsoft.Report.Events.StiGetTitleEventArgs;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiSeries extends StiService implements IStiJsonReportObject, ICloneable, IStiSeries, IStiJsonReportObject {
        private static implementsStiSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiSeries;
        baseTransform(context: Object, x: number, y: number, angle: number, dx: number, dy: number): void;
        readonly parent: StiComponent;
        readonly serviceName: string;
        readonly serviceCategory: string;
        readonly serviceType: Stimulsoft.System.Type;
        private _core;
        core: StiSeriesCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _format;
        format: string;
        private _sortBy;
        sortBy: StiSeriesSortType;
        private _sortDirection;
        sortDirection: StiSeriesSortDirection;
        private _showInLegend;
        showInLegend: boolean;
        showLabels: boolean;
        private _showSeriesLabels;
        showSeriesLabels: StiShowSeriesLabels;
        private _showShadow;
        showShadow: boolean;
        private _filterMode;
        filterMode: StiFilterMode;
        private _filters;
        filters: StiChartFiltersCollection;
        private _conditions;
        conditions: StiChartConditionsCollection;
        private _topN;
        topN: IStiSeriesTopN;
        private _yAxis;
        yAxis: StiSeriesYAxis;
        private _seriesLabels;
        seriesLabels: IStiSeriesLabels;
        private _trendLine;
        trendLine: IStiTrendLine;
        private _chart;
        chart: IStiChart;
        private _values;
        values: number[];
        private _valueDataColumn;
        valueDataColumn: string;
        valuesString: string;
        private _arguments;
        arguments: Object[];
        protected getArguments(): Object[];
        protected setArguments(value: Object[]): void;
        private _argumentDataColumn;
        argumentDataColumn: string;
        argumentsString: string;
        private _autoSeriesTitleDataColumn;
        autoSeriesTitleDataColumn: string;
        private _autoSeriesKeyDataColumn;
        autoSeriesKeyDataColumn: string;
        private _autoSeriesColorDataColumn;
        autoSeriesColorDataColumn: string;
        private _toolTips;
        toolTips: string[];
        private _toolTipDataColumn;
        toolTipDataColumn: string;
        toolTipsString: string;
        private _tags;
        tags: Object[];
        private _tagDataColumn;
        tagDataColumn: string;
        tagString: string;
        private _hyperlinks;
        hyperlinks: string[];
        private _hyperlinkDataColumn;
        hyperlinkDataColumn: string;
        hyperlinkString: string;
        private _drillDownEnabled;
        drillDownEnabled: boolean;
        private _drillDownReport;
        drillDownReport: string;
        drillDownPage: StiPage;
        private _drillDownPageGuid;
        drillDownPageGuid: string;
        private _allowSeries;
        allowSeries: boolean;
        private _allowSeriesElements;
        allowSeriesElements: boolean;
        coreTitle: string;
        private _interaction;
        interaction: IStiSeriesInteraction;
        processSeriesColors(pointIndex: number, seriesColor: Color): Color;
        processSeriesBrushes(pointIndex: number, seriesBrush: StiBrush): StiBrush;
        private getConditionResult(pointIndex, condition);
        toString(): string;
        static getNullableValuesFromString(series: StiSeries, list: string): number[];
        static getValuesFromString(list: string): number[];
        static getStringsFromString(list: string): string[];
        static getArgumentsFromString(list: string): Object[];
        createNew(): StiSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        newAutoSeries: Function;
        invokeNewAutoSeries(e: StiNewAutoSeriesEventArgs): void;
        getValue: Function;
        protected onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValues: Function;
        protected onGetListOfValues(e: StiGetValueEventArgs): void;
        invokeGetListOfValues(sender: StiComponent, e: StiGetValueEventArgs, series: StiSeries): void;
        getArgument: Function;
        protected onGetArgument(e: StiValueEventArgs): void;
        invokeGetArgument(sender: StiComponent, e: StiValueEventArgs): void;
        getListOfArguments: Function;
        protected onGetListOfArguments(e: StiGetValueEventArgs): void;
        invokeGetListOfArguments(sender: StiComponent, e: StiGetValueEventArgs): void;
        getTitle: Function;
        protected onGetTitle(e: StiGetTitleEventArgs): void;
        invokeGetTitle(sender: StiComponent, e: StiGetTitleEventArgs): void;
        getToolTip: Function;
        protected onGetToolTip(e: StiValueEventArgs): void;
        invokeGetToolTip(sender: Object, e: StiValueEventArgs): void;
        getListOfToolTips: Function;
        protected onGetListOfToolTips(e: StiGetValueEventArgs): void;
        invokeGetListOfToolTips(sender: StiComponent, e: StiGetValueEventArgs): void;
        getTag: Function;
        protected onGetTag(e: StiValueEventArgs): void;
        invokeGetTag(sender: Object, e: StiValueEventArgs): void;
        getListOfTags: Function;
        protected onGetListOfTags(e: StiGetValueEventArgs): void;
        invokeGetListOfTags(sender: StiComponent, e: StiGetValueEventArgs): void;
        getHyperlink: Function;
        protected onGetHyperlink(e: StiValueEventArgs): void;
        invokeGetHyperlink(sender: Object, e: StiValueEventArgs): void;
        getListOfHyperlinks: Function;
        protected onGetListOfHyperlinks(e: StiGetValueEventArgs): void;
        invokeGetListOfHyperlinks(sender: StiComponent, e: StiGetValueEventArgs): void;
        private valueObj;
        value: string;
        private _listOfValues;
        listOfValues: string;
        private _argument;
        argument: string;
        private _listOfArguments;
        listOfArguments: string;
        private _titleValue;
        titleValue: string;
        private _title;
        title: string;
        private _toolTip;
        toolTip: string;
        private _listOfToolTips;
        listOfToolTips: string;
        private _tag;
        tag: string;
        private _listOfTags;
        listOfTags: string;
        private _hyperlink;
        hyperlink: string;
        private _listOfHyperlinks;
        listOfHyperlinks: string;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBaseLineSeries extends StiSeries implements IStiJsonReportObject, IStiBaseLineSeries, ICloneable, IStiSeries, IStiAllowApplyColorNegative {
        private static implementsStiBaseLineSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiBaseLineSeries;
        private _showNulls;
        showNulls: boolean;
        showMarker: boolean;
        markerColor: Color;
        markerSize: number;
        markerType: StiMarkerType;
        private _marker;
        marker: IStiMarker;
        private _lineMarker;
        lineMarker: IStiLineMarker;
        private _lineColor;
        lineColor: Color;
        getLineColor(): Color;
        setLineColor(value: Color): void;
        private _lineStyle;
        lineStyle: StiPenStyle;
        private _lighting;
        lighting: boolean;
        private _lineWidth;
        lineWidth: number;
        private _labelsOffset;
        labelsOffset: number;
        private _lineColorNegative;
        lineColorNegative: Color;
        private _allowApplyColorNegative;
        allowApplyColorNegative: boolean;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiScatterSeries extends StiBaseLineSeries implements IStiJsonReportObject, IStiBaseLineSeries, IStiSeries, ICloneable, IStiScatterSeries, IStiAllowApplyColorNegative {
        private static implementsStiScatterSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        clone(): StiScatterSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        getLineColor(): Color;
        setLineColor(value: Color): void;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiScatterLineSeries extends StiScatterSeries implements IStiScatterLineSeries, IStiBaseLineSeries, IStiScatterSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        private static implementsStiScatterLineSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        clone(): StiScatterLineSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAreaCoreXF implements ICloneable, IStiApplyStyle, IStiAreaCoreXF {
        private static implementsStiAreaCoreXF;
        implements(): string[];
        clone(): StiAreaCoreXF;
        applyStyle(style: IStiChartStyle): void;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        protected prepareInfo(rect: RectangleD): void;
        checkInLabelsTypes(typeForCheck: Stimulsoft.System.Type): boolean;
        getSeries(): IStiSeries[];
        isAcceptableSeries(seriesType: Stimulsoft.System.Type): boolean;
        isAcceptableSeriesLabels(seriesLabelsType: Stimulsoft.System.Type): boolean;
        private _area;
        area: IStiArea;
        readonly localizedName: string;
        readonly seriesOrientation: StiChartSeriesOrientation;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisAreaCoreXF extends StiAreaCoreXF implements IStiAxisAreaCoreXF {
        private static implementsStiAxisAreaCoreXF;
        implements(): string[];
        applyStyle(style: IStiChartStyle): void;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        private calculateScrollValuesX(rect, axisArea);
        private calculateScrollValuesY(rect, axisArea);
        protected prepareInfo(rect: RectangleD): void;
        private renderSeries(context, rect, geom, seriesCollection);
        isAutoRangeXAxis(axis: IStiAxis): boolean;
        isAutoRangeYAxis(axis: IStiAxis): boolean;
        calculateMinimumAndMaximumXAxis(axis: IStiAxis): void;
        calculateMinimumAndMaximumYAxis(axis: IStiAxis): void;
        getArgumentLabel(line: StiStripLineXF, series: IStiSeries): string;
        switchOff(): void;
        private swap(REFvalue1, REFvalue2);
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        protected createStripLinesXAxis(axis: IStiAxis): void;
        protected createStripLinesYAxis(axis: IStiAxis, isDateTimeValues: boolean): void;
        protected checkStripLinesAndMaximumMinimumXAxis(axis: IStiAxis): void;
        protected checkStripLinesAndMaximumMinimumYAxis(axis: IStiAxis): void;
        private calculateStepX(axis, topPosition, bottomPosition);
        private calculateStepY(axis, topPosition, bottomPosition);
        private checkStartFromZeroYAxis(axis);
        calculatePositions(axis: IStiAxis, REFcollection: any, step: number): void;
        private calculateDivider(axis);
        private static rotateStripLines(axis);
        getDividerX(): number;
        getDividerY(): number;
        getDividerRightY(): number;
        valuesCount: number;
        readonly scrollDistanceX: number;
        readonly scrollDistanceY: number;
        private _scrollRangeX;
        readonly scrollRangeX: number;
        private _scrollRangeY;
        readonly scrollRangeY: number;
        private _scrollViewX;
        readonly scrollViewX: number;
        private _scrollViewY;
        readonly scrollViewY: number;
        private _blockScrollValueX;
        blockScrollValueX: boolean;
        private _blockScrollValueY;
        blockScrollValueY: boolean;
        private _scrollValueX;
        scrollValueX: number;
        private _scrollValueY;
        scrollValueY: number;
        private _scrollDpiX;
        readonly scrollDpiX: number;
        private _scrollDpiY;
        readonly scrollDpiY: number;
        private _scrollDragStartValue;
        scrollDragStartValue: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiClusteredColumnAreaCoreXF extends StiAxisAreaCoreXF {
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiScatterAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        private isArgumentDateTime;
        private isXAxisAutoRange(xAxis);
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        protected checkStripLinesAndMaximumMinimumXAxis(axis: IStiAxis): void;
        protected createStripLinesXAxis(axis: IStiAxis): void;
        protected createStripLinesYAxis(axis: IStiAxis, isDateTimeValues: boolean): void;
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiBubbleAreaCoreXF extends StiScatterAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiCandlestickAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        protected createStripLinesXAxis(axis: IStiAxis): void;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiClusteredBarAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly seriesOrientation: StiChartSeriesOrientation;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiAreaAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiLineAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiSplineAreaAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiSplineAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiSteppedAreaAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiSteppedLineAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieAreaCoreXF extends StiAreaCoreXF {
        valuesCount: number;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesCollection: IStiSeries[]): void;
        protected prepareInfo(rect: RectangleD): void;
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDoughnutAreaCoreXF extends StiPieAreaCoreXF {
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStackedBarAreaCoreXF extends StiClusteredBarAreaCoreXF {
        private prepareSeriesRange(seriesType);
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        readonly localizedName: string;
        readonly seriesOrientation: StiChartSeriesOrientation;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedBarAreaCoreXF extends StiStackedBarAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStackedColumnAreaCoreXF extends StiAxisAreaCoreXF {
        private prepareSeriesRange(seriesType);
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedColumnAreaCoreXF extends StiStackedColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedAreaAreaCoreXF extends StiFullStackedColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedLineAreaCoreXF extends StiFullStackedColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedSplineAreaAreaCoreXF extends StiFullStackedColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedSplineAreaCoreXF extends StiFullStackedColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiFunnelAreaCoreXF extends StiAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesCollection: IStiSeries[]): void;
        protected prepareInfo(rect: RectangleD): void;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiGanttAreaCoreXF extends StiClusteredBarAreaCoreXF {
        protected createStripLinesXAxis(axis: IStiAxis): void;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        readonly localizedName: string;
        readonly seriesOrientation: StiChartSeriesOrientation;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPictorialAreaCoreXF extends StiAreaCoreXF {
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiRadarAreaCoreXF extends StiAreaCoreXF {
        applyStyle(style: IStiChartStyle): void;
        valuesCount: number;
        points: PointD[];
        arguments: Object[];
        centerPoint: PointD;
        render(context: StiContext, areaRect: RectangleD): StiCellGeom;
        private static centerArea(rect);
        measureLabels(context: StiContext, rect: RectangleD): RectangleD;
        renderArguments(context: StiContext, geom: StiRadarAreaGeom, series: IStiSeries): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesCollection: IStiSeries[]): void;
        protected prepareInfo(rect: RectangleD): void;
        protected createStripLinesAxis(axis: IStiYRadarAxis, minimum: number, maximum: number): void;
        private calculateStep(axis, topPosition, bottomPosition);
        calculatePositions(axis: IStiYRadarAxis, REFcollection: any, step: number): void;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiRadarAreaAreaCoreXF extends StiRadarAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiRadarLineAreaCoreXF extends StiRadarAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiRadarPointAreaCoreXF extends StiRadarAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiRangeAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiRangeBarAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        protected createStripLinesXAxis(axis: IStiAxis): void;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiSplineRangeAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiSteppedRangeAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStackedAreaAreaCoreXF extends StiStackedColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStackedLineAreaCoreXF extends StiStackedColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStackedSplineAreaAreaCoreXF extends StiStackedColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStackedSplineAreaCoreXF extends StiStackedColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStockAreaCoreXF extends StiCandlestickAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTreemapAreaCoreXF extends StiAreaCoreXF {
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderSeries(context: StiContext, boxes: RectangleD[], boxRoot: RectangleD, geom: StiAreaGeom, seriesCollection: IStiSeries[]): void;
        private cutArea(container, area);
        squarify(data: number[], currentrow: number[], container: RectangleD, stack: RectangleD[]): RectangleD[];
        private improvesRatio(currentrow, nextnode, length);
        private calculateRatio(row, length);
        normalizeDataForArea(data: number[], area: number): number[];
        private getCoordinates(rootContainer, rowData);
        prepareInfo(rect: RectangleD): void;
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStripLineCalculatorXF {
        private static getInterval1(interval);
        static getInterval(minValue: number, maxValue: number, num: number): number;
        static getStripLines(minValue: number, maxValue: number, step: number, asDateTimeValue: boolean): StiStripLinesXF;
        private static getCountAfterComma(num);
        static getStripLinesLogScale(minValue: number, maxValue: number): StiStripLinesXF;
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStripLineXF implements IStiStripLineXF {
        private static implementsStiStripLineXF;
        implements(): string[];
        private _valueObject;
        valueObject: Object;
        private valueObj;
        value: number;
        constructor(valueObject: Object, value: number);
    }
}
declare module Stimulsoft.Report.Chart {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiStripLinesXF extends CollectionBase<StiStripLineXF> implements IStiStripLinesXF {
        private static implementsStiStripLinesXF;
        implements(): string[];
        add(valueObject: Object, value: number): void;
        add2(line: StiStripLineXF): void;
        addRange(lines: StiStripLineXF[]): void;
        contains(value: StiStripLineXF): boolean;
        indexOf(value: StiStripLineXF): number;
        insert(index: number, value: StiStripLineXF): void;
        remove(value: StiStripLineXF): void;
        getByindex(index: number): StiStripLineXF;
        setByIndex(index: number, value: StiStripLineXF): void;
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStripPositionXF implements IStiStripPositionXF {
        private static implementsStiStripPositionXF;
        implements(): string[];
        position: number;
        stripLine: StiStripLineXF;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisCoreXF implements ICloneable, IStiApplyStyle, IStiAxisCoreXF {
        private static implementsStiAxisCoreXF;
        implements(): string[];
        clone(): StiAxisCoreXF;
        private _isMouseOverDecreaseButton;
        isMouseOverDecreaseButton: boolean;
        private _isMouseOverIncreaseButton;
        isMouseOverIncreaseButton: boolean;
        private _isMouseOverTrackBar;
        isMouseOverTrackBar: boolean;
        applyStyle(style: IStiChartStyle): void;
        getStartFromZero(): boolean;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderView(context: StiContext, rect: RectangleD): StiCellGeom;
        calculateStripPositions(topPosition: number, bottomPosition: number): void;
        getTicksMaxLength(context: StiContext): number;
        getArrowHeight(context: StiContext): number;
        getLabelsSpaceAxis(context: StiContext): number;
        getLabelsTwoLinesDestination(context: StiContext): number;
        getFontGeom(context: StiContext): StiFontGeom;
        getTextAlignment(): StiHorAlignment;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        protected getAxisTitleSize(context: StiContext): SizeD;
        static defaultScrollBarSize: number;
        static defaultScrollBarSmallFactor: number;
        static defaultScrollBarFirstRecallTime: number;
        static defaultScrollBarOtherRecallTime: number;
        readonly ticksMaxLength: number;
        readonly arrowWidth: number;
        readonly arrowHeight: number;
        private _axis;
        axis: IStiAxis;
        info: StiAxisInfoXF;
        constructor(axis: IStiAxis);
    }
}
declare module Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisInfoXF implements ICloneable, IStiAxisInfoXF {
        private static implementsStiAxisInfoXF;
        implements(): string[];
        clone(): StiAxisInfoXF;
        dpi: number;
        step: number;
        readonly range: number;
        stripLines: StiStripLinesXF;
        stripPositions: number[];
        ticksCollection: StiStripPositionXF[];
        labelsCollection: StiStripPositionXF[];
        minimum: number;
        _maximum: number;
        maximum: number;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiAxisLabelInfoXF {
        clientRectangle: RectangleD;
        textPoint: PointD;
        angle: number;
        rotationMode: StiRotationMode;
        text: string;
        stripLine: StiStripLineXF;
    }
}
declare module Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisLabelsCoreXF implements IStiApplyStyle, ICloneable, IStiAxisLabelsCoreXF {
        private static implementsStiAxisLabelsCoreXF;
        implements(): string[];
        clone(): StiAxisLabelsCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private _labels;
        labels: IStiAxisLabels;
        constructor(labels: IStiAxisLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisTitleCoreXF implements IStiApplyStyle, ICloneable, IStiAxisTitleCoreXF {
        private static implementsStiAxisTitleCoreXF;
        implements(): string[];
        clone(): StiAxisTitleCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private _title;
        title: IStiAxisTitle;
        constructor(title: IStiAxisTitle);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiXAxisCoreXF extends StiAxisCoreXF {
        getStartFromZero(): boolean;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderView(context: StiContext, rect: RectangleD): StiCellGeom;
        renderScrollBar(context: StiContext, axisRect: RectangleD, axisGeom: StiXAxisViewGeom): void;
        renderCenter(context: StiContext, rect: RectangleD): StiCellGeom;
        renderCenterView(context: StiContext, rect: RectangleD): StiCellGeom;
        getLabelText(line: StiStripLineXF, series: IStiSeries): string;
        private readonly isLabelsAngleByWidth;
        private measureStripLines(context, rect);
        getCenterAxisRect(context: StiContext, rect: RectangleD, includeAxisArrow: boolean, includeLabelsHeight: boolean, isDrawing: boolean): RectangleD;
        getAxisRect(context: StiContext, rect: RectangleD, includeAxisArrow: boolean, includeLabelsWidth: boolean, isDrawing: boolean, includeScrollBar: boolean): RectangleD;
        private renderLabels(context, rect, geom);
        private renderTitle(context, axisRect, geom);
        private isArgumentDateTime1(positions);
        private isArgumentDateTime2(infos);
        readonly dock: StiXAxisDock;
        readonly isTopSide: boolean;
        readonly isBottomSide: boolean;
        constructor(axis: IStiAxis);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiXBottomAxisCoreXF extends StiXAxisCoreXF {
        readonly dock: StiXAxisDock;
        constructor(axis: IStiAxis);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiXTopAxisCoreXF extends StiXAxisCoreXF {
        readonly dock: StiXAxisDock;
        constructor(axis: IStiAxis);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiYAxisCoreXF extends StiAxisCoreXF {
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderView(context: StiContext, rect: RectangleD): StiCellGeom;
        renderScrollBar(context: StiContext, axisRect: RectangleD, axisGeom: StiYAxisViewGeom): void;
        renderCenter(context: StiContext, rect: RectangleD): StiCellGeom;
        renderCenterView(context: StiContext, rect: RectangleD): StiCellGeom;
        getLabelText(line: StiStripLineXF, series: IStiSeries): string;
        private measureStripLines(context, rect);
        getCenterAxisRect(context: StiContext, rect: RectangleD, includeAxisArrow: boolean, includeLabelsHeight: boolean, isDrawing: boolean): RectangleD;
        getAxisRect(context: StiContext, rect: RectangleD, includeAxisArrow: boolean, includeLabelsHeight: boolean, isDrawing: boolean, includeScrollBar: boolean): RectangleD;
        private renderLabels(context, rect, geom);
        private renderTitle(context, axisRect, geom);
        readonly dock: StiYAxisDock;
        readonly isLeftSide: boolean;
        readonly isRightSide: boolean;
        constructor(axis: IStiAxis);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiYLeftAxisCoreXF extends StiYAxisCoreXF {
        readonly dock: StiYAxisDock;
        constructor(axis: IStiAxis);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiYRightAxisCoreXF extends StiYAxisCoreXF {
        readonly dock: StiYAxisDock;
        getStartFromZero(): boolean;
        constructor(axis: IStiAxis);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import ICloneable = Stimulsoft.System.ICloneable;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiChartTitleCoreXF implements ICloneable, IStiApplyStyle, IStiChartTitleCoreXF {
        private static implementsStiChartTitleCoreXF;
        implements(): string[];
        clone(): StiChartTitleCoreXF;
        applyStyle(style: IStiChartStyle): void;
        render(context: StiContext, chartTitle: IStiChartTitle, rect: RectangleD): StiCellGeom;
        private _chartTitle;
        chartTitle: IStiChartTitle;
        constructor(chartTitle: IStiChartTitle);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiConstantLinesCoreXF implements IStiApplyStyle, ICloneable, IStiConstantLinesCoreXF {
        private static implementsStiConstantLinesCoreXF;
        implements(): string[];
        clone(): Object;
        applyStyle(style: IStiChartStyle): void;
        renderXConstantLines(context: StiContext, geom: StiAxisAreaGeom, rect: RectangleD): void;
        renderYConstantLines(context: StiContext, geom: StiAxisAreaGeom, rect: RectangleD): void;
        render(context: StiContext, geom: StiAxisAreaGeom, rect: RectangleD): void;
        private _constantLines;
        constantLines: IStiConstantLines;
        constructor(constantLines: IStiConstantLines);
    }
}
declare module Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiGridLinesCoreXF implements IStiApplyStyle, ICloneable, IStiGridLinesCoreXF {
        private static implementsStiGridLinesCoreXF;
        implements(): string[];
        clone(): StiGridLinesCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private _gridLines;
        gridLines: IStiGridLines;
        constructor(gridLines: IStiGridLines);
    }
}
declare module Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarGridLinesCoreXF implements IStiApplyStyle, ICloneable, IStiRadarGridLinesCoreXF {
        private static implementsStiRadarGridLinesCoreXF;
        implements(): string[];
        clone(): StiRadarGridLinesCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private _gridLines;
        gridLines: IStiRadarGridLines;
        constructor(gridLines: IStiRadarGridLines);
    }
}
declare module Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiInterlacingCoreXF implements IStiApplyStyle, ICloneable, IStiInterlacingCoreXF {
        private static implementsStiInterlacingCoreXF;
        implements(): string[];
        clone(): StiInterlacingCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private _interlacing;
        interlacing: IStiInterlacing;
        constructor(interlacing: IStiInterlacing);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import RectangleF = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiLegendCoreXF implements ICloneable, IStiApplyStyle, IStiLegendCoreXF {
        private static implementsStiLegendCoreXF;
        implements(): string[];
        applyStyle(style: IStiChartStyle): void;
        clone(): StiLegendCoreXF;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        getMatrixIndexItem(countColumns: number, countRows: number, countItems: number): number[][];
        getArgumentText(series: IStiSeries, index: number): string;
        getLegendItemColumn(seriesItems: StiLegendItemCoreXF[], seriesItem: StiLegendItemCoreXF): number;
        getTitleSize(context: StiContext): SizeD;
        getItemSize1(context: StiContext, seriesItems: StiLegendItemCoreXF[], seriesIndex: number): SizeD;
        getItemSize2(context: StiContext, seriesItems: StiLegendItemCoreXF[], seriesItem: StiLegendItemCoreXF): SizeD;
        getItemRealSize(context: StiContext, seriesItem: StiLegendItemCoreXF): SizeD;
        getItemsSize(context: StiContext, seriesItems: StiLegendItemCoreXF[]): SizeD;
        getItemsAutoSize(context: StiContext, seriesItems: StiLegendItemCoreXF[], rect: RectangleF, countColumns: any, countRows: any): SizeD;
        getSeriesSize(context: StiContext, rect: RectangleF, countColumns: any, countRows: any): SizeD;
        getLegendSize(context: StiContext, rect: RectangleF, countColumns: any, countRows: any): SizeD;
        getLegendItems(REFcount: any): StiLegendItemCoreXF[];
        private _legend;
        legend: IStiLegend;
        constructor(legend: IStiLegend);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiLegendItemCoreXF {
        private _text;
        readonly text: string;
        private _series;
        readonly series: IStiSeries;
        private _index;
        readonly index: number;
        private _colorIndex;
        readonly colorIndex: number;
        constructor(text: string, series: IStiSeries, index: number, colorIndex: number);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    class StiMarkerCoreXF implements ICloneable, IStiMarkerCoreXF {
        private static implementsStiMarkerCoreXF;
        implements(): string[];
        clone(): StiMarkerCoreXF;
        drawMarkers(context: StiContext, points: PointD[], showShadow: boolean): void;
        static getMarkerRect(position: PointD, markerSize: number, zoom: number): RectangleD;
        draw(context: StiContext, marker: IStiMarker, position: PointD, zoom: number, showShadow: boolean, isMouseOver: boolean, isTooltipMode: boolean, isAnimation: boolean, toolTip: String, tag: Object, interaction: StiInteractionDataGeom): void;
        drawLine(context: StiContext, x1: number, y1: number, x2: number, y2: number, scale: number, brushMarker: StiBrush, penMarker: StiPenGeom, markerType: StiMarkerType, markerStep: number, markerSize: number, angle: number): void;
        drawLines(context: StiContext, points: PointD[], scale: number, brushMarker: Object, penMarker: StiPenGeom, markerType: StiMarkerType, markerStep: number, markerSize: number, angle: number): void;
        drawPoint(context: StiContext, x: number, y: number, scale: number, brush: Object, pen: StiPenGeom, markerType: StiMarkerType, markerSize: number, angle: number, isMouseOver: boolean, isAnimation: boolean, toolTip: String, tag: Object, interaction: StiInteractionDataGeom): void;
        private drawPolygon(context, fillBrush, borderPen, centerX, centerY, radius, count, startAngle, isStar, isMouseOver);
        private _marker;
        marker: IStiMarker;
        constructor(marker: IStiMarker);
    }
}
declare module Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarAxisCoreXF implements ICloneable, IStiApplyStyle, IStiRadarAxisCoreXF {
        private static implementsStiRadarAxisCoreXF;
        implements(): string[];
        clone(): StiRadarAxisCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private _axis;
        axis: IStiRadarAxis;
        constructor(axis: IStiRadarAxis);
    }
}
declare module Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarAxisLabelsCoreXF implements IStiApplyStyle, ICloneable, IStiRadarAxisLabelsCoreXF {
        private static implementsStiRadarAxisLabelsCoreXF;
        implements(): string[];
        clone(): StiRadarAxisLabelsCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private _labels;
        labels: IStiRadarAxisLabels;
        constructor(labels: IStiRadarAxisLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiXRadarAxisCoreXF extends StiRadarAxisCoreXF implements IStiXRadarAxisCoreXF {
        private static implementsStiXRadarAxisCoreXF;
        implements(): string[];
        applyStyle(style: IStiChartStyle): void;
        renderLabel(context: StiContext, series: IStiSeries, point: PointD, argument: Object, angle: number, colorIndex: number, colorCount: number): StiXRadarAxisLabelGeom;
        getLabelText(value: Object): string;
        getLabelRect(context: StiContext, point: PointD, text: string, angle: number): RectangleD;
        readonly xAxis: IStiXRadarAxis;
        constructor(axis: IStiRadarAxis);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiYRadarAxisCoreXF extends StiRadarAxisCoreXF implements IStiYRadarAxisCoreXF {
        private static implementsStiYRadarAxisCoreXF;
        implements(): string[];
        applyStyle(style: IStiChartStyle): void;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        private measureStripLines(context, rect);
        private renderLabels(context, rect, geom);
        calculateStripPositions(topPosition: number, bottomPosition: number): void;
        getAxisRect(context: StiContext, rect: RectangleD, includeAxisArrow: boolean, includeLabelsHeight: boolean, isDrawing: boolean): RectangleD;
        getTicksMaxLength(context: StiContext): number;
        getLabelsSpaceAxis(context: StiContext): number;
        getLabelsTwoLinesDestination(context: StiContext): number;
        getTextAlignment(): StiHorAlignment;
        getLabelText(line: StiStripLineXF, series: IStiSeries): string;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        getFontGeom(context: StiContext): StiFontGeom;
        readonly yAxis: IStiYRadarAxis;
        info: StiAxisInfoXF;
        readonly ticksMaxLength: number;
        constructor(axis: IStiRadarAxis);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSeriesLabelsCoreXF implements ICloneable, IStiApplyStyle, IStiSeriesLabelsCoreXF {
        private static implementsStiSeriesLabelsCoreXF;
        implements(): string[];
        clone(): StiSeriesLabelsCoreXF;
        applyStyle(style: IStiChartStyle): void;
        readonly position: number;
        readonly seriesLabelsType: StiSeriesLabelsType;
        private _seriesLabels;
        seriesLabels: IStiSeriesLabels;
        readonly localizedName: string;
        processSeriesColors(pointIndex: number, brush: StiBrush, series: IStiSeries): StiBrush;
        getSeriesLabelColor(series: IStiSeries, colorIndex: number, colorCount: number): Color;
        getBorderColor(series: IStiSeries, colorIndex: number, colorCount: number): Color;
        getLabelColor(series: IStiSeries, colorIndex: number, colorCount: number): Color;
        recalcValue(value: number, signs: number): number;
        getLabelText(series: IStiSeries, value: number, argument: string, tag: string, seriesName: string, useLegendValueType?: boolean): string;
        getLabelText2(series: IStiSeries, value: number, argument: string, tag: string, seriesName: string, weight: number, useLegendValueType: boolean): string;
        private getArgument(series, argument);
        private getFormatted(series, value, isDateTime);
        getFormattedValue(series: IStiSeries, value: number): string;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiAxisSeriesLabelsCoreXF extends StiSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, endPoint: PointD, startPoint: PointD, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, animation?: StiAnimation): StiSeriesLabelsGeom;
        renderLabel2(series: IStiSeries, context: StiContext, endPoint: PointD, startPoint: PointD, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, weight: number, colorIndex: number, colorCount: number, rect: RectangleD, animation?: StiAnimation): StiSeriesLabelsGeom;
        recalcValue(value: number, signs: number): number;
        readonly seriesLabelsType: StiSeriesLabelsType;
        currentIndex: number;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterAxisLabelsCoreXF extends StiAxisSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, endPoint: PointD, startPoint: PointD, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, animation?: StiAnimation): StiSeriesLabelsGeom;
        renderLabel2(series: IStiSeries, context: StiContext, endPoint: PointD, startPoint: PointD, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, weight: number, colorIndex: number, colorCount: number, rect: RectangleD, animation?: StiAnimation): StiSeriesLabelsGeom;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        readonly position: number;
        readonly localizedName: string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiInsideBaseAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        readonly localizedName: string;
        readonly position: number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiInsideEndAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        readonly position: number;
        readonly localizedName: string;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiLeftAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        readonly localizedName: string;
        readonly position: number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiOutsideAxisLabelsCoreXF extends StiAxisSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, endPoint: PointD, startPoint: PointD, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD): StiSeriesLabelsGeom;
        readonly position: number;
        readonly localizedName: string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiOutsideBaseAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        readonly localizedName: string;
        readonly position: number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiOutsideEndAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        readonly localizedName: string;
        readonly position: number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiRightAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        readonly localizedName: string;
        readonly position: number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiValueAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        readonly localizedName: string;
        readonly position: number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiFunnelSeriesLabelsCoreXF extends StiSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, valueNext: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, singleValueHeight: number, singleValueWidth: number, centerAxis: number, REFmeasureRect: any): StiSeriesLabelsGeom;
        readonly seriesLabelsType: StiSeriesLabelsType;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCenterFunnelLabelsCoreXF extends StiFunnelSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, valueNext: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, singleValueHeight: number, singleValueWidth: number, centerAxis: number, REFmeasureRect: any): StiSeriesLabelsGeom;
        private getSumLastValues(series, indexCurrent);
        readonly seriesLabelsType: StiSeriesLabelsType;
        readonly position: number;
        readonly localizedName: string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsideLeftFunnelLabelsCoreXF extends StiFunnelSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, valueNext: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, singleValueHeight: number, singleValueWidth: number, centerAxis: number, REFmeasureRect: any): StiSeriesLabelsGeom;
        readonly seriesLabelsType: StiSeriesLabelsType;
        readonly position: number;
        readonly localizedName: string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsideRightFunnelLabelsCoreXF extends StiFunnelSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, valueNext: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, singleValueHeight: number, singleValueWidth: number, centerAxis: number, REFmeasureRect: any): StiSeriesLabelsGeom;
        readonly seriesLabelsType: StiSeriesLabelsType;
        readonly position: number;
        readonly localizedName: string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiPieSeriesLabelsCoreXF extends StiSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, centerPie: PointD, radius: number, radius2: number, pieAngle: number, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, measure: boolean, colorIndex: number, colorCount: number, percentPerValue: number, REFmeasureRect: any, drawValue: boolean, deltaY: number): StiSeriesLabelsGeom;
        recalcValue(value: number, signs: number): number;
        readonly seriesLabelsType: StiSeriesLabelsType;
        percentPerValue: number;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiCenterPieLabelsCoreXF extends StiPieSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, centerPie: PointD, radius: number, radius2: number, pieAngle: number, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, measure: boolean, colorIndex: number, colorCount: number, percentPerValue: number, REFmeasureRect: any, drawValue: boolean, deltaY: number): StiSeriesLabelsGeom;
        getLabelPoint(centerPie: PointD, radius: number, angleRad: number): PointD;
        getLabelRect(context: StiContext, labelPoint: PointD, labelText: string, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        readonly seriesLabelsType: StiSeriesLabelsType;
        readonly position: number;
        readonly localizedName: string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiInsideEndPieLabelsCoreXF extends StiCenterPieLabelsCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiOutsidePieLabelsCoreXF extends StiCenterPieLabelsCoreXF {
        applyStyle(style: IStiChartStyle): void;
        readonly position: number;
        readonly localizedName: string;
        getLineColor(series: IStiSeries, colorIndex: number, colorCount: number): Color;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTwoColumnsPieLabelsCoreXF extends StiOutsidePieLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, centerPie: PointD, radius: number, radius2: number, pieAngle: number, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, measure: boolean, colorIndex: number, colorCount: number, percentPerValue: number, REFmeasureRect: any, drawValue: boolean, deltaY: number): StiSeriesLabelsGeom;
        readonly seriesLabelsType: StiSeriesLabelsType;
        readonly position: number;
        readonly localizedName: string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterTreemapLabelsCoreXF extends StiSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, animation?: StiAnimation): StiSeriesLabelsGeom;
        getLabelRect(context: StiContext, rect: RectangleD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        readonly position: number;
        readonly localizedName: string;
        readonly seriesLabelsType: StiSeriesLabelsType;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiNoneLabelsCoreXF extends StiSeriesLabelsCoreXF {
        readonly seriesLabelsType: StiSeriesLabelsType;
        readonly position: number;
        readonly localizedName: string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSeriesCoreXF implements ICloneable, IStiApplyStyleSeries, IStiSeriesCoreXF {
        private static implementsStiSeriesCoreXF;
        implements(): string[];
        clone(): StiSeriesCoreXF;
        applyStyle(style: IStiChartStyle, color: Color): void;
        checkLabelsRect(labels: IStiSeriesLabels, geom: StiAreaGeom, labelsRect: RectangleD): RectangleD;
        private getRectangle(labelsRect, angle);
        private rotatePoint(pointToRotate, centerPoint, angleInDegrees);
        checkIntersectionLabels(geom: StiAreaGeom): void;
        private getLabelRectangle(angle, rect);
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Object;
        getSeriesLabels(): IStiAxisSeriesLabels;
        getTag(tagIndex: number): string;
        private static falseObject;
        private static trueObject;
        private isMouseOverSeriesElementHashtable;
        getIsMouseOverSeriesElement(seriesIndex: number): boolean;
        setIsMouseOverSeriesElement(seriesIndex: number, value: boolean): void;
        private _isMouseOver;
        isMouseOver: boolean;
        readonly localizedName: string;
        private _isDateTimeValues;
        isDateTimeValues: boolean;
        private _isDateTimeArguments;
        isDateTimeArguments: boolean;
        private _series;
        series: IStiSeries;
        interaction: IStiSeriesInteraction;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiBaseLineSeriesCoreXF extends StiSeriesCoreXF implements IStiApplyStyleSeries {
        private static implementsStiBaseLineSeriesCoreXF;
        implements(): string[];
        applyStyle(style: IStiChartStyle, color: Color): void;
        protected clipLinePoints(context: StiContext, geom: StiAreaGeom, points: PointD[], REFstartIndex: any, REFendIndex: any): PointD[];
        renderMarkers(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        getInteractions(context: StiContext, geom: StiAreaGeom, points: PointD[]): StiSeriesInteractionData[];
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private optimizePoints(points);
        private isTopmostLine(series);
        correctPoint(point: PointD, rect: RectangleD, correctY: number): PointD;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Object;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiScatterSeriesCoreXF extends StiBaseLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBubbleSeriesCoreXF extends StiScatterSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        renderBubbles(context: StiContext, geom: StiAreaGeom, series: IStiBubbleSeries, points: PointD[], weights: number[]): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiClusteredColumnSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        protected correctPoint(point: PointD, rect: RectangleD): PointD;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Object;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiClusteredBarSeriesCoreXF extends StiClusteredColumnSeriesCoreXF implements IStiApplyStyleSeries {
        private static implementsStiClusteredBarSeriesCoreXF;
        implements(): string[];
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        protected correctPoint(point: PointD, rect: RectangleD): PointD;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiLineSeriesCoreXF extends StiBaseLineSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiAreaSeriesCoreXF extends StiLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSplineSeriesCoreXF extends StiBaseLineSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSplineAreaSeriesCoreXF extends StiSplineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSteppedLineSeriesCoreXF extends StiBaseLineSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSteppedAreaSeriesCoreXF extends StiSteppedLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        private correctBrush(brush);
        private renderPieElement(context, center, radius, borderColor, brush, start, angle, value, index, currentSeries, distance, geom, beginTime);
        private renderPieElementShadow(context, center, radius, brush, start, angle, currentSeries, distance);
        private measurePieElement(context, center, radius, start, angle, currentSeries, distance);
        private measurePieElementCore(context, center, radius, start, angle, currentSeries, distance, REFpath, REFpathLight, REFrectPie);
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        private checkIntersectionTwoColumnsLabels(geom, rect);
        private checkLabelPosition(labels, rect);
        protected getGradPerValue(series: IStiSeries[]): number;
        getPercentPerValue(series: IStiSeries[]): number;
        getPointCenter(rect: RectangleD): PointD;
        getRadius(context: StiContext, rect: RectangleD): number;
        getPoint(centerPie: PointD, radius: number, angle: number): PointD;
        protected getArgumentText(series: IStiSeries, index: number): string;
        getPieDistance(pieIndex: number): number;
        getPieDistance2(series: IStiPieSeries, pieIndex: number): number;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Object;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDoughnutSeriesCoreXF extends StiPieSeriesCoreXF {
        private renderDoughnutElement(context, center, radius, radiusDt, borderColor, brush, start, angle, value, index, currentSeries, shadow, areaGeom, beginTime);
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        protected getGradPerValue(series: IStiSeries[]): number;
        getPercentPerValue(series: IStiSeries[]): number;
        protected getArgumentText(series: IStiSeries, index: number): string;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCandlestickSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStockSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedBarSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private calculateTotalWidth(series, pointIndex, REFtotalPositiveWidth, REFtotalNegativeWidth);
        private correctRect(columnRect, rect);
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Object;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedBarSeriesCoreXF extends StiStackedBarSeriesCoreXF {
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiStackedBaseLineSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        clipLinePoints(context: StiContext, geom: StiAreaGeom, startPoints: PointD[], endPoints: PointD[], REFnewStartPoints: any, REFnewEndPoints: any, REFstartIndex: any, REFendIndex: any): void;
        renderMarkers(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, startPoints: PointD[], endPoints: PointD[]): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private calculateTotalHeight(series, pointIndex, REFtotalPositiveHeight, REFtotalNegativeHeight);
        private correctPoint(point, rect);
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Object;
        readonly isFullStacked: boolean;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiStackedLineSeriesCoreXF extends StiStackedBaseLineSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedAreaSeriesCoreXF extends StiStackedLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, startPoints: PointD[], endPoints: PointD[]): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedAreaSeriesCoreXF extends StiStackedAreaSeriesCoreXF {
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedColumnSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private calculateTotalHeight(series, pointIndex, REFtotalPositiveHeight, REFtotalNegativeHeight);
        private correctRect(columnRect, rect);
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Object;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedColumnSeriesCoreXF extends StiStackedColumnSeriesCoreXF {
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedLineSeriesCoreXF extends StiStackedLineSeriesCoreXF {
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiStackedSplineSeriesCoreXF extends StiStackedBaseLineSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedSplineAreaSeriesCoreXF extends StiStackedSplineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, startPoints: PointD[], endPoints: PointD[]): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedSplineAreaSeriesCoreXF extends StiStackedSplineAreaSeriesCoreXF {
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedSplineSeriesCoreXF extends StiStackedSplineSeriesCoreXF {
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiFunnelSeriesCoreXF extends StiSeriesCoreXF {
        private labels;
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        private getValues(funnelSeries);
        private getArgumentText(series, index);
        private renderFunnelElement(borderColor, brush, value, valueNext, index, currentSeries, geom, rect, singleValueHeight, singleValueWidth, beginTime);
        private getSingleValueHeight(values, rect);
        private getSingleValueWidth(funnelSeries, rect);
        private measureFunnelElementCore(REFpath, value, valueNext, index, rect, singleValueHeight, singleValueWidth);
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiFunnelWeightedSlicesSeriesCoreXF extends StiSeriesCoreXF {
        private labels;
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        private getValues(funnelSeries);
        private getArgumentText(series, index);
        private renderFunnelElement(borderColor, brush, value, index, currentSeries, geom, rect, singleValueHeight, beginTime);
        private getSumValues();
        private getSumLastValues(indexCurrent);
        private measureFunnelElementCore(index, rect, singleValueHeight);
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiGanttSeriesCoreXF extends StiClusteredBarSeriesCoreXF {
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiFontIcons = Stimulsoft.Report.StiFontIcons;
    class DataPictorial {
        private _value;
        value: number;
        private _icon;
        icon: StiFontIcons;
        constructor(value: number, icon: StiFontIcons);
    }
    class StiPictorialSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        readonly localizedName: string;
        private singleSizeConst;
        getSingleSize(context: StiContext): SizeD;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRadarSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        renderAreas(context: StiContext, series: IStiRadarSeries, points: PointD[], geom: StiAreaGeom): void;
        renderLines(context: StiContext, series: IStiRadarSeries, points: PointD[], geom: StiAreaGeom): void;
        renderPoints(context: StiContext, series: IStiRadarSeries, points: PointD[], geom: StiAreaGeom): void;
        private getArgument(series, pointIndex);
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Object;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarAreaSeriesCoreXF extends StiRadarSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        readonly localizedName: string;
        renderLines(context: StiContext, series: IStiRadarSeries, points: PointD[], geom: StiAreaGeom): void;
        renderAreas(context: StiContext, series: IStiRadarSeries, points: PointD[], geom: StiAreaGeom): void;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarLineSeriesCoreXF extends StiRadarSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        readonly localizedName: string;
        renderLines(context: StiContext, series: IStiRadarSeries, points: PointD[], geom: StiAreaGeom): void;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarPointSeriesCoreXF extends StiRadarSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRangeBarSeriesCoreXF extends StiClusteredColumnSeriesCoreXF {
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRangeSeriesCoreXF extends StiLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private renderLines2(context, geom, points, values, series);
        private renderMarkers2(context, geom, points, values, series);
        private getYPoint(value, currentSeries, axisArea, index);
        private renderAreas2(geom, points, pointsEnd, series);
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSplineRangeSeriesCoreXF extends StiSplineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private renderLines2(context, geom, points, values, series);
        private renderMarkers2(context, geom, points, values, series);
        private getYPoint(value, currentSeries, axisArea, index);
        private renderAreas2(context, geom, points, pointsEnd, series);
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSteppedRangeSeriesCoreXF extends StiSteppedLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private renderAreas2(context, geom, points, pointsEnd, series);
        private renderLines2(context, geom, points, values, series);
        private renderMarkers2(context, geom, points, values, series);
        private getYPoint(value, currentSeries, axisArea, index);
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiScatterLineSeriesCoreXF extends StiScatterSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiScatterSplineSeriesCoreXF extends StiScatterSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTreemapSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        getArgumentText(series: IStiSeries, index: number): string;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): any;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStripsCoreXF implements IStiApplyStyle, ICloneable, IStiStripsCoreXF {
        private static implementsStiStripsCoreXF;
        implements(): string[];
        clone(): Object;
        applyStyle(style: IStiChartStyle): void;
        renderXStrips(context: StiContext, geom: StiAxisAreaGeom, rect: RectangleD): void;
        renderYStrips(context: StiContext, geom: StiAxisAreaGeom, rect: RectangleD): void;
        render(context: StiContext, geom: StiAxisAreaGeom, rect: RectangleD): void;
        private _strips;
        strips: IStiStrips;
        constructor(strips: IStiStrips);
    }
}
declare module Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    class StiStyleCoreXF implements IStiStyleCoreXF {
        private static implementsStiStyleCoreXF;
        implements(): string[];
        readonly localizedName: string;
        readonly styleId: StiChartStyleId;
        readonly chartBrush: StiBrush;
        readonly chartAreaBrush: StiBrush;
        readonly chartAreaBorderColor: Color;
        private _chart;
        chart: IStiChart;
        readonly seriesLabelsBrush: StiBrush;
        readonly seriesLabelsColor: Color;
        readonly seriesLabelsBorderColor: Color;
        readonly seriesLabelsFont: Font;
        readonly legendBrush: StiBrush;
        readonly legendLabelsColor: Color;
        readonly legendBorderColor: Color;
        readonly legendTitleColor: Color;
        readonly legendShowShadow: boolean;
        readonly legendFont: Font;
        readonly axisTitleColor: Color;
        readonly axisLineColor: Color;
        readonly axisLabelsColor: Color;
        readonly interlacingHorBrush: StiBrush;
        readonly interlacingVertBrush: StiBrush;
        readonly gridLinesHorColor: Color;
        readonly gridLinesVertColor: Color;
        readonly seriesLighting: boolean;
        readonly seriesShowShadow: boolean;
        readonly markerVisible: boolean;
        readonly firstStyleColor: Color;
        readonly lastStyleColor: Color;
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        fillColumn(context: StiContext, rect: RectangleD, brush: StiBrush, interaction: StiInteractionDataGeom): void;
        getAreaBrush(color: Color): StiBrush;
        getColumnBrush(color: Color): StiBrush;
        getColumnBorder(color: Color): Color;
        getColors(seriesCount: number): Color[];
        getColorByIndex(index: number, count: number): Color;
        getColorBySeries(series: IStiSeries): Color;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF01 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCustomStyleCoreXF extends StiStyleCoreXF01 {
        private _base;
        readonly localizedName: string;
        reportChartStyle: Stimulsoft.Report.Styles.StiChartStyle;
        readonly chartAreaBrush: StiBrush;
        readonly chartAreaBorderColor: Color;
        readonly seriesShowShadow: boolean;
        readonly seriesLabelsBrush: StiBrush;
        readonly seriesLighting: boolean;
        readonly seriesLabelsColor: Color;
        readonly seriesLabelsBorderColor: Color;
        readonly legendBrush: StiBrush;
        readonly legendLabelsColor: Color;
        readonly legendBorderColor: Color;
        readonly legendTitleColor: Color;
        readonly axisTitleColor: Color;
        readonly axisLineColor: Color;
        readonly axisLabelsColor: Color;
        readonly interlacingHorBrush: StiBrush;
        readonly interlacingVertBrush: StiBrush;
        readonly gridLinesHorColor: Color;
        readonly gridLinesVertColor: Color;
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        private _reportStyleName;
        reportStyleName: string;
        readonly reportStyle: Stimulsoft.Report.Styles.StiChartStyle;
        private _customStyle;
        readonly customStyle: StiCustomStyle;
        getColumnBrush(color: Color): StiBrush;
        constructor(customStyle: StiCustomStyle);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF02 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly basicStyleColor: Color;
        readonly styleColors: Color[];
        readonly styleId: StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF03 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF04 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly basicStyleColor: Color;
        readonly styleColors: Color[];
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF05 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF06 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF07 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF08 extends StiStyleCoreXF03 {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF09 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF10 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF11 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF12 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF13 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF14 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF15 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF16 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF17 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    class StiStyleCoreXF18 extends StiStyleCoreXF {
        readonly localizedName: string;
        fillColumn(context: StiContext, rect: RectangleD, brush: StiBrush, interaction: StiInteractionDataGeom): void;
        getColumnBrush(color: Color): StiBrush;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF19 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly interlacingHorBrush: StiBrush;
        readonly interlacingVertBrush: StiBrush;
        readonly chartAreaBrush: StiBrush;
        readonly chartBrush: StiBrush;
        readonly styleId: StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF20 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly axisLineColor: Color;
        readonly chartAreaBorderColor: Color;
        readonly styleId: StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF21 extends StiStyleCoreXF {
        readonly localizedName: string;
        readonly chartBrush: StiBrush;
        readonly chartAreaBrush: StiBrush;
        readonly chartAreaBorderColor: Color;
        readonly seriesLabelsBrush: StiBrush;
        readonly seriesLabelsColor: Color;
        readonly seriesLabelsBorderColor: Color;
        readonly legendBrush: StiBrush;
        readonly legendLabelsColor: Color;
        readonly axisTitleColor: Color;
        readonly axisLineColor: Color;
        readonly axisLabelsColor: Color;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
        getColumnBorder(color: Color): Color;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF22 extends StiStyleCoreXF {
        readonly localizedName: string;
        readonly chartBrush: StiBrush;
        readonly chartAreaBrush: StiBrush;
        readonly chartAreaBorderColor: Color;
        readonly seriesLabelsBrush: StiBrush;
        readonly seriesLabelsColor: Color;
        readonly seriesLabelsBorderColor: Color;
        readonly legendBrush: StiBrush;
        readonly legendLabelsColor: Color;
        readonly axisTitleColor: Color;
        readonly axisLineColor: Color;
        readonly axisLabelsColor: Color;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
        getColumnBorder(color: Color): Color;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF23 extends StiStyleCoreXF22 {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF24 extends StiStyleCoreXF22 {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStyleCoreXF25 extends StiStyleCoreXF22 {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly styleId: StiChartStyleId;
        readonly legendShowShadow: boolean;
        readonly legendBorderColor: Color;
        readonly seriesLabelsBrush: StiBrush;
        readonly seriesLabelsColor: Color;
        readonly seriesLabelsBorderColor: Color;
        readonly seriesLabelsFont: Font;
        readonly seriesLighting: boolean;
        readonly seriesShowShadow: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStyleCoreXF26 extends StiStyleCoreXF22 {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly chartAreaBrush: StiBrush;
        readonly legendShowShadow: boolean;
        readonly legendBorderColor: Color;
        readonly seriesLabelsBrush: StiBrush;
        readonly seriesLabelsColor: Color;
        readonly seriesLabelsBorderColor: Color;
        readonly seriesLabelsFont: Font;
        readonly seriesLighting: boolean;
        readonly seriesShowShadow: boolean;
        readonly markerVisible: boolean;
        readonly styleId: StiChartStyleId;
        getColumnBorder(color: Color): Color;
    }
}
declare module Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStyleCoreXF27 extends StiStyleCoreXF22 {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly chartBrush: StiBrush;
        readonly chartAreaBrush: StiBrush;
        readonly seriesLabelsBrush: StiBrush;
        readonly seriesLabelsColor: Color;
        readonly seriesLabelsBorderColor: Color;
        readonly seriesLabelsFont: Font;
        readonly legendBrush: StiBrush;
        readonly legendLabelsColor: Color;
        readonly legendBorderColor: Color;
        readonly legendTitleColor: Color;
        readonly legendShowShadow: boolean;
        readonly legendFont: Font;
        readonly seriesLighting: boolean;
        getColumnBorder(color: Color): Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStyleCoreXF28 extends StiStyleCoreXF26 {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly chartBrush: StiBrush;
        readonly chartAreaBrush: StiBrush;
        readonly axisTitleColor: Color;
        readonly axisLineColor: Color;
        readonly axisLabelsColor: Color;
        readonly seriesLabelsColor: Color;
        readonly legendBrush: StiBrush;
        readonly legendLabelsColor: Color;
        readonly legendBorderColor: Color;
        readonly legendTitleColor: Color;
        readonly legendShowShadow: boolean;
        readonly legendFont: Font;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiChartTableCoreXF implements ICloneable, IStiApplyStyle, IStiChartTableCoreXF {
        private static implementsStiChartTableCoreXF;
        implements(): string[];
        applyStyle(style: IStiChartStyle): void;
        clone(): StiChartTableCoreXF;
        private _chartTable;
        chartTable: IStiChartTable;
        showTable(): boolean;
        getHeightTable(context: StiContext, widthTable: number): number;
        getHeightHeaderTable(context: StiContext, widthTable: number): number;
        getWidthCellLegend(context: StiContext): number;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        private getMaxCountValues(series);
        private getArguments();
        private getTableValues();
        constructor(table: IStiChartTable);
    }
}
declare module Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTrendLineCoreXF implements ICloneable, IStiTrendLineCoreXF {
        private static implementsStiTrendLineCoreXF;
        implements(): string[];
        clone(): StiTrendLineCoreXF;
        readonly localizedName: string;
        private _trendLine;
        trendLine: IStiTrendLine;
        renderTrendLine(geom: StiAreaGeom, points: PointD[], posY: number): void;
        sum(values: number[]): number;
        sumSqr(values: number[]): number;
        sumProductions(valuesX: number[], valuesY: number[]): number;
        sumProductionsXLogY(valuesX: number[], valuesY: number[]): number;
        sumLn(values: number[]): number;
        constructor(trendLine: IStiTrendLine);
    }
}
declare module Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTrendLineExponentialCoreXF extends StiTrendLineCoreXF {
        readonly localizedName: string;
        renderTrendLine(geom: StiAreaGeom, points: PointD[], posY: number): void;
        constructor(trendLine: IStiTrendLine);
    }
}
declare module Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTrendLineLinearCoreXF extends StiTrendLineCoreXF {
        readonly localizedName: string;
        renderTrendLine(geom: StiAreaGeom, points: PointD[], posY: number): void;
        constructor(trendLine: IStiTrendLine);
    }
}
declare module Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTrendLineLogarithmicCoreXF extends StiTrendLineCoreXF {
        readonly localizedName: string;
        renderTrendLine(geom: StiAreaGeom, points: PointD[], posY: number): void;
        constructor(trendLine: IStiTrendLine);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiTrendLineNoneCoreXF extends StiTrendLineCoreXF {
        readonly localizedName: string;
        constructor(trendLine: IStiTrendLine);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiChartCoreXF implements ICloneable, IStiApplyStyle, IStiChartCoreXF {
        private static implementsStiChartCoreXF;
        implements(): string[];
        clone(): Object;
        applyStyle(style: IStiChartStyle): void;
        render(context: StiContext, rect: RectangleD, useMargins: boolean): StiCellGeom;
        private setLegendRect(context, chart, REFfullRectangle, REFareaRect, REFlegendRect);
        private _chart;
        chart: IStiChart;
        constructor(chart: IStiChart);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiGeom = Stimulsoft.Base.Context.StiGeom;
    import StiGeomType = Stimulsoft.Base.Context.StiGeomType;
    class StiCellGeom extends StiGeom implements IStiGeomInteraction, IStiCellGeom {
        private static implementsStiCellGeom;
        implements(): string[];
        invokeClick(options: StiInteractionOptions): void;
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeMouseDown(options: StiInteractionOptions): void;
        invokeMouseUp(options: StiInteractionOptions): void;
        invokeDrag(options: StiInteractionOptions): void;
        readonly invisible: boolean;
        readonly type: StiGeomType;
        private _childGeoms;
        readonly childGeoms: StiCellGeom[];
        private _clientRectangle;
        clientRectangle: RectangleD;
        dispose(): void;
        contains(x: number, y: number): boolean;
        getGeomAt(parent: StiCellGeom, x: number, y: number): StiCellGeom;
        getSeriesGeoms(): StiCellGeom[];
        getSeriesElementGeoms(): StiCellGeom[];
        getRect(geom: StiGeom): RectangleD;
        createChildGeoms(): void;
        draw(context: StiContext): void;
        drawGeom(context: StiContext): void;
        drawChildGeoms(context: StiContext): void;
        protected allowChildDrawing(cellGeom: StiCellGeom): boolean;
        constructor(clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAreaGeom extends StiCellGeom {
        private _area;
        readonly area: IStiArea;
        draw(context: StiContext): void;
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisAreaGeom extends StiAreaGeom {
        private _view;
        readonly view: StiAxisAreaViewGeom;
        private minWidth;
        private drawInterlacingHor(context, rect);
        private drawInterlacingVer(context, rect);
        private drawGridLinesHor(context, rect, gridLinesHor, isLeftAxis);
        private drawGridLinesVer(context, rect, gridLinesVert, isBottomAxis);
        protected allowChildDrawing(cellGeom: StiCellGeom): boolean;
        isChildVisibleInView(cellGeom: StiCellGeom): boolean;
        draw(context: StiContext): void;
        constructor(view: StiAxisAreaViewGeom, area: IStiArea, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisAreaViewGeom extends StiAreaGeom {
        drawGeom(context: StiContext): void;
        drawChildGeoms(context: StiContext): void;
        private drawBorder(context);
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieAreaGeom extends StiAreaGeom {
        draw(context: StiContext): void;
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDoughnutAreaGeom extends StiPieAreaGeom {
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPictorialAreaGeom extends StiAreaGeom {
        draw(context: StiContext): void;
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRadarAreaGeom extends StiAreaGeom {
        private _valuesCount;
        readonly valuesCount: number;
        private drawHor(context, fill, draw);
        private drawVert(context, fill, draw);
        private drawBackground(context);
        draw(context: StiContext): void;
        constructor(area: IStiArea, clientRectangle: RectangleD, valuesCount: number);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTreemapAreaGeom extends StiAreaGeom {
        draw(context: StiContext): void;
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDownButtonGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeMouseDown(options: StiInteractionOptions): void;
        private moveDown();
        private _axis;
        readonly axis: IStiYAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHorzScrollBarGeom extends StiCellGeom {
        invokeMouseDown(options: StiInteractionOptions): void;
        draw(context: StiContext): void;
        private _axis;
        readonly axis: IStiXAxis;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHorzTrackBarGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeMouseDown(options: StiInteractionOptions): void;
        invokeDrag(options: StiInteractionOptions): void;
        draw(context: StiContext): void;
        private _axis;
        readonly axis: IStiXAxis;
        private _scrollBar;
        readonly scrollBar: StiHorzScrollBarGeom;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD, scrollBar: StiHorzScrollBarGeom);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLeftButtonGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeMouseDown(options: StiInteractionOptions): void;
        private moveLeft();
        private _axis;
        readonly axis: IStiXAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRightButtonGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeMouseDown(options: StiInteractionOptions): void;
        private moveRight();
        private _axis;
        readonly axis: IStiXAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiUpButtonGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeMouseDown(options: StiInteractionOptions): void;
        private moveUp();
        private _axis;
        readonly axis: IStiYAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiVertScrollBarGeom extends StiCellGeom {
        invokeMouseDown(options: StiInteractionOptions): void;
        draw(context: StiContext): void;
        private _axis;
        readonly axis: IStiYAxis;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiVertTrackBarGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeMouseDown(options: StiInteractionOptions): void;
        invokeDrag(options: StiInteractionOptions): void;
        draw(context: StiContext): void;
        private _axis;
        readonly axis: IStiYAxis;
        private _scrollBar;
        readonly scrollBar: StiVertScrollBarGeom;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD, scrollBar: StiVertScrollBarGeom);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisLabelGeom extends StiCellGeom {
        private _rotationMode;
        readonly rotationMode: StiRotationMode;
        private _textPoint;
        readonly textPoint: PointD;
        private _angle;
        readonly angle: number;
        private _axis;
        readonly axis: IStiAxis;
        private _text;
        readonly text: string;
        private _stripLine;
        readonly stripLine: StiStripLineXF;
        draw(context: StiContext): void;
        constructor(axis: IStiAxis, clientRectangle: RectangleD, textPoint: PointD, text: string, stripLine: StiStripLineXF, angle: number, rotationMode: StiRotationMode);
    }
}
declare module Stimulsoft.Report.Chart {
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisTitleGeom extends StiCellGeom {
        private _axis;
        readonly axis: IStiAxis;
        private _angle;
        readonly angle: number;
        draw(context: StiContext): void;
        constructor(axis: IStiAxis, clientRectangle: RectangleD, angle: number, stringAlignment: StringAlignment);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiXAxisGeom extends StiCellGeom {
        private _axis;
        readonly axis: IStiXAxis;
        private _isCenterAxis;
        readonly isCenterAxis: boolean;
        private _view;
        view: StiXAxisViewGeom;
        drawArrow(context: StiContext, rect: RectangleD): void;
        private drawAxisLine(context, rect);
        private drawMinorTicks(context, pen, posX1, posX2, posY, ticks);
        private drawTicks(context, rect, ticks, penLine);
        private isArgumentDateTime(infos);
        private drawAxis(context, rect);
        private getViewclipRect();
        allowChildDrawing(cellGeom: StiCellGeom): boolean;
        draw(context: StiContext): void;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD, isCenterAxis: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiXAxisViewGeom extends StiXAxisGeom {
        drawChildGeoms(context: StiContext): void;
        draw(context: StiContext): void;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD, isCenterAxis: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiYAxisGeom extends StiCellGeom {
        private _axis;
        readonly axis: IStiYAxis;
        private _isCenterAxis;
        readonly isCenterAxis: boolean;
        private _view;
        view: StiYAxisViewGeom;
        drawArrow(context: StiContext, rect: RectangleD): void;
        private drawAxisLine(context, rect);
        private drawMinorTicks(context, pen, posX, posY1, posY2, ticks);
        private drawTicks(context, rect, ticks, penLine);
        private drawAxis(context, rect);
        private getViewclipRect();
        allowChildDrawing(cellGeom: StiCellGeom): boolean;
        draw(context: StiContext): void;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD, isCenterAxis: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiYAxisViewGeom extends StiYAxisGeom {
        drawChildGeoms(context: StiContext): void;
        draw(context: StiContext): void;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD, isCenterAxis: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiChartTitleGeom extends StiCellGeom {
        private _title;
        readonly title: IStiChartTitle;
        draw(context: StiContext): void;
        constructor(title: IStiChartTitle, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiConstantLinesVerticalGeom extends StiCellGeom {
        private _line;
        readonly line: IStiConstantLines;
        private _point;
        readonly point: PointD;
        private _mode;
        readonly mode: StiRotationMode;
        draw(context: StiContext): void;
        constructor(line: IStiConstantLines, clientRectangle: RectangleD, point: PointD, mode: StiRotationMode);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiConstantLinesYGeom extends StiCellGeom {
        private _line;
        readonly line: IStiConstantLines;
        private _point;
        readonly point: PointD;
        private _mode;
        readonly mode: StiRotationMode;
        draw(context: StiContext): void;
        constructor(line: IStiConstantLines, clientRectangle: RectangleD, point: PointD, mode: StiRotationMode);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendAreaMarker implements IStiLegendMarker {
        private static implementsStiLegendAreaMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendCandelstickMarker implements IStiLegendMarker {
        private static implementsStiLegendCandelstickMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendColumnMarker implements IStiLegendMarker {
        private static implementsStiLegendColumnMarker;
        implements(): string[];
        draw(context: StiContext, series: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendDoughnutMarker implements IStiLegendMarker {
        private static implementsStiLegendDoughnutMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendFunnelMarker implements IStiLegendMarker {
        private static implementsStiLegendFunnelMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendLineMarker implements IStiLegendMarker {
        private static implementsStiLegendLineMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiLegendMarkerHelper {
        static getSteppedMarkerPath(rect: RectangleD): StiSegmentGeom[];
        static getAreaMarkerPath(rect: RectangleD): StiSegmentGeom[];
        static getAreaMarkerLinePoints(rect: RectangleD): PointD[];
        static getSplineAreaMarkerPath(rect: RectangleD): StiSegmentGeom[];
        static getSplineAreaMarkerLinePoints(rect: RectangleD): PointD[];
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendPictorialMarker implements IStiLegendMarker {
        private static implementsStiLegendPictorialMarker;
        implements(): string[];
        draw(context: StiContext, series: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendPieMarker implements IStiLegendMarker {
        private static implementsStiLegendPieMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendRangeMarker implements IStiLegendMarker {
        private static implementsStiLegendRangeMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendSplineAreaMarker implements IStiLegendMarker {
        private static implementsStiLegendSplineAreaMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendSplineRangeMarker implements IStiLegendMarker {
        private static implementsStiLegendSplineRangeMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendStackedAreaMarker implements IStiLegendMarker {
        private static implementsStiLegendStackedAreaMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendStackedSplineAreaMarker implements IStiLegendMarker {
        private static implementsStiLegendStackedSplineAreaMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendSteppedAreaMarker implements IStiLegendMarker {
        private static implementsStiLegendSteppedAreaMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendSteppedRangeMarker implements IStiLegendMarker {
        private static implementsStiSteppedRangeSeries;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendStockMarker implements IStiLegendMarker {
        private static implementsStiLegendStockMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    class StiMarkerLegendFactory {
        static createMarker(series: IStiSeries): IStiLegendMarker;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendGeom extends StiCellGeom {
        private _legend;
        readonly legend: IStiLegend;
        private _seriesItems;
        readonly seriesItems: StiLegendItemCoreXF[];
        private _legendTitleGeom;
        legendTitleGeom: StiLegendTitleGeom;
        dispose(): void;
        draw(context: StiContext): void;
        constructor(legend: IStiLegend, clientRectangle: RectangleD, seriesItems: StiLegendItemCoreXF[]);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendItemGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeClick(options: StiInteractionOptions): void;
        readonly allowMouseOver: boolean;
        private readonly isColorEach;
        isMouseOver: boolean;
        private _legend;
        readonly legend: IStiLegend;
        private _item;
        readonly item: StiLegendItemCoreXF;
        private _colorIndex;
        readonly colorIndex: number;
        private _legendItemsCount;
        readonly legendItemsCount: number;
        draw(context: StiContext): void;
        constructor(legend: IStiLegend, item: StiLegendItemCoreXF, clientRectangle: RectangleD, colorIndex: number, legendItemsCount: number);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendTitleGeom extends StiCellGeom {
        private _legend;
        readonly legend: IStiLegend;
        draw(context: StiContext): void;
        constructor(legend: IStiLegend, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import IStiSeriesElement = Stimulsoft.Report.Chart.IStiSeriesElement;
    class StiMarkerGeom extends StiCellGeom implements IStiSeriesElement {
        private static implementsStiMarkerGeom;
        implements(): string[];
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeClick(options: StiInteractionOptions): void;
        private getValueIndex();
        getHyperlink(): string;
        private getHyperlink2(valueIndex);
        getToolTip(): string;
        private getToolTip2(valueIndex);
        readonly allowMouseOver: boolean;
        isMouseOver: boolean;
        private _interaction;
        interaction: StiSeriesInteractionData;
        private _index;
        readonly index: number;
        private _point;
        readonly point: PointD;
        private _marker;
        readonly marker: IStiMarker;
        private _value;
        readonly value: number;
        private _showShadow;
        readonly showShadow: boolean;
        private _series;
        readonly series: IStiSeries;
        private _elementIndex;
        elementIndex: String;
        private _isTooltipMode;
        readonly isTooltipMode: boolean;
        contains(x: number, y: number): boolean;
        getMouseOverRect(): RectangleD;
        draw(context: StiContext): void;
        constructor(series: IStiSeries, index: number, value: number, point: PointD, marker: IStiMarker, showShadow: boolean, zoom: number, isTooltipMode: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRadarAxisGeom extends StiCellGeom {
        private _axis;
        readonly axis: IStiYRadarAxis;
        private drawAxisLine(context, rect);
        private drawMinorTicks(context, pen, posX, posY1, posY2, ticks);
        private drawTicks(context, rect, ticks, penLine);
        private drawAxis(context, rect);
        draw(context: StiContext): void;
        constructor(axis: IStiYRadarAxis, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiXRadarAxisLabelGeom extends StiCellGeom {
        private _borderColor;
        readonly borderColor: Color;
        private _labelBrush;
        readonly labelBrush: StiBrush;
        private _text;
        readonly text: string;
        private _angle;
        readonly angle: number;
        private _point;
        readonly point: PointD;
        private _labelRect;
        readonly labelRect: RectangleD;
        private _axis;
        readonly axis: IStiXRadarAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiXRadarAxis, text: string, labelBrush: StiBrush, borderColor: Color, angle: number, clientRectangle: RectangleD, labelRect: RectangleD, point: PointD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiYRadarAxisLabelGeom extends StiCellGeom {
        private _rotationMode;
        readonly rotationMode: StiRotationMode;
        private _textPoint;
        readonly textPoint: PointD;
        private _angle;
        readonly angle: number;
        private _axis;
        readonly axis: IStiYRadarAxis;
        private _text;
        readonly text: string;
        private _stripLine;
        readonly stripLine: StiStripLineXF;
        draw(context: StiContext): void;
        constructor(axis: IStiYRadarAxis, clientRectangle: RectangleD, textPoint: PointD, text: string, stripLine: StiStripLineXF, angle: number, rotationMode: StiRotationMode);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiSeriesLabelsGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        private getValueIndex();
        private getHyperlink(valueIndex);
        private getToolTip(valueIndex);
        readonly allowMouseOver: boolean;
        isMouseOver: boolean;
        private _value;
        readonly value: number;
        private _index;
        readonly index: number;
        private _series;
        readonly series: IStiSeries;
        private _seriesLabels;
        readonly seriesLabels: IStiSeriesLabels;
        private _beginTime;
        beginTime: TimeSpan;
        private _duration;
        duration: TimeSpan;
        drawMarker(context: StiContext, itemRect: Rectangle, markerColor: Object, markerBrush: StiBrush): void;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterAxisLabelsGeom extends StiSeriesLabelsGeom {
        private _labelColor;
        readonly labelColor: Color;
        private _labelBorderColor;
        readonly labelBorderColor: Color;
        private _seriesBrush;
        readonly seriesBrush: StiBrush;
        private _seriesLabelsBrush;
        readonly seriesLabelsBrush: StiBrush;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _font;
        readonly font: StiFontGeom;
        private _text;
        readonly text: string;
        private _animation;
        readonly animation: StiAnimation;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, labelColor: Color, labelBorderColor: Color, seriesBrush: StiBrush, seriesLabelsBrush: StiBrush, seriesBorderColor: Color, font: StiFontGeom, animation: StiAnimation);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsideAxisLabelsGeom extends StiSeriesLabelsGeom {
        private _labelColor;
        readonly labelColor: Color;
        private _labelBorderColor;
        readonly labelBorderColor: Color;
        private _seriesBrush;
        readonly seriesBrush: StiBrush;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _font;
        readonly font: StiFontGeom;
        private _text;
        readonly text: string;
        private _startPoint;
        readonly startPoint: PointD;
        private _endPoint;
        readonly endPoint: PointD;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, labelColor: Color, labelBorderColor: Color, seriesBrush: StiBrush, seriesBorderColor: Color, font: StiFontGeom, startPoint: PointD, endPoint: PointD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCenterFunnelLabelsGeom extends StiSeriesLabelsGeom {
        private _seriesBrush;
        readonly seriesBrush: StiBrush;
        private _borderColor;
        readonly borderColor: Color;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _labelBrush;
        readonly labelBrush: StiBrush;
        private _text;
        readonly text: string;
        private _labelRect;
        readonly labelRect: RectangleD;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, seriesBrush: StiBrush, labelBrush: StiBrush, borderColor: Color, seriesBorderColor: Color, labelRect: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsideFunnelLabelsGeom extends StiCenterFunnelLabelsGeom {
        private _startPointLine;
        readonly startPointLine: PointD;
        private _endPointLine;
        readonly endPointLine: PointD;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, seriesBrush: StiBrush, labelBrush: StiBrush, borderColor: Color, seriesBorderColor: Color, labelRect: RectangleD, startPointLine: PointD, endPointLine: PointD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterPieLabelsGeom extends StiSeriesLabelsGeom {
        private _seriesBrush;
        readonly seriesBrush: StiBrush;
        private _borderColor;
        readonly borderColor: Color;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _seriesLabelsBrush;
        readonly seriesLabelsBrush: StiBrush;
        private _labelBrush;
        readonly labelBrush: StiBrush;
        private _text;
        readonly text: string;
        private _rotationMode;
        readonly rotationMode: StiRotationMode;
        private _labelRect;
        readonly labelRect: RectangleD;
        private _angleToUse;
        readonly angleToUse: number;
        private _animation;
        animation: StiAnimation;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, seriesBrush: StiBrush, labelBrush: StiBrush, seriesLabelsBrush: StiBrush, borderColor: Color, seriesBorderColor: Color, rotationMode: StiRotationMode, labelRect: RectangleD, angleToUse: number, animation: StiAnimation);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsidePieLabelsGeom extends StiCenterPieLabelsGeom {
        private _lineColor;
        readonly lineColor: Color;
        private _labelPoint;
        readonly labelPoint: PointD;
        private _startPoint;
        readonly startPoint: PointD;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, seriesBrush: StiBrush, labelBrush: StiBrush, seriesLabelsBrush: StiBrush, borderColor: Color, seriesBorderColor: Color, rotationMode: StiRotationMode, labelRect: RectangleD, angleToUse: number, lineColor: Color, labelPoint: PointD, startPoint: PointD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTwoColumnsPieLabelsGeom extends StiSeriesLabelsGeom {
        private _seriesBrush;
        readonly seriesBrush: StiBrush;
        private _borderColor;
        readonly borderColor: Color;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _labelBrush;
        readonly labelBrush: StiBrush;
        private _seriesLabelsBrush;
        readonly seriesLabelsBrush: StiBrush;
        private _text;
        readonly text: string;
        private _labelRect;
        readonly labelRect: RectangleD;
        private _lineColor;
        readonly lineColor: Color;
        private _startPoint;
        readonly startPoint: PointD;
        private _endPoint;
        endPoint: PointD;
        private _arcPoint;
        readonly arcPoint: PointD;
        private _centerPie;
        readonly centerPie: PointD;
        draw(context: StiContext): void;
        drawMarker(context: StiContext, itemRect: Rectangle, markerColor: Object, markerBrush: StiBrush): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, seriesBrush: StiBrush, labelBrush: StiBrush, seriesLabelsBrush: StiBrush, borderColor: Color, seriesBorderColor: Color, labelRect: RectangleD, lineColor: Color, startPoint: PointD, endPoint: PointD, arcPoint: PointD, centerPie: PointD);
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterTreemapLabelsGeom extends StiSeriesLabelsGeom {
        private _labelColor;
        readonly labelColor: Color;
        private _labelBorderColor;
        readonly labelBorderColor: Color;
        private _seriesBrush;
        readonly seriesBrush: StiBrush;
        private _seriesLabelsBrush;
        readonly seriesLabelsBrush: StiBrush;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _font;
        readonly font: StiFontGeom;
        private _text;
        readonly text: string;
        private _animation;
        readonly animation: StiAnimation;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: any, index: number, value: number, clientRectangle: RectangleD, text: string, labelColor: Color, labelBorderColor: Color, seriesBrush: StiBrush, seriesLabelsBrush: StiBrush, seriesBorderColor: Color, font: StiFontGeom, animation: StiAnimation);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    import IStiSeriesElement = Stimulsoft.Report.Chart.IStiSeriesElement;
    class StiSeriesElementGeom extends StiCellGeom implements IStiSeriesElement {
        private static implementsStiSeriesElementGeom;
        implements(): string[];
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeClick(options: StiInteractionOptions): void;
        protected getValueIndex(): number;
        getHyperlink(): string;
        private getHyperlink2(valueIndex);
        getToolTip(): string;
        private getToolTip2(valueIndex);
        readonly allowMouseOver: boolean;
        isMouseOver: boolean;
        private _value;
        readonly value: number;
        private _index;
        readonly index: number;
        private _series;
        readonly series: IStiSeries;
        private _interaction;
        interaction: StiSeriesInteractionData;
        private _areaGeom;
        areaGeom: StiAreaGeom;
        private _elementIndex;
        elementIndex: String;
        draw(context: StiContext): void;
        getInteractionData(): StiInteractionDataGeom;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiSeries, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiBubbleSeriesElementGeom extends StiSeriesElementGeom {
        private _seriesBrush;
        readonly seriesBrush: StiBrush;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _beginTime;
        readonly beginTime: TimeSpan;
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, clientRectangle: RectangleD, beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiClusteredBarSeriesElementGeom extends StiSeriesElementGeom {
        private _seriesBrush;
        readonly seriesBrush: StiBrush;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _beginTime;
        readonly beginTime: TimeSpan;
        private _valueStart;
        readonly valueStart: number;
        private _columnRectStart;
        readonly columnRectStart: RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, valueStart: number, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, columnRectStart: RectangleD, columnRect: RectangleD, beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiSeriesGeom extends StiCellGeom {
        private _series;
        readonly series: IStiSeries;
        private _interactions;
        interactions: StiSeriesInteractionData[];
        private _areaGeom;
        areaGeom: StiAreaGeom;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, series: IStiSeries, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiBaseLineSeriesGeom extends StiSeriesGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        readonly allowMouseOver: boolean;
        isMouseOver: boolean;
        private _points;
        readonly points: PointD[];
        static getClientRectangle(points: PointD[], lineWidth: number): RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiLineSeriesGeom extends StiBaseLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        private getPointCross(point1, point2, posY);
        private drawLine(context, pen, listPoints);
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiAreaSeriesGeom extends StiLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiClusteredColumnSeriesElementGeom extends StiSeriesElementGeom {
        private _seriesBrush;
        readonly seriesBrush: StiBrush;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _beginTime;
        readonly beginTime: TimeSpan;
        private _animation;
        readonly animation: StiAnimation;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, columnRect: RectangleD, animation: StiAnimation);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSplineSeriesGeom extends StiBaseLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSplineAreaSeriesGeom extends StiSplineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSteppedLineSeriesGeom extends StiBaseLineSeriesGeom {
        getConvertedPoints(points: PointD[]): PointD[];
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        private intersectionAxis(point, pointNext, points, pointsNext, posY);
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSteppedAreaSeriesGeom extends StiSteppedLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDoughnutSeriesElementGeom extends StiSeriesElementGeom {
        private _path;
        readonly path: StiSegmentGeom[];
        private _pathLight;
        readonly pathLight: StiSegmentGeom[];
        private _pathDark;
        readonly pathDark: StiSegmentGeom[];
        private _borderColor;
        readonly borderColor: Color;
        private _brush;
        readonly brush: StiBrush;
        private _brushLight;
        readonly brushLight: StiBrush;
        private _brushDark;
        readonly brushDark: StiBrush;
        private _startAngle;
        readonly startAngle: number;
        private _endAngle;
        readonly endAngle: number;
        private _radiusFrom;
        readonly radiusFrom: number;
        private _radiusTo;
        readonly radiusTo: number;
        private _beginTime;
        readonly beginTime: TimeSpan;
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiDoughnutSeries, clientRectangle: RectangleD, path: StiSegmentGeom[], pathLight: StiSegmentGeom[], pathDark: StiSegmentGeom[], borderColor: Color, brush: StiBrush, brushLight: StiBrush, brushDark: StiBrush, startAngle: number, endAngle: number, radiusFrom: number, radiusTo: number, beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiFinancialSeriesElementGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeClick(options: StiInteractionOptions): void;
        private getValueIndex();
        private getHyperlink(valueIndex);
        private getToolTip(valueIndex);
        readonly allowMouseOver: boolean;
        isMouseOver: boolean;
        private _series;
        readonly series: IStiSeries;
        private _interaction;
        interaction: StiSeriesInteractionData;
        private _open;
        readonly open: number;
        private _close;
        readonly close: number;
        private _high;
        readonly high: number;
        private _low;
        readonly low: number;
        private _positionX;
        readonly positionX: number;
        private _areaGeom;
        readonly areaGeom: StiAreaGeom;
        private _index;
        readonly index: number;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, series: IStiSeries, clientRectangle: RectangleD, open: number, close: number, high: number, low: number, positionX: number, index: number);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCandlestickSeriesElementGeom extends StiFinancialSeriesElementGeom {
        private _brush;
        readonly brush: StiBrush;
        private _borderColor;
        readonly borderColor: Color;
        private _beginTime;
        readonly beginTime: TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, series: IStiSeries, clientRectangle: RectangleD, bodyStart: number, bodyEnd: number, high: number, low: number, positionX: number, index: number, brush: StiBrush, borderColor: Color, beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStockSeriesElementGeom extends StiFinancialSeriesElementGeom {
        private _color;
        readonly color: Color;
        private _beginTime;
        readonly beginTime: TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, series: IStiSeries, clientRectangle: RectangleD, open: number, close: number, high: number, low: number, positionX: number, index: number, color: Color, beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiFunnelSeriesElementGeom extends StiSeriesElementGeom {
        private _path;
        readonly path: StiSegmentGeom[];
        private _borderColor;
        readonly borderColor: Color;
        private _brush;
        readonly brush: StiBrush;
        private _beginTime;
        readonly beginTime: TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiSeries, clientRectangle: RectangleD, brush: StiBrush, borderColor: Color, path: StiSegmentGeom[], beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiGanttSeriesElementGeom extends StiSeriesElementGeom {
        private _beginTime;
        readonly beginTime: TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiSeries, clientRectangle: RectangleD, beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiFontIcons = Stimulsoft.Report.StiFontIcons;
    class StiPictorialSeriesElementGeom extends StiSeriesElementGeom {
        private _icon;
        icon: StiFontIcons;
        private _drawRectangles;
        drawRectangles: RectangleD[];
        private _clipRectangles;
        clipRectangles: RectangleD[];
        private _seriesBrush;
        seriesBrush: StiBrush;
        private _animation;
        animation: StiAnimation;
        draw(context: StiContext): void;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, series: IStiSeries, icon: StiFontIcons, drawRectangles: RectangleD[], clipRectangles: RectangleD[], clientRectangle: RectangleD, animation: StiAnimation);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiPieSeriesElementGeom extends StiSeriesElementGeom {
        private _path;
        readonly path: StiSegmentGeom[];
        private _pathLight;
        readonly pathLight: StiSegmentGeom[];
        private _borderColor;
        readonly borderColor: Color;
        private _brush;
        readonly brush: StiBrush;
        private _startAngle;
        startAngle: number;
        private _endAngle;
        endAngle: number;
        private _radius;
        radius: number;
        private _beginTime;
        readonly beginTime: TimeSpan;
        private _animation;
        animation: StiAnimation;
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiPieSeries, clientRectangle: RectangleD, path: StiSegmentGeom[], pathLight: StiSegmentGeom[], borderColor: Color, brush: StiBrush, startAngle: number, endAngle: number, radius: number, animation: StiAnimation);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieSeriesFullElementGeom extends StiCellGeom {
        private _series;
        readonly series: IStiPieSeries;
        private _brush;
        readonly brush: StiBrush;
        private _borderColor;
        readonly borderColor: Color;
        draw(context: StiContext): void;
        constructor(series: IStiPieSeries, clientRectangle: RectangleD, brush: StiBrush, borderColor: Color);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieSeriesShadowElementGeom extends StiCellGeom {
        readonly invisible: boolean;
        private _series;
        readonly series: IStiPieSeries;
        private _shadowContext;
        readonly shadowContext: StiContext;
        private _radius;
        readonly radius: number;
        private _duration;
        readonly duration: TimeSpan;
        private _beginTime;
        readonly beginTime: TimeSpan;
        private _isAnimation;
        readonly isAnimation: boolean;
        draw(context: StiContext): void;
        constructor(series: IStiPieSeries, clientRectangle: RectangleD, radius: number, shadowContext: StiContext, duration: TimeSpan, beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiRadarAreaSeriesGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        readonly allowMouseOver: boolean;
        isMouseOver: boolean;
        private _series;
        readonly series: IStiSeries;
        private _points;
        readonly points: PointD[];
        private _centerPoint;
        readonly centerPoint: PointD;
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(series: IStiSeries, points: PointD[], centerPoint: PointD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRadarPointSeriesElementGeom extends StiSeriesElementGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeClick(options: StiInteractionOptions): void;
        protected getValueIndex(): number;
        private getHyperlink3(valueIndex);
        private getToolTip3(valueIndex);
        private _point;
        readonly point: PointD;
        contains(x: number, y: number): boolean;
        getMouseOverRect(): RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiRadarSeries, point: PointD, zoom: number);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRangeBarElementGeom extends StiSeriesElementGeom {
        private _beginTime;
        readonly beginTime: TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiSeries, clientRectangle: RectangleD, beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiRangeSeriesGeom extends StiLineSeriesGeom {
        private _pointsEnd;
        pointsEnd: PointD[];
        draw(context: StiContext): void;
        private getBrush(areaSeries, point, pointEnd);
        private fillPath(context, brush, pointsLine, pointsLineEnd);
        private intersection(point, pointEnd, pointNext, pointNextEnd);
        private getPointCross2(point, pointEnd, pointNext, pointNextEnd);
        constructor(areaGeom: StiAreaGeom, points: PointD[], pointsEnd: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSplineRangeSeriesGeom extends StiSplineSeriesGeom {
        private _pointsEnd;
        pointsEnd: PointD[];
        draw(context: StiContext): void;
        private fillPath(context, points, pointsEnd);
        constructor(areaGeom: StiAreaGeom, points: PointD[], pointsEnd: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSteppedRangeSeriesGeom extends StiSteppedLineSeriesGeom {
        private _pointsEnd;
        pointsEnd: PointD[];
        draw(context: StiContext): void;
        private getBrush(areaSeries, point, pointEnd);
        private fillPath(context, brush, pointsLine, pointsLineEnd);
        private intersection(point, pointEnd, pointNext, pointNextEnd);
        constructor(areaGeom: StiAreaGeom, points: PointD[], pointsEnd: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiScatterSplineSeriesGeom extends StiBaseLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedBarSeriesElementGeom extends StiSeriesElementGeom {
        private _seriesBrush;
        readonly seriesBrush: StiBrush;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _beginTime;
        readonly beginTime: TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, clientRectangle: RectangleD, beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedBarSeriesShadowElementGeom extends StiCellGeom {
        readonly invisible: boolean;
        private _series;
        readonly series: IStiSeries;
        private _isLeftShadow;
        readonly isLeftShadow: boolean;
        private _isRightShadow;
        readonly isRightShadow: boolean;
        draw(context: StiContext): void;
        constructor(series: IStiSeries, clientRectangle: RectangleD, isLeftShadow: boolean, isRightShadow: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedAreaSeriesGeom extends StiSeriesGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        readonly allowMouseOver: boolean;
        isMouseOver: boolean;
        private _startPoints;
        readonly startPoints: PointD[];
        private _endPoints;
        readonly endPoints: PointD[];
        contains(x: number, y: number): boolean;
        static getClientRectangle(startPoints: PointD[], endPoints: PointD[]): RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, startPoints: PointD[], endPoints: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedBaseLineSeriesGeom extends StiSeriesGeom {
        private _points;
        readonly points: PointD[];
        static getClientRectangle(points: PointD[]): RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedColumnSeriesElementGeom extends StiSeriesElementGeom {
        private _seriesBrush;
        readonly seriesBrush: StiBrush;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _beginTime;
        readonly beginTime: TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, clientRectangle: RectangleD, beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedColumnSeriesShadowElementGeom extends StiCellGeom {
        readonly invisible: boolean;
        private _series;
        readonly series: IStiSeries;
        private _isTopShadow;
        readonly isTopShadow: boolean;
        private _isBottomShadow;
        readonly isBottomShadow: boolean;
        draw(context: StiContext): void;
        constructor(series: IStiSeries, clientRectangle: RectangleD, isTopShadow: boolean, isBottomShadow: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiStackedLineSeriesGeom extends StiBaseLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        private getPointCross(point1, point2, posY);
        private drawLine(context, pen, listPoints);
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedSplineAreaSeriesGeom extends StiSeriesGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        readonly allowMouseOver: boolean;
        isMouseOver: boolean;
        private _startPoints;
        readonly startPoints: PointD[];
        private _endPoints;
        readonly endPoints: PointD[];
        contains(x: number, y: number): boolean;
        static getClientRectangle(startPoints: PointD[], endPoints: PointD[]): RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, startPoints: PointD[], endPoints: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiStackedSplineSeriesGeom extends StiBaseLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiTreemapSeriesElementGeom extends StiSeriesElementGeom {
        private _seriesBrush;
        readonly seriesBrush: StiBrush;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _animation;
        readonly animation: StiAnimation;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, clientRectangle: RectangleD, animation: StiAnimation);
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMouseOverHelper {
        static getMouseOverColor(): Color;
        static getLineMouseOverColor(): Color;
        static mouseOverLineDistance: number;
        static mouseOverSplineDistance: number;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStripsXGeom extends StiCellGeom {
        private _strip;
        readonly strip: IStiStrips;
        draw(context: StiContext): void;
        constructor(strip: IStiStrips, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStripsYGeom extends StiCellGeom {
        private _strip;
        readonly strip: IStiStrips;
        draw(context: StiContext): void;
        constructor(strip: IStiStrips, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiChartTableGeom extends StiCellGeom {
        constructor(clientRectangle: RectangleD, table: string[][], widthCellLegendTableChart: number, heightCellHeader: number, chartTable: IStiChartTable);
        private table;
        private widthCellLegendTableChart;
        private heightCellHeader;
        private chartTable;
        private pen;
        private font;
        private fontHeader;
        private labelBrush;
        private sf;
        private sfHeader;
        private labelHeaderBrush;
        draw(context: StiContext): void;
        private drawHeaderArgument(context, rect, listArgument, startFromZero);
        private drawTitleLegend(context, rect, list);
        private drawRootTable(context, rect, startFromZero);
        private checkFontSize(context, text, fontGeom, rectangleF);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTrendCurveGeom extends StiCellGeom {
        private _points;
        readonly points: PointD[];
        private _trendLine;
        readonly trendLine: IStiTrendLine;
        draw(context: StiContext): void;
        constructor(points: PointD[], trendLine: IStiTrendLine);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTrendLineGeom extends StiCellGeom {
        private trendLine;
        private pointStart;
        private pointEnd;
        draw(context: StiContext): void;
        private static getArray(pointStart, pointEnd);
        constructor(pointStart: PointD, pointEnd: PointD, trendLine: IStiTrendLine);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiChartGeom extends StiCellGeom {
        draw(context: StiContext): void;
        constructor(clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiNullableDrawing {
        static drawLines(context: StiContext, penGeom: StiPenGeom, points: PointD[], isAnimation?: boolean): void;
        static drawCurve(context: StiContext, penGeom: StiPenGeom, points: PointD[], tension: number, isAnimation?: boolean): void;
        static getPointsList(points: PointD[]): PointD[][];
        static getNullablePointsList(points: PointD[]): PointD[][];
        static getPointsList2(points1: PointD[], points2: PointD[], REFlist1: any, REFlist2: any): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiAxis implements IStiAxis {
        private static implementsStiAxis;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxis;
        private _logarithmicScale;
        logarithmicScale: boolean;
        private _core;
        core: StiAxisCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _startFromZero;
        startFromZero: boolean;
        step: number;
        private _interaction;
        interaction: IStiAxisInteraction;
        private _labels;
        labels: IStiAxisLabels;
        private _range;
        range: IStiAxisRange;
        private _title;
        title: IStiAxisTitle;
        private _ticks;
        ticks: IStiAxisTicks;
        private _arrowStyle;
        arrowStyle: StiArrowStyle;
        private _lineStyle;
        lineStyle: StiPenStyle;
        private _lineColor;
        lineColor: Color;
        private _lineWidth;
        lineWidth: number;
        private _visible;
        visible: boolean;
        titleDirection: StiLegendDirection;
        private _area;
        area: IStiAxisArea;
        private _info;
        info: StiAxisInfoXF;
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, allowApplyStyle?: boolean, logarithmicScale?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiYAxis extends StiAxis implements IStiJsonReportObject, IStiYAxis, ICloneable, IStiAxis {
        private static implementsStiYAxis;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        private _showYAxis;
        showYAxis: StiShowYAxis;
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, showYAxis?: StiShowYAxis, allowApplyStyle?: boolean, logarithmicScale?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiYRightAxis extends StiYAxis implements IStiJsonReportObject, IStiYAxis, ICloneable, IStiAxis, IStiYRightAxis {
        private static implementsStiYRightAxis;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, allowApplyStyle?: boolean, logarithmicScale?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiXAxis extends StiAxis implements IStiJsonReportObject, IStiAxis, IStiXAxis, ICloneable {
        private static implementsStiXAxis;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        private _showEdgeValues;
        showEdgeValues: boolean;
        private _showXAxis;
        showXAxis: StiShowXAxis;
        private _dateTimeStep;
        dateTimeStep: IStiAxisDateTimeStep;
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, showXAxis?: StiShowXAxis, showEdgeValues?: boolean, allowApplyStyle?: boolean, dateTimeStep?: IStiAxisDateTimeStep, logarithmicScale?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiXTopAxis extends StiXAxis implements IStiXTopAxis, ICloneable, IStiAxis, IStiXAxis, IStiJsonReportObject {
        private static implementsStiXTopAxis;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, showXAxis?: StiShowXAxis, showEdgeValues?: boolean, allowApplyStyle?: boolean, logarithmicScale?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiYLeftAxis extends StiYAxis implements IStiJsonReportObject, IStiYAxis, ICloneable, IStiAxis, IStiYLeftAxis {
        private static implementsStiYLeftAxis;
        implements(): string[];
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, showYAxis?: StiShowYAxis, allowApplyStyle?: boolean, logarithmicScale?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiAxisLabels implements IStiJsonReportObject, IStiAxisLabels, ICloneable {
        private static implementsStiAxisLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxisLabels;
        private _core;
        core: StiAxisLabelsCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _format;
        format: string;
        private _angle;
        angle: number;
        private _width;
        width: number;
        private _textBefore;
        textBefore: string;
        private _textAfter;
        textAfter: string;
        private _font;
        font: Font;
        private _antialiasing;
        antialiasing: boolean;
        private _placement;
        placement: StiLabelsPlacement;
        private _color;
        color: Color;
        private _textAlignment;
        textAlignment: StiHorAlignment;
        private _step;
        step: number;
        private _wordWrap;
        wordWrap: boolean;
        constructor(format?: string, textBefore?: string, textAfter?: string, angle?: number, font?: Font, antialiasing?: boolean, placement?: StiLabelsPlacement, color?: Color, width?: number, textAlignment?: StiHorAlignment, step?: number, allowApplyStyle?: boolean, wordWrap?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisRange implements IStiJsonReportObject, ICloneable, IStiAxisRange {
        private static implementsStiAxisRange;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxisRange;
        private _minimum;
        minimum: number;
        private _maximum;
        maximum: number;
        private _auto;
        auto: boolean;
        constructor(auto?: boolean, minimum?: number, maximum?: number);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisTicks implements IStiJsonReportObject, IStiAxisTicks, ICloneable {
        private static implementsStiAxisTicks;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxisTicks;
        private _lengthUnderLabels;
        lengthUnderLabels: number;
        private _length;
        length: number;
        private _minorLength;
        minorLength: number;
        private _minorCount;
        minorCount: number;
        private _step;
        step: number;
        private _minorVisible;
        minorVisible: boolean;
        private _visible;
        visible: boolean;
        constructor(visible?: boolean, length?: number, minorVisible?: boolean, minorLength?: number, minorCount?: number, step?: number, lengthUnderLabels?: number);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisInteraction implements IStiJsonReportObject, IStiAxisInteraction, ICloneable {
        private static implementsStiAxisInteraction;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxisInteraction;
        private _showScrollBar;
        showScrollBar: boolean;
        private _rangeScrollEnabled;
        rangeScrollEnabled: boolean;
        constructor(showScrollBar?: boolean, rangeScrollEnabled?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiAxisDateTimeStep implements IStiAxisDateTimeStep {
        private static implementsStiAxisDateTimeStep;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxisDateTimeStep;
        private _step;
        step: StiTimeDateStep;
        private _numberOfValues;
        numberOfValues: number;
        private _interpolation;
        interpolation: boolean;
        constructor(step?: StiTimeDateStep, numberOfValues?: number, interpolation?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiXBottomAxis extends StiXAxis implements IStiJsonReportObject, IStiXAxis, ICloneable, IStiXBottomAxis, IStiAxis {
        private static implementsStiXBottomAxis;
        implements(): string[];
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, showXAxis?: StiShowXAxis, showEdgeValues?: boolean, allowApplyStyle?: boolean, dateTimeStep?: IStiAxisDateTimeStep, logarithmicScale?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGridLines implements IStiJsonReportObject, IStiGridLines, ICloneable {
        private static implementsStiGridLines;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        needSetAreaJsonPropertyInternal: boolean;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiGridLines;
        private _core;
        core: StiGridLinesCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _color;
        color: Color;
        private _minorColor;
        minorColor: Color;
        private _style;
        style: StiPenStyle;
        private _minorStyle;
        minorStyle: StiPenStyle;
        private _visible;
        visible: boolean;
        private _minorVisible;
        minorVisible: boolean;
        private _minorCount;
        minorCount: number;
        private _area;
        area: IStiArea;
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, minorColor?: Color, minorStyle?: StiPenStyle, minorVisible?: boolean, minorCount?: number, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGridLinesVert extends StiGridLines implements IStiJsonReportObject, IStiGridLines, ICloneable, IStiGridLinesVert {
        private static implementsStiGridLinesVert;
        implements(): string[];
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, minorColor?: Color, minorStyle?: StiPenStyle, minorVisible?: boolean, minorCount?: number, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGridLinesHor extends StiGridLines implements IStiJsonReportObject, IStiGridLines, IStiGridLinesHor, ICloneable {
        private static implementsStiGridLinesHor;
        implements(): string[];
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, minorColor?: Color, minorStyle?: StiPenStyle, minorVisible?: boolean, minorCount?: number, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiInterlacing implements IStiInterlacing, ICloneable, IStiJsonReportObject {
        private static implementsStiInterlacing;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        needSetAreaJsonPropertyInternal: boolean;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiInterlacing;
        private _core;
        core: StiInterlacingCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _interlacedBrush;
        interlacedBrush: StiBrush;
        private _visible;
        visible: boolean;
        private _area;
        area: IStiArea;
        constructor(interlacedBrush?: StiBrush, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiInterlacingVert extends StiInterlacing implements IStiInterlacingVert {
        private static implementsStiInterlacingVert;
        implements(): string[];
        constructor(interlacedBrush?: StiBrush, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiInterlacingHor extends StiInterlacing implements IStiInterlacing, IStiInterlacingHor, IStiJsonReportObject, ICloneable {
        private static implementsStiInterlacingHor;
        implements(): string[];
        constructor(interlacedBrush?: StiBrush, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiArea extends StiService implements IStiJsonReportObject, IStiArea, ICloneable {
        private static implementsStiArea;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        static loadFromJsonObjectInternal(jObject: StiJson): IStiArea;
        static loadAreaFromXml(xmlNode: XmlNode, chart: Stimulsoft.Report.Components.StiChart): StiArea;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiArea;
        createNew(): StiArea;
        toString(): string;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        readonly serviceCategory: string;
        readonly serviceType: Stimulsoft.System.Type;
        readonly isDefaultSeriesTypeFullStackedColumnSeries: boolean;
        readonly isDefaultSeriesTypeFullStackedBarSeries: boolean;
        private _core;
        core: StiAreaCoreXF;
        private _chart;
        chart: IStiChart;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _colorEach;
        colorEach: boolean;
        private _showShadow;
        showShadow: boolean;
        private _borderColor;
        borderColor: Color;
        private _brush;
        brush: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisArea extends StiArea implements IStiJsonReportObject, IStiAxisArea, IStiArea, ICloneable {
        private static implementsStiAxisArea;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxisArea;
        readonly axisCore: StiAxisAreaCoreXF;
        private _interlacingHor;
        interlacingHor: IStiInterlacingHor;
        private _interlacingVert;
        interlacingVert: IStiInterlacingVert;
        private _gridLinesHor;
        gridLinesHor: IStiGridLinesHor;
        private _gridLinesHorRight;
        gridLinesHorRight: IStiGridLinesHor;
        private _gridLinesVert;
        gridLinesVert: IStiGridLinesVert;
        private _yAxis;
        yAxis: IStiYAxis;
        private _yRightAxis;
        yRightAxis: IStiYAxis;
        private _xAxis;
        xAxis: IStiXAxis;
        private _xTopAxis;
        xTopAxis: IStiXAxis;
        private _reverseHor;
        reverseHor: boolean;
        private _reverseVert;
        reverseVert: boolean;
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiClusteredColumnArea extends StiAxisArea implements IStiJsonReportObject, IStiClusteredColumnArea, IStiAxisArea, ICloneable, IStiArea {
        private static implementsStiClusteredColumnArea;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiScatterArea extends StiClusteredColumnArea implements IStiScatterArea, IStiArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiScatterArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiBubbleArea extends StiScatterArea implements IStiScatterArea, IStiClusteredColumnArea, IStiArea, IStiAxisArea, IStiJsonReportObject, ICloneable, IStiBubbleArea {
        private static implementsStiBubbleArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCandlestickArea extends StiClusteredColumnArea implements IStiCandlestickArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, IStiArea, ICloneable {
        private static implementsStiCandlestickArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiClusteredBarArea extends StiClusteredColumnArea implements IStiArea, IStiClusteredBarArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiClusteredBarArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAreaArea extends StiClusteredColumnArea implements IStiArea, IStiClusteredColumnArea, IStiAxisArea, IStiAreaArea, IStiJsonReportObject, ICloneable {
        private static implementsStiAreaArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiLineArea extends StiClusteredColumnArea implements IStiArea, IStiLineArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiLineArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSplineArea extends StiClusteredColumnArea implements IStiArea, IStiSplineArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiSplineArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSplineAreaArea extends StiClusteredColumnArea implements IStiArea, IStiSplineAreaArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiSplineAreaArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSteppedAreaArea extends StiClusteredColumnArea implements IStiArea, IStiSteppedAreaArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiSteppedAreaArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSteppedLineArea extends StiClusteredColumnArea implements IStiArea, IStiClusteredColumnArea, IStiAxisArea, IStiSteppedLineArea, IStiJsonReportObject, ICloneable {
        private static implementsStiSteppedLineArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiPieArea extends StiArea implements IStiJsonReportObject, IStiPieArea, IStiArea, ICloneable {
        private static implementsStiPieArea;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiDoughnutArea extends StiPieArea implements IStiJsonReportObject, IStiPieArea, IStiArea, ICloneable, IStiDoughnutArea {
        private static implementsStiDoughnutArea;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedBarArea extends StiClusteredBarArea implements IStiClusteredBarArea, IStiClusteredColumnArea, IStiArea, IStiAxisArea, IStiJsonReportObject, IStiStackedBarArea, ICloneable {
        private static implementsStiStackedBarArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedBarArea extends StiStackedBarArea implements IStiClusteredBarArea, IStiClusteredColumnArea, IStiArea, IStiAxisArea, IStiFullStackedBarArea, IStiStackedBarArea, IStiJsonReportObject, ICloneable {
        private static implementsStiFullStackedBarArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedColumnArea extends StiAxisArea implements IStiJsonReportObject, IStiStackedColumnArea, IStiAxisArea, ICloneable, IStiArea {
        private static implementsStiStackedColumnArea;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedColumnArea extends StiStackedColumnArea implements IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiFullStackedColumnArea, IStiJsonReportObject, ICloneable {
        private static implementsStiFullStackedColumnArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedAreaArea extends StiFullStackedColumnArea implements IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiFullStackedColumnArea, IStiJsonReportObject, ICloneable, IStiFullStackedAreaArea {
        private static implementsStiFullStackedAreaArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedLineArea extends StiFullStackedColumnArea implements IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiFullStackedColumnArea, IStiJsonReportObject, ICloneable, IStiFullStackedLineArea {
        private static implementsStiFullStackedLineArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedSplineArea extends StiFullStackedColumnArea implements IStiFullStackedSplineArea, IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiFullStackedColumnArea, IStiJsonReportObject, ICloneable {
        private static implementsStiFullStackedSplineArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedSplineAreaArea extends StiFullStackedColumnArea implements IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiFullStackedColumnArea, IStiFullStackedSplineAreaArea, IStiJsonReportObject, ICloneable {
        private static implementsStiFullStackedSplineAreaArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFunnelArea extends StiArea implements IStiJsonReportObject, IStiArea, ICloneable, IStiFunnelArea {
        private static implementsStiFunnelArea;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFunnelWeightedSlicesArea extends StiFunnelArea {
        readonly componentId: StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiGanttArea extends StiClusteredBarArea implements IStiClusteredBarArea, IStiClusteredColumnArea, IStiArea, IStiAxisArea, IStiJsonReportObject, IStiGanttArea, ICloneable {
        private static implementsStiGanttArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiPictorialArea extends StiArea implements IStiJsonReportObject, IStiPictorialArea, IStiArea, ICloneable {
        private static implementsStiPictorialArea;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        private _roundValues;
        roundValues: boolean;
        private _actual;
        actual: boolean;
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarArea extends StiArea implements IStiJsonReportObject, IStiRadarArea, IStiArea, ICloneable {
        private static implementsStiRadarArea;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiRadarArea;
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        private _interlacingHor;
        interlacingHor: IStiInterlacingHor;
        private _interlacingVert;
        interlacingVert: IStiInterlacingVert;
        private _gridLinesHor;
        gridLinesHor: IStiRadarGridLinesHor;
        private _gridLinesVert;
        gridLinesVert: IStiRadarGridLinesVert;
        private _radarStyle;
        radarStyle: StiRadarStyle;
        private _xAxis;
        xAxis: IStiXRadarAxis;
        private _yAxis;
        yAxis: IStiYRadarAxis;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarAreaArea extends StiRadarArea implements IStiJsonReportObject, IStiRadarArea, IStiArea, IStiRadarAreaArea, ICloneable {
        private static implementsStiRadarAreaArea;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarLineArea extends StiRadarArea implements IStiJsonReportObject, IStiRadarArea, IStiArea, ICloneable, IStiRadarLineArea {
        private static implementsStiRadarLineArea;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarPointArea extends StiRadarArea implements IStiJsonReportObject, IStiRadarPointArea, IStiRadarArea, IStiArea, ICloneable {
        private static implementsStiRadarPointArea;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRangeArea extends StiClusteredColumnArea implements IStiArea, IStiRangeArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiRangeArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRangeBarArea extends StiClusteredColumnArea implements IStiArea, IStiRangeBarArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiRangeBarArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSplineRangeArea extends StiClusteredColumnArea implements IStiArea, IStiAxisArea, IStiClusteredColumnArea, IStiSplineRangeArea, IStiJsonReportObject, ICloneable {
        private static implementsStiSplineRangeArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSteppedRangeArea extends StiClusteredColumnArea implements IStiArea, IStiClusteredColumnArea, IStiSteppedRangeArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiSteppedRangeArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedAreaArea extends StiStackedColumnArea implements IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiStackedAreaArea, IStiJsonReportObject, ICloneable {
        private static implementsStiStackedAreaArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedLineArea extends StiStackedColumnArea implements IStiStackedLineArea, IStiArea, IStiAxisArea, IStiStackedColumnArea, IStiJsonReportObject, ICloneable {
        private static implementsStiStackedLineArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedSplineArea extends StiStackedColumnArea implements IStiStackedSplineArea, IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiStackedSplineArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedSplineAreaArea extends StiStackedColumnArea implements IStiAxisArea, IStiStackedColumnArea, IStiArea, IStiStackedSplineAreaArea, IStiJsonReportObject, ICloneable {
        private static implementsStiStackedSplineAreaArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStockArea extends StiClusteredColumnArea implements IStiArea, IStiStockArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiStockArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTreemapArea extends StiArea implements IStiJsonReportObject, IStiTreemapArea, ICloneable {
        private static implementsStiTreemapArea;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiAxisTitle implements IStiAxisTitle, ICloneable, IStiJsonReportObject {
        private static implementsStiAxisTitle;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxisTitle;
        private _core;
        core: StiAxisTitleCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _font;
        font: Font;
        private _text;
        text: string;
        private _color;
        color: Color;
        private _antialiasing;
        antialiasing: boolean;
        private _alignment;
        alignment: StringAlignment;
        private _position;
        position: StiTitlePosition;
        private _direction;
        direction: StiDirection;
        constructor(font?: Font, text?: string, color?: Color, antialiasing?: boolean, alignment?: StringAlignment, direction?: StiDirection, allowApplyStyle?: boolean, position?: StiTitlePosition);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiChartTitle implements IStiChartTitle, ICloneable, IStiJsonReportObject {
        private static implementsStiChartTitle;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiChartTitle;
        private _core;
        core: StiChartTitleCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _font;
        font: Font;
        private _text;
        text: string;
        private _brush;
        brush: StiBrush;
        private _antialiasing;
        antialiasing: boolean;
        private _alignment;
        alignment: StringAlignment;
        private _dock;
        dock: StiChartTitleDock;
        private _spacing;
        spacing: number;
        private _visible;
        visible: boolean;
        private _chart;
        chart: IStiChart;
        constructor(font?: Font, text?: string, brush?: StiBrush, antialiasing?: boolean, alignment?: StringAlignment, dock?: StiChartTitleDock, spacing?: number, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiConstantLines extends StiService implements IStiConstantLines, ICloneable, IStiJsonReportObject {
        private static implementsStiConstantLines;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiConstantLines;
        readonly serviceCategory: string;
        readonly ServiceType: Stimulsoft.System.Type;
        private _core;
        core: StiConstantLinesCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _antialiasing;
        antialiasing: boolean;
        private _position;
        position: StiConstantLines_StiTextPosition;
        private _font;
        font: Font;
        private _text;
        text: string;
        private _titleVisible;
        titleVisible: boolean;
        private _orientation;
        orientation: StiConstantLines_StiOrientation;
        private _lineWidth;
        lineWidth: number;
        private _lineStyle;
        lineStyle: StiPenStyle;
        private _lineColor;
        lineColor: Color;
        private _showInLegend;
        showInLegend: boolean;
        private _showBehind;
        showBehind: boolean;
        private _axisValue;
        axisValue: string;
        private _visible;
        visible: boolean;
        private _chart;
        chart: IStiChart;
        toString(): string;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import EventArgs = Stimulsoft.System.EventArgs;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiConstantLinesCollection extends CollectionBase<IStiConstantLines> implements IStiJsonReportObject, IStiApplyStyle, IStiConstantLinesCollection {
        private static implementsStiConstantLinesCollection;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        applyStyle(style: IStiChartStyle): void;
        private getConstantLineTitle();
        private addCore(value);
        add(value: IStiConstantLines): void;
        addRange(values: IStiConstantLines[]): void;
        addRange2(values: StiConstantLinesCollection): void;
        contains(value: IStiConstantLines): boolean;
        indexOf(value: IStiConstantLines): number;
        insert(index: number, value: IStiConstantLines): void;
        onClear(): void;
        remove(value: IStiConstantLines): void;
        getByIndex(index: number): IStiConstantLines;
        setByIndex(index: number, value: IStiConstantLines): void;
        constantLinesAdded: Function;
        onConstantLinesAdded(e: EventArgs): void;
        private invokeConstantLinesAdded(sender, index);
        constantLinesRemoved: Function;
        onConstantLinesRemoved(e: EventArgs): void;
        private invokeConstantLinesRemoved(sender, index);
        private _chart;
        chart: StiChart;
        constructor();
    }
}
declare module Stimulsoft.Report.Events {
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiGetTitleEventArgs extends EventArgs {
        private valueObject;
        value: string;
        private _index;
        index: number;
        private _series;
        series: IStiSeries;
    }
}
declare module Stimulsoft.Report.Events {
    import EventArgs = Stimulsoft.System.EventArgs;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    class StiNewAutoSeriesEventArgs extends EventArgs {
        private _seriesIndex;
        seriesIndex: number;
        private _color;
        color: Object;
        private _series;
        series: IStiSeries;
        constructor(seriesIndex: number, series: IStiSeries, color: Object);
    }
}
declare module Stimulsoft.Report.Events {
    class StiProcessChartEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiChartFiltersCollection extends CollectionBase<IStiChartFilter> implements IStiJsonReportObject, ICloneable {
        private static implementsStiChartFiltersCollection;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiChartFiltersCollection;
        add(filter: StiChartFilter): void;
        addRange(filters: StiChartFiltersCollection): void;
        addRange2(filters: StiChartFilter[]): void;
        contains(filter: StiChartFilter): boolean;
        indexOf(filter: StiChartFilter): number;
        insert(index: number, filter: StiChartFilter): void;
        remove(filter: StiChartFilter): void;
        getByIndex(index: number): StiChartFilter;
        setByIndex(index: number, value: StiChartFilter): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    class StiDataItem {
        argument: Object;
        value: Object;
        valueEnd: Object;
        weight: Object;
        valueOpen: Object;
        valueClose: Object;
        valueLow: Object;
        valueHigh: Object;
        title: Object;
        key: Object;
        color: Object;
        toolTip: any;
        constructor(argument: Object, value: Object, valueEnd: Object, weight: Object, valueOpen: Object, valueClose: Object, valueLow: Object, valueHight: Object, title: Object, key: Object, color: Object, toolTip: Object);
    }
    class StiDataItemComparer implements IComparer<StiDataItem> {
        compare(x: StiDataItem, y: StiDataItem): number;
        private directionFactor;
        private sortType;
        constructor(sortType: StiSeriesSortType, sortDirection: StiSeriesSortDirection);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarGridLines implements IStiJsonReportObject, IStiRadarGridLines, ICloneable {
        private static implementsStiRadarGridLines;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        needSetAreaJsonPropertyInternal: boolean;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiRadarGridLines;
        private _core;
        core: StiRadarGridLinesCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _color;
        color: Color;
        private _style;
        style: StiPenStyle;
        private _visible;
        visible: boolean;
        private _area;
        area: IStiArea;
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarGridLinesHor extends StiRadarGridLines implements IStiJsonReportObject, IStiRadarGridLines, IStiRadarGridLinesHor, ICloneable {
        private static implementsStiRadarGridLinesHor;
        implements(): string[];
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarGridLinesVert extends StiRadarGridLines implements IStiJsonReportObject, IStiRadarGridLines, IStiRadarGridLinesVert, ICloneable {
        private static implementsStiRadarGridLinesVert;
        implements(): string[];
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiLegend implements IStiJsonReportObject, ICloneable, IStiLegend {
        private static implementsStiLegend;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiLegend;
        private _core;
        core: StiLegendCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _chart;
        chart: IStiChart;
        private _hideSeriesWithEmptyTitle;
        hideSeriesWithEmptyTitle: boolean;
        private _showShadow;
        showShadow: boolean;
        private _borderColor;
        borderColor: Color;
        private _brush;
        brush: StiBrush;
        private _titleColor;
        titleColor: Color;
        private _labelsColor;
        labelsColor: Color;
        private _direction;
        direction: StiLegendDirection;
        private _horAlignment;
        horAlignment: StiLegendHorAlignment;
        private _vertAlignment;
        vertAlignment: StiLegendVertAlignment;
        private _titleFont;
        titleFont: Font;
        private _font;
        font: Font;
        private _visible;
        visible: boolean;
        private _markerVisible;
        markerVisible: boolean;
        private _markerBorder;
        markerBorder: boolean;
        private _markerSize;
        markerSize: SizeD;
        private _markerAlignment;
        markerAlignment: StiMarkerAlignment;
        private _columns;
        columns: number;
        private _horSpacing;
        horSpacing: number;
        private _vertSpacing;
        vertSpacing: number;
        private _size;
        size: SizeD;
        private _title;
        title: string;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMarker implements IStiJsonReportObject, IStiMarker, ICloneable {
        private static implementsStiMarker;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiMarker;
        private _core;
        core: StiMarkerCoreXF;
        private _showInLegend;
        showInLegend: boolean;
        private _visible;
        visible: boolean;
        private _brush;
        brush: StiBrush;
        private _borderColor;
        borderColor: Color;
        private _size;
        size: number;
        private _angle;
        angle: number;
        private _type;
        type: StiMarkerType;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiLineMarker extends StiMarker implements IStiJsonReportObject, IStiLineMarker, IStiMarker, ICloneable {
        private static implementsStiLineMarker;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _step;
        step: number;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarAxis implements IStiJsonReportObject, IStiRadarAxis, ICloneable {
        private static implementsStiRadarAxis;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        jsonLoadFromJsonObjectArea: boolean;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiRadarAxis;
        private _core;
        core: StiRadarAxisCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _visible;
        visible: boolean;
        private _area;
        area: IStiRadarArea;
        constructor(visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiRadarAxisLabels implements IStiJsonReportObject, IStiRadarAxisLabels, ICloneable {
        private static implementsStiRadarAxisLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiRadarAxisLabels;
        private _core;
        core: StiRadarAxisLabelsCoreXF;
        private _rotationLabels;
        rotationLabels: boolean;
        private _textBefore;
        textBefore: string;
        private _textAfter;
        textAfter: string;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _drawBorder;
        drawBorder: boolean;
        private _format;
        format: string;
        private _font;
        font: Font;
        private _antialiasing;
        antialiasing: boolean;
        private _color;
        color: Color;
        private _borderColor;
        borderColor: Color;
        private _brush;
        brush: StiBrush;
        private _width;
        width: number;
        private _wordWrap;
        wordWrap: boolean;
        constructor(format?: string, font?: Font, antialiasing?: boolean, drawBorder?: boolean, color?: Color, borderColor?: Color, brush?: StiBrush, allowApplyStyle?: boolean, rotationLabels?: boolean, width?: number, wordWrap?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiXRadarAxis extends StiRadarAxis implements IStiXRadarAxis, IStiRadarAxis, ICloneable, IStiJsonReportObject {
        private static implementsStiXRadarAxis;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiXRadarAxis;
        readonly xCore: StiXRadarAxisCoreXF;
        private _labels;
        labels: IStiRadarAxisLabels;
        constructor(labels?: IStiRadarAxisLabels, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiYRadarAxis extends StiRadarAxis implements IStiYRadarAxis, IStiRadarAxis, ICloneable, IStiJsonReportObject {
        private static implementsStiYRadarAxis;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiYRadarAxis;
        readonly yCore: StiYRadarAxisCoreXF;
        private _labels;
        labels: IStiAxisLabels;
        private _ticks;
        ticks: IStiAxisTicks;
        private _lineStyle;
        lineStyle: StiPenStyle;
        private _lineColor;
        lineColor: Color;
        private _lineWidth;
        lineWidth: number;
        private _info;
        info: StiAxisInfoXF;
        constructor(labels?: IStiAxisLabels, ticks?: IStiAxisTicks, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiSeriesLabels extends StiService implements IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        private static implementsStiSeriesLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        static loadFromJsonObjectInternal(jObject: StiJson, chart: StiChart): IStiSeriesLabels;
        static loadLabelsFromXml(xmlNode: XmlNode, chart: StiChart): StiSeriesLabels;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiSeriesLabels;
        readonly serviceName: string;
        readonly serviceCategory: string;
        readonly serviceType: Stimulsoft.System.Type;
        private _preventIntersection;
        preventIntersection: boolean;
        private _core;
        core: StiSeriesLabelsCoreXF;
        readonly axisCore: StiAxisSeriesLabelsCoreXF;
        readonly pieCore: StiPieSeriesLabelsCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        conditions: StiChartConditionsCollection;
        showOnZeroValues: boolean;
        private _showZeros;
        showZeros: boolean;
        private _showNulls;
        showNulls: boolean;
        private _markerVisible;
        markerVisible: boolean;
        private _markerSize;
        markerSize: SizeD;
        private _markerAlignment;
        markerAlignment: StiMarkerAlignment;
        private _step;
        step: number;
        private _valueType;
        valueType: StiSeriesLabelsValueType;
        private _valueTypeSeparator;
        valueTypeSeparator: string;
        private _legendValueType;
        legendValueType: StiSeriesLabelsValueType;
        private _textBefore;
        textBefore: string;
        private _textAfter;
        textAfter: string;
        private _angle;
        angle: number;
        private _format;
        format: string;
        private _antialiasing;
        antialiasing: boolean;
        private _visible;
        visible: boolean;
        private _drawBorder;
        drawBorder: boolean;
        private _useSeriesColor;
        useSeriesColor: boolean;
        private _labelColor;
        labelColor: Color;
        private _borderColor;
        borderColor: Color;
        private _brush;
        brush: StiBrush;
        private _font;
        font: Font;
        private _chart;
        chart: IStiChart;
        private _wordWrap;
        wordWrap: boolean;
        private _width;
        width: number;
        toString(): string;
        createNew(): StiSeriesLabels;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisSeriesLabels extends StiSeriesLabels implements IStiJsonReportObject, IStiSeriesLabels, ICloneable, IStiAxisSeriesLabels {
        private static implementsStiAxisSeriesLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _showInPercent;
        showInPercent: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCenterAxisLabels extends StiAxisSeriesLabels implements IStiJsonReportObject, IStiSeriesLabels, IStiCenterAxisLabels, IStiAxisSeriesLabels, ICloneable {
        private static implementsStiCenterAxisLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiInsideBaseAxisLabels extends StiCenterAxisLabels implements IStiInsideBaseAxisLabels, IStiSeriesLabels, ICloneable, IStiAxisSeriesLabels, IStiJsonReportObject {
        private static implementsStiInsideBaseAxisLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiInsideEndAxisLabels extends StiCenterAxisLabels implements IStiCenterAxisLabels, IStiAxisSeriesLabels, IStiSeriesLabels, IStiJsonReportObject, IStiInsideEndAxisLabels, ICloneable {
        private static implementsStiInsideEndAxisLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiLeftAxisLabels extends StiCenterAxisLabels implements IStiCenterAxisLabels, IStiLeftAxisLabels, IStiAxisSeriesLabels, IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        private static implementsStiLeftAxisLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiOutsideAxisLabels extends StiAxisSeriesLabels implements IStiOutsideAxisLabels, IStiSeriesLabels, ICloneable, IStiAxisSeriesLabels, IStiJsonReportObject {
        private static implementsStiOutsideAxisLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _lineLength;
        lineLength: number;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiOutsideBaseAxisLabels extends StiCenterAxisLabels implements IStiCenterAxisLabels, IStiAxisSeriesLabels, IStiJsonReportObject, IStiOutsideBaseAxisLabels, IStiSeriesLabels, ICloneable {
        private static implementsStiOutsideBaseAxisLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiOutsideEndAxisLabels extends StiCenterAxisLabels implements IStiOutsideEndAxisLabels, IStiCenterAxisLabels, IStiAxisSeriesLabels, IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        private static implementsStiOutsideEndAxisLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRightAxisLabels extends StiCenterAxisLabels implements IStiCenterAxisLabels, IStiAxisSeriesLabels, IStiRightAxisLabels, IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        private static implementsStiRightAxisLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiValueAxisLabels extends StiCenterAxisLabels implements IStiValueAxisLabels, IStiCenterAxisLabels, IStiAxisSeriesLabels, IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        private static implementsStiValueAxisLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFunnelSeriesLabels extends StiSeriesLabels implements IStiJsonReportObject, IStiFunnelSeriesLabels, ICloneable, IStiSeriesLabels {
        private static implementsStiFunnelSeriesLabels;
        implements(): string[];
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCenterFunnelLabels extends StiFunnelSeriesLabels implements IStiJsonReportObject, IStiSeriesLabels, IStiFunnelSeriesLabels, ICloneable, IStiCenterFunnelLabels {
        private static implementsStiCenterFunnelLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiOutsideLeftFunnelLabels extends StiFunnelSeriesLabels implements IStiCenterFunnelLabels, IStiOutsideLeftFunnelLabels, IStiJsonReportObject, IStiSeriesLabels, IStiFunnelSeriesLabels, ICloneable {
        private static implementsStiOutsideLeftFunnelLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiOutsideRightFunnelLabels extends StiFunnelSeriesLabels implements IStiOutsideRightFunnelLabels, IStiCenterFunnelLabels, IStiJsonReportObject, IStiSeriesLabels, IStiFunnelSeriesLabels, ICloneable {
        private static implementsStiOutsideRightFunnelLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiPieSeriesLabels extends StiSeriesLabels implements IStiJsonReportObject, IStiPieSeriesLabels, IStiSeriesLabels, ICloneable {
        private static implementsStiPieSeriesLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _showInPercent;
        showInPercent: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCenterPieLabels extends StiPieSeriesLabels implements IStiJsonReportObject, IStiPieSeriesLabels, IStiSeriesLabels, IStiCenterPieLabels, ICloneable {
        private static implementsStiCenterPieLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _autoRotate;
        autoRotate: boolean;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiInsideEndPieLabels extends StiCenterPieLabels implements IStiCenterPieLabels, IStiSeriesLabels, IStiPieSeriesLabels, IStiInsideEndPieLabels, IStiJsonReportObject, ICloneable {
        private static implementsStiInsideEndPieLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiOutsidePieLabels extends StiCenterPieLabels implements IStiOutsidePieLabels, IStiCenterPieLabels, IStiPieSeriesLabels, IStiSeriesLabels, IStiJsonReportObject, ICloneable {
        private static implementsStiOutsidePieLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _showValue;
        showValue: boolean;
        private _lineLength;
        lineLength: number;
        private _lineColor;
        lineColor: Color;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTwoColumnsPieLabels extends StiOutsidePieLabels implements IStiTwoColumnsPieLabels, IStiOutsidePieLabels, IStiCenterPieLabels, IStiPieSeriesLabels, IStiSeriesLabels, IStiJsonReportObject, ICloneable {
        private static implementsStiTwoColumnsPieLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiCenterTreemapLabels extends StiAxisSeriesLabels implements IStiCenterAxisLabels {
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiNoneLabels extends StiSeriesLabels implements IStiNoneLabels, IStiSeriesLabels, ICloneable, IStiJsonReportObject {
        private static implementsStiNoneLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBubbleSeries extends StiScatterSeries implements IStiBaseLineSeries, IStiBubbleSeries, IStiScatterSeries, IStiJsonReportObject, IStiSeries, ICloneable {
        private static implementsStiBubbleSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiBubbleSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _borderColor;
        borderColor: Color;
        private _brush;
        brush: StiBrush;
        private _weights;
        weights: number[];
        weightsString: string;
        private _weightDataColumn;
        weightDataColumn: string;
        getWeight: Function;
        onGetWeight(e: StiGetValueEventArgs): void;
        invokeGetWeight(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfWeights: Function;
        onGetListOfWeights(e: StiGetValueEventArgs): void;
        invokeGetListOfWeights(sender: StiComponent, e: StiGetValueEventArgs): void;
        private _weight;
        weight: string;
        private _listOfWeights;
        listOfWeights: string;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiClusteredColumnSeries extends StiSeries implements IStiJsonReportObject, IStiClusteredColumnSeries, ICloneable, IStiSeries, IStiAllowApplyBrushNegative {
        private static implementsStiClusteredColumnSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiClusteredColumnSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        private _showZeros;
        showZeros: boolean;
        private _width;
        width: number;
        private _borderColor;
        borderColor: Color;
        private _brush;
        brush: StiBrush;
        private _brushNegative;
        brushNegative: StiBrush;
        private _allowApplyBrushNegative;
        allowApplyBrushNegative: boolean;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiClusteredBarSeries extends StiClusteredColumnSeries implements IStiJsonReportObject, IStiClusteredColumnSeries, IStiSeries, ICloneable, IStiClusteredBarSeries, IStiAllowApplyBrushNegative {
        private static implementsStiClusteredBarSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiLineSeries extends StiBaseLineSeries implements IStiJsonReportObject, IStiBaseLineSeries, IStiLineSeries, ICloneable, IStiSeries, IStiAllowApplyColorNegative {
        private static implementsStiLineSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiAreaSeries extends StiLineSeries implements IStiLineSeries, IStiBaseLineSeries, IStiAreaSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyBrushNegative {
        private static implementsStiAreaSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiAreaSeries;
        private _topmostLine;
        topmostLine: boolean;
        private _brush;
        brush: StiBrush;
        private _brushNegative;
        brushNegative: StiBrush;
        private _allowApplyBrushNegative;
        allowApplyBrushNegative: boolean;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSplineSeries extends StiBaseLineSeries implements IStiJsonReportObject, IStiBaseLineSeries, ICloneable, IStiSeries, IStiSplineSeries, IStiAllowApplyColorNegative {
        private static implementsStiSplineSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _tension;
        tension: number;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSplineAreaSeries extends StiSplineSeries implements IStiSplineSeries, IStiBaseLineSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiSplineAreaSeries, IStiAllowApplyColorNegative {
        private static implementsStiSplineAreaSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiSplineAreaSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _topmostLine;
        topmostLine: boolean;
        private _brush;
        brush: StiBrush;
        private _brushNegative;
        brushNegative: StiBrush;
        private _allowApplyBrushNegative;
        allowApplyBrushNegative: boolean;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSteppedLineSeries extends StiBaseLineSeries implements IStiJsonReportObject, IStiBaseLineSeries, IStiSeries, ICloneable, IStiSteppedLineSeries, IStiAllowApplyColorNegative {
        private static implementsStiSteppedLineSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _pointAtCenter;
        pointAtCenter: boolean;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSteppedAreaSeries extends StiSteppedLineSeries implements IStiSteppedLineSeries, IStiBaseLineSeries, IStiJsonReportObject, IStiSteppedAreaSeries, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        private static implementsStiSteppedAreaSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiSteppedAreaSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _topmostLine;
        topmostLine: boolean;
        private _brush;
        brush: StiBrush;
        private _brushNegative;
        brushNegative: StiBrush;
        private _allowApplyBrushNegative;
        allowApplyBrushNegative: boolean;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Components.Design {
    class StiSeriesInteractionConverter {
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiPieSeries extends StiSeries implements IStiPieSeries, ICloneable, IStiSeries, IStiJsonReportObject, IStiAllowApplyBorderColor, IStiAllowApplyBrush {
        private static implementsStiPieSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiPieSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _allowApplyBrush;
        allowApplyBrush: boolean;
        private _allowApplyBorderColor;
        allowApplyBorderColor: boolean;
        getArguments(): Object[];
        setArguments(value: Object[]): void;
        private _startAngle;
        startAngle: number;
        private _borderColor;
        borderColor: Color;
        private _brush;
        brush: StiBrush;
        private _lighting;
        lighting: boolean;
        private _diameter;
        diameter: number;
        private _distance;
        distance: number;
        private _cutPieListValues;
        cutPieListValues: number[];
        cuttedPieList: string;
        private _cutPieList;
        cutPieList: string;
        getCutPieList: Function;
        onGetCutPieList(e: StiGetValueEventArgs): void;
        invokeGetCutPieList(sender: StiComponent, e: StiGetValueEventArgs): void;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiDoughnutSeries extends StiPieSeries implements IStiPieSeries, IStiSeries, ICloneable, IStiDoughnutSeries, IStiJsonReportObject, IStiAllowApplyBorderColor, IStiAllowApplyBrush {
        private static implementsStiDoughnutSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCandlestickSeries extends StiSeries implements IStiJsonReportObject, IStiSeries, IStiFinancialSeries, ICloneable, IStiCandlestickSeries {
        private static implementsStiCandlestickSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiCandlestickSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _valuesOpen;
        valuesOpen: number[];
        private _valuesClose;
        valuesClose: number[];
        valuesStringOpen: string;
        valuesStringClose: string;
        valuesStringHigh: string;
        valuesStringLow: string;
        private _valuesHigh;
        valuesHigh: number[];
        private _valuesLow;
        valuesLow: number[];
        private _valueDataColumnOpen;
        valueDataColumnOpen: string;
        private _valueDataColumnClose;
        valueDataColumnClose: string;
        private _valueDataColumnHigh;
        valueDataColumnHigh: string;
        private _valueDataColumnLow;
        valueDataColumnLow: string;
        private _borderColor;
        borderColor: Color;
        private _borderColorNegative;
        borderColorNegative: Color;
        private _borderWidth;
        borderWidth: number;
        private _brush;
        brush: StiBrush;
        private _brushNegative;
        brushNegative: StiBrush;
        getValueOpen: Function;
        protected onGetValueOpen(e: StiGetValueEventArgs): void;
        invokeGetValueOpen(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesOpen: Function;
        protected onGetListOfValuesOpen(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesOpen(sender: StiComponent, e: StiGetValueEventArgs): void;
        getValueClose: Function;
        protected onGetValueClose(e: StiGetValueEventArgs): void;
        invokeGetValueClose(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesClose: Function;
        protected onGetListOfValuesClose(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesClose(sender: StiComponent, e: StiGetValueEventArgs): void;
        getValueHigh: Function;
        protected onGetValueHigh(e: StiGetValueEventArgs): void;
        invokeGetValueHigh(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesHigh: Function;
        protected onGetListOfValuesHigh(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesHigh(sender: StiComponent, e: StiGetValueEventArgs): void;
        getValueLow: Function;
        protected onGetValueLow(e: StiGetValueEventArgs): void;
        invokeGetValueLow(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesLow: Function;
        protected onGetListOfValuesLow(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesLow(sender: StiComponent, e: StiGetValueEventArgs): void;
        private valueObjOpen;
        valueOpen: string;
        private _listOfValuesOpen;
        listOfValuesOpen: string;
        private valueObjClose;
        valueClose: string;
        private _listOfValuesClose;
        listOfValuesClose: string;
        private valueObjHigh;
        valueHigh: string;
        private _listOfValuesHigh;
        listOfValuesHigh: string;
        private valueObjLow;
        valueLow: string;
        private _listOfValuesLow;
        listOfValuesLow: string;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStockSeries extends StiCandlestickSeries implements IStiJsonReportObject, IStiStockSeries, IStiFinancialSeries, ICloneable, IStiSeries, IStiAllowApplyColorNegative {
        private static implementsStiStockSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiStockSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _lineColor;
        lineColor: Color;
        private _lineStyle;
        lineStyle: StiPenStyle;
        private _lineWidth;
        lineWidth: number;
        private _lineColorNegative;
        lineColorNegative: Color;
        private _allowApplyColorNegative;
        allowApplyColorNegative: boolean;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStackedBarSeries extends StiSeries implements IStiJsonReportObject, IStiStackedBarSeries, ICloneable, IStiSeries, IStiAllowApplyBrushNegative {
        private static implementsStiStackedBarSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiStackedBarSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _showZeros;
        showZeros: boolean;
        private _width;
        width: number;
        private _borderColor;
        borderColor: Color;
        private _brush;
        brush: StiBrush;
        private _brushNegative;
        brushNegative: StiBrush;
        private _allowApplyBrushNegative;
        allowApplyBrushNegative: boolean;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedBarSeries extends StiStackedBarSeries implements IStiJsonReportObject, IStiStackedBarSeries, ICloneable, IStiSeries, IStiFullStackedBarSeries {
        private static implementsStiFullStackedBarSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStackedBaseLineSeries extends StiSeries implements IStiJsonReportObject, IStiStackedBaseLineSeries, ICloneable, IStiSeries {
        private static implementsStiStackedBaseLineSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiStackedBaseLineSeries;
        private _showNulls;
        showNulls: boolean;
        showMarker: boolean;
        markerColor: Color;
        markerSize: number;
        markerType: StiMarkerType;
        private _marker;
        marker: IStiMarker;
        private _lineMarker;
        lineMarker: IStiLineMarker;
        private _lighting;
        lighting: boolean;
        private _lineColor;
        lineColor: Color;
        private _lineWidth;
        lineWidth: number;
        private _lineStyle;
        lineStyle: StiPenStyle;
        private _lineColorNegative;
        lineColorNegative: Color;
        private _allowApplyColorNegative;
        allowApplyColorNegative: boolean;
        getDefaultAreaType(): Stimulsoft.System.Type;
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedLineSeries extends StiStackedBaseLineSeries implements IStiJsonReportObject, IStiStackedBaseLineSeries, IStiStackedLineSeries, IStiSeries, ICloneable {
        private static implementsStiStackedLineSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedAreaSeries extends StiStackedLineSeries implements ICloneable, IStiStackedBaseLineSeries, IStiStackedLineSeries, IStiJsonReportObject, IStiSeries, IStiStackedAreaSeries, IStiAllowApplyBrushNegative {
        private static implementsStiStackedAreaSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiStackedAreaSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        coreBrush: StiBrush;
        private _brush;
        brush: StiBrush;
        private _brushNegative;
        brushNegative: StiBrush;
        private _allowApplyBrushNegative;
        allowApplyBrushNegative: boolean;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedAreaSeries extends StiStackedAreaSeries implements IStiStackedAreaSeries, IStiStackedBaseLineSeries, IStiSeries, IStiJsonReportObject, IStiFullStackedAreaSeries, IStiStackedLineSeries, ICloneable, IStiAllowApplyBrushNegative {
        private static implementsStiFullStackedAreaSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStackedColumnSeries extends StiSeries implements IStiJsonReportObject, IStiStackedColumnSeries, ICloneable, IStiSeries, IStiAllowApplyBrushNegative {
        private static implementsStiStackedColumnSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiStackedColumnSeries;
        private _showZeros;
        showZeros: boolean;
        private _width;
        width: number;
        private _borderColor;
        borderColor: Color;
        private _brush;
        brush: StiBrush;
        private _brushNegative;
        brushNegative: StiBrush;
        private _allowApplyBrushNegative;
        allowApplyBrushNegative: boolean;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedColumnSeries extends StiStackedColumnSeries implements IStiFullStackedColumnSeries, IStiStackedColumnSeries, ICloneable, IStiSeries, IStiJsonReportObject, IStiAllowApplyBrushNegative {
        private static implementsStiFullStackedColumnSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedLineSeries extends StiStackedLineSeries implements IStiJsonReportObject, IStiStackedBaseLineSeries, IStiStackedLineSeries, IStiSeries, ICloneable {
        private static implementsStiFullStackedLineSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedSplineSeries extends StiStackedBaseLineSeries implements IStiJsonReportObject, IStiStackedBaseLineSeries, ICloneable, IStiSeries, IStiStackedSplineSeries, IStiAllowApplyColorNegative {
        private static implementsStiStackedSplineSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _tension;
        tension: number;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedSplineAreaSeries extends StiStackedSplineSeries implements IStiStackedSplineSeries, IStiStackedBaseLineSeries, IStiStackedSplineAreaSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyBrushNegative {
        private static implementsStiStackedSplineAreaSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiStackedSplineAreaSeries;
        private _brush;
        brush: StiBrush;
        private _brushNegative;
        brushNegative: StiBrush;
        private _allowApplyBrushNegative;
        allowApplyBrushNegative: boolean;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedSplineAreaSeries extends StiStackedSplineAreaSeries implements IStiStackedSplineSeries, IStiFullStackedSplineAreaSeries, IStiStackedBaseLineSeries, IStiStackedSplineAreaSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyBrushNegative {
        private static implementsStiFullStackedSplineAreaSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedSplineSeries extends StiStackedSplineSeries implements IStiStackedSplineSeries, IStiStackedBaseLineSeries, IStiFullStackedSplineSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        private static implementsStiFullStackedSplineSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiFunnelSeries extends StiSeries implements IStiJsonReportObject, IStiFunnelSeries, IStiSeries, ICloneable {
        private static implementsStiFunnelSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiFunnelSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _showZeros;
        showZeros: boolean;
        private _allowApplyBrush;
        allowApplyBrush: boolean;
        private _allowApplyBorderColor;
        allowApplyBorderColor: boolean;
        private _brush;
        brush: StiBrush;
        private _borderColor;
        borderColor: Color;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFunnelWeightedSlicesSeries extends StiFunnelSeries implements IStiJsonReportObject, IStiFunnelSeries, IStiFunnelWeightedSlicesSeries, IStiSeries, ICloneable {
        private static implementsStiFunnelWeightedSlicesSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        clone(): StiFunnelWeightedSlicesSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiGanttSeries extends StiClusteredBarSeries implements IStiClusteredColumnSeries, IStiClusteredBarSeries, IStiRangeSeries, IStiJsonReportObject, IStiSeries, IStiGanttSeries, ICloneable, IStiAllowApplyBrushNegative {
        private static implementsStiGanttSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiGanttSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _valuesEnd;
        valuesEnd: number[];
        valuesStringEnd: string;
        private _valueDataColumnEnd;
        valueDataColumnEnd: string;
        getValueEnd: Function;
        protected onGetValueEnd(e: StiGetValueEventArgs): void;
        invokeGetValueEnd(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesEnd: Function;
        protected onGetListOfValuesEnd(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesEnd(sender: StiComponent, e: StiGetValueEventArgs, series: StiGanttSeries): void;
        private valueObjEnd;
        valueEnd: string;
        private _listOfValuesEnd;
        listOfValuesEnd: string;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiPictorialSeries extends StiSeries implements IStiPictorialSeries, ICloneable, IStiSeries, IStiJsonReportObject {
        private static implementsStiPictorialSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _brush;
        brush: StiBrush;
        private _icon;
        icon: StiFontIcons;
        readonly componentId: StiComponentId;
        clone(): StiPictorialSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarSeries extends StiSeries implements IStiJsonReportObject, ICloneable, IStiSeries, IStiRadarSeries {
        private static implementsStiRadarSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiRadarSeries;
        private _showNulls;
        showNulls: boolean;
        private _marker;
        marker: IStiMarker;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarAreaSeries extends StiRadarSeries implements IStiRadarSeries, IStiRadarLineSeries, IStiJsonReportObject, IStiSeries, IStiRadarAreaSeries, ICloneable {
        private static implementsStiRadarAreaSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _lineColor;
        lineColor: Color;
        private _lineStyle;
        lineStyle: StiPenStyle;
        private _lighting;
        lighting: boolean;
        private _lineWidth;
        lineWidth: number;
        private _brush;
        brush: StiBrush;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarLineSeries extends StiRadarSeries implements IStiJsonReportObject, IStiRadarLineSeries, ICloneable, IStiSeries, IStiRadarSeries {
        private static implementsStiRadarLineSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _lineColor;
        lineColor: Color;
        private _lineStyle;
        lineStyle: StiPenStyle;
        private _lighting;
        lighting: boolean;
        private _lineWidth;
        lineWidth: number;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarPointSeries extends StiRadarSeries implements IStiJsonReportObject, IStiRadarPointSeries, ICloneable, IStiSeries, IStiRadarSeries {
        private static implementsStiRadarPointSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiRangeBarSeries extends StiClusteredColumnSeries implements IStiRangeBarSeries, IStiClusteredColumnSeries, IStiRangeSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyBrushNegative {
        private static implementsStiRangeBarSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiRangeBarSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _valuesEnd;
        valuesEnd: number[];
        valuesStringEnd: string;
        private _valueDataColumnEnd;
        valueDataColumnEnd: string;
        getValueEnd: Function;
        protected onGetValueEnd(e: StiGetValueEventArgs): void;
        invokeGetValueEnd(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesEnd: Function;
        protected onGetListOfValuesEnd(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesEnd(sender: StiComponent, e: StiGetValueEventArgs, series: StiRangeBarSeries): void;
        private valueObjEnd;
        valueEnd: string;
        private _listOfValuesEnd;
        listOfValuesEnd: string;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRangeSeries extends StiLineSeries implements IStiLineSeries, IStiLineRangeSeries, IStiBaseLineSeries, IStiRangeSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        private static implementsStiRangeSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiRangeSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _brush;
        brush: StiBrush;
        private _valuesEnd;
        valuesEnd: number[];
        valuesStringEnd: string;
        private _valueDataColumnEnd;
        valueDataColumnEnd: string;
        private _brushNegative;
        brushNegative: StiBrush;
        private _allowApplyBrushNegative;
        allowApplyBrushNegative: boolean;
        getValueEnd: Function;
        onGetValueEnd(e: StiGetValueEventArgs): void;
        invokeGetValueEnd(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesEnd: Function;
        onGetListOfValuesEnd(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesEnd(sender: StiComponent, e: StiGetValueEventArgs, series: StiRangeSeries): void;
        private valueObjEnd;
        valueEnd: string;
        private _listOfValuesEnd;
        listOfValuesEnd: string;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSplineRangeSeries extends StiSplineSeries implements IStiSplineSeries, IStiSplineRangeSeries, IStiBaseLineSeries, IStiRangeSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        private static implementsStiSplineRangeSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiSplineRangeSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _brush;
        brush: StiBrush;
        private _valuesEnd;
        valuesEnd: number[];
        valuesStringEnd: string;
        private _valueDataColumnEnd;
        valueDataColumnEnd: string;
        getValueEnd: Function;
        onGetValueEnd(e: StiGetValueEventArgs): void;
        invokeGetValueEnd(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesEnd: Function;
        onGetListOfValuesEnd(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesEnd(sender: StiComponent, e: StiGetValueEventArgs, series: StiSplineRangeSeries): void;
        private valueObjEnd;
        valueEnd: string;
        private _listOfValuesEnd;
        listOfValuesEnd: string;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSteppedRangeSeries extends StiSteppedLineSeries implements IStiSteppedLineSeries, IStiBaseLineSeries, IStiRangeSeries, IStiSteppedRangeSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        private static implementsStiSteppedRangeSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiSteppedRangeSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _brush;
        brush: StiBrush;
        private _valuesEnd;
        valuesEnd: number[];
        valuesStringEnd: string;
        private _valueDataColumnEnd;
        valueDataColumnEnd: string;
        private _brushNegative;
        brushNegative: StiBrush;
        private _allowApplyBrushNegative;
        allowApplyBrushNegative: boolean;
        getValueEnd: Function;
        onGetValueEnd(e: StiGetValueEventArgs): void;
        invokeGetValueEnd(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesEnd: Function;
        onGetListOfValuesEnd(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesEnd(sender: StiComponent, e: StiGetValueEventArgs, series: StiSteppedRangeSeries): void;
        private valueObjEnd;
        valueEnd: string;
        private _listOfValuesEnd;
        listOfValuesEnd: string;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiScatterSplineSeries extends StiScatterSeries implements ICloneable, IStiScatterLineSeries, IStiBaseLineSeries, IStiScatterSplineSeries, IStiJsonReportObject, IStiSeries, IStiScatterSeries, IStiAllowApplyColorNegative {
        private static implementsStiScatterSplineSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiScatterSplineSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _tension;
        tension: number;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTreemapSeries extends StiSeries implements IStiJsonReportObject, IStiTreemapSeries, ICloneable, IStiSeries {
        private static implementsStiTreemapSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiTreemapSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiSeries;
        private _borderColor;
        borderColor: Color;
        private _brush;
        brush: StiBrush;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import EventArgs = Stimulsoft.System.EventArgs;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiSeriesCollection extends CollectionBase<IStiSeries> implements IStiJsonReportObject, IStiApplyStyle, IStiSeriesCollection {
        private static implementsStiSeriesCollection;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, chart: StiChart): void;
        applyStyle(style: IStiChartStyle): void;
        private getSeriesTitle();
        private addCore(value);
        add(value: IStiSeries): void;
        addRange(values: IStiSeries[]): void;
        addRange2(values: StiSeriesCollection): void;
        contains(value: IStiSeries): boolean;
        indexOf(value: IStiSeries): number;
        insert(index: number, value: IStiSeries): void;
        onClear(): void;
        remove(value: IStiSeries): void;
        getByIndex(index: number): IStiSeries;
        setByIndex(index: number, value: IStiSeries): void;
        getByName(name: string): IStiSeries;
        setByName(index: number, value: IStiSeries): void;
        seriesAdded: Function;
        onSeriesAdded(e: EventArgs): void;
        private invokeSeriesAdded(sender, index);
        onRemove(index: number, value: Object): void;
        seriesRemoved: Function;
        onSeriesRemoved(e: EventArgs): void;
        private invokeSeriesRemoved(sender, index);
        private _chart;
        chart: StiChart;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiSeriesInteraction implements IStiSeriesInteraction, IStiJsonReportObject, ICloneable {
        private static implementsStiSeriesInteraction;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        getReport(): any;
        clone(): StiSeriesInteraction;
        readonly isDefault: boolean;
        hyperlink: string;
        tag: string;
        toolTip: string;
        hyperlinkDataColumn: string;
        tagDataColumn: string;
        toolTipDataColumn: string;
        listOfHyperlinks: string;
        listOfTags: string;
        listOfToolTips: string;
        allowSeries: boolean;
        allowSeriesElements: boolean;
        drillDownEnabled: boolean;
        drillDownReport: string;
        drillDownPage: StiPage;
        drillDownPageGuid: string;
        readonly parentComponent: StiComponent;
        parentSeries: StiSeries;
    }
}
declare module Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSeriesInteractionData {
        private _isElements;
        isElements: boolean;
        private _tag;
        readonly tag: Object;
        private _tooltip;
        readonly tooltip: string;
        private _hyperlink;
        readonly hyperlink: string;
        private _argument;
        readonly argument: Object;
        private _value;
        readonly value: number;
        private _series;
        series: IStiSeries;
        private _pointIndex;
        readonly pointIndex: number;
        private _point;
        point: PointD;
        fill(area: IStiArea, series: IStiSeries, pointIndex: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiStrips extends StiService implements IStiJsonReportObject, IStiStrips, ICloneable {
        private static implementsStiStrips;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiStrips;
        readonly serviceCategory: string;
        readonly serviceType: Stimulsoft.System.Type;
        private _core;
        core: StiStripsCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _showBehind;
        showBehind: boolean;
        private _stripBrush;
        stripBrush: StiBrush;
        private _antialiasing;
        antialiasing: boolean;
        private _font;
        font: Font;
        private _text;
        text: string;
        private _titleVisible;
        titleVisible: boolean;
        private _titleColor;
        titleColor: Color;
        private _orientation;
        orientation: StiStrips_StiOrientation;
        private _showInLegend;
        showInLegend: boolean;
        private _maxValue;
        maxValue: string;
        private _minValue;
        minValue: string;
        private _visible;
        visible: boolean;
        private _chart;
        chart: IStiChart;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import EventArgs = Stimulsoft.System.EventArgs;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiStripsCollection extends CollectionBase<IStiStrips> implements IStiJsonReportObject, IStiApplyStyle, IStiStripsCollection {
        private static implementsStiStripsCollection;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        applyStyle(style: IStiChartStyle): void;
        private getStripsTitle();
        private addCore(value);
        add(value: IStiStrips): void;
        addRange(values: IStiStrips[]): void;
        addRange2(values: StiStripsCollection): void;
        contains(value: IStiStrips): boolean;
        indexOf(value: IStiStrips): number;
        insert(index: number, value: IStiStrips): void;
        onClear(): void;
        remove(value: IStiStrips): void;
        getByIndex(index: number): IStiStrips;
        setByIndex(index: number, value: IStiStrips): void;
        stripsAdded: Function;
        onStripsAdded(e: EventArgs): void;
        private invokeStripsAdded(sender, index);
        stripsRemoved: Function;
        onStripsRemoved(e: EventArgs): void;
        private invokeStripsRemoved(sender, index);
        private _chart;
        chart: StiChart;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiChartStyle extends StiService implements IStiJsonReportObject, IStiChartStyle, ICloneable {
        private static implementsStiChartStyle;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromXml(xmlNode: XmlNode): StiChartStyle;
        static loadFromJsonObjectInternal(jObject: StiJson): StiChartStyle;
        readonly serviceName: string;
        readonly serviceCategory: string;
        readonly serviceType: Stimulsoft.System.Type;
        readonly isOffice2015Style: boolean;
        private _core;
        core: StiStyleCoreXF;
        toString(): string;
        compareChartStyle(style: StiChartStyle): boolean;
        createNew(): StiChartStyle;
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle01 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiCustomStyle extends StiStyle01 implements IStiCustomStyle {
        private static implementsStiCustomStyle;
        implements(): string[];
        readonly serviceName: string;
        readonly customCore: StiCustomStyleCoreXF;
        constructor(reportStyleName?: string);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle02 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle03 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle04 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle05 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle06 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle07 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle08 extends StiStyle03 {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle09 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle10 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle11 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle12 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle13 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle14 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle15 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle16 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle17 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle18 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle19 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle20 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle21 extends StiChartStyle {
        readonly isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle22 extends StiChartStyle {
        readonly isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle23 extends StiChartStyle {
        readonly isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle24 extends StiChartStyle {
        readonly isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle25 extends StiChartStyle {
        readonly isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle26 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle27 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle28 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiChartTable implements IStiJsonReportObject, IStiChartTable, ICloneable {
        private static implementsStiChartTable;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiChartTable;
        font: Font;
        private _visible;
        visible: boolean;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _markerVisible;
        markerVisible: boolean;
        private _gridLineColor;
        gridLineColor: Color;
        textColor: Color;
        private _gridLinesHor;
        gridLinesHor: boolean;
        private _gridLinesVert;
        gridLinesVert: boolean;
        private _gridOutline;
        gridOutline: boolean;
        private _format;
        format: string;
        private _header;
        header: IStiChartTableHeader;
        private _core;
        core: StiChartTableCoreXF;
        private _dataCells;
        dataCells: StiChartTableDataCells;
        private _chart;
        chart: IStiChart;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiChartTableDataCells implements IStiChartTableDataCells {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiChartTableDataCells;
        private _font;
        font: Font;
        private _textColor;
        textColor: Color;
        private _shrinkFontToFit;
        shrinkFontToFit: boolean;
        private _shrinkFontToFitMinimumSize;
        shrinkFontToFitMinimumSize: number;
        constructor(shrinkFontToFit?: boolean, shrinkFontToFitMinimumSize?: number, font?: Font, textColor?: Color);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiChartTableHeader implements IStiJsonReportObject, IStiChartTableHeader, ICloneable {
        private static implementsStiChartTableHeader;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiChartTableHeader;
        private _brush;
        brush: StiBrush;
        private _font;
        font: Font;
        private _textColor;
        textColor: Color;
        private _wordWrap;
        wordWrap: boolean;
        constructor(brush?: StiBrush, font?: Font, textColor?: Color, wordWrap?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSeriesTopN implements IStiJsonReportObject, IStiSeriesTopN, ICloneable {
        private static implementsStiSeriesTopN;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiSeriesTopN;
        private _mode;
        mode: StiTopNMode;
        private _count;
        count: number;
        private _showOthers;
        showOthers: boolean;
        private _othersText;
        othersText: string;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiTrendLine extends StiService implements IStiTrendLine, ICloneable, IStiJsonReportObject {
        private static implementsStiTrendLine;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromJsonObjectInternal(jObject: StiJson): IStiTrendLine;
        loadFromXml(xmlNode: XmlNode): void;
        static loadTrendLineFromXml(xmlNode: XmlNode): StiTrendLine;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiTrendLine;
        readonly serviceName: string;
        readonly serviceCategory: string;
        readonly serviceType: Stimulsoft.System.Type;
        private _core;
        core: StiTrendLineCoreXF;
        private _lineColor;
        lineColor: Color;
        private _lineWidth;
        lineWidth: number;
        private _lineStyle;
        lineStyle: StiPenStyle;
        private _showShadow;
        showShadow: boolean;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        createNew(): StiTrendLine;
        toString(): string;
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTrendLineExponential extends StiTrendLine implements IStiTrendLine, ICloneable, IStiJsonReportObject, IStiTrendLineExponential {
        private static implementsStiTrendLineExponential;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiTrendLine;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTrendLineLinear extends StiTrendLine implements IStiTrendLine, IStiTrendLineLinear, ICloneable, IStiJsonReportObject {
        private static implementsStiTrendLineLinear;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiTrendLine;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTrendLineLogarithmic extends StiTrendLine implements IStiTrendLine, IStiTrendLineLogarithmic, ICloneable, IStiJsonReportObject {
        private static implementsStiTrendLineLogarithmic;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiTrendLine;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTrendLineNone extends StiTrendLine implements IStiTrendLine, IStiTrendLineNone, IStiJsonReportObject, ICloneable {
        private static implementsStiTrendLineNone;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiTrendLine;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiChartHelper {
        static globalDurationElement: TimeSpan;
        static globalBeginTimeElement: TimeSpan;
        static fillSeriesData(series: StiSeries, items: StiDataItem[]): void;
        static getFilterData(report: StiReport, filter: StiChartFilter, filterMethodName: string): Object;
        static getFilterResult(filter: StiChartFilter, itemArgument: Object, itemValue: Object, itemValueEnd: Object, itemValueOpen: Object, itemValueClose: Object, itemValueLow: Object, itemValueHigh: Object, data: Object): boolean;
        static convertStringToColor(colorStr: string): Object;
        static createChart(masterChart: StiChart, chartComp: StiChart): void;
        static getShorterListPoints(series: StiSeries): PointD[];
        private static checkValueNaN(values);
        private static checkArgumentsDateTimeStep(series);
        private static createValuesTopN(series);
        private static getNextDate(firstDate, step);
        private static getKey(key);
        private static sortArray(REFarrayString);
        private static findIndex(array, value);
        private static getValueForDate(dateStart, dateEnd, _arguments, values);
        private static getTotalTimeSpans(step, dateMax, dateMin);
        private static isArgumentsDateTime(_arguments);
        private static maximumDate(dates);
        private static minimumDate(dates);
        private static getAutoSeriesColorFromautoSeriesColorDataColumn(masterChart, series);
        private static getAutoSeriesTitleFromAutoSeriesTitleDataColumn(masterChart, series);
        private static getAutoSeriesKeysFromAutoSeriesKeyDataColumn(masterChart, series);
        private static setTitle(masterChart, seriesIndex, series);
        private static setCutPieList(masterChart, series);
        private static getArguments(masterChart, series);
        private static getArgumentsFromArgumentExpression(masterChart, series);
        private static getArgumentsFromArgumentDataColumn(masterChart, series);
        private static getArgumentsFromListOfArguments(masterChart, series);
        private static getValues(masterChart, series);
        private static getValuesFromValueExpression(masterChart, series);
        private static getValuesFromValueDataColumn(masterChart, series);
        private static getValuesFromListOfValues(masterChart, series);
        private static getValuesEnd(masterChart, series, valueDataColumnEnd, listValuesEnd, valuesEnd);
        private static getValuesEndFromValueEndExpression(masterChart, valuesEnd, series);
        private static getValuesEndFromValueDataColumnEnd(masterChart, series, valueDataColumnEnd);
        private static getValuesEndFromListOfValuesEnd(masterChart, series, listValues);
        private static getValuesOpen(masterChart, series);
        private static getValuesOpenFromValuesOpenExpression(masterChart, series);
        private static getValuesOpenFromValueDataColumnOpen(masterChart, series);
        private static getValuesOpenFromListOfValuesOpen(masterChart, series);
        private static getValuesClose(masterChart, series);
        private static getValuesCloseFromValuesCloseExpression(masterChart, series);
        private static getValuesCloseFromValueDataColumnClose(masterChart, series);
        private static getValuesCloseFromListOfValuesClose(masterChart, series);
        private static getValuesHigh(masterChart, series);
        private static getValuesHighFromValuesHighExpression(masterChart, series);
        private static getValuesHighFromValueDataColumnHigh(masterChart, series);
        private static getValuesHighFromListOfValuesHigh(masterChart, series);
        private static getValuesLow(masterChart, series);
        private static getValuesLowFromValuesLowExpression(masterChart, series);
        private static getValuesLowFromValueDataColumnLow(masterChart, series);
        private static getValuesLowFromListOfValuesLow(masterChart, series);
        private static getWeights(masterChart, series);
        private static getWeightsWeightExpression(masterChart, series);
        private static getWeightsFromWeightDataColumn(masterChart, series);
        private static getWeightsFromListOfWeights(masterChart, series);
        private static getHyperlinks(masterChart, series);
        private static getHyperlinksFromHyperlinkExpression(masterChart, series);
        private static getHyperlinksFromHyperlinkDataColumn(masterChart, series);
        private static getHyperlinksFromListOfHyperlinks(masterChart, series);
        private static getTags(masterChart, series);
        private static getTagsFromTagExpression(masterChart, series);
        private static getTagsFromTagDataColumn(masterChart, series);
        private static getTagsFromListOfTags(masterChart, series);
        private static getToolTips(masterChart, series);
        private static getToolTipsFromToolTipExpression(masterChart, series);
        private static getToolTipsFromToolTipDataColumn(masterChart, series);
        private static getToolTipsFromListOfToolTips(masterChart, series);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    import StiText = Stimulsoft.Report.Components.StiText;
    class StiChartInfo extends StiComponentInfo implements IStiChartInfo {
        private static implementsStiChartInfo;
        implements(): string[];
        storedForProcessAtEndChart: StiChart;
        interactiveComps: StiText[];
    }
}
declare module Stimulsoft.Report.Components {
    import StiProcessChartEvent = Stimulsoft.Report.Events.StiProcessChartEvent;
    import EventArgs = Stimulsoft.System.EventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiChartConditionsCollection = Stimulsoft.Report.Chart.StiChartConditionsCollection;
    import IStiArea = Stimulsoft.Report.Chart.IStiArea;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import IStiChartTable = Stimulsoft.Report.Chart.IStiChartTable;
    import IStiChartTitle = Stimulsoft.Report.Chart.IStiChartTitle;
    import IStiLegend = Stimulsoft.Report.Chart.IStiLegend;
    import IStiSeriesLabels = Stimulsoft.Report.Chart.IStiSeriesLabels;
    import StiChartCoreXF = Stimulsoft.Report.Chart.StiChartCoreXF;
    import StiChartInfo = Stimulsoft.Report.Chart.StiChartInfo;
    import StiConstantLinesCollection = Stimulsoft.Report.Chart.StiConstantLinesCollection;
    import IStiChartStyle = Stimulsoft.Report.Chart.IStiChartStyle;
    import StiStripsCollection = Stimulsoft.Report.Chart.StiStripsCollection;
    import StiSeriesCollection = Stimulsoft.Report.Chart.StiSeriesCollection;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiImageRotation = Stimulsoft.Report.Components.StiImageRotation;
    import StiComponentType = Stimulsoft.Report.Components.StiComponentType;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiFiltersCollection = Stimulsoft.Report.Components.StiFiltersCollection;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiChart extends StiComponent implements IStiBorder, IStiBusinessObject, IStiBrush, IStiDataSource, IStiDataRelation, IStiMasterComponent, IStiSort, IStiFilter, IStiExportImage, IStiExportImageExtended, IStiIgnoryStyle, IStiGlobalizationProvider, IStiChart {
        private static implementsStiChart;
        implements(): string[];
        jsonMasterComponentTemp: string;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        convertToHInches(value: number): number;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        clone(): StiChart;
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        private _filterMethodHandler;
        filterMethodHandler: Function;
        private _filterMode;
        filterMode: StiFilterMode;
        private _filters;
        filters: StiFiltersCollection;
        filter: string;
        private _filterOn;
        filterOn: boolean;
        private _border;
        border: StiBorder;
        private _brush;
        brush: StiBrush;
        private _sort;
        sort: string[];
        readonly dataSource: StiDataSource;
        private _dataSourceName;
        dataSourceName: string;
        readonly isDataSourceEmpty: boolean;
        readonly isBusinessObjectEmpty: boolean;
        readonly businessObject: StiBusinessObject;
        private _businessObjectGuid;
        businessObjectGuid: string;
        private _masterComponent;
        masterComponent: StiComponent;
        private _countData;
        countData: number;
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        isEofValue: boolean;
        isEof: boolean;
        isBofValue: boolean;
        isBof: boolean;
        readonly isEmpty: boolean;
        positionValue: number;
        position: number;
        readonly count: number;
        private isCacheValues;
        private cachedCount;
        private cachedIsBusinessObjectEmpty;
        private cachedIsDataSourceEmpty;
        private cachedDataSource;
        private cachedBusinessObject;
        cacheValues(cache: boolean): void;
        readonly dataRelation: StiDataRelation;
        private _dataRelationName;
        dataRelationName: string;
        private _processAtEnd;
        processAtEnd: boolean;
        readonly priority: number;
        readonly localizedCategory: string;
        readonly defaultClientRectangle: RectangleD;
        readonly componentType: StiComponentType;
        readonly localizedName: string;
        invokeEvents(): void;
        protected onProcessChart(e: EventArgs): void;
        invokeProcessChart(sender: Object, e: EventArgs): void;
        processChartEvent: StiProcessChartEvent;
        private series_SeriesAdded(sender);
        private series_SeriesRemoved(sender);
        private _seriesLabelsConditions;
        seriesLabelsConditions: StiChartConditionsCollection;
        chartType: IStiArea;
        createNew(): StiComponent;
        simplifyValues(): void;
        private _core;
        core: StiChartCoreXF;
        private _rotation;
        rotation: StiImageRotation;
        private _series;
        series: StiSeriesCollection;
        private _area;
        area: IStiArea;
        private _table;
        table: IStiChartTable;
        private _style;
        style: IStiChartStyle;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _customStyleName;
        customStyleName: string;
        private _horSpacing;
        horSpacing: number;
        private _vertSpacing;
        vertSpacing: number;
        private _seriesLabels;
        seriesLabels: IStiSeriesLabels;
        private _legend;
        legend: IStiLegend;
        private _title;
        title: IStiChartTitle;
        private _strips;
        strips: StiStripsCollection;
        private _constantLines;
        constantLines: StiConstantLinesCollection;
        private _isAnimation;
        isAnimation: boolean;
        private _chartInfo;
        readonly chartInfo: StiChartInfo;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiChartOptions {
        private static _oldChartPercentMode;
        static oldChartPercentMode: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import PointD = Stimulsoft.System.Drawing.Point;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiInteractionOptions {
        private _updateContext;
        updateContext: boolean;
        private _recallEvent;
        recallEvent: boolean;
        private _recallTime;
        recallTime: TimeSpan;
        private _isRecalled;
        isRecalled: boolean;
        private _mousePoint;
        mousePoint: PointD;
        private _dragEnabled;
        dragEnabled: boolean;
        private _dragDelta;
        dragDelta: SizeD;
        private _interactionToolTip;
        interactionToolTip: string;
        private _interactionHyperlink;
        interactionHyperlink: string;
        private _seriesInteractionData;
        seriesInteractionData: StiSeriesInteractionData;
    }
}
declare module Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiPointHelper {
        private static getPointClassify(basePoint, point1, point2);
        static isPointInTriangle(p: PointD, a: PointD, b: PointD, c: PointD): boolean;
        static isPointInPolygon(p: PointD, points: PointD[]): boolean;
        static getLineOffsetRectangle(point1: PointD, point2: PointD, offset: number): PointD[];
        static isLineContainsPoint(startPoint: PointD, endPoint: PointD, offset: number, point: PointD): boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSimplifyHelper {
        private static getSquareDistance(p1, p2);
        private static getSquareSegmentDistance(p, p1, p2);
        private static simplifyRadialDistance(points, sqTolerance);
        private static simplifyDouglasPeucker(points, sqTolerance);
        static simplify(points: PointD[], tolerance: number, highestQuality: boolean): PointD[];
    }
}

declare module Stimulsoft.Report.Gauge {
    enum StiPlacement {
        Outside = 0,
        Overlay = 1,
        Inside = 2,
    }
    enum StiGaugeElemenType {
        LinearElement = 0,
        RadialElement = 1,
        All = 2,
    }
    enum StiBarRangeListType {
        LinearBar = 0,
        RadialBar = 1,
    }
    enum StiLinearRangeColorMode {
        Default = 0,
        MixedColor = 1,
    }
    enum StiRadialScaleSkin {
        Default = 0,
        Empty = 1,
        RadialScaleQuarterCircleNW = 2,
        RadialScaleQuarterCircleNE = 3,
        RadialScaleQuarterCircleSW = 4,
        RadialScaleQuarterCircleSE = 5,
        RadialScaleHalfCircleN = 6,
        RadialScaleHalfCircleS = 7,
    }
    enum StiMarkerSkin {
        Diamond = 0,
        Rectangle = 1,
        TriangleTop = 2,
        TriangleBottom = 3,
        PentagonTop = 4,
        PentagonBottom = 5,
        Ellipse = 6,
        RectangularCalloutTop = 7,
        RectangularCalloutBottom = 8,
        TriangleLeft = 9,
        TriangleRight = 10,
        PentagonLeft = 11,
        PentagonRight = 12,
        RectangularCalloutLeft = 13,
    }
    enum StiStateSkin {
        Ellipse = 0,
        Rectangle = 1,
        Diamond = 2,
    }
    enum StiLinearBarSkin {
        Default = 0,
        HorizontalThermometer = 1,
        VerticalThermometer = 2,
    }
    enum StiNeedleSkin {
        DefaultNeedle = 0,
        SpeedometerNeedle = 1,
        SpeedometerNeedle2 = 2,
        SimpleNeedle = 3,
    }
    enum StiTickMarkSkin {
        Rectangle = 0,
        Ellipse = 1,
        Diamond = 2,
        TriangleTop = 3,
        TriangleRight = 4,
        TriangleLeft = 5,
        TriangleBottom = 6,
    }
    enum StiRadiusMode {
        Auto = 0,
        Width = 1,
        Height = 2,
    }
    enum StiRadialPosition {
        TopLeft = 0,
        TopRight = 1,
        BottonLeft = 2,
        BottomRight = 3,
        TopCenter = 4,
        LeftCenter = 5,
        BottomCenter = 6,
        RightCenter = 7,
    }
    enum StiLabelRotationMode {
        None = 0,
        Automatic = 1,
        SurroundIn = 2,
        SurroundOut = 3,
    }
    enum StiGaugeStyleId {
        StiStyle25 = 0,
        StiStyle26 = 1,
        StiStyle27 = 2,
        StiStyle28 = 3,
        StiStyle29 = 4,
        StiStyle30 = 5,
    }
}
declare module Stimulsoft.Report.Gauge.Collections {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiIndicatorRangeInfo = Stimulsoft.Report.Components.Gauge.StiIndicatorRangeInfo;
    class StiBarRangeListCollection extends CollectionBase<StiIndicatorRangeInfo> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private barType;
        clone(): StiBarRangeListCollection;
        readonly isReadOnly: boolean;
        getByIndex(index: number): StiIndicatorRangeInfo;
        setByIndex(index: number, value: StiIndicatorRangeInfo): void;
        add(element: StiIndicatorRangeInfo): void;
        addRange(elements: StiIndicatorRangeInfo[]): void;
        private addCore(element);
        insert(index: number, element: StiIndicatorRangeInfo): void;
        remove(element: StiIndicatorRangeInfo): boolean;
        contains(element: StiIndicatorRangeInfo): boolean;
        copyTo(elements: StiIndicatorRangeInfo[], arrayIndex: number): void;
        indexOf(element: StiIndicatorRangeInfo): number;
        private setItemInternal(index, element);
        moveUp(element: StiIndicatorRangeInfo): boolean;
        moveDown(element: StiIndicatorRangeInfo): boolean;
        constructor(barType: StiBarRangeListType);
    }
}
declare module Stimulsoft.Report.Gauge.Collections {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiCustomValueBase = Stimulsoft.Report.Components.Gauge.StiCustomValueBase;
    class StiCustomValuesCollection extends CollectionBase<StiCustomValueBase> implements ICloneable {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiCustomValuesCollection;
        readonly isReadOnly: boolean;
        getByIndex(index: number): StiCustomValueBase;
        setByIndex(index: number, value: StiCustomValueBase): void;
        add(element: StiCustomValueBase): void;
        addRange(elements: StiCustomValueBase[]): void;
        insert(index: number, element: StiCustomValueBase): void;
        remove(element: StiCustomValueBase): boolean;
        contains(element: StiCustomValueBase): boolean;
        copyTo(elements: StiCustomValueBase[], arrayIndex: number): void;
        indexOf(element: StiCustomValueBase): number;
        private setItemInternal(index, element);
        moveUp(element: StiCustomValueBase): boolean;
        moveDown(element: StiCustomValueBase): boolean;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStateIndicatorFilter implements ICloneable {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): any;
        private _startValue;
        startValue: number;
        private _endValue;
        endValue: number;
        private _brush;
        brush: StiBrush;
        private _borderBrush;
        borderBrush: StiBrush;
        toString(): string;
    }
}
declare module Stimulsoft.Report.Gauge.Collections {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiStateIndicatorFilter = Stimulsoft.Report.Components.Gauge.StiStateIndicatorFilter;
    class StiFilterCollection extends CollectionBase<StiStateIndicatorFilter> implements ICloneable {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiFilterCollection;
        readonly isReadOnly: boolean;
        getByIndex(index: number): StiStateIndicatorFilter;
        setByIndex(index: number, value: StiStateIndicatorFilter): void;
        add(element: StiStateIndicatorFilter): void;
        addRange(elements: StiStateIndicatorFilter[]): void;
        insert(index: number, element: StiStateIndicatorFilter): void;
        remove(element: StiStateIndicatorFilter): boolean;
        contains(element: StiStateIndicatorFilter): boolean;
        copyTo(elements: StiStateIndicatorFilter[], arrayIndex: number): void;
        indexOf(element: StiStateIndicatorFilter): number;
        private setItemInternal(index, element);
        moveUp(element: StiStateIndicatorFilter): boolean;
        moveDown(element: StiStateIndicatorFilter): boolean;
    }
}
declare module Stimulsoft.Report.Gauge.Collections {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    class StiGaugeElementCollection extends CollectionBase<StiGaugeElement> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private scale;
        private scaleType;
        clone(): StiGaugeElementCollection;
        readonly isReadOnly: boolean;
        getByIndex(index: number): StiGaugeElement;
        setByIndex(index: number, value: StiGaugeElement): void;
        toArray(): StiGaugeElement[];
        private addCore(element);
        add(element: StiGaugeElement): void;
        addRange(elements: StiGaugeElement[]): void;
        insert(index: number, element: StiGaugeElement): void;
        remove(element: StiGaugeElement): boolean;
        contains(element: StiGaugeElement): boolean;
        copyTo(elements: StiGaugeElement[], arrayIndex: number): void;
        indexOf(element: StiGaugeElement): number;
        private setItemInternal(index, element);
        moveUp(element: StiGaugeElement): boolean;
        moveDown(element: StiGaugeElement): boolean;
        constructor(scale: StiScaleBase);
    }
}
declare module Stimulsoft.Report.Gauge.Collections {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiRangeBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRangeBase;
    import StiScaleRangeList = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleRangeList;
    class StiRangeCollection extends CollectionBase<StiRangeBase> implements ICloneable {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private parent;
        clone(): StiRangeCollection;
        readonly isReadOnly: boolean;
        getByIndex(index: number): StiRangeBase;
        setByIndex(index: number, value: StiRangeBase): void;
        setParent(element: StiRangeBase): void;
        clearParent(element: StiRangeBase): void;
        add(element: StiRangeBase): void;
        addRange(elements: StiRangeBase[]): void;
        insert(index: number, element: StiRangeBase): void;
        remove(element: StiRangeBase): boolean;
        contains(element: StiRangeBase): boolean;
        copyTo(elements: StiRangeBase[], arrayIndex: number): void;
        indexOf(element: StiRangeBase): number;
        private setItemInternal(index, element);
        private addInternal(element);
        moveUp(element: StiRangeBase): boolean;
        moveDown(element: StiRangeBase): boolean;
        constructor(parent: StiScaleRangeList);
    }
}
declare module Stimulsoft.Report.Gauge.Collections {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    class StiScaleCollection extends CollectionBase<StiScaleBase> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private parent;
        clone(): StiScaleCollection;
        readonly isReadOnly: boolean;
        getByIndex(index: number): StiScaleBase;
        setByIndex(index: number, value: StiScaleBase): void;
        private setParent(element);
        private clearParent(element);
        add(element: StiScaleBase): void;
        addRange(elements: StiScaleBase[]): void;
        private addRangeInternal(elements);
        insert(index: number, element: StiScaleBase): void;
        remove(element: StiScaleBase): boolean;
        onRemoveComplete(index: number, value: any): void;
        onClearComplete(): void;
        contains(element: StiScaleBase): boolean;
        copyTo(elements: StiScaleBase[], arrayIndex: number): void;
        indexOf(element: StiScaleBase): number;
        private setItemInternal(index, element);
        private addInternal(element);
        moveUp(element: StiScaleBase): boolean;
        moveDown(element: StiScaleBase): boolean;
        private invokeElementsChanged();
        constructor(parent: StiGauge);
    }
}
declare module Stimulsoft.Report.Gauge.Events {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiGetSkipIndicesEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Gauge.Events {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiGetSkipValuesEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Gauge.Events {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiGetTextEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Gauge.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiGetTextEventHandler: EventHandler;
    class StiGetTextEventArgs extends EventArgs {
        private _value;
        value: string;
    }
}
declare module Stimulsoft.Report.Gauge.Events {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiGetValueEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Gauge.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    let StiGetValueEventHandler: EventHandler;
    class StiGetValueEventArgs extends EventArgs {
        private _value;
        value: any;
    }
}
declare module Stimulsoft.Report.Gauge.Helpers {
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiDrawingHelper {
        static getRoundedPath(rect: Rectangle, offset: number, leftTop: number, rightTop: number, rightBottom: number, leftBottom: number): void;
        private static PiDiv180;
        private static FourDivThree;
        static getArcGeometry(rect: Rectangle, startAngle: number, sweepAngle: number, startWidth: number, endWidth: number): void;
        static getRadialRangeGeometry(centerPoint: Point, startAngle: number, sweepAngle: number, radius1: number, radius2: number, radius3: number, radius4: number): void;
        private static round(value);
        private static convertArcToCubicBezier(centerPoint, radius, startAngle, sweepAngle);
        private static convertArcToCubicBezier2(centerPoint, radius1, radius2, startAngle, sweepAngle);
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiApplyStyleGauge = Stimulsoft.Report.Gauge.IStiApplyStyleGauge;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiElementBase implements ICloneable, IStiApplyStyleGauge {
        applyStyle(style: IStiGaugeStyle): void;
        clone(): any;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import IStiGaugeElement = Stimulsoft.Report.Components.Gauge.IStiGaugeElement;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiGaugeElement extends StiElementBase implements IStiJsonReportObject, IStiGaugeElement {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        readonly PropName: string;
        animation: StiAnimation;
        readonly elementType: StiGaugeElemenType;
        readonly localizeName: string;
        private _scale;
        scale: StiScaleBase;
        createNew(): StiGaugeElement;
        prepareGaugeElement(): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import StiGetSkipValuesEvent = Stimulsoft.Report.Gauge.Events.StiGetSkipValuesEvent;
    import StiGetSkipIndicesEvent = Stimulsoft.Report.Gauge.Events.StiGetSkipIndicesEvent;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiTickBase extends StiGaugeElement {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiTickBase;
        onGetSkipValues(e: StiGetValueEventArgs): void;
        invokeGetSkipValues(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _getSkipValuesEvent;
        getSkipValuesEvent: StiGetSkipValuesEvent;
        onGetSkipIndices(e: StiGetValueEventArgs): void;
        invokeGetSkipIndices(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _getSkipIndicesEvent;
        getSkipIndicesEvent: StiGetSkipIndicesEvent;
        private _skipValues;
        skipValues: string;
        private _skipIndices;
        skipIndices: string;
        private _placement;
        placement: Stimulsoft.Report.Gauge.StiPlacement;
        private _skipValuesObj;
        skipValuesObj: number[];
        private _skipIndicesObj;
        skipIndicesObj: number[];
        private _offset;
        offset: number;
        private _minimumValue;
        minimumValue: number;
        private _maximumValue;
        maximumValue: number;
        readonly isSkipMajorValues: boolean;
        getPointCollection(): Hashtable;
        getMinorCollections(): Hashtable;
        getMajorCollections(): Hashtable;
        checkTickValue(skipValues: number[], skipIndices: number[], key: number, value: number): boolean;
        prepareGaugeElement(): void;
        getOffset(value: number): number;
        getPlacement(value: Stimulsoft.Report.Gauge.StiPlacement): Stimulsoft.Report.Gauge.StiPlacement;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiTickLabelBase extends StiTickBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiTickLabelBase;
        private _textFormat;
        textFormat: string;
        private _textBrush;
        textBrush: StiBrush;
        private _font;
        font: Font;
        getTextForRender(value: number, format: string): string;
        getTextForRender2(value: string, format?: string): string;
    }
}
declare module Stimulsoft.Report.Gauge.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiRectangleHelper {
        static centerX(rect: Rectangle): number;
        static centerY(rect: Rectangle): number;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import StiTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiTickLabelBase;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiLinearTickLabelBase extends StiTickLabelBase {
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiLinearTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickLabelBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiLinearTickLabelMajor extends StiLinearTickLabelBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare module Stimulsoft.Report.Gauge {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle?: number, centerPoint?: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiIndicatorBase = Stimulsoft.Report.Components.Gauge.Primitives.StiIndicatorBase;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiMarkerBaseSkin extends StiGaugeElementSkin {
        addLines(context: StiGaugeContextPainter, indicator: StiIndicatorBase, points: Point[], rect: Rectangle, angle: number, centerPoint: Point, sf: StringFormat, animation: StiAnimation): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker10Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker11Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker12Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker13Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker14Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker15Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker1Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker2Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker3Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker4Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker5Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker6Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker7Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker8Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker9Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiNeedleIndicator1Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    class StiNeedleIndicator2Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiNeedleIndicator3Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    class StiNeedleIndicator4Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiState1Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    class StiState2Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiState3Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark1Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark2Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark3Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark4Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark5Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark6Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark7Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Helpers {
    class StiGaugeSkinHelper {
        static getMarkerSkin(skin: StiMarkerSkin): StiGaugeElementSkin;
        static getTickMarkSkin(skin: StiTickMarkSkin): StiGaugeElementSkin;
        static getStateIndicatorSkin(skin: StiStateSkin): StiGaugeElementSkin;
        static getNeedleIndicatorSkin(skin: StiNeedleSkin): StiGaugeElementSkin;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiTickBase = Stimulsoft.Report.Components.Gauge.Primitives.StiTickBase;
    class StiTickMarkBase extends StiTickBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiTickMarkBase;
        private _relativeHeight;
        relativeHeight: number;
        private _relativeWidth;
        relativeWidth: number;
        private _skin;
        skin: Stimulsoft.Report.Gauge.StiTickMarkSkin;
        private _customSkin;
        customSkin: StiGaugeElementSkin;
        private _brush;
        brush: StiBrush;
        private _borderBrush;
        borderBrush: StiBrush;
        private _borderWidth;
        borderWidth: number;
        getActualSkin(): StiGaugeElementSkin;
        getRelativeWidth(value: number): number;
        getRelativeHeight(value: number): number;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiTickMarkBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiRadialTickMarkBase extends StiTickMarkBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _offsetAngle;
        offsetAngle: number;
        readonly elementType: StiGaugeElemenType;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRadialTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickMarkBase;
    import IStiTickCustom = Stimulsoft.Report.Gauge.Primitives.IStiTickCustom;
    import StiGetValueEvent = Stimulsoft.Report.Events.StiGetValueEvent;
    import StiCustomValuesCollection = Stimulsoft.Report.Gauge.Collections.StiCustomValuesCollection;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiRadialTickMarkCustom extends StiRadialTickMarkBase implements IStiTickCustom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        clone(): StiRadialTickMarkCustom;
        private _valueObj;
        valueObj: number;
        private _values;
        values: StiCustomValuesCollection;
        onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _getValueEvent;
        getValueEvent: StiGetValueEvent;
        private _value;
        value: string;
        readonly elementType: StiGaugeElemenType;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        prepareGaugeElement(): void;
        drawElement(context: StiGaugeContextPainter): void;
        private getOffsetAngle(value);
    }
}
declare module Stimulsoft.Report.Gauge.Helpers {
    class StiMathHelper {
        static length1(value1: number, value2: number): number;
        static maxMinusMin(value1: number, value2: number): number;
        static getMax(...list: number[]): number;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import StiGraphicsPathLinesGaugeGeom = Stimulsoft.Report.Gauge.GaugeGeoms.StiGraphicsPathLinesGaugeGeom;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import IStiScaleBarGeometry = Stimulsoft.Report.Gauge.Primitives.IStiScaleBarGeometry;
    import Size = Stimulsoft.System.Drawing.Size;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiLinearBarGeometry implements IStiScaleBarGeometry {
        private scale;
        private _size;
        readonly size: Size;
        private _rectGeometry;
        readonly rectGeometry: Rectangle;
        readonly radius: number;
        readonly diameter: number;
        private _center;
        readonly center: Point;
        checkRectGeometry(rect: Rectangle): void;
        private getRectGeometry(rect, value);
        getRestToLenght(): number;
        private checkMinMaxWidth(REFstartWidth, REFendWidth);
        drawScaleGeometry(context: StiGaugeContextPainter): void;
        drawGeometry(context: StiGaugeContextPainter, startValue1: number, endValue1: number, startWidth: number, endWidth: number, offset: number, placement: StiPlacement, REFrect: any, returnOnlyRect: boolean): StiGraphicsPathLinesGaugeGeom;
        drawPrimitiveGeometry(context: StiGaugeContextPainter, rect: Rectangle, minAscent: number, maxAscent: number, startWidth: number, endWidth: number, placement: StiPlacement, restOffset: number, isStartGreaterEnd: boolean): StiGraphicsPathLinesGaugeGeom;
        constructor(scale: StiLinearScale);
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import EventArgs = Stimulsoft.System.EventArgs;
    import IStiScaleBarGeometry = Stimulsoft.Report.Gauge.Primitives.IStiScaleBarGeometry;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiGaugeElementCollection = Stimulsoft.Report.Gauge.Collections.StiGaugeElementCollection;
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiScaleBase = Stimulsoft.Report.Components.Gauge.IStiScaleBase;
    class StiScaleHelper {
        actualMinimum: number;
        actualMaximum: number;
        minWidth: number;
        maxWidth: number;
        private _totalLength;
        totalLength: number;
    }
    class StiScaleBase extends StiElementBase implements IStiJsonReportObject, IStiScaleBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiScaleBase;
        barGeometry: IStiScaleBarGeometry;
        scaleHelper: StiScaleHelper;
        readonly isUp: boolean;
        private _gauge;
        gauge: StiGauge;
        private _left;
        left: number;
        private _top;
        top: number;
        private _startWidth;
        startWidth: number;
        private _endWidth;
        endWidth: number;
        private _majorInterval;
        majorInterval: number;
        private _minorInterval;
        minorInterval: number;
        private _minimum;
        minimum: number;
        private _maximum;
        maximum: number;
        private _isReversed;
        isReversed: boolean;
        private _brush;
        brush: StiBrush;
        private _borderBrush;
        borderBrush: StiBrush;
        _items: StiGaugeElementCollection;
        readonly items: StiGaugeElementCollection;
        set(value: StiGaugeElementCollection): void;
        readonly scaleType: StiGaugeElemenType;
        prepare(gauge: StiGauge): void;
        private calculateMinMaxScaleHelper();
        private calculateWidthScaleHelper();
        getPosition(value: number): number;
        interactiveClick(e: EventArgs): void;
        createNew(): StiScaleBase;
        drawElement(context: StiGaugeContextPainter): void;
        constructor();
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import EventArgs = Stimulsoft.System.EventArgs;
    import Orientation = Stimulsoft.System.Windows.Forms.Orientation;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiLinearScale extends StiScaleBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private _orientation;
        orientation: Orientation;
        private _relativeHeight;
        relativeHeight: number;
        readonly scaleType: Stimulsoft.Report.Gauge.StiGaugeElemenType;
        interactiveClick(e: EventArgs): void;
        createNew(): StiScaleBase;
        constructor();
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    import IStiCustomValueBase = Stimulsoft.Report.Components.Gauge.IStiCustomValueBase;
    class StiCustomValueBase implements ICloneable, IStiCustomValueBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): any;
        private _value;
        value: number;
        private _placement;
        placement: StiPlacement;
        private _offset;
        offset: number;
        readonly localizedName: string;
        createNew(): StiCustomValueBase;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiCustomValueBase = Stimulsoft.Report.Components.Gauge.StiCustomValueBase;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    class StiRadialTickMarkCustomValue extends StiCustomValueBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        clone(): StiRadialTickMarkCustomValue;
        useBrush: boolean;
        useBorderBrush: boolean;
        useBorderWidth: boolean;
        private _relativeWidth;
        relativeWidth: number;
        private _relativeHeight;
        relativeHeight: number;
        private _offsetAngle;
        offsetAngle: number;
        private _skin;
        skin: StiGaugeElementSkin;
        private _brush;
        brush: StiBrush;
        private _borderBrush;
        borderBrush: StiBrush;
        private _borderWidth;
        borderWidth: number;
        readonly localizedName: string;
        toString(): string;
        createNew(): StiCustomValueBase;
        constructor(value?: number, offset?: number, relativeWidth?: number, relativeHeight?: number, offsetAngle?: number, placement?: StiPlacement, brush?: StiBrush, borderBrush?: StiBrush, borderWidth?: number, skin?: StiGaugeElementSkin);
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRadialTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickMarkBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiRadialTickMarkMajor extends StiRadialTickMarkBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        readonly elementType: StiGaugeElemenType;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRadialTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickMarkBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiRadialTickMarkMinor extends StiRadialTickMarkBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private _skipMajorValues;
        skipMajorValues: boolean;
        readonly isSkipMajorValues: boolean;
        readonly elementType: StiGaugeElemenType;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiBarRangeListType = Stimulsoft.Report.Gauge.StiBarRangeListType;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiIndicatorRangeInfo = Stimulsoft.Report.Components.Gauge.IStiIndicatorRangeInfo;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiIndicatorRangeInfo implements ICloneable, IStiIndicatorRangeInfo {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, report: StiReport): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): any;
        private _value;
        value: number;
        readonly rangeListType: StiBarRangeListType;
        createNew(): StiIndicatorRangeInfo;
    }
}
declare module Stimulsoft.Report.Gauge.Helpers {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMixedColorHelper {
        static colorMixed(colors: Color[]): Color;
        private static colorMixer(c1, c2);
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiGetValueEvent = Stimulsoft.Report.Events.StiGetValueEvent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    class StiIndicatorBase extends StiGaugeElement {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiIndicatorBase;
        private _valueObj;
        valueObj: number;
        private _placement;
        placement: Stimulsoft.Report.Gauge.StiPlacement;
        private _brush;
        brush: StiBrush;
        private _borderBrush;
        borderBrush: StiBrush;
        private _borderWidth;
        borderWidth: number;
        onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _getValueEvent;
        getValueEvent: StiGetValueEvent;
        private _value;
        value: string;
        prepareGaugeElement(): void;
        interactiveClick(rect: Rectangle, p: Point): void;
        onValueChanged(): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiBarRangeListCollection = Stimulsoft.Report.Gauge.Collections.StiBarRangeListCollection;
    import StiBarRangeListType = Stimulsoft.Report.Gauge.StiBarRangeListType;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiBarBase extends StiIndicatorBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiBarBase;
        private _emptyBrush;
        emptyBrush: StiBrush;
        private _emptyBorderBrush;
        emptyBorderBrush: StiBrush;
        private _emptyBorderWidth;
        emptyBorderWidth: number;
        private _offset;
        offset: number;
        private _startWidth;
        startWidth: number;
        private _endWidth;
        endWidth: number;
        private _useRangeColor;
        useRangeColor: boolean;
        private _rangeList;
        rangeList: StiBarRangeListCollection;
        readonly barType: StiBarRangeListType;
        onRangeColorChanged(): void;
        checkActualBrushForTopGeometry(): void;
        onValueChanged(): void;
        constructor();
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBarBase = Stimulsoft.Report.Components.Gauge.Primitives.StiBarBase;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiLinearBar extends StiBarBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, report: StiReport): void;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private colorModeHelper;
        private actualBackground;
        private _skin;
        skin: Stimulsoft.Report.Gauge.StiLinearBarSkin;
        private _rangeColorMode;
        rangeColorMode: Stimulsoft.Report.Gauge.StiLinearRangeColorMode;
        onRangeColorChanged(): void;
        readonly barType: Stimulsoft.Report.Gauge.StiBarRangeListType;
        readonly localizeName: string;
        checkActualBrushForTopGeometry(): void;
        private getRangeBrush();
        createNew(): StiGaugeElement;
        interactiveClick(rect: Rectangle, p: Point): void;
        drawElement(context: StiGaugeContextPainter): void;
        private drawHorizontalThermometer(context);
        private drawVerticalThermometer(context);
        private getGeometryHelperForTopIndicator(value);
        private getTopGeometry(helper, REFrect);
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiBarRangeListType = Stimulsoft.Report.Gauge.StiBarRangeListType;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiLinearIndicatorRangeInfo extends StiIndicatorRangeInfo {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, report: StiReport): void;
        readonly componentId: StiComponentId;
        private _color;
        color: Color;
        private _brush;
        brush: StiBrush;
        readonly rangeListType: StiBarRangeListType;
        createNew(): StiIndicatorRangeInfo;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import IStiGaugeMarker = Stimulsoft.Report.Gauge.IStiGaugeMarker;
    class StiMarkerBase extends StiIndicatorBase implements IStiGaugeMarker {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiMarkerBase;
        private _offset;
        offset: number;
        private _relativeWidth;
        relativeWidth: number;
        private _relativeHeight;
        relativeHeight: number;
        private _skin;
        skin: Stimulsoft.Report.Gauge.StiMarkerSkin;
        private _customSkin;
        customSkin: StiGaugeElementSkin;
        private _format;
        format: string;
        private _showValue;
        showValue: boolean;
        private _textBrush;
        textBrush: StiBrush;
        private _font;
        font: Font;
        getActualSkin(): StiGaugeElementSkin;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiMarkerBase = Stimulsoft.Report.Components.Gauge.Primitives.StiMarkerBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiLinearMarker extends StiMarkerBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        drawElement(context: StiGaugeContextPainter): void;
        private getRectangle(value);
        interactiveClick(rect: Rectangle, p: Point): void;
        private getBarPosition(orientation, value);
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import Point = Stimulsoft.System.Drawing.Point;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiIndicatorBase = Stimulsoft.Report.Components.Gauge.Primitives.StiIndicatorBase;
    class StiNeedle extends StiIndicatorBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private _format;
        format: string;
        private _showValue;
        showValue: boolean;
        private _textBrush;
        textBrush: StiBrush;
        private _font;
        font: Font;
        private _capBrush;
        capBrush: StiBrush;
        private _capBorderBrush;
        capBorderBrush: StiBrush;
        private _capBorderWidth;
        capBorderWidth: number;
        private _offsetNeedle;
        offsetNeedle: number;
        private _startWidth;
        startWidth: number;
        private _endWidth;
        endWidth: number;
        private _autoCalculateCenterPoint;
        autoCalculateCenterPoint: boolean;
        private _centerPoint;
        centerPoint: Point;
        private _relativeHeight;
        relativeHeight: number;
        private _relativeWidth;
        relativeWidth: number;
        private _skin;
        skin: Stimulsoft.Report.Gauge.StiNeedleSkin;
        private _customSkin;
        customSkin: StiGaugeElementSkin;
        readonly elementType: StiGaugeElemenType;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        drawElement(context: StiGaugeContextPainter): void;
        interactiveClick(rect: Rectangle, p: Point): void;
        private getActualCenterPoint();
        private getActualSkin();
        constructor();
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBarBase = Stimulsoft.Report.Components.Gauge.Primitives.StiBarBase;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiRadialBar extends StiBarBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private actualBush;
        private colorModeHelper;
        readonly elementType: StiGaugeElemenType;
        readonly barType: Stimulsoft.Report.Gauge.StiBarRangeListType;
        readonly localizeName: string;
        checkActualBrushForTopGeometry(): void;
        createNew(): StiGaugeElement;
        drawElement(context: StiGaugeContextPainter): void;
        onRangeColorChanged(): void;
        interactiveClick(rect: Rectangle, p: Point): void;
        private getRangeGeometry(context, scale, bg, bb, bw, startValue, endValue);
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiBarRangeListType = Stimulsoft.Report.Gauge.StiBarRangeListType;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiRadialIndicatorRangeInfo extends StiIndicatorRangeInfo {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        private _brush;
        brush: StiBrush;
        readonly rangeListType: StiBarRangeListType;
        createNew(): StiIndicatorRangeInfo;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiMarkerBase = Stimulsoft.Report.Components.Gauge.Primitives.StiMarkerBase;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiRadialMarker extends StiMarkerBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        readonly elementType: StiGaugeElemenType;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        drawElement(context: StiGaugeContextPainter): void;
        interactiveClick(rect: Rectangle, p: Point): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiFilterCollection = Stimulsoft.Report.Gauge.Collections.StiFilterCollection;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiIndicatorBase = Stimulsoft.Report.Components.Gauge.Primitives.StiIndicatorBase;
    import IStiGaugeMarker = Stimulsoft.Report.Gauge.IStiGaugeMarker;
    class StiStateIndicator extends StiIndicatorBase implements IStiGaugeMarker {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        private lastFilter;
        private _format;
        format: string;
        private _showValue;
        showValue: boolean;
        private _textBrush;
        textBrush: StiBrush;
        private _font;
        font: Font;
        readonly elementType: Stimulsoft.Report.Gauge.StiGaugeElemenType;
        readonly localizeName: string;
        private _filters;
        filters: StiFilterCollection;
        private _left;
        left: number;
        private _top;
        top: number;
        private _relativeWidth;
        relativeWidth: number;
        private _relativeHeight;
        relativeHeight: number;
        private _skin;
        skin: Stimulsoft.Report.Gauge.StiStateSkin;
        private _customSkin;
        customSkin: Stimulsoft.Report.Gauge.StiGaugeElementSkin;
        createNew(): StiGaugeElement;
        onValueChanged(): void;
        interactiveClick(rect: Rectangle, p: Point): void;
        drawElement(context: StiGaugeContextPainter): void;
        getActualSkin(): Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import StiGraphicsPathLinesGaugeGeom = Stimulsoft.Report.Gauge.GaugeGeoms.StiGraphicsPathLinesGaugeGeom;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import Size = Stimulsoft.System.Drawing.Size;
    import IStiScaleBarGeometry = Stimulsoft.Report.Gauge.Primitives.IStiScaleBarGeometry;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiRadialBarGeometry implements IStiScaleBarGeometry {
        private scale;
        private _size;
        readonly size: Size;
        private _rectGeometry;
        readonly rectGeometry: Rectangle;
        private _radius;
        readonly radius: number;
        private _diameter;
        readonly diameter: number;
        private _center;
        readonly center: Point;
        checkRectGeometry(rect: Rectangle): void;
        drawScaleGeometry(context: StiGaugeContextPainter): void;
        getRestToLenght(): number;
        drawGeometry(context: StiGaugeContextPainter, startValue: number, endValue: number, startWidth: number, endWidth: number, offset: number, placement: StiPlacement, REFrect: any, returnOnlyRect: boolean): StiGraphicsPathLinesGaugeGeom;
        constructor(scale: StiRadialScale);
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import EventArgs = Stimulsoft.System.EventArgs;
    import Point = Stimulsoft.System.Drawing.Point;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    class StiRadialScale extends StiScaleBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        clone(): StiRadialScale;
        applyStyle(style: IStiGaugeStyle): void;
        private _radius;
        radius: number;
        private _radiusMode;
        radiusMode: Stimulsoft.Report.Gauge.StiRadiusMode;
        private _center;
        center: Point;
        private _startAngle;
        startAngle: number;
        private _sweepAngle;
        sweepAngle: number;
        private _skin;
        skin: Stimulsoft.Report.Gauge.StiRadialScaleSkin;
        readonly scaleType: Stimulsoft.Report.Gauge.StiGaugeElemenType;
        getRadius(): number;
        getStartWidth(): number;
        getEndWidth(): number;
        getSweepAngle(): number;
        getCurrentAngle(angle: number): number;
        interactiveClick(e: EventArgs): void;
        createNew(): StiScaleBase;
        constructor();
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import IStiRangeBase = Stimulsoft.Report.Components.Gauge.IStiRangeBase;
    class StiRangeBase implements ICloneable, IStiRangeBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiRangeBase;
        private _brush;
        brush: StiBrush;
        private _borderBrush;
        borderBrush: StiBrush;
        private _borderWidth;
        borderWidth: number;
        private _startValue;
        startValue: number;
        private _endValue;
        endValue: number;
        private _startWidth;
        startWidth: number;
        private _endWidth;
        endWidth: number;
        private _placement;
        placement: StiPlacement;
        private _offset;
        offset: number;
        private _rangeList;
        rangeList: StiScaleRangeList;
        readonly localizeName: string;
        drawRange(context: StiGaugeContextPainter, scale: StiScaleBase): void;
        createNew(): StiRangeBase;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRangeBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRangeBase;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    class StiLinearRange extends StiRangeBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        drawRange(context: StiGaugeContextPainter, scale: StiScaleBase): void;
        readonly localizeName: string;
        createNew(): StiRangeBase;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRangeCollection = Stimulsoft.Report.Gauge.Collections.StiRangeCollection;
    class StiScaleRangeList extends StiGaugeElement {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        clone(): StiScaleRangeList;
        private _ranges;
        ranges: StiRangeCollection;
        constructor();
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiScaleRangeList = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleRangeList;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiLinearRangeList extends StiScaleRangeList {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        createNew(): StiGaugeElement;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRangeBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRangeBase;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiRadialRange extends StiRangeBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        private _useValuesFromTheSpecifiedRange;
        useValuesFromTheSpecifiedRange: boolean;
        readonly localizeName: string;
        drawRange(context: StiGaugeContextPainter, scale: StiScaleBase): void;
        createNew(): StiRangeBase;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiScaleRangeList = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleRangeList;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    class StiRadialRangeList extends StiScaleRangeList {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        readonly elementType: StiGaugeElemenType;
        createNew(): StiGaugeElement;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiLinearTickMarkBase extends StiTickMarkBase {
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGetValueEvent = Stimulsoft.Report.Events.StiGetValueEvent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiLinearTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickMarkBase;
    import IStiTickCustom = Stimulsoft.Report.Gauge.Primitives.IStiTickCustom;
    import StiCustomValuesCollection = Stimulsoft.Report.Gauge.Collections.StiCustomValuesCollection;
    class StiLinearTickMarkCustom extends StiLinearTickMarkBase implements IStiTickCustom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        clone(): StiLinearTickMarkCustom;
        private _valueObj;
        valueObj: number;
        private _values;
        values: StiCustomValuesCollection;
        readonly localizeName: string;
        onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _getValueEvent;
        getValueEvent: StiGetValueEvent;
        private _value;
        value: string;
        createNew(): StiGaugeElement;
        prepareGaugeElement(): void;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    class StiLinearTickMarkCustomValue extends StiCustomValueBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        private _relativeWidth;
        relativeWidth: number;
        private _relativeHeight;
        get(): number;
        relativeHeight: number;
        private _skin;
        skin: StiGaugeElementSkin;
        readonly localizedName: string;
        toString(): string;
        createNew(): StiCustomValueBase;
        constructor(value?: number, offset?: number, relativeWidth?: number, relativeHeight?: number, placement?: StiPlacement, skin?: StiGaugeElementSkin);
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiLinearTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickMarkBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiLinearTickMarkMajor extends StiLinearTickMarkBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiLinearTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickMarkBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiLinearTickMarkMinor extends StiLinearTickMarkBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private _skipMajorValues;
        skipMajorValues: boolean;
        readonly isSkipMajorValues: boolean;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import StiTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiTickLabelBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Point = Stimulsoft.System.Drawing.Point;
    import Size = Stimulsoft.System.Drawing.Size;
    class StiRadialTickLabelBase extends StiTickLabelBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _labelRotationMode;
        labelRotationMode: Stimulsoft.Report.Gauge.StiLabelRotationMode;
        private _offsetAngle;
        offsetAngle: number;
        readonly elementType: StiGaugeElemenType;
        drawElement(context: StiGaugeContextPainter): void;
        getMatrixRotation(context: StiGaugeContextPainter, centerPoint: Point, textSize: Size, rotateMode: Stimulsoft.Report.Gauge.StiLabelRotationMode, radius: number, angle: number, REFposition: any): number;
        private getRadialPosition(angle);
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiGetTextEventArgs = Stimulsoft.Report.Gauge.Events.StiGetTextEventArgs;
    import StiGetTextEvent = Stimulsoft.Report.Gauge.Events.StiGetTextEvent;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiGetValueEvent = Stimulsoft.Report.Events.StiGetValueEvent;
    import StiCustomValuesCollection = Stimulsoft.Report.Gauge.Collections.StiCustomValuesCollection;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRadialTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickLabelBase;
    import IStiTickCustom = Stimulsoft.Report.Gauge.Primitives.IStiTickCustom;
    class StiRadialTickLabelCustom extends StiRadialTickLabelBase implements IStiTickCustom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        clone(): StiRadialTickLabelCustom;
        private _valueObj;
        valueObj: number;
        private _textObj;
        textObj: string;
        private _values;
        values: StiCustomValuesCollection;
        readonly elementType: StiGaugeElemenType;
        readonly localizeName: string;
        onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _getValueEvent;
        getValueEvent: StiGetValueEvent;
        onGetText(e: StiGetTextEventArgs): void;
        invokeGetText(sender: StiGaugeElement, e: StiGetTextEventArgs): void;
        private _getTextEvent;
        getTextEvent: StiGetTextEvent;
        private _value;
        value: string;
        private _text;
        text: string;
        createNew(): StiGaugeElement;
        prepareGaugeElement(): void;
        drawElement(context: StiGaugeContextPainter): void;
        private getOffsetAngle(value);
        private getLabelRotationMode(value);
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiLabelRotationMode = Stimulsoft.Report.Gauge.StiLabelRotationMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    class StiRadialTickLabelCustomValue extends StiCustomValueBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        private _text;
        text: string;
        private _offsetAngle;
        offsetAngle: number;
        private _labelRotationMode;
        labelRotationMode: StiLabelRotationMode;
        readonly localizedName: string;
        toString(): string;
        createNew(): StiCustomValueBase;
        constructor(value?: number, text?: string, offset?: number, offsetAngle?: number, labelRotationMode?: StiLabelRotationMode, placement?: StiPlacement);
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRadialTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickLabelBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiRadialTickLabelMajor extends StiRadialTickLabelBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        readonly elementType: StiGaugeElemenType;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRadialTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickLabelBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiRadialTickLabelMinor extends StiRadialTickLabelBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private _skipMajorValues;
        skipMajorValues: boolean;
        readonly isSkipMajorValues: boolean;
        readonly elementType: StiGaugeElemenType;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare module Stimulsoft.Report.Gauge.Helpers {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    class StiGaugeHelper {
        static globalDurationElement: TimeSpan;
        static globalBeginTimeElement: TimeSpan;
        static getFloatValueFromObject(valueObj: any, scale: StiScaleBase): number;
        static getFloatValueFromObject2(valueObj: any, defaultValue: number): number;
        static getFloatArrayValueFromString(value: any): number[];
        private static initializeGauge(gauge, width, height);
        private static initializeName(gauge, report);
        static checkGaugeName(gauge: StiGauge): void;
        static simpleRadialGauge(gauge: StiGauge, report: StiReport): void;
        static radialTwoScalesGauge(gauge: StiGauge, report: StiReport): void;
        static radialBarGauge(gauge: StiGauge, report: StiReport): void;
        static simpleTwoBarGauge(gauge: StiGauge, report: StiReport): void;
        static defaultRadialGauge(gauge: StiGauge, report: StiReport): void;
        static defaultLinearGauge(gauge: StiGauge, report: StiReport): void;
        static linearGaugeRangeList(gauge: StiGauge, report: StiReport): void;
        static bulletGraphsGreen(gauge: StiGauge, report: StiReport): void;
        static halfDonutsGauge(gauge: StiGauge, report: StiReport): void;
        static halfDonutsGauge2(gauge: StiGauge, report: StiReport): void;
        static radialGaugeHalfCircleN(gauge: StiGauge, report: StiReport): void;
        static radialGaugeHalfCircleS(gauge: StiGauge, report: StiReport): void;
        static radialGaugeQuarterCircleNW(gauge: StiGauge, report: StiReport): void;
        static radialGaugeQuarterCircleNE(gauge: StiGauge, report: StiReport): void;
        static radialGaugeQuarterCircleSW(gauge: StiGauge, report: StiReport): void;
        static radialGaugeQuarterCircleSE(gauge: StiGauge, report: StiReport): void;
        private static radialGaugeQuarterCircle(gauge, report, scaleSkin, startAngle, center);
        static horizontalThermometer(gauge: StiGauge, report: StiReport): void;
        static verticalThermometer(gauge: StiGauge, report: StiReport): void;
        static lightSpeedometer(gauge: StiGauge, report: StiReport): void;
        static darkSpeedometer(gauge: StiGauge, report: StiReport): void;
    }
}
declare module Stimulsoft.Report.Gauge.Primitives {
    import StiGraphicsPathLinesGaugeGeom = Stimulsoft.Report.Gauge.GaugeGeoms.StiGraphicsPathLinesGaugeGeom;
    import Size = Stimulsoft.System.Drawing.Size;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    var IStiScaleBarGeometry: string;
    interface IStiScaleBarGeometry {
        size: Size;
        rectGeometry: Rectangle;
        center: Point;
        radius: number;
        diameter: number;
        checkRectGeometry(rect: Rectangle): any;
        drawScaleGeometry(context: StiGaugeContextPainter): any;
        getRestToLenght(): number;
        drawGeometry(context: StiGaugeContextPainter, startValue: number, endValue: number, startWidth: number, endWidth: number, offset: number, placement: StiPlacement, REFrect: any, returnOnlyRect: boolean): StiGraphicsPathLinesGaugeGeom;
    }
}
declare module Stimulsoft.Report.Gauge.Primitives {
    import StiCustomValuesCollection = Stimulsoft.Report.Gauge.Collections.StiCustomValuesCollection;
    var IStiTickCustom: string;
    interface IStiTickCustom {
        valueObj: number;
        values: StiCustomValuesCollection;
    }
}
declare module Stimulsoft.Report.Gauge {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    class StiGaugeStyleCoreXF {
        readonly localizedName: string;
        readonly brush: StiBrush;
        readonly borderColor: Color;
        readonly borderWidth: number;
        readonly tickMarkMajorBrush: StiBrush;
        readonly tickMarkMajorBorder: StiBrush;
        readonly tickMarkMajorBorderWidth: number;
        readonly tickMarkMinorBrush: StiBrush;
        readonly tickMarkMinorBorder: StiBrush;
        readonly tickMarkMinorBorderWidth: number;
        readonly tickLabelMajorTextBrush: StiBrush;
        readonly tickLabelMajorFont: Font;
        readonly tickLabelMinorTextBrush: StiBrush;
        readonly tickLabelMinorFont: Font;
        readonly linearBarBrush: StiBrush;
        readonly linearBarBorderBrush: StiBrush;
        readonly linearBarEmptyBrush: StiBrush;
        readonly linearBarEmptyBorderBrush: StiBrush;
        readonly linearBarStartWidth: number;
        readonly linearBarEndWidth: number;
        readonly radialBarBrush: StiBrush;
        readonly radialBarBorderBrush: StiBrush;
        readonly radialBarEmptyBrush: StiBrush;
        readonly radialBarEmptyBorderBrush: StiBrush;
        readonly radialBarStartWidth: number;
        readonly radialBarEndWidth: number;
        readonly needleBrush: StiBrush;
        readonly needleBorderBrush: StiBrush;
        readonly needleCapBrush: StiBrush;
        readonly needleCapBorderBrush: StiBrush;
        readonly needleBorderWidth: number;
        readonly needleCapBorderWidth: number;
        readonly needleStartWidth: number;
        readonly needleEndWidth: number;
        readonly needleRelativeHeight: number;
        readonly needleRelativeWith: number;
        readonly markerSkin: StiMarkerSkin;
        readonly markerBrush: StiBrush;
        readonly markerBorderBrush: StiBrush;
        readonly markerBorderWidth: number;
        readonly styleId: StiGaugeStyleId;
        private _gauge;
        gauge: StiGauge;
    }
}
declare module Stimulsoft.Report.Gauge {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiGaugeStyleCoreXF25 extends StiGaugeStyleCoreXF {
        readonly localizedName: string;
        readonly brush: StiBrush;
        getBrush(): StiBrush;
        readonly borderColor: Color;
        getBorderColor(): Color;
        readonly borderWidth: number;
        getBorderWidth(): number;
        readonly tickMarkMajorBrush: StiBrush;
        getTickMarkMajorBrush(): StiBrush;
        readonly tickMarkMajorBorder: StiBrush;
        getTickMarkMajorBorder(): StiBrush;
        readonly tickMarkMinorBrush: StiBrush;
        getTickMarkMinorBrush(): StiBrush;
        readonly tickMarkMinorBorder: StiBrush;
        getTickMarkMinorBorder(): StiBrush;
        readonly tickLabelMajorTextBrush: StiBrush;
        getTickLabelMajorTextBrush(): StiBrush;
        readonly tickLabelMajorFont: Font;
        getTickLabelMajorFont(): Font;
        readonly tickLabelMinorTextBrush: StiBrush;
        getTickLabelMinorTextBrush(): StiBrush;
        readonly tickLabelMinorFont: Font;
        getTickLabelMinorFont(): Font;
        readonly markerBrush: StiBrush;
        getMarkerBrush(): StiBrush;
        readonly linearBarBrush: StiBrush;
        readonly linearBarBorderBrush: StiBrush;
        readonly linearBarEmptyBrush: StiBrush;
        readonly linearBarEmptyBorderBrush: StiBrush;
        readonly linearBarStartWidth: number;
        readonly linearBarEndWidth: number;
        readonly radialBarBrush: StiBrush;
        readonly radialBarBorderBrush: StiBrush;
        readonly radialBarEmptyBrush: StiBrush;
        readonly radialBarEmptyBorderBrush: StiBrush;
        readonly radialBarStartWidth: number;
        readonly radialBarEndWidth: number;
        readonly needleBrush: StiBrush;
        readonly needleBorderBrush: StiBrush;
        readonly needleCapBrush: StiBrush;
        readonly needleCapBorderBrush: StiBrush;
        readonly needleBorderWidth: number;
        readonly needleCapBorderWidth: number;
        readonly needleStartWidth: number;
        readonly needleEndWidth: number;
        readonly needleRelativeHeight: number;
        readonly needleRelativeWith: number;
    }
}
declare module Stimulsoft.Report.Gauge {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiGaugeStyle = Stimulsoft.Report.StiGaugeStyle;
    class StiCustomGaugeStyleCoreXF extends StiGaugeStyleCoreXF25 {
        readonly localizedName: string;
        reportGaugeStyle: StiGaugeStyle;
        readonly reportStyle: StiGaugeStyle;
        private _reportStyleName;
        reportStyleName: string;
        private _customStyle;
        readonly customStyle: StiCustomGaugeStyle;
        getBrush(): StiBrush;
        getBorderColor(): Color;
        getBorderWidth(): number;
        getTickMarkMajorBrush(): StiBrush;
        getTickMarkMajorBorder(): StiBrush;
        getTickMarkMinorBrush(): StiBrush;
        getTickMarkMinorBorder(): StiBrush;
        getTickLabelMajorTextBrush(): StiBrush;
        getTickLabelMajorFont(): Font;
        getTickLabelMinorTextBrush(): StiBrush;
        getTickLabelMinorFont(): Font;
        getMarkerBrush(): StiBrush;
        readonly linearBarBrush: StiBrush;
        readonly linearBarBorderBrush: StiBrush;
        readonly linearBarEmptyBrush: StiBrush;
        readonly linearBarEmptyBorderBrush: StiBrush;
        readonly linearBarStartWidth: number;
        readonly linearBarEndWidth: number;
        readonly radialBarBrush: StiBrush;
        readonly radialBarBorderBrush: StiBrush;
        readonly radialBarEmptyBrush: StiBrush;
        readonly radialBarEmptyBorderBrush: StiBrush;
        readonly radialBarStartWidth: number;
        readonly radialBarEndWidth: number;
        readonly needleBrush: StiBrush;
        readonly needleBorderBrush: StiBrush;
        readonly needleCapBrush: StiBrush;
        readonly needleCapBorderBrush: StiBrush;
        readonly needleBorderWidth: number;
        readonly needleCapBorderWidth: number;
        readonly needleStartWidth: number;
        readonly needleEndWidth: number;
        readonly needleRelativeHeight: number;
        readonly needleRelativeWith: number;
        constructor(customStyle: StiCustomGaugeStyle);
    }
}
declare module Stimulsoft.Report.Gauge {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiGaugeStyleCoreXF24 extends StiGaugeStyleCoreXF {
        readonly localizedName: string;
        readonly brush: StiBrush;
        readonly borderColor: Color;
        readonly borderWidth: number;
        readonly tickMarkMajorBrush: StiBrush;
        readonly tickMarkMajorBorder: StiBrush;
        readonly tickMarkMinorBrush: StiBrush;
        readonly tickMarkMinorBorder: StiBrush;
        readonly tickLabelMajorTextBrush: StiBrush;
        readonly tickLabelMajorFont: Font;
        readonly tickLabelMinorTextBrush: StiBrush;
        readonly tickLabelMinorFont: Font;
        readonly markerBrush: StiBrush;
        readonly linearBarBrush: StiBrush;
        readonly linearBarBorderBrush: StiBrush;
        readonly linearBarEmptyBrush: StiBrush;
        readonly linearBarEmptyBorderBrush: StiBrush;
        readonly linearBarStartWidth: number;
        readonly linearBarEndWidth: number;
        readonly radialBarBrush: StiBrush;
        readonly radialBarBorderBrush: StiBrush;
        readonly radialBarEmptyBrush: StiBrush;
        readonly radialBarEmptyBorderBrush: StiBrush;
        readonly radialBarStartWidth: number;
        readonly radialBarEndWidth: number;
        readonly needleBrush: StiBrush;
        readonly needleBorderBrush: StiBrush;
        readonly needleCapBrush: StiBrush;
        readonly needleCapBorderBrush: StiBrush;
        readonly needleBorderWidth: number;
        readonly needleCapBorderWidth: number;
        readonly needleStartWidth: number;
        readonly needleEndWidth: number;
        readonly needleRelativeHeight: number;
        readonly needleRelativeWith: number;
    }
}
declare module Stimulsoft.Report.Gauge {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiGaugeStyleCoreXF26 extends StiGaugeStyleCoreXF {
        readonly localizedName: string;
        readonly brush: StiBrush;
        readonly borderColor: Color;
        readonly borderWidth: number;
        readonly tickMarkMajorBrush: StiBrush;
        readonly tickMarkMajorBorder: StiBrush;
        readonly tickMarkMinorBrush: StiBrush;
        readonly tickMarkMinorBorder: StiBrush;
        readonly tickLabelMajorTextBrush: StiBrush;
        readonly tickLabelMajorFont: Font;
        readonly tickLabelMinorTextBrush: StiBrush;
        readonly tickLabelMinorFont: Font;
        readonly markerBrush: StiBrush;
        readonly linearBarBrush: StiBrush;
        readonly linearBarBorderBrush: StiBrush;
        readonly linearBarEmptyBrush: StiBrush;
        readonly linearBarEmptyBorderBrush: StiBrush;
        readonly linearBarStartWidth: number;
        readonly linearBarEndWidth: number;
        readonly radialBarBrush: StiBrush;
        readonly radialBarBorderBrush: StiBrush;
        readonly radialBarEmptyBrush: StiBrush;
        readonly radialBarEmptyBorderBrush: StiBrush;
        readonly radialBarStartWidth: number;
        readonly radialBarEndWidth: number;
        readonly needleBrush: StiBrush;
        readonly needleBorderBrush: StiBrush;
        readonly needleCapBrush: StiBrush;
        readonly needleCapBorderBrush: StiBrush;
        readonly needleBorderWidth: number;
        readonly needleCapBorderWidth: number;
        readonly needleStartWidth: number;
        readonly needleEndWidth: number;
        readonly needleRelativeHeight: number;
        readonly needleRelativeWith: number;
    }
}
declare module Stimulsoft.Report.Gauge {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiGaugeStyleCoreXF27 extends StiGaugeStyleCoreXF {
        readonly localizedName: string;
        readonly brush: StiBrush;
        readonly borderColor: Color;
        readonly borderWidth: number;
        readonly tickMarkMajorBrush: StiBrush;
        readonly tickMarkMajorBorder: StiBrush;
        readonly tickMarkMinorBrush: StiBrush;
        readonly tickMarkMinorBorder: StiBrush;
        readonly tickLabelMajorTextBrush: StiBrush;
        readonly tickLabelMajorFont: Font;
        readonly tickLabelMinorTextBrush: StiBrush;
        readonly tickLabelMinorFont: Font;
        readonly markerBrush: StiBrush;
        readonly linearBarBrush: StiBrush;
        readonly linearBarBorderBrush: StiBrush;
        readonly linearBarEmptyBrush: StiBrush;
        readonly linearBarEmptyBorderBrush: StiBrush;
        readonly linearBarStartWidth: number;
        readonly linearBarEndWidth: number;
        readonly radialBarBrush: StiBrush;
        readonly radialBarBorderBrush: StiBrush;
        readonly radialBarEmptyBrush: StiBrush;
        readonly radialBarEmptyBorderBrush: StiBrush;
        readonly radialBarStartWidth: number;
        readonly radialBarEndWidth: number;
        readonly needleBrush: StiBrush;
        readonly needleBorderBrush: StiBrush;
        readonly needleCapBrush: StiBrush;
        readonly needleCapBorderBrush: StiBrush;
        readonly needleBorderWidth: number;
        readonly needleCapBorderWidth: number;
        readonly needleStartWidth: number;
        readonly needleEndWidth: number;
        readonly needleRelativeHeight: number;
        readonly needleRelativeWith: number;
    }
}
declare module Stimulsoft.Report.Gauge {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiGaugeStyleCoreXF28 extends StiGaugeStyleCoreXF {
        readonly localizedName: string;
        readonly brush: StiBrush;
        readonly borderColor: Color;
        readonly borderWidth: number;
        readonly tickMarkMajorBrush: StiBrush;
        readonly tickMarkMajorBorder: StiBrush;
        readonly tickMarkMinorBrush: StiBrush;
        readonly tickMarkMinorBorder: StiBrush;
        readonly tickLabelMajorTextBrush: StiBrush;
        readonly tickLabelMajorFont: Font;
        readonly tickLabelMinorTextBrush: StiBrush;
        readonly tickLabelMinorFont: Font;
        readonly markerBrush: StiBrush;
        readonly linearBarBrush: StiBrush;
        readonly linearBarBorderBrush: StiBrush;
        readonly linearBarEmptyBrush: StiBrush;
        readonly linearBarEmptyBorderBrush: StiBrush;
        readonly linearBarStartWidth: number;
        readonly linearBarEndWidth: number;
        readonly radialBarBrush: StiBrush;
        readonly radialBarBorderBrush: StiBrush;
        readonly radialBarEmptyBrush: StiBrush;
        readonly radialBarEmptyBorderBrush: StiBrush;
        readonly radialBarStartWidth: number;
        readonly radialBarEndWidth: number;
        readonly needleBrush: StiBrush;
        readonly needleBorderBrush: StiBrush;
        readonly needleCapBrush: StiBrush;
        readonly needleCapBorderBrush: StiBrush;
        readonly needleBorderWidth: number;
        readonly needleCapBorderWidth: number;
        readonly needleStartWidth: number;
        readonly needleEndWidth: number;
        readonly needleRelativeHeight: number;
        readonly needleRelativeWith: number;
    }
}
declare module Stimulsoft.Report.Gauge {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Type = Stimulsoft.System.Type;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import IStiGaugeStyleXF = Stimulsoft.Report.Gauge.IStiGaugeStyleXF;
    class StiGaugeStyleXF extends StiBaseStyle implements IStiGaugeStyle, IStiGaugeStyleXF {
        private static implementsStiGaugeStyleXF;
        implements(): string[];
        readonly componentId: StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromJsonObjectInternal(jObject: StiJson): StiGaugeStyleXF;
        readonly serviceName: string;
        readonly serviceCategory: string;
        readonly serviceType: Type;
        private _core;
        core: StiGaugeStyleCoreXF;
        toString(): string;
        compareGaugeStyle(style: StiGaugeStyleXF): boolean;
        drawStyle(g: Graphics, rect: Rectangle, paintValue: boolean, paintImage: boolean): void;
        drawBox(g: Graphics, rect: Rectangle, paintValue: boolean, paintImage: boolean): void;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
        createNew(): StiGaugeStyleXF;
    }
}
declare module Stimulsoft.Report.Gauge {
    class StiGaugeStyleXF27 extends StiGaugeStyleXF {
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare module Stimulsoft.Report.Gauge {
    class StiCustomGaugeStyle extends StiGaugeStyleXF27 {
        readonly serviceName: string;
        readonly customCore: StiCustomGaugeStyleCoreXF;
        constructor(reportStyleName?: string);
    }
}
declare module Stimulsoft.Report.Gauge {
    class StiGaugeStyleXF24 extends StiGaugeStyleXF {
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare module Stimulsoft.Report.Gauge {
    class StiGaugeStyleXF25 extends StiGaugeStyleXF {
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare module Stimulsoft.Report.Gauge {
    class StiGaugeStyleXF26 extends StiGaugeStyleXF {
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare module Stimulsoft.Report.Gauge {
    class StiGaugeStyleXF28 extends StiGaugeStyleXF {
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare module Stimulsoft.Report.Gauge {
    var IStiApplyStyleGauge: string;
    interface IStiApplyStyleGauge {
        applyStyle(style: IStiGaugeStyle): any;
    }
}
declare module Stimulsoft.Report.Gauge {
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiGaugeStyle: string;
    interface IStiGaugeStyle extends ICloneable, IStiJsonReportObject {
        core: StiGaugeStyleCoreXF;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiGetTextEventArgs = Stimulsoft.Report.Gauge.Events.StiGetTextEventArgs;
    import StiGetTextEvent = Stimulsoft.Report.Gauge.Events.StiGetTextEvent;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiCustomValuesCollection = Stimulsoft.Report.Gauge.Collections.StiCustomValuesCollection;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGetValueEvent = Stimulsoft.Report.Events.StiGetValueEvent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiLinearTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickLabelBase;
    import IStiTickCustom = Stimulsoft.Report.Gauge.Primitives.IStiTickCustom;
    class StiLinearTickLabelCustom extends StiLinearTickLabelBase implements IStiTickCustom {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        clone(): StiLinearTickLabelCustom;
        private _valueObj;
        valueObj: number;
        private _textObj;
        textObj: string;
        private _values;
        values: StiCustomValuesCollection;
        readonly localizeName: string;
        onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _getValueEvent;
        getValueEvent: StiGetValueEvent;
        onGetText(e: StiGetTextEventArgs): void;
        invokeGetText(sender: StiGaugeElement, e: StiGetTextEventArgs): void;
        private _getTextEvent;
        getTextEvent: StiGetTextEvent;
        private _value;
        value: string;
        private _text;
        text: string;
        createNew(): StiGaugeElement;
        prepareGaugeElement(): void;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    class StiLinearTickLabelCustomValue extends StiCustomValueBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        private _text;
        text: string;
        readonly localizedName: string;
        toString(): string;
        createNew(): StiCustomValueBase;
        constructor(value?: number, text?: string, offset?: number, placement?: StiPlacement);
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiLinearTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickLabelBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiLinearTickLabelMinor extends StiLinearTickLabelBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private _skipMajorValues;
        skipMajorValues: boolean;
        readonly isSkipMajorValues: boolean;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare module Stimulsoft.Report.Components {
    import Image = Stimulsoft.System.Drawing.Image;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiScaleCollection = Stimulsoft.Report.Gauge.Collections.StiScaleCollection;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiExportImageExtended = Stimulsoft.Report.Components.IStiExportImageExtended;
    import IStiBorder = Stimulsoft.Report.Components.IStiBorder;
    import IStiBrush = Stimulsoft.Report.Components.IStiBrush;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiGauge = Stimulsoft.Report.Components.Gauge.IStiGauge;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiGauge extends StiComponent implements IStiExportImageExtended, IStiBorder, IStiBrush, IStiGauge {
        private static implementsStiGauge;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        clone(cloneProperties?: boolean, cloneComponents?: boolean): StiGauge;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        private _border;
        border: StiBorder;
        private _brush;
        brush: StiBrush;
        readonly localizedCategory: string;
        readonly localizedName: string;
        readonly defaultClientRectangle: Rectangle;
        painter: StiGaugeContextPainter;
        private _style;
        style: IStiGaugeStyle;
        private _customStyleName;
        customStyleName: string;
        private _scales;
        scales: StiScaleCollection;
        private _isAnimation;
        isAnimation: boolean;
        private changeSkin();
        drawGauge(context: StiGaugeContextPainter): void;
        createNew(): StiComponent;
        applyStyle(style: IStiGaugeStyle): void;
        constructor(rect?: Rectangle);
    }
}

/**
 * @hidden
 */
declare module Stimulsoft.Reflection {
    class StiTypesHelper {
        static run(type?: Stimulsoft.System.Type, namespace?: string): void;
    }
}
/**
 * @hidden
 */
declare let _module: any;

declare module Stimulsoft.Viewer {
    class StiCollectionsHelper {
        static GetLocalizationItems(): Object;
    }
}
declare module Stimulsoft.Viewer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiEditableFieldsHelper {
        static checkEditableReport(report: StiReport): boolean;
        static applyEditableFieldsToReport(report: StiReport, parameters: Object): void;
    }
}
declare module Stimulsoft.Viewer {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiExportFormat = Stimulsoft.Report.StiExportFormat;
    class StiExportsHelper {
        static getReportFileName(report: StiReport): string;
        static applyExportSettings(exportFormat: StiExportFormat, settingsObject: any, settings: any): void;
    }
}
declare module Stimulsoft.Viewer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiReportHelper {
        static applySorting(report: StiReport, parameters: any): void;
        static applyCollapsing(report: StiReport, parameters: any): void;
        static cloneReport2(report: StiReport): StiReport;
        static cloneReport(report: StiReport): StiReport;
        static applyDrillDown(report: StiReport, renderedReport: StiReport, parameters: any): StiReport;
        private static addBookmarkNode(bkm, parentNode, bookmarksTree);
        static getBookmarksContent(report: StiReport, viewerId: string, pageNumber: number): string;
    }
    class StiBookmarkTreeNode {
        parent: number;
        title: string;
        url: string;
        used: boolean;
        componentGuid: string;
    }
}
declare module Stimulsoft.Viewer {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiResource = Stimulsoft.Report.Dictionary.StiResource;
    class StiReportResourceHelper {
        static getResourcesItems(report: StiReport): any[];
        static getResourceContentType(resource: StiResource): string;
        static getResourceFileExt(resource: StiResource): string;
    }
}
declare module Stimulsoft.Viewer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiVariablesHelper {
        private en_us_culture;
        static fillDialogInfoItems(report: StiReport): void;
        private static getVariableAlias(variable);
        private static getItems(variable);
        private static getDateTimeObject(value);
        private static getBasicType(variable);
        private static getStiType(variable);
        static applyReportParameters(report: StiReport, values: any): void;
        static applyReportBindingVariables(report: StiReport, values: any): void;
        private static setVariableValue(report, paramName, paramValue, variable);
        static getVariables(report: StiReport, values: any): any;
    }
}
declare module Stimulsoft.Viewer {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiHtmlExportMode = Stimulsoft.Report.Export.StiHtmlExportMode;
    class StiAppearanceOptions {
        /** Gets or sets the background color of the viewer. */
        backgroundColor: Color;
        /** Gets or sets a color of the report page border. */
        pageBorderColor: Color;
        /** Gets or sets a value which controls of output objects in the right to left mode. */
        rightToLeft: boolean;
        /** Gets or sets a value which indicates which indicates that the viewer is displayed in full screen mode. */
        fullScreenMode: boolean;
        /** Gets or sets a value which indicates that the viewer will show the report area with scrollbars. */
        scrollbarsMode: boolean;
        /** Gets or sets a browser window to open links from the report. */
        openLinksWindow: string;
        /** Gets or sets a browser window to open the exported report. */
        openExportedReportWindow: string;
        /** Gets or sets a value which indicates that show or hide tooltips. */
        showTooltips: boolean;
        /** Gets or sets a value which indicates that show or hide the help link in tooltips. */
        showTooltipsHelp: boolean;
        /** Gets or sets the alignment of the viewer page. */
        pageAlignment: StiContentAlignment;
        /** Gets or sets a value which indicates that the shadow of the page will be displayed in the viewer. */
        showPageShadow: boolean;
        /** Gets or sets a value which allows printing report bookmarks. */
        bookmarksPrint: boolean;
        /** Gets or sets a width of the bookmarks tree in the viewer. */
        bookmarksTreeWidth: number;
        parametersPanelPosition: StiParametersPanelPosition;
        /** Gets or sets a max height of parameters panel in the viewer. */
        parametersPanelMaxHeight: number;
        /** Gets or sets a count columns in parameters panel. */
        parametersPanelColumnsCount: number;
        /** Gets or sets a date format for datetime parameters in parameters panel. The default is the client browser date format. */
        parametersPanelDateFormat: string;
        /** Gets or sets the type of the viewer interface. */
        interfaceType: StiInterfaceType;
        /** Gets or sets the type of the chart in the viewer. */
        chartRenderType: StiChartRenderType;
        /** Gets or sets a method how the viewer will show a report. */
        reportDisplayMode: StiHtmlExportMode;
        /** Gets or sets the first day of week in the date picker */
        datePickerFirstDayOfWeek: StiFirstDayOfWeek;
        /** Gets or sets a value which allows touch zoom in the viewer. */
        allowTouchZoom: boolean;
        /** Obsolete. Please use the reportDisplayMode property instead. Should be removed in 2018.3 version. */
        htmlRenderMode: StiHtmlExportMode;
    }
}
declare module Stimulsoft.Viewer {
    class StiEmailOptions {
        /** Gets or sets a value which allows to display the Email dialog, or send Email with the default settings. */
        showEmailDialog: boolean;
        /** Gets or sets a value which allows to display the export dialog for Email, or export report for Email with the default settings. */
        showExportDialog: boolean;
        /** Gets or sets the default email address of the message created in the viewer. */
        defaultEmailAddress: string;
        /** Gets or sets the default subject of the message created in the viewer. */
        defaultEmailSubject: string;
        /** Gets or sets the default text of the message created in the viewer. */
        defaultEmailMessage: string;
    }
}
declare module Stimulsoft.Viewer {
    class StiExportsOptions {
        /** Gets or sets a value which allows store the export settings in the cookies. */
        storeExportSettings: boolean;
        /** Gets or sets a value which allows to display the export dialog, or to export with the default settings. */
        showExportDialog: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the report document file. */
        showExportToDocument: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the PDF format. */
        showExportToPdf: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the XPS format. */
        showExportToXps: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the Power Point 2007-2010 format. */
        showExportToPowerPoint: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the HTML format. */
        showExportToHtml: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the HTML5 format. */
        showExportToHtml5: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the MHT (Web Archive) format. */
        showExportToMht: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the TEXT format. */
        showExportToText: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the Rich Text format. */
        showExportToRtf: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the Word 2007-2010 format. */
        showExportToWord2007: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the Open Document Text format. */
        showExportToOpenDocumentWriter: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the Excel BIFF format. */
        showExportToExcel: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the Excel XML format. */
        showExportToExcelXml: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the Excel 2007-2010 format. */
        showExportToExcel2007: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the Open Document Calc format. */
        showExportToOpenDocumentCalc: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the CSV format. */
        showExportToCsv: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the DBF format. */
        showExportToDbf: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the XML format. */
        showExportToXml: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the DIF format. */
        showExportToDif: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the Sylk format. */
        showExportToSylk: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the BMP image format. */
        showExportToImageBmp: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the GIF image format. */
        showExportToImageGif: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the JPEG image format. */
        showExportToImageJpeg: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the PCX image format. */
        showExportToImagePcx: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the PNG image format. */
        showExportToImagePng: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the TIFF image format. */
        showExportToImageTiff: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the Metafile image format. */
        showExportToImageMetafile: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the SVG image format. */
        showExportToImageSvg: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the SVGZ image format. */
        showExportToImageSvgz: boolean;
    }
}
declare module Stimulsoft.Viewer {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiToolbarOptions {
        /** Gets or sets a value which indicates that toolbar will be shown in the viewer. */
        visible: boolean;
        /** Gets or sets the display mode of the toolbar - simple or separated into upper and lower parts. */
        displayMode: StiToolbarDisplayMode;
        /** Gets or sets a color of the toolbar background. The default value is the theme color. */
        backgroundColor: Color;
        /** Gets or sets a color of the toolbar border. The default value is the theme color. */
        borderColor: Color;
        /** Gets or sets a color of the toolbar texts. */
        fontColor: Color;
        /** Gets or sets a value which indicates which font family will be used for drawing texts in the viewer. */
        fontFamily: string;
        /** Gets or sets the alignment of the viewer toolbar. */
        alignment: StiContentAlignment;
        /** Gets or sets a value which allows displaying or hiding toolbar buttons captions. */
        showButtonCaptions: boolean;
        /** Gets or sets a visibility of the Print button in the toolbar of the viewer. */
        showPrintButton: boolean;
        /** Gets or sets a visibility of the Open button in the toolbar of the viewer. */
        showOpenButton: boolean;
        /** Gets or sets a visibility of the Save button in the toolbar of the viewer. */
        showSaveButton: boolean;
        /** Gets or sets a visibility of the Send Email button in the toolbar of the viewer. */
        showSendEmailButton: boolean;
        /** Gets or sets a visibility of the Find button in the toolbar of the viewer. */
        showFindButton: boolean;
        /** Gets or sets a visibility of the Bookmarks button in the toolbar of the viewer. */
        showBookmarksButton: boolean;
        /** Gets or sets a visibility of the Parameters button in the toolbar of the viewer. */
        showParametersButton: boolean;
        /** Gets or sets a visibility of the Resources button in the toolbar of the viewer. */
        showResourcesButton: boolean;
        /** Gets or sets a visibility of the Editor button in the toolbar of the viewer. */
        showEditorButton: boolean;
        /** Gets or sets a visibility of the Full Screen button in the toolbar of the viewer. */
        showFullScreenButton: boolean;
        /** Gets or sets a visibility of the First Page button in the toolbar of the viewer. */
        showFirstPageButton: boolean;
        /** Gets or sets a visibility of the Prev Page button in the toolbar of the viewer. */
        showPreviousPageButton: boolean;
        /** Gets or sets a visibility of the current page control in the toolbar of the viewer. */
        showCurrentPageControl: boolean;
        /** Gets or sets a visibility of the Next Page button in the toolbar of the viewer. */
        showNextPageButton: boolean;
        /** Gets or sets a visibility of the Last Page button in the toolbar of the viewer. */
        showLastPageButton: boolean;
        /** Gets or sets a visibility of the Zoom control in the toolbar of the viewer. */
        showZoomButton: boolean;
        /** Gets or sets a visibility of the View Mode button in the toolbar of the viewer. */
        showViewModeButton: boolean;
        /** Gets or sets a visibility of the Design button in the toolbar of the viewer. */
        showDesignButton: boolean;
        /** Gets or sets a visibility of the About button in the toolbar of the viewer. */
        showAboutButton: boolean;
        /** Gets or sets a visibility of the Pin button in the toolbar of the viewer in mobile mode. */
        showPinToolbarButton: boolean;
        /** Gets or sets the default mode of the report print destination. */
        printDestination: StiPrintDestination;
        /** Gets or sets the mode of showing a report in the viewer - one page or the whole report. */
        viewMode: StiWebViewMode;
        multiPageWidthCount: number;
        multiPageHeightCount: number;
        private _zoom;
        /** Gets or sets the report showing zoom. The default value is 100. */
        zoom: number;
        /** Gets or sets a value which indicates that menu animation is enabled. */
        menuAnimation: boolean;
        /** Gets or sets the mode that shows menu of the viewer. */
        showMenuMode: StiShowMenuMode;
        /** Gets or sets a value which allows automatically hide the viewer toolbar in mobile mode. */
        autoHide: boolean;
    }
}
declare module Stimulsoft.Viewer {
    enum StiContentAlignment {
        Left = 0,
        Center = 1,
        Right = 2,
        Default = 3,
    }
    enum StiInterfaceType {
        Auto = 0,
        Mouse = 1,
        Touch = 2,
        Mobile = 3,
    }
    enum StiChartRenderType {
        Vector = 2,
        AnimatedVector = 3,
    }
    enum StiPrintDestination {
        Default = 0,
        Pdf = 1,
        Direct = 2,
        WithPreview = 3,
    }
    enum StiWebViewMode {
        SinglePage = 0,
        Continuous = 1,
        MultiplePages = 2,
        OnePage = 3,
        WholeReport = 4,
        MultiPage = 5,
    }
    enum StiShowMenuMode {
        Click = 0,
        Hover = 1,
    }
    enum StiZoomMode {
        PageWidth = -1,
        PageHeight = -2,
    }
    enum StiExportAction {
        ExportReport = 1,
        SendEmail = 2,
    }
    enum StiFirstDayOfWeek {
        Monday = 0,
        Sunday = 1,
    }
    enum StiParametersPanelPosition {
        Top = 0,
        Left = 1,
    }
    enum StiToolbarDisplayMode {
        Simple = 0,
        Separated = 1,
    }
}
declare module Stimulsoft.Viewer {
    class StiEmailSettings {
        email: string;
        subject: string;
        message: string;
    }
}
declare module Stimulsoft.Viewer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiJsViewer {
        options: any;
        controls: any;
        reportParams: any;
        assignReport(report: StiReport): any;
        initAutoUpdateCache(jsText: any, jsObject: any): any;
        postAjax(url: string, data: any, callback?: any): any;
        postAction(action: string, bookmarkPage?: any, bookmarkAnchor?: any): any;
        postEmail(format: string, settingsObject: any): any;
        postExport(format: string, settingsObject: any, action: StiExportAction): any;
        postReportResource(resourceName: string, viewType: string): any;
        postPrint(action: string): any;
        postOpen(fileName: string, content: string): any;
        postInteraction(params: any): any;
        postDesign(): any;
        getReportParameters(action: string): any;
        viewer: StiViewer;
        InitializeErrorMessageForm(): any;
        constructor(parameters: any);
    }
    class StiViewer {
        drillDownReportCache: any;
        private _renderAfterCreate;
        onBeginProcessData: Function;
        onEndProcessData: Function;
        onPrintReport: Function;
        onBeginExportReport: Function;
        onEndExportReport: Function;
        onInteraction: Function;
        onEmailReport: Function;
        onDesignReport: Function;
        onShowReport: Function;
        onLoadDocument: Function;
        onGetReport: Function;
        onGetSubReport: Function;
        private reportCache;
        private _viewerId;
        readonly viewerId: string;
        private _options;
        readonly options: StiViewerOptions;
        private _jsObject;
        readonly jsObject: StiJsViewer;
        private _currentReportGuid;
        currentReportGuid: string;
        readonly reportTemplate: StiReport;
        report: StiReport;
        private _visible;
        visible: boolean;
        renderHtml(element?: string | HTMLElement): void;
        private invokeBeginProcessData(args, callback);
        private invokeEndProcessData(args);
        private invokePrintReport(printAction);
        private invokeBeginExportReport(settings, format, fileName, openAfterExport, callback);
        private invokeEndExportReport(format, fileName, openAfterExport, data);
        private invokeInteraction(action, variables, sortingParameters, collapsingParameters, drillDownParameters, callback);
        private invokeEmailReport(emailSettings, format, fileName, data);
        private invokeDesignReport();
        private invokeShowReport();
        private invokeLoadDocument(callback);
        private invokeGetReport();
        private invokeOnGetSubReport(args, callback);
        private callRemoteApi(commad, timeout?);
        private getReportPage(report, service, pageIndex, zoom, openLinksTarget);
        private getPagesArray(report, options, requestParams);
        private getReportFileName();
        showProcessIndicator(): void;
        hideProcessIndicator(): void;
        constructor(options?: StiViewerOptions, viewerId?: string, renderAfterCreate?: boolean);
    }
}
declare module Stimulsoft.Viewer {
    class StiViewerOptions {
        /** A class which controls settings of the viewer appearance. */
        appearance: StiAppearanceOptions;
        /** A class which controls settings of the viewer toolbar. */
        toolbar: StiToolbarOptions;
        /** A class which controls the export options. */
        exports: StiExportsOptions;
        /** A class which controls the export options. */
        email: StiEmailOptions;
        /** Gets or sets the width of the viewer. */
        width: string;
        /** Gets or sets the height of the viewer. */
        height: string;
        viewerId: string;
        reportDesignerMode: boolean;
        private requestStylesUrl;
        private productVersion;
        private actions;
        toParameters(): Object;
        private serializeObject(fromObject, toObject);
    }
}

declare module Stimulsoft.Report.Check {
    class StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiAllowDoublePassAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiAllowHtmlTagsInTextAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiApplyGeneralTextFormat extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCanBreakComponentInContainerAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCanGrowComponentInContainerAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCanGrowGrowToHeightComponentInContainerAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCanGrowWordWrapTextAndWysiwygAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiColumnsWidthGreaterContainerWidthAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiComponentStyleIsNotFoundAtComponentAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiConversionContainerInPanelAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiConversionContourTextInTextAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiConversionSystemTextInTextAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDeleteComponentAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiFixCrossLinePrimitiveAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiGenerateNewNameComponentAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiGrowToHeightOverlappingAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiMinRowsInColumnsAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiMoveComponentToPageAreaAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiMoveComponentToPrintablePageAreaAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiNegativeSizesOfComponentsAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiVerySmallSizesOfComponentsAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiWordWrapCanGrowTextDoesNotFitAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDeleteConnectionAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDeleteDataRelationAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiGenerateNewNameRelationAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDeleteDataSourceAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiGenerateNewNameDataSourceAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDeleteLostPointsAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDeletePageAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiGenerateNewNamePageAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiLargeHeightAtPageAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiOrientationPageToLandscapeAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiOrientationPageToPortraitAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiPrintHeadersFootersFromPreviousPageAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiPrintOnPreviousPageAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiResetPageNumberAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiSwitchWidthAndHeightOfPageAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiEditNameAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiEditPropertyAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiGoToCodeAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCheck {
        private _element;
        element: any;
        readonly previewVisible: boolean;
        readonly elementName: string;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        readonly objectType: StiCheckObjectType;
        readonly defaultStateEnabled: boolean;
        enabled: boolean;
        private _actions;
        readonly actions: StiAction[];
        processCheck(report: StiReport, obj: any): any;
        createPreviewImage(refElementImage: any, refHighlightedElementImage: any): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiComponentCheck extends StiCheck {
        readonly objectType: StiCheckObjectType;
        readonly elementName: string;
    }
}
declare module Stimulsoft.Report.Check {
    class StiAllowHtmlTagsInTextCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiBigSizeOfTheImageCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCanBreakComponentInContainerCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCanGrowComponentInContainerCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCanGrowGrowToHeightComponentInContainerCheck extends StiComponentCheck {
        readonly defaultStateEnabled: boolean;
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCanGrowWordWrapTextAndWysiwygCheck extends StiComponentCheck {
        readonly defaultStateEnabled: boolean;
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiColumnsWidthGreaterContainerWidthCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiComponentBoundsAreOutOfBand extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiComponentDataColumnCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiComponentStyleIsNotFoundAtComponentCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiContainerInEngineV2Check extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiContourTextObsoleteCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCorruptedCrossLinePrimitiveCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCountDataDataSourceAtDataBandCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCrossGroupHeaderNotEqualToCrossGroupFooterOnContainerCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDataSourcesForImageCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiFontMissingCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiGroupHeaderNotEqualToGroupFooterOnContainerCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiGrowToHeightOverlappingCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiLocationOutsidePageCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        readonly isOutsidePage: boolean;
        readonly isOutsidePrintableArea: boolean;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiMinRowsInColumnsCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiNegativeSizesOfComponentsCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiNoConditionAtGroupCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiNoNameComponentCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiPrintOnDoublePassCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiShowInsteadNullValuesCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiSystemTextObsoleteCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiTextColorEqualToBackColorCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiTextTextFormatCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        check(): boolean;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiUndefinedComponentCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiVerySmallSizesOfComponentsCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiWidthHeightZeroComponentCheck extends StiComponentCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiWordWrapCanGrowTextDoesNotFitCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiConnectionCheck extends StiCheck {
        readonly objectType: StiCheckObjectType;
        readonly elementName: string;
    }
}
declare module Stimulsoft.Report.Check {
    class StiUndefinedConnectionCheck extends StiConnectionCheck {
        private report;
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDataRelationCheck extends StiCheck {
        private dataBuilder;
        readonly objectType: StiCheckObjectType;
        readonly elementName: string;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDifferentAmountOfKeysInDataRelationCheck extends StiDataRelationCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiKeysInAbsentDataRelationCheck extends StiDataRelationCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiKeysNotFoundRelationCheck extends StiDataRelationCheck {
        readonly previewVisible: boolean;
        private _columns;
        columns: string;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private isColumnsExist(relation);
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiKeysTypesMismatchDataRelationCheck extends StiDataRelationCheck {
        readonly previewVisible: boolean;
        private _columns;
        columns: string;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private isColumnsExist(relation);
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiNoNameDataRelationCheck extends StiDataRelationCheck {
        readonly previewVisible: boolean;
        private _dataSources;
        dataSources: string;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiNoNameInSourceDataRelationCheck extends StiDataRelationCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiSourcesInAbsentDataRelationCheck extends StiDataRelationCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDataColumnCheck extends StiCheck {
        private dataBuilder;
        readonly previewVisible: boolean;
        readonly objectType: StiCheckObjectType;
        readonly elementName: string;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCalculatedColumnRecursionCheck extends StiDataColumnCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private checkForRecursion(column, report);
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDataSourceCheck extends StiCheck {
        private dataBuilder;
        readonly objectType: StiCheckObjectType;
        readonly elementName: string;
    }
}
declare module Stimulsoft.Report.Check {
    class StiNoNameDataSourceCheck extends StiDataSourceCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiNoNameInSourceDataSourceCheck extends StiDataSourceCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiUndefinedDataSourceCheck extends StiDataSourceCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    import StiDatabase = Stimulsoft.Report.Dictionary.StiDatabase;
    import StiResource = Stimulsoft.Report.Dictionary.StiResource;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiUsedResourceHelper {
        static getDatabasesUsedResource(report: StiReport, resource: StiResource): StiDatabase[];
        static getComponentsUsedResource(report: StiReport, resource: StiResource): StiComponent[];
        private static getImageComponentsUsedResource(report, resource);
        private static getRichTextComponentsUsedResource(report, resource);
        private static getReportsUsedResource(report, resource);
    }
}
declare module Stimulsoft.Report.Check {
    class StiPageCheck extends StiCheck {
        readonly previewVisible: boolean;
        readonly objectType: StiCheckObjectType;
        readonly elementName: string;
    }
}
declare module Stimulsoft.Report.Check {
    class StiBigSizeOfTheImageAtWatermarkCheck extends StiPageCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiColumnsWidthGreaterPageWidthCheck extends StiPageCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiComponentStyleIsNotFoundAtPageCheck extends StiPageCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCrossGroupHeaderNotEqualToCrossGroupFooterOnPageCheck extends StiPageCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiGroupHeaderNotEqualToGroupFooterOnPageCheck extends StiPageCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiLargeHeightAtPageCheck extends StiPageCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiPointPrimitive = Stimulsoft.Report.Components.StiPointPrimitive;
    class StiLostPointsOnPageCheck extends StiPageCheck {
        readonly previewVisible: boolean;
        private readonly page;
        readonly shortMessage: string;
        readonly longMessage: string;
        private _lostPointsNames;
        lostPointsNames: string;
        readonly status: StiCheckStatus;
        static getLostPointsOnPage(page: StiPage): StiPointPrimitive[];
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiNoNamePageCheck extends StiPageCheck {
        private readonly page;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiOrientationPageCheck extends StiPageCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiPrintHeadersAndFootersFromPreviousPageCheck extends StiPageCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private getPageCount(report);
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiPrintOnPreviousPageCheck extends StiPageCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private getPageCount(report);
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiPrintOnPreviousPageCheck2 extends StiPageCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiResetPageNumberCheck extends StiPageCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private getPageCount(report);
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiReportCheck extends StiCheck {
        readonly objectType: StiCheckObjectType;
        readonly elementName: string;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDuplicatedNameCheck extends StiReportCheck {
        readonly elementName: string;
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private _isDataSource;
        isDataSource: boolean;
        private dataBuilder;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDuplicatedNameInSourceInDataRelationReportCheck extends StiReportCheck {
        readonly previewVisible: boolean;
        private _relationsNames;
        relationsNames: string;
        private _relationsNameInSource;
        relationsNameInSource: string;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiIsFirstPageIsLastPageDoublePassCheck extends StiReportCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiIsFirstPassIsSecondPassCheck extends StiReportCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiReportRenderingMessageCheck extends StiReportCheck {
        readonly shortMessage: string;
        private _longMessage;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        setMessage(message: string): void;
        processCheck(report: StiReport, msg: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiTotalPageCountDoublePassCheck extends StiReportCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check();
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiVariableCheck extends StiCheck {
        readonly previewVisible: boolean;
        readonly objectType: StiCheckObjectType;
        readonly elementName: string;
    }
}
declare module Stimulsoft.Report.Check {
    class StiVariableRecursionCheck extends StiVariableCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private checkForRecursion(variable, report);
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    enum StiCheckStatus {
        ReportRenderingMessage = 0,
        Information = 1,
        Warning = 2,
        Error = 3,
    }
    enum StiCheckObjectType {
        Report = 0,
        Page = 1,
        Component = 2,
        Database = 3,
        DataSource = 4,
        DataRelation = 5,
        DataColumn = 6,
        Variable = 7,
    }
}
declare module Stimulsoft.Report.Check {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiCheckEngine {
        private invokeFinishCheckingReport();
        private invokeStartCheckingPages();
        private invokeCheckingPages();
        private invokeFinishCheckingPages();
        private invokeStartCheckingComponents();
        private invokeCheckingComponents();
        private invokeFinishCheckingComponents();
        private invokeStartCheckingDatabases();
        private invokeCheckingDatabases();
        private invokeFinishCheckingDatabases();
        private invokeStartCheckingDataSource();
        private invokeCheckingDataSource();
        private invokeFinishCheckingDataSource();
        private invokeStartCheckingRelations();
        private invokeCheckingRelations();
        private invokeFinishCheckingRelations();
        private invokeStartCheckingVariables();
        private invokeCheckingVariables();
        private invokeFinishCheckingVariables();
        private static _checks;
        static readonly checks: StiCheck[];
        private _progressValue;
        readonly progressValue: number;
        private _progressMaximum;
        readonly progressMaximum: number;
        private _progressInformation;
        readonly progressInformation: string;
        private static createChecks();
        checkReport(report: StiReport): StiCheck[];
        private static checkObject(report, obj, results, checksObject);
        constructor();
    }
}
declare module Stimulsoft.Report.Check {
    class StiCheckHelper {
        private _errorsCount;
        readonly errorsCount: number;
        private _warningsCount;
        readonly warningsCount: number;
        private _informationMessagesCount;
        readonly informationMessagesCount: number;
        private _reportRenderingMessagesCount;
        readonly reportRenderingMessagesCount: number;
        private _checks;
        readonly checks: StiCheck[];
        private _reportRenderingMessagesChecks;
        readonly reportRenderingMessagesChecks: StiCheck[];
        readonly isMessagesPresent: boolean;
        buildChecks(report: StiReport): void;
        buildReportRenderingMessages(report: StiReport): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiLocalizationExt {
        static languages: any;
        static English: any;
        private static _cultureName;
        static cultureName: string;
        static addLocalizationFile(filePath: string, load?: boolean, language?: string): string;
        static setLocalizationFile(filePath: string, onlyThis?: boolean): void;
        static loadLocalization(localizationXml: any, extension?: boolean): string;
        static loadLocalizationFile(filePath: string): string;
        private static loadLocalizationXmlInternal(xml);
        static get(category: string, key: string): string;
    }
}

declare module Stimulsoft.Designer {
    import StiReportUnitType = Stimulsoft.Report.StiReportUnitType;
    class StiAppearanceOptions {
        /** Gets or sets a default value of unit in the designer. */
        defaultUnit: StiReportUnitType;
        /** Gets or sets the type of the designer interface. */
        interfaceType: StiInterfaceType;
        /** Gets or sets a value which indicates that animation is enabled. */
        showAnimation: boolean;
        /** Gets or sets a visibility of the save dialog of the designer. */
        showSaveDialog: boolean;
        /** Gets or sets a value which indicates that show or hide tooltips. */
        showTooltips: boolean;
        /** Gets or sets a value which indicates that show or hide tooltips help icon. */
        showTooltipsHelp: boolean;
        /** Gets or sets a value which indicates which indicates that the designer is displayed in full screen mode. */
        fullScreenMode: boolean;
        /** Gets or sets a visibility of the localization control of the designer. */
        private _showLocalization;
        showLocalization: boolean;
        /** Allow the designer to change the window title. */
        allowChangeWindowTitle: boolean;
        /** Gets or sets a visibility of the properties grid in the designer. */
        showPropertiesGrid: boolean;
        /** Gets or sets a visibility of the report tree in the designer. */
        showReportTree: boolean;
    }
}
declare module Stimulsoft.Designer {
    class StiBandsOptions {
        /** Gets or sets a visibility of the ReportTitleBand item in the bands menu of the designer. */
        showReportTitleBand: boolean;
        /** Gets or sets a visibility of the ReportSummaryBand item in the bands menu of the designer. */
        showReportSummaryBand: boolean;
        /** Gets or sets a visibility of the PageHeaderBand item in the bands menu of the designer. */
        showPageHeaderBand: boolean;
        /** Gets or sets a visibility of the PageFooterBand item in the bands menu of the designer. */
        showPageFooterBand: boolean;
        /** Gets or sets a visibility of the GroupHeaderBand item in the bands menu of the designer. */
        showGroupHeaderBand: boolean;
        /** Gets or sets a visibility of the GroupFooterBand item in the bands menu of the designer. */
        showGroupFooterBand: boolean;
        /** Gets or sets a visibility of the HeaderBand item in the bands menu of the designer. */
        showHeaderBand: boolean;
        /** Gets or sets a visibility of the FooterBand item in the bands menu of the designer. */
        showFooterBand: boolean;
        /** Gets or sets a visibility of the ColumnHeaderBand item in the bands menu of the designer. */
        showColumnHeaderBand: boolean;
        /** Gets or sets a visibility of the ColumnFooterBand item in the bands menu of the designer. */
        showColumnFooterBand: boolean;
        /** Gets or sets a visibility of the DataBand item in the bands menu of the designer. */
        showDataBand: boolean;
        /** Gets or sets a visibility of the HierarchicalBand item in the bands menu of the designer. */
        showHierarchicalBand: boolean;
        /** Gets or sets a visibility of the ChildBand item in the bands menu of the designer. */
        showChildBand: boolean;
        /** Gets or sets a visibility of the EmptyBand item in the bands menu of the designer. */
        showEmptyBand: boolean;
        /** Gets or sets a visibility of the OverlayBand item in the bands menu of the designer. */
        showOverlayBand: boolean;
        /** Gets or sets a visibility of the Table item in the bands menu of the designer. */
        showTable: boolean;
    }
}
declare module Stimulsoft.Designer {
    class StiComponentsOptions {
        /** Gets or sets a visibility of the Text item in the components menu of the designer. */
        showText: boolean;
        /** Gets or sets a visibility of the TextInCells item in the components menu of the designer. */
        showTextInCells: boolean;
        /** Gets or sets a visibility of the RichText item in the components menu of the designer. */
        showRichText: boolean;
        /** Gets or sets a visibility of the Image item in the components menu of the designer. */
        showImage: boolean;
        /** Gets or sets a visibility of the BarCode item in the components menu of the designer. */
        showBarCode: boolean;
        /** Gets or sets a visibility of the Shape item in the components menu of the designer. */
        showShape: boolean;
        /** Gets or sets a visibility of the Panel item in the components menu of the designer. */
        showPanel: boolean;
        /** Gets or sets a visibility of the Clone item in the components menu of the designer. */
        showClone: boolean;
        /** Gets or sets a visibility of the CheckBox item in the components menu of the designer. */
        showCheckBox: boolean;
        /** Gets or sets a visibility of the SubReport item in the components menu of the designer. */
        showSubReport: boolean;
        /** Gets or sets a visibility of the ZipCode item in the components menu of the designer. */
        showZipCode: boolean;
        /** Gets or sets a visibility of the Chart item in the components menu of the designer. */
        showChart: boolean;
    }
}
declare module Stimulsoft.Designer {
    class StiCrossBandsOptions {
        /** Gets or sets a visibility of the CrossTab item in the crossbands menu of the designer. */
        showCrossTab: boolean;
        /** Gets or sets a visibility of the CrossGroupHeaderBand item in the crossbands menu of the designer. */
        showCrossGroupHeaderBand: boolean;
        /** Gets or sets a visibility of the CrossGroupFooterBand item in the crossbands menu of the designer. */
        showCrossGroupFooterBand: boolean;
        /** Gets or sets a visibility of the CrossHeaderBand item in the crossbands menu of the designer. */
        showCrossHeaderBand: boolean;
        /** Gets or sets a visibility of the CrossFooterBand item in the crossbands menu of the designer. */
        showCrossFooterBand: boolean;
        /** Gets or sets a visibility of the CrossDataBand item in the crossbands menu of the designer. */
        showCrossDataBand: boolean;
    }
}
declare module Stimulsoft.Designer {
    class StiDictionaryOptions {
        /** Gets or sets a visibility of the other category in the new connection form. */
        showAdaptersInNewConnectionForm: boolean;
        /** Gets or sets a visibility of the dictionary in the designer. */
        showDictionary: boolean;
        /** Gets or sets a value of permissions for datasources in the designer. */
        dataSourcesPermissions: StiDesignerPermissions;
        /** Gets or sets a value of connections for datasources in the designer. */
        dataConnectionsPermissions: StiDesignerPermissions;
        /** Gets or sets a value of connections for columns in the designer. */
        dataColumnsPermissions: StiDesignerPermissions;
        /** Gets or sets a value of connections for relations in the designer. */
        dataRelationsPermissions: StiDesignerPermissions;
        /** Gets or sets a value of connections for business objects in the designer. */
        businessObjectsPermissions: StiDesignerPermissions;
        /** Gets or sets a value of connections for variables in the designer. */
        variablesPermissions: StiDesignerPermissions;
        /** Gets or sets a value of connections for resources in the designer. */
        resourcesPermissions: StiDesignerPermissions;
    }
}
declare module Stimulsoft.Designer {
    class StiToolbarOptions {
        /** Gets or sets a visibility of the preview button in the toolbar of the designer. */
        showPreviewButton: boolean;
        /** Gets or sets a visibility of the save button in the toolbar of the designer. */
        showSaveButton: boolean;
        /** Gets or sets a visibility of the about button in the toolbar of the designer. */
        showAboutButton: boolean;
        /** Gets or sets a visibility of the publish button in the toolbar of the designer. */
        showPublishButton: boolean;
        /** Gets or sets a visibility of the file menu of the designer. */
        showFileMenu: boolean;
        /** Gets or sets a visibility of the item New in the file menu. */
        showFileMenuNew: boolean;
        /** Gets or sets a visibility of the item Open in the file menu. */
        showFileMenuOpen: boolean;
        /** Gets or sets a visibility of the item Save in the file menu. */
        showFileMenuSave: boolean;
        /** Gets or sets a visibility of the item Save As in the file menu. */
        showFileMenuSaveAs: boolean;
        /** Gets or sets a visibility of the item Close in the file menu. */
        showFileMenuClose: boolean;
        /** Gets or sets a visibility of the item Exit in the file menu. */
        showFileMenuExit: boolean;
        /** Gets or sets a visibility of the item Report Setup in the file menu. */
        showFileMenuReportSetup: boolean;
        /** Gets or sets a visibility of the item Options in the file menu. */
        showFileMenuOptions: boolean;
        /** Gets or sets a visibility of the item Info in the file menu. */
        showFileMenuInfo: boolean;
        /** Gets or sets a visibility of the item About in the file menu. */
        showFileMenuAbout: boolean;
        showSetupToolboxButton: boolean;
    }
}
declare module Stimulsoft.Designer {
    class StiAggregateFunctions {
        static getItems(): any[];
    }
}
declare module Stimulsoft.Designer {
    import StiBarCode = Stimulsoft.Report.BarCodes.StiBarCode;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiBarCodeHelper {
        static getBarCodeJSObject(barCode: StiBarCode): any;
        static getBarCodeProperties(barCode: StiBarCode): any;
        static applyBarCodeProperties(report: StiReport, param: any, callbackResult: any): void;
        static getBarCodeSampleImage(barCode: StiBarCode): string;
    }
}
declare module Stimulsoft.Designer {
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiTable = Stimulsoft.Report.Components.Table.StiTable;
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    import StiInteraction = Stimulsoft.Report.Components.StiInteraction;
    import StiBaseCondition = Stimulsoft.Report.Components.StiBaseCondition;
    import StiCondition = Stimulsoft.Report.Components.StiCondition;
    import StiColorScaleCondition = Stimulsoft.Report.Components.StiColorScaleCondition;
    import StiIconSetCondition = Stimulsoft.Report.Components.StiIconSetCondition;
    import StiDataBarCondition = Stimulsoft.Report.Components.StiDataBarCondition;
    import StiFiltersCollection = Stimulsoft.Report.Components.StiFiltersCollection;
    import StiConditionPermissions = Stimulsoft.Report.Components.StiConditionPermissions;
    import StiConditionBorderSides = Stimulsoft.Report.Components.StiConditionBorderSides;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiSubReport = Stimulsoft.Report.Components.StiSubReport;
    import StiShape = Stimulsoft.Report.Components.StiShape;
    import StiRichText = Stimulsoft.Report.Components.StiRichText;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiImage = Stimulsoft.Report.Components.StiImage;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiStylesCollection = Stimulsoft.Report.Styles.StiStylesCollection;
    class StiReportEdit {
        static setPropertyValue(report: StiReport, propertyName: string, owner: any, value: any, enumType?: Object): void;
        static getPropertyValue(propertyName: string, owner: any): Object;
        static getFiltersProperty(obj: any): any;
        static setFiltersProperty(obj: any, value: any): void;
        static lowerFirstChar(text: string): string;
        static lowerFirstCharPropertyNames(text: string): string;
        static upperFirstChar(text: string): string;
        static base64ToImage(base64String: string): Stimulsoft.System.Drawing.Image;
        static imageToBase64(image: Stimulsoft.System.Drawing.Image): string;
        static fontToStr(font: Font): string;
        static brushToStr(brush: StiBrush): string;
        static borderToStr(border: StiBorder): string;
        static getStringFromColor(color: Color): string;
        static addComponentToPage(component: StiComponent, currentPage: StiPage): void;
        static getParentName(comp: StiComponent): string;
        static getParentIndex(comp: StiComponent): number;
        static getComponentIndex(component: StiComponent): number;
        static getAllChildComponents(component: StiComponent): string;
        static getPropsRebuildPage(report: StiReport, currentPage: StiPage): any;
        private static getPageIndexes(report);
        static setComponentRectWithOffset(comp: StiComponent, newCompRect: RectangleD, command: string, resizeType: string, compProps: any): void;
        static setComponentRect(component: StiComponent, rect: RectangleD, alignToGrid: boolean): void;
        static getComponentRect(component: StiComponent): string;
        static getPageSize(page: StiPage): string;
        static getPageMargins(page: StiPage): string;
        static getAllComponentsPositions(report: StiReport, callbackResult: any): void;
        private static getIconSetItemObject(iconSetItem);
        private static getIconSetItemFromObject(iconSetItemObject);
        static strToColor(colorStr: string): Color;
        static strToNumber(value: string): number;
        static numberToStr(value: number): string;
        static strToBrush(value: string): StiBrush;
        static strToBorder(value: string): StiBorder;
        static strToFont(value: string): Font;
        static strBordersToConditionBorderSidesObject(borders: string): StiConditionBorderSides;
        static strPermissionsToConditionPermissionsObject(strPermissions: string): StiConditionPermissions;
        static getReportFileName(report: StiReport): string;
        static createInfographicComponent(componentTypeArray: string): StiComponent;
        static createShapeComponent(componentTypeArray: string): StiComponent;
        private static createBarCodeComponent(componentTypeArray);
        private static applyStyleCollection(comp, stylesCollection);
        static applyStyles(comp: StiComponent, stylesCollection: StiStylesCollection): void;
        static getComponentMainProperties(component: StiComponent, zoom: number): any;
        static getTableCells(table: StiTable, zoom: number): any[];
        static getColumnFromColumnPath(columnPath: string, report: StiReport): StiDataColumn;
        static getImageContentForPaint(imageComp: StiImage): string;
        static getWatermarkImageContentForPaint(page: StiPage, pageProps: any): string;
        static addPrimitivePoints(addedComp: StiComponent, currentPage: StiPage): void;
        static removePrimitivePoints(removiedComp: StiComponent): void;
        static changeRectPrimitivePoints(changedComp: StiComponent, rect: RectangleD): void;
        static checkAllPrimitivePoints(page: StiPage): void;
        static isAlignedByGrid(component: StiComponent): boolean;
        static addSubReportPage(subReport: StiSubReport, callbackResult: any): void;
        static getAllProperties(component: StiComponent): any;
        static getRichTextProperty(component: StiRichText): string;
        static getSortDataProperty(object: any): string;
        private static getRelationNameByNameInSource(object, nameInSource);
        private static getSingleSort(object, sortArray);
        static getFiltersObject(filters: StiFiltersCollection): any[];
        static getFilterDataProperty(component: StiBaseCondition | StiComponent): string;
        static getFilterOnProperty(component: StiBaseCondition | StiComponent): boolean;
        static getFilterModeProperty(component: StiBaseCondition | StiComponent): string;
        static getSvgContent(component: StiComponent, zoom: number): string;
        static getConditionsProperty(component: StiComponent): string;
        static getDataBarConditionObject(condition: StiDataBarCondition): any;
        static getIconSetConditionObject(condition: StiIconSetCondition): any;
        static getColorScaleConditionObject(condition: StiColorScaleCondition): any;
        static getHighlightConditionObject(condition: StiCondition): any;
        static getComponentHeaderSize(component: Object): string;
        static getInteractionProperty(interaction: StiInteraction): any;
        static getCrossTabFieldsProperties(crossTab: StiCrossTab): any[];
        static getEventsProperty(object_: any): any;
        static getSubReportParametersProperty(subReport: StiSubReport): any[];
        static getShapeTypeProperty(component: StiShape): string;
        static setAllProperties(component: StiComponent, props: any[]): void;
        static setSubReportPageProperty(component: Object, propertyValue: any): void;
        static setContainerProperty(component: StiComponent, propertyValue: string): void;
        static setShapeTypeProperty(component: StiComponent, shapeType: string): void;
        static setBarCodeTypeProperty(component: StiComponent, propValue: string): void;
        static setMarginsProperty(component: StiComponent, propertyValue: string): void;
        static setTextProperty(component: StiComponent, propertyValue: string): void;
        static setExcelValueProperty(component: StiComponent, propertyValue: string): void;
        static setRichTextProperty(component: StiComponent, propertyValue: string): void;
        static setTextFormatProperty(component: StiComponent, propertyValue: any): void;
        static setConditionProperty(component: StiComponent, propertyValue: string): void;
        private static getCorrectName(value);
        static setDataSourceProperty(component: any, propertyValue: string): void;
        static setDataRelationProperty(component: any, propertyValue: string): void;
        static setMasterComponentProperty(component: StiComponent, propertyValue: string): void;
        static setBusinessObjectProperty(component: StiComponent, propertyValue: string): void;
        static setSortDataProperty1(object: any, sortArray: any[]): void;
        static setSortDataProperty2(object: any, propertyValue: string): void;
        private static getSortArray(object, sort, result);
        private static getColumnPathArray(dataSource, columnPath, result);
        private static getChildRelation(relations, relationName);
        static setFilterDataProperty1(component: StiBaseCondition | any, filters: any[]): void;
        static setFilterDataProperty2(component: StiBaseCondition | any, propertyValue: string): void;
        private static filterFromObject(filterObject);
        private static strToFilterDataType(dataType);
        private static strToFilterCondition(condition);
        static setFilterOnProperty(component: StiBaseCondition | StiComponent, propertyValue: string): void;
        static setFilterModeProperty(component: StiBaseCondition | StiComponent, propertyValue: string): void;
        static setShiftModeProperty(component: any, propValue: any): void;
        static setRestrictionsProperty(component: StiComponent, propertyValue: string): void;
        static setAnchorProperty(component: StiComponent, propertyValue: string): void;
        static setConditionsProperty(component: StiComponent, propertyValue: string): void;
        static createHighlightCondition(conditionObject: any): StiBaseCondition;
        static createDataBarCondition(conditionObject: any): StiBaseCondition;
        static createColorScaleCondition(conditionObject: any): StiBaseCondition;
        static createIconSetCondition(conditionObject: any): StiBaseCondition;
        static setInteractionProperty(component: any, propertyValue: any): void;
        static setChartStyleProperty(component: any, propertyValue: any): void;
        static setCrossTabStyleProperty(component: any, propertyValue: any): void;
        static setSubReportParametersProperty(component: any, propertyValue: any): void;
        static writeReportInObject(report: StiReport): string;
        static writeReportInObject2(report: StiReport, attachedItems: any): string;
        static createComponent(report: StiReport, param: any, callbackResult: any): void;
        static removeComponent(report: StiReport, param: any, callbackResult: any): void;
        static changeRectComponent(report: StiReport, param: any, callbackResult: any): void;
        static addPage(report: StiReport, param: any, callbackResult: any): void;
        static removePage(report: StiReport, param: any, callbackResult: any): void;
        static readAllPropertiesFromString(report: StiReport, param: any, callbackResult: any): void;
        static changeUnit(report: StiReport, unitName: string): void;
        static getPreviewPagesAsync(onResult: Function, designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static cloneReportForPreview(report: StiReport): StiReport;
        static cloneReport(report: StiReport): StiReport;
        static setToClipboard(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static getFromClipboard(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static addReportToUndoArray(designer: StiDesigner, report: StiReport): void;
        static getUndoStep(designer: StiDesigner, currentReport: StiReport, param: any, callbackResult: any): StiReport;
        static getRedoStep(designer: StiDesigner, currentReport: StiReport, param: any, callbackResult: any): StiReport;
        static renameComponent(report: StiReport, param: any, callbackResult: any): void;
        static saveComponentClone(designer: StiDesigner, component: StiComponent): void;
        static canceledEditComponent(designer: StiDesigner, currentReport: StiReport, param: any): void;
        static createTextComponentFromDictionary(report: StiReport, param: any, callbackResult: any): void;
        static createComponentFromResource(report: StiReport, param: any, callbackResult: any): void;
        private static alignToMaxGrid(page, value, converted);
        private static alignToGrid(page, value, converted);
        static createDataComponentFromDictionary(report: StiReport, param: any, callbackResult: any): void;
        static setReportProperties(report: StiReport, param: any, callbackResult: any): void;
        static getReportProperties(report: StiReport): any;
        static pageMove(report: StiReport, param: any, callbackResult: any): void;
        static alignToGridComponents(report: StiReport, param: any, callbackResult: any): void;
        static changeArrangeComponents(report: StiReport, param: any, callbackResult: any): void;
        static duplicatePage(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static setEventValue(report: StiReport, param: any, callbackResult: any): void;
        static changeSizeComponents(report: StiReport, param: any, callbackResult: any): void;
        static createMovingCopyComponent(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static updateReportAliases(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static openPage(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare module Stimulsoft.Designer {
    import IStiSeriesLabels = Stimulsoft.Report.Chart.IStiSeriesLabels;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import IStiArea = Stimulsoft.Report.Chart.IStiArea;
    import IStiConstantLines = Stimulsoft.Report.Chart.IStiConstantLines;
    import IStiStrips = Stimulsoft.Report.Chart.IStiStrips;
    import IStiChartConditionsCollection = Stimulsoft.Report.Chart.IStiChartConditionsCollection;
    import IStiChartFiltersCollection = Stimulsoft.Report.Chart.IStiChartFiltersCollection;
    class StiChartHelper {
        static getChartProperties(chart: IStiChart): any;
        static getSeriesArray(chart: IStiChart): any[];
        static getSeries(series: IStiSeries): any;
        static getConditions(conditions: IStiChartConditionsCollection): any[];
        static getFilters(filters: IStiChartFiltersCollection): any[];
        static getTypesCollection(chart: IStiChart): any[];
        static getArea(chart: IStiChart): any;
        static getStyle(chart: IStiChart): any;
        static getMainProperties(chart: IStiChart): any;
        static getConstantLines(chart: IStiChart): any[];
        static getConstantLineProperties(constantLine: IStiConstantLines): any;
        static getStrips(chart: IStiChart): any[];
        static getStripsProperties(strip: IStiStrips): any;
        static getLabels(seriesLabels: IStiSeriesLabels): any;
        static getSeriesProperties(series: IStiSeries): any;
        static getAreaProperties(area: IStiArea): any;
        static getLabelsProperties(labels: IStiSeriesLabels): any;
        private static setConditionsValue(conditions, conditionValues);
        private static setFiltersValue(filters, filterValues);
        static getChartSampleSvg(svgData: StiSvgData, zoom: number): string;
        private static addDefaultSeries(chart);
        private static cloneChart(chart);
        private static addUserChartStyles(report, chartStyles);
        private static getChartStyles(report);
        static addSeries(report: StiReport, param: any, callbackResult: any): void;
        static removeSeries(report: StiReport, param: any, callbackResult: any): void;
        static seriesMove(report: StiReport, param: any, callbackResult: any): void;
        static addConstantLineOrStrip(report: StiReport, param: any, callbackResult: any): void;
        static removeConstantLineOrStrip(report: StiReport, param: any, callbackResult: any): void;
        static constantLineOrStripMove(report: StiReport, param: any, callbackResult: any): void;
        static getLabelsContent(report: StiReport, param: any, callbackResult: any): void;
        static getStylesContent(report: StiReport, param: any, callbackResult: any, forStylesControl: boolean): void;
        static setLabelsType(report: StiReport, param: any, callbackResult: any): void;
        static setChartStyle(report: StiReport, param: any, callbackResult: any): void;
        static setChartPropertyValue(report: StiReport, param: any, callbackResult: any): void;
        static setContainerValue(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare module Stimulsoft.Designer {
    class StiCodePageHelper {
        static getDBaseCodePageItems(): any[];
        static getCsvCodePageItems(): any[];
    }
}
declare module Stimulsoft.Designer {
    import StiCrossField = Stimulsoft.Report.CrossTab.StiCrossField;
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    class StiCrossTabHelper {
        private rowTotals;
        private colTotals;
        private sumHeaders;
        private createdTotals;
        private crossTab;
        private columnsContainer;
        private rowsContainer;
        private summaryContainer;
        private selectedDataSource;
        private selectedBusinessObject;
        private oldLeft;
        private oldTop;
        restorePositions(): void;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private getContainerByName(containerName);
        getCrossTabResult(): any[];
        getCrossFieldJSProperies(crossField: StiCrossField): any;
        getFieldsPropertiesForJS(): any;
        static getColorStyles(): any[];
        private updateCrossTab();
        private createRowTotal(rowGuid);
        private createColTotal(colGuid);
        private swapColumnsAndRows();
        private changeSummaryDirection(summaryDirection);
        private copySummaryToRow(field);
        private copySummaryToColumn(field);
        private copyHeaderToSummary(header);
        private copyRowToColumn(row);
        private copyColumnToRow(column);
        private copyRowTotalToColumnTotal(row);
        private copyColumnTotalToRowTotal(column);
        private copyFieldToField(dest, source);
        private convertColumnTotal(sourceColumn, destRow);
        private convertRowTotal(sourceRow, destColumn);
        private killRightTitle();
        constructor(crossTab: StiCrossTab);
    }
}
declare module Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiCultureHelper {
        static getItems(): any[];
        private static getHashtableObjectForJs(hashtable);
        private static getGlobalizationContainerObject(globContainer, report);
        static getReportGlobalizationStrings(report: StiReport): any[];
        static addReportGlobalizationStrings(report: StiReport, param: any, callbackResult: any): void;
        static removeReportGlobalizationStrings(report: StiReport, param: any, callbackResult: any): void;
        static getCultureSettingsFromReport(report: StiReport, param: any, callbackResult: any): void;
        static setCultureSettingsToReport(report: StiReport, param: any, callbackResult: any): void;
        static applyGlobalizationStrings(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare module Stimulsoft.Designer {
    class StiDefaultConditions {
        static getItems(): any;
    }
}
declare module Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDesignReportHelper {
        private report;
        getReportToObject(): any;
        getPages(): any[];
        getPage(pageIndex: number): any;
        private getComponents(page);
        private getComponent(component);
        private getReportInfo();
        constructor(report: StiReport);
    }
}
declare module Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDesignerOptionsHelper {
        static getDefaultDesignerOptions(): any;
        private static getCookie(name);
        static getDesignerOptions(): any;
        static applyDesignerOptionsToReport(designerOptions: any, report: StiReport): void;
    }
}
declare module Stimulsoft.Designer {
    import StiResource = Stimulsoft.Report.Dictionary.StiResource;
    import StiVirtualSource = Stimulsoft.Report.Dictionary.StiVirtualSource;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiReport = Stimulsoft.Report.StiReport;
    import Promise = Stimulsoft.System.Promise;
    import StiFileDatabase = Stimulsoft.Report.Dictionary.StiFileDatabase;
    class StiDictionaryHelper {
        private static databaseItem4(name, nameInSource, alias, dataInStore);
        private static databaseItem1(database);
        private static datasourceItem(datasource);
        private static columnItem(column);
        private static parameterItem(parameter);
        private static relationItem(relation, upLevelRelations);
        private static businessObjectItem(businessObject);
        private static variableItem(variable);
        private static tableItem(table);
        private static functionItem(functionn, report);
        private static functionsCategoryItem(name, typeIcon);
        private static resourceItem(resource);
        private static imagesGalleryItem(name, type, source);
        private static richTextGalleryItem(name, type, imageName);
        static getGroupColumnsProperty(dataSource: StiVirtualSource): string;
        static getResultsProperty(dataSource: StiVirtualSource): string;
        private static setGroupColumnsAndResultsProperty(dataSource, groupsData, resultsData);
        private static getDataParameterTypes(source);
        private static getItemType(itemVariable);
        private static getItemKeyObject(itemKey, type_, itemType);
        private static getItems(variable, type);
        private static createDataBaseByTypeName(typeDatabase);
        private static createDataAdapterByTypeName(typeDataAdapter);
        private static copyProperties(propertyNames, fromObject, toObject);
        private static getColumnsByTypeAndNameOfObject(report, props);
        private static getDatabaseByName(name, databasesTree);
        private static updateColumns(columns, columnsSource);
        private static updateParameters(parameters, parametersSource);
        private static getVariableBasicType(variable);
        private static getVariableType(variable);
        private static getValueByType(stringValue, typeVariable, basicType, canReturnNull);
        private static setDialogInfoItems(variable, itemsObject, type, basicType);
        static getBusinessObjectByFullName(report: StiReport, fullName: string[]): StiBusinessObject;
        private static getAjaxDataFromDatabaseInformation(information);
        private static convertAjaxDatabaseInfoToDatabaseInfo(data, allInfo);
        private static createDataStoreSourceFromParams(report, param);
        private static saveDataSourceParam(REFdataSourceWithParam, report, dataSource, param);
        static getViewDataItemValue(item: Object, type: Stimulsoft.System.Type): any;
        static createNewDatabaseFromResource(report: StiReport, resource: StiResource): StiFileDatabase;
        static getNewDatabaseName(report: StiReport, fileName: string): string;
        private static isCategoryVariable(variable);
        private static getVariableCategory(report, categoryName);
        private static applyParametersToSqlSourse(sqlSource, parameters);
        private static applyDataSourceProps(dataSource, dataSourceProps, report);
        private static applyConnectionProps(database, connectionProps, dictionary);
        private static applyColumnProps(column, columnProps);
        private static applyParameterProps(parameter, parameterProps);
        private static applyRelationProps(report, relation, relationProps);
        private static applyBusinessObjectProps(businessObject, businessObjectProps);
        private static applyVariableProps(report, variable, variableProps);
        private static applyResourceProps(report, resource, resourceProps);
        static getIconTypeForColumn(column: StiDataColumn): StiImagesID;
        static getLockedCalcImageIDFromType(type: Stimulsoft.System.Type, inherited: boolean): StiImagesID;
        private static getDataColumnImageIdFromType(type, isDataColumn);
        private static getTypeValueToString(type);
        private static getTypeVariableToString(variable);
        private static getTypeFromString(type);
        static getDictionaryTree(report: StiReport): any;
        static getResourcesTree(report: StiReport): any[];
        static getFunctionsTree(report: StiReport): any[];
        static getSystemVariablesTree(report: StiReport): string[];
        private static getDataBasesTree(report);
        private static isExistInDatabases(report, databaseName);
        private static getObjectsTreeByCategories(report, collectionObjects);
        private static getBusinessObjectsTree(report);
        private static getChildBusinessObjectsTree(businessObject);
        private static getVariablesTree(report);
        private static getColumnsTree1(columnsCollection);
        private static getColumnsTree2(columnsCollection, isCloud);
        private static getColumnsTree3(columnsCollection);
        private static getParametersTree(parametersCollection, isCloud);
        private static getRelationsTree3(parentRelation, relations, isCloud, upLevelRelations);
        private static getRelationsTree2(parentRelation, relations, upLevelRelations);
        private static getRelationsTree4(relationsCollection);
        static getConnectionTypes(report: StiReport, param: any, callbackResult: any, showAdaptersInNewConnectionForm?: boolean): void;
        static getDataAdapterTypes(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditConnection(report: StiReport, param: any, callbackResult: any): void;
        static deleteConnection(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditRelation(report: StiReport, param: any, callbackResult: any): void;
        static deleteRelation(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditColumn(report: StiReport, param: any, callbackResult: any): void;
        static deleteColumn(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditParameter(report: StiReport, param: any, callbackResult: any): void;
        static deleteParameter(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditDataSource(report: StiReport, param: any, callbackResult: any): void;
        static deleteDataSource(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditBusinessObject(report: StiReport, param: any, callbackResult: any): void;
        static deleteBusinessObject(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditVariable(report: StiReport, param: any, callbackResult: any): void;
        static deleteVariable(report: StiReport, param: any, callbackResult: any): void;
        static deleteVariablesCategory(report: StiReport, param: any, callbackResult: any): void;
        static editVariablesCategory(report: StiReport, param: any, callbackResult: any): void;
        static createVariablesCategory(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditResource(report: StiReport, param: any, callbackResult: any): void;
        static deleteResource(report: StiReport, param: any, callbackResult: any): void;
        static deleteBusinessObjectCategory(report: StiReport, param: any, callbackResult: any): void;
        static editBusinessObjectCategory(report: StiReport, param: any, callbackResult: any): void;
        static synchronizeDictionary(report: StiReport, param: any, callbackResult: any): void;
        static newDictionary(report: StiReport, param: any, callbackResult: any): void;
        static getAllConnectionsAsync(report: StiReport, param: any, callbackResult: any): Promise<void>;
        static retrieveColumnsAsync(report: StiReport, param: any, callbackResult: any): Promise<void>;
        static getDatabaseDataAsync(report: StiReport, param: any, callbackResult: any): Promise<void>;
        static applySelectedData(report: StiReport, param: any, callbackResult: any): void;
        static testConnectionAsync(report: StiReport, param: any, callbackResult: any): Promise<void>;
        static runQueryScriptAsync(report: StiReport, param: any, callbackResult: any): Promise<void>;
        static viewDataAsync(report: StiReport, param: any, callbackResult: any): Promise<void>;
        static createFieldOnDblClick(report: StiReport, param: any, callbackResult: any): void;
        static getParamsFromQueryString(report: StiReport, param: any, callbackResult: any): void;
        static getImagesGallery(report: StiReport, param: any, callbackResult: any): Promise<void>;
        static getRichTextGallery(report: StiReport, param: any, callbackResult: any): void;
        static getSampleConnectionString(report: StiReport, param: any, callbackResult: any): void;
        static createDatabaseFromResource(report: StiReport, param: any, callbackResult: any): void;
        static deleteAllDataSources(report: StiReport, param: any, callbackResult: any): void;
        static getVariableItemsFromDataColumn(report: StiReport, param: any, callbackResult: any): Promise<void>;
        static moveDictionaryItem(report: StiReport, param: any, callbackResult: any): void;
        static moveConnectionDataToResource(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare module Stimulsoft.Designer {
    class StiEmptyObject {
    }
}
declare module Stimulsoft.Designer {
    class StiEncodingHelper {
        static decodeString(str: string): string;
        static encode(str: string): string;
    }
}
declare module Stimulsoft.Designer {
    class StiFontNames {
        private static item(value, key);
        static getItems(): any[];
    }
}
import StiReport = Stimulsoft.Report.StiReport;
import StiResource = Stimulsoft.Report.Dictionary.StiResource;
import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
declare module Stimulsoft.Designer {
    class StiFontResourceHelper {
        static addFontToReport(report: StiReport, resource: StiResource, resourceItem: any): void;
        static getBase64DataForCssFromResourceContent(resourceType: StiResourceType, content: number[]): string;
    }
}
declare module Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiVariable = Stimulsoft.Report.Dictionary.StiVariable;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiResource = Stimulsoft.Report.Dictionary.StiResource;
    class StiGalleriesHelper {
        static getImageColumns(report: StiReport): StiDataColumn[];
        static getImageVariables(report: StiReport): StiVariable[];
        static getImageResources(report: StiReport): StiResource[];
        static getRichTextColumns(report: StiReport): StiDataColumn[];
        static getRichTextVariables(report: StiReport): StiVariable[];
        static getRichTextResources(report: StiReport): StiResource[];
        static getImageFromColumn(column: StiDataColumn, report: StiReport): Image;
        static isRtfColumn(column: StiDataColumn, report: StiReport): boolean;
        static getRichTextAsHtmlFromColumn(column: StiDataColumn, report: StiReport): string;
        static getHtmlTextFromText(text: string): string;
        static getHtmlStringFromRichTextItem(report: StiReport, itemObject: any): string;
        private static getResource(report, resourceName);
        private static getVariable(report, variableName);
    }
}
declare module Stimulsoft.Designer {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiGroup extends StiContainer {
        toString2(application: string): string;
        static createFromString(text: string, application: string): StiGroup;
        static getSelectedComponents(isSelectedFinded: boolean, level: number, cont: StiContainer, allComps: StiComponentsCollection, lists: Hashtable): StiComponentsCollection;
        static getGroupFromPage(page: StiPage): StiGroup;
        private static resetSelection(cont);
        private static getAllComps(comps);
        insertIntoPage(page: StiPage): StiComponentsCollection;
        constructor();
    }
}
declare module Stimulsoft.Designer {
    class StiHatchStyles {
        private static item(value, key);
        static getItems(): any[];
    }
}
declare module Stimulsoft.Designer {
    class StiIconSetArrays {
        static getItems(): any;
    }
}
declare module Stimulsoft.Designer {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiInsertionComponents {
        static insertGroups(currentPage: StiPage, group: StiGroup): void;
        static insertComponents(currentPage: StiPage, comps: StiComponentsCollection, alignToGrid?: boolean): void;
        static insert(currentPage: StiPage, alignToGrid?: boolean): void;
    }
}
declare module Stimulsoft.Designer {
    import StiMap = Stimulsoft.Report.Maps.StiMap;
    class StiMapHelper {
        static getMapProperties(map: StiMap): any;
        static setMapProperties(report: StiReport, param: any, callbackResult: any): void;
        static updateMapData(report: StiReport, param: any, callbackResult: any): void;
        static getMapDataForJS(map: StiMap): any[];
        private static allowGroup(map);
        private static allowColor(map);
        static getStyle(map: StiMap): any;
        private static getMapStyles(report);
        static getMapSampleImage(map: StiMap, width: number, height: number, zoom: number): string;
        static setMapStyle(report: StiReport, param: any, callbackResult: any): void;
        static getStylesContent(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare module Stimulsoft.Designer {
    class StiPaperSizes {
        static getItems(): any[];
    }
}
declare module Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiPreviewHelper {
        static getPages(report: StiReport, pageNumber: number, zoom: number, designerId: string): any[];
        private static renderReportPage(service, report, pageIndex, zoom);
        private static renderPageParameters(report, pageNumber, zoom);
    }
}
declare module Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiReportCheckHelper {
        private static checkItem(check);
        private static checkActionItem(action);
        private static getActions(check);
        private static removeCheck(check, checks);
        private static getChecksJSCollection(checks);
        private static updateCurrentReport(designer, report, parameters, callbackResult);
        private static createImage(check, refPixelElement, refPixelHighlightedElement);
        private static getErrorsCount(checks);
        private static buildReportRenderingMessages(report, checks);
        static checkReport(designer: StiDesigner, report: StiReport, parameters: any, callbackResult: any, callbackFunc: any): void;
        static getCheckPreview(designer: StiDesigner, report: StiReport, parameters: any, callbackResult: any): void;
        static actionCheck(designer: StiDesigner, report: StiReport, parameters: any, callbackResult: any): void;
        static checkExpression(report: StiReport, parameters: any, callbackResult: any): void;
    }
}
declare module Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
    class StiResourcesHelper {
        static getReportThumbnailParameters(report: StiReport, zoom: number): string;
        static getHtmlColor(color: Color): string;
        static isPackedFile(content: number[]): boolean;
        static getStringContentForJSFromResourceContent(resourceType: StiResourceType, content: number[]): string;
        static getResourceContent(report: StiReport, param: any, callbackResult: any): void;
        static getResourceText(report: StiReport, param: any, callbackResult: any): void;
        static setResourceText(report: StiReport, param: any, callbackResult: any): void;
        static getResourceViewData(report: StiReport, param: any, callbackResult: any): void;
        static isFontResourceType(resourceType: StiResourceType): boolean;
    }
}
declare module Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiShapeHelper {
        static getShapeSampleImage(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare module Stimulsoft.Designer {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiStyleConditionsCollection = Stimulsoft.Report.Styles.Conditions.StiStyleConditionsCollection;
    import StiStyleCondition = Stimulsoft.Report.Styles.Conditions.StiStyleCondition;
    class StiStylesHelper {
        private static getStyleProperties(style);
        static styleItem(style: StiBaseStyle): any;
        static setConditionTypeProperty(styleCondition: StiStyleCondition, propertyValue: string): void;
        static setLocationProperty(styleCondition: StiStyleCondition, propertyValue: string): void;
        static setComponentTypeProperty(styleCondition: StiStyleCondition, propertyValue: string): void;
        static setPlacementProperty(styleCondition: StiStyleCondition, propertyValue: string): void;
        static setStyleConditionsProprty(style: StiBaseStyle, conditions: any[]): void;
        static getStyleConditionsProprty(conditions: StiStyleConditionsCollection): any[];
        static getStyles(report: StiReport): any[];
        private static generateNewName(report, newStyle);
        static applyStyleProperties(style: StiBaseStyle, properties: any): void;
        static writeStylesToReport(report: StiReport, stylesCollection: any[]): void;
        static getColorsCollectionProperty(colors: Color[]): any[];
        static setColorsCollectionProperty(style: StiBaseStyle, colorsString: any[]): void;
        static updateStyles(report: StiReport, param: any, callbackResult: any): void;
        static addStyle(report: StiReport, param: any, callbackResult: any): void;
        static createStyleCollection(report: StiReport, param: any, callbackResult: any): void;
        static createStylesFromComponents(report: StiReport, param: any, callbackResult: any): void;
        static openStyle(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare module Stimulsoft.Designer {
    import StiTable = Stimulsoft.Report.Components.Table.StiTable;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiTableHelper {
        private table;
        private zoom;
        executeJSCommand(parameters: Hashtable, callbackResult: Hashtable): void;
        private getFirstIndexX(selectedComponents);
        private getLastIndexX(selectedComponents);
        private getFirstIndexY(selectedComponents);
        private getLastIndexY(selectedComponents);
        private joinCells(selectedComponents);
        private setSelectedCurrentCells(cellsNames);
        private getSelectedCellNames();
        private getSelectedCellsByNames(cellsNames);
        static getTableStyles(): any[];
        static getTableCellsProperties(table: StiTable, zoom: number): any[];
        private getTableCellsForJS();
        private convertTableCell(parameters, result);
        constructor(table: StiTable, zoom: number);
    }
}
declare module Stimulsoft.Designer {
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiGeneralFormatService = Stimulsoft.Report.Components.TextFormats.StiGeneralFormatService;
    import StiNumberFormatService = Stimulsoft.Report.Components.TextFormats.StiNumberFormatService;
    import StiCurrencyFormatService = Stimulsoft.Report.Components.TextFormats.StiCurrencyFormatService;
    import StiDateFormatService = Stimulsoft.Report.Components.TextFormats.StiDateFormatService;
    import StiTimeFormatService = Stimulsoft.Report.Components.TextFormats.StiTimeFormatService;
    import StiPercentageFormatService = Stimulsoft.Report.Components.TextFormats.StiPercentageFormatService;
    import StiBooleanFormatService = Stimulsoft.Report.Components.TextFormats.StiBooleanFormatService;
    import StiCustomFormatService = Stimulsoft.Report.Components.TextFormats.StiCustomFormatService;
    class StiTextFormatHelper {
        static commonTextFormatItem(service: StiFormatService): any;
        static generalTextFormatItem(service: StiGeneralFormatService): any;
        static numberTextFormatItem(service: StiNumberFormatService): any;
        static currencyTextFormatItem(service: StiCurrencyFormatService): any;
        static dateTextFormatItem(service: StiDateFormatService): any;
        static timeTextFormatItem(service: StiTimeFormatService): any;
        static percentageTextFormatItem(service: StiPercentageFormatService): any;
        static booleanTextFormatItem(service: StiBooleanFormatService): any;
        static customTextFormatItem(service: StiCustomFormatService): any;
        private static getStateProperty(propertyValue);
        static getCurrencySymbols(): string[];
        static getFormatService(properties: any): StiFormatService;
        static getTextFormatItem(service: StiFormatService): any;
        static getDateAndTimeFormats(category: string, service: StiFormatService): any[];
        static getTextFormatItems(): any;
    }
}
declare module Stimulsoft.Designer {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import Promise = Stimulsoft.System.Promise;
    class StiViewDataHelper {
        resultDataTable: DataTable;
        dataSource: StiDataSource;
        private businessObject;
        private fillLevel2(businessObject, tempTable);
        private fillLevel4(index, list, businessObject, tempTable);
        buildAsync(): Promise<void>;
        constructor(dataSource: StiDataSource, businessObject?: StiBusinessObject);
    }
}
declare module Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiWizardHelper {
        private static getGroupsFromDataSource(dataSourceName, dataSources);
        private static getColumnsFromDataSource(dataSourceName, dataSources);
        private static getSortFromDataSource(dataSourceName, dataSources);
        private static getFiltersFromDataSource(dataSourceName, dataSources);
        private static getTotalsFromDataSource(dataSourceName, dataSources);
        private static alignToMaxGrid(page, value, converted);
        private static alignToGrid(page, value, converted);
        static getReportFromWizardOptions(createdReport: StiReport, reportOptions: any, wizardDataSources: any): StiReport;
    }
}
declare module Stimulsoft.Designer {
    enum StiImagesID {
        BusinessObject = 0,
        CalcColumn = 1,
        CalcColumnBinary = 2,
        CalcColumnBool = 3,
        CalcColumnChar = 4,
        CalcColumnDateTime = 5,
        CalcColumnDecimal = 6,
        CalcColumnFloat = 7,
        CalcColumnImage = 8,
        CalcColumnInt = 9,
        CalcColumnString = 10,
        Class = 11,
        Close = 12,
        ColumnsOrder = 13,
        Connection = 14,
        ConnectionFail = 15,
        DataColumn = 16,
        DataColumnBinary = 17,
        DataColumnBool = 18,
        DataColumnChar = 19,
        DataColumnDateTime = 20,
        DataColumnDecimal = 21,
        DataColumnFloat = 22,
        DataColumnImage = 23,
        DataColumnInt = 24,
        DataColumnString = 25,
        DataSource = 26,
        DataSources = 27,
        DataStore = 28,
        DataTable = 29,
        DataTables = 30,
        Folder = 31,
        Format = 32,
        FormatBoolean = 33,
        FormatCurrency = 34,
        FormatDate = 35,
        FormatGeneral = 36,
        FormatNumber = 37,
        FormatPercentage = 38,
        FormatTime = 39,
        Function = 40,
        HtmlTag = 41,
        LabelType = 42,
        LockedCalcColumn = 43,
        LockedCalcColumnBinary = 44,
        LockedCalcColumnBool = 45,
        LockedCalcColumnChar = 46,
        LockedCalcColumnDateTime = 47,
        LockedCalcColumnDecimal = 48,
        LockedCalcColumnFloat = 49,
        LockedCalcColumnImage = 50,
        LockedCalcColumnInt = 51,
        LockedCalcColumnString = 52,
        LockedConnection = 53,
        LockedDataColumn = 54,
        LockedDataColumnBinary = 55,
        LockedDataColumnBool = 56,
        LockedDataColumnChar = 57,
        LockedDataColumnDateTime = 58,
        LockedDataColumnDecimal = 59,
        LockedDataColumnFloat = 60,
        LockedDataColumnImage = 61,
        LockedDataColumnInt = 62,
        LockedDataColumnString = 63,
        LockedDataSource = 64,
        LockedFolder = 65,
        LockedParameter = 66,
        LockedRelation = 67,
        LockedVariable = 68,
        LockedVariableBinary = 69,
        LockedVariableBool = 70,
        LockedVariableChar = 71,
        LockedVariableDateTime = 72,
        LockedVariableDecimal = 73,
        LockedVariableFloat = 74,
        LockedVariableImage = 75,
        LockedVariableInt = 76,
        LockedVariableString = 77,
        Namespace = 78,
        Parameter = 79,
        Property = 80,
        Queries = 81,
        Query = 82,
        RecentConnection = 83,
        Relation = 84,
        StoredProcedure = 85,
        StoredProcedures = 86,
        SystemVariable = 87,
        SystemVariableColumn = 88,
        SystemVariableGroupLine = 89,
        SystemVariableIsFirstPage = 90,
        SystemVariableIsFirstPageThrough = 91,
        SystemVariableIsLastPage = 92,
        SystemVariableIsLastPageThrough = 93,
        SystemVariableLine = 94,
        SystemVariableLineABC = 95,
        SystemVariableLineRoman = 96,
        SystemVariableLineThrough = 97,
        SystemVariablePageNofM = 98,
        SystemVariablePageNofMThrough = 99,
        SystemVariablePageNumber = 100,
        SystemVariablePageNumberThrough = 101,
        SystemVariableReportAlias = 102,
        SystemVariableReportAuthor = 103,
        SystemVariableReportChanged = 104,
        SystemVariableReportCreated = 105,
        SystemVariableReportDescription = 106,
        SystemVariableReportName = 107,
        SystemVariables = 108,
        SystemVariableTime = 109,
        SystemVariableToday = 110,
        SystemVariableTotalPageCount = 111,
        SystemVariableTotalPageCountThrough = 112,
        UndefinedConnection = 113,
        UndefinedDataSource = 114,
        Variable = 115,
        VariableBinary = 116,
        VariableBool = 117,
        VariableChar = 118,
        VariableDateTime = 119,
        VariableDecimal = 120,
        VariableFloat = 121,
        VariableImage = 122,
        VariableInt = 123,
        VariableString = 124,
        View = 125,
        Views = 126,
        LockedVariableListBool = 127,
        LockedVariableListChar = 128,
        LockedVariableListDateTime = 129,
        LockedVariableListDecimal = 130,
        LockedVariableListFloat = 131,
        LockedVariableListImage = 132,
        LockedVariableListInt = 133,
        LockedVariableListString = 134,
        LockedVariableRangeChar = 135,
        LockedVariableRangeDateTime = 136,
        LockedVariableRangeDecimal = 137,
        LockedVariableRangeFloat = 138,
        LockedVariableRangeInt = 139,
        LockedVariableRangeString = 140,
        VariableListBool = 141,
        VariableListChar = 142,
        VariableListDateTime = 143,
        VariableListDecimal = 144,
        VariableListFloat = 145,
        VariableListImage = 146,
        VariableListInt = 147,
        VariableListString = 148,
        VariableRangeChar = 149,
        VariableRangeDateTime = 150,
        VariableRangeDecimal = 151,
        VariableRangeFloat = 152,
        VariableRangeInt = 153,
        VariableRangeString = 154,
    }
    enum StiDesignerPermissions {
        /** Deny all. */
        None = 0,
        /** Allows to create an item. */
        Create = 1,
        /** Allows to delete an item. */
        Delete = 2,
        /** Allows to modify an item. */
        Modify = 4,
        /** Allows to view an item. */
        View = 8,
        /** Allows modify and view an item. */
        ModifyView = 12,
        /** Allow any action with an item. */
        All = 15,
    }
    enum StiInterfaceType {
        Auto = 0,
        Mouse = 1,
        Touch = 2,
    }
    enum StiFirstDayOfWeek {
        Monday = 0,
        Sunday = 1,
    }
}
declare module Stimulsoft.Designer {
    import StiCheck = Stimulsoft.Report.Check.StiCheck;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiReportUnitType = Stimulsoft.Report.StiReportUnitType;
    import StiViewer = Stimulsoft.Viewer.StiViewer;
    class StiJsDesigner {
        options: any;
        loc: any;
        designer: StiDesigner;
        assignReport(report: StiReport): any;
        SendCommandUpdateCache(): any;
        SendCommandLoadReportToViewer(): any;
        SendCommandCloseViewer(): any;
        SendCommandOpenReport(fileContent: any, fileName: string, reportParams: any, filePath?: string): any;
        ExecuteCommandFromStack(): any;
        Sen(evt: any): any;
        ActionExitDesigner(): any;
        InitializeAboutPanel(): any;
        InitializeProcessImage(): any;
        InitializeErrorMessageForm(): any;
        ActionOpenReport(): any;
        SendCommandSaveStyle(stylesCollection: any[]): any;
        SendCommandSavePage(pageIndex: string): any;
        GetFontNamesItems(): any;
        AddCustomFontsCss(customFontsCss: string): any;
        InitializeSelectDataForm(func: any): any;
        InitializeImageForm(func: any): any;
        constructor(parameters: any);
    }
    class StiDesigner {
        private _renderAfterCreate;
        private viewState;
        undoLevel: number;
        private callbackResult;
        private viewerOptions;
        viewer: StiViewer;
        onBeginProcessData: Function;
        onEndProcessData: Function;
        onCreateReport: Function;
        onOpenReport: Function;
        onSaveReport: Function;
        onSaveAsReport: Function;
        onPreviewReport: Function;
        onExit: Function;
        onGetSubReport: Function;
        private _designerId;
        readonly designerId: string;
        private _options;
        readonly options: StiDesignerOptions;
        private _jsObject;
        readonly jsObject: StiJsDesigner;
        private _report;
        report: StiReport;
        private _reportGuid;
        reportGuid: string;
        private _renderedReport;
        renderedReport: StiReport;
        private _clipboardId;
        clipboardId: string;
        private _clipboard;
        clipboard: string;
        private _stylesClipboard;
        stylesClipboard: any;
        private _undoArrayId;
        undoArrayId: string;
        private _undoArray;
        undoArray: any[];
        private _componentCloneId;
        componentCloneId: string;
        private _componentClone;
        componentClone: any;
        private _reportCheckers;
        reportCheckers: StiCheck[];
        defaultUnit: StiReportUnitType;
        private _visible;
        visible: boolean;
        private _element;
        renderHtml(element?: string | HTMLElement): void;
        private invokeBeginProcessData(args, callback);
        private invokeEndProcessData(args);
        private invokeOnGetSubReport(args);
        private invokeCreateReport(report, isWizardUsed, callback);
        private invokeOpenReport();
        private invokeSaveReport(report);
        private invokeSaveAsReport(report);
        private invokePreviewReport(report, callback);
        private invokeExit();
        private copyReportDictionary(reportFrom, reportTo);
        private getNewReport();
        private getReportFileName();
        private static asyncPromise;
        private raiseCallbackEventAsync(onResult, param);
        constructor(options?: StiDesignerOptions, designerId?: string, renderAfterCreate?: boolean);
    }
}
declare module Stimulsoft.Designer {
    import StiViewerOptions = Stimulsoft.Viewer.StiViewerOptions;
    class StiDesignerOptions {
        /** A class which controls settings of the designer appearance. */
        appearance: StiAppearanceOptions;
        /** A class which controls settings of the designer toolbar. */
        toolbar: StiToolbarOptions;
        /** A class which controls settings of the bands. */
        bands: StiBandsOptions;
        /** A class which controls settings of the cross-bands. */
        crossBands: StiCrossBandsOptions;
        /** A class which controls settings of the components. */
        components: StiComponentsOptions;
        /** A class which controls settings of the dictionary. */
        dictionary: StiDictionaryOptions;
        /** Gets or sets the width of the designer. */
        width: string;
        /** Gets or sets the height of the designer. */
        height: string;
        viewerOptions: StiViewerOptions;
        mobileDesignerId: string;
        private productVersion;
        toParameters(): Object;
        private serializeObject(fromObject, toObject);
    }
}
